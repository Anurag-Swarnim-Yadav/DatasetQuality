Unnamed: 0,source,target,cwe_id
1,"CWE-119 static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index , <S2SV_StartBug> int_mv * ref_mv , <S2SV_EndBug> int_mv * second_ref_mv , int64_t comp_pred_diff [ REFERENCE_MODES ] , <S2SV_StartBug> int64_t tx_size_diff [ TX_MODES ] , <S2SV_EndBug> <S2SV_StartBug> int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ) { <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; ctx -> skip = x -> skip ; <S2SV_StartBug> ctx -> best_mode_index = mode_index ; <S2SV_EndBug> ctx -> mic = * xd -> mi [ 0 ] ; <S2SV_StartBug> ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ; <S2SV_EndBug> ctx -> best_ref_mv [ 1 ] . as_int = second_ref_mv -> as_int ; ctx -> single_pred_diff = ( int ) comp_pred_diff [ SINGLE_REFERENCE ] ; ctx -> comp_pred_diff = ( int ) comp_pred_diff [ COMPOUND_REFERENCE ] ; ctx -> hybrid_pred_diff = ( int ) comp_pred_diff [ REFERENCE_MODE_SELECT ] ; <S2SV_StartBug> vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ; <S2SV_EndBug> vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ; }
","<S2SV_ModStart> int mode_index , <S2SV_ModEnd> int64_t comp_pred_diff [ <S2SV_ModStart> ] , int64_t <S2SV_ModEnd> best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS <S2SV_ModStart> [ SWITCHABLE_FILTER_CONTEXTS ] , int skippable <S2SV_ModStart> ; ctx -> skippable = skippable ; ctx -> <S2SV_ModStart> ; ctx -> mbmi_ext = * x -> mbmi_ext <S2SV_ModEnd> ; ctx -> <S2SV_ModStart> REFERENCE_MODE_SELECT ] ; memcpy <S2SV_ModEnd> ( ctx ->
",CWE-119
2,"CWE-125 static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { ""invalid"" , ""rsasig"" , ""shared-secret"" , ""dsssig"" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , "")<S2SV_blank>"" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
","<S2SV_ModStart> int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
",CWE-125
3,"CWE-119 void vp9_encode_frame ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; if ( ! frame_is_intra_only ( cm ) ) { if ( ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) || ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ LAST_FRAME ] ) ) { <S2SV_StartBug> cm -> allow_comp_inter_inter = 0 ; <S2SV_EndBug> } else { <S2SV_StartBug> cm -> allow_comp_inter_inter = 1 ; <S2SV_EndBug> cm -> comp_fixed_ref = ALTREF_FRAME ; cm -> comp_var_ref [ 0 ] = LAST_FRAME ; cm -> comp_var_ref [ 1 ] = GOLDEN_FRAME ; } } if ( cpi -> sf . frame_parameter_update ) { <S2SV_StartBug> int i ; <S2SV_EndBug> const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ; <S2SV_StartBug> const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter ) <S2SV_EndBug> cm -> reference_mode = SINGLE_REFERENCE ; <S2SV_StartBug> else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] && <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ COMPOUND_REFERENCE ] > <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ REFERENCE_MODE_SELECT ] && <S2SV_EndBug> check_dual_ref_flags ( cpi ) && cpi -> static_mb_pct == 100 ) cm -> reference_mode = COMPOUND_REFERENCE ; <S2SV_StartBug> else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] ) <S2SV_EndBug> cm -> reference_mode = SINGLE_REFERENCE ; else cm -> reference_mode = REFERENCE_MODE_SELECT ; <S2SV_StartBug> if ( cm -> interp_filter == SWITCHABLE ) { <S2SV_EndBug> if ( frame_type != ALTREF_FRAME && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP_SHARP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ SWITCHABLE - 1 ] ) { <S2SV_StartBug> cm -> interp_filter = EIGHTTAP_SMOOTH ; <S2SV_EndBug> } else if ( filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP_SHARP ; } else if ( filter_thresh [ EIGHTTAP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP ; } } encode_frame_internal ( cpi ) ; <S2SV_StartBug> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ; <S2SV_EndBug> cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] >>= 1 ; } <S2SV_StartBug> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ; <S2SV_EndBug> cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ; <S2SV_StartBug> } <S2SV_EndBug> for ( i = 0 ; i < TX_MODES ; ++ i ) { int64_t pd = cpi -> rd_tx_select_diff [ i ] ; int diff ; if ( i == TX_MODE_SELECT ) pd -= RDCOST ( cpi -> mb . rdmult , cpi -> mb . rddiv , 2048 * ( TX_SIZES - 1 ) , 0 ) ; diff = ( int ) ( pd / cm -> MBs ) ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] /= 2 ; } if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { int single_count_zero = 0 ; int comp_count_zero = 0 ; for ( i = 0 ; i < COMP_INTER_CONTEXTS ; i ++ ) { <S2SV_StartBug> single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ; <S2SV_EndBug> } if ( comp_count_zero == 0 ) { cm -> reference_mode = SINGLE_REFERENCE ; <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> } else if ( single_count_zero == 0 ) { cm -> reference_mode = COMPOUND_REFERENCE ; <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> } } if ( cm -> tx_mode == TX_MODE_SELECT ) { int count4x4 = 0 ; int count8x8_lp = 0 , count8x8_8x8p = 0 ; int count16x16_16x16p = 0 , count16x16_lp = 0 ; int count32x32 = 0 ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; ++ i ) { <S2SV_StartBug> count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ; <S2SV_EndBug> } if ( count4x4 == 0 && count16x16_lp == 0 && count16x16_16x16p == 0 && count32x32 == 0 ) { cm -> tx_mode = ALLOW_8X8 ; <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_8X8 ) ; <S2SV_EndBug> } else if ( count8x8_8x8p == 0 && count16x16_16x16p == 0 && count8x8_lp == 0 && count16x16_lp == 0 && count32x32 == 0 ) { cm -> tx_mode = ONLY_4X4 ; <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_4X4 ) ; <S2SV_EndBug> } else if ( count8x8_lp == 0 && count16x16_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_32X32 ; } else if ( count32x32 == 0 && count8x8_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_16X16 ; <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_16X16 ) ; <S2SV_EndBug> } } } else { cm -> reference_mode = SINGLE_REFERENCE ; <S2SV_StartBug> cm -> interp_filter = SWITCHABLE ; <S2SV_EndBug> encode_frame_internal ( cpi ) ; } }
","<S2SV_ModStart> ) ) { cpi <S2SV_ModEnd> -> allow_comp_inter_inter = <S2SV_ModStart> } else { cpi <S2SV_ModEnd> -> allow_comp_inter_inter = <S2SV_ModStart> { int i ; RD_OPT * const rd_opt = & cpi -> rd ; FRAME_COUNTS * counts = cpi -> td . counts ; RD_COUNTS * const rdc = & cpi -> td . rd_counts <S2SV_ModStart> cpi ) ; int64_t * const mode_thrs = rd_opt -> prediction_type_threshes <S2SV_ModEnd> [ frame_type ] <S2SV_ModStart> frame_type ] ; int64_t * const filter_thrs = rd_opt -> filter_threshes <S2SV_ModEnd> [ frame_type ] <S2SV_ModStart> frame_type ] ; const int is_alt_ref = <S2SV_ModEnd> frame_type == ALTREF_FRAME <S2SV_ModStart> frame_type == ALTREF_FRAME ; if ( is_alt_ref || ! cpi <S2SV_ModEnd> -> allow_comp_inter_inter ) <S2SV_ModStart> else if ( mode_thrs <S2SV_ModEnd> [ COMPOUND_REFERENCE ] <S2SV_ModStart> COMPOUND_REFERENCE ] > mode_thrs <S2SV_ModEnd> [ SINGLE_REFERENCE ] <S2SV_ModStart> SINGLE_REFERENCE ] && mode_thrs <S2SV_ModEnd> [ COMPOUND_REFERENCE ] <S2SV_ModStart> COMPOUND_REFERENCE ] > mode_thrs <S2SV_ModEnd> [ REFERENCE_MODE_SELECT ] <S2SV_ModStart> else if ( mode_thrs <S2SV_ModEnd> [ SINGLE_REFERENCE ] <S2SV_ModStart> SINGLE_REFERENCE ] > mode_thrs <S2SV_ModEnd> [ REFERENCE_MODE_SELECT ] <S2SV_ModStart> == SWITCHABLE ) <S2SV_ModEnd> cm -> interp_filter <S2SV_ModStart> -> interp_filter = get_interp_filter ( filter_thrs , is_alt_ref ) ; <S2SV_ModEnd> encode_frame_internal ( cpi <S2SV_ModStart> ++ i ) mode_thrs [ i ] = ( mode_thrs [ i ] + rdc -> comp_pred_diff <S2SV_ModEnd> [ i ] <S2SV_ModStart> -> MBs ) / 2 ; <S2SV_ModEnd> for ( i <S2SV_ModStart> < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_thrs [ i ] = ( filter_thrs [ i ] + rdc -> filter_diff <S2SV_ModEnd> [ i ] <S2SV_ModStart> cm -> MBs <S2SV_ModEnd> ) / 2 <S2SV_ModStart> / 2 ; <S2SV_ModEnd> if ( cm <S2SV_ModStart> { single_count_zero += counts -> <S2SV_ModEnd> comp_inter [ i <S2SV_ModStart> ; comp_count_zero += counts -> <S2SV_ModEnd> comp_inter [ i <S2SV_ModStart> ; vp9_zero ( counts -> <S2SV_ModEnd> comp_inter ) ; <S2SV_ModStart> ; vp9_zero ( counts -> <S2SV_ModEnd> comp_inter ) ; <S2SV_ModStart> { count4x4 += counts -> <S2SV_ModEnd> tx . p32x32 <S2SV_ModStart> ; count4x4 += counts -> <S2SV_ModEnd> tx . p16x16 <S2SV_ModStart> ; count4x4 += counts -> <S2SV_ModEnd> tx . p8x8 <S2SV_ModStart> ; count8x8_lp += counts -> <S2SV_ModEnd> tx . p32x32 <S2SV_ModStart> ; count8x8_lp += counts -> <S2SV_ModEnd> tx . p16x16 <S2SV_ModStart> ; count8x8_8x8p += counts -> <S2SV_ModEnd> tx . p8x8 <S2SV_ModStart> ; count16x16_16x16p += counts -> <S2SV_ModEnd> tx . p16x16 <S2SV_ModStart> ; count16x16_lp += counts -> <S2SV_ModEnd> tx . p32x32 <S2SV_ModStart> ; count32x32 += counts -> <S2SV_ModEnd> tx . p32x32 <S2SV_ModStart> = ALLOW_8X8 ; reset_skip_tx_size <S2SV_ModEnd> ( cm , <S2SV_ModStart> = ONLY_4X4 ; reset_skip_tx_size <S2SV_ModEnd> ( cm , <S2SV_ModStart> = ALLOW_16X16 ; reset_skip_tx_size <S2SV_ModEnd> ( cm , <S2SV_ModStart> = SINGLE_REFERENCE ; <S2SV_ModEnd> encode_frame_internal ( cpi
",CWE-119
4,"CWE-787 int input_set_keycode ( struct input_dev * dev , const struct input_keymap_entry * ke ) { unsigned long flags ; unsigned int old_keycode ; int retval ; if ( ke -> keycode > KEY_MAX ) return - EINVAL ; spin_lock_irqsave ( & dev -> event_lock , flags ) ; retval = dev -> setkeycode ( dev , ke , & old_keycode ) ; if ( retval ) goto out ; __clear_bit ( KEY_RESERVED , dev -> keybit ) ; <S2SV_StartBug> if ( test_bit ( EV_KEY , dev -> evbit ) && <S2SV_EndBug> ! is_event_supported ( old_keycode , dev -> keybit , KEY_MAX ) && __test_and_clear_bit ( old_keycode , dev -> key ) ) { struct input_value vals [ ] = { { EV_KEY , old_keycode , 0 } , input_value_sync } ; input_pass_values ( dev , vals , ARRAY_SIZE ( vals ) ) ; } out : spin_unlock_irqrestore ( & dev -> event_lock , flags ) ; return retval ; }
","<S2SV_ModStart> keybit ) ; if ( old_keycode > KEY_MAX ) { dev_warn ( dev -> dev . parent ? : & dev -> dev , ""%s:<S2SV_blank>got<S2SV_blank>too<S2SV_blank>big<S2SV_blank>old<S2SV_blank>keycode<S2SV_blank>%#x\\n"" , __func__ , old_keycode ) ; } else
",CWE-787
7,"CWE-59 static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s"" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }
","<S2SV_ModStart> O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW
",CWE-59
9,"CWE-59 static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid ) { <S2SV_StartBug> FILE * fp = fopen ( dest_filename , ""w"" ) ; <S2SV_EndBug> if ( ! fp ) return false ; unsigned fd = 0 ; while ( fd <= 99999 ) { sprintf ( source_filename + source_base_ofs , ""fd/%u"" , fd ) ; char * name = malloc_readlink ( source_filename ) ; if ( ! name ) break ; fprintf ( fp , ""%u:%s\\n"" , fd , name ) ; free ( name ) ; sprintf ( source_filename + source_base_ofs , ""fdinfo/%u"" , fd ) ; fd ++ ; FILE * in = fopen ( source_filename , ""r"" ) ; if ( ! in ) continue ; char buf [ 128 ] ; while ( fgets ( buf , sizeof ( buf ) - 1 , in ) ) { char * eol = strchrnul ( buf , '\\n' ) ; eol [ 0 ] = '\\n' ; eol [ 1 ] = '\\0' ; fputs ( buf , fp ) ; } fclose ( in ) ; } const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( ""Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu"" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; } fclose ( fp ) ; return true ; }
","<S2SV_ModStart> ( dest_filename , ""wx"" <S2SV_ModEnd> ) ; if
",CWE-59
11,"CWE-362 void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) { struct kvm_pit * pit = vcpu -> kvm -> arch . vpit ; struct hrtimer * timer ; if ( ! kvm_vcpu_is_bsp ( vcpu ) || ! pit ) return ; timer = & pit -> pit_state . timer ; <S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> . timer ; mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> HRTIMER_MODE_ABS ) ; mutex_unlock ( & pit -> pit_state . lock ) ;
",CWE-362
12,"CWE-119 static void set_roi_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { unsigned int i ; <S2SV_StartBug> vpx_roi_map_t roi = { 0 } ; <S2SV_EndBug> roi . rows = ( cfg -> g_h + 15 ) / 16 ; roi . cols = ( cfg -> g_w + 15 ) / 16 ; roi . delta_q [ 0 ] = 0 ; roi . delta_q [ 1 ] = - 2 ; roi . delta_q [ 2 ] = - 4 ; roi . delta_q [ 3 ] = - 6 ; roi . delta_lf [ 0 ] = 0 ; roi . delta_lf [ 1 ] = 1 ; roi . delta_lf [ 2 ] = 2 ; roi . delta_lf [ 3 ] = 3 ; roi . static_threshold [ 0 ] = 1500 ; roi . static_threshold [ 1 ] = 1000 ; roi . static_threshold [ 2 ] = 500 ; roi . static_threshold [ 3 ] = 0 ; roi . roi_map = ( uint8_t * ) malloc ( roi . rows * roi . cols ) ; for ( i = 0 ; i < roi . rows * roi . cols ; ++ i ) roi . roi_map [ i ] = i % 4 ; if ( vpx_codec_control ( codec , VP8E_SET_ROI_MAP , & roi ) ) die_codec ( codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>ROI<S2SV_blank>map"" ) ; free ( roi . roi_map ) ; }
","<S2SV_ModStart> ; vpx_roi_map_t roi ; memset ( & roi , 0 , sizeof ( roi ) ) <S2SV_ModEnd> ; roi .
",CWE-119
13,"CWE-119 <S2SV_StartBug> static const char * parse_object ( cJSON * item , const char * value ) <S2SV_EndBug> { cJSON * child ; if ( * value != '{' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } item -> type = cJSON_Object ; value = skip ( value + 1 ) ; if ( * value == '}' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) ) <S2SV_EndBug> return 0 ; child -> string = child -> valuestring ; child -> valuestring = 0 ; if ( * value != ':' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; while ( * value == ',' ) { cJSON * new_item ; if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ; child -> next = new_item ; new_item -> prev = child ; <S2SV_StartBug> child = new_item ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; child -> string = child -> valuestring ; child -> valuestring = 0 ; if ( * value != ':' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; } if ( * value == '}' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> ep = value ; return 0 ; }
","<S2SV_ModStart> char * value , const char * * ep <S2SV_ModStart> '{' ) { * ep = value ; return 0 ; <S2SV_ModEnd> } item -> <S2SV_ModStart> == '}' ) return value + 1 ; <S2SV_ModEnd> item -> child <S2SV_ModStart> cJSON_New_Item ( ) ; if ( ! item -> child ) return 0 ; <S2SV_ModEnd> value = skip <S2SV_ModStart> ( value ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> ':' ) { * ep = value ; return 0 ; } <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> = child ; child = new_item ; <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> ':' ) { * ep = value ; return 0 ; } <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> == '}' ) return value + 1 ; * ep = value ; <S2SV_ModEnd> return 0 ;
",CWE-119
15,"CWE-190 static void addArgumentToVtab ( Parse * pParse ) { if ( pParse -> sArg . z && pParse -> pNewTable ) { const char * z = ( const char * ) pParse -> sArg . z ; int n = pParse -> sArg . n ; sqlite3 * db = pParse -> db ; <S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pParse ->
",CWE-190
18,"CWE-254 static int follow_dotdot_rcu ( struct nameidata * nd ) { struct inode * inode = nd -> inode ; if ( ! nd -> root . mnt ) set_root_rcu ( nd ) ; while ( 1 ) { if ( path_equal ( & nd -> path , & nd -> root ) ) break ; if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { struct dentry * old = nd -> path . dentry ; struct dentry * parent = old -> d_parent ; unsigned seq ; inode = parent -> d_inode ; seq = read_seqcount_begin ( & parent -> d_seq ) ; if ( unlikely ( read_seqcount_retry ( & old -> d_seq , nd -> seq ) ) ) return - ECHILD ; nd -> path . dentry = parent ; nd -> seq = seq ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { struct mount * mnt = real_mount ( nd -> path . mnt ) ; struct mount * mparent = mnt -> mnt_parent ; struct dentry * mountpoint = mnt -> mnt_mountpoint ; struct inode * inode2 = mountpoint -> d_inode ; unsigned seq = read_seqcount_begin ( & mountpoint -> d_seq ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( & mparent -> mnt == nd -> path . mnt ) break ; nd -> path . dentry = mountpoint ; nd -> path . mnt = & mparent -> mnt ; inode = inode2 ; nd -> seq = seq ; } } while ( unlikely ( d_mountpoint ( nd -> path . dentry ) ) ) { struct mount * mounted ; mounted = __lookup_mnt ( nd -> path . mnt , nd -> path . dentry ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( ! mounted ) break ; nd -> path . mnt = & mounted -> mnt ; nd -> path . dentry = mounted -> mnt . mnt_root ; inode = nd -> path . dentry -> d_inode ; nd -> seq = read_seqcount_begin ( & nd -> path . dentry -> d_seq ) ; } nd -> inode = inode ; return 0 ; }
","<S2SV_ModStart> = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
",CWE-254
23,"CWE-119 static void resize_multistep ( const uint8_t * const input , int length , uint8_t * output , int olength , uint8_t * buf ) { int steps ; if ( length == olength ) { <S2SV_StartBug> memcpy ( output , input , sizeof ( uint8_t ) * length ) ; <S2SV_EndBug> return ; } steps = get_down2_steps ( length , olength ) ; if ( steps > 0 ) { int s ; uint8_t * out = NULL ; uint8_t * tmpbuf = NULL ; uint8_t * otmp , * otmp2 ; int filteredlength = length ; if ( ! tmpbuf ) { tmpbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * length ) ; otmp = tmpbuf ; } else { otmp = buf ; } otmp2 = otmp + get_down2_length ( length , 1 ) ; for ( s = 0 ; s < steps ; ++ s ) { const int proj_filteredlength = get_down2_length ( filteredlength , 1 ) ; const uint8_t * const in = ( s == 0 ? input : out ) ; if ( s == steps - 1 && proj_filteredlength == olength ) out = output ; else out = ( s & 1 ? otmp2 : otmp ) ; if ( filteredlength & 1 ) down2_symodd ( in , filteredlength , out ) ; else down2_symeven ( in , filteredlength , out ) ; filteredlength = proj_filteredlength ; } if ( filteredlength != olength ) { interpolate ( out , filteredlength , output , olength ) ; } if ( tmpbuf ) free ( tmpbuf ) ; } else { interpolate ( input , length , output , olength ) ; } }
","<S2SV_ModStart> , sizeof ( output [ 0 ] <S2SV_ModEnd> ) * length
",CWE-119
27,"CWE-119 xmlChar * xmlStringLenDecodeEntities ( xmlParserCtxtPtr ctxt , const xmlChar * str , int len , int what , xmlChar end , xmlChar end2 , xmlChar end3 ) { xmlChar * buffer = NULL ; int buffer_size = 0 ; xmlChar * current = NULL ; xmlChar * rep = NULL ; const xmlChar * last ; xmlEntityPtr ent ; int c , l ; int nbchars = 0 ; if ( ( ctxt == NULL ) || ( str == NULL ) || ( len < 0 ) ) return ( NULL ) ; last = str + len ; if ( ( ( ctxt -> depth > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> depth > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; return ( NULL ) ; } buffer_size = XML_PARSER_BIG_BUFFER_SIZE ; buffer = ( xmlChar * ) xmlMallocAtomic ( buffer_size * sizeof ( xmlChar ) ) ; if ( buffer == NULL ) goto mem_error ; if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; while ( ( c != 0 ) && ( c != end ) && ( c != end2 ) && ( c != end3 ) ) { if ( c == 0 ) break ; if ( ( c == '&' ) && ( str [ 1 ] == '#' ) ) { int val = xmlParseStringCharRef ( ctxt , & str ) ; if ( val != 0 ) { COPY_BUF ( 0 , buffer , nbchars , val ) ; } if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else if ( ( c == '&' ) && ( what & XML_SUBSTITUTE_REF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""String<S2SV_blank>decoding<S2SV_blank>Entity<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , str ) ; ent = xmlParseStringEntityRef ( ctxt , & str ) ; if ( ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) || ( ctxt -> lastError . code == XML_ERR_INTERNAL_ERROR ) ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ( ent != NULL ) && ( ent -> etype == XML_INTERNAL_PREDEFINED_ENTITY ) ) { if ( ent -> content != NULL ) { COPY_BUF ( 0 , buffer , nbchars , ent -> content [ 0 ] ) ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else { xmlFatalErrMsg ( ctxt , XML_ERR_INTERNAL_ERROR , ""predefined<S2SV_blank>entity<S2SV_blank>has<S2SV_blank>no<S2SV_blank>content\\n"" ) ; } } else if ( ( ent != NULL ) && ( ent -> content != NULL ) ) { ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } else if ( ent != NULL ) { int i = xmlStrlen ( ent -> name ) ; const xmlChar * cur = ent -> name ; buffer [ nbchars ++ ] = '&' ; if ( nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE ) { <S2SV_StartBug> growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; <S2SV_EndBug> } for ( ; i > 0 ; i -- ) buffer [ nbchars ++ ] = * cur ++ ; buffer [ nbchars ++ ] = ';' ; } } else if ( c == '%' && ( what & XML_SUBSTITUTE_PEREF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""String<S2SV_blank>decoding<S2SV_blank>PE<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , str ) ; ent = xmlParseStringPEReference ( ctxt , & str ) ; if ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ent != NULL ) { if ( ent -> content == NULL ) { xmlLoadEntityContent ( ctxt , ent ) ; } ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } } else { COPY_BUF ( l , buffer , nbchars , c ) ; str += l ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; } buffer [ nbchars ] = 0 ; return ( buffer ) ; mem_error : xmlErrMemory ( ctxt , NULL ) ; int_error : if ( rep != NULL ) xmlFree ( rep ) ; if ( buffer != NULL ) xmlFree ( buffer ) ; return ( NULL ) ; }
","<S2SV_ModStart> ( buffer , i +
",CWE-119
31,"CWE-119 <S2SV_StartBug> void fdct16_8col ( __m128i * in ) { <S2SV_EndBug> __m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ; <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ; <S2SV_StartBug> const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ; <S2SV_EndBug> const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p28_p04 = pair_set_epi16 ( cospi_28_64 , cospi_4_64 ) ; const __m128i k__cospi_m04_p28 = pair_set_epi16 ( - cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p12_p20 = pair_set_epi16 ( cospi_12_64 , cospi_20_64 ) ; const __m128i k__cospi_m20_p12 = pair_set_epi16 ( - cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p30_p02 = pair_set_epi16 ( cospi_30_64 , cospi_2_64 ) ; const __m128i k__cospi_p14_p18 = pair_set_epi16 ( cospi_14_64 , cospi_18_64 ) ; const __m128i k__cospi_m02_p30 = pair_set_epi16 ( - cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_m18_p14 = pair_set_epi16 ( - cospi_18_64 , cospi_14_64 ) ; const __m128i k__cospi_p22_p10 = pair_set_epi16 ( cospi_22_64 , cospi_10_64 ) ; const __m128i k__cospi_p06_p26 = pair_set_epi16 ( cospi_6_64 , cospi_26_64 ) ; const __m128i k__cospi_m10_p22 = pair_set_epi16 ( - cospi_10_64 , cospi_22_64 ) ; const __m128i k__cospi_m26_p06 = pair_set_epi16 ( - cospi_26_64 , cospi_6_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; i [ 0 ] = _mm_add_epi16 ( in [ 0 ] , in [ 15 ] ) ; i [ 1 ] = _mm_add_epi16 ( in [ 1 ] , in [ 14 ] ) ; i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , in [ 13 ] ) ; i [ 3 ] = _mm_add_epi16 ( in [ 3 ] , in [ 12 ] ) ; i [ 4 ] = _mm_add_epi16 ( in [ 4 ] , in [ 11 ] ) ; i [ 5 ] = _mm_add_epi16 ( in [ 5 ] , in [ 10 ] ) ; i [ 6 ] = _mm_add_epi16 ( in [ 6 ] , in [ 9 ] ) ; i [ 7 ] = _mm_add_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 0 ] = _mm_sub_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 1 ] = _mm_sub_epi16 ( in [ 6 ] , in [ 9 ] ) ; s [ 2 ] = _mm_sub_epi16 ( in [ 5 ] , in [ 10 ] ) ; s [ 3 ] = _mm_sub_epi16 ( in [ 4 ] , in [ 11 ] ) ; s [ 4 ] = _mm_sub_epi16 ( in [ 3 ] , in [ 12 ] ) ; s [ 5 ] = _mm_sub_epi16 ( in [ 2 ] , in [ 13 ] ) ; s [ 6 ] = _mm_sub_epi16 ( in [ 1 ] , in [ 14 ] ) ; s [ 7 ] = _mm_sub_epi16 ( in [ 0 ] , in [ 15 ] ) ; p [ 0 ] = _mm_add_epi16 ( i [ 0 ] , i [ 7 ] ) ; p [ 1 ] = _mm_add_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 2 ] = _mm_add_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 3 ] = _mm_add_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 4 ] = _mm_sub_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 6 ] = _mm_sub_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 7 ] = _mm_sub_epi16 ( i [ 0 ] , i [ 7 ] ) ; u [ 0 ] = _mm_add_epi16 ( p [ 0 ] , p [ 3 ] ) ; u [ 1 ] = _mm_add_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 2 ] = _mm_sub_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 3 ] = _mm_sub_epi16 ( p [ 0 ] , p [ 3 ] ) ; v [ 0 ] = _mm_unpacklo_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 1 ] = _mm_unpackhi_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 2 ] = _mm_unpacklo_epi16 ( u [ 2 ] , u [ 3 ] ) ; v [ 3 ] = _mm_unpackhi_epi16 ( u [ 2 ] , u [ 3 ] ) ; u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ; u [ 1 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_p16 ) ; u [ 2 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ; u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_m16 ) ; u [ 4 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_p24_p08 ) ; u [ 5 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_p24_p08 ) ; u [ 6 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_m08_p24 ) ; u [ 7 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_m08_p24 ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; in [ 4 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; in [ 8 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; in [ 12 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 5 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 5 ] , p [ 6 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; u [ 0 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; u [ 1 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 0 ] = _mm_add_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 1 ] = _mm_sub_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 2 ] = _mm_sub_epi16 ( p [ 7 ] , u [ 1 ] ) ; t [ 3 ] = _mm_add_epi16 ( p [ 7 ] , u [ 1 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( t [ 1 ] , t [ 2 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( t [ 1 ] , t [ 2 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_p04 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_p04 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_p20 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_p20 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m20_p12 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m20_p12 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m04_p28 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m04_p28 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; in [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 10 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 14 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 3 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; p [ 0 ] = _mm_add_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 1 ] = _mm_add_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 2 ] = _mm_sub_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 3 ] = _mm_sub_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 4 ] = _mm_sub_epi16 ( s [ 7 ] , t [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 6 ] = _mm_add_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 7 ] = _mm_add_epi16 ( s [ 7 ] , t [ 4 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( p [ 2 ] , p [ 5 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( p [ 2 ] , p [ 5 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m08_p24 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m08_p24 ) ; <S2SV_StartBug> v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ; <S2SV_EndBug> v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_m08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m08_p24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m08_p24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ; <S2SV_StartBug> v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_EndBug> <S2SV_StartBug> u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; <S2SV_EndBug> u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 6 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; s [ 0 ] = _mm_add_epi16 ( p [ 0 ] , t [ 1 ] ) ; s [ 1 ] = _mm_sub_epi16 ( p [ 0 ] , t [ 1 ] ) ; <S2SV_StartBug> s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; <S2SV_EndBug> s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 6 ] = _mm_sub_epi16 ( p [ 7 ] , t [ 6 ] ) ; s [ 7 ] = _mm_add_epi16 ( p [ 7 ] , t [ 6 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p30_p02 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p30_p02 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p14_p18 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p14_p18 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p22_p10 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p22_p10 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p06_p26 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p06_p26 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m26_p06 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m26_p06 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m10_p22 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m10_p22 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m18_p14 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m18_p14 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m02_p30 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m02_p30 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; in [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 9 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 13 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; in [ 3 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; in [ 11 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; in [ 7 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; in [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t ) <S2SV_ModStart> ; const __m128i k__cospi_p08_m24 <S2SV_ModEnd> = pair_set_epi16 ( <S2SV_ModStart> = pair_set_epi16 ( cospi_8_64 , - cospi_24_64 <S2SV_ModEnd> ) ; const <S2SV_ModStart> 2 ] , <S2SV_ModEnd> k__cospi_p24_p08 ) ; <S2SV_ModStart> ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 <S2SV_ModEnd> ] , k__cospi_p24_p08 <S2SV_ModStart> k__cospi_p24_p08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_m24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_m24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_ModStart> 2 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; s [ 3 ] = <S2SV_ModStart> ; s [ 4 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 <S2SV_ModEnd> ] = _mm_add_epi16 <S2SV_ModStart> ] = _mm_add_epi16 <S2SV_ModEnd> ( p [
",CWE-119
32,"CWE-835 static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>syncword\\n"" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>streamid\\n"" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n"" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n"" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ; <S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\n"" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , ""header<S2SV_blank>too<S2SV_blank>short\\n"" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , ""audio<S2SV_blank>data<S2SV_blank>corruption\\n"" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }
","<S2SV_ModStart> ; if ( avio_feof ( pb ) ) { return AVERROR_EOF ; } if (
",CWE-835
39,"CWE-119 static vpx_codec_err_t validate_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg , const struct vp8_extracfg * vp8_cfg , int finalize ) { RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ; <S2SV_StartBug> RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ; <S2SV_EndBug> RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ; RANGE_CHECK_HI ( cfg , g_threads , 64 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # else RANGE_CHECK_HI ( cfg , g_lag_in_frames , 25 ) ; # endif RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ; RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ; RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ; # if CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , rc_resize_allowed , 0 ) ; # else RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ; # endif RANGE_CHECK_HI ( cfg , rc_dropframe_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_up_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_down_thresh , 100 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # else RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ; # endif if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( ""kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>"" ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ; RANGE_CHECK_BOOL ( vp8_cfg , enable_auto_alt_ref ) ; RANGE_CHECK ( vp8_cfg , cpu_used , - 16 , 16 ) ; # if CONFIG_REALTIME_ONLY && ! CONFIG_TEMPORAL_DENOISING RANGE_CHECK ( vp8_cfg , noise_sensitivity , 0 , 0 ) ; # else RANGE_CHECK_HI ( vp8_cfg , noise_sensitivity , 6 ) ; # endif RANGE_CHECK ( vp8_cfg , token_partitions , VP8_ONE_TOKENPARTITION , VP8_EIGHT_TOKENPARTITION ) ; RANGE_CHECK_HI ( vp8_cfg , Sharpness , 7 ) ; RANGE_CHECK ( vp8_cfg , arnr_max_frames , 0 , 15 ) ; RANGE_CHECK_HI ( vp8_cfg , arnr_strength , 6 ) ; RANGE_CHECK ( vp8_cfg , arnr_type , 1 , 3 ) ; <S2SV_StartBug> RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ; <S2SV_EndBug> if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cfg -> g_pass == VPX_RC_LAST_PASS ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; FIRSTPASS_STATS * stats ; if ( ! cfg -> rc_twopass_stats_in . buf ) ERROR ( ""rc_twopass_stats_in.buf<S2SV_blank>not<S2SV_blank>set."" ) ; if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) ERROR ( ""rc_twopass_stats_in.sz<S2SV_blank>indicates<S2SV_blank>truncated<S2SV_blank>packet."" ) ; if ( cfg -> rc_twopass_stats_in . sz < 2 * packet_sz ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets."" ) ; stats = ( void * ) ( ( char * ) cfg -> rc_twopass_stats_in . buf + ( n_packets - 1 ) * packet_sz ) ; if ( ( int ) ( stats -> count + 0.5 ) != n_packets - 1 ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ; } # endif RANGE_CHECK ( cfg , ts_number_layers , 1 , 5 ) ; if ( cfg -> ts_number_layers > 1 ) { unsigned int i ; RANGE_CHECK_HI ( cfg , ts_periodicity , 16 ) ; for ( i = 1 ; i < cfg -> ts_number_layers ; i ++ ) <S2SV_StartBug> if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] ) <S2SV_EndBug> ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ; RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ; for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; i -- ) if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; RANGE_CHECK_HI ( cfg , ts_layer_id [ i ] , cfg -> ts_number_layers - 1 ) ; } # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cfg -> g_threads > ( 1 << vp8_cfg -> token_partitions ) ) ERROR ( ""g_threads<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>number<S2SV_blank>of<S2SV_blank>token<S2SV_blank>partitions"" ) ; # endif return VPX_CODEC_OK ; }
","<S2SV_ModStart> , 1 , 1000000000 <S2SV_ModEnd> ) ; RANGE_CHECK_HI <S2SV_ModStart> 0 , 63 ) ; RANGE_CHECK_HI ( vp8_cfg , screen_content_mode , 2 <S2SV_ModStart> - 1 ] && cfg -> rc_target_bitrate > 0
",CWE-119
44,"CWE-20 TcpOption * tcpGetOption ( TcpHeader * segment , uint8_t kind ) { <S2SV_StartBug> size_t length ; <S2SV_EndBug> uint_t i ; TcpOption * option ; <S2SV_StartBug> if ( segment -> dataOffset < 5 ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> length = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ; <S2SV_EndBug> i = 0 ; while ( i < length ) { option = ( TcpOption * ) ( segment -> options + i ) ; <S2SV_StartBug> if ( option -> kind == TCP_OPTION_NOP ) <S2SV_EndBug> { i ++ ; <S2SV_StartBug> continue ; <S2SV_EndBug> } if ( option -> kind == TCP_OPTION_END ) break ; <S2SV_StartBug> if ( ( i + 1 ) >= length || ( i + option -> length ) > length ) <S2SV_EndBug> break ; if ( option -> kind == kind ) return option ; i += option -> length ; } <S2SV_StartBug> return NULL ; <S2SV_EndBug> }
","<S2SV_ModStart> ) { size_t i ; size_t length <S2SV_ModEnd> ; TcpOption * <S2SV_ModStart> segment -> dataOffset >= ( sizeof ( TcpHeader ) / 4 ) ) { length = ( <S2SV_ModEnd> segment -> dataOffset <S2SV_ModStart> dataOffset * 4 ) <S2SV_ModStart> -> kind == TCP_OPTION_END ) { break ; } else if ( option -> kind == <S2SV_ModStart> i ++ ; } else { <S2SV_ModEnd> if ( ( <S2SV_ModStart> ) >= length ) break ; if ( option -> length < sizeof ( TcpOption ) <S2SV_ModStart> length ; } } }
",CWE-20
45,"CWE-119 <S2SV_StartBug> double vp9_convert_qindex_to_q ( int qindex ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_ac_quant ( qindex , 0 ) / 4.0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ( int qindex , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> return vp9_ac_quant ( <S2SV_ModStart> qindex , 0 , bit_depth <S2SV_ModStart> / 4.0 ; case VPX_BITS_10 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 16.0 ; case VPX_BITS_12 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 64.0 ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return - 1.0 ; } # else return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ; # endif
",CWE-119
46,"CWE-125 void bit_write_MC ( Bit_Chain * dat , BITCODE_MC val ) { int i , j ; int negative = 0 ; unsigned char byte [ 5 ] ; BITCODE_UMC mask = 0x0000007f ; BITCODE_UMC value = ( BITCODE_UMC ) val ; if ( val < 0 ) { negative = 1 ; value = ( BITCODE_UMC ) - val ; } for ( i = 4 , j = 0 ; i >= 0 ; i -- , j += 7 ) { byte [ i ] = ( unsigned char ) ( ( value & mask ) >> j ) ; byte [ i ] |= 0x80 ; mask = mask << 7 ; } for ( i = 0 ; i < 4 ; i ++ ) if ( byte [ i ] & 0x7f ) break ; <S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug> i -- ; byte [ i ] &= 0x7f ; if ( negative ) byte [ i ] |= 0x40 ; for ( j = 4 ; j >= i ; j -- ) bit_write_RC ( dat , byte [ j ] ) ; }
","<S2SV_ModStart> ] & 0x40 && i > 0
",CWE-125
49,"CWE-000 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( num_mb_skip & 1 ) ) { num_mb_skip ++ ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = - 1 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) { if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) { if ( ps_dec -> ps_pps [ i ] . ps_sps -> u1_is_valid == TRUE ) { j = i ; break ; } } } if ( j == - 1 ) { <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> } if ( ps_dec -> u4_pic_buf_got == 0 ) { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } ps_dec -> u4_first_slice_in_pic = 0 ; } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { if ( ( u1_mbaff ) && ( ps_dec -> u4_num_mbs_cur_nmb & 1 ) ) { ps_dec -> u4_num_mbs_cur_nmb = ps_dec -> u4_num_mbs_cur_nmb - 1 ; ps_dec -> u2_cur_mb_addr -- ; } u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; if ( u1_num_mbs ) { ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } if ( ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice < ( UWORD32 ) ( ps_dec -> u2_total_mbs_coded >> ps_slice -> u1_mbaff_frame_flag ) ) { ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> ps_parse_cur_slice ++ ; } } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= u1_mbaff ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> ) { return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; } if
",CWE-000
54,"CWE-284 int main ( int argc , char * * argv ) { int error ; my_bool first_argument_uses_wildcards = 0 ; char * wild ; MYSQL mysql ; MY_INIT ( argv [ 0 ] ) ; my_getopt_use_args_separator = TRUE ; if ( load_defaults ( ""my"" , load_default_groups , & argc , & argv ) ) exit ( 1 ) ; my_getopt_use_args_separator = FALSE ; get_options ( & argc , & argv ) ; wild = 0 ; if ( argc ) { char * pos = argv [ argc - 1 ] , * to ; for ( to = pos ; * pos ; pos ++ , to ++ ) { switch ( * pos ) { case '*' : * pos = '%' ; first_argument_uses_wildcards = 1 ; break ; case '?' : * pos = '_' ; first_argument_uses_wildcards = 1 ; break ; case '%' : case '_' : first_argument_uses_wildcards = 1 ; break ; case '\\\\' : pos ++ ; default : break ; } * to = * pos ; } * to = * pos ; } if ( first_argument_uses_wildcards ) wild = argv [ -- argc ] ; else if ( argc == 3 ) wild = argv [ -- argc ] ; if ( argc > 2 ) { fprintf ( stderr , ""%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>arguments\\n"" , my_progname ) ; exit ( 1 ) ; } mysql_init ( & mysql ) ; if ( opt_compress ) mysql_options ( & mysql , MYSQL_OPT_COMPRESS , NullS ) ; <S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> if ( opt_use_ssl ) { mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( & mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ; # endif if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( & mysql , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif mysql_options ( & mysql , MYSQL_SET_CHARSET_NAME , default_charset ) ; if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql , MYSQL_OPT_CONNECT_ATTR_ADD , ""program_name"" , ""mysqlshow"" ) ; if ( ! ( mysql_real_connect ( & mysql , host , user , opt_password , ( first_argument_uses_wildcards ) ? """" : argv [ 0 ] , opt_mysql_port , opt_mysql_unix_port , 0 ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>%s\\n"" , my_progname , mysql_error ( & mysql ) ) ; exit ( 1 ) ; } mysql . reconnect = 1 ; switch ( argc ) { case 0 : error = list_dbs ( & mysql , wild ) ; break ; case 1 : if ( opt_status ) error = list_table_status ( & mysql , argv [ 0 ] , wild ) ; else error = list_tables ( & mysql , argv [ 0 ] , wild ) ; break ; default : if ( opt_status && ! wild ) error = list_table_status ( & mysql , argv [ 0 ] , argv [ 1 ] ) ; else error = list_fields ( & mysql , argv [ 0 ] , argv [ 1 ] , wild ) ; break ; } mysql_close ( & mysql ) ; my_free ( opt_password ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) my_free ( shared_memory_base_name ) ; # endif my_end ( my_end_arg ) ; exit ( error ? 1 : 0 ) ; return 0 ; }
","<S2SV_ModStart> NullS ) ; SSL_SET_OPTIONS ( & mysql ) ; <S2SV_ModEnd> if ( opt_protocol
",CWE-284
56,"CWE-20 error_t enc624j600SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; } <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ECON1 ) & ECON1_TXRTS ) <S2SV_EndBug> { return ERROR_FAILURE ; } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EGPWRPT , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> enc624j600WriteBuffer ( interface , ENC624J600_CMD_WGPDATA , buffer , offset ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXST , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_ECON1 ) & ENC624J600_ECON1_TXRTS <S2SV_ModEnd> ) { return <S2SV_ModStart> ( interface , ENC624J600_EGPWRPT <S2SV_ModEnd> , ENC624J600_TX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ETXST <S2SV_ModEnd> , ENC624J600_TX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ETXLEN <S2SV_ModEnd> , length ) <S2SV_ModStart> ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> ) ; enc624j600SetBit <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_TXRTS <S2SV_ModEnd> ) ; return
",CWE-20
57,"CWE-189 native_handle_t * native_handle_create ( int numFds , int numInts ) { <S2SV_StartBug> native_handle_t * h = malloc ( <S2SV_EndBug> <S2SV_StartBug> sizeof ( native_handle_t ) + sizeof ( int ) * ( numFds + numInts ) ) ; <S2SV_EndBug> if ( h ) { h -> version = sizeof ( native_handle_t ) ; h -> numFds = numFds ; h -> numInts = numInts ; } return h ; }
","<S2SV_ModStart> numInts ) { if ( numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts ) { return NULL ; } size_t mallocSize = <S2SV_ModEnd> sizeof ( native_handle_t <S2SV_ModStart> native_handle_t ) + ( <S2SV_ModStart> + numInts ) ) ; native_handle_t * h = malloc ( mallocSize
",CWE-189
58,"CWE-119 static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }
","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> x ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",CWE-119
59,"CWE-78 static inline int r_sys_mkdirp ( char * dir ) { int ret = 1 ; const char slash = DIRSEP ; char * path = dir ; char * ptr = path ; if ( * ptr == slash ) { ptr ++ ; } # if __SDB_WINDOWS__ char * p = strstr ( ptr , "":\\\\"" ) ; if ( p ) { <S2SV_StartBug> ptr = p + 2 ; <S2SV_EndBug> } # endif while ( ( ptr = strchr ( ptr , slash ) ) ) { * ptr = 0 ; if ( ! r_sys_mkdir ( path ) && r_sys_mkdir_failed ( ) ) { eprintf ( ""r_sys_mkdirp:<S2SV_blank>fail<S2SV_blank>\'%s\'<S2SV_blank>of<S2SV_blank>\'%s\'\\n"" , path , dir ) ; * ptr = slash ; return 0 ; } * ptr = slash ; ptr ++ ; } return ret ; }
","<S2SV_ModStart> = p + 3 <S2SV_ModEnd> ; } #
",CWE-78
60,"CWE-264 static int walk_pmd_range ( pud_t * pud , unsigned long addr , unsigned long end , struct mm_walk * walk ) { pmd_t * pmd ; unsigned long next ; int err = 0 ; pmd = pmd_offset ( pud , addr ) ; do { again : next = pmd_addr_end ( addr , end ) ; if ( pmd_none ( * pmd ) ) { if ( walk -> pte_hole ) err = walk -> pte_hole ( addr , next , walk ) ; if ( err ) break ; continue ; } if ( walk -> pmd_entry ) err = walk -> pmd_entry ( pmd , addr , next , walk ) ; if ( err ) break ; if ( ! walk -> pte_entry ) continue ; split_huge_page_pmd ( walk -> mm , pmd ) ; <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> goto again ; err = walk_pte_range ( pmd , addr , next , walk ) ; if ( err ) break ; } while ( pmd ++ , addr = next , addr != end ) ; return err ; }
","<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
",CWE-264
61,"CWE-254 IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; impeg2d_bit_stream_get ( ps_stream , 10 ) ; ps_dec -> e_pic_type = ( e_pic_type_t ) impeg2d_bit_stream_get ( ps_stream , 3 ) ; if ( ( ps_dec -> e_pic_type < I_PIC ) || ( ps_dec -> e_pic_type > D_PIC ) ) { impeg2d_next_code ( ps_dec , PICTURE_START_CODE ) ; return IMPEG2D_INVALID_PIC_TYPE ; } impeg2d_bit_stream_get ( ps_stream , 16 ) ; if ( ps_dec -> e_pic_type == P_PIC || ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_forw_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_back_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_back_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> u2_is_mpeg2 == 0 ) { ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ; } <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <S2SV_EndBug> { impeg2d_bit_stream_get ( ps_stream , 9 ) ; } impeg2d_bit_stream_get_bit ( ps_stream ) ; impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
","<S2SV_ModStart> ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset
",CWE-254
62,"CWE-119 vpx_codec_err_t vpx_codec_control_ ( vpx_codec_ctx_t * ctx , int ctrl_id , ... ) { vpx_codec_err_t res ; if ( ! ctx || ! ctrl_id ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv || ! ctx -> iface -> ctrl_maps ) res = VPX_CODEC_ERROR ; else { vpx_codec_ctrl_fn_map_t * entry ; res = VPX_CODEC_ERROR ; for ( entry = ctx -> iface -> ctrl_maps ; entry && entry -> fn ; entry ++ ) { if ( ! entry -> ctrl_id || entry -> ctrl_id == ctrl_id ) { va_list ap ; va_start ( ap , ctrl_id ) ; <S2SV_StartBug> res = entry -> fn ( ctx -> priv -> alg_priv , ctrl_id , ap ) ; <S2SV_EndBug> va_end ( ap ) ; break ; } } } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> -> fn ( ( vpx_codec_alg_priv_t * ) <S2SV_ModStart> ctx -> priv <S2SV_ModEnd> , ap )
",CWE-119
65,"CWE-125 static expr_ty ast_for_decorator ( struct compiling * c , const node * n ) { expr_ty d = NULL ; expr_ty name_expr ; REQ ( n , decorator ) ; REQ ( CHILD ( n , 0 ) , AT ) ; REQ ( RCHILD ( n , - 1 ) , NEWLINE ) ; name_expr = ast_for_dotted_name ( c , CHILD ( n , 1 ) ) ; if ( ! name_expr ) return NULL ; if ( NCH ( n ) == 3 ) { d = name_expr ; name_expr = NULL ; } else if ( NCH ( n ) == 5 ) { d = Call ( name_expr , NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( ! d ) return NULL ; name_expr = NULL ; } else { <S2SV_StartBug> d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ; <S2SV_EndBug> if ( ! d ) return NULL ; name_expr = NULL ; } return d ; }
","<S2SV_ModStart> ) , name_expr , true
",CWE-125
69,"CWE-119 static ssize_t bat_socket_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct socket_client * socket_client = file -> private_data ; struct socket_packet * socket_packet ; size_t packet_len ; int error ; if ( ( file -> f_flags & O_NONBLOCK ) && ( socket_client -> queue_len == 0 ) ) return - EAGAIN ; if ( ( ! buf ) || ( count < sizeof ( struct icmp_packet ) ) ) return - EINVAL ; if ( ! access_ok ( VERIFY_WRITE , buf , count ) ) return - EFAULT ; error = wait_event_interruptible ( socket_client -> queue_wait , socket_client -> queue_len ) ; if ( error ) return error ; spin_lock_bh ( & socket_client -> lock ) ; socket_packet = list_first_entry ( & socket_client -> queue_list , struct socket_packet , list ) ; list_del ( & socket_packet -> list ) ; socket_client -> queue_len -- ; spin_unlock_bh ( & socket_client -> lock ) ; <S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> packet_len = socket_packet -> icmp_len ; kfree ( socket_packet ) ; if ( error ) return - EFAULT ; return packet_len ; }
","<S2SV_ModStart> lock ) ; packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> -> icmp_packet , packet_len ) <S2SV_ModEnd> ; kfree (
",CWE-119
70,"CWE-787 static void rfbProcessClientNormalMessage ( rfbClientPtr cl ) { int n ; rfbClientToServerMsg msg ; char * str ; READ ( ( char * ) & msg , 1 ) switch ( msg . type ) { case rfbSetPixelFormat : READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetPixelFormatMsg - 1 ) cl -> format . bitsPerPixel = msg . spf . format . bitsPerPixel ; cl -> format . depth = msg . spf . format . depth ; cl -> format . bigEndian = ( msg . spf . format . bigEndian ? 1 : 0 ) ; cl -> format . trueColour = ( msg . spf . format . trueColour ? 1 : 0 ) ; cl -> format . redMax = Swap16IfLE ( msg . spf . format . redMax ) ; cl -> format . greenMax = Swap16IfLE ( msg . spf . format . greenMax ) ; cl -> format . blueMax = Swap16IfLE ( msg . spf . format . blueMax ) ; cl -> format . redShift = msg . spf . format . redShift ; cl -> format . greenShift = msg . spf . format . greenShift ; cl -> format . blueShift = msg . spf . format . blueShift ; cl -> readyForSetColourMapEntries = TRUE ; rfbSetTranslateFunction ( cl ) ; return ; case rfbFixColourMapEntries : READ ( ( ( char * ) & msg ) + 1 , sz_rfbFixColourMapEntriesMsg - 1 ) rfbLog ( ""rfbProcessClientNormalMessage:<S2SV_blank>FixColourMapEntries<S2SV_blank>unsupported\\n"" ) ; rfbCloseClient ( cl ) ; return ; case rfbSetEncodings : { int i ; CARD32 enc ; Bool firstFence = ! cl -> enableFence ; Bool firstCU = ! cl -> enableCU ; Bool firstGII = ! cl -> enableGII ; Bool logTightCompressLevel = FALSE ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetEncodingsMsg - 1 ) msg . se . nEncodings = Swap16IfLE ( msg . se . nEncodings ) ; cl -> preferredEncoding = - 1 ; cl -> useCopyRect = FALSE ; cl -> enableCursorShapeUpdates = FALSE ; cl -> enableCursorPosUpdates = FALSE ; cl -> enableLastRectEncoding = FALSE ; cl -> tightCompressLevel = TIGHT_DEFAULT_COMPRESSION ; cl -> tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP ; cl -> tightQualityLevel = - 1 ; cl -> imageQualityLevel = - 1 ; for ( i = 0 ; i < msg . se . nEncodings ; i ++ ) { READ ( ( char * ) & enc , 4 ) enc = Swap32IfLE ( enc ) ; switch ( enc ) { case rfbEncodingCopyRect : cl -> useCopyRect = TRUE ; break ; case rfbEncodingRaw : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>raw<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>rre<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingCoRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>CoRRE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingHextile : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>hextile<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingZlib : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>zlib<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingZRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>ZRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingZYWRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>ZYWRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingTight : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>tight<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingXCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( ""Enabling<S2SV_blank>X-style<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = FALSE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingRichCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( ""Enabling<S2SV_blank>full-color<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = TRUE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingPointerPos : if ( ! cl -> enableCursorPosUpdates ) { rfbLog ( ""Enabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorPosUpdates = TRUE ; cl -> cursorWasMoved = TRUE ; cl -> cursorX = - 1 ; cl -> cursorY = - 1 ; } break ; case rfbEncodingLastRect : if ( ! cl -> enableLastRectEncoding ) { rfbLog ( ""Enabling<S2SV_blank>LastRect<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableLastRectEncoding = TRUE ; } break ; case rfbEncodingFence : if ( ! cl -> enableFence ) { rfbLog ( ""Enabling<S2SV_blank>Fence<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableFence = TRUE ; } break ; case rfbEncodingContinuousUpdates : if ( ! cl -> enableCU ) { rfbLog ( ""Enabling<S2SV_blank>Continuous<S2SV_blank>Updates<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCU = TRUE ; } break ; case rfbEncodingNewFBSize : if ( ! cl -> enableDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( ""Enabling<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableDesktopSize = TRUE ; } else rfbLog ( ""WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\n"" ) ; } break ; case rfbEncodingExtendedDesktopSize : if ( ! cl -> enableExtDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( ""Enabling<S2SV_blank>Extended<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableExtDesktopSize = TRUE ; } else rfbLog ( ""WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\n"" ) ; } break ; case rfbEncodingGII : if ( ! cl -> enableGII ) { rfbLog ( ""Enabling<S2SV_blank>GII<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableGII = TRUE ; } break ; default : if ( enc >= ( CARD32 ) rfbEncodingCompressLevel0 && enc <= ( CARD32 ) rfbEncodingCompressLevel9 ) { cl -> zlibCompressLevel = enc & 0x0F ; cl -> tightCompressLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) logTightCompressLevel = TRUE ; else rfbLog ( ""Using<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightCompressLevel , cl -> host ) ; if ( rfbInterframe == - 1 ) { if ( cl -> tightCompressLevel >= 5 ) { if ( ! InterframeOn ( cl ) ) { rfbCloseClient ( cl ) ; return ; } } else InterframeOff ( cl ) ; } } else if ( enc >= ( CARD32 ) rfbEncodingSubsamp1X && enc <= ( CARD32 ) rfbEncodingSubsampGray ) { cl -> tightSubsampLevel = enc & 0xFF ; rfbLog ( ""Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightSubsampLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingQualityLevel0 && enc <= ( CARD32 ) rfbEncodingQualityLevel9 ) { cl -> tightQualityLevel = JPEG_QUAL [ enc & 0x0F ] ; cl -> tightSubsampLevel = JPEG_SUBSAMP [ enc & 0x0F ] ; cl -> imageQualityLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) rfbLog ( ""Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d,<S2SV_blank>Q%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightSubsampLevel , cl -> tightQualityLevel , cl -> host ) ; else rfbLog ( ""Using<S2SV_blank>image<S2SV_blank>quality<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> imageQualityLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingFineQualityLevel0 + 1 && enc <= ( CARD32 ) rfbEncodingFineQualityLevel100 ) { cl -> tightQualityLevel = enc & 0xFF ; rfbLog ( ""Using<S2SV_blank>JPEG<S2SV_blank>quality<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightQualityLevel , cl -> host ) ; } else { rfbLog ( ""rfbProcessClientNormalMessage:<S2SV_blank>ignoring<S2SV_blank>unknown<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>(%x)\\n"" , ( int ) enc , ( int ) enc ) ; } } } if ( cl -> preferredEncoding == - 1 ) cl -> preferredEncoding = rfbEncodingTight ; if ( cl -> preferredEncoding == rfbEncodingTight && logTightCompressLevel ) rfbLog ( ""Using<S2SV_blank>Tight<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , rfbTightCompressLevel ( cl ) , cl -> host ) ; if ( cl -> enableCursorPosUpdates && ! cl -> enableCursorShapeUpdates ) { rfbLog ( ""Disabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorPosUpdates = FALSE ; } if ( cl -> enableFence && firstFence ) { if ( ! rfbSendFence ( cl , rfbFenceFlagRequest , 0 , NULL ) ) return ; } if ( cl -> enableCU && cl -> enableFence && firstCU ) { if ( ! rfbSendEndOfCU ( cl ) ) return ; } if ( cl -> enableGII && firstGII ) { rfbGIIServerVersionMsg msg ; msg . type = rfbGIIServer ; msg . endianAndSubType = rfbGIIVersion | rfbGIIBE ; msg . length = Swap16IfLE ( sz_rfbGIIServerVersionMsg - 4 ) ; msg . maximumVersion = msg . minimumVersion = Swap16IfLE ( 1 ) ; if ( WriteExact ( cl , ( char * ) & msg , sz_rfbGIIServerVersionMsg ) < 0 ) { rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>write"" ) ; rfbCloseClient ( cl ) ; return ; } } return ; } case rfbFramebufferUpdateRequest : { RegionRec tmpRegion ; BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFramebufferUpdateRequestMsg - 1 ) box . x1 = Swap16IfLE ( msg . fur . x ) ; box . y1 = Swap16IfLE ( msg . fur . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . fur . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . fur . h ) ; SAFE_REGION_INIT ( pScreen , & tmpRegion , & box , 0 ) ; if ( ! msg . fur . incremental || ! cl -> continuousUpdates ) REGION_UNION ( pScreen , & cl -> requestedRegion , & cl -> requestedRegion , & tmpRegion ) ; if ( ! cl -> readyForSetColourMapEntries ) { cl -> readyForSetColourMapEntries = TRUE ; if ( ! cl -> format . trueColour ) { if ( ! rfbSetClientColourMap ( cl , 0 , 0 ) ) { REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } } } if ( ! msg . fur . incremental ) { REGION_UNION ( pScreen , & cl -> modifiedRegion , & cl -> modifiedRegion , & tmpRegion ) ; REGION_SUBTRACT ( pScreen , & cl -> copyRegion , & cl -> copyRegion , & tmpRegion ) ; REGION_UNION ( pScreen , & cl -> ifRegion , & cl -> ifRegion , & tmpRegion ) ; cl -> pendingExtDesktopResize = TRUE ; } if ( FB_UPDATE_PENDING ( cl ) && ( ! cl -> deferredUpdateScheduled || rfbDeferUpdateTime == 0 || gettime ( ) - cl -> deferredUpdateStart >= ( double ) rfbDeferUpdateTime ) ) { if ( rfbSendFramebufferUpdate ( cl ) ) cl -> deferredUpdateScheduled = FALSE ; } REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } case rfbKeyEvent : cl -> rfbKeyEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbKeyEventMsg - 1 ) if ( ! rfbViewOnly && ! cl -> viewOnly ) KeyEvent ( ( KeySym ) Swap32IfLE ( msg . ke . key ) , msg . ke . down ) ; return ; case rfbPointerEvent : cl -> rfbPointerEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbPointerEventMsg - 1 ) if ( pointerClient && ( pointerClient != cl ) ) return ; if ( msg . pe . buttonMask == 0 ) pointerClient = NULL ; else pointerClient = cl ; if ( ! rfbViewOnly && ! cl -> viewOnly ) { cl -> cursorX = ( int ) Swap16IfLE ( msg . pe . x ) ; cl -> cursorY = ( int ) Swap16IfLE ( msg . pe . y ) ; PtrAddEvent ( msg . pe . buttonMask , cl -> cursorX , cl -> cursorY , cl ) ; } return ; case rfbClientCutText : { int ignoredBytes = 0 ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbClientCutTextMsg - 1 ) msg . cct . length = Swap32IfLE ( msg . cct . length ) ; if ( msg . cct . length > rfbMaxClipboard ) { rfbLog ( ""Truncating<S2SV_blank>%d-byte<S2SV_blank>clipboard<S2SV_blank>update<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>bytes.\\n"" , msg . cct . length , rfbMaxClipboard ) ; ignoredBytes = msg . cct . length - rfbMaxClipboard ; msg . cct . length = rfbMaxClipboard ; } if ( msg . cct . length <= 0 ) return ; str = ( char * ) malloc ( msg . cct . length ) ; if ( str == NULL ) { rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>rfbClientCutText<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; rfbCloseClient ( cl ) ; return ; } if ( ( n = ReadExact ( cl , str , msg . cct . length ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>read"" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } if ( ignoredBytes > 0 ) { if ( ( n = SkipExact ( cl , ignoredBytes ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>read"" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } } if ( ! rfbViewOnly && ! cl -> viewOnly && ! rfbAuthDisableCBRecv ) { vncClientCutText ( str , msg . cct . length ) ; if ( rfbSyncCutBuffer ) rfbSetXCutText ( str , msg . cct . length ) ; } free ( str ) ; return ; } case rfbEnableContinuousUpdates : { BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbEnableContinuousUpdatesMsg - 1 ) if ( ! cl -> enableFence || ! cl -> enableCU ) { rfbLog ( ""Ignoring<S2SV_blank>request<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>continuous<S2SV_blank>updates<S2SV_blank>because<S2SV_blank>the<S2SV_blank>client<S2SV_blank>does<S2SV_blank>not\\n"" ) ; rfbLog ( ""support<S2SV_blank>the<S2SV_blank>flow<S2SV_blank>control<S2SV_blank>extensions.\\n"" ) ; return ; } box . x1 = Swap16IfLE ( msg . ecu . x ) ; box . y1 = Swap16IfLE ( msg . ecu . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . ecu . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . ecu . h ) ; SAFE_REGION_INIT ( pScreen , & cl -> cuRegion , & box , 0 ) ; cl -> continuousUpdates = msg . ecu . enable ; if ( cl -> continuousUpdates ) { REGION_EMPTY ( pScreen , & cl -> requestedRegion ) ; if ( ! rfbSendFramebufferUpdate ( cl ) ) return ; } else { if ( ! rfbSendEndOfCU ( cl ) ) return ; } rfbLog ( ""Continuous<S2SV_blank>updates<S2SV_blank>%s\\n"" , cl -> continuousUpdates ? ""enabled"" : ""disabled"" ) ; return ; } case rfbFence : { CARD32 flags ; char data [ 64 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFenceMsg - 1 ) flags = Swap32IfLE ( msg . f . flags ) ; <S2SV_StartBug> READ ( data , msg . f . length ) <S2SV_EndBug> <S2SV_StartBug> if ( msg . f . length > sizeof ( data ) ) <S2SV_EndBug> rfbLog ( ""Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\n"" , msg . f . length ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> HandleFence ( cl , flags , msg . f . length , data ) ; <S2SV_EndBug> return ; } # define EDSERROR ( format , args ... ) { if ( ! strlen ( errMsg ) ) snprintf ( errMsg , 256 , ""Desktop<S2SV_blank>resize<S2SV_blank>ERROR:<S2SV_blank>"" format ""\\n"" , args ) ; result = rfbEDSResultInvalid ; } case rfbSetDesktopSize : { int i ; struct xorg_list newScreens ; rfbClientPtr cl2 ; int result = rfbEDSResultSuccess ; char errMsg [ 256 ] = ""\\0"" ; ScreenPtr pScreen = screenInfo . screens [ 0 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetDesktopSizeMsg - 1 ) if ( msg . sds . numScreens < 1 ) EDSERROR ( ""Requested<S2SV_blank>number<S2SV_blank>of<S2SV_blank>screens<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid"" , msg . sds . numScreens ) ; msg . sds . w = Swap16IfLE ( msg . sds . w ) ; msg . sds . h = Swap16IfLE ( msg . sds . h ) ; if ( msg . sds . w < 1 || msg . sds . h < 1 ) EDSERROR ( ""Requested<S2SV_blank>framebuffer<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid"" , msg . sds . w , msg . sds . h ) ; xorg_list_init ( & newScreens ) ; for ( i = 0 ; i < msg . sds . numScreens ; i ++ ) { rfbScreenInfo * screen = rfbNewScreen ( 0 , 0 , 0 , 0 , 0 , 0 ) ; READ ( ( char * ) & screen -> s , sizeof ( rfbScreenDesc ) ) screen -> s . id = Swap32IfLE ( screen -> s . id ) ; screen -> s . x = Swap16IfLE ( screen -> s . x ) ; screen -> s . y = Swap16IfLE ( screen -> s . y ) ; screen -> s . w = Swap16IfLE ( screen -> s . w ) ; screen -> s . h = Swap16IfLE ( screen -> s . h ) ; screen -> s . flags = Swap32IfLE ( screen -> s . flags ) ; if ( screen -> s . w < 1 || screen -> s . h < 1 ) EDSERROR ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid"" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h ) ; if ( screen -> s . x >= msg . sds . w || screen -> s . y >= msg . sds . h || screen -> s . x + screen -> s . w > msg . sds . w || screen -> s . y + screen -> s . h > msg . sds . h ) EDSERROR ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>geometry<S2SV_blank>%dx%d+%d+%d<S2SV_blank>exceeds<S2SV_blank>requested<S2SV_blank>framebuffer<S2SV_blank>dimensions"" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h , screen -> s . x , screen -> s . y ) ; if ( rfbFindScreenID ( & newScreens , screen -> s . id ) ) { EDSERROR ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>duplicate<S2SV_blank>ID"" , ( unsigned int ) screen -> s . id ) ; free ( screen ) ; } else rfbAddScreen ( & newScreens , screen ) ; } if ( cl -> viewOnly ) { rfbLog ( ""NOTICE:<S2SV_blank>Ignoring<S2SV_blank>remote<S2SV_blank>desktop<S2SV_blank>resize<S2SV_blank>request<S2SV_blank>from<S2SV_blank>a<S2SV_blank>view-only<S2SV_blank>client.\\n"" ) ; result = rfbEDSResultProhibited ; } else if ( result == rfbEDSResultSuccess ) { result = ResizeDesktop ( pScreen , cl , msg . sds . w , msg . sds . h , & newScreens ) ; if ( result == rfbEDSResultSuccess ) return ; } else rfbLog ( errMsg ) ; rfbRemoveScreens ( & newScreens ) ; for ( cl2 = rfbClientHead ; cl2 ; cl2 = cl2 -> next ) { if ( cl2 == cl ) { cl2 -> pendingExtDesktopResize = TRUE ; cl2 -> reason = rfbEDSReasonClient ; cl2 -> result = result ; rfbSendFramebufferUpdate ( cl2 ) ; break ; } } return ; } case rfbGIIClient : { CARD8 endianAndSubType , littleEndian , subType ; READ ( ( char * ) & endianAndSubType , 1 ) ; littleEndian = ( endianAndSubType & rfbGIIBE ) ? 0 : 1 ; subType = endianAndSubType & ~ rfbGIIBE ; switch ( subType ) { case rfbGIIVersion : READ ( ( char * ) & msg . giicv . length , sz_rfbGIIClientVersionMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giicv . length = Swap16 ( msg . giicv . length ) ; msg . giicv . version = Swap16 ( msg . giicv . version ) ; } if ( msg . giicv . length != sz_rfbGIIClientVersionMsg - 4 || msg . giicv . version < 1 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>client<S2SV_blank>version<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } rfbLog ( ""Client<S2SV_blank>supports<S2SV_blank>GII<S2SV_blank>version<S2SV_blank>%d\\n"" , msg . giicv . version ) ; break ; case rfbGIIDeviceCreate : { int i ; rfbDevInfo dev ; rfbGIIDeviceCreatedMsg dcmsg ; memset ( & dev , 0 , sizeof ( dev ) ) ; dcmsg . deviceOrigin = 0 ; READ ( ( char * ) & msg . giidc . length , sz_rfbGIIDeviceCreateMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidc . length = Swap16 ( msg . giidc . length ) ; msg . giidc . vendorID = Swap32 ( msg . giidc . vendorID ) ; msg . giidc . productID = Swap32 ( msg . giidc . productID ) ; msg . giidc . canGenerate = Swap32 ( msg . giidc . canGenerate ) ; msg . giidc . numRegisters = Swap32 ( msg . giidc . numRegisters ) ; msg . giidc . numValuators = Swap32 ( msg . giidc . numValuators ) ; msg . giidc . numButtons = Swap32 ( msg . giidc . numButtons ) ; } rfbLog ( ""GII<S2SV_blank>Device<S2SV_blank>Create:<S2SV_blank>%s\\n"" , msg . giidc . deviceName ) ; # ifdef GII_DEBUG rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vendor<S2SV_blank>ID:<S2SV_blank>%d\\n"" , msg . giidc . vendorID ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Product<S2SV_blank>ID:<S2SV_blank>%d\\n"" , msg . giidc . productID ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Event<S2SV_blank>mask:<S2SV_blank>%.8x\\n"" , msg . giidc . canGenerate ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Registers:<S2SV_blank>%d\\n"" , msg . giidc . numRegisters ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuators:<S2SV_blank>%d\\n"" , msg . giidc . numValuators ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Buttons:<S2SV_blank>%d\\n"" , msg . giidc . numButtons ) ; # endif if ( msg . giidc . length != sz_rfbGIIDeviceCreateMsg - 4 + msg . giidc . numValuators * sz_rfbGIIValuator ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } if ( msg . giidc . numButtons > MAX_BUTTONS ) { rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>buttons<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\n"" , msg . giidc . numButtons , MAX_BUTTONS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } if ( msg . giidc . numValuators > MAX_VALUATORS ) { rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>valuators<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\n"" , msg . giidc . numValuators , MAX_VALUATORS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } memcpy ( & dev . name , msg . giidc . deviceName , 32 ) ; dev . numButtons = msg . giidc . numButtons ; dev . numValuators = msg . giidc . numValuators ; dev . eventMask = msg . giidc . canGenerate ; dev . mode = ( dev . eventMask & rfbGIIValuatorAbsoluteMask ) ? Absolute : Relative ; dev . productID = msg . giidc . productID ; if ( dev . mode == Relative ) { rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>relative<S2SV_blank>valuators<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>(yet)\\n"" ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } for ( i = 0 ; i < dev . numValuators ; i ++ ) { rfbGIIValuator * v = & dev . valuators [ i ] ; READ ( ( char * ) v , sz_rfbGIIValuator ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v -> index = Swap32 ( v -> index ) ; v -> rangeMin = Swap32 ( ( CARD32 ) v -> rangeMin ) ; v -> rangeCenter = Swap32 ( ( CARD32 ) v -> rangeCenter ) ; v -> rangeMax = Swap32 ( ( CARD32 ) v -> rangeMax ) ; v -> siUnit = Swap32 ( v -> siUnit ) ; v -> siAdd = Swap32 ( ( CARD32 ) v -> siAdd ) ; v -> siMul = Swap32 ( ( CARD32 ) v -> siMul ) ; v -> siDiv = Swap32 ( ( CARD32 ) v -> siDiv ) ; v -> siShift = Swap32 ( ( CARD32 ) v -> siShift ) ; } # ifdef GII_DEBUG rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuator:<S2SV_blank>%s<S2SV_blank>(%s)\\n"" , v -> longName , v -> shortName ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Index:<S2SV_blank>%d\\n"" , v -> index ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Range:<S2SV_blank>min<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>center<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>max<S2SV_blank>=<S2SV_blank>%d\\n"" , v -> rangeMin , v -> rangeCenter , v -> rangeMax ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>unit:<S2SV_blank>%d\\n"" , v -> siUnit ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>add:<S2SV_blank>%d\\n"" , v -> siAdd ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>multiply:<S2SV_blank>%d\\n"" , v -> siMul ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>divide:<S2SV_blank>%d\\n"" , v -> siDiv ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>shift:<S2SV_blank>%d\\n"" , v -> siShift ) ; # endif } for ( i = 0 ; i < cl -> numDevices ; i ++ ) { if ( ! strcmp ( dev . name , cl -> devices [ i ] . name ) ) { rfbLog ( ""Device<S2SV_blank>\\\'%s\\\'<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>with<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>%d\\n"" , dev . name , i + 1 ) ; dcmsg . deviceOrigin = Swap32IfLE ( i + 1 ) ; goto sendMessage ; } } if ( rfbVirtualTablet || AddExtInputDevice ( & dev ) ) { memcpy ( & cl -> devices [ cl -> numDevices ] , & dev , sizeof ( dev ) ) ; cl -> numDevices ++ ; dcmsg . deviceOrigin = Swap32IfLE ( cl -> numDevices ) ; } rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>=<S2SV_blank>%d\\n"" , cl -> numDevices ) ; sendMessage : dcmsg . type = rfbGIIServer ; dcmsg . endianAndSubType = rfbGIIDeviceCreate | rfbGIIBE ; dcmsg . length = Swap16IfLE ( sz_rfbGIIDeviceCreatedMsg - 4 ) ; if ( WriteExact ( cl , ( char * ) & dcmsg , sz_rfbGIIDeviceCreatedMsg ) < 0 ) { rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>write"" ) ; rfbCloseClient ( cl ) ; return ; } break ; } case rfbGIIDeviceDestroy : READ ( ( char * ) & msg . giidd . length , sz_rfbGIIDeviceDestroyMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidd . length = Swap16 ( msg . giidd . length ) ; msg . giidd . deviceOrigin = Swap32 ( msg . giidd . deviceOrigin ) ; } if ( msg . giidd . length != sz_rfbGIIDeviceDestroyMsg - 4 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } RemoveExtInputDevice ( cl , msg . giidd . deviceOrigin - 1 ) ; break ; case rfbGIIEvent : { CARD16 length ; READ ( ( char * ) & length , sizeof ( CARD16 ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) length = Swap16 ( length ) ; while ( length > 0 ) { CARD8 eventSize , eventType ; READ ( ( char * ) & eventSize , 1 ) ; READ ( ( char * ) & eventType , 1 ) ; switch ( eventType ) { case rfbGIIButtonPress : case rfbGIIButtonRelease : { rfbGIIButtonEvent b ; rfbDevInfo * dev ; READ ( ( char * ) & b . pad , sz_rfbGIIButtonEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { b . deviceOrigin = Swap32 ( b . deviceOrigin ) ; b . buttonNumber = Swap32 ( b . buttonNumber ) ; } if ( eventSize != sz_rfbGIIButtonEvent || b . deviceOrigin <= 0 || b . buttonNumber < 1 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event\\n"" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( b . deviceOrigin < 1 || b . deviceOrigin > cl -> numDevices ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\n"" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ b . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIButtonPress && ( dev -> eventMask & rfbGIIButtonPressMask ) == 0 ) || ( eventType == rfbGIIButtonRelease && ( dev -> eventMask & rfbGIIButtonReleaseMask ) == 0 ) ) { rfbLog ( ""ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>can\'t<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>events\\n"" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( b . buttonNumber > dev -> numButtons ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>button<S2SV_blank>count<S2SV_blank>(%d)\\n"" , b . buttonNumber , b . deviceOrigin , dev -> numButtons ) ; rfbCloseClient ( cl ) ; return ; } # ifdef GII_DEBUG rfbLog ( ""Device<S2SV_blank>%d<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>%s\\n"" , b . deviceOrigin , b . buttonNumber , eventType == rfbGIIButtonPress ? ""PRESS"" : ""release"" ) ; fflush ( stderr ) ; # endif ExtInputAddEvent ( dev , eventType == rfbGIIButtonPress ? ButtonPress : ButtonRelease , b . buttonNumber ) ; break ; } case rfbGIIValuatorRelative : case rfbGIIValuatorAbsolute : { rfbGIIValuatorEvent v ; int i ; rfbDevInfo * dev ; READ ( ( char * ) & v . pad , sz_rfbGIIValuatorEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v . deviceOrigin = Swap32 ( v . deviceOrigin ) ; v . first = Swap32 ( v . first ) ; v . count = Swap32 ( v . count ) ; } if ( eventSize != sz_rfbGIIValuatorEvent + sizeof ( int ) * v . count ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event\\n"" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( v . deviceOrigin < 1 || v . deviceOrigin > cl -> numDevices ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\n"" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ v . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIValuatorRelative && ( dev -> eventMask & rfbGIIValuatorRelativeMask ) == 0 ) || ( eventType == rfbGIIValuatorAbsolute && ( dev -> eventMask & rfbGIIValuatorAbsoluteMask ) == 0 ) ) { rfbLog ( ""ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>cannot<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>events\\n"" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( v . first + v . count > dev -> numValuators ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>valuator<S2SV_blank>count<S2SV_blank>(%d)\\n"" , v . deviceOrigin , dev -> numValuators ) ; rfbCloseClient ( cl ) ; return ; } # ifdef GII_DEBUG rfbLog ( ""Device<S2SV_blank>%d<S2SV_blank>Valuator<S2SV_blank>%s<S2SV_blank>first=%d<S2SV_blank>count=%d:\\n"" , v . deviceOrigin , eventType == rfbGIIValuatorRelative ? ""rel"" : ""ABS"" , v . first , v . count ) ; # endif for ( i = v . first ; i < v . first + v . count ; i ++ ) { READ ( ( char * ) & dev -> values [ i ] , sizeof ( int ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) dev -> values [ i ] = Swap32 ( ( CARD32 ) dev -> values [ i ] ) ; # ifdef GII_DEBUG fprintf ( stderr , ""v[%d]=%d<S2SV_blank>"" , i , dev -> values [ i ] ) ; # endif } # ifdef GII_DEBUG fprintf ( stderr , ""\\n"" ) ; # endif if ( v . count > 0 ) { dev -> valFirst = v . first ; dev -> valCount = v . count ; dev -> mode = eventType == rfbGIIValuatorAbsolute ? Absolute : Relative ; ExtInputAddEvent ( dev , MotionNotify , 0 ) ; } break ; } default : rfbLog ( ""ERROR:<S2SV_blank>This<S2SV_blank>server<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>type<S2SV_blank>%d\\n"" , eventType ) ; rfbCloseClient ( cl ) ; return ; } } if ( length != 0 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } break ; } } return ; } default : rfbLog ( ""rfbProcessClientNormalMessage:<S2SV_blank>unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d\\n"" , msg . type ) ; rfbLog ( ""<S2SV_blank>...<S2SV_blank>closing<S2SV_blank>connection\\n"" ) ; rfbCloseClient ( cl ) ; return ; } }
","<S2SV_ModStart> flags ) ; <S2SV_ModEnd> if ( msg <S2SV_ModStart> data ) ) { <S2SV_ModStart> length ) ; SKIP ( msg . f . length ) } else { READ ( data , msg . f . length ) <S2SV_ModEnd> HandleFence ( cl <S2SV_ModStart> data ) ; }
",CWE-787
74,"CWE-190 <S2SV_StartBug> int mongo_env_write_socket ( mongo * conn , const void * buf , int len ) { <S2SV_EndBug> const char * cbuf = buf ; # ifdef __APPLE__ int flags = 0 ; # else int flags = MSG_NOSIGNAL ; # endif while ( len ) { <S2SV_StartBug> int sent = send ( conn -> sock , cbuf , len , flags ) ; <S2SV_EndBug> if ( sent == - 1 ) { if ( errno == EPIPE ) conn -> connected = 0 ; __mongo_set_error ( conn , MONGO_IO_ERROR , strerror ( errno ) , errno ) ; return MONGO_ERROR ; } cbuf += sent ; len -= sent ; } return MONGO_OK ; }
","<S2SV_ModStart> * buf , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> len ) { size_t <S2SV_ModEnd> sent = send
",CWE-190
75,"CWE-787 size_t OpenMP4SourceUDTA ( char * filename ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == NULL ) return 0 ; memset ( mp4 , 0 , sizeof ( mp4object ) ) ; # ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ; # else mp4 -> mediafp = fopen ( filename , ""rb"" ) ; # endif if ( mp4 -> mediafp ) { <S2SV_StartBug> uint32_t qttag , qtsize32 , len ; <S2SV_EndBug> int32_t nest = 0 ; uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; if ( len == 8 ) { if ( ! GPMF_VALID_FOURCC ( qttag ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( lastsize - 8 ) ; continue ; } qtsize32 = BYTESWAP32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; qtsize = BYTESWAP64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= MAX_NEST_LEVEL ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; continue ; } if ( qttag == MAKEID ( 'G' , 'P' , 'M' , 'F' ) ) { mp4 -> videolength += 1.0 ; mp4 -> metadatalength += 1.0 ; mp4 -> indexcount = ( int ) mp4 -> metadatalength ; mp4 -> metasizes = ( uint32_t * ) malloc ( mp4 -> indexcount * 4 + 4 ) ; memset ( mp4 -> metasizes , 0 , mp4 -> indexcount * 4 + 4 ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> indexcount * 8 + 8 ) ; memset ( mp4 -> metaoffsets , 0 , mp4 -> indexcount * 8 + 8 ) ; mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ; mp4 -> metaoffsets [ 0 ] = ftell ( mp4 -> mediafp ) ; mp4 -> metasize_count = 1 ; return ( size_t ) mp4 ; } if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'u' , 'd' , 't' , 'a' ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; continue ; } else { NESTSIZE ( 8 ) ; } } } while ( len > 0 ) ; } return ( size_t ) mp4 ; }
","<S2SV_ModStart> qttag , qtsize32 ; size_t <S2SV_ModEnd> len ; int32_t <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , lastsize - <S2SV_ModStart> 8 - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE
",CWE-787
78,"CWE-000 WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SLICE_HDR_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ; <S2SV_StartBug> if ( ! ps_seq -> u1_frame_mbs_only_flag ) <S2SV_EndBug> { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 1 ; ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; if ( ps_dec -> u4_first_slice_in_pic != 2 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; <S2SV_StartBug> } <S2SV_EndBug> u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { ps_dec -> ps_decode_cur_slice ++ ; } ps_dec -> u1_slice_header_done = 0 ; <S2SV_StartBug> if ( ! ps_dec -> u1_first_slice_in_stream ) <S2SV_EndBug> { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; # if WIN32 H264_DEC_DEBUG_PRINT ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n"" ) ; # endif return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }
","<S2SV_ModStart> if ( ! ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } ps_dec -> u2_total_mbs_coded = 0 ; } if ( ! <S2SV_ModStart> u1_bottom_field_flag ) ; if ( i1_is_end_of_poc ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( u1_field_pic_flag
",CWE-000
80,"CWE-000 static int list_table_status ( MYSQL * mysql , const char * db , const char * wild ) { <S2SV_StartBug> char query [ 1024 ] , * end ; <S2SV_EndBug> MYSQL_RES * result ; MYSQL_ROW row ; <S2SV_StartBug> end = strxmov ( query , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`"" , db , ""`"" , NullS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wild && wild [ 0 ] ) <S2SV_EndBug> strxmov ( end , ""<S2SV_blank>like<S2SV_blank>\'"" , wild , ""\'"" , NullS ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>get<S2SV_blank>status<S2SV_blank>for<S2SV_blank>db:<S2SV_blank>%s,<S2SV_blank>table:<S2SV_blank>%s:<S2SV_blank>%s\\n"" , my_progname , db , wild ? wild : """" , mysql_error ( mysql ) ) ; if ( mysql_errno ( mysql ) == ER_PARSE_ERROR ) fprintf ( stderr , ""This<S2SV_blank>error<S2SV_blank>probably<S2SV_blank>means<S2SV_blank>that<S2SV_blank>your<S2SV_blank>MySQL<S2SV_blank>server<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>the\\n\\\'show<S2SV_blank>table<S2SV_blank>status\'<S2SV_blank>command.\\n"" ) ; return 1 ; } printf ( ""Database:<S2SV_blank>%s"" , db ) ; if ( wild ) printf ( ""<S2SV_blank><S2SV_blank>Wildcard:<S2SV_blank>%s"" , wild ) ; putchar ( '\\n' ) ; print_res_header ( result ) ; while ( ( row = mysql_fetch_row ( result ) ) ) print_res_row ( result , row ) ; print_res_top ( result ) ; mysql_free_result ( result ) ; return 0 ; }
","<S2SV_ModStart> char query [ NAME_LEN + 100 ] ; int len <S2SV_ModEnd> ; MYSQL_RES * <S2SV_ModStart> MYSQL_ROW row ; len = sizeof ( query ) ; len -= my_snprintf ( query , len , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`%s`"" , db <S2SV_ModEnd> ) ; if <S2SV_ModStart> [ 0 ] && len ) strxnmov ( query + strlen ( query ) , len <S2SV_ModEnd> , ""<S2SV_blank>like<S2SV_blank>\'"" ,
",CWE-000
81,"CWE-119 int vp8_find_best_sub_pixel_step ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * bestmv , int_mv * ref_mv , int error_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvcost [ 2 ] , int * distortion , unsigned int * sse1 ) { int bestmse = INT_MAX ; int_mv startmv ; int_mv this_mv ; unsigned char * z = ( * ( b -> base_src ) + b -> src ) ; int left , right , up , down , diag ; unsigned int sse ; int whichdir ; int thismse ; int y_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; # if ARCH_X86 || ARCH_X86_64 MACROBLOCKD * xd = & x -> e_mbd ; unsigned char * y_0 = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ; unsigned char * y ; y_stride = 32 ; vfp -> copymem ( y_0 - 1 - pre_stride , pre_stride , xd -> y_buf , y_stride , 18 ) ; y = xd -> y_buf + y_stride + 1 ; # else unsigned char * y = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ; y_stride = pre_stride ; # endif <S2SV_StartBug> bestmv -> as_mv . row <<= 3 ; <S2SV_EndBug> <S2SV_StartBug> bestmv -> as_mv . col <<= 3 ; <S2SV_EndBug> startmv = * bestmv ; bestmse = vfp -> vf ( y , y_stride , z , b -> src_stride , sse1 ) ; * distortion = bestmse ; bestmse += mv_err_cost ( bestmv , ref_mv , mvcost , error_per_bit ) ; this_mv . as_mv . row = startmv . as_mv . row ; this_mv . as_mv . col = ( ( startmv . as_mv . col - 8 ) | 4 ) ; thismse = vfp -> svf_halfpix_h ( y - 1 , y_stride , z , b -> src_stride , & sse ) ; left = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( left < bestmse ) { * bestmv = this_mv ; bestmse = left ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col += 8 ; thismse = vfp -> svf_halfpix_h ( y , y_stride , z , b -> src_stride , & sse ) ; right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( right < bestmse ) { * bestmv = this_mv ; bestmse = right ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col = startmv . as_mv . col ; this_mv . as_mv . row = ( ( startmv . as_mv . row - 8 ) | 4 ) ; thismse = vfp -> svf_halfpix_v ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ; up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( up < bestmse ) { * bestmv = this_mv ; bestmse = up ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . row += 8 ; thismse = vfp -> svf_halfpix_v ( y , y_stride , z , b -> src_stride , & sse ) ; down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( down < bestmse ) { * bestmv = this_mv ; bestmse = down ; * distortion = thismse ; * sse1 = sse ; } whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ; this_mv = startmv ; switch ( whichdir ) { case 0 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ; this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ; thismse = vfp -> svf_halfpix_hv ( y - 1 - y_stride , y_stride , z , b -> src_stride , & sse ) ; break ; case 1 : this_mv . as_mv . col += 4 ; this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ; thismse = vfp -> svf_halfpix_hv ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ; break ; case 2 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ; this_mv . as_mv . row += 4 ; thismse = vfp -> svf_halfpix_hv ( y - 1 , y_stride , z , b -> src_stride , & sse ) ; break ; case 3 : default : this_mv . as_mv . col += 4 ; this_mv . as_mv . row += 4 ; thismse = vfp -> svf_halfpix_hv ( y , y_stride , z , b -> src_stride , & sse ) ; break ; } diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( diag < bestmse ) { * bestmv = this_mv ; bestmse = diag ; * distortion = thismse ; * sse1 = sse ; } if ( bestmv -> as_mv . row < startmv . as_mv . row ) y -= y_stride ; if ( bestmv -> as_mv . col < startmv . as_mv . col ) y -- ; startmv = * bestmv ; this_mv . as_mv . row = startmv . as_mv . row ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col = startmv . as_mv . col - 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } left = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( left < bestmse ) { * bestmv = this_mv ; bestmse = left ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col += 4 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( right < bestmse ) { * bestmv = this_mv ; bestmse = right ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col = startmv . as_mv . col ; if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row = startmv . as_mv . row - 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( up < bestmse ) { * bestmv = this_mv ; bestmse = up ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . row += 4 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( down < bestmse ) { * bestmv = this_mv ; bestmse = down ; * distortion = thismse ; * sse1 = sse ; } whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ; this_mv = startmv ; switch ( whichdir ) { case 0 : if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row -= 2 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; ; } } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride - 1 , y_stride , 6 , 6 , z , b -> src_stride , & sse ) ; } } break ; case 1 : this_mv . as_mv . col += 2 ; if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } break ; case 2 : this_mv . as_mv . row += 2 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } break ; case 3 : this_mv . as_mv . col += 2 ; this_mv . as_mv . row += 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; break ; } diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( diag < bestmse ) { * bestmv = this_mv ; bestmse = diag ; * distortion = thismse ; * sse1 = sse ; } return bestmse ; }
","<S2SV_ModStart> as_mv . row *= 8 <S2SV_ModEnd> ; bestmv -> <S2SV_ModStart> as_mv . col *= 8 <S2SV_ModEnd> ; startmv =
",CWE-119
82,"CWE-772 generic_ret * delete_principal_2_svc ( dprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , arg -> princ , NULL ) ) { ret . code = KADM5_AUTH_DELETE ; log_unauth ( ""kadm5_delete_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_delete_principal ( ( void * ) handle , arg -> princ ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_delete_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",CWE-772
85,"CWE-119 int main ( int argc , char * * argv ) { FILE * infile = NULL ; <S2SV_StartBug> VpxVideoWriter * writer = NULL ; <S2SV_EndBug> vpx_codec_ctx_t codec ; vpx_codec_enc_cfg_t cfg ; vpx_image_t raw ; vpx_codec_err_t res ; <S2SV_StartBug> vpx_fixed_buf_t stats = { 0 } ; <S2SV_EndBug> VpxVideoInfo info = { 0 } ; <S2SV_StartBug> const VpxInterface * encoder = NULL ; <S2SV_EndBug> int pass ; const int fps = 30 ; const int bitrate = 200 ; const char * const codec_arg = argv [ 1 ] ; const char * const width_arg = argv [ 2 ] ; const char * const height_arg = argv [ 3 ] ; const char * const infile_arg = argv [ 4 ] ; const char * const outfile_arg = argv [ 5 ] ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; encoder = get_vpx_encoder_by_name ( codec_arg ) ; if ( ! encoder ) die ( ""Unsupported<S2SV_blank>codec."" ) ; <S2SV_StartBug> info . codec_fourcc = encoder -> fourcc ; <S2SV_EndBug> info . time_base . numerator = 1 ; info . time_base . denominator = fps ; info . frame_width = strtol ( width_arg , NULL , 0 ) ; <S2SV_StartBug> info . frame_height = strtol ( height_arg , NULL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( info . frame_width <= 0 || <S2SV_EndBug> <S2SV_StartBug> info . frame_height <= 0 || <S2SV_EndBug> <S2SV_StartBug> ( info . frame_width % 2 ) != 0 || <S2SV_EndBug> <S2SV_StartBug> ( info . frame_height % 2 ) != 0 ) { <S2SV_EndBug> <S2SV_StartBug> die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , <S2SV_EndBug> <S2SV_StartBug> info . frame_height , 1 ) ) { <S2SV_EndBug> <S2SV_StartBug> die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ; <S2SV_EndBug> } writer = vpx_video_writer_open ( outfile_arg , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing"" , outfile_arg ) ; printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; for ( pass = 0 ; pass < 2 ; ++ pass ) { int frame_count = 0 ; if ( pass == 0 ) { cfg . g_pass = VPX_RC_FIRST_PASS ; } else { cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; } if ( ! ( infile = fopen ( infile_arg , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , infile_arg ) ; if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; <S2SV_StartBug> while ( vpx_img_read ( & raw , infile ) ) { <S2SV_EndBug> ++ frame_count ; if ( pass == 0 ) { get_frame_stats ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { encode_frame ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ; } } if ( pass == 0 ) { get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { printf ( ""\\n"" ) ; } <S2SV_StartBug> fclose ( infile ) ; <S2SV_EndBug> printf ( ""Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , pass + 1 , frame_count ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; } vpx_img_free ( & raw ) ; free ( stats . buf ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }
","<S2SV_ModStart> = NULL ; int w , h <S2SV_ModEnd> ; vpx_codec_ctx_t codec <S2SV_ModStart> ; vpx_fixed_buf_t stats <S2SV_ModEnd> ; const VpxInterface <S2SV_ModStart> encoder = NULL <S2SV_ModEnd> ; const int <S2SV_ModStart> ""Unsupported<S2SV_blank>codec."" ) ; w <S2SV_ModEnd> = strtol ( <S2SV_ModStart> 0 ) ; h <S2SV_ModEnd> = strtol ( <S2SV_ModStart> ; if ( w <S2SV_ModEnd> <= 0 || <S2SV_ModStart> <= 0 || h <S2SV_ModEnd> <= 0 || <S2SV_ModStart> <= 0 || ( w <S2SV_ModEnd> % 2 ) <S2SV_ModStart> != 0 || ( h <S2SV_ModEnd> % 2 ) <S2SV_ModStart> != 0 ) <S2SV_ModEnd> die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" <S2SV_ModStart> ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , w , h ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> , VPX_IMG_FMT_I420 , w , h <S2SV_ModEnd> , 1 ) <S2SV_ModStart> 1 ) ) <S2SV_ModEnd> die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" <S2SV_ModStart> ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , w , h ) ; printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = w ; cfg . g_h = h ; cfg . g_timebase . num = 1 ; cfg . g_timebase . den = fps ; cfg . rc_target_bitrate = bitrate ; if ( ! ( infile = fopen ( infile_arg , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , infile_arg ) ; cfg . g_pass = VPX_RC_FIRST_PASS ; stats = pass0 ( & raw , infile , encoder , & cfg ) ; rewind ( infile ) ; cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; pass1 ( & raw , infile , outfile_arg , encoder , & cfg ) ; free ( stats . buf ) ; vpx_img_free <S2SV_ModEnd> ( & raw <S2SV_ModStart> ( & raw ) ; <S2SV_ModEnd> fclose ( infile <S2SV_ModStart> fclose ( infile <S2SV_ModEnd> ) ; return
",CWE-119
86,"CWE-119 void cJSON_Delete ( cJSON * c ) { cJSON * next ; while ( c ) { next = c -> next ; if ( ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ; if ( ! ( c -> type & cJSON_IsReference ) && c -> valuestring ) cJSON_free ( c -> valuestring ) ; <S2SV_StartBug> if ( c -> string ) <S2SV_EndBug> cJSON_free ( c -> string ) ; cJSON_free ( c ) ; c = next ; } }
","<S2SV_ModStart> ; if ( ! ( c -> type & cJSON_StringIsConst ) &&
",CWE-119
87,"CWE-119 <S2SV_StartBug> void vp9_inc_frame_in_layer ( SVC * svc ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = ( svc -> number_temporal_layers > 1 ) <S2SV_EndBug> ? & svc -> layer_context [ svc -> temporal_layer_id ] : & svc -> layer_context [ svc -> spatial_layer_id ] ; ++ lc -> current_video_frame_in_layer ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> void vp9_inc_frame_in_layer ( VP9_COMP * const cpi <S2SV_ModEnd> ) { LAYER_CONTEXT <S2SV_ModStart> const lc = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers <S2SV_ModEnd> ] ; ++ <S2SV_ModStart> -> current_video_frame_in_layer ; ++ lc -> frames_from_key_frame ;
",CWE-119
91,"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; <S2SV_StartBug> ExitLoop : <S2SV_EndBug> if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
",CWE-125
93,"CWE-20 error_t enc624j600SoftReset ( NetInterface * interface ) { do { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EUDAST , 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_CLKRDY ) == 0 ) <S2SV_EndBug> { } <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON2 , ECON2_ETHRST ) ; <S2SV_EndBug> sleep ( 1 ) ; <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x0000 ) <S2SV_EndBug> { return ERROR_FAILURE ; } sleep ( 1 ) ; return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> , 0x1234 ) <S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> ) != 0x1234 <S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_CLKRDY <S2SV_ModEnd> ) == 0 <S2SV_ModStart> ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHRST <S2SV_ModEnd> ) ; sleep <S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> ) != 0x0000
",CWE-20
95,"CWE-416 static void mark_context_stack ( mrb_state * mrb , struct mrb_context * c ) { size_t i ; <S2SV_StartBug> size_t e ; <S2SV_EndBug> if ( c -> stack == NULL ) return ; e = c -> stack - c -> stbase ; if ( c -> ci ) e += c -> ci -> nregs ; if ( c -> stbase + e > c -> stend ) e = c -> stend - c -> stbase ; for ( i = 0 ; i < e ; i ++ ) { mrb_value v = c -> stbase [ i ] ; if ( ! mrb_immediate_p ( v ) ) { <S2SV_StartBug> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <S2SV_EndBug> c -> stbase [ i ] = mrb_nil_value ( ) ; } else { mrb_gc_mark ( mrb , mrb_basic_ptr ( v ) ) ; } } <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> ; size_t e ; mrb_value nil <S2SV_ModStart> ) ) { <S2SV_ModEnd> mrb_gc_mark ( mrb <S2SV_ModStart> ; } } e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ;
",CWE-416
96,"CWE-399 gboolean cib_notify_client ( gpointer key , gpointer value , gpointer user_data ) { const char * type = NULL ; gboolean do_send = FALSE ; cib_client_t * client = value ; xmlNode * update_msg = user_data ; CRM_CHECK ( client != NULL , return TRUE ) ; CRM_CHECK ( update_msg != NULL , return TRUE ) ; <S2SV_StartBug> if ( client -> ipc == NULL ) { <S2SV_EndBug> crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ; return FALSE ; } type = crm_element_value ( update_msg , F_SUBTYPE ) ; CRM_LOG_ASSERT ( type != NULL ) ; if ( client -> diffs && safe_str_eq ( type , T_CIB_DIFF_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> replace && safe_str_eq ( type , T_CIB_REPLACE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> confirmations && safe_str_eq ( type , T_CIB_UPDATE_CONFIRM ) ) { do_send = TRUE ; } else if ( client -> pre_notify && safe_str_eq ( type , T_CIB_PRE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> post_notify && safe_str_eq ( type , T_CIB_POST_NOTIFY ) ) { do_send = TRUE ; } if ( do_send ) { if ( client -> ipc ) { if ( crm_ipcs_send ( client -> ipc , 0 , update_msg , TRUE ) == FALSE ) { crm_warn ( ""Notification<S2SV_blank>of<S2SV_blank>client<S2SV_blank>%s/%s<S2SV_blank>failed"" , client -> name , client -> id ) ; } # ifdef HAVE_GNUTLS_GNUTLS_H } else if ( client -> session ) { crm_debug ( ""Sent<S2SV_blank>%s<S2SV_blank>notification<S2SV_blank>to<S2SV_blank>client<S2SV_blank>%s/%s"" , type , client -> name , client -> id ) ; crm_send_remote_msg ( client -> session , update_msg , client -> encrypted ) ; # endif } else { crm_err ( ""Unknown<S2SV_blank>transport<S2SV_blank>for<S2SV_blank>%s"" , client -> name ) ; } } return FALSE ; }
","<S2SV_ModStart> ipc == NULL && client -> session == NULL
",CWE-399
99,"CWE-20 static int wb_id ( netdissect_options * ndo , const struct pkt_id * id , u_int len ) { int i ; const char * cp ; const struct id_off * io ; char c ; int nid ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-id:"" ) ) ; if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ; len -= sizeof ( * id ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ; nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ; len -= sizeof ( * io ) * nid ; io = ( struct id_off * ) ( id + 1 ) ; cp = ( char * ) ( io + nid ) ; <S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\"""" ) ) ; fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; } c = '<' ; for ( i = 0 ; i < nid && ND_TTEST ( * io ) ; ++ io , ++ i ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } if ( i >= nid ) { ND_PRINT ( ( ndo , "">"" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp
",CWE-20
100,"CWE-264 int udpv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; <S2SV_StartBug> struct ipv6_txoptions * opt = NULL ; <S2SV_EndBug> struct ip6_flowlabel * flowlabel = NULL ; struct flowi6 fl6 ; struct dst_entry * dst ; int addr_len = msg -> msg_namelen ; int ulen = len ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; int corkreq = up -> corkflag || msg -> msg_flags & MSG_MORE ; int err ; int connected = 0 ; int is_udplite = IS_UDPLITE ( sk ) ; int ( * getfrag ) ( void * , char * , int , int , int , struct sk_buff * ) ; if ( sin6 ) { if ( addr_len < offsetof ( struct sockaddr , sa_data ) ) return - EINVAL ; switch ( sin6 -> sin6_family ) { case AF_INET6 : if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; daddr = & sin6 -> sin6_addr ; break ; case AF_INET : goto do_udp_sendmsg ; case AF_UNSPEC : msg -> msg_name = sin6 = NULL ; msg -> msg_namelen = addr_len = 0 ; daddr = NULL ; break ; default : return - EINVAL ; } } else if ( ! up -> pending ) { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = & sk -> sk_v6_daddr ; } else daddr = NULL ; if ( daddr ) { if ( ipv6_addr_v4mapped ( daddr ) ) { struct sockaddr_in sin ; sin . sin_family = AF_INET ; sin . sin_port = sin6 ? sin6 -> sin6_port : inet -> inet_dport ; sin . sin_addr . s_addr = daddr -> s6_addr32 [ 3 ] ; msg -> msg_name = & sin ; msg -> msg_namelen = sizeof ( sin ) ; do_udp_sendmsg : if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ; return udp_sendmsg ( sk , msg , len ) ; } } if ( up -> pending == AF_INET ) return udp_sendmsg ( sk , msg , len ) ; if ( len > INT_MAX - sizeof ( struct udphdr ) ) return - EMSGSIZE ; getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag ; if ( up -> pending ) { lock_sock ( sk ) ; if ( likely ( up -> pending ) ) { if ( unlikely ( up -> pending != AF_INET6 ) ) { release_sock ( sk ) ; return - EAFNOSUPPORT ; } dst = NULL ; goto do_append_data ; } release_sock ( sk ) ; } ulen += sizeof ( struct udphdr ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( sin6 ) { if ( sin6 -> sin6_port == 0 ) return - EINVAL ; fl6 . fl6_dport = sin6 -> sin6_port ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; fl6 . fl6_dport = inet -> inet_dport ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; connected = 1 ; } if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> sticky_pktinfo . ipi6_ifindex ; fl6 . flowi6_mark = sk -> sk_mark ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( * opt ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; connected = 0 ; } <S2SV_StartBug> if ( ! opt ) <S2SV_EndBug> opt = np -> opt ; if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = sk -> sk_protocol ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; fl6 . fl6_sport = inet -> inet_sport ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( final_p ) connected = 0 ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) { fl6 . flowi6_oif = np -> mcast_oif ; connected = 0 ; } else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_sk_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; dst = NULL ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( ! corkreq ) { struct sk_buff * skb ; skb = ip6_make_skb ( sk , getfrag , msg , ulen , sizeof ( struct udphdr ) , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; err = PTR_ERR ( skb ) ; if ( ! IS_ERR_OR_NULL ( skb ) ) err = udp_v6_send_skb ( skb , & fl6 ) ; goto release_dst ; } lock_sock ( sk ) ; if ( unlikely ( up -> pending ) ) { release_sock ( sk ) ; net_dbg_ratelimited ( ""udp<S2SV_blank>cork<S2SV_blank>app<S2SV_blank>bug<S2SV_blank>2\\n"" ) ; err = - EINVAL ; goto out ; } up -> pending = AF_INET6 ; do_append_data : if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; up -> len += ulen ; err = ip6_append_data ( sk , getfrag , msg , ulen , sizeof ( struct udphdr ) , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , corkreq ? msg -> msg_flags | MSG_MORE : msg -> msg_flags , dontfrag ) ; if ( err ) udp_v6_flush_pending_frames ( sk ) ; else if ( ! corkreq ) err = udp_v6_push_pending_frames ( sk ) ; else if ( unlikely ( skb_queue_empty ( & sk -> sk_write_queue ) ) ) up -> pending = 0 ; if ( err > 0 ) err = np -> recverr ? net_xmit_errno ( err ) : 0 ; release_sock ( sk ) ; release_dst : if ( dst ) { if ( connected ) { ip6_dst_store ( sk , dst , ipv6_addr_equal ( & fl6 . daddr , & sk -> sk_v6_daddr ) ? & sk -> sk_v6_daddr : NULL , # ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal ( & fl6 . saddr , & np -> saddr ) ? & np -> saddr : # endif NULL ) ; } else { dst_release ( dst ) ; } dst = NULL ; } out : dst_release ( dst ) ; <S2SV_StartBug> fl6_sock_release ( flowlabel ) ; <S2SV_EndBug> if ( ! err ) return len ; if ( err == - ENOBUFS || test_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ) { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ) ; } return err ; do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto out ; }
","<S2SV_ModStart> ipv6_txoptions * opt = NULL ; struct ipv6_txoptions * opt_to_free <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free
",CWE-264
102,"CWE-125 l_ok pixFillMapHoles ( PIX * pix , l_int32 nx , l_int32 ny , l_int32 filltype ) { l_int32 w , h , y , nmiss , goodcol , i , j , found , ival , valtest ; l_uint32 val , lastval ; <S2SV_StartBug> NUMA * na ; <S2SV_EndBug> PIX * pixt ; PROCNAME ( ""pixFillMapHoles"" ) ; if ( ! pix || pixGetDepth ( pix ) != 8 ) return ERROR_INT ( ""pix<S2SV_blank>not<S2SV_blank>defined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>8<S2SV_blank>bpp"" , procName , 1 ) ; if ( pixGetColormap ( pix ) ) return ERROR_INT ( ""pix<S2SV_blank>is<S2SV_blank>colormapped"" , procName , 1 ) ; pixGetDimensions ( pix , & w , & h , NULL ) ; na = numaCreate ( 0 ) ; nmiss = 0 ; valtest = ( filltype == L_FILL_WHITE ) ? 255 : 0 ; for ( j = 0 ; j < nx ; j ++ ) { found = FALSE ; for ( i = 0 ; i < ny ; i ++ ) { pixGetPixel ( pix , j , i , & val ) ; if ( val != valtest ) { y = i ; found = TRUE ; break ; } } if ( found == FALSE ) { numaAddNumber ( na , 0 ) ; nmiss ++ ; } else { numaAddNumber ( na , 1 ) ; for ( i = y - 1 ; i >= 0 ; i -- ) pixSetPixel ( pix , j , i , val ) ; pixGetPixel ( pix , j , 0 , & lastval ) ; for ( i = 1 ; i < h ; i ++ ) { pixGetPixel ( pix , j , i , & val ) ; if ( val == valtest ) pixSetPixel ( pix , j , i , lastval ) ; else lastval = val ; } } } numaAddNumber ( na , 0 ) ; if ( nmiss == nx ) { numaDestroy ( & na ) ; L_WARNING ( ""no<S2SV_blank>bg<S2SV_blank>found;<S2SV_blank>no<S2SV_blank>data<S2SV_blank>in<S2SV_blank>any<S2SV_blank>column\\n"" , procName ) ; return 1 ; } if ( nmiss > 0 ) { <S2SV_StartBug> pixt = pixCopy ( NULL , pix ) ; <S2SV_EndBug> goodcol = 0 ; for ( j = 0 ; j < w ; j ++ ) { numaGetIValue ( na , j , & ival ) ; if ( ival == 1 ) { goodcol = j ; break ; } } if ( goodcol > 0 ) { <S2SV_StartBug> for ( j = goodcol - 1 ; j >= 0 ; j -- ) { <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j + 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; <S2SV_EndBug> } } for ( j = goodcol + 1 ; j < w ; j ++ ) { numaGetIValue ( na , j , & ival ) ; if ( ival == 0 ) { <S2SV_StartBug> pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j - 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; <S2SV_EndBug> } } pixDestroy ( & pixt ) ; } if ( w > nx ) { for ( i = 0 ; i < h ; i ++ ) { pixGetPixel ( pix , w - 2 , i , & val ) ; pixSetPixel ( pix , w - 1 , i , val ) ; } } numaDestroy ( & na ) ; return 0 ; }
","<S2SV_ModStart> NUMA * na <S2SV_ModEnd> ; PROCNAME ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> goodcol = 0 <S2SV_ModStart> j -- ) <S2SV_ModEnd> pixRasterop ( pix <S2SV_ModStart> , PIX_SRC , pix <S2SV_ModEnd> , j + <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> } for ( <S2SV_ModStart> , PIX_SRC , pix <S2SV_ModEnd> , j - <S2SV_ModStart> 0 ) ; } } <S2SV_ModEnd> } if (
",CWE-125
107,"CWE-119 Imaging ImagingResampleHorizontal ( Imaging imIn , int xsize , int filter ) { ImagingSectionCookie cookie ; Imaging imOut ; struct filter * filterp ; float support , scale , filterscale ; float center , ww , ss , ss0 , ss1 , ss2 , ss3 ; int xx , yy , x , kmax , xmin , xmax ; int * xbounds ; float * k , * kk ; switch ( filter ) { case IMAGING_TRANSFORM_LANCZOS : filterp = & LANCZOS ; break ; case IMAGING_TRANSFORM_BILINEAR : filterp = & BILINEAR ; break ; case IMAGING_TRANSFORM_BICUBIC : filterp = & BICUBIC ; break ; default : return ( Imaging ) ImagingError_ValueError ( ""unsupported<S2SV_blank>resampling<S2SV_blank>filter"" ) ; } filterscale = scale = ( float ) imIn -> xsize / xsize ; support = filterp -> support ; if ( filterscale < 1.0 ) { filterscale = 1.0 ; } support = support * filterscale ; kmax = ( int ) ceil ( support ) * 2 + 1 ; <S2SV_StartBug> kk = malloc ( xsize * kmax * sizeof ( float ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! kk ) <S2SV_EndBug> return ( Imaging ) ImagingError_MemoryError ( ) ; xbounds = malloc ( xsize * 2 * sizeof ( int ) ) ; if ( ! xbounds ) { free ( kk ) ; return ( Imaging ) ImagingError_MemoryError ( ) ; } for ( xx = 0 ; xx < xsize ; xx ++ ) { k = & kk [ xx * kmax ] ; center = ( xx + 0.5 ) * scale ; ww = 0.0 ; ss = 1.0 / filterscale ; xmin = ( int ) floor ( center - support ) ; if ( xmin < 0 ) xmin = 0 ; xmax = ( int ) ceil ( center + support ) ; if ( xmax > imIn -> xsize ) xmax = imIn -> xsize ; for ( x = xmin ; x < xmax ; x ++ ) { float w = filterp -> filter ( ( x - center + 0.5 ) * ss ) * ss ; k [ x - xmin ] = w ; ww += w ; } for ( x = 0 ; x < xmax - xmin ; x ++ ) { if ( ww != 0.0 ) k [ x ] /= ww ; } xbounds [ xx * 2 + 0 ] = xmin ; xbounds [ xx * 2 + 1 ] = xmax ; } imOut = ImagingNew ( imIn -> mode , xsize , imIn -> ysize ) ; if ( ! imOut ) { free ( kk ) ; free ( xbounds ) ; return NULL ; } ImagingSectionEnter ( & cookie ) ; for ( yy = 0 ; yy < imOut -> ysize ; yy ++ ) { if ( imIn -> image8 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) ss += i2f ( imIn -> image8 [ yy ] [ x ] ) * k [ x - xmin ] ; imOut -> image8 [ yy ] [ xx ] = clip8 ( ss ) ; } } else { switch ( imIn -> type ) { case IMAGING_TYPE_UINT8 : if ( imIn -> bands == 2 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 3 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 3 ] = clip8 ( ss1 ) ; } } else if ( imIn -> bands == 3 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = ss2 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 1 ] ) * k [ x - xmin ] ; ss2 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 2 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 1 ] = clip8 ( ss1 ) ; imOut -> image [ yy ] [ xx * 4 + 2 ] = clip8 ( ss2 ) ; } } else { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = ss2 = ss3 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 1 ] ) * k [ x - xmin ] ; ss2 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 2 ] ) * k [ x - xmin ] ; ss3 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 3 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 1 ] = clip8 ( ss1 ) ; imOut -> image [ yy ] [ xx * 4 + 2 ] = clip8 ( ss2 ) ; imOut -> image [ yy ] [ xx * 4 + 3 ] = clip8 ( ss3 ) ; } } break ; case IMAGING_TYPE_INT32 : for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.0 ; for ( x = xmin ; x < xmax ; x ++ ) ss += i2f ( IMAGING_PIXEL_I ( imIn , x , yy ) ) * k [ x - xmin ] ; IMAGING_PIXEL_I ( imOut , xx , yy ) = ( int ) ss ; } break ; case IMAGING_TYPE_FLOAT32 : for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.0 ; for ( x = xmin ; x < xmax ; x ++ ) ss += IMAGING_PIXEL_F ( imIn , x , yy ) * k [ x - xmin ] ; IMAGING_PIXEL_F ( imOut , xx , yy ) = ss ; } break ; } } } ImagingSectionLeave ( & cookie ) ; free ( kk ) ; free ( xbounds ) ; return imOut ; }
","<S2SV_ModStart> + 1 ; if ( kmax > 0 && xsize > SIZE_MAX / kmax ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize * kmax > SIZE_MAX / sizeof ( float ) ) return ( Imaging ) ImagingError_MemoryError ( ) ; <S2SV_ModStart> ( ! kk ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize > SIZE_MAX / ( 2 * sizeof ( int ) )
",CWE-119
108,"CWE-20 static int do_replace ( struct net * net , const void __user * user , unsigned int len ) { int ret , countersize ; struct ebt_table_info * newinfo ; struct ebt_replace tmp ; if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 ) return - EFAULT ; if ( len != sizeof ( tmp ) + tmp . entries_size ) { BUGPRINT ( ""Wrong<S2SV_blank>len<S2SV_blank>argument\\n"" ) ; return - EINVAL ; } if ( tmp . entries_size == 0 ) { BUGPRINT ( ""Entries_size<S2SV_blank>never<S2SV_blank>zero\\n"" ) ; return - EINVAL ; } if ( tmp . nentries >= ( ( INT_MAX - sizeof ( struct ebt_table_info ) ) / NR_CPUS - SMP_CACHE_BYTES ) / sizeof ( struct ebt_counter ) ) return - ENOMEM ; if ( tmp . num_counters >= INT_MAX / sizeof ( struct ebt_counter ) ) return - ENOMEM ; <S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ; if ( ! newinfo ) return - ENOMEM ; if ( countersize ) memset ( newinfo -> counters , 0 , countersize ) ; newinfo -> entries = vmalloc ( tmp . entries_size ) ; if ( ! newinfo -> entries ) { ret = - ENOMEM ; goto free_newinfo ; } if ( copy_from_user ( newinfo -> entries , tmp . entries , tmp . entries_size ) != 0 ) { BUGPRINT ( ""Couldn\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\n"" ) ; ret = - EFAULT ; goto free_entries ; } ret = do_replace_finish ( net , & tmp , newinfo ) ; if ( ret == 0 ) return ret ; free_entries : vfree ( newinfo -> entries ) ; free_newinfo : vfree ( newinfo ) ; return ret ; }
","<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;
",CWE-20
110,"CWE-770 rfbBool HandleRFBServerMessage ( rfbClient * client ) { rfbServerToClientMsg msg ; if ( client -> serverPort == - 1 ) client -> vncRec -> readTimestamp = TRUE ; if ( ! ReadFromRFBServer ( client , ( char * ) & msg , 1 ) ) return FALSE ; switch ( msg . type ) { case rfbSetColourMapEntries : { break ; } case rfbFramebufferUpdate : { rfbFramebufferUpdateRectHeader rect ; int linesToRead ; int bytesPerLine ; int i ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg . fu ) + 1 , sz_rfbFramebufferUpdateMsg - 1 ) ) return FALSE ; msg . fu . nRects = rfbClientSwap16IfLE ( msg . fu . nRects ) ; for ( i = 0 ; i < msg . fu . nRects ; i ++ ) { if ( ! ReadFromRFBServer ( client , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ) return FALSE ; rect . encoding = rfbClientSwap32IfLE ( rect . encoding ) ; if ( rect . encoding == rfbEncodingLastRect ) break ; rect . r . x = rfbClientSwap16IfLE ( rect . r . x ) ; rect . r . y = rfbClientSwap16IfLE ( rect . r . y ) ; rect . r . w = rfbClientSwap16IfLE ( rect . r . w ) ; rect . r . h = rfbClientSwap16IfLE ( rect . r . h ) ; if ( rect . encoding == rfbEncodingXCursor || rect . encoding == rfbEncodingRichCursor ) { if ( ! HandleCursorShape ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h , rect . encoding ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingPointerPos ) { if ( ! client -> HandleCursorPos ( client , rect . r . x , rect . r . y ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingKeyboardLedState ) { client -> KeyboardLedStateEnabled = 1 ; if ( client -> HandleKeyboardLedState != NULL ) client -> HandleKeyboardLedState ( client , rect . r . x , 0 ) ; client -> CurrentKeyboardLedState = rect . r . x ; continue ; } if ( rect . encoding == rfbEncodingNewFBSize ) { client -> width = rect . r . w ; client -> height = rect . r . h ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , rect . r . w , rect . r . h , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , rect . r . w , rect . r . h ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedMessages ) { int loop ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> supportedMessages , sz_rfbSupportedMessages ) ) return FALSE ; rfbClientLog ( ""client2server<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , loop , client -> supportedMessages . client2server [ loop ] , client -> supportedMessages . client2server [ loop + 1 ] , client -> supportedMessages . client2server [ loop + 2 ] , client -> supportedMessages . client2server [ loop + 3 ] , client -> supportedMessages . client2server [ loop + 4 ] , client -> supportedMessages . client2server [ loop + 5 ] , client -> supportedMessages . client2server [ loop + 6 ] , client -> supportedMessages . client2server [ loop + 7 ] ) ; rfbClientLog ( ""server2client<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , loop , client -> supportedMessages . server2client [ loop ] , client -> supportedMessages . server2client [ loop + 1 ] , client -> supportedMessages . server2client [ loop + 2 ] , client -> supportedMessages . server2client [ loop + 3 ] , client -> supportedMessages . server2client [ loop + 4 ] , client -> supportedMessages . server2client [ loop + 5 ] , client -> supportedMessages . server2client [ loop + 6 ] , client -> supportedMessages . server2client [ loop + 7 ] ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedEncodings ) { char * buffer ; buffer = malloc ( rect . r . w ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } free ( buffer ) ; continue ; } if ( rect . encoding == rfbEncodingServerIdentity ) { char * buffer ; buffer = malloc ( rect . r . w + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } buffer [ rect . r . w ] = 0 ; rfbClientLog ( ""Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\""%s\\""\\n"" , buffer ) ; free ( buffer ) ; continue ; } if ( rect . encoding != rfbEncodingUltraZip ) { if ( ( rect . r . x + rect . r . w > client -> width ) || ( rect . r . y + rect . r . h > client -> height ) ) { rfbClientLog ( ""Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\n"" , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; return FALSE ; } client -> SoftCursorLockArea ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } switch ( rect . encoding ) { case rfbEncodingRaw : { int y = rect . r . y , h = rect . r . h ; bytesPerLine = rect . r . w * client -> format . bitsPerPixel / 8 ; linesToRead = bytesPerLine ? ( RFB_BUFFER_SIZE / bytesPerLine ) : 0 ; while ( linesToRead && h > 0 ) { if ( linesToRead > h ) linesToRead = h ; if ( ! ReadFromRFBServer ( client , client -> buffer , bytesPerLine * linesToRead ) ) return FALSE ; client -> GotBitmap ( client , ( uint8_t * ) client -> buffer , rect . r . x , y , rect . r . w , linesToRead ) ; h -= linesToRead ; y += linesToRead ; } break ; } case rfbEncodingCopyRect : { rfbCopyRect cr ; if ( ! ReadFromRFBServer ( client , ( char * ) & cr , sz_rfbCopyRect ) ) return FALSE ; cr . srcX = rfbClientSwap16IfLE ( cr . srcX ) ; cr . srcY = rfbClientSwap16IfLE ( cr . srcY ) ; client -> SoftCursorLockArea ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h ) ; client -> GotCopyRect ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; break ; } case rfbEncodingRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingCoRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleCoRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleCoRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleCoRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingHextile : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleHextile8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleHextile16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleHextile32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltra : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltra8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltra16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltra32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltraZip : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltraZip8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltraZip16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltraZip32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingTRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleTRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleTRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleTRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleTRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleTRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleTRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZlib8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleZlib16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleZlib32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTight8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleTight16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleTight32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # endif case rfbEncodingZRLE : client -> appData . qualityLevel = 9 ; case rfbEncodingZYWRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleZRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleZRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleZRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleZRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleZRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleZRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # endif default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleEncoding && e -> handleEncoding ( client , & rect ) ) handled = TRUE ; if ( ! handled ) { rfbClientLog ( ""Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\n"" , ( int ) rect . encoding ) ; return FALSE ; } } } client -> SoftCursorUnlockScreen ( client ) ; client -> GotFrameBufferUpdate ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } if ( ! SendIncrementalFramebufferUpdateRequest ( client ) ) return FALSE ; if ( client -> FinishedFrameBufferUpdate ) client -> FinishedFrameBufferUpdate ( client ) ; break ; } case rfbBell : { client -> Bell ( client ) ; break ; } case rfbServerCutText : { char * buffer ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbServerCutTextMsg - 1 ) ) return FALSE ; msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ; if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( ""Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned int ) msg . sct . length ) ; return FALSE ; } buffer = malloc ( msg . sct . length + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . sct . length ] = 0 ; if ( client -> GotXCutText ) client -> GotXCutText ( client , buffer , msg . sct . length ) ; free ( buffer ) ; break ; } case rfbTextChat : { char * buffer = NULL ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbTextChatMsg - 1 ) ) return FALSE ; msg . tc . length = rfbClientSwap32IfLE ( msg . sct . length ) ; switch ( msg . tc . length ) { case rfbTextChatOpen : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Open\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatOpen , NULL ) ; break ; case rfbTextChatClose : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Close\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatClose , NULL ) ; break ; case rfbTextChatFinished : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Finished\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatFinished , NULL ) ; break ; default : <S2SV_StartBug> buffer = malloc ( msg . tc . length + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . tc . length ] = 0 ; rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>\\""%s\\""\\n"" , buffer ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) msg . tc . length , buffer ) ; free ( buffer ) ; break ; } break ; } case rfbXvp : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbXvpMsg - 1 ) ) return FALSE ; SetClient2Server ( client , rfbXvp ) ; SetServer2Client ( client , rfbXvp ) ; if ( client -> HandleXvpMsg ) client -> HandleXvpMsg ( client , msg . xvp . version , msg . xvp . code ) ; break ; } case rfbResizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbResizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . rsfb . framebufferWidth ) ; client -> height = rfbClientSwap16IfLE ( msg . rsfb . framebufferHeigth ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , client -> width , client -> height ) ; break ; } case rfbPalmVNCReSizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbPalmVNCReSizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . prsfb . buffer_w ) ; client -> height = rfbClientSwap16IfLE ( msg . prsfb . buffer_h ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , client -> width , client -> height ) ; break ; } default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleMessage && e -> handleMessage ( client , & msg ) ) handled = TRUE ; if ( ! handled ) { char buffer [ 256 ] ; rfbClientLog ( ""Unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server\\n"" , msg . type ) ; ReadFromRFBServer ( client , buffer , 256 ) ; return FALSE ; } } } return TRUE ; }
","<S2SV_ModStart> ; default : if ( msg . tc . length > MAX_TEXTCHAT_SIZE ) return FALSE ;
",CWE-770
111,"CWE-611 void init_xml_relax_ng ( ) { VALUE nokogiri = rb_define_module ( ""Nokogiri"" ) ; VALUE xml = rb_define_module_under ( nokogiri , ""XML"" ) ; VALUE klass = rb_define_class_under ( xml , ""RelaxNG"" , cNokogiriXmlSchema ) ; cNokogiriXmlRelaxNG = klass ; <S2SV_StartBug> rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ; <S2SV_EndBug> rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ; }
","<S2SV_ModStart> , read_memory , - <S2SV_ModStart> , from_document , -
",CWE-611
115,"CWE-352 char * Util_monitId ( char * idfile ) { <S2SV_StartBug> FILE * file = NULL ; <S2SV_EndBug> ASSERT ( idfile ) ; if ( ! File_exist ( idfile ) ) { <S2SV_StartBug> md5_context_t ctx ; <S2SV_EndBug> char buf [ STRLEN ] ; MD_T digest ; file = fopen ( idfile , ""w"" ) ; if ( ! file ) { LogError ( ""Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } <S2SV_StartBug> snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ; <S2SV_EndBug> md5_init ( & ctx ) ; md5_append ( & ctx , ( const md5_byte_t * ) buf , STRLEN - 1 ) ; md5_finish ( & ctx , ( md5_byte_t * ) digest ) ; Util_digest2Bytes ( ( unsigned char * ) digest , 16 , Run . id ) ; <S2SV_StartBug> fprintf ( file , ""%s"" , Run . id ) ; <S2SV_EndBug> LogInfo ( ""<S2SV_blank>New<S2SV_blank>Monit<S2SV_blank>id:<S2SV_blank>%s\\n<S2SV_blank>Stored<S2SV_blank>in<S2SV_blank>\'%s\'\\n"" , Run . id , idfile ) ; } else { if ( ! File_isFile ( idfile ) ) { LogError ( ""idfile<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file\\n"" , idfile ) ; return NULL ; } if ( ( file = fopen ( idfile , ""r"" ) ) == ( FILE * ) NULL ) { LogError ( ""Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } if ( fscanf ( file , ""%64s"" , Run . id ) != 1 ) { LogError ( ""Error<S2SV_blank>reading<S2SV_blank>id<S2SV_blank>from<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , idfile ) ; if ( fclose ( file ) ) LogError ( ""Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } } if ( fclose ( file ) ) LogError ( ""Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return Run . id ; }
","<S2SV_ModStart> idfile ) { ASSERT ( idfile ) ; <S2SV_ModStart> file = NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { <S2SV_ModEnd> file = fopen <S2SV_ModStart> NULL ; } <S2SV_ModEnd> fprintf ( file <S2SV_ModStart> , ""%s"" , Util_getToken ( Run . id ) <S2SV_ModEnd> ) ; LogInfo
",CWE-352
116,"CWE-125 int ares_parse_a_reply ( const unsigned char * abuf , int alen , struct hostent * * host ) { unsigned int qdcount , ancount ; int status , i , rr_type , rr_class , rr_len , naddrs ; long int len ; int naliases ; const unsigned char * aptr ; char * hostname , * rr_name , * rr_data , * * aliases ; struct in_addr * addrs ; struct hostent * hostent ; * host = NULL ; if ( alen < HFIXEDSZ ) return ARES_EBADRESP ; qdcount = DNS_HEADER_QDCOUNT ( abuf ) ; ancount = DNS_HEADER_ANCOUNT ( abuf ) ; if ( qdcount != 1 ) return ARES_EBADRESP ; aptr = abuf + HFIXEDSZ ; status = ares_expand_name ( aptr , abuf , alen , & hostname , & len ) ; if ( status != ARES_SUCCESS ) return status ; if ( aptr + len + QFIXEDSZ > abuf + alen ) { free ( hostname ) ; return ARES_EBADRESP ; } aptr += len + QFIXEDSZ ; addrs = malloc ( ancount * sizeof ( struct in_addr ) ) ; if ( ! addrs ) { free ( hostname ) ; return ARES_ENOMEM ; } aliases = malloc ( ( ancount + 1 ) * sizeof ( char * ) ) ; if ( ! aliases ) { free ( hostname ) ; free ( addrs ) ; return ARES_ENOMEM ; } naddrs = 0 ; naliases = 0 ; for ( i = 0 ; i < ( int ) ancount ; i ++ ) { status = ares_expand_name ( aptr , abuf , alen , & rr_name , & len ) ; if ( status != ARES_SUCCESS ) break ; aptr += len ; if ( aptr + RRFIXEDSZ > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; } rr_type = DNS_RR_TYPE ( aptr ) ; rr_class = DNS_RR_CLASS ( aptr ) ; rr_len = DNS_RR_LEN ( aptr ) ; <S2SV_StartBug> aptr += RRFIXEDSZ ; <S2SV_EndBug> if ( rr_class == C_IN && rr_type == T_A && rr_len == sizeof ( struct in_addr ) && strcasecmp ( rr_name , hostname ) == 0 ) { memcpy ( & addrs [ naddrs ] , aptr , sizeof ( struct in_addr ) ) ; naddrs ++ ; status = ARES_SUCCESS ; } if ( rr_class == C_IN && rr_type == T_CNAME ) { aliases [ naliases ] = rr_name ; naliases ++ ; status = ares_expand_name ( aptr , abuf , alen , & rr_data , & len ) ; if ( status != ARES_SUCCESS ) break ; free ( hostname ) ; hostname = rr_data ; } else free ( rr_name ) ; aptr += rr_len ; if ( aptr > abuf + alen ) { status = ARES_EBADRESP ; break ; } } if ( status == ARES_SUCCESS && naddrs == 0 ) status = ARES_ENODATA ; if ( status == ARES_SUCCESS ) { aliases [ naliases ] = NULL ; hostent = malloc ( sizeof ( struct hostent ) ) ; if ( hostent ) { hostent -> h_addr_list = malloc ( ( naddrs + 1 ) * sizeof ( char * ) ) ; if ( hostent -> h_addr_list ) { hostent -> h_name = hostname ; hostent -> h_aliases = aliases ; hostent -> h_addrtype = AF_INET ; hostent -> h_length = sizeof ( struct in_addr ) ; for ( i = 0 ; i < naddrs ; i ++ ) hostent -> h_addr_list [ i ] = ( char * ) & addrs [ i ] ; hostent -> h_addr_list [ naddrs ] = NULL ; * host = hostent ; return ARES_SUCCESS ; } free ( hostent ) ; } status = ARES_ENOMEM ; } for ( i = 0 ; i < naliases ; i ++ ) free ( aliases [ i ] ) ; free ( aliases ) ; free ( addrs ) ; free ( hostname ) ; return status ; }
","<S2SV_ModStart> += RRFIXEDSZ ; if ( aptr + rr_len > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; }
",CWE-125
118,"CWE-90 kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_timestamp now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; if ( entry == NULL ) return EINVAL ; if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = calloc ( 1 , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = ts_incr ( now , polent . pw_max_life ) ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; ret = krb5_copy_principal ( handle -> context , entry -> principal , & kdb -> princ ) ; if ( ret ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }
","<S2SV_ModStart> return KADM5_BAD_MASK ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } }
",CWE-90
120,"CWE-264 static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCKED ; atomic_inc ( & sb -> s_active ) ; mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; lock_mount_hash ( ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; unlock_mount_hash ( ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED ) || IS_MNT_SHARED ( old ) ) list_add ( & mnt -> mnt_share , & old -> mnt_share ) ; if ( IS_MNT_SLAVE ( old ) ) list_add ( & mnt -> mnt_slave , & old -> mnt_slave ) ; mnt -> mnt_master = old -> mnt_master ; } if ( flag & CL_MAKE_SHARED ) set_mnt_shared ( mnt ) ; if ( flag & CL_EXPIRE ) { if ( ! list_empty ( & old -> mnt_expire ) ) list_add ( & mnt -> mnt_expire , & old -> mnt_expire ) ; } return mnt ; out_free : mnt_free_id ( mnt ) ; free_vfsmnt ( mnt ) ; return ERR_PTR ( err ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> flag & CL_UNPRIVILEGED <S2SV_ModStart> & CL_UNPRIVILEGED ) { mnt -> mnt . mnt_flags |= MNT_LOCK_ATIME ; if <S2SV_ModEnd> ( mnt -> <S2SV_ModStart> mnt_flags & MNT_READONLY <S2SV_ModEnd> ) mnt -> <S2SV_ModStart> ; if ( mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ; if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ; if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ; } if (
",CWE-264
121,"CWE-476 int writefile ( const char * name , struct string * s ) { FILE * f ; int ret ; f = fopen ( name , ""w"" ) ; if ( ! f ) { warn ( ""open<S2SV_blank>%s:"" , name ) ; return - 1 ; } ret = 0 ; <S2SV_StartBug> if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) { <S2SV_EndBug> warn ( ""write<S2SV_blank>%s:"" , name ) ; ret = - 1 ; } fclose ( f ) ; return ret ; }
","<S2SV_ModStart> ; if ( s && ( <S2SV_ModStart> ) != 0 )
",CWE-476
122,"CWE-119 SNDFILE * sf_open_virtual ( SF_VIRTUAL_IO * sfvirtual , int mode , SF_INFO * sfinfo , void * user_data ) { SF_PRIVATE * psf ; if ( sfvirtual -> get_filelen == NULL || sfvirtual -> seek == NULL || sfvirtual -> tell == NULL ) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf ( sf_parselog , sizeof ( sf_parselog ) , ""Bad<S2SV_blank>vio_get_filelen<S2SV_blank>/<S2SV_blank>vio_seek<S2SV_blank>/<S2SV_blank>vio_tell<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n"" ) ; return NULL ; } ; if ( ( mode == SFM_READ || mode == SFM_RDWR ) && sfvirtual -> read == NULL ) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf ( sf_parselog , sizeof ( sf_parselog ) , ""Bad<S2SV_blank>vio_read<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n"" ) ; return NULL ; } ; if ( ( mode == SFM_WRITE || mode == SFM_RDWR ) && sfvirtual -> write == NULL ) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf ( sf_parselog , sizeof ( sf_parselog ) , ""Bad<S2SV_blank>vio_write<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n"" ) ; return NULL ; } ; <S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug> { sf_errno = SFE_MALLOC_FAILED ; return NULL ; } ; psf_init_files ( psf ) ; psf -> virtual_io = SF_TRUE ; psf -> vio = * sfvirtual ; psf -> vio_user_data = user_data ; psf -> file . mode = mode ; return psf_open_file ( psf , sfinfo ) ; }
","<S2SV_ModStart> ( psf = psf_allocate ( <S2SV_ModEnd> ) ) ==
",CWE-119
124,"CWE-119 int yr_object_array_set_item ( YR_OBJECT * object , YR_OBJECT * item , int index ) { YR_OBJECT_ARRAY * array ; int i ; int count ; assert ( index >= 0 ) ; assert ( object -> type == OBJECT_TYPE_ARRAY ) ; array = object_as_array ( object ) ; if ( array -> items == NULL ) { <S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; memset ( array -> items -> objects , 0 , count * sizeof ( YR_OBJECT * ) ) ; array -> items -> count = count ; } else if ( index >= array -> items -> count ) { count = array -> items -> count * 2 ; <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; for ( i = array -> items -> count ; i < count ; i ++ ) array -> items -> objects [ i ] = NULL ; array -> items -> count = count ; } item -> parent = object ; array -> items -> objects [ index ] = item ; return ERROR_SUCCESS ; }
","<S2SV_ModStart> { count = 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> ; array -> <S2SV_ModStart> * 2 ; while ( count <= index ) count *= 2 ;
",CWE-119
125,"CWE-125 static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; <S2SV_StartBug> if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; <S2SV_StartBug> else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }
","<S2SV_ModStart> ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && <S2SV_ModStart> else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) &&
",CWE-125
129,"CWE-552 static ssize_t _hostsock_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( desc ) ; void * buf = NULL ; <S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> if ( ! sock || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_sendv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }
","<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",CWE-552
131,"CWE-20 int auth_password ( Authctxt * authctxt , const char * password ) { struct passwd * pw = authctxt -> pw ; int result , ok = authctxt -> valid ; # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) static int expire_checked = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> # ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ; # endif if ( * password == '\\0' && options . permit_empty_passwd == 0 ) return 0 ; # ifdef KRB5 if ( options . kerberos_authentication == 1 ) { int ret = auth_krb5_password ( authctxt , password ) ; if ( ret == 1 || ret == 0 ) return ret && ok ; } # endif # ifdef HAVE_CYGWIN { HANDLE hToken = cygwin_logon_user ( pw , password ) ; if ( hToken == INVALID_HANDLE_VALUE ) return 0 ; cygwin_set_impersonation_token ( hToken ) ; return ok ; } # endif # ifdef USE_PAM if ( options . use_pam ) return ( sshpam_auth_passwd ( authctxt , password ) && ok ) ; # endif # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) if ( ! expire_checked ) { expire_checked = 1 ; if ( auth_shadow_pwexpired ( authctxt ) ) authctxt -> force_pwchange = 1 ; } # endif result = sys_auth_passwd ( authctxt , password ) ; if ( authctxt -> force_pwchange ) disable_forwarding ( ) ; return ( result && ok ) ; }
","<S2SV_ModStart> ; # endif if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ;
",CWE-20
132,"CWE-119 int nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeargs * args ) { unsigned int len , v , hdr , dlen ; u32 max_blocksize = svc_max_payload ( rqstp ) ; struct kvec * head = rqstp -> rq_arg . head ; struct kvec * tail = rqstp -> rq_arg . tail ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; args -> count = ntohl ( * p ++ ) ; args -> stable = ntohl ( * p ++ ) ; <S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> if ( args -> count != args -> len ) return 0 ; hdr = ( void * ) p - head -> iov_base ; dlen = head -> iov_len + rqstp -> rq_arg . page_len + tail -> iov_len - hdr ; if ( dlen < XDR_QUADLEN ( len ) * 4 ) return 0 ; if ( args -> count > max_blocksize ) { args -> count = max_blocksize ; len = args -> len = max_blocksize ; } rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }
","<S2SV_ModStart> p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0
",CWE-119
135,"CWE-119 void WT_NoiseGenerator ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 nInterpolatedSample ; EAS_I32 numSamples ; <S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; tmp0 = ( EAS_I32 ) ( pWTVoice -> phaseAccum ) >> 18 ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; while ( numSamples -- ) { nInterpolatedSample = MULT_AUDIO_COEF ( tmp0 , ( PHASE_ONE - pWTVoice -> phaseFrac ) ) ; nInterpolatedSample += MULT_AUDIO_COEF ( tmp1 , pWTVoice -> phaseFrac ) ; * pOutputBuffer ++ = ( EAS_PCM ) nInterpolatedSample ; pWTVoice -> phaseFrac += ( EAS_U32 ) phaseInc ; if ( GET_PHASE_INT_PART ( pWTVoice -> phaseFrac ) ) { tmp0 = tmp1 ; pWTVoice -> phaseAccum = pWTVoice -> loopEnd ; pWTVoice -> loopEnd = ( 5 * pWTVoice -> loopEnd + 1 ) ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; pWTVoice -> phaseFrac = GET_PHASE_FRAC_PART ( pWTVoice -> phaseFrac ) ; } } }
","<S2SV_ModStart> -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; }
",CWE-119
136,"CWE-200 void __ip_select_ident ( struct iphdr * iph , int segs ) { static u32 ip_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }
","<S2SV_ModStart> ip_idents_hashrnd __read_mostly ; static u32 ip_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> sizeof ( ip_idents_hashrnd ) ) ; net_get_random_once ( & ip_idents_hashrnd_extra , sizeof ( ip_idents_hashrnd_extra <S2SV_ModStart> iph -> protocol ^ ip_idents_hashrnd_extra
",CWE-200
140,"CWE-119 static void txfm_rd_in_plane ( MACROBLOCK * x , int * rate , int64_t * distortion , int * skippable , int64_t * sse , int64_t ref_best_rd , int plane , BLOCK_SIZE bsize , TX_SIZE tx_size , int use_fast_coef_casting ) { MACROBLOCKD * const xd = & x -> e_mbd ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> struct rdcost_block_args args = { 0 } ; <S2SV_EndBug> args . x = x ; args . best_rd = ref_best_rd ; <S2SV_StartBug> args . use_fast_coef_costing = use_fast_coef_casting ; <S2SV_EndBug> if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ; vp9_get_entropy_contexts ( bsize , tx_size , pd , args . t_above , args . t_left ) ; args . so = get_scan ( xd , tx_size , pd -> plane_type , 0 ) ; vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , block_rd_txfm , & args ) ; <S2SV_StartBug> if ( args . skip ) { <S2SV_EndBug> * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } else { * distortion = args . this_dist ; * rate = args . this_rate ; * sse = args . this_sse ; <S2SV_StartBug> * skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> struct rdcost_block_args args ; vp9_zero ( args ) <S2SV_ModEnd> ; args . <S2SV_ModStart> use_fast_coef_costing = use_fast_coef_casting ; args . skippable = 1 <S2SV_ModStart> ( args . exit_early <S2SV_ModEnd> ) { * <S2SV_ModStart> * skippable = args . skippable <S2SV_ModEnd> ; } }
",CWE-119
144,"CWE-416 GF_Err audio_sample_entry_Read ( GF_Box * s , GF_BitStream * bs ) { GF_MPEGAudioSampleEntryBox * ptr ; char * data ; u8 a , b , c , d ; u32 i , size , v , nb_alnum ; GF_Err e ; u64 pos , start ; ptr = ( GF_MPEGAudioSampleEntryBox * ) s ; start = gf_bs_get_position ( bs ) ; gf_bs_seek ( bs , start + 8 ) ; v = gf_bs_read_u16 ( bs ) ; if ( v ) ptr -> is_qtff = 1 ; if ( v == 1 ) { gf_bs_seek ( bs , start + 8 + 20 + 4 ) ; a = gf_bs_read_u8 ( bs ) ; b = gf_bs_read_u8 ( bs ) ; c = gf_bs_read_u8 ( bs ) ; d = gf_bs_read_u8 ( bs ) ; nb_alnum = 0 ; if ( isalnum ( a ) ) nb_alnum ++ ; if ( isalnum ( b ) ) nb_alnum ++ ; if ( isalnum ( c ) ) nb_alnum ++ ; if ( isalnum ( d ) ) nb_alnum ++ ; if ( nb_alnum > 2 ) ptr -> is_qtff = 0 ; } gf_bs_seek ( bs , start ) ; e = gf_isom_audio_sample_entry_read ( ( GF_AudioSampleEntryBox * ) s , bs ) ; if ( e ) return e ; pos = gf_bs_get_position ( bs ) ; size = ( u32 ) s -> size ; if ( gf_bs_get_cookie ( bs ) ) { ptr -> is_qtff |= 1 << 16 ; } e = gf_isom_box_array_read ( s , bs , audio_sample_entry_AddBox ) ; if ( ! e ) return GF_OK ; if ( size < 8 ) return GF_ISOM_INVALID_FILE ; gf_bs_seek ( bs , pos ) ; data = ( char * ) gf_malloc ( sizeof ( char ) * size ) ; gf_bs_read_data ( bs , data , size ) ; for ( i = 0 ; i < size - 8 ; i ++ ) { if ( GF_4CC ( ( u32 ) data [ i + 4 ] , ( u8 ) data [ i + 5 ] , ( u8 ) data [ i + 6 ] , ( u8 ) data [ i + 7 ] ) == GF_ISOM_BOX_TYPE_ESDS ) { <S2SV_StartBug> GF_BitStream * mybs = gf_bs_new ( data + i , size - i , GF_BITSTREAM_READ ) ; <S2SV_EndBug> if ( ptr -> esd ) { <S2SV_StartBug> gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ; <S2SV_EndBug> ptr -> esd = NULL ; } e = gf_isom_box_parse ( ( GF_Box * * ) & ptr -> esd , mybs ) ; if ( e == GF_OK ) { gf_isom_box_add_for_dump_mode ( ( GF_Box * ) ptr , ( GF_Box * ) ptr -> esd ) ; } else if ( ptr -> esd ) { gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ; ptr -> esd = NULL ; } gf_bs_del ( mybs ) ; break ; } } gf_free ( data ) ; return e ; }
","<S2SV_ModStart> GF_ISOM_BOX_TYPE_ESDS ) { extern Bool use_dump_mode ; <S2SV_ModStart> esd ) { if ( ! use_dump_mode )
",CWE-416
145,"CWE-119 static EAS_RESULT PushcdlStack ( EAS_U32 * pStack , EAS_INT * pStackPtr , EAS_U32 value ) { <S2SV_StartBug> if ( * pStackPtr >= CDL_STACK_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return EAS_ERROR_FILE_FORMAT ; <S2SV_EndBug> * pStackPtr = * pStackPtr + 1 ; pStack [ * pStackPtr ] = value ; return EAS_SUCCESS ; }
","<S2SV_ModStart> * pStackPtr >= ( CDL_STACK_SIZE - 1 ) ) { ALOGE ( ""b/34031018,<S2SV_blank>stackPtr(%d)"" , * pStackPtr ) ; android_errorWriteLog ( 0x534e4554 , ""34031018"" ) ; <S2SV_ModEnd> return EAS_ERROR_FILE_FORMAT ; <S2SV_ModStart> return EAS_ERROR_FILE_FORMAT ; }
",CWE-119
148,"CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , ""200"" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , ""201"" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( ""%s"" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , ""MODE<S2SV_blank>READER\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , ""200"" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , ""201"" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode"" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( ""Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s"" ) , conn -> account . host , posting ? _ ( ""Posting<S2SV_blank>is<S2SV_blank>ok"" ) : _ ( ""Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok"" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , ""STARTTLS\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , ""382"" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( ""STARTTLS:<S2SV_blank>%s"" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , ""STAT\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , ""480"" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode"" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }
","<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;
",CWE-74
149,"CWE-20 void ArrowHead ( ) { int k ; double length ; SaveGraphicsState ; if ( flip ) length = - arrow . length ; else length = arrow . length ; SetDashSize ( 0 , 0 ) ; if ( arrow . stroke ) { SetLineWidth ( arrow . stroke ) ; for ( k = 1 ; k <= 2 ; k ++ ) { SaveGraphicsState ; MoveTo ( length * 0.5 , 0 ) ; LineTo ( - length * 0.5 , arrow . width ) ; LineTo ( - length * 0.5 + length * arrow . inset , 0 ) ; LineTo ( - length * 0.5 , - arrow . width ) ; if ( k == 1 ) { SetBackgroundColor ( NONSTROKING ) ; <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> } else { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>s"" ) ; <S2SV_EndBug> } RestoreGraphicsState ; } } else { MoveTo ( length * 0.5 , 0 ) ; LineTo ( - length * 0.5 , arrow . width ) ; LineTo ( - length * 0.5 + length * arrow . inset , 0 ) ; LineTo ( - length * 0.5 , - arrow . width ) ; <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> } RestoreGraphicsState ; }
","<S2SV_ModStart> NONSTROKING ) ; send ( <S2SV_ModEnd> ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_ModStart> } else { send ( <S2SV_ModEnd> ""<S2SV_blank>s"" ) ; <S2SV_ModStart> width ) ; send ( <S2SV_ModEnd> ""<S2SV_blank>h<S2SV_blank>f"" ) ;
",CWE-20
150,"CWE-119 void WT_VoiceGain ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_I32 * pMixBuffer ; EAS_PCM * pInputBuffer ; EAS_I32 gain ; EAS_I32 gainIncrement ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 tmp2 ; EAS_I32 numSamples ; # if ( NUM_OUTPUT_CHANNELS == 2 ) EAS_I32 gainLeft , gainRight ; # endif <S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> pMixBuffer = pWTIntFrame -> pMixBuffer ; pInputBuffer = pWTIntFrame -> pAudioBuffer ; gainIncrement = ( pWTIntFrame -> frame . gainTarget - pWTIntFrame -> prevGain ) << ( 16 - SYNTH_UPDATE_PERIOD_IN_BITS ) ; if ( gainIncrement < 0 ) gainIncrement ++ ; gain = pWTIntFrame -> prevGain << 16 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) gainLeft = pWTVoice -> gainLeft ; gainRight = pWTVoice -> gainRight ; # endif while ( numSamples -- ) { tmp0 = * pInputBuffer ++ ; gain += gainIncrement ; tmp2 = gain >> 16 ; tmp2 *= tmp0 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) tmp2 = tmp2 >> 14 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainLeft ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainRight ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; # else tmp1 = * pMixBuffer ; tmp2 = tmp2 >> ( NUM_MIXER_GUARD_BITS - 1 ) ; tmp1 += tmp2 ; * pMixBuffer ++ = tmp1 ; # endif } }
","<S2SV_ModStart> -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; }
",CWE-119
152,"CWE-119 void dvb_usbv2_disconnect ( struct usb_interface * intf ) { struct dvb_usb_device * d = usb_get_intfdata ( intf ) ; <S2SV_StartBug> const char * name = d -> name ; <S2SV_EndBug> <S2SV_StartBug> struct device dev = d -> udev -> dev ; <S2SV_EndBug> dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\n"" , __func__ , intf -> cur_altsetting -> desc . bInterfaceNumber ) ; if ( d -> props -> exit ) d -> props -> exit ( d ) ; dvb_usbv2_exit ( d ) ; <S2SV_StartBug> dev_info ( & dev , ""%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" , <S2SV_EndBug> <S2SV_StartBug> KBUILD_MODNAME , name ) ; <S2SV_EndBug> }
","<S2SV_ModStart> const char * devname = kstrdup ( dev_name ( & <S2SV_ModEnd> d -> udev <S2SV_ModStart> udev -> dev ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModStart> d ) ; pr_info ( ""%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" <S2SV_ModEnd> , KBUILD_MODNAME , <S2SV_ModStart> , KBUILD_MODNAME , drvname , devname ) ; kfree ( devname <S2SV_ModEnd> ) ; }
",CWE-119
154,"CWE-125 static stmt_ty ast_for_for_stmt ( struct compiling * c , const node * n0 , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; asdl_seq * _target , * seq = NULL , * suite_seq ; expr_ty expression ; expr_ty target , first ; const node * node_target ; int end_lineno , end_col_offset ; <S2SV_StartBug> REQ ( n , for_stmt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NCH ( n ) == 9 ) { <S2SV_EndBug> <S2SV_StartBug> seq = ast_for_suite ( c , CHILD ( n , 8 ) ) ; <S2SV_EndBug> if ( ! seq ) return NULL ; } node_target = CHILD ( n , 1 ) ; _target = ast_for_exprlist ( c , node_target , Store ) ; if ( ! _target ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( _target , 0 ) ; if ( NCH ( node_target ) == 1 ) target = first ; else target = Tuple ( _target , Store , first -> lineno , first -> col_offset , node_target -> n_end_lineno , node_target -> n_end_col_offset , c -> c_arena ) ; expression = ast_for_testlist ( c , CHILD ( n , 3 ) ) ; if ( ! expression ) return NULL ; <S2SV_StartBug> suite_seq = ast_for_suite ( c , CHILD ( n , 5 ) ) ; <S2SV_EndBug> if ( ! suite_seq ) return NULL ; if ( seq != NULL ) { get_last_end_pos ( seq , & end_lineno , & end_col_offset ) ; } else { get_last_end_pos ( suite_seq , & end_lineno , & end_col_offset ) ; } <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFor ( target , expression , suite_seq , seq , <S2SV_EndBug> LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return For ( target , expression , suite_seq , seq , <S2SV_EndBug> LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> , end_col_offset ; int has_type_comment ; string type_comment ; <S2SV_ModStart> , for_stmt ) ; has_type_comment = TYPE ( CHILD ( n , 5 ) ) == TYPE_COMMENT <S2SV_ModStart> ) == 9 + has_type_comment <S2SV_ModStart> n , 8 + has_type_comment <S2SV_ModStart> n , 5 + has_type_comment <S2SV_ModStart> } if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , 5 ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; if ( <S2SV_ModStart> , seq , type_comment , <S2SV_ModStart> suite_seq , seq , type_comment
",CWE-125
156,"CWE-200 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug> MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;
",CWE-200
159,"CWE-125 uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>"" ""empty<S2SV_blank>extents<S2SV_blank>btree\\n"" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" ""root<S2SV_blank>node<S2SV_blank>%"" PRIu32 "";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%"" PRIu16 ""\\n"" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file"" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%"" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid"" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%"" PRIu32 ""<S2SV_blank>@<S2SV_blank>%"" PRIu64 ""<S2SV_blank>has<S2SV_blank>%"" PRIu16 ""<S2SV_blank>records\\n"" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%"" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; int keylen ; rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; <S2SV_StartBug> if ( ( keylen ) > nodesize ) { <S2SV_EndBug> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" <S2SV_StartBug> PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; <S2SV_EndBug> free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error"" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d"" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node"" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; int keylen ; rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error"" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf"" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(%"" PRIu64 "")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%"" PRIu8 "")"" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }
","<S2SV_ModStart> ; if ( keylen >= nodesize - rec_off <S2SV_ModEnd> ) { tsk_error_set_errno <S2SV_ModStart> , keylen , ( nodesize - rec_off ) <S2SV_ModEnd> ) ; free
",CWE-125
163,"CWE-476 int mp4boxMain ( int argc , char * * argv ) { u32 i , j ; const char * gpac_profile = ""0"" ; GF_Err e = GF_OK ; nb_tsel_acts = nb_add = nb_cat = nb_track_act = nb_sdp_ex = max_ptime = nb_meta_act = rtp_rate = major_brand = nb_alt_brand_add = nb_alt_brand_rem = car_dur = minor_version = 0 ; split_duration = 0.0 ; split_start = - 1.0 ; interleaving_time = 0 ; dash_duration = dash_subduration = 0.0 ; import_fps . num = import_fps . den = 0 ; import_flags = 0 ; split_size = 0 ; movie_time = 0 ; dump_nal = dump_saps = dump_saps_mode = force_new = 0 ; FullInter = HintInter = encode = do_scene_log = old_interleave = do_saf = do_hash = verbose = do_mpd_rip = merge_vtt_cues = get_nb_tracks = GF_FALSE ; # ifndef GPAC_DISABLE_SCENE_DUMP dump_mode = GF_SM_DUMP_NONE ; # endif Frag = force_ocr = remove_sys_tracks = agg_samples = remove_hint = keep_sys_tracks = remove_root_od = single_group = clean_groups = compress_moov = GF_FALSE ; conv_type = HintIt = needSave = print_sdp = regular_iod = dump_std = open_edit = dump_rtp = dump_cr = dump_srt = dump_ttxt = dump_m2ts = dump_cart = import_subtitle = force_cat = pack_wgt = dash_live = GF_FALSE ; no_fragments_defaults = GF_FALSE ; single_traf_per_moof = hls_clock = GF_FALSE ; tfdt_per_traf = GF_FALSE ; dump_nal_type = 0 ; dump_isom = 0 ; print_info = 0 ; align_cat = GF_TRUE ; subsegs_per_sidx = 0 ; track_dump_type = 0 ; crypt = 0 ; time_shift_depth = 0 ; file = NULL ; itunes_tags = pes_dump = NULL ; seg_name = dash_ctx_file = NULL ; compress_top_boxes = NULL ; initial_moof_sn = 0 ; initial_tfdt = 0 ; # ifndef GPAC_DISABLE_SCENE_ENCODER memset ( & smenc_opts , 0 , sizeof ( smenc_opts ) ) ; # endif trackID = stat_level = hint_flags = 0 ; program_number = 0 ; info_track_id = 0 ; do_flat = 0 ; inName = outName = mediaSource = input_ctx = output_ctx = drm_file = avi2raw = cprt = chap_file = pack_file = raw_cat = high_dynamc_range_filename = use_init_seg = box_patch_filename = NULL ; # ifndef GPAC_DISABLE_SWF_IMPORT swf_flags = GF_SM_SWF_SPLIT_TIMELINE ; # endif swf_flatten_angle = 0.0f ; tmpdir = NULL ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , ""-mem-track"" ) || ! strcmp ( argv [ i ] , ""-mem-track-stack"" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( argv [ i ] , ""-mem-track-stack"" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , ""WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\""%s\\""\\n"" , argv [ i ] ) ; # endif break ; } else if ( ! strcmp ( argv [ i ] , ""-p"" ) ) { if ( i + 1 < ( u32 ) argc ) gpac_profile = argv [ i + 1 ] ; else { fprintf ( stderr , ""Bad<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>-p,<S2SV_blank>expecting<S2SV_blank>profile<S2SV_blank>name<S2SV_blank>but<S2SV_blank>no<S2SV_blank>more<S2SV_blank>args\\n"" ) ; return 1 ; } } else if ( ! strncmp ( argv [ i ] , ""-p="" , 3 ) ) gpac_profile = argv [ i ] + 3 ; } # ifdef _TWO_DIGIT_EXPONENT _set_output_format ( _TWO_DIGIT_EXPONENT ) ; # endif gf_sys_init ( mem_track , gpac_profile ) ; if ( argc < 2 ) { fprintf ( stderr , ""Not<S2SV_blank>enough<S2SV_blank>arguments<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\n"" ""MP4Box<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>version<S2SV_blank>%s\\n"" ""%s\\n"" , gf_gpac_version ( ) , gf_gpac_copyright ( ) ) ; gf_sys_close ( ) ; return 0 ; } helpout = stdout ; i = mp4box_parse_args ( argc , argv ) ; if ( i ) { return mp4box_cleanup ( i - 1 ) ; } if ( ! inName && dump_std ) inName = ""std"" ; if ( ! inName ) { if ( has_next_arg ) { fprintf ( stderr , ""Broken<S2SV_blank>argument<S2SV_blank>specifier<S2SV_blank>or<S2SV_blank>file<S2SV_blank>name<S2SV_blank>missing<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\n"" ) ; } else { PrintUsage ( ) ; } return mp4box_cleanup ( 1 ) ; } if ( ! strcmp ( inName , ""std"" ) ) dump_std = 2 ; if ( ! strcmp ( inName , ""stdb"" ) ) { inName = ""std"" ; dump_std = 1 ; } if ( ! interleaving_time ) { if ( dash_duration ) interleaving_time = dash_duration ; else if ( ! do_flat ) { interleaving_time = DEFAULT_INTERLEAVING_IN_SEC ; } } if ( dump_std ) outName = ""std"" ; if ( dump_std == 2 ) { # ifdef WIN32 if ( _setmode ( _fileno ( stdout ) , _O_BINARY ) == - 1 ) # else if ( freopen ( NULL , ""wb"" , stdout ) == NULL ) # endif { fprintf ( stderr , ""Fatal<S2SV_blank>error:<S2SV_blank>cannot<S2SV_blank>reopen<S2SV_blank>stdout<S2SV_blank>in<S2SV_blank>binary<S2SV_blank>mode.\\n"" ) ; return mp4box_cleanup ( 1 ) ; } } # if ! defined ( GPAC_DISABLE_STREAMING ) && ! defined ( GPAC_DISABLE_SENG ) if ( live_scene ) { int ret = live_session ( argc , argv ) ; return mp4box_cleanup ( ret ) ; } # endif GF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO ; gf_log_set_tool_level ( GF_LOG_CONTAINER , level ) ; gf_log_set_tool_level ( GF_LOG_SCENE , level ) ; gf_log_set_tool_level ( GF_LOG_PARSER , level ) ; gf_log_set_tool_level ( GF_LOG_AUTHOR , level ) ; gf_log_set_tool_level ( GF_LOG_CODING , level ) ; gf_log_set_tool_level ( GF_LOG_DASH , level ) ; # ifdef GPAC_MEMORY_TRACKING if ( mem_track ) gf_log_set_tool_level ( GF_LOG_MEMORY , level ) ; # endif e = gf_sys_set_args ( argc , ( const char * * ) argv ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>assigning<S2SV_blank>libgpac<S2SV_blank>arguments:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } if ( raw_cat ) { char chunk [ 4096 ] ; FILE * fin , * fout ; s64 to_copy , done ; fin = gf_fopen ( raw_cat , ""rb"" ) ; if ( ! fin ) return mp4box_cleanup ( 1 ) ; fout = gf_fopen ( inName , ""a+b"" ) ; if ( ! fout ) { gf_fclose ( fin ) ; return mp4box_cleanup ( 1 ) ; } gf_fseek ( fin , 0 , SEEK_END ) ; to_copy = gf_ftell ( fin ) ; gf_fseek ( fin , 0 , SEEK_SET ) ; done = 0 ; while ( 1 ) { u32 nb_bytes = ( u32 ) gf_fread ( chunk , 4096 , fin ) ; gf_fwrite ( chunk , nb_bytes , fout ) ; done += nb_bytes ; fprintf ( stderr , ""Appending<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%02.2f<S2SV_blank>done\\r"" , raw_cat , 100.0 * done / to_copy ) ; if ( done >= to_copy ) break ; } gf_fclose ( fin ) ; gf_fclose ( fout ) ; return mp4box_cleanup ( 0 ) ; } if ( compress_top_boxes ) { if ( size_top_box ) { u64 top_size = do_size_top_boxes ( inName , compress_top_boxes , size_top_box ) ; fprintf ( stdout , LLU ""\\n"" , top_size ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } else { e = do_compress_top_boxes ( inName , outName , compress_top_boxes , comp_top_box_version , comp_lzma ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } } if ( do_mpd_rip ) { e = rip_mpd ( inName , outName ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } # ifndef GPAC_DISABLE_CORE_TOOLS if ( do_wget != NULL ) { e = gf_dm_wget ( do_wget , inName , 0 , 0 , NULL ) ; if ( e != GF_OK ) { fprintf ( stderr , ""Cannot<S2SV_blank>retrieve<S2SV_blank>%s:<S2SV_blank>%s\\n"" , do_wget , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } return mp4box_cleanup ( 0 ) ; } # endif if ( udp_dest ) { GF_Socket * sock = gf_sk_new ( GF_SOCK_TYPE_UDP ) ; u16 port = 2345 ; char * sep = strrchr ( udp_dest , ':' ) ; if ( sep ) { sep [ 0 ] = 0 ; port = atoi ( sep + 1 ) ; } e = gf_sk_bind ( sock , ""127.0.0.1"" , 0 , udp_dest , port , 0 ) ; if ( sep ) sep [ 0 ] = ':' ; if ( e ) fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>%s\\n"" , udp_dest , gf_error_to_string ( e ) ) ; else { e = gf_sk_send ( sock , ( u8 * ) inName , ( u32 ) strlen ( inName ) ) ; if ( e ) fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>datagram:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; } gf_sk_del ( sock ) ; return 0 ; } # ifndef GPAC_DISABLE_MPD if ( do_mpd ) { Bool remote = GF_FALSE ; GF_MPD * mpd ; char * mpd_base_url = NULL ; if ( ! strnicmp ( inName , ""http://"" , 7 ) || ! strnicmp ( inName , ""https://"" , 8 ) ) { # if ! defined ( GPAC_DISABLE_CORE_TOOLS ) e = gf_dm_wget ( inName , ""tmp_main.m3u8"" , 0 , 0 , & mpd_base_url ) ; if ( e != GF_OK ) { fprintf ( stderr , ""Cannot<S2SV_blank>retrieve<S2SV_blank>M3U8<S2SV_blank>(%s):<S2SV_blank>%s\\n"" , inName , gf_error_to_string ( e ) ) ; if ( mpd_base_url ) gf_free ( mpd_base_url ) ; return mp4box_cleanup ( 1 ) ; } remote = GF_TRUE ; # else gf_free ( mpd_base_url ) ; fprintf ( stderr , ""HTTP<S2SV_blank>Downloader<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build\\n"" ) ; return mp4box_cleanup ( 1 ) ; # endif if ( outName ) strcpy ( outfile , outName ) ; else { const char * sep = gf_file_basename ( inName ) ; char * ext = gf_file_ext_start ( sep ) ; if ( ext ) ext [ 0 ] = 0 ; sprintf ( outfile , ""%s.mpd"" , sep ) ; if ( ext ) ext [ 0 ] = '.' ; } } else { if ( outName ) strcpy ( outfile , outName ) ; else { char * dst = strdup ( inName ) ; char * ext = strstr ( dst , "".m3u8"" ) ; if ( ext ) ext [ 0 ] = 0 ; sprintf ( outfile , ""%s.mpd"" , dst ) ; gf_free ( dst ) ; } } mpd = gf_mpd_new ( ) ; if ( ! mpd ) { e = GF_OUT_OF_MEM ; fprintf ( stderr , ""[DASH]<S2SV_blank>Error:<S2SV_blank>MPD<S2SV_blank>creation<S2SV_blank>problem<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; mp4box_cleanup ( 1 ) ; } FILE * f = gf_fopen ( remote ? ""tmp_main.m3u8"" : inName , ""r"" ) ; u32 manif_type = 0 ; if ( f ) { char szDATA [ 1000 ] ; s32 read ; szDATA [ 999 ] = 0 ; read = ( s32 ) gf_fread ( szDATA , 999 , f ) ; if ( read < 0 ) read = 0 ; szDATA [ read ] = 0 ; gf_fclose ( f ) ; if ( strstr ( szDATA , ""SmoothStreamingMedia"" ) ) manif_type = 2 ; else if ( strstr ( szDATA , ""#EXTM3U"" ) ) manif_type = 1 ; } if ( manif_type == 1 ) { e = gf_m3u8_to_mpd ( remote ? ""tmp_main.m3u8"" : inName , mpd_base_url ? mpd_base_url : inName , outfile , 0 , ""video/mp2t"" , GF_TRUE , use_url_template , segment_timeline , NULL , mpd , GF_TRUE , GF_TRUE ) ; } else if ( manif_type == 2 ) { e = gf_mpd_smooth_to_mpd ( remote ? ""tmp_main.m3u8"" : inName , mpd , mpd_base_url ? mpd_base_url : inName ) ; } else { e = GF_NOT_SUPPORTED ; } if ( ! e ) gf_mpd_write_file ( mpd , outfile ) ; if ( mpd ) gf_mpd_del ( mpd ) ; if ( mpd_base_url ) gf_free ( mpd_base_url ) ; if ( remote ) { gf_file_delete ( ""tmp_main.m3u8"" ) ; } if ( e != GF_OK ) { fprintf ( stderr , ""Error<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s):<S2SV_blank>%s\\n"" , ( manif_type == 1 ) ? ""HLS"" : ""Smooth"" , inName , outfile , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } else { fprintf ( stderr , ""Done<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s)\\n"" , ( manif_type == 1 ) ? ""HLS"" : ""Smooth"" , inName , outfile ) ; return mp4box_cleanup ( 0 ) ; } } # endif if ( dash_duration && ! nb_dash_inputs ) { dash_inputs = set_dash_input ( dash_inputs , inName , & nb_dash_inputs ) ; } if ( do_saf && ! encode ) { switch ( get_file_type_by_ext ( inName ) ) { case GF_FILE_TYPE_BT_WRL_X3DV : case GF_FILE_TYPE_XMT_X3D : case GF_FILE_TYPE_SVG : encode = GF_TRUE ; break ; case GF_FILE_TYPE_NOT_SUPPORTED : case GF_FILE_TYPE_ISO_MEDIA : case GF_FILE_TYPE_SWF : case GF_FILE_TYPE_LSR_SAF : break ; } } # ifndef GPAC_DISABLE_SCENE_DUMP if ( dump_mode == GF_SM_DUMP_SVG ) { if ( strstr ( inName , "".srt"" ) || strstr ( inName , "".ttxt"" ) ) import_subtitle = 2 ; } # endif if ( import_subtitle && ! trackID ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT GF_MediaImporter import ; file = gf_isom_open ( ""ttxt_convert"" , GF_ISOM_OPEN_WRITE , NULL ) ; if ( timescale && file ) gf_isom_set_timescale ( file , timescale ) ; memset ( & import , 0 , sizeof ( GF_MediaImporter ) ) ; import . dest = file ; import . in_name = inName ; e = gf_media_import ( & import ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\n"" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_file_delete ( ""ttxt_convert"" ) ; return mp4box_cleanup ( 1 ) ; } strcpy ( outfile , inName ) ; if ( strchr ( outfile , '.' ) ) { while ( outfile [ strlen ( outfile ) - 1 ] != '.' ) outfile [ strlen ( outfile ) - 1 ] = 0 ; outfile [ strlen ( outfile ) - 1 ] = 0 ; } # ifndef GPAC_DISABLE_ISOM_DUMP dump_isom_timed_text ( file , gf_isom_get_track_id ( file , 1 ) , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_TRUE , ( import_subtitle == 2 ) ? GF_TEXTDUMPTYPE_SVG : ( dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ) ; # endif gf_isom_delete ( file ) ; gf_file_delete ( ""ttxt_convert"" ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>converting<S2SV_blank>%s:<S2SV_blank>%s\\n"" , inName , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } return mp4box_cleanup ( 0 ) ; # else fprintf ( stderr , ""Feature<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return mp4box_cleanup ( 1 ) ; # endif } # if ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) && ! defined ( GPAC_DISABLE_ISOM_WRITE ) if ( nb_add || nb_cat ) { u32 ipass , nb_pass = 1 ; char * mux_args = NULL ; GF_FilterSession * fs = NULL ; if ( nb_add ) { GF_ISOOpenMode open_mode = GF_ISOM_OPEN_EDIT ; if ( force_new ) { open_mode = ( do_flat || ( force_new == 2 ) ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; } else { FILE * test = gf_fopen ( inName , ""rb"" ) ; if ( ! test ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } else { gf_fclose ( test ) ; if ( ! gf_isom_probe_file ( inName ) ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } } } open_edit = do_flat ? GF_FALSE : GF_TRUE ; file = gf_isom_open ( inName , open_mode , tmpdir ) ; if ( ! file ) { fprintf ( stderr , ""Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\n"" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } if ( freeze_box_order ) gf_isom_freeze_order ( file ) ; } if ( do_flat && interleaving_time ) { char szSubArg [ 100 ] ; gf_isom_set_storage_mode ( file , GF_ISOM_STORE_FASTSTART ) ; do_flat = 2 ; nb_pass = 2 ; fs = gf_fs_new_defaults ( 0 ) ; if ( ! fs ) { fprintf ( stderr , ""Error<S2SV_blank>creating<S2SV_blank>filter<S2SV_blank>session\\n"" ) ; gf_isom_delete ( file ) ; return mp4box_cleanup ( 1 ) ; } gf_dynstrcat ( & mux_args , ""mp4mx:importer:store=fstart"" , "":"" ) ; sprintf ( szSubArg , ""file=%p"" , file ) ; gf_dynstrcat ( & mux_args , szSubArg , "":"" ) ; sprintf ( szSubArg , ""cdur=%g"" , interleaving_time ) ; gf_dynstrcat ( & mux_args , szSubArg , "":"" ) ; } for ( ipass = 0 ; ipass < nb_pass ; ipass ++ ) { u32 tk_idx = 1 ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { char * margs = NULL ; if ( ! strcmp ( argv [ i ] , ""-add"" ) ) { char * src = argv [ i + 1 ] ; while ( src ) { char * loc_src = src ; char * sep = NULL ; while ( 1 ) { char * opt_sep ; sep = strchr ( loc_src , '+' ) ; if ( ! sep ) break ; sep [ 0 ] = 0 ; if ( strstr ( src , ""://"" ) ) break ; opt_sep = gf_url_colon_suffix ( src ) ; if ( opt_sep ) opt_sep [ 0 ] = 0 ; if ( gf_file_exists ( src ) ) { if ( opt_sep ) opt_sep [ 0 ] = ':' ; break ; } if ( opt_sep ) opt_sep [ 0 ] = ':' ; sep [ 0 ] = '+' ; loc_src = sep + 1 ; } e = import_file ( file , src , import_flags , import_fps , agg_samples , fs , ( fs && ( ipass == 0 ) ) ? & margs : NULL , tk_idx ) ; tk_idx ++ ; if ( margs ) { gf_dynstrcat ( & mux_args , margs , "":"" ) ; gf_free ( margs ) ; } if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\n"" , argv [ i + 1 ] , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; if ( fs ) gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } if ( sep ) { sep [ 0 ] = '+' ; src = sep + 1 ; } else { break ; } } i ++ ; } else if ( ! strcmp ( argv [ i ] , ""-cat"" ) || ! strcmp ( argv [ i ] , ""-catx"" ) || ! strcmp ( argv [ i ] , ""-catpl"" ) ) { if ( nb_pass == 2 ) { fprintf ( stderr , ""Cannot<S2SV_blank>cat<S2SV_blank>files<S2SV_blank>when<S2SV_blank>using<S2SV_blank>-newfs<S2SV_blank>mode\\n"" ) ; return mp4box_cleanup ( 1 ) ; } if ( ! file ) { u8 open_mode = GF_ISOM_OPEN_EDIT ; if ( force_new ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; } else { FILE * test = gf_fopen ( inName , ""rb"" ) ; if ( ! test ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } else gf_fclose ( test ) ; } open_edit = GF_TRUE ; file = gf_isom_open ( inName , open_mode , tmpdir ) ; if ( ! file ) { fprintf ( stderr , ""Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\n"" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } } e = cat_isomedia_file ( file , argv [ i + 1 ] , import_flags , import_fps , agg_samples , tmpdir , force_cat , align_cat , ! strcmp ( argv [ i ] , ""-catx"" ) ? GF_TRUE : GF_FALSE , ! strcmp ( argv [ i ] , ""-catpl"" ) ? GF_TRUE : GF_FALSE ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>appending<S2SV_blank>%s:<S2SV_blank>%s\\n"" , argv [ i + 1 ] , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; return mp4box_cleanup ( 1 ) ; } i ++ ; } } if ( ( nb_pass == 2 ) && ! ipass ) { GF_Filter * mux_filter = gf_fs_load_filter ( fs , mux_args , NULL ) ; gf_free ( mux_args ) ; if ( ! mux_filter ) { fprintf ( stderr , ""Error<S2SV_blank>loadin<S2SV_blank>isobmff<S2SV_blank>mux<S2SV_blank>filter\\n"" ) ; gf_isom_delete ( file ) ; gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } e = gf_fs_run ( fs ) ; if ( e == GF_EOS ) e = GF_OK ; if ( ! e ) e = gf_fs_get_last_connect_error ( fs ) ; if ( ! e ) e = gf_fs_get_last_process_error ( fs ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>importing<S2SV_blank>sources:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } } } if ( fs ) { if ( fs_dump_flags & 1 ) gf_fs_print_stats ( fs ) ; if ( fs_dump_flags & 2 ) gf_fs_print_connections ( fs ) ; gf_fs_del ( fs ) ; } # ifndef GPAC_DISABLE_AV_PARSERS if ( ! keep_sys_tracks ) remove_systems_tracks ( file ) ; # endif needSave = GF_TRUE ; } # endif # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_SCENE_ENCODER ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) else if ( chunk_mode ) { if ( ! inName ) { fprintf ( stderr , ""chunk<S2SV_blank>encoding<S2SV_blank>syntax:<S2SV_blank>[-outctx<S2SV_blank>outDump]<S2SV_blank>-inctx<S2SV_blank>inScene<S2SV_blank>auFile\\n"" ) ; return mp4box_cleanup ( 1 ) ; } e = EncodeFileChunk ( inName , outName ? outName : inName , input_ctx , output_ctx , tmpdir ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>encoding<S2SV_blank>chunk<S2SV_blank>file<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } goto exit ; } # endif else if ( encode ) { # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_SCENE_ENCODER ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) FILE * logs = NULL ; if ( do_scene_log ) { char alogfile [ GF_MAX_PATH ] ; strcpy ( alogfile , inName ) ; if ( strchr ( alogfile , '.' ) ) { while ( alogfile [ strlen ( alogfile ) - 1 ] != '.' ) alogfile [ strlen ( alogfile ) - 1 ] = 0 ; alogfile [ strlen ( alogfile ) - 1 ] = 0 ; } strcat ( alogfile , ""_enc.logs"" ) ; logs = gf_fopen ( alogfile , ""wt"" ) ; } strcpy ( outfile , outName ? outName : inName ) ; if ( strchr ( outfile , '.' ) ) { while ( outfile [ strlen ( outfile ) - 1 ] != '.' ) outfile [ strlen ( outfile ) - 1 ] = 0 ; outfile [ strlen ( outfile ) - 1 ] = 0 ; } strcat ( outfile , "".mp4"" ) ; file = gf_isom_open ( outfile , GF_ISOM_WRITE_EDIT , tmpdir ) ; smenc_opts . mediaSource = mediaSource ? mediaSource : outfile ; e = EncodeFile ( inName , file , & smenc_opts , logs ) ; if ( logs ) gf_fclose ( logs ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( do_saf ) { needSave = GF_FALSE ; open_edit = GF_FALSE ; } # endif } # ifndef GPAC_DISABLE_ISOM_WRITE else if ( pack_file ) { char * fileName = gf_url_colon_suffix ( pack_file ) ; if ( fileName && ( ( fileName - pack_file ) == 4 ) ) { fileName [ 0 ] = 0 ; file = package_file ( fileName + 1 , pack_file , tmpdir , pack_wgt ) ; fileName [ 0 ] = ':' ; } else { file = package_file ( pack_file , NULL , tmpdir , pack_wgt ) ; if ( ! file ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>package<S2SV_blank>file\\n"" ) ; return mp4box_cleanup ( 1 ) ; } } if ( ! outName ) outName = inName ; needSave = GF_TRUE ; open_edit = GF_TRUE ; } # endif if ( dash_duration ) { Bool del_file = GF_FALSE ; char szMPD [ GF_MAX_PATH ] , * sep ; char szStateFile [ GF_MAX_PATH ] ; Bool dyn_state_file = GF_FALSE ; u32 do_abort = 0 ; GF_DASHSegmenter * dasher = NULL ; if ( crypt ) { fprintf ( stderr , ""MP4Box<S2SV_blank>cannot<S2SV_blank>crypt<S2SV_blank>and<S2SV_blank>DASH<S2SV_blank>on<S2SV_blank>the<S2SV_blank>same<S2SV_blank>pass.<S2SV_blank>Please<S2SV_blank>encrypt<S2SV_blank>your<S2SV_blank>content<S2SV_blank>first.\\n"" ) ; return mp4box_cleanup ( 1 ) ; } strcpy ( outfile , outName ? outName : gf_url_get_resource_name ( inName ) ) ; sep = strrchr ( outfile , '.' ) ; if ( sep ) sep [ 0 ] = 0 ; if ( ! outName ) strcat ( outfile , ""_dash"" ) ; strcpy ( szMPD , outfile ) ; if ( outName && sep ) { sep [ 0 ] = '.' ; strcat ( szMPD , sep ) ; } else { strcat ( szMPD , "".mpd"" ) ; } if ( ( dash_subduration > 0 ) && ( dash_duration > dash_subduration ) ) { fprintf ( stderr , ""Warning:<S2SV_blank>-subdur<S2SV_blank>parameter<S2SV_blank>(%g<S2SV_blank>s)<S2SV_blank>should<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>segment<S2SV_blank>duration<S2SV_blank>(%g<S2SV_blank>s),<S2SV_blank>using<S2SV_blank>segment<S2SV_blank>duration<S2SV_blank>instead\\n"" , dash_subduration , dash_duration ) ; dash_subduration = dash_duration ; } if ( dash_mode && dash_live ) fprintf ( stderr , ""Live<S2SV_blank>DASH-ing<S2SV_blank>-<S2SV_blank>press<S2SV_blank>\'q\'<S2SV_blank>to<S2SV_blank>quit,<S2SV_blank>\'s\'<S2SV_blank>to<S2SV_blank>save<S2SV_blank>context<S2SV_blank>and<S2SV_blank>quit\\n"" ) ; if ( ! dash_ctx_file && dash_live ) { u32 r1 ; u64 add = ( u64 ) ( intptr_t ) & dasher ; add ^= gf_net_get_utc ( ) ; r1 = ( u32 ) add ^ ( u32 ) ( add / 0xFFFFFFFF ) ; r1 ^= gf_rand ( ) ; sprintf ( szStateFile , ""%s/dasher_%X.xml"" , gf_get_default_cache_directory ( ) , r1 ) ; dash_ctx_file = szStateFile ; dyn_state_file = GF_TRUE ; } else if ( dash_ctx_file ) { if ( force_new ) gf_file_delete ( dash_ctx_file ) ; } if ( dash_profile == GF_DASH_PROFILE_AUTO ) dash_profile = dash_mode ? GF_DASH_PROFILE_LIVE : GF_DASH_PROFILE_FULL ; if ( ! dash_mode ) { time_shift_depth = 0 ; mpd_update_time = 0 ; } else if ( ( dash_profile >= GF_DASH_PROFILE_MAIN ) && ! use_url_template && ! mpd_update_time ) { mpd_update_time = ( Double ) ( dash_subduration ? dash_subduration : dash_duration ) ; fprintf ( stderr , ""Using<S2SV_blank>default<S2SV_blank>MPD<S2SV_blank>refresh<S2SV_blank>of<S2SV_blank>%g<S2SV_blank>seconds\\n"" , mpd_update_time ) ; } if ( file && needSave ) { gf_isom_close ( file ) ; file = NULL ; del_file = GF_TRUE ; } dasher = gf_dasher_new ( szMPD , dash_profile , tmpdir , dash_scale , dash_ctx_file ) ; if ( ! dasher ) { return mp4box_cleanup ( 1 ) ; } e = gf_dasher_set_info ( dasher , dash_title , cprt , dash_more_info , dash_source , NULL ) ; if ( e ) { fprintf ( stderr , ""DASH<S2SV_blank>Error:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } gf_dasher_set_start_date ( dasher , dash_start_date ) ; gf_dasher_set_location ( dasher , dash_source ) ; for ( i = 0 ; i < nb_mpd_base_urls ; i ++ ) { e = gf_dasher_add_base_url ( dasher , mpd_base_urls [ i ] ) ; if ( e ) { fprintf ( stderr , ""DASH<S2SV_blank>Error:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } } if ( segment_timeline && ! use_url_template ) { fprintf ( stderr , ""DASH<S2SV_blank>Warning:<S2SV_blank>using<S2SV_blank>-segment-timeline<S2SV_blank>with<S2SV_blank>no<S2SV_blank>-url-template.<S2SV_blank>Forcing<S2SV_blank>URL<S2SV_blank>template.\\n"" ) ; use_url_template = GF_TRUE ; } e = gf_dasher_enable_url_template ( dasher , ( Bool ) use_url_template , seg_name , seg_ext , init_seg_ext ) ; if ( ! e ) e = gf_dasher_enable_segment_timeline ( dasher , segment_timeline ) ; if ( ! e ) e = gf_dasher_enable_single_segment ( dasher , single_segment ) ; if ( ! e ) e = gf_dasher_enable_single_file ( dasher , single_file ) ; if ( ! e ) e = gf_dasher_set_switch_mode ( dasher , bitstream_switching_mode ) ; if ( ! e ) e = gf_dasher_set_durations ( dasher , dash_duration , interleaving_time , dash_subduration ) ; if ( ! e ) e = gf_dasher_enable_rap_splitting ( dasher , seg_at_rap , frag_at_rap ) ; if ( ! e ) e = gf_dasher_set_segment_marker ( dasher , segment_marker ) ; if ( ! e ) e = gf_dasher_enable_sidx ( dasher , ( subsegs_per_sidx >= 0 ) ? 1 : 0 , ( u32 ) subsegs_per_sidx , daisy_chain_sidx , use_ssix ) ; if ( ! e ) e = gf_dasher_set_dynamic_mode ( dasher , dash_mode , mpd_update_time , time_shift_depth , mpd_live_duration ) ; if ( ! e ) e = gf_dasher_set_min_buffer ( dasher , min_buffer ) ; if ( ! e ) e = gf_dasher_set_ast_offset ( dasher , ast_offset_ms ) ; if ( ! e ) e = gf_dasher_enable_memory_fragmenting ( dasher , memory_frags ) ; if ( ! e ) e = gf_dasher_set_initial_isobmf ( dasher , initial_moof_sn , initial_tfdt ) ; if ( ! e ) e = gf_dasher_configure_isobmf_default ( dasher , no_fragments_defaults , pssh_mode , samplegroups_in_traf , single_traf_per_moof , tfdt_per_traf , mvex_after_traks , sdtp_in_traf ) ; if ( ! e ) e = gf_dasher_enable_utc_ref ( dasher , insert_utc ) ; if ( ! e ) e = gf_dasher_enable_real_time ( dasher , frag_real_time ) ; if ( ! e ) e = gf_dasher_set_content_protection_location_mode ( dasher , cp_location_mode ) ; if ( ! e ) e = gf_dasher_set_profile_extension ( dasher , dash_profile_extension ) ; if ( ! e ) e = gf_dasher_enable_cached_inputs ( dasher , no_cache ) ; if ( ! e ) e = gf_dasher_enable_loop_inputs ( dasher , ! no_loop ) ; if ( ! e ) e = gf_dasher_set_split_mode ( dasher , dash_split_mode ) ; if ( ! e ) e = gf_dasher_set_hls_clock ( dasher , hls_clock ) ; if ( ! e && dash_cues ) e = gf_dasher_set_cues ( dasher , dash_cues , strict_cues ) ; if ( ! e && fs_dump_flags ) e = gf_dasher_print_session_info ( dasher , fs_dump_flags ) ; for ( i = 0 ; i < nb_dash_inputs ; i ++ ) { if ( ! e ) e = gf_dasher_add_input ( dasher , & dash_inputs [ i ] ) ; } if ( e ) { fprintf ( stderr , ""DASH<S2SV_blank>Setup<S2SV_blank>Error:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } dash_cumulated_time = 0 ; while ( 1 ) { if ( run_for && ( dash_cumulated_time >= run_for ) ) { fprintf ( stderr , ""Done<S2SV_blank>running,<S2SV_blank>computing<S2SV_blank>static<S2SV_blank>MPD\\n"" ) ; do_abort = 3 ; } dash_prev_time = gf_sys_clock ( ) ; if ( do_abort >= 2 ) { e = gf_dasher_set_dynamic_mode ( dasher , GF_DASH_DYNAMIC_LAST , 0 , time_shift_depth , mpd_live_duration ) ; } if ( ! e ) e = gf_dasher_process ( dasher ) ; if ( ! dash_live && ( e == GF_EOS ) ) { fprintf ( stderr , ""Nothing<S2SV_blank>to<S2SV_blank>dash,<S2SV_blank>too<S2SV_blank>early<S2SV_blank>...\\n"" ) ; e = GF_OK ; } if ( do_abort ) break ; if ( dash_live && ( e == GF_IO_ERR ) ) { fprintf ( stderr , ""Error<S2SV_blank>dashing<S2SV_blank>file<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>continuing<S2SV_blank>...\\n"" , gf_error_to_string ( e ) ) ; e = GF_OK ; } if ( e ) break ; if ( dash_live ) { u64 ms_in_session = 0 ; u32 slept = gf_sys_clock ( ) ; u32 sleep_for = gf_dasher_next_update_time ( dasher , & ms_in_session ) ; fprintf ( stderr , ""Next<S2SV_blank>generation<S2SV_blank>scheduled<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>ms<S2SV_blank>(DASH<S2SV_blank>time<S2SV_blank>"" LLU ""<S2SV_blank>ms)\\r"" , sleep_for , ms_in_session ) ; if ( run_for && ( ms_in_session >= run_for ) ) { dash_cumulated_time = 1 + run_for ; continue ; } while ( 1 ) { if ( gf_prompt_has_input ( ) ) { char c = ( char ) gf_prompt_get_char ( ) ; if ( c == 'X' ) { do_abort = 1 ; break ; } if ( c == 'q' ) { do_abort = 2 ; break ; } if ( c == 's' ) { do_abort = 3 ; break ; } } if ( dash_mode == GF_DASH_DYNAMIC_DEBUG ) { break ; } if ( ! sleep_for ) break ; gf_sleep ( sleep_for / 10 ) ; sleep_for = gf_dasher_next_update_time ( dasher , NULL ) ; if ( sleep_for <= 1 ) { dash_now_time = gf_sys_clock ( ) ; dash_cumulated_time += ( dash_now_time - dash_prev_time ) ; fprintf ( stderr , ""Slept<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>before<S2SV_blank>generation,<S2SV_blank>dash<S2SV_blank>cumulated<S2SV_blank>time<S2SV_blank>%d\\n"" , dash_now_time - slept , dash_cumulated_time ) ; break ; } } } else { break ; } } gf_dasher_del ( dasher ) ; if ( ! run_for && dash_ctx_file && ( do_abort == 3 ) && ( dyn_state_file ) && ! gf_sys_is_test_mode ( ) ) { char szName [ 1024 ] ; fprintf ( stderr , ""Enter<S2SV_blank>file<S2SV_blank>name<S2SV_blank>to<S2SV_blank>save<S2SV_blank>dash<S2SV_blank>context:\\n"" ) ; if ( scanf ( ""%1023s"" , szName ) == 1 ) { gf_file_move ( dash_ctx_file , szName ) ; } } if ( e ) fprintf ( stderr , ""Error<S2SV_blank>DASHing<S2SV_blank>file:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; if ( file ) gf_isom_delete ( file ) ; if ( del_file ) gf_file_delete ( inName ) ; if ( e ) return mp4box_cleanup ( 1 ) ; goto exit ; } else if ( ! file && ! do_hash # ifndef GPAC_DISABLE_MEDIA_EXPORT && ! ( track_dump_type & GF_EXPORT_AVI_NATIVE ) # endif ) { FILE * st = gf_fopen ( inName , ""rb"" ) ; Bool file_exists = 0 ; GF_ISOOpenMode omode ; if ( st ) { file_exists = 1 ; gf_fclose ( st ) ; } switch ( get_file_type_by_ext ( inName ) ) { case 1 : omode = ( u8 ) ( force_new ? GF_ISOM_WRITE_EDIT : ( open_edit ? GF_ISOM_OPEN_EDIT : ( ( ( dump_isom > 0 ) || print_info ) ? GF_ISOM_OPEN_READ_DUMP : GF_ISOM_OPEN_READ ) ) ) ; if ( crypt ) { omode = GF_ISOM_OPEN_READ ; if ( use_init_seg ) file = gf_isom_open ( use_init_seg , GF_ISOM_OPEN_READ , tmpdir ) ; } if ( ! crypt && use_init_seg ) { file = gf_isom_open ( use_init_seg , GF_ISOM_OPEN_READ_DUMP , tmpdir ) ; if ( file ) { e = gf_isom_open_segment ( file , inName , 0 , 0 , 0 ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>opening<S2SV_blank>segment<S2SV_blank>%s:<S2SV_blank>%s\\n"" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; file = NULL ; } } } if ( ! file ) file = gf_isom_open ( inName , omode , tmpdir ) ; if ( ! file && ( gf_isom_last_error ( NULL ) == GF_ISOM_INCOMPLETE_FILE ) && ! open_edit ) { u64 missing_bytes ; e = gf_isom_open_progressive ( inName , 0 , 0 , GF_FALSE , & file , & missing_bytes ) ; fprintf ( stderr , ""Truncated<S2SV_blank>file<S2SV_blank>-<S2SV_blank>missing<S2SV_blank>"" LLD ""<S2SV_blank>bytes\\n"" , missing_bytes ) ; } if ( ! file ) { if ( open_edit && nb_meta_act ) { file = gf_isom_open ( inName , GF_ISOM_WRITE_EDIT , tmpdir ) ; if ( ! outName && file ) outName = inName ; } if ( ! file ) { fprintf ( stderr , ""Error<S2SV_blank>opening<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\n"" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } } if ( freeze_box_order ) gf_isom_freeze_order ( file ) ; break ; case 2 : case 3 : case 4 : case 5 : break ; case 6 : # ifndef GPAC_DISABLE_SCENE_DUMP if ( ( dump_mode == GF_SM_DUMP_LASER ) || ( dump_mode == GF_SM_DUMP_SVG ) ) { break ; } # endif default : if ( ! open_edit && file_exists && ! gf_isom_probe_file ( inName ) && track_dump_type ) { } # ifndef GPAC_DISABLE_ISOM_WRITE else if ( ! open_edit && file_exists # ifndef GPAC_DISABLE_SCENE_DUMP && dump_mode == GF_SM_DUMP_NONE # endif ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT if ( dvbhdemux ) { GF_MediaImporter import ; file = gf_isom_open ( ""ttxt_convert"" , GF_ISOM_OPEN_WRITE , NULL ) ; memset ( & import , 0 , sizeof ( GF_MediaImporter ) ) ; import . dest = file ; import . in_name = inName ; import . flags = GF_IMPORT_MPE_DEMUX ; e = gf_media_import ( & import ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\n"" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_file_delete ( ""ttxt_convert"" ) ; return mp4box_cleanup ( 1 ) ; } } # endif if ( dump_m2ts ) { # ifndef GPAC_DISABLE_MPEG2TS dump_mpeg2_ts ( inName , pes_dump , program_number ) ; # endif } else if ( dump_timestamps ) { # ifndef GPAC_DISABLE_MPEG2TS dump_mpeg2_ts ( inName , pes_dump , program_number ) ; # endif # ifndef GPAC_DISABLE_CORE_TOOLS } else if ( do_bin_xml ) { xml_bs_to_bin ( inName , outName , dump_std ) ; # endif } else if ( do_hash ) { hash_file ( inName , dump_std ) ; } else if ( print_info ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT convert_file_info ( inName , info_track_id ) ; # endif } else { fprintf ( stderr , ""Input<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>an<S2SV_blank>MP4<S2SV_blank>file,<S2SV_blank>operation<S2SV_blank>not<S2SV_blank>allowed\\n"" , inName ) ; return mp4box_cleanup ( 1 ) ; } goto exit ; } # endif else if ( open_edit ) { file = gf_isom_open ( inName , GF_ISOM_WRITE_EDIT , tmpdir ) ; if ( ! outName && file ) outName = inName ; } else if ( ! file_exists ) { fprintf ( stderr , ""Error<S2SV_blank>creating<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\n"" , inName , gf_error_to_string ( GF_URL_ERROR ) ) ; return mp4box_cleanup ( 1 ) ; } else { fprintf ( stderr , ""Cannot<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>extension<S2SV_blank>not<S2SV_blank>supported\\n"" , inName ) ; return mp4box_cleanup ( 1 ) ; } } } if ( high_dynamc_range_filename ) { e = parse_high_dynamc_range_xml_desc ( file , high_dynamc_range_filename ) ; if ( e ) goto err_exit ; } if ( file && keep_utc && open_edit ) { gf_isom_keep_utc_times ( file , 1 ) ; } strcpy ( outfile , outName ? outName : inName ) ; { char * szExt = gf_file_ext_start ( outfile ) ; if ( szExt ) { if ( ! stricmp ( szExt , "".3gp"" ) || ! stricmp ( szExt , "".3gpp"" ) || ! stricmp ( szExt , "".3g2"" ) ) conv_type = GF_ISOM_CONV_TYPE_3GPP ; else if ( ! stricmp ( szExt , "".m4a"" ) || ! stricmp ( szExt , "".m4v"" ) ) conv_type = GF_ISOM_CONV_TYPE_IPOD ; else if ( ! stricmp ( szExt , "".psp"" ) ) conv_type = GF_ISOM_CONV_TYPE_PSP ; else if ( ! stricmp ( szExt , "".mov"" ) || ! stricmp ( szExt , "".qt"" ) ) conv_type = GF_ISOM_CONV_TYPE_MOV ; * szExt = 0 ; } } # ifndef GPAC_DISABLE_MEDIA_EXPORT if ( track_dump_type & GF_EXPORT_AVI_NATIVE ) { char szFile [ GF_MAX_PATH + 24 ] ; GF_MediaExporter mdump ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . in_name = inName ; mdump . flags = GF_EXPORT_AVI_NATIVE ; mdump . trackID = trackID ; if ( dump_std ) { mdump . out_name = ""std"" ; } else if ( outName ) { mdump . out_name = outName ; } else if ( trackID > 2 ) { sprintf ( szFile , ""%s_audio%d"" , outfile , trackID - 1 ) ; mdump . out_name = szFile ; } else { sprintf ( szFile , ""%s_%s"" , outfile , ( trackID == 1 ) ? ""video"" : ""audio"" ) ; mdump . out_name = szFile ; } mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; goto exit ; } if ( ! open_edit && track_dump_type && ! gf_isom_probe_file ( inName ) ) { GF_MediaExporter mdump ; char szFile [ GF_MAX_PATH + 24 ] ; for ( i = 0 ; i < nb_track_act ; i ++ ) { TrackAction * tka = & tracks [ i ] ; if ( tka -> act_type != TRAC_ACTION_RAW_EXTRACT ) continue ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . in_name = inName ; mdump . flags = tka -> dump_type ; mdump . trackID = tka -> trackID ; mdump . sample_num = tka -> sample_num ; if ( outName ) { mdump . out_name = outName ; mdump . flags |= GF_EXPORT_MERGE ; } else if ( nb_track_act > 1 ) { sprintf ( szFile , ""%s_track%d"" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; } else { mdump . out_name = outfile ; } mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } goto exit ; } # endif # ifndef GPAC_DISABLE_SCENE_DUMP if ( dump_mode != GF_SM_DUMP_NONE ) { e = dump_isom_scene ( inName , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_mode , do_scene_log , no_odf_conf ) ; if ( e ) goto err_exit ; } # endif # ifndef GPAC_DISABLE_SCENE_STATS if ( stat_level ) dump_isom_scene_stats ( inName , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , stat_level ) ; # endif # ifndef GPAC_DISABLE_ISOM_HINTING if ( ! HintIt && print_sdp ) dump_isom_sdp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; # endif if ( get_nb_tracks ) { fprintf ( stdout , ""%d\\n"" , gf_isom_get_track_count ( file ) ) ; } if ( print_info ) { if ( ! file ) { fprintf ( stderr , ""Cannot<S2SV_blank>print<S2SV_blank>info<S2SV_blank>on<S2SV_blank>a<S2SV_blank>non<S2SV_blank>ISOM<S2SV_blank>file<S2SV_blank>(%s)\\n"" , inName ) ; } else { if ( info_track_id ) DumpTrackInfo ( file , info_track_id , 1 , ( print_info == 2 ) ? GF_TRUE : GF_FALSE ) ; else DumpMovieInfo ( file ) ; } } # ifndef GPAC_DISABLE_ISOM_DUMP if ( dump_isom ) { e = dump_isom_xml ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , ( dump_isom == 2 ) ? GF_TRUE : GF_FALSE , merge_vtt_cues , use_init_seg ? GF_TRUE : GF_FALSE , ( dump_isom == 3 ) ? GF_TRUE : GF_FALSE ) ; if ( e ) goto err_exit ; } if ( dump_cr ) dump_isom_ismacryp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( ( dump_ttxt || dump_srt ) && trackID ) { if ( trackID == ( u32 ) - 1 ) { for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { trackID = gf_isom_get_track_id ( file , j + 1 ) ; dump_isom_timed_text ( file , trackID , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_FALSE , dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ; } } else { dump_isom_timed_text ( file , trackID , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_FALSE , dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ; } } # ifndef GPAC_DISABLE_ISOM_HINTING if ( dump_rtp ) dump_isom_rtp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; # endif # endif if ( dump_timestamps ) dump_isom_timestamps ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_timestamps ) ; if ( dump_nal ) dump_isom_nal ( file , dump_nal , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_nal_type ) ; if ( dump_saps ) dump_isom_saps ( file , dump_saps , dump_saps_mode , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( do_hash ) { e = hash_file ( inName , dump_std ) ; if ( e ) goto err_exit ; } # ifndef GPAC_DISABLE_CORE_TOOLS if ( do_bin_xml ) { e = xml_bs_to_bin ( inName , outName , dump_std ) ; if ( e ) goto err_exit ; } # endif if ( dump_cart ) dump_isom_cover_art ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( dump_chap ) dump_isom_chapters ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_chap ) ; if ( dump_udta_type ) dump_isom_udta ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_udta_type , dump_udta_track ) ; if ( dump_iod ) { GF_InitialObjectDescriptor * iod = ( GF_InitialObjectDescriptor * ) gf_isom_get_root_od ( file ) ; if ( ! iod ) { <S2SV_StartBug> fprintf ( stderr , ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD"" , inName ) ; <S2SV_EndBug> } else { char szName [ GF_MAX_PATH + 10 ] ; FILE * iodf ; sprintf ( szName , ""%s.iod"" , outfile ) ; iodf = gf_fopen ( szName , ""wb"" ) ; if ( ! iodf ) { fprintf ( stderr , ""Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>%s\\n"" , szName ) ; } else { u8 * desc ; u32 size ; GF_BitStream * bs = gf_bs_from_file ( iodf , GF_BITSTREAM_WRITE ) ; if ( gf_odf_desc_write ( ( GF_Descriptor * ) iod , & desc , & size ) == GF_OK ) { gf_fwrite ( desc , size , iodf ) ; gf_free ( desc ) ; } else { fprintf ( stderr , ""Error<S2SV_blank>writing<S2SV_blank>IOD<S2SV_blank>%s\\n"" , szName ) ; } gf_fclose ( iodf ) ; gf_bs_del ( bs ) ; } gf_odf_desc_del ( ( GF_Descriptor * ) iod ) ; } } # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) if ( split_duration || split_size || split_range_str ) { split_isomedia_file ( file , split_duration , split_size , inName , interleaving_time , split_start , adjust_split_end , outName , tmpdir , seg_at_rap , split_range_str ) ; open_edit = GF_FALSE ; needSave = GF_FALSE ; } # endif # ifndef GPAC_DISABLE_MEDIA_EXPORT if ( track_dump_type ) { char szFile [ GF_MAX_PATH + 24 ] ; GF_MediaExporter mdump ; for ( i = 0 ; i < nb_track_act ; i ++ ) { TrackAction * tka = & tracks [ i ] ; if ( tka -> act_type != TRAC_ACTION_RAW_EXTRACT ) continue ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . file = file ; mdump . flags = tka -> dump_type ; mdump . trackID = tka -> trackID ; mdump . sample_num = tka -> sample_num ; if ( tka -> out_name ) { mdump . out_name = tka -> out_name ; } else if ( outName ) { mdump . out_name = outName ; mdump . flags |= GF_EXPORT_MERGE ; mdump . flags |= GF_EXPORT_NO_FILE_EXT ; } else if ( mdump . trackID ) { sprintf ( szFile , ""%s_track%d"" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; } else { sprintf ( szFile , ""%s_export"" , outfile ) ; mdump . out_name = szFile ; } if ( tka -> trackID == ( u32 ) - 1 ) { for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { mdump . trackID = gf_isom_get_track_id ( file , j + 1 ) ; sprintf ( szFile , ""%s_track%d"" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } } else { mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } } } else if ( do_saf ) { GF_MediaExporter mdump ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . file = file ; mdump . flags = GF_EXPORT_SAF ; mdump . out_name = outfile ; mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } # endif for ( i = 0 ; i < nb_meta_act ; i ++ ) { u32 tk = 0 ; # ifndef GPAC_DISABLE_ISOM_WRITE Bool self_ref ; # endif MetaAction * meta = & metas [ i ] ; if ( meta -> trackID ) tk = gf_isom_get_track_by_id ( file , meta -> trackID ) ; switch ( meta -> act_type ) { # ifndef GPAC_DISABLE_ISOM_WRITE case META_ACTION_SET_TYPE : e = gf_isom_set_meta_type ( file , meta -> root_meta , tk , meta -> meta_4cc ) ; gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_ISO2 , GF_TRUE ) ; needSave = GF_TRUE ; break ; case META_ACTION_ADD_ITEM : self_ref = ! stricmp ( meta -> szPath , ""NULL"" ) || ! stricmp ( meta -> szPath , ""this"" ) || ! stricmp ( meta -> szPath , ""self"" ) ; e = gf_isom_add_meta_item ( file , meta -> root_meta , tk , self_ref , self_ref ? NULL : meta -> szPath , meta -> szName , meta -> item_id , meta -> item_type , meta -> mime_type , meta -> enc_type , meta -> use_dref ? meta -> szPath : NULL , NULL , meta -> image_props ) ; if ( meta -> ref_type ) { e = gf_isom_meta_add_item_ref ( file , meta -> root_meta , tk , meta -> item_id , meta -> ref_item_id , meta -> ref_type , NULL ) ; } needSave = GF_TRUE ; break ; case META_ACTION_ADD_IMAGE_ITEM : { u32 old_tk_count = gf_isom_get_track_count ( file ) ; GF_Fraction _frac = { 0 , 0 } ; e = import_file ( file , meta -> szPath , 0 , _frac , 0 , NULL , NULL , 0 ) ; if ( e == GF_OK ) { u32 meta_type = gf_isom_get_meta_type ( file , meta -> root_meta , tk ) ; if ( ! meta_type ) { e = gf_isom_set_meta_type ( file , meta -> root_meta , tk , GF_META_ITEM_TYPE_PICT ) ; } else { if ( meta_type != GF_META_ITEM_TYPE_PICT ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Warning:<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>a<S2SV_blank>root<S2SV_blank>\'meta\'<S2SV_blank>box<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%s\\n"" , gf_4cc_to_str ( meta_type ) ) ) ; e = GF_BAD_PARAM ; } } if ( e == GF_OK ) { if ( ! meta -> item_id ) { e = gf_isom_meta_get_next_item_id ( file , meta -> root_meta , tk , & meta -> item_id ) ; } if ( e == GF_OK ) { e = gf_isom_iff_create_image_item_from_track ( file , meta -> root_meta , tk , 1 , meta -> szName , meta -> item_id , meta -> image_props , NULL ) ; if ( e == GF_OK && meta -> primary ) { e = gf_isom_set_meta_primary_item ( file , meta -> root_meta , tk , meta -> item_id ) ; } if ( e == GF_OK && meta -> ref_type ) { e = gf_isom_meta_add_item_ref ( file , meta -> root_meta , tk , meta -> item_id , meta -> ref_item_id , meta -> ref_type , NULL ) ; } } } } gf_isom_remove_track ( file , old_tk_count + 1 ) ; needSave = GF_TRUE ; } break ; case META_ACTION_REM_ITEM : e = gf_isom_remove_meta_item ( file , meta -> root_meta , tk , meta -> item_id ) ; needSave = GF_TRUE ; break ; case META_ACTION_SET_PRIMARY_ITEM : e = gf_isom_set_meta_primary_item ( file , meta -> root_meta , tk , meta -> item_id ) ; needSave = GF_TRUE ; break ; case META_ACTION_SET_XML : case META_ACTION_SET_BINARY_XML : e = gf_isom_set_meta_xml ( file , meta -> root_meta , tk , meta -> szPath , NULL , 0 , ( meta -> act_type == META_ACTION_SET_BINARY_XML ) ? 1 : 0 ) ; needSave = GF_TRUE ; break ; case META_ACTION_REM_XML : if ( gf_isom_get_meta_item_count ( file , meta -> root_meta , tk ) ) { e = gf_isom_remove_meta_xml ( file , meta -> root_meta , tk ) ; needSave = GF_TRUE ; } else { fprintf ( stderr , ""No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\n"" ) ; } break ; case META_ACTION_DUMP_ITEM : if ( gf_isom_get_meta_item_count ( file , meta -> root_meta , tk ) ) { e = gf_isom_extract_meta_item ( file , meta -> root_meta , tk , meta -> item_id , strlen ( meta -> szPath ) ? meta -> szPath : NULL ) ; } else { fprintf ( stderr , ""No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\n"" ) ; } break ; # endif case META_ACTION_DUMP_XML : if ( gf_isom_has_meta_xml ( file , meta -> root_meta , tk ) ) { e = gf_isom_extract_meta_xml ( file , meta -> root_meta , tk , meta -> szPath , NULL ) ; } else { fprintf ( stderr , ""No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\n"" ) ; } break ; default : break ; } if ( meta -> image_props ) { gf_free ( meta -> image_props ) ; meta -> image_props = NULL ; } if ( e ) goto err_exit ; } if ( ! open_edit && ! needSave ) { if ( file ) gf_isom_delete ( file ) ; goto exit ; } # ifndef GPAC_DISABLE_ISOM_WRITE if ( clean_groups ) { e = gf_isom_reset_switch_parameters ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_tsel_acts ; i ++ ) { switch ( tsel_acts [ i ] . act_type ) { case TSEL_ACTION_SET_PARAM : e = gf_isom_set_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , tsel_acts [ i ] . refTrackID ? gf_isom_get_track_by_id ( file , tsel_acts [ i ] . refTrackID ) : 0 , tsel_acts [ i ] . is_switchGroup ? 1 : 0 , & tsel_acts [ i ] . switchGroupID , tsel_acts [ i ] . criteria , tsel_acts [ i ] . nb_criteria ) ; if ( e == GF_BAD_PARAM ) { u32 alternateGroupID , nb_groups ; gf_isom_get_track_switch_group_count ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , & alternateGroupID , & nb_groups ) ; if ( alternateGroupID ) fprintf ( stderr , ""Hint:<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>more<S2SV_blank>tracks<S2SV_blank>to<S2SV_blank>group,<S2SV_blank>using:<S2SV_blank>-group-add<S2SV_blank>-refTrack=ID1:[criteria:]trackID=ID2\\n"" ) ; else fprintf ( stderr , ""Hint:<S2SV_blank>for<S2SV_blank>creates<S2SV_blank>a<S2SV_blank>new<S2SV_blank>grouping<S2SV_blank>information,<S2SV_blank>using<S2SV_blank>-group-add<S2SV_blank>-trackID=ID1:[criteria:]trackID=ID2\\n"" ) ; } if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; case TSEL_ACTION_REMOVE_TSEL : e = gf_isom_reset_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , 0 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; case TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP : e = gf_isom_reset_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , 1 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; default : break ; } } if ( remove_sys_tracks ) { # ifndef GPAC_DISABLE_AV_PARSERS remove_systems_tracks ( file ) ; # endif needSave = GF_TRUE ; if ( conv_type < GF_ISOM_CONV_TYPE_ISMA_EX ) conv_type = 0 ; } if ( remove_root_od ) { gf_isom_remove_root_od ( file ) ; needSave = GF_TRUE ; } # ifndef GPAC_DISABLE_ISOM_HINTING if ( remove_hint ) { for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( gf_isom_get_media_type ( file , i + 1 ) == GF_ISOM_MEDIA_HINT ) { fprintf ( stderr , ""Removing<S2SV_blank>hint<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d\\n"" , gf_isom_get_track_id ( file , i + 1 ) ) ; gf_isom_remove_track ( file , i + 1 ) ; i -- ; } } gf_isom_sdp_clean ( file ) ; needSave = GF_TRUE ; } # endif if ( timescale && ( timescale != gf_isom_get_timescale ( file ) ) ) { gf_isom_set_timescale ( file , timescale ) ; needSave = GF_TRUE ; } if ( ! encode ) { if ( ! file ) { fprintf ( stderr , ""Nothing<S2SV_blank>to<S2SV_blank>do<S2SV_blank>-<S2SV_blank>exiting\\n"" ) ; goto exit ; } if ( outName ) { strcpy ( outfile , outName ) ; } else { char * rel_name = strrchr ( inName , GF_PATH_SEPARATOR ) ; if ( ! rel_name ) rel_name = strrchr ( inName , '/' ) ; strcpy ( outfile , """" ) ; if ( tmpdir ) { strcpy ( outfile , tmpdir ) ; if ( ! strchr ( ""\\\\/"" , tmpdir [ strlen ( tmpdir ) - 1 ] ) ) strcat ( outfile , ""/"" ) ; } if ( ! pack_file ) strcat ( outfile , ""out_"" ) ; strcat ( outfile , rel_name ? rel_name + 1 : inName ) ; if ( pack_file ) { strcpy ( outfile , rel_name ? rel_name + 1 : inName ) ; rel_name = strrchr ( outfile , '.' ) ; if ( rel_name ) rel_name [ 0 ] = 0 ; strcat ( outfile , "".m21"" ) ; } } # ifndef GPAC_DISABLE_MEDIA_IMPORT if ( ( conv_type == GF_ISOM_CONV_TYPE_ISMA ) || ( conv_type == GF_ISOM_CONV_TYPE_ISMA_EX ) ) { fprintf ( stderr , ""Converting<S2SV_blank>to<S2SV_blank>ISMA<S2SV_blank>Audio-Video<S2SV_blank>MP4<S2SV_blank>file...\\n"" ) ; e = gf_media_make_isma ( file , crypt ? 1 : 0 , GF_FALSE , ( conv_type == GF_ISOM_CONV_TYPE_ISMA_EX ) ? 1 : 0 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_3GPP ) { fprintf ( stderr , ""Converting<S2SV_blank>to<S2SV_blank>3GP<S2SV_blank>file...\\n"" ) ; e = gf_media_make_3gpp ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_PSP ) { fprintf ( stderr , ""Converting<S2SV_blank>to<S2SV_blank>PSP<S2SV_blank>file...\\n"" ) ; e = gf_media_make_psp ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_MOV ) { e = gf_media_check_qt_prores ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( interleaving_time ) interleaving_time = 0.5 ; } # endif if ( conv_type == GF_ISOM_CONV_TYPE_IPOD ) { u32 ipod_major_brand = 0 ; fprintf ( stderr , ""Setting<S2SV_blank>up<S2SV_blank>iTunes/iPod<S2SV_blank>file...\\n"" ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { u32 mType = gf_isom_get_media_type ( file , i + 1 ) ; switch ( mType ) { case GF_ISOM_MEDIA_VISUAL : case GF_ISOM_MEDIA_AUXV : case GF_ISOM_MEDIA_PICT : ipod_major_brand = GF_ISOM_BRAND_M4V ; gf_isom_set_ipod_compatible ( file , i + 1 ) ; break ; case GF_ISOM_MEDIA_AUDIO : if ( ! ipod_major_brand ) ipod_major_brand = GF_ISOM_BRAND_M4A ; else gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_M4A , GF_TRUE ) ; break ; case GF_ISOM_MEDIA_TEXT : if ( gf_isom_get_media_subtype ( file , i + 1 , 1 ) == GF_ISOM_SUBTYPE_TX3G ) { Bool is_chap = 0 ; for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { s32 count = gf_isom_get_reference_count ( file , j + 1 , GF_ISOM_REF_CHAP ) ; if ( count > 0 ) { u32 tk , k ; for ( k = 0 ; k < ( u32 ) count ; k ++ ) { gf_isom_get_reference ( file , j + 1 , GF_ISOM_REF_CHAP , k + 1 , & tk ) ; if ( tk == i + 1 ) { is_chap = 1 ; break ; } } if ( is_chap ) break ; } if ( is_chap ) break ; } if ( ! is_chap ) gf_isom_set_media_type ( file , i + 1 , GF_ISOM_MEDIA_SUBT ) ; } break ; } } gf_isom_set_brand_info ( file , ipod_major_brand , 1 ) ; gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_MP42 , GF_TRUE ) ; needSave = GF_TRUE ; } } else if ( outName ) { strcpy ( outfile , outName ) ; } for ( j = 0 ; j < nb_track_act ; j ++ ) { TrackAction * tka = & tracks [ j ] ; u32 track = tka -> trackID ? gf_isom_get_track_by_id ( file , tka -> trackID ) : 0 ; timescale = gf_isom_get_timescale ( file ) ; switch ( tka -> act_type ) { case TRAC_ACTION_REM_TRACK : e = gf_isom_remove_track ( file , track ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>Removing<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d:<S2SV_blank>%s\\n"" , tka -> trackID , gf_error_to_string ( e ) ) ; } else { fprintf ( stderr , ""Removing<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d\\n"" , tka -> trackID ) ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_LANGUAGE : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_set_media_language ( file , i + 1 , tka -> lang ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_KIND : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_add_track_kind ( file , i + 1 , tka -> kind_scheme , tka -> kind_value ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_KIND : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_remove_track_kind ( file , i + 1 , tka -> kind_scheme , tka -> kind_value ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_DELAY : if ( tka -> delay_ms ) { u64 tk_dur ; gf_isom_remove_edits ( file , track ) ; tk_dur = gf_isom_get_track_duration ( file , track ) ; if ( gf_isom_get_edits_count ( file , track ) ) needSave = GF_TRUE ; if ( tka -> delay_ms > 0 ) { gf_isom_append_edit ( file , track , ( timescale * tka -> delay_ms ) / 1000 , 0 , GF_ISOM_EDIT_EMPTY ) ; gf_isom_append_edit ( file , track , tk_dur , 0 , GF_ISOM_EDIT_NORMAL ) ; needSave = GF_TRUE ; } else { u64 to_skip = ( timescale * ( - tka -> delay_ms ) ) / 1000 ; if ( to_skip < tk_dur ) { u64 media_time = ( - tka -> delay_ms ) * gf_isom_get_media_timescale ( file , track ) / 1000 ; gf_isom_append_edit ( file , track , tk_dur - to_skip , media_time , GF_ISOM_EDIT_NORMAL ) ; needSave = GF_TRUE ; } else { fprintf ( stderr , ""Warning:<S2SV_blank>request<S2SV_blank>negative<S2SV_blank>delay<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>track<S2SV_blank>duration<S2SV_blank>-<S2SV_blank>ignoring\\n"" ) ; } } } else if ( gf_isom_get_edits_count ( file , track ) ) { gf_isom_remove_edits ( file , track ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_SET_KMS_URI : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; if ( ! gf_isom_is_media_encrypted ( file , i + 1 , 1 ) ) continue ; if ( ! gf_isom_is_ismacryp_media ( file , i + 1 , 1 ) ) continue ; e = gf_isom_change_ismacryp_protection ( file , i + 1 , 1 , NULL , ( char * ) tka -> kms ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_SET_ID : if ( ! tka -> trackID && ( gf_isom_get_track_count ( file ) == 1 ) ) { fprintf ( stderr , ""Warning:<S2SV_blank>track<S2SV_blank>id<S2SV_blank>is<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>but<S2SV_blank>file<S2SV_blank>has<S2SV_blank>only<S2SV_blank>one<S2SV_blank>track<S2SV_blank>-<S2SV_blank>assume<S2SV_blank>that<S2SV_blank>you<S2SV_blank>want<S2SV_blank>to<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>this<S2SV_blank>track\\n"" ) ; track = 1 ; } if ( track ) { u32 newTrack ; newTrack = gf_isom_get_track_by_id ( file , tka -> newTrackID ) ; if ( newTrack != 0 ) { fprintf ( stderr , ""Error:<S2SV_blank>Cannot<S2SV_blank>set<S2SV_blank>track<S2SV_blank>id<S2SV_blank>with<S2SV_blank>value<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>a<S2SV_blank>track<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>-<S2SV_blank>ignoring"" , tka -> newTrackID ) ; } else { e = gf_isom_set_track_id ( file , track , tka -> newTrackID ) ; needSave = GF_TRUE ; } } else { fprintf ( stderr , ""Error:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>track<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>it<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>-<S2SV_blank>ignoring"" , tka -> trackID ) ; } break ; case TRAC_ACTION_SWAP_ID : if ( track ) { u32 tk1 , tk2 ; tk1 = gf_isom_get_track_by_id ( file , tka -> trackID ) ; tk2 = gf_isom_get_track_by_id ( file , tka -> newTrackID ) ; if ( ! tk1 || ! tk2 ) { fprintf ( stderr , ""Error:<S2SV_blank>Cannot<S2SV_blank>swap<S2SV_blank>track<S2SV_blank>IDs<S2SV_blank>because<S2SV_blank>not<S2SV_blank>existing<S2SV_blank>-<S2SV_blank>ignoring"" ) ; } else { e = gf_isom_set_track_id ( file , tk2 , 0 ) ; if ( ! e ) e = gf_isom_set_track_id ( file , tk1 , tka -> newTrackID ) ; if ( ! e ) e = gf_isom_set_track_id ( file , tk2 , tka -> trackID ) ; needSave = GF_TRUE ; } } else { fprintf ( stderr , ""Error:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>track<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>it<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>-<S2SV_blank>ignoring"" , tka -> trackID ) ; } break ; case TRAC_ACTION_SET_PAR : e = gf_media_change_par ( file , track , tka -> par_num , tka -> par_den , tka -> force_par , tka -> rewrite_bs ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_CLAP : e = gf_isom_set_clean_aperture ( file , track , 1 , tka -> clap_wnum , tka -> clap_wden , tka -> clap_hnum , tka -> clap_hden , tka -> clap_honum , tka -> clap_hoden , tka -> clap_vonum , tka -> clap_voden ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_MX : e = gf_isom_set_track_matrix ( file , track , tka -> mx ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_HANDLER_NAME : e = gf_isom_set_handler_name ( file , track , tka -> hdl_name ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_ENABLE : if ( ! gf_isom_is_track_enabled ( file , track ) ) { e = gf_isom_set_track_enabled ( file , track , GF_TRUE ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_DISABLE : if ( gf_isom_is_track_enabled ( file , track ) ) { e = gf_isom_set_track_enabled ( file , track , GF_FALSE ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_REFERENCE : e = gf_isom_set_track_reference ( file , track , GF_4CC ( tka -> lang [ 0 ] , tka -> lang [ 1 ] , tka -> lang [ 2 ] , tka -> lang [ 3 ] ) , ( u32 ) tka -> delay_ms ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_NON_RAP : fprintf ( stderr , ""Removing<S2SV_blank>non-rap<S2SV_blank>samples<S2SV_blank>from<S2SV_blank>track<S2SV_blank>%d\\n"" , tka -> trackID ) ; e = gf_media_remove_non_rap ( file , track , GF_FALSE ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_NON_REFS : fprintf ( stderr , ""Removing<S2SV_blank>non-reference<S2SV_blank>samples<S2SV_blank>from<S2SV_blank>track<S2SV_blank>%d\\n"" , tka -> trackID ) ; e = gf_media_remove_non_rap ( file , track , GF_TRUE ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_UDTA : fprintf ( stderr , ""Assigning<S2SV_blank>udta<S2SV_blank>box\\n"" ) ; e = set_file_udta ( file , track , tka -> udta_type , tka -> src_name , tka -> sample_num ? GF_TRUE : GF_FALSE ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; default : break ; } if ( e ) goto err_exit ; } if ( itunes_tags ) { char * tags = itunes_tags ; while ( tags ) { char * val ; char * sep = gf_url_colon_suffix ( tags ) ; u32 tlen , itag = 0 ; if ( sep ) { while ( sep ) { for ( itag = 0 ; itag < nb_itunes_tags ; itag ++ ) { if ( ! strnicmp ( sep + 1 , itags [ itag ] . name , strlen ( itags [ itag ] . name ) ) ) break ; } if ( itag < nb_itunes_tags ) { break ; } sep = gf_url_colon_suffix ( sep + 1 ) ; } if ( sep ) sep [ 0 ] = 0 ; } for ( itag = 0 ; itag < nb_itunes_tags ; itag ++ ) { if ( ! strnicmp ( tags , itags [ itag ] . name , strlen ( itags [ itag ] . name ) ) ) { break ; } } if ( itag == nb_itunes_tags ) { fprintf ( stderr , ""Invalid<S2SV_blank>iTune<S2SV_blank>tag<S2SV_blank>format<S2SV_blank>\\""%s\\""<S2SV_blank>-<S2SV_blank>ignoring\\n"" , tags ) ; tags = NULL ; continue ; } itag = itags [ itag ] . code ; val = strchr ( tags , '=' ) ; if ( ! val ) { fprintf ( stderr , ""Invalid<S2SV_blank>iTune<S2SV_blank>tag<S2SV_blank>format<S2SV_blank>\\""%s\\""<S2SV_blank>(expecting<S2SV_blank>\'=\')<S2SV_blank>-<S2SV_blank>ignoring\\n"" , tags ) ; tags = NULL ; continue ; } val ++ ; if ( ( val [ 0 ] == ':' ) || ! val [ 0 ] || ! stricmp ( val , ""NULL"" ) ) val = NULL ; tlen = val ? ( u32 ) strlen ( val ) : 0 ; switch ( itag ) { case GF_ISOM_ITUNE_COVER_ART : { u8 * d = NULL ; e = GF_OK ; if ( val ) { char * ext ; e = gf_file_load_data ( val , ( u8 * * ) & d , & tlen ) ; ext = strrchr ( val , '.' ) ; if ( ! stricmp ( ext , "".png"" ) ) tlen |= 0x80000000 ; } if ( ! e ) e = gf_isom_apple_set_tag ( file , GF_ISOM_ITUNE_COVER_ART , d , tlen ) ; if ( d ) gf_free ( d ) ; } break ; case GF_ISOM_ITUNE_TEMPO : gf_isom_apple_set_tag ( file , itag , NULL , val ? atoi ( val ) : 0 ) ; break ; case GF_ISOM_ITUNE_GENRE : { u8 _v = gf_id3_get_genre_tag ( val ) ; if ( _v ) { gf_isom_apple_set_tag ( file , itag , NULL , _v ) ; } else { if ( ! val ) val = """" ; gf_isom_apple_set_tag ( file , itag , ( u8 * ) val , ( u32 ) strlen ( val ) ) ; } } break ; case GF_ISOM_ITUNE_DISK : case GF_ISOM_ITUNE_TRACKNUMBER : { u32 n , t ; char _t [ 8 ] ; n = t = 0 ; if ( val ) { memset ( _t , 0 , sizeof ( char ) * 8 ) ; tlen = ( itag == GF_ISOM_ITUNE_DISK ) ? 6 : 8 ; if ( sscanf ( val , ""%u/%u"" , & n , & t ) == 2 ) { _t [ 3 ] = n ; _t [ 2 ] = n >> 8 ; _t [ 5 ] = t ; _t [ 4 ] = t >> 8 ; } else if ( sscanf ( val , ""%u"" , & n ) == 1 ) { _t [ 3 ] = n ; _t [ 2 ] = n >> 8 ; } else tlen = 0 ; } if ( ! val || tlen ) gf_isom_apple_set_tag ( file , itag , val ? ( u8 * ) _t : NULL , tlen ) ; } break ; case GF_ISOM_ITUNE_GAPLESS : case GF_ISOM_ITUNE_COMPILATION : { u8 _t [ 1 ] ; if ( val && ! stricmp ( val , ""yes"" ) ) _t [ 0 ] = 1 ; else _t [ 0 ] = 0 ; gf_isom_apple_set_tag ( file , itag , _t , 1 ) ; } break ; default : gf_isom_apple_set_tag ( file , itag , ( u8 * ) val , tlen ) ; break ; } needSave = GF_TRUE ; if ( sep ) { sep [ 0 ] = ':' ; tags = sep + 1 ; } else { tags = NULL ; } } } if ( movie_time ) { gf_isom_set_creation_time ( file , movie_time ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { gf_isom_set_track_creation_time ( file , i + 1 , movie_time ) ; } needSave = GF_TRUE ; } if ( cprt ) { e = gf_isom_set_copyright ( file , ""und"" , cprt ) ; needSave = GF_TRUE ; if ( e ) goto err_exit ; } if ( chap_file ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT e = gf_media_import_chapters ( file , chap_file , import_fps , chap_qt ) ; needSave = GF_TRUE ; # else fprintf ( stderr , ""Warning:<S2SV_blank>GPAC<S2SV_blank>compiled<S2SV_blank>without<S2SV_blank>Media<S2SV_blank>Import,<S2SV_blank>chapters<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>imported\\n"" ) ; e = GF_NOT_SUPPORTED ; # endif if ( e ) goto err_exit ; } if ( major_brand ) { gf_isom_set_brand_info ( file , major_brand , minor_version ) ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_alt_brand_add ; i ++ ) { gf_isom_modify_alternate_brand ( file , brand_add [ i ] , GF_TRUE ) ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_alt_brand_rem ; i ++ ) { gf_isom_modify_alternate_brand ( file , brand_rem [ i ] , GF_FALSE ) ; needSave = GF_TRUE ; } if ( box_patch_filename ) { e = gf_isom_apply_box_patch ( file , box_patch_trackID , box_patch_filename , GF_FALSE ) ; if ( e ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>box<S2SV_blank>patch<S2SV_blank>%s:<S2SV_blank>%s\\n"" , box_patch_filename , gf_error_to_string ( e ) ) ; goto err_exit ; } needSave = GF_TRUE ; } # ifndef GPAC_DISABLE_CRYPTO if ( crypt ) { if ( ! drm_file ) { fprintf ( stderr , ""Missing<S2SV_blank>DRM<S2SV_blank>file<S2SV_blank>location<S2SV_blank>-<S2SV_blank>usage<S2SV_blank>\'-%s<S2SV_blank>drm_file<S2SV_blank>input_file\\n"" , ( crypt == 1 ) ? ""crypt"" : ""decrypt"" ) ; e = GF_BAD_PARAM ; goto err_exit ; } if ( get_file_type_by_ext ( inName ) != GF_FILE_TYPE_ISO_MEDIA ) { fprintf ( stderr , ""MP4Box<S2SV_blank>can<S2SV_blank>crypt<S2SV_blank>only<S2SV_blank>ISOMedia<S2SV_blank>File\\n"" ) ; e = GF_BAD_PARAM ; goto err_exit ; } if ( crypt == 1 ) { if ( use_init_seg ) { e = gf_crypt_fragment ( file , drm_file , outfile , inName , fs_dump_flags ) ; } else { e = gf_crypt_file ( file , drm_file , outfile , interleaving_time , fs_dump_flags ) ; } } else if ( crypt == 2 ) { if ( use_init_seg ) { e = gf_decrypt_fragment ( file , drm_file , outfile , inName , fs_dump_flags ) ; } else { e = gf_decrypt_file ( file , drm_file , outfile , interleaving_time , fs_dump_flags ) ; } } if ( e ) goto err_exit ; needSave = outName ? GF_FALSE : GF_TRUE ; if ( ! Frag && ! HintIt && ! FullInter && ! force_co64 ) { char szName [ GF_MAX_PATH ] ; strcpy ( szName , gf_isom_get_filename ( file ) ) ; gf_isom_delete ( file ) ; file = NULL ; if ( ! outName ) { e = gf_file_move ( outfile , szName ) ; if ( e ) goto err_exit ; } goto exit ; } } # endif # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( Frag ) { if ( ! interleaving_time ) interleaving_time = DEFAULT_INTERLEAVING_IN_SEC ; if ( HintIt ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>hint<S2SV_blank>and<S2SV_blank>fragment<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>hint\\n"" ) ; fprintf ( stderr , ""Fragmenting<S2SV_blank>file<S2SV_blank>(%.3f<S2SV_blank>seconds<S2SV_blank>fragments)\\n"" , interleaving_time ) ; e = gf_media_fragment_file ( file , outfile , interleaving_time , use_mfra ) ; if ( e ) fprintf ( stderr , ""Error<S2SV_blank>while<S2SV_blank>fragmenting<S2SV_blank>file:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; if ( ! e && ! outName ) { if ( gf_file_exists ( inName ) && gf_file_delete ( inName ) ) fprintf ( stderr , ""Error<S2SV_blank>removing<S2SV_blank>file<S2SV_blank>%s\\n"" , inName ) ; else if ( gf_file_move ( outfile , inName ) ) fprintf ( stderr , ""Error<S2SV_blank>renaming<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s\\n"" , outfile , inName ) ; } if ( e ) goto err_exit ; gf_isom_delete ( file ) ; goto exit ; } # endif # ifndef GPAC_DISABLE_ISOM_HINTING if ( HintIt ) { if ( force_ocr ) SetupClockReferences ( file ) ; fprintf ( stderr , ""Hinting<S2SV_blank>file<S2SV_blank>with<S2SV_blank>Path-MTU<S2SV_blank>%d<S2SV_blank>Bytes\\n"" , MTUSize ) ; MTUSize -= 12 ; e = HintFile ( file , MTUSize , max_ptime , rtp_rate , hint_flags , HintCopy , HintInter , regular_iod , single_group , hint_no_offset ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( print_sdp ) dump_isom_sdp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; } # endif # if ! defined ( GPAC_DISABLE_ISOM_HINTING ) && ! defined ( GPAC_DISABLE_SENG ) for ( i = 0 ; i < nb_sdp_ex ; i ++ ) { if ( sdp_lines [ i ] . trackID ) { u32 track = gf_isom_get_track_by_id ( file , sdp_lines [ i ] . trackID ) ; if ( gf_isom_get_media_type ( file , track ) != GF_ISOM_MEDIA_HINT ) { s32 ref_count ; u32 k , count = gf_isom_get_track_count ( file ) ; for ( j = 0 ; j < count ; j ++ ) { if ( gf_isom_get_media_type ( file , j + 1 ) != GF_ISOM_MEDIA_HINT ) continue ; ref_count = gf_isom_get_reference_count ( file , j + 1 , GF_ISOM_REF_HINT ) ; if ( ref_count < 0 ) continue ; for ( k = 0 ; k < ( u32 ) ref_count ; k ++ ) { u32 refTk ; if ( gf_isom_get_reference ( file , j + 1 , GF_ISOM_REF_HINT , k + 1 , & refTk ) ) continue ; if ( refTk == track ) { track = j + 1 ; j = count ; break ; } } } } gf_isom_sdp_add_track_line ( file , track , sdp_lines [ i ] . line ) ; needSave = GF_TRUE ; } else { gf_isom_sdp_add_line ( file , sdp_lines [ i ] . line ) ; needSave = GF_TRUE ; } } # endif if ( FullInter ) { e = gf_isom_set_storage_mode ( file , GF_ISOM_STORE_TIGHT ) ; } else if ( do_flat ) { e = gf_isom_set_storage_mode ( file , ( do_flat == 1 ) ? GF_ISOM_STORE_FLAT : GF_ISOM_STORE_STREAMABLE ) ; needSave = GF_TRUE ; } else { e = gf_isom_make_interleave ( file , interleaving_time ) ; if ( ! e && old_interleave ) e = gf_isom_set_storage_mode ( file , GF_ISOM_STORE_INTERLEAVED ) ; } if ( force_co64 ) gf_isom_force_64bit_chunk_offset ( file , GF_TRUE ) ; if ( compress_moov ) gf_isom_enable_compression ( file , GF_ISO_COMP_MOOV , GF_FALSE ) ; if ( e ) goto err_exit ; if ( ! encode && ! force_new ) gf_isom_set_final_name ( file , outfile ) ; if ( needSave ) { if ( ! gf_sys_is_quiet ( ) ) { if ( outName ) { gf_isom_set_final_name ( file , outfile ) ; } else if ( encode || pack_file ) { fprintf ( stderr , ""Saving<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>"" , gf_isom_get_filename ( file ) ) ; } else { fprintf ( stderr , ""Saving<S2SV_blank>%s:<S2SV_blank>"" , inName ) ; } if ( HintIt && FullInter ) fprintf ( stderr , ""Hinted<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Full<S2SV_blank>Interleaving\\n"" ) ; else if ( FullInter ) fprintf ( stderr , ""Full<S2SV_blank>Interleaving\\n"" ) ; else if ( ( force_new == 2 ) && interleaving_time ) fprintf ( stderr , ""Fast-start<S2SV_blank>interleaved<S2SV_blank>storage\\n"" ) ; else if ( do_flat || ! interleaving_time ) fprintf ( stderr , ""Flat<S2SV_blank>storage\\n"" ) ; else fprintf ( stderr , ""%.3f<S2SV_blank>secs<S2SV_blank>Interleaving%s\\n"" , interleaving_time , old_interleave ? ""<S2SV_blank>-<S2SV_blank>no<S2SV_blank>drift<S2SV_blank>control"" : """" ) ; } else { if ( outName ) gf_isom_set_final_name ( file , outfile ) ; } e = gf_isom_close ( file ) ; file = NULL ; if ( ! e && ! outName && ! encode && ! force_new && ! pack_file ) { if ( gf_file_exists ( inName ) ) { e = gf_file_delete ( inName ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>removing<S2SV_blank>file<S2SV_blank>%s\\n"" , inName ) ; } } e = gf_file_move ( outfile , inName ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>renaming<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s\\n"" , outfile , inName ) ; } } } else { gf_isom_delete ( file ) ; } if ( e ) { fprintf ( stderr , ""Error:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; goto err_exit ; } goto exit ; # else gf_isom_delete ( file ) ; fprintf ( stderr , ""Error:<S2SV_blank>Read-only<S2SV_blank>version<S2SV_blank>of<S2SV_blank>MP4Box.\\n"" ) ; return mp4box_cleanup ( 1 ) ; # endif err_exit : if ( file ) gf_isom_delete ( file ) ; fprintf ( stderr , ""\\n\\tError:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; exit : mp4box_cleanup ( 0 ) ; # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return 0 ; }
","<S2SV_ModStart> ( stderr , ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD\\n"" <S2SV_ModEnd> , inName )
",CWE-476
164,"CWE-119 static int get_results ( struct iperf_test * test ) { int r = 0 ; cJSON * j ; cJSON * j_cpu_util_total ; cJSON * j_cpu_util_user ; cJSON * j_cpu_util_system ; cJSON * j_sender_has_retransmits ; int result_has_retransmits ; cJSON * j_streams ; int n , i ; cJSON * j_stream ; cJSON * j_id ; cJSON * j_bytes ; cJSON * j_retransmits ; cJSON * j_jitter ; cJSON * j_errors ; cJSON * j_packets ; cJSON * j_server_output ; int sid , cerror , pcount ; double jitter ; iperf_size_t bytes_transferred ; int retransmits ; struct iperf_stream * sp ; j = JSON_read ( test -> ctrl_sck ) ; if ( j == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { j_cpu_util_total = cJSON_GetObjectItem ( j , ""cpu_util_total"" ) ; j_cpu_util_user = cJSON_GetObjectItem ( j , ""cpu_util_user"" ) ; j_cpu_util_system = cJSON_GetObjectItem ( j , ""cpu_util_system"" ) ; j_sender_has_retransmits = cJSON_GetObjectItem ( j , ""sender_has_retransmits"" ) ; if ( j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { if ( test -> debug ) { printf ( ""get_results\\n%s\\n"" , cJSON_Print ( j ) ) ; } <S2SV_StartBug> test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuefloat ; <S2SV_EndBug> result_has_retransmits = j_sender_has_retransmits -> valueint ; if ( ! test -> sender ) test -> sender_has_retransmits = result_has_retransmits ; j_streams = cJSON_GetObjectItem ( j , ""streams"" ) ; if ( j_streams == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { n = cJSON_GetArraySize ( j_streams ) ; for ( i = 0 ; i < n ; ++ i ) { j_stream = cJSON_GetArrayItem ( j_streams , i ) ; if ( j_stream == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { j_id = cJSON_GetObjectItem ( j_stream , ""id"" ) ; j_bytes = cJSON_GetObjectItem ( j_stream , ""bytes"" ) ; j_retransmits = cJSON_GetObjectItem ( j_stream , ""retransmits"" ) ; j_jitter = cJSON_GetObjectItem ( j_stream , ""jitter"" ) ; j_errors = cJSON_GetObjectItem ( j_stream , ""errors"" ) ; j_packets = cJSON_GetObjectItem ( j_stream , ""packets"" ) ; if ( j_id == NULL || j_bytes == NULL || j_retransmits == NULL || j_jitter == NULL || j_errors == NULL || j_packets == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { sid = j_id -> valueint ; bytes_transferred = j_bytes -> valueint ; retransmits = j_retransmits -> valueint ; <S2SV_StartBug> jitter = j_jitter -> valuefloat ; <S2SV_EndBug> cerror = j_errors -> valueint ; pcount = j_packets -> valueint ; SLIST_FOREACH ( sp , & test -> streams , streams ) if ( sp -> id == sid ) break ; if ( sp == NULL ) { i_errno = IESTREAMID ; r = - 1 ; } else { if ( test -> sender ) { sp -> jitter = jitter ; sp -> cnt_error = cerror ; sp -> packet_count = pcount ; sp -> result -> bytes_received = bytes_transferred ; } else { sp -> result -> bytes_sent = bytes_transferred ; sp -> result -> stream_retrans = retransmits ; } } } } } if ( test -> role == 'c' && iperf_get_test_get_server_output ( test ) ) { j_server_output = cJSON_DetachItemFromObject ( j , ""server_output_json"" ) ; if ( j_server_output != NULL ) { test -> json_server_output = j_server_output ; } else { j_server_output = cJSON_GetObjectItem ( j , ""server_output_text"" ) ; if ( j_server_output != NULL ) { test -> server_output_text = strdup ( j_server_output -> valuestring ) ; } } } } } cJSON_Delete ( j ) ; } return r ; }
","<S2SV_ModStart> = j_cpu_util_total -> valuedouble <S2SV_ModEnd> ; test -> <S2SV_ModStart> = j_cpu_util_user -> valuedouble <S2SV_ModEnd> ; test -> <S2SV_ModStart> = j_cpu_util_system -> valuedouble <S2SV_ModEnd> ; result_has_retransmits = <S2SV_ModStart> = j_jitter -> valuedouble <S2SV_ModEnd> ; cerror =
",CWE-119
165,"CWE-200 static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - EOPNOTSUPP ; if ( m -> msg_flags & MSG_OOB ) goto read_error ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= MSG_TRUNC ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }
","<S2SV_ModStart> goto read_error ; m -> msg_namelen = 0 ;
",CWE-200
166,"CWE-000 static int traceLogDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * format , * option , * ovalue , * tok , * path , * formatter ; ssize size ; int flags , backup , level ; route = state -> route ; size = MAXINT ; backup = 0 ; flags = 0 ; path = 0 ; format = ME_HTTP_LOG_FORMAT ; formatter = ""detail"" ; level = 0 ; if ( route -> trace -> flags & MPR_LOG_CMDLINE ) { mprLog ( ""info<S2SV_blank>appweb<S2SV_blank>config"" , 4 , ""Already<S2SV_blank>tracing.<S2SV_blank>Ignoring<S2SV_blank>TraceLog<S2SV_blank>directive"" ) ; return 0 ; } for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { if ( ! path ) { path = sclone ( option ) ; } else { <S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( smatch ( option , ""anew"" ) ) { flags |= MPR_LOG_ANEW ; } else if ( smatch ( option , ""backup"" ) ) { backup = atoi ( ovalue ) ; } else if ( smatch ( option , ""format"" ) ) { format = ovalue ; } else if ( smatch ( option , ""level"" ) ) { level = ( int ) stoi ( ovalue ) ; } else if ( smatch ( option , ""size"" ) ) { size = ( ssize ) getnum ( ovalue ) ; } else if ( smatch ( option , ""formatter"" ) ) { formatter = ovalue ; } else { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Unknown<S2SV_blank>TraceLog<S2SV_blank>option<S2SV_blank>%s"" , option ) ; } } } if ( size < HTTP_TRACE_MIN_LOG_SIZE ) { size = HTTP_TRACE_MIN_LOG_SIZE ; } if ( path == 0 ) { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Missing<S2SV_blank>TraceLog<S2SV_blank>filename"" ) ; return MPR_ERR_BAD_SYNTAX ; } if ( formatter ) { httpSetTraceFormatterName ( route -> trace , formatter ) ; } if ( ! smatch ( path , ""stdout"" ) && ! smatch ( path , ""stderr"" ) ) { path = httpMakePath ( route , state -> configDir , path ) ; } route -> trace = httpCreateTrace ( route -> trace ) ; if ( httpSetTraceLogFile ( route -> trace , path , size , backup , format , flags ) < 0 ) { return MPR_ERR_CANT_OPEN ; } httpSetTraceLevel ( level ) ; return 0 ; }
","<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
",CWE-000
170,"CWE-476 static void jpc_undo_roi ( jas_matrix_t * x , int roishift , int bgshift , int numbps ) { int i ; int j ; int thresh ; jpc_fix_t val ; jpc_fix_t mag ; bool warn ; uint_fast32_t mask ; <S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> return ; } thresh = 1 << roishift ; warn = false ; for ( i = 0 ; i < jas_matrix_numrows ( x ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( x ) ; ++ j ) { val = jas_matrix_get ( x , i , j ) ; mag = JAS_ABS ( val ) ; if ( mag >= thresh ) { mag >>= roishift ; val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } else { mag <<= bgshift ; <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> if ( mag & ( ~ mask ) ) { if ( ! warn ) { jas_eprintf ( ""warning:<S2SV_blank>possibly<S2SV_blank>corrupt<S2SV_blank>code<S2SV_blank>stream\\n"" ) ; warn = true ; } mag &= mask ; } val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } } } }
","<S2SV_ModStart> if ( roishift < 0 ) { jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n"" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> mask = ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << numbps )
",CWE-476
171,"CWE-264 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return 0 ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return 0 ; return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <S2SV_StartBug> case EXIT_REASON_INVEPT : <S2SV_EndBug> return 1 ; case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : return 0 ; case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }
","<S2SV_ModStart> case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID :
",CWE-264
176,"CWE-399 static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; <S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | MSR_PMM ) ; mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
","<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }
",CWE-399
177,"CWE-119 static Image * ReadGRAYImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( size_t ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , GRAYColorspace ) ; canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod ) ; quantum_type = GrayQuantum ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = GetQuantumPixels ( quantum_info ) ; if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) break ; } } scene = 0 ; count = 0 ; length = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register ssize_t x ; register PixelPacket * restrict q ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; SetPixelGreen ( q , GetPixelGreen ( p ) ) ; SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; InheritException ( & image -> exception , & canvas_image -> exception ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",CWE-119
178,"CWE-000 int fit_image_verify ( const void * fit , int image_noffset ) { <S2SV_StartBug> const void * data ; <S2SV_EndBug> size_t size ; <S2SV_StartBug> int noffset = 0 ; <S2SV_EndBug> <S2SV_StartBug> char * err_msg = """" ; <S2SV_EndBug> if ( fit_image_get_data_and_size ( fit , image_noffset , & data , & size ) ) { err_msg = ""Can\'t<S2SV_blank>get<S2SV_blank>image<S2SV_blank>data/size"" ; <S2SV_StartBug> printf ( ""error!\\n%s<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>hash<S2SV_blank>node<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , <S2SV_EndBug> <S2SV_StartBug> err_msg , fit_get_name ( fit , noffset , NULL ) , <S2SV_EndBug> fit_get_name ( fit , image_noffset , NULL ) ) ; return 0 ; } <S2SV_StartBug> return fit_image_verify_with_data ( fit , image_noffset , data , size ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) { const char * name = fit_get_name ( fit , image_noffset , NULL ) ; const <S2SV_ModStart> size_t size ; <S2SV_ModEnd> char * err_msg <S2SV_ModStart> = """" ; if ( strchr ( name , '@' ) ) { err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ; goto err ; } <S2SV_ModStart> = ""Can\'t<S2SV_blank>get<S2SV_blank>image<S2SV_blank>data/size"" ; goto err ; } return fit_image_verify_with_data <S2SV_ModEnd> ( fit , <S2SV_ModStart> ( fit , image_noffset , data , size ) ; err : printf ( ""error!\\n%s<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , err_msg <S2SV_ModEnd> , fit_get_name ( <S2SV_ModStart> 0 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",CWE-000
180,"CWE-327 int wc_SignatureGenerate ( enum wc_HashType hash_type , enum wc_SignatureType sig_type , const byte * data , word32 data_len , byte * sig , word32 * sig_len , const void * key , word32 key_len , WC_RNG * rng ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> word32 hash_len , hash_enc_len ; # ifdef WOLFSSL_SMALL_STACK byte * hash_data ; # else byte hash_data [ MAX_DER_DIGEST_SZ ] ; # endif if ( data == NULL || data_len <= 0 || sig == NULL || sig_len == NULL || * sig_len <= 0 || key == NULL || key_len <= 0 ) { return BAD_FUNC_ARG ; } if ( ( int ) * sig_len < wc_SignatureGetSize ( sig_type , key , key_len ) ) { WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>sig<S2SV_blank>type/len"" ) ; return BAD_FUNC_ARG ; } ret = wc_HashGetDigestSize ( hash_type ) ; if ( ret < 0 ) { WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>hash<S2SV_blank>type/len"" ) ; return ret ; } hash_enc_len = hash_len = ret ; # if ! defined ( NO_RSA ) && ! defined ( WOLFSSL_RSA_PUBLIC_ONLY ) if ( sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC ) { hash_enc_len += MAX_DER_DIGEST_ASN_SZ ; } # endif # ifdef WOLFSSL_SMALL_STACK hash_data = ( byte * ) XMALLOC ( hash_enc_len , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ; if ( hash_data == NULL ) { return MEMORY_E ; } # endif <S2SV_StartBug> ret = wc_Hash ( hash_type , data , data_len , hash_data , hash_len ) ; <S2SV_EndBug> if ( ret == 0 ) { if ( sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC ) { # if defined ( NO_RSA ) || defined ( NO_ASN ) || defined ( WOLFSSL_RSA_PUBLIC_ONLY ) ret = SIG_TYPE_E ; # else ret = wc_SignatureDerEncode ( hash_type , hash_data , hash_len , & hash_enc_len ) ; # endif } if ( ret == 0 ) { ret = wc_SignatureGenerateHash ( hash_type , sig_type , <S2SV_StartBug> hash_data , hash_enc_len , sig , sig_len , key , key_len , rng ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug> # ifdef WOLFSSL_SMALL_STACK XFREE ( hash_data , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ; # endif return ret ; }
","<S2SV_ModStart> rng ) { return wc_SignatureGenerate_ex ( hash_type , sig_type <S2SV_ModEnd> , data , <S2SV_ModStart> , data_len , sig , <S2SV_ModEnd> sig_len , key <S2SV_ModStart> key_len , rng , 1 <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",CWE-327
181,"CWE-401 static int hgcm_call_preprocess_linaddr ( const struct vmmdev_hgcm_function_parameter * src_parm , void * * bounce_buf_ret , size_t * extra ) { void * buf , * bounce_buf ; bool copy_in ; u32 len ; int ret ; buf = ( void * ) src_parm -> u . pointer . u . linear_addr ; len = src_parm -> u . pointer . size ; copy_in = src_parm -> type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT ; if ( len > VBG_MAX_HGCM_USER_PARM ) return - E2BIG ; bounce_buf = kvmalloc ( len , GFP_KERNEL ) ; if ( ! bounce_buf ) return - ENOMEM ; <S2SV_StartBug> if ( copy_in ) { <S2SV_EndBug> ret = copy_from_user ( bounce_buf , ( void __user * ) buf , len ) ; if ( ret ) return - EFAULT ; } else { memset ( bounce_buf , 0 , len ) ; } <S2SV_StartBug> * bounce_buf_ret = bounce_buf ; <S2SV_EndBug> hgcm_call_add_pagelist_size ( bounce_buf , len , extra ) ; return 0 ; }
","<S2SV_ModStart> - ENOMEM ; * bounce_buf_ret = bounce_buf ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> hgcm_call_add_pagelist_size ( bounce_buf
",CWE-401
182,"CWE-119 static double calculate_modified_err ( const VP9_COMP * cpi , <S2SV_StartBug> const FIRSTPASS_STATS * this_frame ) { <S2SV_EndBug> <S2SV_StartBug> const struct twopass_rc * twopass = & cpi -> twopass ; <S2SV_EndBug> const SVC * const svc = & cpi -> svc ; const FIRSTPASS_STATS * stats ; double av_err ; double modified_error ; if ( svc -> number_spatial_layers > 1 && svc -> number_temporal_layers == 1 ) { twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass ; } stats = & twopass -> total_stats ; <S2SV_StartBug> av_err = stats -> ssim_weighted_pred_err / stats -> count ; <S2SV_EndBug> <S2SV_StartBug> modified_error = av_err * pow ( this_frame -> ssim_weighted_pred_err / <S2SV_EndBug> DOUBLE_DIVIDE_CHECK ( av_err ) , <S2SV_StartBug> cpi -> oxcf . two_pass_vbrbias / 100.0 ) ; <S2SV_EndBug> return fclamp ( modified_error , twopass -> modified_error_min , twopass -> modified_error_max ) ; }
","<S2SV_ModStart> cpi , const TWO_PASS * twopass , const VP9EncoderConfig * oxcf , const <S2SV_ModStart> ) { const FIRSTPASS_STATS * const <S2SV_ModEnd> stats = & <S2SV_ModStart> -> total_stats ; const double av_weight <S2SV_ModEnd> = stats -> <S2SV_ModStart> = stats -> weight <S2SV_ModEnd> / stats -> <S2SV_ModStart> -> count ; const double av_err = ( stats -> coded_error * av_weight ) / stats -> count ; double <S2SV_ModStart> ( this_frame -> coded_error * this_frame -> weight <S2SV_ModEnd> / DOUBLE_DIVIDE_CHECK ( <S2SV_ModStart> av_err ) , oxcf -> <S2SV_ModEnd> two_pass_vbrbias / 100.0 <S2SV_ModStart> two_pass_vbrbias / 100.0 ) ; modified_error *= pow ( calculate_active_area ( cpi , this_frame ) , ACT_AREA_CORRECTION
",CWE-119
184,"CWE-476 BOOL transport_accept_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> TlsIn == NULL ) transport -> TlsIn = tls_new ( transport -> settings ) ; if ( transport -> TlsOut == NULL ) transport -> TlsOut = transport -> TlsIn ; transport -> layer = TRANSPORT_LAYER_TLS ; transport -> TlsIn -> sockfd = transport -> TcpIn -> sockfd ; if ( tls_accept ( transport -> TlsIn , transport -> settings -> CertificateFile , transport -> settings -> PrivateKeyFile ) != TRUE ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { fprintf ( stderr , ""client<S2SV_blank>authentication<S2SV_blank>failure\\n"" ) ; credssp_free ( transport -> credssp ) ; <S2SV_StartBug> return FALSE ; <S2SV_EndBug> } return TRUE ; }
","<S2SV_ModStart> credssp ) ; transport -> credssp = NULL ;
",CWE-476
186,"CWE-190 static MatchinfoBuffer * fts3MIBufferNew ( int nElem , const char * zMatchinfo ) { MatchinfoBuffer * pRet ; <S2SV_StartBug> int nByte = sizeof ( u32 ) * ( 2 * nElem + 1 ) + sizeof ( MatchinfoBuffer ) ; <S2SV_EndBug> <S2SV_StartBug> int nStr = ( int ) strlen ( zMatchinfo ) ; <S2SV_EndBug> <S2SV_StartBug> pRet = sqlite3_malloc ( nByte + nStr + 1 ) ; <S2SV_EndBug> if ( pRet ) { memset ( pRet , 0 , nByte ) ; pRet -> aMatchinfo [ 0 ] = ( u8 * ) ( & pRet -> aMatchinfo [ 1 ] ) - ( u8 * ) pRet ; pRet -> aMatchinfo [ 1 + nElem ] = pRet -> aMatchinfo [ 0 ] + sizeof ( u32 ) * ( nElem + 1 ) ; pRet -> nElem = nElem ; pRet -> zMatchinfo = ( ( char * ) pRet ) + nByte ; memcpy ( pRet -> zMatchinfo , zMatchinfo , nStr + 1 ) ; pRet -> aRef [ 0 ] = 1 ; } return pRet ; }
","<S2SV_ModStart> * pRet ; sqlite3_int64 <S2SV_ModEnd> nByte = sizeof <S2SV_ModStart> ( 2 * ( sqlite3_int64 ) <S2SV_ModStart> MatchinfoBuffer ) ; sqlite3_int64 nStr = <S2SV_ModEnd> strlen ( zMatchinfo <S2SV_ModStart> ; pRet = sqlite3_malloc64 <S2SV_ModEnd> ( nByte +
",CWE-190
187,"CWE-400 int handle_ldf_stq ( u32 insn , struct pt_regs * regs ) { unsigned long addr = compute_effective_address ( regs , insn , 0 ) ; int freg = ( ( insn >> 25 ) & 0x1e ) | ( ( insn >> 20 ) & 0x20 ) ; struct fpustate * f = FPUSTATE ; int asi = decode_asi ( insn , regs ) ; int flag = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> save_and_clear_fpu ( ) ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ 0x1c000 ; if ( freg & 3 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; do_fpother ( regs ) ; return 0 ; } if ( insn & 0x200000 ) { u64 first = 0 , second = 0 ; if ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) { first = * ( u64 * ) & f -> regs [ freg ] ; second = * ( u64 * ) & f -> regs [ freg + 2 ] ; } if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } switch ( asi ) { case ASI_P : case ASI_S : break ; case ASI_PL : case ASI_SL : { u64 tmp = __swab64p ( & first ) ; first = __swab64p ( & second ) ; second = tmp ; break ; } default : if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( put_user ( first >> 32 , ( u32 __user * ) addr ) || __put_user ( ( u32 ) first , ( u32 __user * ) ( addr + 4 ) ) || __put_user ( second >> 32 , ( u32 __user * ) ( addr + 8 ) ) || __put_user ( ( u32 ) second , ( u32 __user * ) ( addr + 12 ) ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } } else { u32 data [ 4 ] __attribute__ ( ( aligned ( 8 ) ) ) ; int size , i ; int err ; if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } else if ( asi > ASI_SNFL ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } switch ( insn & 0x180000 ) { case 0x000000 : size = 1 ; break ; case 0x100000 : size = 4 ; break ; default : size = 2 ; break ; } for ( i = 0 ; i < size ; i ++ ) data [ i ] = 0 ; err = get_user ( data [ 0 ] , ( u32 __user * ) addr ) ; if ( ! err ) { for ( i = 1 ; i < size ; i ++ ) err |= __get_user ( data [ i ] , ( u32 __user * ) ( addr + 4 * i ) ) ; } if ( err && ! ( asi & 0x2 ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( asi & 0x8 ) { u64 tmp ; switch ( size ) { case 1 : data [ 0 ] = le32_to_cpup ( data + 0 ) ; break ; default : * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; break ; case 4 : tmp = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 2 ) ) ; * ( u64 * ) ( data + 2 ) = tmp ; break ; } } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & FPRS_FEF ) ) { current_thread_info ( ) -> fpsaved [ 0 ] = FPRS_FEF ; current_thread_info ( ) -> gsr [ 0 ] = 0 ; } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) ) { if ( freg < 32 ) memset ( f -> regs , 0 , 32 * sizeof ( u32 ) ) ; else memset ( f -> regs + 32 , 0 , 32 * sizeof ( u32 ) ) ; } memcpy ( f -> regs + freg , data , size * 4 ) ; current_thread_info ( ) -> fpsaved [ 0 ] |= flag ; } advance ( regs ) ; return 1 ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
",CWE-400
188,"CWE-284 static int connect_to_db ( char * host , char * user , char * passwd ) { char buff [ 20 + FN_REFLEN ] ; DBUG_ENTER ( ""connect_to_db"" ) ; verbose_msg ( ""--<S2SV_blank>Connecting<S2SV_blank>to<S2SV_blank>%s...\\n"" , host ? host : ""localhost"" ) ; mysql_init ( & mysql_connection ) ; if ( opt_compress ) mysql_options ( & mysql_connection , MYSQL_OPT_COMPRESS , NullS ) ; <S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> if ( opt_use_ssl ) { mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( & mysql_connection , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ; # endif if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( & mysql_connection , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql_connection , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif mysql_options ( & mysql_connection , MYSQL_SET_CHARSET_NAME , default_charset ) ; if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql_connection , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql_connection , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_ADD , ""program_name"" , ""mysqldump"" ) ; if ( ! ( mysql = mysql_real_connect ( & mysql_connection , host , user , passwd , NULL , opt_mysql_port , opt_mysql_unix_port , 0 ) ) ) { DB_error ( & mysql_connection , ""when<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>connect"" ) ; DBUG_RETURN ( 1 ) ; } if ( ( mysql_get_server_version ( & mysql_connection ) < 40100 ) || ( opt_compatible_mode & 3 ) ) { opt_set_charset = 0 ; server_supports_switching_charsets = FALSE ; } mysql -> reconnect = 0 ; my_snprintf ( buff , sizeof ( buff ) , ""/*!40100<S2SV_blank>SET<S2SV_blank>@@SQL_MODE=\'%s\'<S2SV_blank>*/"" , compatible_mode_normal_str ) ; if ( mysql_query_with_error_report ( mysql , 0 , buff ) ) DBUG_RETURN ( 1 ) ; if ( opt_tz_utc ) { my_snprintf ( buff , sizeof ( buff ) , ""/*!40103<S2SV_blank>SET<S2SV_blank>TIME_ZONE=\'+00:00\'<S2SV_blank>*/"" ) ; if ( mysql_query_with_error_report ( mysql , 0 , buff ) ) DBUG_RETURN ( 1 ) ; } DBUG_RETURN ( 0 ) ; }
","<S2SV_ModStart> NullS ) ; SSL_SET_OPTIONS ( & mysql_connection ) ; <S2SV_ModEnd> if ( opt_protocol
",CWE-284
190,"CWE-190 <S2SV_StartBug> void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 , <S2SV_EndBug> int c0 , int r1 , int c1 ) { <S2SV_StartBug> int i ; <S2SV_EndBug> if ( mat0 -> data_ ) { if ( ! ( mat0 -> flags_ & JAS_MATRIX_REF ) ) { jas_free ( mat0 -> data_ ) ; } mat0 -> data_ = 0 ; mat0 -> datasize_ = 0 ; } if ( mat0 -> rows_ ) { jas_free ( mat0 -> rows_ ) ; mat0 -> rows_ = 0 ; } mat0 -> flags_ |= JAS_MATRIX_REF ; mat0 -> numrows_ = r1 - r0 + 1 ; mat0 -> numcols_ = c1 - c0 + 1 ; mat0 -> maxrows_ = mat0 -> numrows_ ; if ( ! ( mat0 -> rows_ = jas_alloc2 ( mat0 -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { abort ( ) ; } for ( i = 0 ; i < mat0 -> numrows_ ; ++ i ) { mat0 -> rows_ [ i ] = mat1 -> rows_ [ r0 + i ] + c0 ; } mat0 -> xstart_ = mat1 -> xstart_ + c0 ; mat0 -> ystart_ = mat1 -> ystart_ + r0 ; mat0 -> xend_ = mat0 -> xstart_ + mat0 -> numcols_ ; mat0 -> yend_ = mat0 -> ystart_ + mat0 -> numrows_ ; }
","<S2SV_ModStart> * mat1 , jas_matind_t r0 , jas_matind_t c0 , jas_matind_t r1 , jas_matind_t <S2SV_ModEnd> c1 ) { <S2SV_ModStart> c1 ) { jas_matind_t <S2SV_ModEnd> i ; if
",CWE-190
194,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { int update = va_arg ( args , int ) ; vp8_update_entropy ( ctx -> cpi , update ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
",CWE-119
195,"CWE-189 static int sgi_timer_set ( struct k_itimer * timr , int flags , struct itimerspec * new_setting , struct itimerspec * old_setting ) { unsigned long when , period , irqflags ; int err = 0 ; cnodeid_t nodeid ; struct mmtimer * base ; struct rb_node * n ; if ( old_setting ) sgi_timer_get ( timr , old_setting ) ; sgi_timer_del ( timr ) ; <S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> if ( when == 0 ) return 0 ; base = kmalloc ( sizeof ( struct mmtimer ) , GFP_KERNEL ) ; if ( base == NULL ) return - ENOMEM ; if ( flags & TIMER_ABSTIME ) { struct timespec n ; unsigned long now ; getnstimeofday ( & n ) ; <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug> if ( when > now ) when -= now ; else when = 0 ; } when = ( when + sgi_clock_period - 1 ) / sgi_clock_period + rtc_time ( ) ; period = ( period + sgi_clock_period - 1 ) / sgi_clock_period ; preempt_disable ( ) ; nodeid = cpu_to_node ( smp_processor_id ( ) ) ; spin_lock_irqsave ( & timers [ nodeid ] . lock , irqflags ) ; base -> timer = timr ; base -> cpu = smp_processor_id ( ) ; timr -> it . mmtimer . clock = TIMER_SET ; timr -> it . mmtimer . node = nodeid ; timr -> it . mmtimer . incr = period ; timr -> it . mmtimer . expires = when ; n = timers [ nodeid ] . next ; mmtimer_add_list ( base ) ; if ( timers [ nodeid ] . next == n ) { spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; } if ( n ) mmtimer_disable_int ( cnodeid_to_nasid ( nodeid ) , COMPARATOR ) ; mmtimer_set_next_timer ( nodeid ) ; spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; }
","<S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( &
",CWE-189
199,"CWE-362 static int <S2SV_StartBug> mptctl_replace_fw ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_replace_fw __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_replace_fw karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> int iocnum ; int newFwSize ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_replace_fw ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_replace_fw<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_replace_fw<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_replace_fw()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_replace_fw<S2SV_blank>called.\\n"" , ioc -> name ) ) ; if ( ioc -> cached_fw == NULL ) return 0 ; mpt_free_fw_memory ( ioc ) ; newFwSize = ALIGN ( karg . newImageSize , 4 ) ; mpt_alloc_fw_memory ( ioc , newFwSize ) ; if ( ioc -> cached_fw == NULL ) return - ENOMEM ; if ( copy_from_user ( ioc -> cached_fw , uarg -> newImage , newFwSize ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_replace_fw<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_replace_fw<S2SV_blank>image<S2SV_blank>"" ""@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; mpt_free_fw_memory ( ioc ) ; return - EFAULT ; } ioc -> facts . FWImageSize = newFwSize ; return 0 ; }
","<S2SV_ModStart> int mptctl_replace_fw ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_replace_fw karg ; <S2SV_ModEnd> int newFwSize ; <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
",CWE-362
200,"CWE-284 static void btif_fetch_local_bdaddr ( bt_bdaddr_t * local_addr ) { char val [ PROPERTY_VALUE_MAX ] = { 0 } ; uint8_t valid_bda = FALSE ; int val_size = 0 ; const uint8_t null_bdaddr [ BD_ADDR_LEN ] = { 0 , 0 , 0 , 0 , 0 , 0 } ; if ( property_get ( PROPERTY_BT_BDADDR_PATH , val , NULL ) ) { int addr_fd ; BTIF_TRACE_DEBUG ( ""%s,<S2SV_blank>local<S2SV_blank>bdaddr<S2SV_blank>is<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%s"" , __func__ , val ) ; <S2SV_StartBug> if ( ( addr_fd = open ( val , O_RDONLY ) ) != - 1 ) <S2SV_EndBug> { memset ( val , 0 , sizeof ( val ) ) ; <S2SV_StartBug> read ( addr_fd , val , FACTORY_BT_BDADDR_STORAGE_LEN ) ; <S2SV_EndBug> if ( ( string_to_bdaddr ( val , local_addr ) ) && ( memcmp ( local_addr -> address , null_bdaddr , BD_ADDR_LEN ) != 0 ) ) { valid_bda = TRUE ; BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank>Got<S2SV_blank>Factory<S2SV_blank>BDA<S2SV_blank>%s"" , __func__ , val ) ; } close ( addr_fd ) ; } } if ( ! valid_bda ) { val_size = sizeof ( val ) ; if ( btif_config_get_str ( ""Adapter"" , ""Address"" , val , & val_size ) ) { string_to_bdaddr ( val , local_addr ) ; BTIF_TRACE_DEBUG ( ""local<S2SV_blank>bdaddr<S2SV_blank>from<S2SV_blank>bt_config.xml<S2SV_blank>is<S2SV_blank><S2SV_blank>%s"" , val ) ; return ; } } if ( ! valid_bda ) { valid_bda = btif_fetch_property ( PERSIST_BDADDR_PROPERTY , local_addr ) ; } if ( ! valid_bda ) { valid_bda = btif_fetch_property ( FACTORY_BT_ADDR_PROPERTY , local_addr ) ; } if ( ! valid_bda ) { bdstr_t bdstr ; srand ( ( unsigned int ) ( time ( 0 ) ) ) ; local_addr -> address [ 0 ] = 0x22 ; local_addr -> address [ 1 ] = 0x22 ; local_addr -> address [ 2 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 3 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 4 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 5 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; bdaddr_to_string ( local_addr , bdstr , sizeof ( bdstr ) ) ; BTIF_TRACE_DEBUG ( ""No<S2SV_blank>preset<S2SV_blank>BDA.<S2SV_blank>Generating<S2SV_blank>BDA:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>prop<S2SV_blank>%s"" , ( char * ) bdstr , PERSIST_BDADDR_PROPERTY ) ; if ( property_set ( PERSIST_BDADDR_PROPERTY , ( char * ) bdstr ) < 0 ) BTIF_TRACE_ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>random<S2SV_blank>BDA<S2SV_blank>in<S2SV_blank>prop<S2SV_blank>%s"" , PERSIST_BDADDR_PROPERTY ) ; } bdstr_t bdstr ; bdaddr_to_string ( local_addr , bdstr , sizeof ( bdstr ) ) ; val_size = sizeof ( val ) ; if ( btif_config_get_str ( ""Adapter"" , ""Address"" , val , & val_size ) ) { if ( strcmp ( bdstr , val ) == 0 ) { return ; } } btif_config_set_str ( ""Adapter"" , ""Address"" , bdstr ) ; }
","<S2SV_ModStart> ( addr_fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> val , O_RDONLY ) <S2SV_ModStart> ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> val , FACTORY_BT_BDADDR_STORAGE_LEN )
",CWE-284
201,"CWE-125 static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , ""ptr"" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , ""byte"" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""word"" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""dword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""qword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""oword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""tbyte"" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , ""+-"" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }
","<S2SV_ModStart> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> = temp ; } <S2SV_ModStart> += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> = X86R_UNDEFINED ; }
",CWE-125
202,"CWE-125 PyObject * ast2obj_stmt ( void * _o ) { stmt_ty o = ( stmt_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } switch ( o -> kind ) { case FunctionDef_kind : result = PyType_GenericNew ( FunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . FunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . FunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . AsyncFunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . AsyncFunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ClassDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . bases , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_bases , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . keywords , ast2obj_keyword ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_keywords , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Return_kind : result = PyType_GenericNew ( Return_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Return . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Delete_kind : result = PyType_GenericNew ( Delete_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Delete . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assign_kind : result = PyType_GenericNew ( Assign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Assign . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AugAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . AugAssign . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AugAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AnnAssign_kind : result = PyType_GenericNew ( AnnAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AnnAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . AnnAssign . simple ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_simple , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case For_kind : result = PyType_GenericNew ( For_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . For . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . For . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AsyncFor . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFor . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . While . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case If_kind : result = PyType_GenericNew ( If_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . If . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case With_kind : result = PyType_GenericNew ( With_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . With . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . With . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . AsyncWith . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncWith . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Raise . exc ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_exc , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Raise . cause ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_cause , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Try_kind : result = PyType_GenericNew ( Try_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Try . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . handlers , ast2obj_excepthandler ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_handlers , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . finalbody , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_finalbody , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assert_kind : result = PyType_GenericNew ( Assert_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Assert . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assert . msg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_msg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Import_kind : result = PyType_GenericNew ( Import_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Import . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ImportFrom_kind : result = PyType_GenericNew ( ImportFrom_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ImportFrom . module ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_module , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ImportFrom . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . ImportFrom . level ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_level , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Global_kind : result = PyType_GenericNew ( Global_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Global . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Nonlocal_kind : result = PyType_GenericNew ( Nonlocal_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Nonlocal . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expr_kind : result = PyType_GenericNew ( Expr_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expr . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Pass_kind : result = PyType_GenericNew ( Pass_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Break_kind : result = PyType_GenericNew ( Break_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Continue_kind : result = PyType_GenericNew ( Continue_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . Assign . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . For . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . With . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ;
",CWE-125
204,"CWE-125 int obj2ast_withitem ( PyObject * obj , withitem_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty context_expr ; expr_ty optional_vars ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_context_expr ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_context_expr ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & context_expr , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""context_expr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_optional_vars ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_optional_vars ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & optional_vars , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { optional_vars = NULL ; } * out = withitem ( context_expr , optional_vars , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_context_expr , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""context_expr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & context_expr , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_optional_vars , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; optional_vars = NULL ; } else { int res ; <S2SV_ModStart> tmp , & optional_vars <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> * out =
",CWE-125
205,"CWE-20 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; if ( length != 0x000a ) { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ; length = ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; if ( length == 0 ) break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""iptc"" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; } length = ReadBlobMSBLong ( image ) ; if ( length > 154 ) { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%.20gx%.20g"" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
",CWE-20
206,"CWE-125 PyObject * ast2obj_keyword ( void * _o ) { keyword_ty o = ( keyword_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( keyword_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
",CWE-125
207,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_active_map_t * data = va_arg ( args , vpx_active_map_t * ) ; if ( data ) { vpx_active_map_t * map = ( vpx_active_map_t * ) data ; if ( ! vp8_set_active_map ( ctx -> cpi , map -> active_map , map -> rows , map -> cols ) ) return VPX_CODEC_OK ; else return VPX_CODEC_INVALID_PARAM ; } else return VPX_CODEC_INVALID_PARAM ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
",CWE-119
208,"CWE-74 int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_str_startswith ( adata -> buf , ""*<S2SV_blank>OK"" , CASE_IGNORE ) ) { if ( ! mutt_str_startswith ( adata -> buf , ""*<S2SV_blank>OK<S2SV_blank>[CAPABILITY"" , CASE_IGNORE ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ! adata -> conn -> ssf && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { <S2SV_StartBug> enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_NO_FLAGS ) ; <S2SV_EndBug> if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ! adata -> conn -> ssf ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_str_startswith ( adata -> buf , ""*<S2SV_blank>PREAUTH"" , CASE_IGNORE ) ) { # ifdef USE_SSL if ( adata -> conn -> ssf == 0 ) { bool proceed = true ; if ( C_SslForceTls ) { proceed = false ; } else if ( C_SslStarttls != MUTT_NO ) { proceed = mutt_yesorno ( _ ( ""Abort<S2SV_blank>unencrypted<S2SV_blank>PREAUTH<S2SV_blank>connection?"" ) , C_SslStarttls ) != MUTT_NO ; } if ( ! proceed ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; goto err_close_conn ; } } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
","<S2SV_ModStart> , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn <S2SV_ModEnd> ) ; if
",CWE-74
209,"CWE-59 void open_log_file ( const char * name , const char * prog , const char * namespace , const char * instance ) { char * file_name ; if ( log_file ) { fclose ( log_file ) ; log_file = NULL ; } if ( ! name ) return ; file_name = make_file_name ( name , prog , namespace , instance ) ; <S2SV_StartBug> log_file = fopen ( file_name , ""a"" ) ; <S2SV_EndBug> if ( log_file ) { int n = fileno ( log_file ) ; fcntl ( n , F_SETFD , FD_CLOEXEC | fcntl ( n , F_GETFD ) ) ; fcntl ( n , F_SETFL , O_NONBLOCK | fcntl ( n , F_GETFL ) ) ; } FREE ( file_name ) ; }
","<S2SV_ModStart> ; log_file = fopen_safe <S2SV_ModEnd> ( file_name ,
",CWE-59
211,"CWE-119 int main ( int argc , const char * * argv_ ) { int pass ; vpx_image_t raw ; <S2SV_StartBug> int frame_avail , got_data ; <S2SV_EndBug> <S2SV_StartBug> struct VpxInputContext input = { 0 } ; <S2SV_EndBug> struct VpxEncoderConfig global ; struct stream_state * streams = NULL ; char * * argv , * * argi ; uint64_t cx_time = 0 ; int stream_cnt = 0 ; int res = 0 ; <S2SV_StartBug> exec_name = argv_ [ 0 ] ; <S2SV_EndBug> if ( argc < 3 ) usage_exit ( ) ; input . framerate . numerator = 30 ; input . framerate . denominator = 1 ; <S2SV_StartBug> input . use_i420 = 1 ; <S2SV_EndBug> <S2SV_StartBug> input . only_i420 = 1 ; <S2SV_EndBug> argv = argv_dup ( argc - 1 , argv_ + 1 ) ; <S2SV_StartBug> parse_global_config ( & global , argv ) ; <S2SV_EndBug> { struct stream_state * stream = NULL ; do { stream = new_stream ( & global , stream ) ; stream_cnt ++ ; if ( ! streams ) streams = stream ; } while ( parse_stream_params ( & global , stream , argv ) ) ; } for ( argi = argv ; * argi ; argi ++ ) if ( argi [ 0 ] [ 0 ] == '-' && argi [ 0 ] [ 1 ] ) die ( ""Error:<S2SV_blank>Unrecognized<S2SV_blank>option<S2SV_blank>%s\\n"" , * argi ) ; FOREACH_STREAM ( check_encoder_config ( global . disable_warning_prompt , & global , & stream -> config . cfg ) ; ) ; input . filename = argv [ 0 ] ; if ( ! input . filename ) usage_exit ( ) ; if ( global . codec -> fourcc == VP9_FOURCC ) input . only_i420 = 0 ; for ( pass = global . pass ? global . pass - 1 : 0 ; pass < global . passes ; pass ++ ) { int frames_in = 0 , seen_frames = 0 ; int64_t estimated_time_left = - 1 ; int64_t average_rate = - 1 ; <S2SV_StartBug> off_t lagged_count = 0 ; <S2SV_EndBug> open_input_file ( & input ) ; <S2SV_StartBug> if ( ! input . width || ! input . height ) <S2SV_EndBug> FOREACH_STREAM ( { if ( stream -> config . cfg . g_w && stream -> config . cfg . g_h ) { input . width = stream -> config . cfg . g_w ; input . height = stream -> config . cfg . g_h ; break ; } <S2SV_StartBug> } ) ; <S2SV_EndBug> if ( ! input . width || ! input . height ) fatal ( ""Specify<S2SV_blank>stream<S2SV_blank>dimensions<S2SV_blank>with<S2SV_blank>--width<S2SV_blank>(-w)<S2SV_blank>"" <S2SV_StartBug> ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" ) ; <S2SV_EndBug> FOREACH_STREAM ( set_stream_dimensions ( stream , input . width , input . height ) ) ; FOREACH_STREAM ( validate_stream_config ( stream , & global ) ) ; if ( global . pass && global . passes == 2 ) FOREACH_STREAM ( { if ( ! stream -> config . stats_fn ) die ( ""Stream<S2SV_blank>%d:<S2SV_blank>Must<S2SV_blank>specify<S2SV_blank>--fpf<S2SV_blank>when<S2SV_blank>--pass=%d"" ""<S2SV_blank>and<S2SV_blank>--passes=2\\n"" , stream -> index , global . pass ) ; } ) ; # if ! CONFIG_WEBM_IO FOREACH_STREAM ( { stream -> config . write_webm = 0 ; warn ( ""vpxenc<S2SV_blank>was<S2SV_blank>compiled<S2SV_blank>without<S2SV_blank>WebM<S2SV_blank>container<S2SV_blank>support."" ""Producing<S2SV_blank>IVF<S2SV_blank>output"" ) ; } ) ; # endif if ( ! global . have_framerate ) { global . framerate . num = input . framerate . numerator ; global . framerate . den = input . framerate . denominator ; } FOREACH_STREAM ( set_default_kf_interval ( stream , & global ) ) ; if ( global . verbose && pass == 0 ) FOREACH_STREAM ( show_stream_config ( stream , & global , & input ) ) ; if ( pass == ( global . pass ? global . pass - 1 : 0 ) ) { if ( input . file_type == FILE_TYPE_Y4M ) memset ( & raw , 0 , sizeof ( raw ) ) ; else vpx_img_alloc ( & raw , <S2SV_StartBug> input . use_i420 ? VPX_IMG_FMT_I420 <S2SV_EndBug> : VPX_IMG_FMT_YV12 , input . width , input . height , 32 ) ; FOREACH_STREAM ( stream -> rate_hist = init_rate_histogram ( & stream -> config . cfg , & global . framerate ) ) ; } FOREACH_STREAM ( setup_pass ( stream , & global , pass ) ) ; <S2SV_StartBug> FOREACH_STREAM ( open_output_file ( stream , & global ) ) ; <S2SV_EndBug> <S2SV_StartBug> FOREACH_STREAM ( initialize_encoder ( stream , & global ) ) ; <S2SV_EndBug> frame_avail = 1 ; got_data = 0 ; while ( frame_avail || got_data ) { struct vpx_usec_timer timer ; if ( ! global . limit || frames_in < global . limit ) { frame_avail = read_frame ( & input , & raw ) ; if ( frame_avail ) frames_in ++ ; seen_frames = frames_in > global . skip_frames ? frames_in - global . skip_frames : 0 ; if ( ! global . quiet ) { float fps = usec_to_fps ( cx_time , seen_frames ) ; fprintf ( stderr , ""\\rPass<S2SV_blank>%d/%d<S2SV_blank>"" , pass + 1 , global . passes ) ; if ( stream_cnt == 1 ) fprintf ( stderr , ""frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>"" , frames_in , streams -> frames_out , ( int64_t ) streams -> nbytes ) ; else fprintf ( stderr , ""frame<S2SV_blank>%4d<S2SV_blank>"" , frames_in ) ; fprintf ( stderr , ""%7"" PRId64 ""<S2SV_blank>%s<S2SV_blank>%.2f<S2SV_blank>%s<S2SV_blank>"" , cx_time > 9999999 ? cx_time / 1000 : cx_time , cx_time > 9999999 ? ""ms"" : ""us"" , fps >= 1.0 ? fps : fps * 60 , fps >= 1.0 ? ""fps"" : ""fpm"" ) ; print_time ( ""ETA"" , estimated_time_left ) ; <S2SV_StartBug> fprintf ( stderr , ""\\033[K"" ) ; <S2SV_EndBug> } } else frame_avail = 0 ; <S2SV_StartBug> if ( frames_in > global . skip_frames ) { <S2SV_EndBug> vpx_usec_timer_start ( & timer ) ; FOREACH_STREAM ( encode_frame ( stream , & global , frame_avail ? & raw : NULL , frames_in ) ) ; <S2SV_StartBug> vpx_usec_timer_mark ( & timer ) ; <S2SV_EndBug> cx_time += vpx_usec_timer_elapsed ( & timer ) ; FOREACH_STREAM ( update_quantizer_histogram ( stream ) ) ; got_data = 0 ; FOREACH_STREAM ( get_cx_data ( stream , & global , & got_data ) ) ; <S2SV_StartBug> if ( ! got_data && input . length && ! streams -> frames_out ) { <S2SV_EndBug> lagged_count = global . limit ? seen_frames : ftello ( input . file ) ; } else if ( input . length ) { int64_t remaining ; int64_t rate ; if ( global . limit ) { <S2SV_StartBug> off_t frame_in_lagged = ( seen_frames - lagged_count ) * 1000 ; <S2SV_EndBug> rate = cx_time ? frame_in_lagged * ( int64_t ) 1000000 / cx_time : 0 ; remaining = 1000 * ( global . limit - global . skip_frames - seen_frames + lagged_count ) ; } else { <S2SV_StartBug> off_t input_pos = ftello ( input . file ) ; <S2SV_EndBug> <S2SV_StartBug> off_t input_pos_lagged = input_pos - lagged_count ; <S2SV_EndBug> <S2SV_StartBug> int64_t limit = input . length ; <S2SV_EndBug> rate = cx_time ? input_pos_lagged * ( int64_t ) 1000000 / cx_time : 0 ; remaining = limit - input_pos + lagged_count ; } average_rate = ( average_rate <= 0 ) ? rate : ( average_rate * 7 + rate ) / 8 ; estimated_time_left = average_rate ? remaining / average_rate : - 1 ; } if ( got_data && global . test_decode != TEST_DECODE_OFF ) FOREACH_STREAM ( test_decode ( stream , global . test_decode , global . codec ) ) ; } fflush ( stdout ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( stream_cnt > 1 ) fprintf ( stderr , ""\\n"" ) ; <S2SV_StartBug> if ( ! global . quiet ) <S2SV_EndBug> FOREACH_STREAM ( fprintf ( stderr , <S2SV_StartBug> ""\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>%7lub/f<S2SV_blank>%7"" PRId64 ""b/s"" <S2SV_EndBug> ""<S2SV_blank>%7"" PRId64 ""<S2SV_blank>%s<S2SV_blank>(%.2f<S2SV_blank>fps)\\033[K\\n"" , pass + 1 , global . passes , frames_in , stream -> frames_out , ( int64_t ) stream -> nbytes , <S2SV_StartBug> seen_frames ? ( unsigned long ) ( stream -> nbytes * 8 / seen_frames ) : 0 , <S2SV_EndBug> seen_frames ? ( int64_t ) stream -> nbytes * 8 * ( int64_t ) global . framerate . num / global . framerate . den / seen_frames : 0 , stream -> cx_time > 9999999 ? stream -> cx_time / 1000 : stream -> cx_time , stream -> cx_time > 9999999 ? ""ms"" : ""us"" , <S2SV_StartBug> usec_to_fps ( stream -> cx_time , seen_frames ) ) ; <S2SV_EndBug> ) ; if ( global . show_psnr ) <S2SV_StartBug> FOREACH_STREAM ( show_psnr ( stream ) ) ; <S2SV_EndBug> FOREACH_STREAM ( vpx_codec_destroy ( & stream -> encoder ) ) ; if ( global . test_decode != TEST_DECODE_OFF ) { FOREACH_STREAM ( vpx_codec_destroy ( & stream -> decoder ) ) ; } close_input_file ( & input ) ; if ( global . test_decode == TEST_DECODE_FATAL ) { FOREACH_STREAM ( res |= stream -> mismatch_seen ) ; } FOREACH_STREAM ( close_output_file ( stream , global . codec -> fourcc ) ) ; <S2SV_StartBug> FOREACH_STREAM ( stats_close ( & stream -> stats , global . passes - 1 ) ) ; <S2SV_EndBug> if ( global . pass ) break ; } if ( global . show_q_hist_buckets ) FOREACH_STREAM ( show_q_histogram ( stream -> counts , global . show_q_hist_buckets ) ) ; if ( global . show_rate_hist_buckets ) FOREACH_STREAM ( show_rate_histogram ( stream -> rate_hist , & stream -> config . cfg , global . show_rate_hist_buckets ) ) ; FOREACH_STREAM ( destroy_rate_histogram ( stream -> rate_hist ) ) ; # if CONFIG_INTERNAL_STATS if ( ! ( global . pass == 1 && global . passes == 2 ) ) FOREACH_STREAM ( { FILE * f = fopen ( ""opsnr.stt"" , ""a"" ) ; if ( stream -> mismatch_seen ) { fprintf ( f , ""First<S2SV_blank>mismatch<S2SV_blank>occurred<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>%d\\n"" , stream -> mismatch_seen ) ; } else { fprintf ( f , ""No<S2SV_blank>mismatch<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>recon<S2SV_blank>buffers\\n"" ) ; } fclose ( f ) ; <S2SV_StartBug> } ) ; <S2SV_EndBug> # endif vpx_img_free ( & raw ) ; free ( argv ) ; free ( streams ) ; return res ? EXIT_FAILURE : EXIT_SUCCESS ; }
","<S2SV_ModStart> vpx_image_t raw ; # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t raw_shift ; int allocated_raw_shift = 0 ; int use_16bit_internal = 0 ; int input_shift = 0 ; # endif <S2SV_ModStart> struct VpxInputContext input <S2SV_ModEnd> ; struct VpxEncoderConfig <S2SV_ModStart> = 0 ; memset ( & input , 0 , sizeof ( input ) ) ; <S2SV_ModStart> ; input . only_i420 <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ; input . bit_depth = 0 <S2SV_ModEnd> ; argv = <S2SV_ModStart> argv ) ; switch ( global . color_type ) { case I420 : input . fmt = VPX_IMG_FMT_I420 ; break ; case I422 : input . fmt = VPX_IMG_FMT_I422 ; break ; case I444 : input . fmt = VPX_IMG_FMT_I444 ; break ; case I440 : input . fmt = VPX_IMG_FMT_I440 ; break ; case YV12 : input . fmt = VPX_IMG_FMT_YV12 ; break ; } <S2SV_ModStart> - 1 ; int64_t <S2SV_ModEnd> lagged_count = 0 <S2SV_ModStart> . height ) { <S2SV_ModStart> } ) ; } <S2SV_ModStart> ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" ) ; if ( ! input . bit_depth ) { FOREACH_STREAM ( { if ( stream -> config . cfg . g_input_bit_depth ) input . bit_depth = stream -> config . cfg . g_input_bit_depth ; else input . bit_depth = stream -> config . cfg . g_input_bit_depth = ( int ) stream -> config . cfg . g_bit_depth ; } ) ; if ( input . bit_depth > 8 ) input . fmt |= VPX_IMG_FMT_HIGHBITDEPTH ; } else { FOREACH_STREAM ( { stream -> config . cfg . g_input_bit_depth = input . bit_depth ; } ) ; } <S2SV_ModStart> & raw , input . fmt , <S2SV_ModEnd> input . width <S2SV_ModStart> , & global , & input . pixel_aspect_ratio <S2SV_ModStart> ) ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global . codec -> name , ""vp9"" ) == 0 || strcmp ( global . codec -> name , ""vp10"" ) == 0 ) { FOREACH_STREAM ( { if ( stream -> config . use_16bit_internal ) { use_16bit_internal = 1 ; } if ( stream -> config . cfg . g_profile == 0 ) { input_shift = 0 ; } else { input_shift = ( int ) stream -> config . cfg . g_bit_depth - stream -> config . cfg . g_input_bit_depth ; } } ) ; } # endif <S2SV_ModStart> estimated_time_left ) ; <S2SV_ModEnd> } } else <S2SV_ModStart> skip_frames ) { # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * frame_to_encode ; if ( input_shift || ( use_16bit_internal && input . bit_depth == 8 ) ) { assert ( use_16bit_internal ) ; if ( ! allocated_raw_shift ) { vpx_img_alloc ( & raw_shift , raw . fmt | VPX_IMG_FMT_HIGHBITDEPTH , input . width , input . height , 32 ) ; allocated_raw_shift = 1 ; } vpx_img_upshift ( & raw_shift , & raw , input_shift ) ; frame_to_encode = & raw_shift ; } else { frame_to_encode = & raw ; } vpx_usec_timer_start ( & timer ) ; if ( use_16bit_internal ) { assert ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ; FOREACH_STREAM ( { if ( stream -> config . use_16bit_internal ) encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ; else assert ( 0 ) ; } ) ; } else { assert ( ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) == 0 ) ; FOREACH_STREAM ( encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ) ; } # else <S2SV_ModStart> ) ) ; # endif <S2SV_ModStart> . length && streams != NULL && <S2SV_ModStart> limit ) { const int64_t <S2SV_ModEnd> frame_in_lagged = ( <S2SV_ModStart> } else { const int64_t <S2SV_ModEnd> input_pos = ftello <S2SV_ModStart> file ) ; const int64_t <S2SV_ModEnd> input_pos_lagged = input_pos <S2SV_ModStart> - lagged_count ; const <S2SV_ModStart> stdout ) ; if ( ! global . quiet ) fprintf ( stderr , ""\\033[K"" ) ; <S2SV_ModStart> . quiet ) { <S2SV_ModStart> , ""\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>%7"" PRId64 ""b/f<S2SV_blank>%7"" <S2SV_ModEnd> PRId64 ""b/s"" ""<S2SV_blank>%7"" <S2SV_ModStart> seen_frames ? ( int64_t <S2SV_ModEnd> ) ( stream <S2SV_ModStart> seen_frames ) ) ) ; } <S2SV_ModEnd> if ( global <S2SV_ModStart> . show_psnr ) { if ( global . codec -> fourcc == VP9_FOURCC ) { FOREACH_STREAM ( <S2SV_ModEnd> show_psnr ( stream <S2SV_ModStart> show_psnr ( stream , ( 1 << stream -> config . cfg . g_input_bit_depth ) - 1 ) ) ; } else { FOREACH_STREAM ( show_psnr ( stream , 255.0 ) ) ; } } <S2SV_ModEnd> FOREACH_STREAM ( vpx_codec_destroy <S2SV_ModStart> ) ) ; # if CONFIG_FP_MB_STATS FOREACH_STREAM ( stats_close ( & stream -> fpmb_stats , global . passes - 1 ) ) ; # endif <S2SV_ModStart> ) ; } ) ; # endif # if CONFIG_VP9_HIGHBITDEPTH if ( allocated_raw_shift ) vpx_img_free ( & raw_shift
",CWE-119
213,"CWE-787 <S2SV_StartBug> uint32_t GetPayloadTime ( size_t handle , uint32_t index , float * in , float * out ) <S2SV_EndBug> { mp4object * mp4 = ( mp4object * ) handle ; <S2SV_StartBug> if ( mp4 == NULL ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets == 0 || mp4 -> basemetadataduration == 0 || mp4 -> meta_clockdemon == 0 || in == NULL || out == NULL ) return 1 ; <S2SV_EndBug> <S2SV_StartBug> * in = ( float ) ( ( double ) index * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> * out = ( float ) ( ( double ) ( index + 1 ) * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> uint32_t index , double <S2SV_ModEnd> * in , <S2SV_ModStart> * in , double <S2SV_ModEnd> * out ) <S2SV_ModStart> NULL ) return GPMF_ERROR_MEMORY <S2SV_ModEnd> ; if ( <S2SV_ModStart> NULL ) return GPMF_ERROR_MEMORY <S2SV_ModEnd> ; * in <S2SV_ModStart> * in = <S2SV_ModEnd> ( ( double <S2SV_ModStart> * out = <S2SV_ModEnd> ( ( double <S2SV_ModStart> ) ; return GPMF_OK <S2SV_ModEnd> ; } <S2SV_null>
",CWE-787
215,"CWE-20 error_t httpReadRequestHeader ( HttpConnection * connection ) { error_t error ; size_t length ; error = socketSetTimeout ( connection -> socket , HTTP_SERVER_IDLE_TIMEOUT ) ; if ( error ) return error ; error = httpReceive ( connection , connection -> buffer , HTTP_SERVER_BUFFER_SIZE - 1 , & length , SOCKET_FLAG_BREAK_CRLF ) ; if ( error ) return error ; error = socketSetTimeout ( connection -> socket , HTTP_SERVER_TIMEOUT ) ; if ( error ) return error ; connection -> buffer [ length ] = '\\0' ; TRACE_INFO ( ""%s"" , connection -> buffer ) ; error = httpParseRequestLine ( connection , connection -> buffer ) ; if ( error ) return error ; connection -> request . chunkedEncoding = FALSE ; connection -> request . contentLength = 0 ; # if ( HTTP_SERVER_WEB_SOCKET_SUPPORT == ENABLED ) connection -> request . upgradeWebSocket = FALSE ; connection -> request . connectionUpgrade = FALSE ; osStrcpy ( connection -> request . clientKey , """" ) ; # endif if ( connection -> request . version >= HTTP_VERSION_1_0 ) { char_t firstChar ; char_t * separator ; char_t * name ; char_t * value ; firstChar = '\\0' ; while ( 1 ) { error = httpReadHeaderField ( connection , connection -> buffer , HTTP_SERVER_BUFFER_SIZE , & firstChar ) ; if ( error ) return error ; TRACE_DEBUG ( ""%s"" , connection -> buffer ) ; if ( ! osStrcmp ( connection -> buffer , ""\\r\\n"" ) ) break ; <S2SV_StartBug> separator = strchr ( connection -> buffer , ':' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( connection -> buffer ) ; value = strTrimWhitespace ( separator + 1 ) ; httpParseHeaderField ( connection , name , value ) ; } } } if ( connection -> request . chunkedEncoding ) { connection -> request . byteCount = 0 ; connection -> request . firstChunk = TRUE ; connection -> request . lastChunk = FALSE ; } else { connection -> request . byteCount = connection -> request . contentLength ; } return NO_ERROR ; }
","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( connection ->
",CWE-20
216,"CWE-400 static int session_new ( nghttp2_session * * session_ptr , const nghttp2_session_callbacks * callbacks , void * user_data , int server , const nghttp2_option * option , nghttp2_mem * mem ) { int rv ; size_t nbuffer ; size_t max_deflate_dynamic_table_size = NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE ; if ( mem == NULL ) { mem = nghttp2_mem_default ( ) ; } * session_ptr = nghttp2_mem_calloc ( mem , 1 , sizeof ( nghttp2_session ) ) ; if ( * session_ptr == NULL ) { rv = NGHTTP2_ERR_NOMEM ; goto fail_session ; } ( * session_ptr ) -> mem = * mem ; mem = & ( * session_ptr ) -> mem ; nghttp2_stream_init ( & ( * session_ptr ) -> root , 0 , NGHTTP2_STREAM_FLAG_NONE , NGHTTP2_STREAM_IDLE , NGHTTP2_DEFAULT_WEIGHT , 0 , 0 , NULL , mem ) ; ( * session_ptr ) -> remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ; ( * session_ptr ) -> recv_window_size = 0 ; ( * session_ptr ) -> consumed_size = 0 ; ( * session_ptr ) -> recv_reduction = 0 ; ( * session_ptr ) -> local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ; ( * session_ptr ) -> goaway_flags = NGHTTP2_GOAWAY_NONE ; ( * session_ptr ) -> local_last_stream_id = ( 1u << 31 ) - 1 ; ( * session_ptr ) -> remote_last_stream_id = ( 1u << 31 ) - 1 ; ( * session_ptr ) -> pending_local_max_concurrent_stream = NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS ; ( * session_ptr ) -> pending_enable_push = 1 ; if ( server ) { ( * session_ptr ) -> server = 1 ; } init_settings ( & ( * session_ptr ) -> remote_settings ) ; init_settings ( & ( * session_ptr ) -> local_settings ) ; ( * session_ptr ) -> max_incoming_reserved_streams = NGHTTP2_MAX_INCOMING_RESERVED_STREAMS ; ( * session_ptr ) -> remote_settings . max_concurrent_streams = 100 ; ( * session_ptr ) -> max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN ; ( * session_ptr ) -> max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM ; <S2SV_StartBug> if ( option ) { <S2SV_EndBug> if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE ) && option -> no_auto_window_update ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE ; } if ( option -> opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS ) { ( * session_ptr ) -> remote_settings . max_concurrent_streams = option -> peer_max_concurrent_streams ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS ) { ( * session_ptr ) -> max_incoming_reserved_streams = option -> max_reserved_remote_streams ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC ) && option -> no_recv_client_magic ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING ) && option -> no_http_messaging ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING ; } if ( option -> opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES ) { memcpy ( ( * session_ptr ) -> user_recv_ext_types , option -> user_recv_ext_types , sizeof ( ( * session_ptr ) -> user_recv_ext_types ) ) ; } if ( option -> opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES ) { ( * session_ptr ) -> builtin_recv_ext_types = option -> builtin_recv_ext_types ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK ) && option -> no_auto_ping_ack ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH ) { ( * session_ptr ) -> max_send_header_block_length = option -> max_send_header_block_length ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE ) { max_deflate_dynamic_table_size = option -> max_deflate_dynamic_table_size ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS ) && option -> no_closed_streams ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK ) { ( * session_ptr ) -> max_outbound_ack = option -> max_outbound_ack ; } <S2SV_StartBug> } <S2SV_EndBug> rv = nghttp2_hd_deflate_init2 ( & ( * session_ptr ) -> hd_deflater , max_deflate_dynamic_table_size , mem ) ; if ( rv != 0 ) { goto fail_hd_deflater ; } rv = nghttp2_hd_inflate_init ( & ( * session_ptr ) -> hd_inflater , mem ) ; if ( rv != 0 ) { goto fail_hd_inflater ; } rv = nghttp2_map_init ( & ( * session_ptr ) -> streams , mem ) ; if ( rv != 0 ) { goto fail_map ; } nbuffer = ( ( * session_ptr ) -> max_send_header_block_length + NGHTTP2_FRAMEBUF_CHUNKLEN - 1 ) / NGHTTP2_FRAMEBUF_CHUNKLEN ; if ( nbuffer == 0 ) { nbuffer = 1 ; } rv = nghttp2_bufs_init3 ( & ( * session_ptr ) -> aob . framebufs , NGHTTP2_FRAMEBUF_CHUNKLEN , nbuffer , 1 , NGHTTP2_FRAME_HDLEN + 1 , mem ) ; if ( rv != 0 ) { goto fail_aob_framebuf ; } active_outbound_item_reset ( & ( * session_ptr ) -> aob , mem ) ; ( * session_ptr ) -> callbacks = * callbacks ; ( * session_ptr ) -> user_data = user_data ; session_inbound_frame_reset ( * session_ptr ) ; if ( nghttp2_enable_strict_preface ) { nghttp2_inbound_frame * iframe = & ( * session_ptr ) -> iframe ; if ( server && ( ( * session_ptr ) -> opt_flags & NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC ) == 0 ) { iframe -> state = NGHTTP2_IB_READ_CLIENT_MAGIC ; iframe -> payloadleft = NGHTTP2_CLIENT_MAGIC_LEN ; } else { iframe -> state = NGHTTP2_IB_READ_FIRST_SETTINGS ; } if ( ! server ) { ( * session_ptr ) -> aob . state = NGHTTP2_OB_SEND_CLIENT_MAGIC ; nghttp2_bufs_add ( & ( * session_ptr ) -> aob . framebufs , NGHTTP2_CLIENT_MAGIC , NGHTTP2_CLIENT_MAGIC_LEN ) ; } } return 0 ; fail_aob_framebuf : nghttp2_map_free ( & ( * session_ptr ) -> streams ) ; fail_map : nghttp2_hd_inflate_free ( & ( * session_ptr ) -> hd_inflater ) ; fail_hd_inflater : nghttp2_hd_deflate_free ( & ( * session_ptr ) -> hd_deflater ) ; fail_hd_deflater : nghttp2_mem_free ( mem , * session_ptr ) ; fail_session : return rv ; }
","<S2SV_ModStart> = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM ; ( * session_ptr ) -> max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS ; <S2SV_ModStart> max_outbound_ack ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS ) && option -> max_settings ) { ( * session_ptr ) -> max_settings = option -> max_settings ; }
",CWE-400
220,"CWE-200 static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }
","<S2SV_ModStart> ; if ( ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> inode -> i_flock <S2SV_ModStart> F_RDLCK ) ) <S2SV_ModEnd> return 1 ;
",CWE-200
221,"CWE-552 static ssize_t _hostsock_recvfrom ( oe_fd_t * sock_ , void * buf , size_t count , int flags , <S2SV_StartBug> const struct oe_sockaddr * src_addr , <S2SV_EndBug> oe_socklen_t * addrlen ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; <S2SV_StartBug> oe_socklen_t addrlen_in = 0 ; <S2SV_EndBug> oe_errno = 0 ; <S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( addrlen ) addrlen_in = * addrlen ; if ( oe_syscall_recvfrom_ocall ( & ret , sock -> host_fd , buf , count , flags , <S2SV_StartBug> ( struct oe_sockaddr * ) src_addr , <S2SV_EndBug> addrlen_in , <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> int flags , <S2SV_ModEnd> struct oe_sockaddr * <S2SV_ModStart> ; oe_socklen_t addrlen_in = 0 ; oe_socklen_t addrlen_out <S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( src_addr && <S2SV_ModEnd> addrlen ) addrlen_in <S2SV_ModStart> , flags , <S2SV_ModEnd> src_addr , addrlen_in <S2SV_ModStart> , addrlen_in , & addrlen_out <S2SV_ModEnd> ) != OE_OK <S2SV_ModStart> ) ; } if ( src_addr && addrlen ) { if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ; } if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",CWE-552
222,"CWE-119 WORD32 ih264d_parse_pslice ( dec_struct_t * ps_dec , UWORD16 u2_first_mb_in_slice ) { dec_pic_params_t * ps_pps = ps_dec -> ps_cur_pps ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD8 u1_mbaff = ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; UWORD32 u4_temp ; WORD32 i_temp ; WORD32 ret ; { WORD8 * pi1_buf ; WORD16 * pi2_mv = ps_dec -> s_default_mv_pred . i2_mv ; WORD32 * pi4_mv = ( WORD32 * ) pi2_mv ; WORD16 * pi16_refFrame ; pi1_buf = ps_dec -> s_default_mv_pred . i1_ref_frame ; pi16_refFrame = ( WORD16 * ) pi1_buf ; * pi4_mv = 0 ; * ( pi4_mv + 1 ) = 0 ; * pi16_refFrame = OUT_OF_RANGE_REF ; ps_dec -> s_default_mv_pred . u1_col_ref_pic_idx = ( UWORD8 ) - 1 ; ps_dec -> s_default_mv_pred . u1_pic_type = ( UWORD8 ) - 1 ; } ps_cur_slice -> u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>num_ref_idx_override_flag"" , ps_cur_slice -> u1_num_ref_idx_active_override_flag ) ; u4_temp = ps_dec -> ps_cur_pps -> u1_num_ref_idx_lx_active [ 0 ] ; if ( ps_cur_slice -> u1_num_ref_idx_active_override_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) + 1 ; } { UWORD8 u1_max_ref_idx = MAX_FRAMES << u1_field_pic_flag ; if ( u4_temp > u1_max_ref_idx ) { return ERROR_NUM_REF ; } ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>num_ref_idx_l0_active_minus1"" , ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] - 1 ) ; } { UWORD8 uc_refIdxReFlagL0 = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>ref_pic_list_reordering_flag_l0"" , uc_refIdxReFlagL0 ) ; { UWORD8 init_idx_flg = ( ps_dec -> u1_pr_sl_type != ps_dec -> ps_cur_slice -> u1_slice_type ) ; if ( ps_dec -> u1_first_pb_nal_in_pic || ( init_idx_flg & ! ps_dec -> u1_sl_typ_5_9 ) || ps_dec -> u1_num_ref_idx_lx_active_prev != ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ) { ih264d_init_ref_idx_lx_p ( ps_dec ) ; } if ( ps_dec -> u1_first_pb_nal_in_pic & ps_dec -> u1_sl_typ_5_9 ) ps_dec -> u1_first_pb_nal_in_pic = 0 ; } ps_dec -> u1_num_ref_idx_lx_active_prev = ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; if ( uc_refIdxReFlagL0 ) { WORD8 ret ; ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_mod_dpb [ 0 ] ; ret = ih264d_ref_idx_reordering ( ps_dec , 0 ) ; if ( ret == - 1 ) return ERROR_REFIDX_ORDER_T ; ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_mod_dpb [ 0 ] ; } else ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; } { void * * pui_map_ref_idx_to_poc_lx0 , * * pui_map_ref_idx_to_poc_lx1 ; WORD8 idx ; struct pic_buffer_t * ps_pic ; pui_map_ref_idx_to_poc_lx0 = ps_dec -> ppv_map_ref_idx_to_poc + FRM_LIST_L0 ; pui_map_ref_idx_to_poc_lx0 [ 0 ] = 0 ; pui_map_ref_idx_to_poc_lx0 ++ ; for ( idx = 0 ; idx < ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ idx ] ; pui_map_ref_idx_to_poc_lx0 [ idx ] = ( ps_pic -> pu1_buf1 ) ; } pui_map_ref_idx_to_poc_lx1 = ps_dec -> ppv_map_ref_idx_to_poc + FRM_LIST_L1 ; pui_map_ref_idx_to_poc_lx1 [ 0 ] = 0 ; if ( u1_mbaff ) { void * * ppv_map_ref_idx_to_poc_lx_t , * * ppv_map_ref_idx_to_poc_lx_b ; void * * ppv_map_ref_idx_to_poc_lx_t1 , * * ppv_map_ref_idx_to_poc_lx_b1 ; ppv_map_ref_idx_to_poc_lx_t = ps_dec -> ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L0 ; ppv_map_ref_idx_to_poc_lx_b = ps_dec -> ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L0 ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_t ++ ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_b ++ ; idx = 0 ; for ( idx = 0 ; idx < ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ idx ] ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ 1 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t [ 1 ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t += 2 ; ppv_map_ref_idx_to_poc_lx_b += 2 ; } ppv_map_ref_idx_to_poc_lx_t1 = ps_dec -> ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L1 ; ppv_map_ref_idx_to_poc_lx_t1 [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_b1 = ps_dec -> ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L1 ; ppv_map_ref_idx_to_poc_lx_b1 [ 0 ] = 0 ; } if ( ps_dec -> u4_num_cores >= 3 ) { WORD32 num_entries ; WORD32 size ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; memcpy ( ( void * ) ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc , ps_dec -> ppv_map_ref_idx_to_poc , size ) ; } } if ( ps_pps -> u1_wted_pred_flag ) { ret = ih264d_parse_pred_weight_table ( ps_cur_slice , ps_bitstrm ) ; if ( ret != OK ) return ret ; ih264d_form_pred_weight_matrix ( ps_dec ) ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; } else { ps_dec -> ps_cur_slice -> u2_log2Y_crwd = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; } ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( u1_mbaff && ( u1_field_pic_flag == 0 ) ) { ih264d_convert_frm_mbaff_list ( ps_dec ) ; } if ( ps_cur_slice -> u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) <S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ; <S2SV_EndBug> else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; } if ( ps_pps -> u1_entropy_coding_mode == CABAC ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_CABAC_INIT_IDC ) { return ERROR_INV_SLICE_HDR_T ; } ps_cur_slice -> u1_cabac_init_idc = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>cabac_init_idc"" , ps_cur_slice -> u1_cabac_init_idc ) ; } i_temp = ps_pps -> u1_pic_init_qp + ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( i_temp < 0 ) || ( i_temp > 51 ) ) { return ERROR_INV_RANGE_QP_T ; } ps_cur_slice -> u1_slice_qp = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_qp_delta"" , ( WORD8 ) ( ps_cur_slice -> u1_slice_qp - ps_pps -> u1_pic_init_qp ) ) ; if ( ps_pps -> u1_deblocking_filter_parameters_present_flag == 1 ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > SLICE_BOUNDARY_DBLK_DISABLED ) { return ERROR_INV_SLICE_HDR_T ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>disable_deblocking_filter_idc"" , u4_temp ) ; ps_cur_slice -> u1_disable_dblk_filter_idc = u4_temp ; if ( u4_temp != 1 ) { i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_cur_slice -> i1_slice_alpha_c0_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_alpha_c0_offset_div2"" , ps_cur_slice -> i1_slice_alpha_c0_offset >> 1 ) ; i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_cur_slice -> i1_slice_beta_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_beta_offset_div2"" , ps_cur_slice -> i1_slice_beta_offset >> 1 ) ; } else { ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_cur_slice -> i1_slice_beta_offset = 0 ; } } else { ps_cur_slice -> u1_disable_dblk_filter_idc = 0 ; ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_cur_slice -> i1_slice_beta_offset = 0 ; } ps_dec -> u1_slice_header_done = 2 ; if ( ps_pps -> u1_entropy_coding_mode ) { SWITCHOFFTRACE ; SWITCHONTRACECABAC ; ps_dec -> pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac ; ps_dec -> pf_parse_inter_mb = ih264d_parse_pmb_cabac ; ih264d_init_cabac_contexts ( P_SLICE , ps_dec ) ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff ; else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff ; } else { SWITCHONTRACE ; SWITCHOFFTRACECABAC ; ps_dec -> pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc ; ps_dec -> pf_parse_inter_mb = ih264d_parse_pmb_cavlc ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff ; } else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff ; } ps_dec -> u1_B = 0 ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ret = ps_dec -> pf_parse_inter_slice ( ps_dec , ps_cur_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; return OK ; }
","<S2SV_ModStart> -> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> -> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_bitstrm ->
",CWE-119
223,"CWE-119 <S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> int size_group ) { <S2SV_StartBug> const MB_PREDICTION_MODE y_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . y_mode_prob [ size_group ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . y_mode [ size_group ] [ y_mode ] ; return y_mode ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_intra_mode_y ( VP9_COMMON <S2SV_ModStart> * cm , MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> ) { const PREDICTION_MODE <S2SV_ModEnd> y_mode = read_intra_mode <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> y_mode_prob [ size_group <S2SV_ModStart> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> y_mode [ size_group
",CWE-119
231,"CWE-617 static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; <S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }
","<S2SV_ModStart> , n ) ; if ( w == NULL ) return 0
",CWE-617
232,"CWE-20 static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; PixelTrait alpha_trait ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } <S2SV_StartBug> if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { alpha_trait = BlendPixelTrait ; decoder = ReadUncompressedRGBA ; } else { alpha_trait = UndefinedPixelTrait ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { alpha_trait = UndefinedPixelTrait ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { alpha_trait = UndefinedPixelTrait ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { alpha_trait = BlendPixelTrait ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { alpha_trait = BlendPixelTrait ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; <S2SV_StartBug> for ( n = 0 ; n < num_images ; n ++ ) <S2SV_EndBug> { if ( n != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> alpha_trait = alpha_trait ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> != MagickTrue ) <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> ""ImproperImageHeader"" ) ; <S2SV_ModEnd> if ( dds_info <S2SV_ModStart> . depth ; if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;
",CWE-20
233,"CWE-119 static void encode_block ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct encode_b_args * const args = arg ; MACROBLOCK * const x = args -> x ; MACROBLOCKD * const xd = & x -> e_mbd ; struct optimize_ctx * const ctx = args -> ctx ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> int i , j ; uint8_t * dst ; ENTROPY_CONTEXT * a , * l ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; dst = & pd -> dst . buf [ 4 * j * pd -> dst . stride + 4 * i ] ; a = & ctx -> ta [ plane ] [ i ] ; l = & ctx -> tl [ plane ] [ j ] ; if ( x -> zcoeff_blk [ tx_size ] [ block ] && plane == 0 ) { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } <S2SV_StartBug> if ( ! x -> skip_recode ) <S2SV_EndBug> <S2SV_StartBug> vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; <S2SV_EndBug> if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) { <S2SV_StartBug> optimize_b ( plane , block , plane_bsize , tx_size , x , a , l ) ; <S2SV_EndBug> } else { * a = * l = p -> eobs [ block ] > 0 ; } if ( p -> eobs [ block ] ) * ( args -> skip ) = 0 ; if ( x -> skip_encode || p -> eobs [ block ] == 0 ) return ; <S2SV_StartBug> switch ( tx_size ) { <S2SV_EndBug> case TX_32X32 : <S2SV_StartBug> vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; case TX_16X16 : <S2SV_StartBug> vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; case TX_8X8 : <S2SV_StartBug> vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; case TX_4X4 : <S2SV_StartBug> xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; default : assert ( 0 && ""Invalid<S2SV_blank>transform<S2SV_blank>size"" ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> plane ] ; tran_low_t <S2SV_ModEnd> * const dqcoeff <S2SV_ModStart> -> skip_recode ) { if ( x -> quant_fp ) { if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC && plane == 0 ) { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } else { vp9_xform_quant_fp ( x , plane , block , plane_bsize , tx_size ) ; } } else { if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { int txfm_blk_index = ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ; if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_NONE ) { <S2SV_ModStart> tx_size ) ; } else if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_AC_ONLY ) { vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; } else { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } } else { vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; } } } <S2SV_ModStart> ) ) { const int ctx = combine_entropy_contexts ( * a , * l ) ; * a = * l = optimize_b ( x , plane , block , tx_size , ctx ) > 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) return ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> case TX_32X32 : vp9_highbd_idct32x32_add <S2SV_ModEnd> ( dqcoeff , <S2SV_ModStart> . stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; break <S2SV_ModStart> case TX_16X16 : vp9_highbd_idct16x16_add <S2SV_ModEnd> ( dqcoeff , <S2SV_ModStart> . stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; break <S2SV_ModStart> case TX_8X8 : vp9_highbd_idct8x8_add <S2SV_ModEnd> ( dqcoeff , <S2SV_ModStart> . stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; break <S2SV_ModStart> case TX_4X4 : x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; break <S2SV_ModStart> ) ; } return ; } # endif switch ( tx_size ) { case TX_32X32 : vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_16X16 : vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_8X8 : vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_4X4 : x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; default : assert ( 0 && ""Invalid<S2SV_blank>transform<S2SV_blank>size"" ) ; break ; }
",CWE-119
235,"CWE-190 void jas_matrix_asl ( jas_matrix_t * matrix , int n ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = jas_seqent_asl ( * data , n ) ; } } } }
","<S2SV_ModStart> n ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
",CWE-190
237,"CWE-125 PyObject * ast2obj_stmt ( void * _o ) { stmt_ty o = ( stmt_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case FunctionDef_kind : result = PyType_GenericNew ( FunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . FunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . FunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . AsyncFunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . AsyncFunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ClassDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . bases , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_bases , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . keywords , ast2obj_keyword ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_keywords , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Return_kind : result = PyType_GenericNew ( Return_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Return . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Delete_kind : result = PyType_GenericNew ( Delete_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Delete . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assign_kind : result = PyType_GenericNew ( Assign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Assign . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . Assign . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AugAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . AugAssign . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AugAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AnnAssign_kind : result = PyType_GenericNew ( AnnAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AnnAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . AnnAssign . simple ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_simple , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case For_kind : result = PyType_GenericNew ( For_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . For . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . For . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . For . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AsyncFor . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFor . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . While . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case If_kind : result = PyType_GenericNew ( If_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . If . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case With_kind : result = PyType_GenericNew ( With_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . With . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . With . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . With . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . AsyncWith . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncWith . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Raise . exc ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_exc , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Raise . cause ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_cause , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Try_kind : result = PyType_GenericNew ( Try_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Try . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . handlers , ast2obj_excepthandler ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_handlers , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . finalbody , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_finalbody , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assert_kind : result = PyType_GenericNew ( Assert_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Assert . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assert . msg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_msg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Import_kind : result = PyType_GenericNew ( Import_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Import . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ImportFrom_kind : result = PyType_GenericNew ( ImportFrom_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ImportFrom . module ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_module , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ImportFrom . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . ImportFrom . level ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_level , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Global_kind : result = PyType_GenericNew ( Global_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Global . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Nonlocal_kind : result = PyType_GenericNew ( Nonlocal_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Nonlocal . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expr_kind : result = PyType_GenericNew ( Expr_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expr . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Pass_kind : result = PyType_GenericNew ( Pass_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Break_kind : result = PyType_GenericNew ( Break_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Continue_kind : result = PyType_GenericNew ( Continue_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",CWE-125
238,"CWE-617 static bool access_pmu_evcntr ( struct kvm_vcpu * vcpu , struct sys_reg_params * p , const struct sys_reg_desc * r ) { u64 idx ; if ( ! kvm_arm_pmu_v3_ready ( vcpu ) ) return trap_raz_wi ( vcpu , p , r ) ; if ( r -> CRn == 9 && r -> CRm == 13 ) { if ( r -> Op2 == 2 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = vcpu_sys_reg ( vcpu , PMSELR_EL0 ) & ARMV8_PMU_COUNTER_MASK ; } else if ( r -> Op2 == 0 ) { if ( pmu_access_cycle_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } } else if ( r -> CRn == 14 && ( r -> CRm & 12 ) == 8 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ( ( r -> CRm & 3 ) << 3 ) | ( r -> Op2 & 7 ) ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } if ( ! pmu_counter_idx_valid ( vcpu , idx ) ) return false ; if ( p -> is_write ) { if ( pmu_access_el0_disabled ( vcpu ) ) return false ; kvm_pmu_set_counter_value ( vcpu , idx , p -> regval ) ; } else { p -> regval = kvm_pmu_get_counter_value ( vcpu , idx ) ; } return true ; }
","<S2SV_ModStart> } else { return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> } else if <S2SV_ModStart> } else { return false <S2SV_ModEnd> ; } if
",CWE-617
248,"CWE-20 void MoveTo ( double x1 , double y1 ) { <S2SV_StartBug> outpos += <S2SV_EndBug> sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m"" , x1 , y1 ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> y1 ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m"" , <S2SV_ModStart> y1 ) ; sendClean ( outputbuffer ) ;
",CWE-20
249,"CWE-200 static long __media_device_enum_links ( struct media_device * mdev , struct media_links_enum * links ) { struct media_entity * entity ; entity = find_entity ( mdev , links -> entity ) ; if ( entity == NULL ) return - EINVAL ; if ( links -> pads ) { unsigned int p ; for ( p = 0 ; p < entity -> num_pads ; p ++ ) { struct media_pad_desc pad ; <S2SV_StartBug> media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; <S2SV_EndBug> if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ; } } if ( links -> links ) { struct media_link_desc __user * ulink ; unsigned int l ; for ( l = 0 , ulink = links -> links ; l < entity -> num_links ; l ++ ) { struct media_link_desc link ; if ( entity -> links [ l ] . source -> entity != entity ) continue ; <S2SV_StartBug> media_device_kpad_to_upad ( entity -> links [ l ] . source , <S2SV_EndBug> & link . source ) ; media_device_kpad_to_upad ( entity -> links [ l ] . sink , & link . sink ) ; link . flags = entity -> links [ l ] . flags ; if ( copy_to_user ( ulink , & link , sizeof ( * ulink ) ) ) return - EFAULT ; ulink ++ ; } } return 0 ; }
","<S2SV_ModStart> media_pad_desc pad ; memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> ) continue ; memset ( & link , 0 , sizeof ( link ) ) ;
",CWE-200
250,"CWE-189 static int efx_probe_all ( struct efx_nic * efx ) { int rc ; rc = efx_probe_nic ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>NIC\\n"" ) ; goto fail1 ; } rc = efx_probe_port ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>port\\n"" ) ; goto fail2 ; } <S2SV_StartBug> efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ; <S2SV_EndBug> rc = efx_probe_channels ( efx ) ; if ( rc ) goto fail3 ; rc = efx_probe_filters ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>filter<S2SV_blank>tables\\n"" ) ; goto fail4 ; } return 0 ; fail4 : efx_remove_channels ( efx ) ; fail3 : efx_remove_port ( efx ) ; fail2 : efx_remove_nic ( efx ) ; fail1 : return rc ; }
","<S2SV_ModStart> fail2 ; } BUILD_BUG_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT ) ; if ( WARN_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT ( efx ) ) ) { rc = - EINVAL ; goto fail3 ; }
",CWE-189
256,"CWE-119 static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) { ssize_t l , ll , o ; double now ; uint8_t * ptr ; struct vsb * synth_body ; CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ; AN ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ; assert ( bo -> director_state == DIR_S_NULL ) ; wrk -> stats -> fetch_failed ++ ; now = W_TIM_real ( wrk ) ; VSLb_ts_busyobj ( bo , ""Error"" , now ) ; if ( bo -> fetch_objcore -> stobj -> stevedore != NULL ) ObjFreeObj ( bo -> wrk , bo -> fetch_objcore ) ; HTTP_Setup ( bo -> beresp , bo -> ws , bo -> vsl , SLT_BerespMethod ) ; http_PutResponse ( bo -> beresp , ""HTTP/1.1"" , 503 , ""Backend<S2SV_blank>fetch<S2SV_blank>failed"" ) ; http_TimeHeader ( bo -> beresp , ""Date:<S2SV_blank>"" , now ) ; http_SetHeader ( bo -> beresp , ""Server:<S2SV_blank>Varnish"" ) ; bo -> fetch_objcore -> t_origin = now ; if ( ! VTAILQ_EMPTY ( & bo -> fetch_objcore -> objhead -> waitinglist ) ) { bo -> fetch_objcore -> ttl = 1 ; bo -> fetch_objcore -> grace = 5 ; bo -> fetch_objcore -> keep = 5 ; } else { bo -> fetch_objcore -> ttl = 0 ; bo -> fetch_objcore -> grace = 0 ; bo -> fetch_objcore -> keep = 0 ; } synth_body = VSB_new_auto ( ) ; AN ( synth_body ) ; VCL_backend_error_method ( bo -> vcl , wrk , NULL , bo , synth_body ) ; AZ ( VSB_finish ( synth_body ) ) ; if ( wrk -> handling == VCL_RET_ABANDON || wrk -> handling == VCL_RET_FAIL ) { VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } if ( wrk -> handling == VCL_RET_RETRY ) { VSB_destroy ( & synth_body ) ; if ( bo -> retries ++ < cache_param -> max_retries ) return ( F_STP_RETRY ) ; VSLb ( bo -> vsl , SLT_VCL_Error , ""Too<S2SV_blank>many<S2SV_blank>retries,<S2SV_blank>failing"" ) ; return ( F_STP_FAIL ) ; } assert ( wrk -> handling == VCL_RET_DELIVER ) ; bo -> vfc -> bo = bo ; bo -> vfc -> wrk = bo -> wrk ; bo -> vfc -> oc = bo -> fetch_objcore ; bo -> vfc -> http = bo -> beresp ; bo -> vfc -> esi_req = bo -> bereq ; if ( vbf_beresp2obj ( bo ) ) { ( void ) VFP_Error ( bo -> vfc , ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>storage"" ) ; VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } ll = VSB_len ( synth_body ) ; o = 0 ; while ( ll > 0 ) { l = ll ; if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ; <S2SV_StartBug> memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ; <S2SV_EndBug> VFP_Extend ( bo -> vfc , l ) ; ll -= l ; o += l ; } AZ ( ObjSetU64 ( wrk , bo -> fetch_objcore , OA_LEN , o ) ) ; VSB_destroy ( & synth_body ) ; HSH_Unbusy ( wrk , bo -> fetch_objcore ) ; ObjSetState ( wrk , bo -> fetch_objcore , BOS_FINISHED ) ; return ( F_STP_DONE ) ; }
","<S2SV_ModStart> ) break ; if ( l > ll ) l = ll ;
",CWE-119
260,"CWE-119 WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16 ( UWORD32 u4_isdc , UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD32 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; if ( u4_trailing_ones < 3 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : 1 ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = 2 + ( MIN ( u4_lev_prefix , 15 ) << 1 ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } } else { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = ( u4_lev_prefix - 3 ) ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( 15 , u4_lev_prefix ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u4_suffix_len < 6 ) ? ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) : 0 ; } } if ( u4_total_coeff < ( 16 - u4_isdc ) ) { UWORD32 u4_index ; const UWORD8 ( * ppu1_total_zero_lkup ) [ 16 ] = ( const UWORD8 ( * ) [ 16 ] ) gau1_ih264d_table_total_zero_11to15 ; NEXTBITS ( u4_index , u4_bitstream_offset , pu4_bitstrm_buf , 4 ) ; u4_total_zeroes = ppu1_total_zero_lkup [ u4_total_coeff - 11 ] [ u4_index ] ; FLUSHBITS ( u4_bitstream_offset , ( u4_total_zeroes >> 4 ) ) ; u4_total_zeroes &= 0xf ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; WORD32 k ; UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc ; WORD32 u4_zeroes_left = u4_total_zeroes ; k = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( ( u4_zeroes_left > 0 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } if ( u4_zeroes_left < 0 ) return - 1 ; while ( k >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; return 0 ; }
","<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t
",CWE-119
261,"CWE-190 jas_image_t * bmp_decode ( jas_stream_t * in , char * optstr ) { jas_image_t * image ; bmp_hdr_t hdr ; bmp_info_t * info ; uint_fast16_t cmptno ; jas_image_cmptparm_t cmptparms [ 3 ] ; jas_image_cmptparm_t * cmptparm ; uint_fast16_t numcmpts ; long n ; <S2SV_StartBug> image = 0 ; <S2SV_EndBug> info = 0 ; if ( optstr ) { jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\n"" ) ; } jas_eprintf ( ""THE<S2SV_blank>BMP<S2SV_blank>FORMAT<S2SV_blank>IS<S2SV_blank>NOT<S2SV_blank>FULLY<S2SV_blank>SUPPORTED!\\n"" ""THAT<S2SV_blank>IS,<S2SV_blank>THE<S2SV_blank>JASPER<S2SV_blank>SOFTWARE<S2SV_blank>CANNOT<S2SV_blank>DECODE<S2SV_blank>ALL<S2SV_blank>TYPES<S2SV_blank>OF<S2SV_blank>BMP<S2SV_blank>DATA.\\n"" ""IF<S2SV_blank>YOU<S2SV_blank>HAVE<S2SV_blank>ANY<S2SV_blank>PROBLEMS,<S2SV_blank>PLEASE<S2SV_blank>TRY<S2SV_blank>CONVERTING<S2SV_blank>YOUR<S2SV_blank>IMAGE<S2SV_blank>DATA\\n"" ""TO<S2SV_blank>THE<S2SV_blank>PNM<S2SV_blank>FORMAT,<S2SV_blank>AND<S2SV_blank>USING<S2SV_blank>THIS<S2SV_blank>FORMAT<S2SV_blank>INSTEAD.\\n"" ) ; if ( bmp_gethdr ( in , & hdr ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>header\\n"" ) ; goto error ; } JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n"" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; if ( ! ( info = bmp_getinfo ( in ) ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\n"" ) ; goto error ; } JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\n"" , JAS_CAST ( long , info -> len ) , JAS_CAST ( long , info -> width ) , JAS_CAST ( long , info -> height ) , JAS_CAST ( long , info -> numplanes ) , JAS_CAST ( long , info -> depth ) , JAS_CAST ( long , info -> enctype ) , JAS_CAST ( long , info -> siz ) , JAS_CAST ( long , info -> hres ) , JAS_CAST ( long , info -> vres ) , JAS_CAST ( long , info -> numcolors ) , JAS_CAST ( long , info -> mincolors ) ) ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { <S2SV_StartBug> jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; <S2SV_EndBug> goto error ; } if ( ! bmp_issupported ( & hdr , info ) ) { jas_eprintf ( ""error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n"" ) ; goto error ; } if ( ( n = hdr . off - ( BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN ( info ) ) ) < 0 ) { jas_eprintf ( ""error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n"" ) ; goto error ; } if ( n > 0 ) { jas_eprintf ( ""skipping<S2SV_blank>unknown<S2SV_blank>data<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\\n"" ) ; if ( bmp_gobble ( in , n ) ) { goto error ; } } numcmpts = bmp_numcmpts ( info ) ; for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , ++ cmptparm ) { cmptparm -> tlx = 0 ; cmptparm -> tly = 0 ; cmptparm -> hstep = 1 ; cmptparm -> vstep = 1 ; cmptparm -> width = info -> width ; cmptparm -> height = info -> height ; cmptparm -> prec = 8 ; cmptparm -> sgnd = false ; } if ( ! ( image = jas_image_create ( numcmpts , cmptparms , JAS_CLRSPC_UNKNOWN ) ) ) { goto error ; } if ( numcmpts == 3 ) { jas_image_setclrspc ( image , JAS_CLRSPC_SRGB ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_R ) ) ; jas_image_setcmpttype ( image , 1 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_G ) ) ; jas_image_setcmpttype ( image , 2 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_B ) ) ; } else { jas_image_setclrspc ( image , JAS_CLRSPC_SGRAY ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_GRAY_Y ) ) ; } if ( bmp_getdata ( in , info , image ) ) { goto error ; } bmp_info_destroy ( info ) ; return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { jas_image_destroy ( image ) ; } return 0 ; }
","<S2SV_ModStart> long n ; bmp_dec_importopts_t opts ; size_t num_samples ; image = 0 ; info = 0 ; if ( bmp_dec_parseopts ( optstr , & opts ) ) { goto error <S2SV_ModEnd> ; } jas_eprintf <S2SV_ModStart> jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; goto error ; } if ( ! jas_safe_size_mul3 ( info -> width , info -> height , info -> numplanes , & num_samples ) ) { jas_eprintf ( ""image<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large\\n"" ) ; goto error ; } if ( opts . max_samples > 0 && num_samples > opts . max_samples ) { jas_eprintf ( ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>pixels<S2SV_blank>exceeded<S2SV_blank>(%zu)\\n"" , opts . max_samples
",CWE-190
262,"CWE-20 error_t httpClientFormatAuthorizationField ( HttpClientContext * context ) { size_t n ; char_t * p ; HttpClientAuthParams * authParams ; if ( context -> bufferLen < 2 || context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; authParams = & context -> authParams ; # if ( HTTP_CLIENT_BASIC_AUTH_SUPPORT == ENABLED ) if ( authParams -> mode == HTTP_AUTH_MODE_BASIC ) { size_t k ; size_t m ; n = osStrlen ( authParams -> username ) + osStrlen ( authParams -> password ) ; if ( ( context -> bufferLen + n + 22 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; p = context -> buffer + context -> bufferLen - 2 ; n = osSprintf ( p , ""Authorization:<S2SV_blank>Basic<S2SV_blank>"" ) ; m = osSprintf ( p + n , ""%s:%s"" , authParams -> username , authParams -> password ) ; base64Encode ( p + n , m , NULL , & k ) ; if ( ( context -> bufferLen + n + k ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; base64Encode ( p + n , m , p + n , & k ) ; n += k ; if ( ( context -> bufferLen + n + 2 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osSprintf ( p + n , ""\\r\\n\\r\\n"" ) ; context -> bufferLen = context -> bufferLen + n + 2 ; } else # endif # if ( HTTP_CLIENT_DIGEST_AUTH_SUPPORT == ENABLED ) if ( authParams -> mode == HTTP_AUTH_MODE_DIGEST ) { error_t error ; const char_t * q ; const char_t * uri ; size_t uriLen ; char_t response [ HTTP_CLIENT_MAX_RESPONSE_LEN + 1 ] ; context -> buffer [ context -> bufferLen ] = '\\0' ; <S2SV_StartBug> q = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; uri = q + 1 ; <S2SV_StartBug> q = strchr ( uri , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; uriLen = q - uri ; if ( authParams -> qop == HTTP_AUTH_QOP_AUTH || authParams -> qop == HTTP_AUTH_QOP_AUTH_INT ) { if ( context -> randCallback == NULL ) return ERROR_PRNG_NOT_READY ; error = context -> randCallback ( authParams -> cnonce , HTTP_CLIENT_CNONCE_SIZE ) ; if ( error ) return error ; httpEncodeHexString ( authParams -> cnonce , HTTP_CLIENT_CNONCE_SIZE , authParams -> cnonce ) ; authParams -> nc ++ ; } error = httpClientComputeDigest ( authParams , context -> method , osStrlen ( context -> method ) , uri , uriLen , response ) ; if ( error ) return error ; n = osStrlen ( authParams -> username ) + osStrlen ( authParams -> realm ) + uriLen + osStrlen ( authParams -> nonce ) + osStrlen ( authParams -> cnonce ) + osStrlen ( response ) + osStrlen ( authParams -> opaque ) ; if ( ( context -> bufferLen + n + 121 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; p = context -> buffer + context -> bufferLen - 2 ; n = osSprintf ( p , ""Authorization:<S2SV_blank>Digest<S2SV_blank>"" ) ; n += osSprintf ( p + n , ""username=\\""%s\\"",<S2SV_blank>"" , authParams -> username ) ; n += osSprintf ( p + n , ""realm=\\""%s\\"",<S2SV_blank>"" , authParams -> realm ) ; n += osSprintf ( p + n , ""uri=\\"""" ) ; osStrncpy ( p + n , uri , uriLen ) ; n += uriLen ; n += osSprintf ( p + n , ""\\"",<S2SV_blank>"" ) ; n += osSprintf ( p + n , ""nonce=\\""%s\\"",<S2SV_blank>"" , authParams -> nonce ) ; if ( authParams -> qop == HTTP_AUTH_QOP_AUTH ) { n += osSprintf ( p + n , ""qop=auth,<S2SV_blank>"" ) ; n += osSprintf ( p + n , ""nc=%08x,<S2SV_blank>"" , authParams -> nc ) ; n += osSprintf ( p + n , ""cnonce=\\""%s\\"",<S2SV_blank>"" , authParams -> cnonce ) ; } n += osSprintf ( p + n , ""response=\\""%s\\"""" , response ) ; if ( authParams -> opaque [ 0 ] != '\\0' ) { n += osSprintf ( p + n , "",<S2SV_blank>opaque=\\""%s\\"""" , authParams -> opaque ) ; } osSprintf ( p + n , ""\\r\\n\\r\\n"" ) ; context -> bufferLen = context -> bufferLen + n + 2 ; } else # endif { } return NO_ERROR ; }
","<S2SV_ModStart> ; q = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> ; q = osStrchr <S2SV_ModEnd> ( uri ,
",CWE-20
263,"CWE-000 static void mem_cgroup_usage_unregister_event ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd ) { struct mem_cgroup * memcg = mem_cgroup_from_cont ( cgrp ) ; struct mem_cgroup_thresholds * thresholds ; struct mem_cgroup_threshold_ary * new ; int type = MEMFILE_TYPE ( cft -> private ) ; u64 usage ; int i , j , size ; mutex_lock ( & memcg -> thresholds_lock ) ; if ( type == _MEM ) thresholds = & memcg -> thresholds ; else if ( type == _MEMSWAP ) thresholds = & memcg -> memsw_thresholds ; else BUG ( ) ; <S2SV_StartBug> BUG_ON ( ! thresholds ) ; <S2SV_EndBug> usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ; __mem_cgroup_threshold ( memcg , type == _MEMSWAP ) ; size = 0 ; for ( i = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd != eventfd ) size ++ ; } new = thresholds -> spare ; if ( ! size ) { kfree ( new ) ; new = NULL ; goto swap_buffers ; } new -> size = size ; new -> current_threshold = - 1 ; for ( i = 0 , j = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd == eventfd ) continue ; new -> entries [ j ] = thresholds -> primary -> entries [ i ] ; if ( new -> entries [ j ] . threshold < usage ) { ++ new -> current_threshold ; } j ++ ; } swap_buffers : thresholds -> spare = thresholds -> primary ; rcu_assign_pointer ( thresholds -> primary , new ) ; synchronize_rcu ( ) ; <S2SV_StartBug> mutex_unlock ( & memcg -> thresholds_lock ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ! thresholds ) ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> ( ) ; unlock :
",CWE-000
264,"CWE-000 static int list_dbs ( MYSQL * mysql , const char * wild ) { const char * header ; uint length , counter = 0 ; ulong rowcount = 0L ; char tables [ NAME_LEN + 1 ] , rows [ NAME_LEN + 1 ] ; <S2SV_StartBug> char query [ 255 ] ; <S2SV_EndBug> MYSQL_FIELD * field ; MYSQL_RES * result ; MYSQL_ROW row = NULL , rrow ; if ( ! ( result = mysql_list_dbs ( mysql , wild ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>list<S2SV_blank>databases:<S2SV_blank>%s\\n"" , my_progname , mysql_error ( mysql ) ) ; return 1 ; } if ( wild && mysql_num_rows ( result ) == 1 ) { row = mysql_fetch_row ( result ) ; if ( ! my_strcasecmp ( & my_charset_latin1 , row [ 0 ] , wild ) ) { mysql_free_result ( result ) ; if ( opt_status ) return list_table_status ( mysql , wild , NULL ) ; else return list_tables ( mysql , wild , NULL ) ; } } if ( wild ) printf ( ""Wildcard:<S2SV_blank>%s\\n"" , wild ) ; header = ""Databases"" ; length = ( uint ) strlen ( header ) ; field = mysql_fetch_field ( result ) ; if ( length < field -> max_length ) length = field -> max_length ; if ( ! opt_verbose ) print_header ( header , length , NullS ) ; else if ( opt_verbose == 1 ) print_header ( header , length , ""Tables"" , 6 , NullS ) ; else print_header ( header , length , ""Tables"" , 6 , ""Total<S2SV_blank>Rows"" , 12 , NullS ) ; while ( row || ( row = mysql_fetch_row ( result ) ) ) { counter ++ ; if ( opt_verbose ) { if ( ! ( mysql_select_db ( mysql , row [ 0 ] ) ) ) { MYSQL_RES * tresult = mysql_list_tables ( mysql , ( char * ) NULL ) ; if ( mysql_affected_rows ( mysql ) > 0 ) { sprintf ( tables , ""%6lu"" , ( ulong ) mysql_affected_rows ( mysql ) ) ; rowcount = 0 ; if ( opt_verbose > 1 ) { MYSQL_ROW trow ; while ( ( trow = mysql_fetch_row ( tresult ) ) ) { <S2SV_StartBug> sprintf ( query , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , trow [ 0 ] ) ; <S2SV_EndBug> if ( ! ( mysql_query ( mysql , query ) ) ) { MYSQL_RES * rresult ; if ( ( rresult = mysql_store_result ( mysql ) ) ) { rrow = mysql_fetch_row ( rresult ) ; rowcount += ( ulong ) strtoull ( rrow [ 0 ] , ( char * * ) 0 , 10 ) ; mysql_free_result ( rresult ) ; } } } sprintf ( rows , ""%12lu"" , rowcount ) ; } } else { sprintf ( tables , ""%6d"" , 0 ) ; sprintf ( rows , ""%12d"" , 0 ) ; } mysql_free_result ( tresult ) ; } else { strmov ( tables , ""N/A"" ) ; strmov ( rows , ""N/A"" ) ; } } if ( ! opt_verbose ) print_row ( row [ 0 ] , length , 0 ) ; else if ( opt_verbose == 1 ) print_row ( row [ 0 ] , length , tables , 6 , NullS ) ; else print_row ( row [ 0 ] , length , tables , 6 , rows , 12 , NullS ) ; row = NULL ; } print_trailer ( length , ( opt_verbose > 0 ? 6 : 0 ) , ( opt_verbose > 1 ? 12 : 0 ) , 0 ) ; if ( counter && opt_verbose ) printf ( ""%u<S2SV_blank>row%s<S2SV_blank>in<S2SV_blank>set.\\n"" , counter , ( counter > 1 ) ? ""s"" : """" ) ; mysql_free_result ( result ) ; return 0 ; }
","<S2SV_ModStart> char query [ NAME_LEN + 100 <S2SV_ModEnd> ] ; MYSQL_FIELD <S2SV_ModStart> ) ) { my_snprintf <S2SV_ModEnd> ( query , <S2SV_ModStart> ( query , sizeof ( query ) ,
",CWE-000
269,"CWE-732 char * * <S2SV_StartBug> prepenv ( const struct rule * rule ) <S2SV_EndBug> { static const char * safeset [ ] = { ""DISPLAY"" , ""HOME"" , ""LOGNAME"" , ""MAIL"" , ""PATH"" , ""TERM"" , ""USER"" , ""USERNAME"" , NULL } ; struct env * env ; <S2SV_StartBug> env = createenv ( rule ) ; <S2SV_EndBug> if ( ! ( rule -> options & KEEPENV ) ) fillenv ( env , safeset ) ; if ( rule -> envlist ) fillenv ( env , rule -> envlist ) ; return flattenenv ( env ) ; }
","<S2SV_ModStart> rule * rule , const struct passwd * mypw , const struct passwd * targpw ) { <S2SV_ModEnd> struct env * <S2SV_ModStart> createenv ( rule , mypw , targpw <S2SV_ModEnd> ) ; if
",CWE-732
270,"CWE-000 int hashbin_delete ( hashbin_t * hashbin , FREE_FUNC free_func ) { irda_queue_t * queue ; unsigned long flags = 0 ; int i ; IRDA_ASSERT ( hashbin != NULL , return - 1 ; ) ; IRDA_ASSERT ( hashbin -> magic == HB_MAGIC , return - 1 ; ) ; <S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> spin_lock_irqsave_nested ( & hashbin -> hb_spinlock , flags , hashbin_lock_depth ++ ) ; } for ( i = 0 ; i < HASHBIN_SIZE ; i ++ ) { <S2SV_StartBug> queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> while ( queue ) { <S2SV_EndBug> if ( free_func ) <S2SV_StartBug> ( * free_func ) ( queue ) ; <S2SV_EndBug> queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; } } hashbin -> hb_current = NULL ; hashbin -> magic = ~ HB_MAGIC ; <S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; <S2SV_StartBug> # ifdef CONFIG_LOCKDEP <S2SV_EndBug> hashbin_lock_depth -- ; # endif } kfree ( hashbin ) ; return 0 ; }
","<S2SV_ModStart> & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ++ ) { while ( 1 ) { <S2SV_ModStart> ] ) ; if ( ! queue ) break ; <S2SV_ModEnd> if ( free_func <S2SV_ModStart> ( free_func ) { if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; free_func ( queue ) ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; } <S2SV_ModEnd> } } hashbin <S2SV_ModStart> & HB_LOCK ) <S2SV_ModEnd> spin_unlock_irqrestore ( & <S2SV_ModStart> flags ) ; <S2SV_ModEnd> kfree ( hashbin
",CWE-000
271,"CWE-119 static void accumulate_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) { section -> frame += frame -> frame ; <S2SV_StartBug> section -> spatial_layer_id = frame -> spatial_layer_id ; <S2SV_EndBug> section -> intra_error += frame -> intra_error ; section -> coded_error += frame -> coded_error ; section -> sr_coded_error += frame -> sr_coded_error ; <S2SV_StartBug> section -> ssim_weighted_pred_err += frame -> ssim_weighted_pred_err ; <S2SV_EndBug> section -> pcnt_inter += frame -> pcnt_inter ; section -> pcnt_motion += frame -> pcnt_motion ; section -> pcnt_second_ref += frame -> pcnt_second_ref ; <S2SV_StartBug> section -> pcnt_neutral += frame -> pcnt_neutral ; <S2SV_EndBug> section -> MVr += frame -> MVr ; section -> mvr_abs += frame -> mvr_abs ; section -> MVc += frame -> MVc ; section -> mvc_abs += frame -> mvc_abs ; section -> MVrv += frame -> MVrv ; section -> MVcv += frame -> MVcv ; section -> mv_in_out_count += frame -> mv_in_out_count ; section -> new_mv_count += frame -> new_mv_count ; section -> count += frame -> count ; section -> duration += frame -> duration ; }
","<S2SV_ModStart> ; section -> weight += frame -> weight ; section -> <S2SV_ModStart> ; section -> <S2SV_ModEnd> pcnt_inter += frame <S2SV_ModStart> frame -> pcnt_neutral ; section -> intra_skip_pct += frame -> intra_skip_pct ; section -> inactive_zone_rows += frame -> inactive_zone_rows ; section -> inactive_zone_cols += frame -> inactive_zone_cols
",CWE-119
273,"CWE-264 static int cg_getattr ( const char * path , struct stat * sb ) { struct timespec now ; struct fuse_context * fc = fuse_get_context ( ) ; char * cgdir = NULL ; char * fpath = NULL , * path1 , * path2 ; struct cgfs_files * k = NULL ; const char * cgroup ; const char * controller = NULL ; int ret = - ENOENT ; if ( ! fc ) return - EIO ; memset ( sb , 0 , sizeof ( struct stat ) ) ; if ( clock_gettime ( CLOCK_REALTIME , & now ) < 0 ) return - EINVAL ; sb -> st_uid = sb -> st_gid = 0 ; sb -> st_atim = sb -> st_mtim = sb -> st_ctim = now ; sb -> st_size = 0 ; if ( strcmp ( path , ""/cgroup"" ) == 0 ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { path1 = ""/"" ; path2 = cgdir ; } else { path1 = cgdir ; path2 = fpath ; } if ( is_child_cgroup ( controller , path1 , path2 ) ) { <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> sb -> st_mode = S_IFDIR | 00555 ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { ret = - EACCES ; goto out ; } sb -> st_mode = S_IFDIR | 00755 ; k = cgfs_get_key ( controller , cgroup , ""tasks"" ) ; if ( ! k ) { sb -> st_uid = sb -> st_gid = 0 ; } else { sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; } free_key ( k ) ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ( k = cgfs_get_key ( controller , path1 , path2 ) ) != NULL ) { sb -> st_mode = S_IFREG | k -> mode ; sb -> st_nlink = 1 ; sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; sb -> st_size = 0 ; free_key ( k ) ; if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , path1 , path2 , O_RDONLY ) ) { ret = - EACCES ; goto out ; } ret = 0 ; } out : free ( cgdir ) ; return ret ; }
","<S2SV_ModStart> if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( !
",CWE-264
280,"CWE-190 int jas_matrix_cmp ( jas_matrix_t * mat0 , jas_matrix_t * mat1 ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; if ( mat0 -> numrows_ != mat1 -> numrows_ || mat0 -> numcols_ != mat1 -> numcols_ ) { return 1 ; } for ( i = 0 ; i < mat0 -> numrows_ ; i ++ ) { for ( j = 0 ; j < mat0 -> numcols_ ; j ++ ) { if ( jas_matrix_get ( mat0 , i , j ) != jas_matrix_get ( mat1 , i , j ) ) { return 1 ; } } } return 0 ; }
","<S2SV_ModStart> mat1 ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; if
",CWE-190
281,"CWE-125 void ndpi_search_h323 ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow ) { struct ndpi_packet_struct * packet = & flow -> packet ; u_int16_t dport = 0 , sport = 0 ; NDPI_LOG_DBG ( ndpi_struct , ""search<S2SV_blank>H323\\n"" ) ; if ( ( packet -> tcp != NULL ) && ( packet -> tcp -> dest != ntohs ( 102 ) ) ) { NDPI_LOG_DBG2 ( ndpi_struct , ""calculated<S2SV_blank>dport<S2SV_blank>over<S2SV_blank>tcp\\n"" ) ; if ( packet -> payload_packet_len >= 4 && ( packet -> payload [ 0 ] == 0x03 ) && ( packet -> payload [ 1 ] == 0x00 ) ) { struct tpkt * t = ( struct tpkt * ) packet -> payload ; u_int16_t len = ntohs ( t -> len ) ; if ( packet -> payload_packet_len == len ) { if ( packet -> payload [ 4 ] == ( packet -> payload_packet_len - sizeof ( struct tpkt ) - 1 ) ) { if ( ( packet -> payload [ 5 ] == 0xE0 ) || ( packet -> payload [ 5 ] == 0xD0 ) ) { NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>RDP\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_RDP , NDPI_PROTOCOL_UNKNOWN ) ; return ; } } flow -> l4 . tcp . h323_valid_packets ++ ; if ( flow -> l4 . tcp . h323_valid_packets >= 2 ) { NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; } } else { NDPI_EXCLUDE_PROTO ( ndpi_struct , flow ) ; return ; } } } else if ( packet -> udp != NULL ) { sport = ntohs ( packet -> udp -> source ) , dport = ntohs ( packet -> udp -> dest ) ; NDPI_LOG_DBG2 ( ndpi_struct , ""calculated<S2SV_blank>dport<S2SV_blank>over<S2SV_blank>udp\\n"" ) ; if ( packet -> payload_packet_len >= 6 && packet -> payload [ 0 ] == 0x80 && packet -> payload [ 1 ] == 0x08 && ( packet -> payload [ 2 ] == 0xe7 || packet -> payload [ 2 ] == 0x26 ) && packet -> payload [ 4 ] == 0x00 && packet -> payload [ 5 ] == 0x00 ) { NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } if ( sport == 1719 || dport == 1719 ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( packet -> payload [ 0 ] == 0x16 && packet -> payload [ 1 ] == 0x80 && packet -> payload [ 4 ] == 0x06 && packet -> payload [ 5 ] == 0x00 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } else if ( packet -> payload_packet_len >= 20 && packet -> payload_packet_len <= 117 ) { NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } else { NDPI_EXCLUDE_PROTO ( ndpi_struct , flow ) ; return ; } } } }
","<S2SV_ModStart> == 1719 ) { if ( ( packet -> payload_packet_len >= 5 ) && <S2SV_ModEnd> ( packet -> <S2SV_ModStart> ] == 0x16 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> ] == 0x80 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> ] == 0x06 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> == 0x00 ) )
",CWE-125
283,"CWE-120 void gtkui_conf_read ( void ) { FILE * fd ; const char * path ; char line [ 100 ] , name [ 30 ] ; short value ; # ifdef OS_WINDOWS path = ec_win_get_user_dir ( ) ; # else <S2SV_StartBug> path = g_get_tmp_dir ( ) ; <S2SV_EndBug> # endif filename = g_build_filename ( path , "".ettercap_gtk"" , NULL ) ; DEBUG_MSG ( ""gtkui_conf_read:<S2SV_blank>%s"" , filename ) ; fd = fopen ( filename , ""r"" ) ; if ( ! fd ) return ; while ( fgets ( line , 100 , fd ) ) { sscanf ( line , ""%s<S2SV_blank>=<S2SV_blank>%hd"" , name , & value ) ; gtkui_conf_set ( name , value ) ; } fclose ( fd ) ; }
","<S2SV_ModStart> else path = g_get_home_dir <S2SV_ModEnd> ( ) ;
",CWE-120
284,"CWE-20 static vpx_image_t * img_alloc_helper ( vpx_image_t * img , vpx_img_fmt_t fmt , unsigned int d_w , unsigned int d_h , unsigned int buf_align , unsigned int stride_align , unsigned char * img_data ) { unsigned int h , w , s , xcs , ycs , bps ; unsigned int stride_in_bytes ; int align ; if ( ! buf_align ) buf_align = 1 ; if ( buf_align & ( buf_align - 1 ) ) goto fail ; if ( ! stride_align ) stride_align = 1 ; if ( stride_align & ( stride_align - 1 ) ) goto fail ; switch ( fmt ) { case VPX_IMG_FMT_RGB32 : case VPX_IMG_FMT_RGB32_LE : case VPX_IMG_FMT_ARGB : case VPX_IMG_FMT_ARGB_LE : bps = 32 ; break ; case VPX_IMG_FMT_RGB24 : case VPX_IMG_FMT_BGR24 : bps = 24 ; break ; case VPX_IMG_FMT_RGB565 : case VPX_IMG_FMT_RGB565_LE : case VPX_IMG_FMT_RGB555 : case VPX_IMG_FMT_RGB555_LE : case VPX_IMG_FMT_UYVY : case VPX_IMG_FMT_YUY2 : case VPX_IMG_FMT_YVYU : bps = 16 ; break ; case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : bps = 12 ; break ; case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I440 : bps = 16 ; break ; case VPX_IMG_FMT_I444 : bps = 24 ; break ; case VPX_IMG_FMT_I42016 : bps = 24 ; break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44016 : bps = 32 ; break ; case VPX_IMG_FMT_I44416 : bps = 48 ; break ; default : bps = 16 ; break ; } switch ( fmt ) { case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I42216 : xcs = 1 ; break ; default : xcs = 0 ; break ; } switch ( fmt ) { case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_I440 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I44016 : ycs = 1 ; break ; default : ycs = 0 ; break ; } <S2SV_StartBug> align = ( 1 << xcs ) - 1 ; <S2SV_EndBug> w = ( d_w + align ) & ~ align ; align = ( 1 << ycs ) - 1 ; h = ( d_h + align ) & ~ align ; s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; <S2SV_StartBug> if ( ! img ) { <S2SV_EndBug> img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ; if ( ! img ) goto fail ; img -> self_allocd = 1 ; } else { memset ( img , 0 , sizeof ( vpx_image_t ) ) ; } img -> img_data = img_data ; if ( ! img_data ) { const uint64_t alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? ( uint64_t ) h * s * bps / 8 : ( uint64_t ) h * s ; if ( alloc_size != ( size_t ) alloc_size ) goto fail ; img -> img_data = ( uint8_t * ) vpx_memalign ( buf_align , ( size_t ) alloc_size ) ; img -> img_data_owner = 1 ; } if ( ! img -> img_data ) goto fail ; img -> fmt = fmt ; img -> bit_depth = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 16 : 8 ; img -> w = w ; img -> h = h ; img -> x_chroma_shift = xcs ; img -> y_chroma_shift = ycs ; img -> bps = bps ; img -> stride [ VPX_PLANE_Y ] = img -> stride [ VPX_PLANE_ALPHA ] = stride_in_bytes ; img -> stride [ VPX_PLANE_U ] = img -> stride [ VPX_PLANE_V ] = stride_in_bytes >> xcs ; if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ; fail : vpx_img_free ( img ) ; return NULL ; }
","<S2SV_ModStart> break ; } w = d_w ; h = d_h ; s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; if ( ! img ) { img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ; if ( ! img ) goto fail ; img -> self_allocd = 1 ; } else { memset ( img , 0 , sizeof ( vpx_image_t ) ) ; } img -> img_data = img_data ; if ( ! img_data ) { uint64_t alloc_size ; <S2SV_ModStart> : s ; <S2SV_ModEnd> alloc_size = (
",CWE-20
286,"CWE-284 int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( ""socket()"" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; <S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( ""bind()"" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( ""listen()"" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }
","<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
",CWE-284
288,"CWE-125 static u_int16_t concat_hash_string ( struct ndpi_packet_struct * packet , char * buf , u_int8_t client_hash ) { u_int16_t offset = 22 , buf_out_len = 0 ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; u_int32_t len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( buf , ( const char * ) & packet -> payload [ offset ] , buf_out_len = len ) ; buf [ buf_out_len ++ ] = ';' ; offset += len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else offset += 4 + len ; # ifdef SSH_DEBUG printf ( ""[SSH]<S2SV_blank>%s\\n"" , buf ) ; # endif return ( buf_out_len ) ; invalid_payload : # ifdef SSH_DEBUG printf ( ""[SSH]<S2SV_blank>Invalid<S2SV_blank>packet<S2SV_blank>payload\\n"" ) ; # endif return ( 0 ) ; }
","<S2SV_ModStart> += len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload
",CWE-125
290,"CWE-189 static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { long i ; <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i ] = src1 [ i ] + src2 [ i ] ; }
","<S2SV_ModStart> <= w - ( int )
",CWE-189
291,"CWE-400 static void xen_irq_init ( unsigned irq ) { struct irq_info * info ; # ifdef CONFIG_SMP cpumask_copy ( irq_get_affinity_mask ( irq ) , cpumask_of ( 0 ) ) ; # endif info = kzalloc ( sizeof ( * info ) , GFP_KERNEL ) ; if ( info == NULL ) panic ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>metadata<S2SV_blank>for<S2SV_blank>IRQ%d\\n"" , irq ) ; info -> type = IRQT_UNBOUND ; info -> refcnt = - 1 ; set_info_for_irq ( irq , info ) ; <S2SV_StartBug> list_add_tail ( & info -> list , & xen_irq_list_head ) ; <S2SV_EndBug> }
","<S2SV_ModStart> info ) ; INIT_LIST_HEAD ( & info -> eoi_list ) ;
",CWE-400
292,"CWE-119 static void update_buffer_level ( VP9_COMP * cpi , int encoded_frame_size ) { <S2SV_StartBug> const VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; RATE_CONTROL * const rc = & cpi -> rc ; if ( ! cm -> show_frame ) { rc -> bits_off_target -= encoded_frame_size ; } else { <S2SV_StartBug> rc -> bits_off_target += rc -> av_per_frame_bandwidth - encoded_frame_size ; <S2SV_EndBug> } <S2SV_StartBug> rc -> bits_off_target = MIN ( rc -> bits_off_target , oxcf -> maximum_buffer_size ) ; <S2SV_EndBug> rc -> buffer_level = rc -> bits_off_target ; <S2SV_StartBug> if ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> update_layer_buffer_level ( & cpi -> svc , encoded_frame_size ) ; } }
","<S2SV_ModStart> cpi -> common <S2SV_ModEnd> ; RATE_CONTROL * <S2SV_ModStart> += rc -> avg_frame_bandwidth <S2SV_ModEnd> - encoded_frame_size ; <S2SV_ModStart> -> bits_off_target , rc <S2SV_ModEnd> -> maximum_buffer_size ) <S2SV_ModStart> ; if ( is_one_pass_cbr_svc ( cpi ) <S2SV_ModEnd> ) { update_layer_buffer_level
",CWE-119
295,"CWE-59 int main ( int argc , char * * argv ) { int fd = xopen ( ""/dev/null"" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( ""Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]"" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( ""CCpp.conf"" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , ""MakeCompatCore"" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""SaveBinaryImage"" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""VerboseLog"" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || pid <= 0 ) { perror_msg_and_die ( ""PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus"" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN ""/abrt/saved_core_pattern"" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } struct utsname uts ; if ( ! argv [ 8 ] ) { uname ( & uts ) ; argv [ 8 ] = uts . nodename ; } char path [ PATH_MAX ] ; int src_fd_binary = - 1 ; char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; if ( executable && strstr ( executable , ""/abrt-hook-ccpp"" ) ) { error_msg_and_die ( ""PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion"" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( ""user_pwd:\'%s\'"" , user_pwd ) ; sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ; proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) { fsuid = tmp_fsuid ; } } if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ; goto create_user_core ; } const char * signame = NULL ; switch ( signal_no ) { case SIGILL : signame = ""ILL"" ; break ; case SIGFPE : signame = ""FPE"" ; break ; case SIGSEGV : signame = ""SEGV"" ; break ; case SIGBUS : signame = ""BUS"" ; break ; case SIGABRT : signame = ""ABRT"" ; break ; case SIGTRAP : signame = ""TRAP"" ; break ; default : goto create_user_core ; } if ( ! daemon_is_ok ( ) ) { log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'"" ) ; goto create_user_core ; } if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ; } snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { goto create_user_core ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) { snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) ; int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; return 0 ; } unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) { goto create_user_core ; } dd = dd_create ( path , fsuid , DEFAULT_DUMP_DIR_MODE ) ; if ( dd ) { char * rootdir = get_rootdir ( pid ) ; dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ; char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , ""/proc/%lu/smaps"" , ( long ) pid ) ; source_base_ofs -= strlen ( ""smaps"" ) ; char * dest_filename = concat_path_file ( dd -> dd_dirname , ""also_somewhat_longish_name"" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , ""maps"" ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""limits"" ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( rootdir ) { if ( strcmp ( rootdir , ""/"" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } char * reason = xasprintf ( ""%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s"" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : """" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : """" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; if ( src_fd_binary > 0 ) { strcpy ( path + path_len , ""/"" FILENAME_BINARY ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd_binary ) ; } strcpy ( path + path_len , ""/"" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path ) ; off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; dd_delete ( dd ) ; if ( user_core_fd >= 0 ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } error_msg_and_die ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , path ) ; } if ( user_core_fd >= 0 && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || ( ulimit_c == 0 || core_size > ulimit_c ) ) ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } <S2SV_StartBug> { <S2SV_EndBug> char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( ""%s/hs_err_pid%lu.log"" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , ""/hs_err.log"" ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd ) ; } <S2SV_StartBug> } <S2SV_EndBug> dd_close ( dd ) ; path [ path_len ] = '\\0' ; char * newpath = xstrndup ( path , path_len - ( sizeof ( "".new"" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } free ( rootdir ) ; return 0 ; } create_user_core : if ( user_core_fd >= 0 ) { off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) { perror_msg ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , full_core_basename ) ; xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } if ( ulimit_c == 0 || core_size > ulimit_c ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , full_core_basename , ( long long ) core_size ) ; } return 0 ; }
","<S2SV_ModStart> ) ; } # if 0 <S2SV_ModStart> ; } } # endif
",CWE-59
296,"CWE-20 static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
",CWE-20
300,"CWE-285 static int __f2fs_set_acl ( struct inode * inode , int type , struct posix_acl * acl , struct page * ipage ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; <S2SV_StartBug> set_acl_inode ( inode , inode -> i_mode ) ; <S2SV_EndBug> if ( error == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = f2fs_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) { clear_inode_flag ( inode , FI_ACL_MODE ) ; return ( int ) PTR_ERR ( value ) ; } } error = f2fs_setxattr ( inode , name_index , """" , value , size , ipage , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; clear_inode_flag ( inode , FI_ACL_MODE ) ; return error ; }
","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error <S2SV_ModEnd> ) return error <S2SV_ModStart> -> i_mode ) <S2SV_ModEnd> ; } break
",CWE-285
306,"CWE-400 static void xen_irq_lateeoi_locked ( struct irq_info * info ) { evtchn_port_t evtchn ; <S2SV_StartBug> evtchn = info -> evtchn ; <S2SV_EndBug> <S2SV_StartBug> if ( ! VALID_EVTCHN ( evtchn ) ) <S2SV_EndBug> return ; unmask_evtchn ( evtchn ) ; }
","<S2SV_ModStart> evtchn_port_t evtchn ; unsigned int cpu ; <S2SV_ModStart> ( evtchn ) || ! list_empty ( & info -> eoi_list ) ) return ; cpu = info -> eoi_cpu ; if ( info -> eoi_time && info -> irq_epoch == per_cpu ( irq_epoch , cpu ) ) { lateeoi_list_add ( info ) ; return ; } info -> eoi_time = 0 <S2SV_ModEnd> ; unmask_evtchn (
",CWE-400
307,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { # if CONFIG_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; if ( data ) { ctx -> postproc_cfg_set = 1 ; ctx -> postproc_cfg = * ( ( vp8_postproc_cfg_t * ) data ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; # else <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug> # endif }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args <S2SV_ModStart> ; # else ( void ) ctx ; ( void ) args ;
",CWE-119
309,"CWE-362 int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) { struct page * page = vmf -> page ; loff_t size ; unsigned long len ; int ret ; struct file * file = vma -> vm_file ; struct inode * inode = file_inode ( file ) ; struct address_space * mapping = inode -> i_mapping ; handle_t * handle ; get_block_t * get_block ; int retries = 0 ; sb_start_pagefault ( inode -> i_sb ) ; <S2SV_StartBug> file_update_time ( vma -> vm_file ) ; <S2SV_EndBug> if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) { do { ret = block_page_mkwrite ( vma , vmf , ext4_da_get_block_prep ) ; } while ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) ; goto out_ret ; } lock_page ( page ) ; size = i_size_read ( inode ) ; if ( page -> mapping != mapping || page_offset ( page ) > size ) { unlock_page ( page ) ; ret = VM_FAULT_NOPAGE ; goto out ; } if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { if ( ! ext4_walk_page_buffers ( NULL , page_buffers ( page ) , 0 , len , NULL , ext4_bh_unmapped ) ) { wait_for_stable_page ( page ) ; ret = VM_FAULT_LOCKED ; goto out ; } } unlock_page ( page ) ; if ( ext4_should_dioread_nolock ( inode ) ) get_block = ext4_get_block_write ; else get_block = ext4_get_block ; retry_alloc : handle = ext4_journal_start ( inode , EXT4_HT_WRITE_PAGE , ext4_writepage_trans_blocks ( inode ) ) ; if ( IS_ERR ( handle ) ) { ret = VM_FAULT_SIGBUS ; goto out ; } ret = block_page_mkwrite ( vma , vmf , get_block ) ; if ( ! ret && ext4_should_journal_data ( inode ) ) { if ( ext4_walk_page_buffers ( handle , page_buffers ( page ) , 0 , PAGE_CACHE_SIZE , NULL , do_journal_get_write_access ) ) { unlock_page ( page ) ; ret = VM_FAULT_SIGBUS ; ext4_journal_stop ( handle ) ; goto out ; } ext4_set_inode_state ( inode , EXT4_STATE_JDATA ) ; } ext4_journal_stop ( handle ) ; if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) goto retry_alloc ; out_ret : ret = block_page_mkwrite_return ( ret ) ; out : <S2SV_StartBug> sb_end_pagefault ( inode -> i_sb ) ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> vma -> vm_file ) ; down_read ( & EXT4_I ( inode ) -> i_mmap_sem <S2SV_ModStart> ; out : up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
",CWE-362
310,"CWE-119 void vp9_setup_src_planes ( MACROBLOCK * x , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; int i ; x -> e_mbd . cur_buf = src ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) setup_pred_plane ( & x -> plane [ i ] . src , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , x -> e_mbd . plane [ i ] . subsampling_x , x -> e_mbd . plane [ i ] . subsampling_y ) ; }
","<S2SV_ModStart> const buffers [ 3 <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> v_buffer <S2SV_ModEnd> } ; const <S2SV_ModStart> int strides [ 3 <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> uv_stride <S2SV_ModEnd> } ; int
",CWE-119
311,"CWE-787 static int webSocketsDecodeHybi ( rfbClientPtr cl , char * dst , int len ) { <S2SV_StartBug> char * buf , * payload ; <S2SV_EndBug> uint32_t * payload32 ; <S2SV_StartBug> int ret = - 1 , result = - 1 ; <S2SV_EndBug> <S2SV_StartBug> int total = 0 ; <S2SV_EndBug> ws_mask_t mask ; ws_header_t * header ; int i ; unsigned char opcode ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; int flength , fhlen ; if ( wsctx -> readbuflen ) { if ( wsctx -> readbuflen > len ) { memcpy ( dst , wsctx -> readbuf + wsctx -> readbufstart , len ) ; result = len ; wsctx -> readbuflen -= len ; wsctx -> readbufstart += len ; } else { memcpy ( dst , wsctx -> readbuf + wsctx -> readbufstart , wsctx -> readbuflen ) ; result = wsctx -> readbuflen ; wsctx -> readbuflen = 0 ; wsctx -> readbufstart = 0 ; } goto spor ; } buf = wsctx -> codeBufDecode ; header = ( ws_header_t * ) wsctx -> codeBufDecode ; ret = ws_peek ( cl , buf , B64LEN ( len ) + WSHLENMAX ) ; if ( ret < 2 ) { if ( - 1 == ret ) { int olderrno = errno ; rfbErr ( ""%s:<S2SV_blank>peek;<S2SV_blank>%m\\n"" , __func__ ) ; errno = olderrno ; <S2SV_StartBug> } else if ( 0 == ret ) { <S2SV_EndBug> result = 0 ; } else { errno = EAGAIN ; } goto spor ; } opcode = header -> b0 & 0x0f ; flength = header -> b1 & 0x7f ; if ( ! ( header -> b1 & 0x80 ) ) { rfbErr ( ""%s:<S2SV_blank>got<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>mask\\n"" , __func__ , ret ) ; errno = EIO ; goto spor ; } if ( flength < 126 ) { fhlen = 2 ; mask = header -> u . m ; } else if ( flength == 126 && 4 <= ret ) { flength = WS_NTOH16 ( header -> u . s16 . l16 ) ; fhlen = 4 ; mask = header -> u . s16 . m16 ; } else if ( flength == 127 && 10 <= ret ) { flength = WS_NTOH64 ( header -> u . s64 . l64 ) ; fhlen = 10 ; mask = header -> u . s64 . m64 ; } else { rfbErr ( ""%s:<S2SV_blank>incomplete<S2SV_blank>frame<S2SV_blank>header\\n"" , __func__ , ret ) ; errno = EIO ; goto spor ; } total = fhlen + flength + 4 ; payload = buf + fhlen + 4 ; if ( - 1 == ( ret = ws_read ( cl , buf , total ) ) ) { int olderrno = errno ; rfbErr ( ""%s:<S2SV_blank>read;<S2SV_blank>%m"" , __func__ ) ; errno = olderrno ; return ret ; } else if ( ret < total ) { rfbLog ( ""%s:<S2SV_blank>read;<S2SV_blank>got<S2SV_blank>partial<S2SV_blank>data\\n"" , __func__ ) ; } else { buf [ ret ] = '\\0' ; } payload32 = ( uint32_t * ) payload ; for ( i = 0 ; i < flength / 4 ; i ++ ) { payload32 [ i ] ^= mask . u ; } for ( i *= 4 ; i < flength ; i ++ ) { payload [ i ] ^= mask . c [ i % 4 ] ; } switch ( opcode ) { case WS_OPCODE_CLOSE : rfbLog ( ""got<S2SV_blank>closure,<S2SV_blank>reason<S2SV_blank>%d\\n"" , WS_NTOH16 ( ( ( uint16_t * ) payload ) [ 0 ] ) ) ; errno = ECONNRESET ; break ; case WS_OPCODE_TEXT_FRAME : if ( - 1 == ( flength = b64_pton ( payload , ( unsigned char * ) wsctx -> codeBufDecode , sizeof ( wsctx -> codeBufDecode ) ) ) ) { rfbErr ( ""%s:<S2SV_blank>Base64<S2SV_blank>decode<S2SV_blank>error;<S2SV_blank>%m\\n"" , __func__ ) ; break ; } payload = wsctx -> codeBufDecode ; case WS_OPCODE_BINARY_FRAME : if ( flength > len ) { memcpy ( wsctx -> readbuf , payload + len , flength - len ) ; wsctx -> readbufstart = 0 ; wsctx -> readbuflen = flength - len ; flength = len ; } memcpy ( dst , payload , flength ) ; result = flength ; break ; default : rfbErr ( ""%s:<S2SV_blank>unhandled<S2SV_blank>opcode<S2SV_blank>%d,<S2SV_blank>b0:<S2SV_blank>%02x,<S2SV_blank>b1:<S2SV_blank>%02x\\n"" , __func__ , ( int ) opcode , header -> b0 , header -> b1 ) ; } spor : return result ; }
","<S2SV_ModStart> len ) { int result <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; rfbLog ( ""%s_enter:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writeTo=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""<S2SV_blank>nReadRaw=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf ) ; switch ( wsctx -> hybiDecodeState ) { case WS_HYBI_STATE_HEADER_PENDING : wsctx -> hybiDecodeState = hybiReadHeader ( cl , & result ) ; if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { goto spor ; } if ( wsctx -> hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING ) { wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; } break ; case WS_HYBI_STATE_DATA_AVAILABLE : wsctx -> hybiDecodeState = hybiReturnData ( dst , len , wsctx , & result ) ; break ; case WS_HYBI_STATE_DATA_NEEDED : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; case WS_HYBI_STATE_CLOSE_REASON_PENDING : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; default : rfbErr ( ""%s:<S2SV_blank>called<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>%d\\n"" , wsctx -> hybiDecodeState ) ; <S2SV_ModEnd> result = - <S2SV_ModStart> - 1 ; errno = EIO ; wsctx -> hybiDecodeState = WS_HYBI_STATE_ERR ; } spor : if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE ) { rfbLog ( ""frame<S2SV_blank>received<S2SV_blank>successfully,<S2SV_blank>cleaning<S2SV_blank>up:<S2SV_blank>read=%d<S2SV_blank>hlen=%d<S2SV_blank>plen=%d\\n"" , wsctx -> header . nRead , wsctx -> header . headerLen , wsctx -> header . payloadLen ) ; hybiDecodeCleanup ( wsctx ) <S2SV_ModEnd> ; } else <S2SV_ModStart> else if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { hybiDecodeCleanup ( wsctx ) ; } rfbLog ( ""%s_exit:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writePos=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""nRead=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p<S2SV_blank>"" ""result=%d\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf , result ) ; return <S2SV_ModEnd> result ; }
",CWE-787
312,"CWE-119 static double get_prediction_decay_rate ( VP8_COMP * cpi , FIRSTPASS_STATS * next_frame ) { double prediction_decay_rate ; double motion_decay ; <S2SV_StartBug> double motion_pct = next_frame -> pcnt_motion ; <S2SV_EndBug> prediction_decay_rate = next_frame -> pcnt_inter ; motion_decay = ( 1.0 - ( motion_pct / 20.0 ) ) ; if ( motion_decay < prediction_decay_rate ) prediction_decay_rate = motion_decay ; { double this_mv_rabs ; double this_mv_cabs ; double distance_factor ; this_mv_rabs = fabs ( next_frame -> mvr_abs * motion_pct ) ; this_mv_cabs = fabs ( next_frame -> mvc_abs * motion_pct ) ; distance_factor = sqrt ( ( this_mv_rabs * this_mv_rabs ) + ( this_mv_cabs * this_mv_cabs ) ) / 250.0 ; distance_factor = ( ( distance_factor > 1.0 ) ? 0.0 : ( 1.0 - distance_factor ) ) ; if ( distance_factor < prediction_decay_rate ) prediction_decay_rate = distance_factor ; } return prediction_decay_rate ; }
","<S2SV_ModStart> next_frame -> pcnt_motion ; ( void ) cpi
",CWE-119
314,"CWE-362 static int do_ip_getsockopt ( struct sock * sk , int level , int optname , char __user * optval , int __user * optlen ) { struct inet_sock * inet = inet_sk ( sk ) ; int val ; int len ; if ( level != SOL_IP ) return - EOPNOTSUPP ; if ( ip_mroute_opt ( optname ) ) return ip_mroute_getsockopt ( sk , optname , optval , optlen ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( len < 0 ) return - EINVAL ; lock_sock ( sk ) ; switch ( optname ) { case IP_OPTIONS : { unsigned char optbuf [ sizeof ( struct ip_options ) + 40 ] ; struct ip_options * opt = ( struct ip_options * ) optbuf ; <S2SV_StartBug> opt -> optlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug> memcpy ( optbuf , inet -> opt , sizeof ( struct ip_options ) + inet -> opt -> optlen ) ; release_sock ( sk ) ; if ( opt -> optlen == 0 ) return put_user ( 0 , optlen ) ; ip_options_undo ( opt ) ; len = min_t ( unsigned int , len , opt -> optlen ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , opt -> __data , len ) ) return - EFAULT ; return 0 ; } case IP_PKTINFO : val = ( inet -> cmsg_flags & IP_CMSG_PKTINFO ) != 0 ; break ; case IP_RECVTTL : val = ( inet -> cmsg_flags & IP_CMSG_TTL ) != 0 ; break ; case IP_RECVTOS : val = ( inet -> cmsg_flags & IP_CMSG_TOS ) != 0 ; break ; case IP_RECVOPTS : val = ( inet -> cmsg_flags & IP_CMSG_RECVOPTS ) != 0 ; break ; case IP_RETOPTS : val = ( inet -> cmsg_flags & IP_CMSG_RETOPTS ) != 0 ; break ; case IP_PASSSEC : val = ( inet -> cmsg_flags & IP_CMSG_PASSSEC ) != 0 ; break ; case IP_RECVORIGDSTADDR : val = ( inet -> cmsg_flags & IP_CMSG_ORIGDSTADDR ) != 0 ; break ; case IP_TOS : val = inet -> tos ; break ; case IP_TTL : val = ( inet -> uc_ttl == - 1 ? sysctl_ip_default_ttl : inet -> uc_ttl ) ; break ; case IP_HDRINCL : val = inet -> hdrincl ; break ; case IP_NODEFRAG : val = inet -> nodefrag ; break ; case IP_MTU_DISCOVER : val = inet -> pmtudisc ; break ; case IP_MTU : { struct dst_entry * dst ; val = 0 ; dst = sk_dst_get ( sk ) ; if ( dst ) { val = dst_mtu ( dst ) ; dst_release ( dst ) ; } if ( ! val ) { release_sock ( sk ) ; return - ENOTCONN ; } break ; } case IP_RECVERR : val = inet -> recverr ; break ; case IP_MULTICAST_TTL : val = inet -> mc_ttl ; break ; case IP_MULTICAST_LOOP : val = inet -> mc_loop ; break ; case IP_MULTICAST_IF : { struct in_addr addr ; len = min_t ( unsigned int , len , sizeof ( struct in_addr ) ) ; addr . s_addr = inet -> mc_addr ; release_sock ( sk ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & addr , len ) ) return - EFAULT ; return 0 ; } case IP_MSFILTER : { struct ip_msfilter msf ; int err ; if ( len < IP_MSFILTER_SIZE ( 0 ) ) { release_sock ( sk ) ; return - EINVAL ; } if ( copy_from_user ( & msf , optval , IP_MSFILTER_SIZE ( 0 ) ) ) { release_sock ( sk ) ; return - EFAULT ; } err = ip_mc_msfget ( sk , & msf , ( struct ip_msfilter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case MCAST_MSFILTER : { struct group_filter gsf ; int err ; if ( len < GROUP_FILTER_SIZE ( 0 ) ) { release_sock ( sk ) ; return - EINVAL ; } if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) { release_sock ( sk ) ; return - EFAULT ; } err = ip_mc_gsfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case IP_MULTICAST_ALL : val = inet -> mc_all ; break ; case IP_PKTOPTIONS : { struct msghdr msg ; release_sock ( sk ) ; if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ; msg . msg_control = optval ; msg . msg_controllen = len ; msg . msg_flags = 0 ; if ( inet -> cmsg_flags & IP_CMSG_PKTINFO ) { struct in_pktinfo info ; info . ipi_addr . s_addr = inet -> inet_rcv_saddr ; info . ipi_spec_dst . s_addr = inet -> inet_rcv_saddr ; info . ipi_ifindex = inet -> mc_index ; put_cmsg ( & msg , SOL_IP , IP_PKTINFO , sizeof ( info ) , & info ) ; } if ( inet -> cmsg_flags & IP_CMSG_TTL ) { int hlim = inet -> mc_ttl ; put_cmsg ( & msg , SOL_IP , IP_TTL , sizeof ( hlim ) , & hlim ) ; } len -= msg . msg_controllen ; return put_user ( len , optlen ) ; } case IP_FREEBIND : val = inet -> freebind ; break ; case IP_TRANSPARENT : val = inet -> transparent ; break ; case IP_MINTTL : val = inet -> min_ttl ; break ; default : release_sock ( sk ) ; return - ENOPROTOOPT ; } release_sock ( sk ) ; if ( len < sizeof ( int ) && len > 0 && val >= 0 && val <= 255 ) { unsigned char ucval = ( unsigned char ) val ; len = 1 ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & ucval , 1 ) ) return - EFAULT ; } else { len = min_t ( unsigned int , sizeof ( int ) , len ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & val , len ) ) return - EFAULT ; } return 0 ; }
","<S2SV_ModStart> ) optbuf ; struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ; if ( inet_opt ) memcpy ( optbuf , & inet_opt -> opt , sizeof ( struct ip_options ) + inet_opt -> opt . <S2SV_ModEnd> optlen ) ;
",CWE-362
315,"CWE-125 static UINT parallel_process_irp_create ( PARALLEL_DEVICE * parallel , IRP * irp ) { char * path = NULL ; int status ; <S2SV_StartBug> UINT32 PathLength ; <S2SV_EndBug> <S2SV_StartBug> Stream_Seek ( irp -> input , 28 ) ; <S2SV_EndBug> Stream_Read_UINT32 ( irp -> input , PathLength ) ; <S2SV_StartBug> status = ConvertFromUnicode ( CP_UTF8 , 0 , ( WCHAR * ) Stream_Pointer ( irp -> input ) , PathLength / 2 , <S2SV_EndBug> & path , 0 , NULL , NULL ) ; if ( status < 1 ) if ( ! ( path = ( char * ) calloc ( 1 , 1 ) ) ) { WLog_ERR ( TAG , ""calloc<S2SV_blank>failed!"" ) ; return CHANNEL_RC_NO_MEMORY ; } parallel -> id = irp -> devman -> id_sequence ++ ; parallel -> file = open ( parallel -> path , O_RDWR ) ; if ( parallel -> file < 0 ) { irp -> IoStatus = STATUS_ACCESS_DENIED ; parallel -> id = 0 ; } else { if ( fcntl ( parallel -> file , F_SETFL , O_NONBLOCK ) == - 1 ) { } } Stream_Write_UINT32 ( irp -> output , parallel -> id ) ; Stream_Write_UINT8 ( irp -> output , 0 ) ; free ( path ) ; return irp -> Complete ( irp ) ; }
","<S2SV_ModStart> int status ; WCHAR * ptr ; <S2SV_ModStart> UINT32 PathLength ; if ( ! Stream_SafeSeek <S2SV_ModEnd> ( irp -> <S2SV_ModStart> , 28 ) ) return ERROR_INVALID_DATA ; if ( Stream_GetRemainingLength ( irp -> input ) < 4 ) return ERROR_INVALID_DATA <S2SV_ModStart> PathLength ) ; ptr = ( WCHAR * ) Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , PathLength ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> , 0 , ptr <S2SV_ModEnd> , PathLength /
",CWE-125
318,"CWE-000 BIO * PKCS7_dataDecode ( PKCS7 * p7 , EVP_PKEY * pkey , BIO * in_bio , X509 * pcert ) { int i , j ; BIO * out = NULL , * btmp = NULL , * etmp = NULL , * bio = NULL ; X509_ALGOR * xa ; ASN1_OCTET_STRING * data_body = NULL ; const EVP_MD * evp_md ; const EVP_CIPHER * evp_cipher = NULL ; EVP_CIPHER_CTX * evp_ctx = NULL ; X509_ALGOR * enc_alg = NULL ; STACK_OF ( X509_ALGOR ) * md_sk = NULL ; STACK_OF ( PKCS7_RECIP_INFO ) * rsk = NULL ; PKCS7_RECIP_INFO * ri = NULL ; unsigned char * ek = NULL , * tkey = NULL ; int eklen = 0 , tkeylen = 0 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; return NULL ; } i = OBJ_obj2nid ( p7 -> type ) ; p7 -> state = PKCS7_S_HEADER ; switch ( i ) { case NID_pkcs7_signed : data_body = PKCS7_get_octet_string ( p7 -> d . sign -> contents ) ; if ( ! PKCS7_is_detached ( p7 ) && data_body == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_SIGNED_DATA_TYPE ) ; goto err ; } md_sk = p7 -> d . sign -> md_algs ; break ; case NID_pkcs7_signedAndEnveloped : rsk = p7 -> d . signed_and_enveloped -> recipientinfo ; md_sk = p7 -> d . signed_and_enveloped -> md_algs ; data_body = p7 -> d . signed_and_enveloped -> enc_data -> enc_data ; enc_alg = p7 -> d . signed_and_enveloped -> enc_data -> algorithm ; evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ; if ( evp_cipher == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ; goto err ; } break ; case NID_pkcs7_enveloped : rsk = p7 -> d . enveloped -> recipientinfo ; enc_alg = p7 -> d . enveloped -> enc_data -> algorithm ; data_body = p7 -> d . enveloped -> enc_data -> enc_data ; evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ; if ( evp_cipher == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ; goto err ; } break ; default : PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ; goto err ; } <S2SV_StartBug> if ( md_sk != NULL ) { <S2SV_EndBug> for ( i = 0 ; i < sk_X509_ALGOR_num ( md_sk ) ; i ++ ) { xa = sk_X509_ALGOR_value ( md_sk , i ) ; if ( ( btmp = BIO_new ( BIO_f_md ( ) ) ) == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ; goto err ; } j = OBJ_obj2nid ( xa -> algorithm ) ; evp_md = EVP_get_digestbynid ( j ) ; if ( evp_md == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNKNOWN_DIGEST_TYPE ) ; goto err ; } BIO_set_md ( btmp , evp_md ) ; if ( out == NULL ) out = btmp ; else BIO_push ( out , btmp ) ; btmp = NULL ; } } if ( evp_cipher != NULL ) { if ( ( etmp = BIO_new ( BIO_f_cipher ( ) ) ) == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ; goto err ; } if ( pcert ) { for ( i = 0 ; i < sk_PKCS7_RECIP_INFO_num ( rsk ) ; i ++ ) { ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ; if ( ! pkcs7_cmp_ri ( ri , pcert ) ) break ; ri = NULL ; } if ( ri == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE ) ; goto err ; } } if ( pcert == NULL ) { for ( i = 0 ; i < sk_PKCS7_RECIP_INFO_num ( rsk ) ; i ++ ) { ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ; if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ; ERR_clear_error ( ) ; } } else { if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ; ERR_clear_error ( ) ; } evp_ctx = NULL ; BIO_get_cipher_ctx ( etmp , & evp_ctx ) ; if ( EVP_CipherInit_ex ( evp_ctx , evp_cipher , NULL , NULL , NULL , 0 ) <= 0 ) goto err ; if ( EVP_CIPHER_asn1_to_param ( evp_ctx , enc_alg -> parameter ) < 0 ) goto err ; tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; if ( ! tkey ) goto err ; if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ; if ( ek == NULL ) { ek = tkey ; eklen = tkeylen ; tkey = NULL ; } if ( eklen != EVP_CIPHER_CTX_key_length ( evp_ctx ) ) { if ( ! EVP_CIPHER_CTX_set_key_length ( evp_ctx , eklen ) ) { OPENSSL_clear_free ( ek , eklen ) ; ek = tkey ; eklen = tkeylen ; tkey = NULL ; } } ERR_clear_error ( ) ; if ( EVP_CipherInit_ex ( evp_ctx , NULL , NULL , ek , NULL , 0 ) <= 0 ) goto err ; OPENSSL_clear_free ( ek , eklen ) ; ek = NULL ; OPENSSL_clear_free ( tkey , tkeylen ) ; tkey = NULL ; if ( out == NULL ) out = etmp ; else BIO_push ( out , etmp ) ; etmp = NULL ; } <S2SV_StartBug> if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) { <S2SV_EndBug> bio = in_bio ; } else { if ( data_body -> length > 0 ) bio = BIO_new_mem_buf ( data_body -> data , data_body -> length ) ; else { bio = BIO_new ( BIO_s_mem ( ) ) ; BIO_set_mem_eof_return ( bio , 0 ) ; } if ( bio == NULL ) goto err ; } BIO_push ( out , bio ) ; bio = NULL ; return out ; err : OPENSSL_clear_free ( ek , eklen ) ; OPENSSL_clear_free ( tkey , tkeylen ) ; BIO_free_all ( out ) ; BIO_free_all ( btmp ) ; BIO_free_all ( etmp ) ; BIO_free_all ( bio ) ; return NULL ; }
","<S2SV_ModStart> } if ( data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; goto err ; } if ( <S2SV_ModStart> } if ( <S2SV_ModEnd> in_bio != NULL <S2SV_ModStart> != NULL ) <S2SV_ModEnd> { bio =
",CWE-000
321,"CWE-362 int my_redel ( const char * org_name , const char * tmp_name , myf MyFlags ) { int error = 1 ; DBUG_ENTER ( ""my_redel"" ) ; DBUG_PRINT ( ""my"" , ( ""org_name:<S2SV_blank>\'%s\'<S2SV_blank>tmp_name:<S2SV_blank>\'%s\'<S2SV_blank><S2SV_blank>MyFlags:<S2SV_blank>%d"" , org_name , tmp_name , MyFlags ) ) ; <S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto end ; <S2SV_EndBug> if ( MyFlags & MY_REDEL_MAKE_BACKUP ) { char name_buff [ FN_REFLEN + 20 ] ; char ext [ 20 ] ; ext [ 0 ] = '-' ; get_date ( ext + 1 , 2 + 4 , ( time_t ) 0 ) ; strmov ( strend ( ext ) , REDEL_EXT ) ; if ( my_rename ( org_name , fn_format ( name_buff , org_name , """" , ext , 2 ) , MyFlags ) ) goto end ; } else if ( my_delete_allow_opened ( org_name , MyFlags ) ) goto end ; if ( my_rename ( tmp_name , org_name , MyFlags ) ) goto end ; error = 0 ; end : DBUG_RETURN ( error ) ; }
","<S2SV_ModStart> ; if ( ! ( MyFlags & MY_REDEL_NO_COPY_STAT ) ) { if ( <S2SV_ModStart> goto end ; }
",CWE-362
323,"CWE-787 static int extractRDNSequence ( struct ndpi_packet_struct * packet , u_int offset , char * buffer , u_int buffer_len , char * rdnSeqBuf , u_int * rdnSeqBuf_offset , u_int rdnSeqBuf_len , const char * label ) { u_int8_t str_len = packet -> payload [ offset + 4 ] , is_printable = 1 ; char * str ; <S2SV_StartBug> u_int len , j ; <S2SV_EndBug> if ( ( offset + 4 + str_len ) >= packet -> payload_packet_len ) return ( - 1 ) ; str = ( char * ) & packet -> payload [ offset + 5 ] ; len = ( u_int ) ndpi_min ( str_len , buffer_len - 1 ) ; strncpy ( buffer , str , len ) ; buffer [ len ] = '\\0' ; for ( j = 0 ; j < len ; j ++ ) { if ( ! ndpi_isprint ( buffer [ j ] ) ) { is_printable = 0 ; break ; } } if ( is_printable ) { int rc = snprintf ( & rdnSeqBuf [ * rdnSeqBuf_offset ] , rdnSeqBuf_len - ( * rdnSeqBuf_offset ) , ""%s%s=%s"" , ( * rdnSeqBuf_offset > 0 ) ? "",<S2SV_blank>"" : """" , label , buffer ) ; if ( rc > 0 ) ( * rdnSeqBuf_offset ) += rc ; } return ( is_printable ) ; }
","<S2SV_ModStart> , j ; if ( * rdnSeqBuf_offset >= rdnSeqBuf_len ) { # ifdef DEBUG_TLS printf ( ""[TLS]<S2SV_blank>%s()<S2SV_blank>[buffer<S2SV_blank>capacity<S2SV_blank>reached][%u]\\n"" , __FUNCTION__ , rdnSeqBuf_len ) ; # endif return - 1 ; }
",CWE-787
324,"CWE-000 void ngx_gmtime ( time_t t , ngx_tm_t * tp ) { ngx_int_t yday ; ngx_uint_t sec , min , hour , mday , mon , year , wday , days , leap ; if ( t < 0 ) { t = 0 ; } days = t / 86400 ; <S2SV_StartBug> sec = t % 86400 ; <S2SV_EndBug> wday = ( 4 + days ) % 7 ; hour = sec / 3600 ; sec %= 3600 ; min = sec / 60 ; sec %= 60 ; days = days - ( 31 + 28 ) + 719527 ; year = ( days + 2 ) * 400 / ( 365 * 400 + 100 - 4 + 1 ) ; yday = days - ( 365 * year + year / 4 - year / 100 + year / 400 ) ; if ( yday < 0 ) { leap = ( year % 4 == 0 ) && ( year % 100 || ( year % 400 == 0 ) ) ; yday = 365 + leap + yday ; year -- ; } mon = ( yday + 31 ) * 10 / 306 ; mday = yday - ( 367 * mon / 12 - 30 ) + 1 ; if ( yday >= 306 ) { year ++ ; mon -= 10 ; } else { mon += 2 ; } tp -> ngx_tm_sec = ( ngx_tm_sec_t ) sec ; tp -> ngx_tm_min = ( ngx_tm_min_t ) min ; tp -> ngx_tm_hour = ( ngx_tm_hour_t ) hour ; tp -> ngx_tm_mday = ( ngx_tm_mday_t ) mday ; tp -> ngx_tm_mon = ( ngx_tm_mon_t ) mon ; tp -> ngx_tm_year = ( ngx_tm_year_t ) year ; tp -> ngx_tm_wday = ( ngx_tm_wday_t ) wday ; }
","<S2SV_ModStart> % 86400 ; if ( days > 2932896 ) { days = 2932896 ; sec = 86399 ; }
",CWE-000
325,"CWE-20 static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; <S2SV_StartBug> struct rose_sock * rose = rose_sk ( sk ) ; <S2SV_EndBug> struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( srose != NULL ) { <S2SV_EndBug> <S2SV_StartBug> memset ( srose , 0 , msg -> msg_namelen ) ; <S2SV_EndBug> srose -> srose_family = AF_ROSE ; srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }
","<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; size_t copied <S2SV_ModStart> ; if ( msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> ; srose ->
",CWE-20
326,"CWE-787 static void exif_data_load_data_thumbnail ( ExifData * data , const unsigned char * d , unsigned int ds , ExifLong o , ExifLong s ) { <S2SV_StartBug> if ( ( o + s < o ) || ( o + s < s ) || ( o + s > ds ) || ( o > ds ) ) { <S2SV_EndBug> <S2SV_StartBug> exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , <S2SV_EndBug> ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)<S2SV_blank>or<S2SV_blank>size<S2SV_blank>(%u)."" , o , s ) ; return ; } if ( data -> data ) exif_mem_free ( data -> priv -> mem , data -> data ) ; if ( ! ( data -> data = exif_data_alloc ( data , s ) ) ) { EXIF_LOG_NO_MEMORY ( data -> priv -> log , ""ExifData"" , s ) ; data -> size = 0 ; return ; } data -> size = s ; memcpy ( data -> data , d + o , s ) ; }
","<S2SV_ModStart> { if ( o >= ds <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , ""ExifData"" , ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)."" , o ) ; return ; } if ( s > ds - o ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Bogus<S2SV_blank>thumbnail<S2SV_blank>size<S2SV_blank>(%u),<S2SV_blank>max<S2SV_blank>would<S2SV_blank>be<S2SV_blank>%u."" , s , ds - o <S2SV_ModEnd> ) ; return
",CWE-787
328,"CWE-000 static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) { struct bpf_insn * insn = env -> prog -> insnsi ; int insn_cnt = env -> prog -> len ; int i , j ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) == BPF_LDX && ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { verbose ( ""BPF_LDX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) == BPF_STX && ( ( BPF_MODE ( insn -> code ) != BPF_MEM && BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { verbose ( ""BPF_STX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { struct bpf_map * map ; struct fd f ; if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || insn [ 1 ] . off != 0 ) { verbose ( ""invalid<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n"" ) ; return - EINVAL ; } if ( insn -> src_reg == 0 ) goto next_insn ; if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { verbose ( ""unrecognized<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n"" ) ; return - EINVAL ; } f = fdget ( insn -> imm ) ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) { verbose ( ""fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\n"" , insn -> imm ) ; <S2SV_StartBug> fdput ( f ) ; <S2SV_EndBug> return PTR_ERR ( map ) ; } insn [ 0 ] . imm = ( u32 ) ( unsigned long ) map ; insn [ 1 ] . imm = ( ( u64 ) ( unsigned long ) map ) >> 32 ; for ( j = 0 ; j < env -> used_map_cnt ; j ++ ) if ( env -> used_maps [ j ] == map ) { fdput ( f ) ; goto next_insn ; } if ( env -> used_map_cnt >= MAX_USED_MAPS ) { fdput ( f ) ; return - E2BIG ; } env -> used_maps [ env -> used_map_cnt ++ ] = map ; bpf_map_inc ( map , false ) ; fdput ( f ) ; next_insn : insn ++ ; i ++ ; } } return 0 ; }
","<S2SV_ModStart> imm ) ; <S2SV_ModEnd> return PTR_ERR (
",CWE-000
334,"CWE-295 static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client , <S2SV_StartBug> krb5_principal client_principal , <S2SV_EndBug> hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) { KDC_REP rep ; EncKDCRepPart ek ; EncTicketPart et ; KDCOptions f = b -> kdc_options ; krb5_error_code ret ; int is_weak = 0 ; memset ( & rep , 0 , sizeof ( rep ) ) ; memset ( & et , 0 , sizeof ( et ) ) ; memset ( & ek , 0 , sizeof ( ek ) ) ; rep . pvno = 5 ; rep . msg_type = krb_tgs_rep ; et . authtime = tgt -> authtime ; _kdc_fix_time ( & b -> till ) ; et . endtime = min ( tgt -> endtime , * b -> till ) ; ALLOC ( et . starttime ) ; * et . starttime = kdc_time ; ret = check_tgs_flags ( context , config , b , tgt , & et ) ; if ( ret ) goto out ; # define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) , <S2SV_StartBug> krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ; <S2SV_EndBug> if ( ret ) goto out ; copy_Realm ( & server_principal -> realm , & rep . ticket . realm ) ; _krb5_principal2principalname ( & rep . ticket . sname , server_principal ) ; copy_Realm ( & tgt_name -> realm , & rep . crealm ) ; copy_PrincipalName ( & tgt_name -> name , & rep . cname ) ; rep . ticket . tkt_vno = 5 ; ek . caddr = et . caddr ; { time_t life ; life = et . endtime - * et . starttime ; if ( client && client -> entry . max_life ) life = min ( life , * client -> entry . max_life ) ; if ( server -> entry . max_life ) life = min ( life , * server -> entry . max_life ) ; et . endtime = * et . starttime + life ; } if ( f . renewable_ok && tgt -> flags . renewable && et . renew_till == NULL && et . endtime < * b -> till && tgt -> renew_till != NULL ) { et . flags . renewable = 1 ; ALLOC ( et . renew_till ) ; * et . renew_till = * b -> till ; } if ( et . renew_till ) { time_t renew ; renew = * et . renew_till - * et . starttime ; if ( client && client -> entry . max_renew ) renew = min ( renew , * client -> entry . max_renew ) ; if ( server -> entry . max_renew ) renew = min ( renew , * server -> entry . max_renew ) ; * et . renew_till = * et . starttime + renew ; } if ( et . renew_till ) { * et . renew_till = min ( * et . renew_till , * tgt -> renew_till ) ; * et . starttime = min ( * et . starttime , * et . renew_till ) ; et . endtime = min ( et . endtime , * et . renew_till ) ; } * et . starttime = min ( * et . starttime , et . endtime ) ; if ( * et . starttime == et . endtime ) { ret = KRB5KDC_ERR_NEVER_VALID ; goto out ; } if ( et . renew_till && et . endtime == * et . renew_till ) { free ( et . renew_till ) ; et . renew_till = NULL ; et . flags . renewable = 0 ; } et . flags . pre_authent = tgt -> flags . pre_authent ; et . flags . hw_authent = tgt -> flags . hw_authent ; et . flags . anonymous = tgt -> flags . anonymous ; et . flags . ok_as_delegate = server -> entry . flags . ok_as_delegate ; if ( rspac -> length ) { ret = _kdc_tkt_add_if_relevant_ad ( context , & et , KRB5_AUTHDATA_WIN2K_PAC , rspac ) ; if ( ret ) goto out ; } if ( auth_data ) { unsigned int i = 0 ; if ( et . authorization_data == NULL ) { et . authorization_data = calloc ( 1 , sizeof ( * et . authorization_data ) ) ; if ( et . authorization_data == NULL ) { ret = ENOMEM ; krb5_set_error_message ( context , ret , ""malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; goto out ; } } for ( i = 0 ; i < auth_data -> len ; i ++ ) { ret = add_AuthorizationData ( et . authorization_data , & auth_data -> val [ i ] ) ; if ( ret ) { krb5_set_error_message ( context , ret , ""malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; goto out ; } } ret = find_KRB5SignedPath ( context , et . authorization_data , NULL ) ; if ( ret == 0 ) { if ( et . authorization_data -> len == 1 ) { free_AuthorizationData ( et . authorization_data ) ; free ( et . authorization_data ) ; et . authorization_data = NULL ; } else { AuthorizationData * ad = et . authorization_data ; free_AuthorizationDataElement ( & ad -> val [ ad -> len - 1 ] ) ; ad -> len -- ; } } } ret = krb5_copy_keyblock_contents ( context , sessionkey , & et . key ) ; if ( ret ) goto out ; et . crealm = tgt_name -> realm ; et . cname = tgt_name -> name ; ek . key = et . key ; ek . last_req . val = calloc ( 1 , sizeof ( * ek . last_req . val ) ) ; if ( ek . last_req . val == NULL ) { ret = ENOMEM ; goto out ; } ek . last_req . len = 1 ; ek . nonce = b -> nonce ; ek . flags = et . flags ; ek . authtime = et . authtime ; ek . starttime = et . starttime ; ek . endtime = et . endtime ; ek . renew_till = et . renew_till ; ek . srealm = rep . ticket . realm ; ek . sname = rep . ticket . sname ; _kdc_log_timestamp ( context , config , ""TGS-REQ"" , et . authtime , et . starttime , et . endtime , et . renew_till ) ; { char * r = get_krbtgt_realm ( & ek . sname ) ; if ( r == NULL || strcmp ( r , ek . srealm ) == 0 ) { ret = _kdc_add_KRB5SignedPath ( context , config , krbtgt , krbtgt_etype , client_principal , NULL , spp , & et ) ; if ( ret ) goto out ; } } if ( enc_pa_data -> len ) { rep . padata = calloc ( 1 , sizeof ( * rep . padata ) ) ; if ( rep . padata == NULL ) { ret = ENOMEM ; goto out ; } ret = copy_METHOD_DATA ( enc_pa_data , rep . padata ) ; if ( ret ) goto out ; } if ( krb5_enctype_valid ( context , serverkey -> keytype ) != 0 && _kdc_is_weak_exception ( server -> entry . principal , serverkey -> keytype ) ) { krb5_enctype_enable ( context , serverkey -> keytype ) ; is_weak = 1 ; } ret = _kdc_encode_reply ( context , config , NULL , 0 , & rep , & et , & ek , serverkey -> keytype , kvno , serverkey , 0 , replykey , rk_is_subkey , e_text , reply ) ; if ( is_weak ) krb5_enctype_disable ( context , serverkey -> keytype ) ; out : free_TGS_REP ( & rep ) ; free_TransitedEncoding ( & et . transited ) ; if ( et . starttime ) free ( et . starttime ) ; if ( et . renew_till ) free ( et . renew_till ) ; if ( et . authorization_data ) { free_AuthorizationData ( et . authorization_data ) ; free ( et . authorization_data ) ; } free_LastReq ( & ek . last_req ) ; memset ( et . key . keyvalue . data , 0 , et . key . keyvalue . length ) ; free_EncryptionKey ( & et . key ) ; return ret ; }
","<S2SV_ModStart> , krb5_principal client_principal , const char * tgt_realm <S2SV_ModStart> principal ) , tgt_realm <S2SV_ModEnd> ) ; if
",CWE-295
335,"CWE-400 <S2SV_StartBug> static void evtchn_fifo_handle_events ( unsigned cpu ) <S2SV_EndBug> { <S2SV_StartBug> __evtchn_fifo_handle_events ( cpu , false ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart> ( cpu , ctrl <S2SV_ModEnd> ) ; }
",CWE-400
337,"CWE-20 error_t rawSocketProcessIpPacket ( NetInterface * interface , IpPseudoHeader * pseudoHeader , const NetBuffer * buffer , size_t offset , NetRxAncillary * ancillary ) { uint_t i ; size_t length ; Socket * socket ; SocketQueueItem * queueItem ; NetBuffer * p ; length = netBufferGetLength ( buffer ) - offset ; for ( i = 0 ; i < SOCKET_MAX_COUNT ; i ++ ) { socket = socketTable + i ; if ( socket -> type != SOCKET_TYPE_RAW_IP ) continue ; if ( socket -> interface && socket -> interface != interface ) continue ; # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { if ( socket -> protocol != pseudoHeader -> ipv4Data . protocol ) continue ; if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> localIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . destAddr ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> remoteIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . srcAddr ) continue ; } } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { if ( socket -> protocol != pseudoHeader -> ipv6Data . nextHeader ) continue ; if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> localIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . destAddr ) ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> remoteIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . srcAddr ) ) continue ; } } else # endif { continue ; } break ; } if ( i >= SOCKET_MAX_COUNT ) return ERROR_PROTOCOL_UNREACHABLE ; if ( socket -> receiveQueue == NULL ) { p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem = netBufferAt ( p , 0 ) ; queueItem -> buffer = p ; socket -> receiveQueue = queueItem ; } else { queueItem = NULL ; } } else { queueItem = socket -> receiveQueue ; for ( i = 1 ; queueItem -> next ; i ++ ) { queueItem = queueItem -> next ; } if ( i >= RAW_SOCKET_RX_QUEUE_SIZE ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_RECEIVE_QUEUE_FULL ; } p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem -> next = netBufferAt ( p , 0 ) ; queueItem = queueItem -> next ; queueItem -> buffer = p ; } else { queueItem = NULL ; } } if ( queueItem == NULL ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_OUT_OF_MEMORY ; } queueItem -> next = NULL ; <S2SV_StartBug> queueItem -> srcPort = 0 ; <S2SV_EndBug> # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> srcIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> destIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . destAddr ; } # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> srcIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> destIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . destAddr ; } # endif queueItem -> offset = sizeof ( SocketQueueItem ) ; netBufferCopy ( queueItem -> buffer , queueItem -> offset , buffer , offset , length ) ; queueItem -> ancillary = * ancillary ; rawSocketUpdateEvents ( socket ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; queueItem -> interface = interface ; queueItem ->
",CWE-20
338,"CWE-119 <S2SV_StartBug> static void encode_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> int ctx ; PARTITION_TYPE partition ; <S2SV_StartBug> BLOCK_SIZE subsize ; <S2SV_EndBug> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; if ( bsize >= BLOCK_8X8 ) { ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> subsize = * get_sb_partitioning ( x , bsize ) ; <S2SV_EndBug> } else { ctx = 0 ; subsize = BLOCK_4X4 ; } <S2SV_StartBug> partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_EndBug> switch ( partition ) { case PARTITION_NONE : <S2SV_StartBug> if ( output_enabled && bsize >= BLOCK_8X8 ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_NONE ] ++ ; <S2SV_StartBug> encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> break ; case PARTITION_VERT : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; } break ; case PARTITION_HORZ : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_HORZ ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; } break ; case PARTITION_SPLIT : <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_EndBug> if ( output_enabled ) cm -> counts . partition [ ctx ] [ PARTITION_SPLIT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 2 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 3 ; encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize ) ; break ; default : <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> } if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; }
","<S2SV_ModStart> * cpi , ThreadData * td , <S2SV_ModStart> , BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = <S2SV_ModStart> ; BLOCK_SIZE subsize = bsize <S2SV_ModStart> ; subsize = get_subsize ( bsize , pc_tree -> partitioning <S2SV_ModEnd> ) ; } <S2SV_ModStart> [ subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ <S2SV_ModStart> case PARTITION_NONE : <S2SV_ModEnd> encode_b ( cpi <S2SV_ModStart> , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none <S2SV_ModEnd> ) ; break <S2SV_ModStart> case PARTITION_VERT : encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> cm -> mi_cols && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_HORZ : encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> cm -> mi_rows && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_SPLIT : if ( bsize == BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> encode_sb ( cpi <S2SV_ModStart> ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) ; encode_sb ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> ; encode_sb ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; encode_sb ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] ) ; } <S2SV_ModEnd> break ; default <S2SV_ModStart> : assert ( 0 && ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break <S2SV_ModEnd> ; } if
",CWE-119
340,"CWE-362 static int sctp_init_sock ( struct sock * sk ) { struct net * net = sock_net ( sk ) ; struct sctp_sock * sp ; pr_debug ( ""%s:<S2SV_blank>sk:%p\\n"" , __func__ , sk ) ; sp = sctp_sk ( sk ) ; switch ( sk -> sk_type ) { case SOCK_SEQPACKET : sp -> type = SCTP_SOCKET_UDP ; break ; case SOCK_STREAM : sp -> type = SCTP_SOCKET_TCP ; break ; default : return - ESOCKTNOSUPPORT ; } sp -> default_stream = 0 ; sp -> default_ppid = 0 ; sp -> default_flags = 0 ; sp -> default_context = 0 ; sp -> default_timetolive = 0 ; sp -> default_rcv_context = 0 ; sp -> max_burst = net -> sctp . max_burst ; sp -> sctp_hmac_alg = net -> sctp . sctp_hmac_alg ; sp -> initmsg . sinit_num_ostreams = sctp_max_outstreams ; sp -> initmsg . sinit_max_instreams = sctp_max_instreams ; sp -> initmsg . sinit_max_attempts = net -> sctp . max_retrans_init ; sp -> initmsg . sinit_max_init_timeo = net -> sctp . rto_max ; sp -> rtoinfo . srto_initial = net -> sctp . rto_initial ; sp -> rtoinfo . srto_max = net -> sctp . rto_max ; sp -> rtoinfo . srto_min = net -> sctp . rto_min ; sp -> assocparams . sasoc_asocmaxrxt = net -> sctp . max_retrans_association ; sp -> assocparams . sasoc_number_peer_destinations = 0 ; sp -> assocparams . sasoc_peer_rwnd = 0 ; sp -> assocparams . sasoc_local_rwnd = 0 ; sp -> assocparams . sasoc_cookie_life = net -> sctp . valid_cookie_life ; memset ( & sp -> subscribe , 0 , sizeof ( struct sctp_event_subscribe ) ) ; sp -> hbinterval = net -> sctp . hb_interval ; sp -> pathmaxrxt = net -> sctp . max_retrans_path ; sp -> pathmtu = 0 ; sp -> sackdelay = net -> sctp . sack_timeout ; sp -> sackfreq = 2 ; sp -> param_flags = SPP_HB_ENABLE | SPP_PMTUD_ENABLE | SPP_SACKDELAY_ENABLE ; sp -> disable_fragments = 0 ; sp -> nodelay = 0 ; sp -> recvrcvinfo = 0 ; sp -> recvnxtinfo = 0 ; sp -> v4mapped = 1 ; sp -> autoclose = 0 ; sp -> user_frag = 0 ; sp -> adaptation_ind = 0 ; sp -> pf = sctp_get_pf_specific ( sk -> sk_family ) ; atomic_set ( & sp -> pd_mode , 0 ) ; skb_queue_head_init ( & sp -> pd_lobby ) ; sp -> frag_interleave = 0 ; sp -> ep = sctp_endpoint_new ( sk , GFP_KERNEL ) ; if ( ! sp -> ep ) return - ENOMEM ; sp -> hmac = NULL ; sk -> sk_destruct = sctp_destruct_sock ; SCTP_DBG_OBJCNT_INC ( sock ) ; local_bh_disable ( ) ; percpu_counter_inc ( & sctp_sockets_allocated ) ; sock_prot_inuse_add ( net , sk -> sk_prot , 1 ) ; if ( net -> sctp . default_auto_asconf ) { <S2SV_StartBug> list_add_tail ( & sp -> auto_asconf_list , <S2SV_EndBug> & net -> sctp . auto_asconf_splist ) ; <S2SV_StartBug> sp -> do_auto_asconf = 1 ; <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 0 ; <S2SV_EndBug> local_bh_enable ( ) ; return 0 ; }
","<S2SV_ModStart> default_auto_asconf ) { spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> do_auto_asconf = 1 ; spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) <S2SV_ModStart> ; } else { <S2SV_ModStart> = 0 ; }
",CWE-362
341,"CWE-17 void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> file_free ( file ) ; } }
","<S2SV_ModStart> file ) ; <S2SV_ModEnd> file_free ( file
",CWE-17
342,"CWE-119 cJSON * cJSON_CreateString ( const char * string ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) { item -> type = cJSON_String ; item -> valuestring = cJSON_strdup ( string ) ; <S2SV_StartBug> } <S2SV_EndBug> return item ; }
","<S2SV_ModStart> string ) ; if ( ! item -> valuestring ) { cJSON_Delete ( item ) ; return 0 ; } } <S2SV_ModEnd> return item ;
",CWE-119
343,"CWE-119 int effect_command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { effect_context_t * context = ( effect_context_t * ) self ; int retsize ; int status = 0 ; pthread_mutex_lock ( & lock ) ; if ( ! effect_exists ( context ) ) { status = - ENOSYS ; goto exit ; } if ( context == NULL || context -> state == EFFECT_STATE_UNINITIALIZED ) { status = - ENOSYS ; goto exit ; } switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> ops . init ) * ( int * ) pReplyData = context -> ops . init ( context ) ; else * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } * ( int * ) pReplyData = set_config ( context , ( effect_config_t * ) pCmdData ) ; break ; case EFFECT_CMD_GET_CONFIG : if ( pReplyData == NULL || * replySize != sizeof ( effect_config_t ) ) { status = - EINVAL ; goto exit ; } if ( ! context -> offload_enabled ) { status = - EINVAL ; goto exit ; } get_config ( context , ( effect_config_t * ) pReplyData ) ; break ; case EFFECT_CMD_RESET : if ( context -> ops . reset ) context -> ops . reset ( context ) ; break ; case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> state != EFFECT_STATE_INITIALIZED ) { status = - ENOSYS ; goto exit ; } context -> state = EFFECT_STATE_ACTIVE ; if ( context -> ops . enable ) context -> ops . enable ( context ) ; ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_ENABLE"" , __func__ ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> state != EFFECT_STATE_ACTIVE ) { status = - ENOSYS ; goto exit ; } context -> state = EFFECT_STATE_INITIALIZED ; if ( context -> ops . disable ) context -> ops . disable ( context ) ; ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_DISABLE"" , __func__ ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_GET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) ) || pReplyData == NULL || * replySize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + <S2SV_StartBug> sizeof ( uint16_t ) ) ) { <S2SV_EndBug> status = - EINVAL ; ALOGV ( ""EFFECT_CMD_GET_PARAM<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>*replySize<S2SV_blank>%d"" , cmdSize , * replySize ) ; goto exit ; } if ( ! context -> offload_enabled ) { status = - EINVAL ; goto exit ; } effect_param_t * q = ( effect_param_t * ) pCmdData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + q -> psize ) ; effect_param_t * p = ( effect_param_t * ) pReplyData ; if ( context -> ops . get_parameter ) context -> ops . get_parameter ( context , p , replySize ) ; } break ; case EFFECT_CMD_SET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + sizeof ( uint16_t ) ) || pReplyData == NULL || * replySize != sizeof ( int32_t ) ) { status = - EINVAL ; ALOGV ( ""EFFECT_CMD_SET_PARAM<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>*replySize<S2SV_blank>%d"" , cmdSize , * replySize ) ; goto exit ; } * ( int32_t * ) pReplyData = 0 ; effect_param_t * p = ( effect_param_t * ) pCmdData ; if ( context -> ops . set_parameter ) * ( int32_t * ) pReplyData = context -> ops . set_parameter ( context , p , * replySize ) ; } break ; case EFFECT_CMD_SET_DEVICE : { uint32_t device ; ALOGV ( ""\\t<S2SV_blank>EFFECT_CMD_SET_DEVICE<S2SV_blank>start"" ) ; if ( pCmdData == NULL || cmdSize < sizeof ( uint32_t ) ) { status = - EINVAL ; ALOGV ( ""EFFECT_CMD_SET_DEVICE<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d"" , cmdSize ) ; goto exit ; } device = * ( uint32_t * ) pCmdData ; if ( context -> ops . set_device ) context -> ops . set_device ( context , device ) ; } break ; case EFFECT_CMD_SET_VOLUME : case EFFECT_CMD_SET_AUDIO_MODE : break ; case EFFECT_CMD_OFFLOAD : { output_context_t * out_ctxt ; if ( cmdSize != sizeof ( effect_offload_param_t ) || pCmdData == NULL || pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_OFFLOAD<S2SV_blank>bad<S2SV_blank>format"" , __func__ ) ; status = - EINVAL ; break ; } effect_offload_param_t * offload_param = ( effect_offload_param_t * ) pCmdData ; ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_OFFLOAD<S2SV_blank>offload<S2SV_blank>%d<S2SV_blank>output<S2SV_blank>%d"" , __func__ , offload_param -> isOffload , offload_param -> ioHandle ) ; * ( int * ) pReplyData = 0 ; context -> offload_enabled = offload_param -> isOffload ; if ( context -> out_handle == offload_param -> ioHandle ) break ; out_ctxt = get_output ( context -> out_handle ) ; if ( out_ctxt != NULL ) remove_effect_from_output ( out_ctxt , context ) ; context -> out_handle = offload_param -> ioHandle ; out_ctxt = get_output ( context -> out_handle ) ; if ( out_ctxt != NULL ) add_effect_to_output ( out_ctxt , context ) ; } break ; default : if ( cmdCode >= EFFECT_CMD_FIRST_PROPRIETARY && context -> ops . command ) status = context -> ops . command ( context , cmdCode , cmdSize , pCmdData , replySize , pReplyData ) ; else { ALOGW ( ""%s<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>%d"" , __func__ , cmdCode ) ; status = - EINVAL ; } break ; } exit : pthread_mutex_unlock ( & lock ) ; return status ; }
","<S2SV_ModStart> ( uint16_t ) ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t
",CWE-119
346,"CWE-416 ExprDef * ExprAppendMultiKeysymList ( ExprDef * expr , ExprDef * append ) { unsigned nSyms = darray_size ( expr -> keysym_list . syms ) ; unsigned numEntries = darray_size ( append -> keysym_list . syms ) ; darray_append ( expr -> keysym_list . symsMapIndex , nSyms ) ; darray_append ( expr -> keysym_list . symsNumEntries , numEntries ) ; darray_concat ( expr -> keysym_list . syms , append -> keysym_list . syms ) ; <S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> return expr ; }
","<S2SV_ModStart> ParseCommon * ) <S2SV_ModEnd> append ) ;
",CWE-416
349,"CWE-770 int server_partial_file_request ( struct httpd * env , struct client * clt , char * path , struct stat * st , char * range_str ) { struct server_config * srv_conf = clt -> clt_srv_conf ; struct http_descriptor * resp = clt -> clt_descresp ; struct http_descriptor * desc = clt -> clt_descreq ; struct media_type * media , multipart_media ; <S2SV_StartBug> struct range * range ; <S2SV_EndBug> struct evbuffer * evb = NULL ; <S2SV_StartBug> size_t content_length ; <S2SV_EndBug> <S2SV_StartBug> int code = 500 , fd = - 1 , i , nranges , ret ; <S2SV_EndBug> uint32_t boundary ; char content_range [ 64 ] ; const char * errstr = NULL ; if ( desc -> http_method != HTTP_METHOD_GET ) return server_file_request ( env , clt , path , st ) ; <S2SV_StartBug> if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) { <S2SV_EndBug> code = 416 ; ( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes<S2SV_blank>*/%lld"" , st -> st_size ) ; errstr = content_range ; goto abort ; } if ( ( fd = open ( path , O_RDONLY ) ) == - 1 ) goto abort ; media = media_find_config ( env , srv_conf , path ) ; <S2SV_StartBug> if ( ( evb = evbuffer_new ( ) ) == NULL ) { <S2SV_EndBug> errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer"" ; goto abort ; } if ( nranges == 1 ) { <S2SV_StartBug> ( void ) snprintf ( content_range , sizeof ( content_range ) , <S2SV_EndBug> ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ; if ( kv_add ( & resp -> http_headers , ""Content-Range"" , content_range ) == NULL ) goto abort ; <S2SV_StartBug> content_length = range -> end - range -> start + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( buffer_add_range ( fd , evb , range ) == 0 ) <S2SV_EndBug> goto abort ; } else { <S2SV_StartBug> content_length = 0 ; <S2SV_EndBug> boundary = arc4random ( ) ; while ( nranges -- ) { if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud\\r\\n"" , boundary ) ) == - 1 ) goto abort ; <S2SV_StartBug> content_length += i ; <S2SV_EndBug> if ( ( i = evbuffer_add_printf ( evb , ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" , media -> media_type , media -> media_subtype ) ) == - 1 ) goto abort ; content_length += i ; if ( ( i = evbuffer_add_printf ( evb , ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , range -> start , range -> end , st -> st_size ) ) == - 1 ) goto abort ; content_length += i ; if ( buffer_add_range ( fd , evb , range ) == 0 ) goto abort ; content_length += range -> end - range -> start + 1 ; <S2SV_StartBug> range ++ ; <S2SV_EndBug> } <S2SV_StartBug> if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud--\\r\\n"" , <S2SV_EndBug> boundary ) ) == - 1 ) goto abort ; <S2SV_StartBug> content_length += i ; <S2SV_EndBug> ( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ; ( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) , <S2SV_StartBug> ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ; <S2SV_EndBug> media = & multipart_media ; } <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> fd = - 1 ; ret = server_response_http ( clt , 206 , media , content_length , MINIMUM ( time ( NULL ) , st -> st_mtim . tv_sec ) ) ; switch ( ret ) { case - 1 : goto fail ; case 0 : <S2SV_StartBug> goto done ; <S2SV_EndBug> default : break ; } <S2SV_StartBug> if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 ) <S2SV_EndBug> goto fail ; <S2SV_StartBug> bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( clt -> clt_persist ) <S2SV_EndBug> clt -> clt_toread = TOREAD_HTTP_HEADER ; else clt -> clt_toread = TOREAD_HTTP_NONE ; clt -> clt_done = 0 ; done : evbuffer_free ( evb ) ; server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; bufferevent_free ( clt -> clt_bev ) ; clt -> clt_bev = NULL ; abort : <S2SV_StartBug> if ( evb != NULL ) <S2SV_EndBug> evbuffer_free ( evb ) ; if ( fd != - 1 ) close ( fd ) ; if ( errstr == NULL ) errstr = strerror ( errno ) ; server_abort_http ( clt , code , errstr ) ; return ( - 1 ) ; }
","<S2SV_ModStart> multipart_media ; struct range_data * r = & clt -> clt_ranges ; struct range * range <S2SV_ModEnd> ; size_t content_length <S2SV_ModStart> ; size_t content_length = 0 <S2SV_ModStart> nranges , ret <S2SV_ModEnd> ; char content_range <S2SV_ModStart> if ( ( nranges = parse_ranges ( clt , <S2SV_ModEnd> range_str , st <S2SV_ModStart> st -> st_size ) ) < 1 <S2SV_ModEnd> ) { code <S2SV_ModStart> path ) ; r -> range_media = media ; <S2SV_ModEnd> if ( nranges <S2SV_ModStart> 1 ) { range = & r -> range [ 0 ] ; <S2SV_ModStart> goto abort ; range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu\\r\\n"" ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret + <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu--\\r\\n"" , clt -> clt_boundary ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret <S2SV_ModEnd> ; ( void <S2SV_ModStart> media_subtype ) , ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary <S2SV_ModEnd> ) ; media <S2SV_ModStart> multipart_media ; } r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> ; ret = <S2SV_ModStart> case 0 : close ( fd ) ; <S2SV_ModStart> break ; } clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ; <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> ( clt -> <S2SV_ModStart> EV_WRITE ) ; <S2SV_ModEnd> bufferevent_free ( clt <S2SV_ModStart> ; abort : <S2SV_ModEnd> if ( fd
",CWE-770
351,"CWE-79 static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , ""enter"" ) ; const char * java_script = ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\""text/javascript\\"">\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n"" ""\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" <S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n"" <S2SV_EndBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n"" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\0' ; const char * op_iframe_id = ""openidc-op"" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , ""no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?"" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , ""poll"" , & s_poll_interval ) ; <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> s_poll_interval = ""3000"" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , ""setTimer"" , NULL , DONE ) ; }
","<S2SV_ModStart> ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n"" <S2SV_ModEnd> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" <S2SV_ModStart> s_poll_interval ) ; int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> ; const char <S2SV_ModStart> , op_iframe_id , poll_interval <S2SV_ModEnd> , redirect_uri ,
",CWE-79
353,"CWE-399 static int dissect_spoolss_uint16uni ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint8 * drep _U_ , char * * data , int hf_name ) { gint len , remaining ; char * text ; if ( offset % 2 ) offset += 2 - ( offset % 2 ) ; <S2SV_StartBug> remaining = tvb_captured_length_remaining ( tvb , offset ) ; <S2SV_EndBug> if ( remaining <= 0 ) { if ( data ) * data = g_strdup ( """" ) ; return offset ; } text = tvb_get_string_enc ( NULL , tvb , offset , remaining , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ; len = ( int ) strlen ( text ) ; proto_tree_add_string ( tree , hf_name , tvb , offset , len * 2 , text ) ; if ( data ) * data = text ; else g_free ( text ) ; return offset + ( len + 1 ) * 2 ; }
","<S2SV_ModStart> ; remaining = tvb_reported_length_remaining <S2SV_ModEnd> ( tvb ,
",CWE-399
356,"CWE-476 static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; tmp = ! ! tmp ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> cluster -> cl_local_node != node -> nd_num ) <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> ret = o2net_start_listening ( node ) ; if ( ret ) <S2SV_StartBug> return ret ; <S2SV_EndBug> } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } <S2SV_StartBug> return count ; <S2SV_EndBug> }
","<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> -> nd_num ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; goto out ; } <S2SV_ModStart> ( ret ) goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> nd_num ; } ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",CWE-476
357,"CWE-399 static int kvm_set_guest_paused ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> return - EINVAL ; vcpu -> arch . pvclock_set_guest_stopped_request = true ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; return 0 ; }
","<S2SV_ModStart> -> arch . pv_time_enabled <S2SV_ModEnd> ) return -
",CWE-399
361,"CWE-20 static int lmp_print_data_link_subobjs ( netdissect_options * ndo , const u_char * obj_tptr , int total_subobj_len , int offset ) { int hexdump = FALSE ; int subobj_type , subobj_len ; union { float f ; uint32_t i ; } bw ; while ( total_subobj_len > 0 && hexdump == FALSE ) { <S2SV_StartBug> subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; <S2SV_EndBug> subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Subobject,<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Length:<S2SV_blank>%u"" , tok2str ( lmp_data_link_subobj , ""Unknown"" , subobj_type ) , subobj_type , subobj_len ) ) ; if ( subobj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; break ; } if ( ( subobj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; break ; } if ( total_subobj_len < subobj_len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>object)"" ) ) ; break ; } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> tok2str ( gmpls_switch_cap_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) , <S2SV_StartBug> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( gmpls_encoding_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Min<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Max<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , <S2SV_EndBug> EXTRACT_32BITS ( obj_tptr + offset + 4 ) ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; offset += subobj_len ; } return ( hexdump ) ; trunc : return - 1 ; }
","<S2SV_ModStart> FALSE ) { ND_TCHECK_16BITS ( obj_tptr + offset ) ; <S2SV_ModStart> case INT_SWITCHING_TYPE_SUBOBJ : ND_TCHECK_8BITS ( obj_tptr + offset + 2 ) ; <S2SV_ModStart> 2 ) ) ) ; ND_TCHECK_8BITS ( obj_tptr + offset + 3 <S2SV_ModStart> ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_ModStart> case WAVELENGTH_SUBOBJ : ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ;
",CWE-20
362,"CWE-119 <S2SV_StartBug> static BLOCK_SIZE get_rd_var_based_fixed_partition ( VP9_COMP * cpi , <S2SV_EndBug> int mi_row , int mi_col ) { <S2SV_StartBug> unsigned int var = get_sby_perpixel_diff_variance ( cpi , & cpi -> mb , <S2SV_EndBug> mi_row , mi_col , BLOCK_64X64 ) ; if ( var < 8 ) return BLOCK_64X64 ; else if ( var < 128 ) return BLOCK_32X32 ; else if ( var < 2048 ) return BLOCK_16X16 ; else return BLOCK_8X8 ; }
","<S2SV_ModStart> VP9_COMP * cpi , MACROBLOCK * x <S2SV_ModStart> cpi , & x -> plane [ 0 ] . src <S2SV_ModEnd> , mi_row ,
",CWE-119
364,"CWE-119 static void set_offsets ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; <S2SV_StartBug> const int mb_row = mi_row >> 1 ; <S2SV_EndBug> const int mb_col = mi_col >> 1 ; const int idx_map = mb_row * cm -> mb_cols + mb_col ; const struct segmentation * const seg = & cm -> seg ; set_skip_context ( xd , mi_row , mi_col ) ; <S2SV_StartBug> x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ; <S2SV_EndBug> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ; <S2SV_EndBug> x -> mv_row_min = - ( ( ( mi_row + mi_height ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; x -> mv_col_min = - ( ( ( mi_col + mi_width ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; x -> mv_row_max = ( cm -> mi_rows - mi_row ) * MI_SIZE + VP9_INTERP_EXTEND ; x -> mv_col_max = ( cm -> mi_cols - mi_col ) * MI_SIZE + VP9_INTERP_EXTEND ; assert ( ! ( mi_col & ( mi_width - 1 ) ) && ! ( mi_row & ( mi_height - 1 ) ) ) ; set_mi_row_col ( xd , tile , mi_row , mi_height , mi_col , mi_width , cm -> mi_rows , cm -> mi_cols ) ; vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ; <S2SV_StartBug> x -> rddiv = cpi -> RDDIV ; <S2SV_EndBug> <S2SV_StartBug> x -> rdmult = cpi -> RDMULT ; <S2SV_EndBug> if ( seg -> enabled ) { if ( cpi -> oxcf . aq_mode != VARIANCE_AQ ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; <S2SV_StartBug> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> } vp9_init_plane_quantizers ( cpi , x ) ; x -> encode_breakout = cpi -> segment_encode_breakout [ mbmi -> segment_id ] ; } else { mbmi -> segment_id = 0 ; x -> encode_breakout = cpi -> encode_breakout ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> const tile , MACROBLOCK * const x , <S2SV_ModStart> bsize ) { <S2SV_ModEnd> VP9_COMMON * const <S2SV_ModStart> ] ; const <S2SV_ModEnd> struct segmentation * <S2SV_ModStart> mi_col ) ; set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , <S2SV_ModStart> vp9_setup_dst_planes ( xd -> plane <S2SV_ModStart> = cpi -> rd . <S2SV_ModStart> = cpi -> rd . <S2SV_ModStart> -> segment_id = get_segment_id <S2SV_ModEnd> ( cm , <S2SV_ModStart> encode_breakout ; } xd -> tile = * tile ;
",CWE-119
365,"CWE-264 static void uv__process_child_init ( const uv_process_options_t * options , int stdio_count , int ( * pipes ) [ 2 ] , int error_fd ) { int close_fd ; int use_fd ; int fd ; if ( options -> flags & UV_PROCESS_DETACHED ) setsid ( ) ; for ( fd = 0 ; fd < stdio_count ; fd ++ ) { close_fd = pipes [ fd ] [ 0 ] ; use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd < 0 ) { if ( fd >= 3 ) continue ; else { use_fd = open ( ""/dev/null"" , fd == 0 ? O_RDONLY : O_RDWR ) ; close_fd = use_fd ; if ( use_fd == - 1 ) { uv__write_int ( error_fd , - errno ) ; perror ( ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stdio"" ) ; _exit ( 127 ) ; } } } if ( fd == use_fd ) uv__cloexec ( use_fd , 0 ) ; else dup2 ( use_fd , fd ) ; if ( fd <= 2 ) uv__nonblock ( fd , 0 ) ; if ( close_fd != - 1 ) uv__close ( close_fd ) ; } for ( fd = 0 ; fd < stdio_count ; fd ++ ) { use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd >= 0 && fd != use_fd ) close ( use_fd ) ; } if ( options -> cwd != NULL && chdir ( options -> cwd ) ) { uv__write_int ( error_fd , - errno ) ; perror ( ""chdir()"" ) ; _exit ( 127 ) ; } <S2SV_StartBug> if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) { <S2SV_EndBug> uv__write_int ( error_fd , - errno ) ; perror ( ""setgid()"" ) ; _exit ( 127 ) ; } if ( ( options -> flags & UV_PROCESS_SETUID ) && setuid ( options -> uid ) ) { uv__write_int ( error_fd , - errno ) ; perror ( ""setuid()"" ) ; _exit ( 127 ) ; } if ( options -> env != NULL ) { environ = options -> env ; } execvp ( options -> file , options -> args ) ; uv__write_int ( error_fd , - errno ) ; perror ( ""execvp()"" ) ; _exit ( 127 ) ; }
","<S2SV_ModStart> } if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if (
",CWE-264
366,"CWE-119 WORD32 ihevcd_parse_transform_tree ( codec_t * ps_codec , WORD32 x0 , WORD32 y0 , WORD32 cu_x_base , WORD32 cu_y_base , WORD32 log2_trafo_size , WORD32 trafo_depth , WORD32 blk_idx , WORD32 intra_pred_mode ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; sps_t * ps_sps ; pps_t * ps_pps ; WORD32 value ; WORD32 x1 , y1 ; WORD32 max_trafo_depth ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; WORD32 intra_split_flag ; WORD32 split_transform_flag ; WORD32 ctxt_idx ; cab_ctxt_t * ps_cabac = & ps_codec -> s_parse . s_cabac ; max_trafo_depth = ps_codec -> s_parse . s_cu . i4_max_trafo_depth ; ps_sps = ps_codec -> s_parse . ps_sps ; ps_pps = ps_codec -> s_parse . ps_pps ; intra_split_flag = ps_codec -> s_parse . s_cu . i4_intra_split_flag ; { split_transform_flag = 0 ; if ( ( log2_trafo_size <= ps_sps -> i1_log2_max_transform_block_size ) && ( log2_trafo_size > ps_sps -> i1_log2_min_transform_block_size ) && ( trafo_depth < max_trafo_depth ) && ! ( intra_split_flag && ( trafo_depth == 0 ) ) ) { ctxt_idx = IHEVC_CAB_SPLIT_TFM + ( 5 - log2_trafo_size ) ; TRACE_CABAC_CTXT ( ""split_transform_flag"" , ps_cabac -> u4_range , ctxt_idx ) ; split_transform_flag = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( ""split_transform_flag"" , split_transform_flag , ps_cabac -> u4_range ) ; } else { WORD32 inter_split_flag = 0 ; if ( ( 0 == ps_sps -> i1_max_transform_hierarchy_depth_inter ) && ( PRED_MODE_INTER == ps_codec -> s_parse . s_cu . i4_pred_mode ) && ( PART_2Nx2N != ps_codec -> s_parse . s_cu . i4_part_mode ) && ( 0 == trafo_depth ) ) { inter_split_flag = 1 ; } if ( ( log2_trafo_size > ps_sps -> i1_log2_max_transform_block_size ) || ( ( 1 == intra_split_flag ) && ( 0 == trafo_depth ) ) || ( 1 == inter_split_flag ) ) { split_transform_flag = 1 ; } } if ( 0 == trafo_depth ) { ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] = 0 ; ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] = 0 ; } else { ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] = ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth - 1 ] ; ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] = ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth - 1 ] ; } if ( trafo_depth == 0 || log2_trafo_size > 2 ) { ctxt_idx = IHEVC_CAB_CBCR_IDX + trafo_depth ; if ( ( trafo_depth == 0 ) || ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth - 1 ] ) { TRACE_CABAC_CTXT ( ""cbf_cb"" , ps_cabac -> u4_range , ctxt_idx ) ; value = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( ""cbf_cb"" , value , ps_cabac -> u4_range ) ; ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] = value ; } if ( ( trafo_depth == 0 ) || ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth - 1 ] ) { TRACE_CABAC_CTXT ( ""cbf_cr"" , ps_cabac -> u4_range , ctxt_idx ) ; value = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( ""cbf_cr"" , value , ps_cabac -> u4_range ) ; ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] = value ; } } if ( split_transform_flag ) { WORD32 intra_pred_mode_tmp ; x1 = x0 + ( ( 1 << log2_trafo_size ) >> 1 ) ; y1 = y0 + ( ( 1 << log2_trafo_size ) >> 1 ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 0 ] ; ihevcd_parse_transform_tree ( ps_codec , x0 , y0 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 0 , intra_pred_mode_tmp ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 1 ] ; ihevcd_parse_transform_tree ( ps_codec , x1 , y0 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 1 , intra_pred_mode_tmp ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 2 ] ; ihevcd_parse_transform_tree ( ps_codec , x0 , y1 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 2 , intra_pred_mode_tmp ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 3 ] ; ihevcd_parse_transform_tree ( ps_codec , x1 , y1 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 3 , intra_pred_mode_tmp ) ; } else { WORD32 ctb_x_base ; WORD32 ctb_y_base ; WORD32 cu_qp_delta_abs ; tu_t * ps_tu = ps_codec -> s_parse . ps_tu ; cu_qp_delta_abs = 0 ; ctb_x_base = ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ; ctb_y_base = ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ; if ( ( ps_codec -> s_parse . s_cu . i4_pred_mode == PRED_MODE_INTRA ) || ( trafo_depth != 0 ) || ( ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] ) || ( ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) ) { ctxt_idx = IHEVC_CAB_CBF_LUMA_IDX ; ctxt_idx += ( trafo_depth == 0 ) ? 1 : 0 ; TRACE_CABAC_CTXT ( ""cbf_luma"" , ps_cabac -> u4_range , ctxt_idx ) ; value = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( ""cbf_luma"" , value , ps_cabac -> u4_range ) ; ps_codec -> s_parse . s_cu . i1_cbf_luma = value ; } else { ps_codec -> s_parse . s_cu . i1_cbf_luma = 1 ; } ps_tu -> b1_cb_cbf = 0 ; ps_tu -> b1_cr_cbf = 0 ; ps_tu -> b1_y_cbf = 0 ; ps_tu -> b4_pos_x = ( ( x0 - ctb_x_base ) >> 2 ) ; ps_tu -> b4_pos_y = ( ( y0 - ctb_y_base ) >> 2 ) ; ps_tu -> b1_transquant_bypass = ps_codec -> s_parse . s_cu . i4_cu_transquant_bypass ; ps_tu -> b3_size = ( log2_trafo_size - 2 ) ; ps_tu -> b7_qp = ps_codec -> s_parse . u4_qp ; ps_tu -> b6_luma_intra_mode = intra_pred_mode ; ps_tu -> b3_chroma_intra_mode_idx = ps_codec -> s_parse . s_cu . i4_intra_chroma_pred_mode_idx ; if ( ps_codec -> s_parse . s_cu . i1_cbf_luma || ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] || ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) { WORD32 intra_pred_mode_chroma ; if ( ps_pps -> i1_cu_qp_delta_enabled_flag && ! ps_codec -> s_parse . i4_is_cu_qp_delta_coded ) { WORD32 c_max = TU_MAX_QP_DELTA_ABS ; WORD32 ctxt_inc = IHEVC_CAB_QP_DELTA_ABS ; WORD32 ctxt_inc_max = CTXT_MAX_QP_DELTA_ABS ; TRACE_CABAC_CTXT ( ""cu_qp_delta_abs"" , ps_cabac -> u4_range , ctxt_inc ) ; cu_qp_delta_abs = ihevcd_cabac_decode_bins_tunary ( ps_cabac , ps_bitstrm , c_max , ctxt_inc , 0 , ctxt_inc_max ) ; if ( cu_qp_delta_abs >= c_max ) { value = ihevcd_cabac_decode_bypass_bins_egk ( ps_cabac , ps_bitstrm , 0 ) ; cu_qp_delta_abs += value ; } AEV_TRACE ( ""cu_qp_delta_abs"" , cu_qp_delta_abs , ps_cabac -> u4_range ) ; ps_codec -> s_parse . i4_is_cu_qp_delta_coded = 1 ; if ( cu_qp_delta_abs ) { value = ihevcd_cabac_decode_bypass_bin ( ps_cabac , ps_bitstrm ) ; AEV_TRACE ( ""cu_qp_delta_sign"" , value , ps_cabac -> u4_range ) ; if ( value ) cu_qp_delta_abs = - cu_qp_delta_abs ; } <S2SV_StartBug> ps_codec -> s_parse . s_cu . i4_cu_qp_delta = cu_qp_delta_abs ; <S2SV_EndBug> } if ( ps_codec -> s_parse . s_cu . i1_cbf_luma ) { ps_tu -> b1_y_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , x0 , y0 , log2_trafo_size , 0 , intra_pred_mode ) ; } if ( 4 == ps_codec -> s_parse . s_cu . i4_intra_chroma_pred_mode_idx ) intra_pred_mode_chroma = ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 0 ] ; else { intra_pred_mode_chroma = gau1_intra_pred_chroma_modes [ ps_codec -> s_parse . s_cu . i4_intra_chroma_pred_mode_idx ] ; if ( intra_pred_mode_chroma == ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 0 ] ) { intra_pred_mode_chroma = INTRA_ANGULAR ( 34 ) ; } } if ( log2_trafo_size > 2 ) { if ( ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] ) { ps_tu -> b1_cb_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , x0 , y0 , log2_trafo_size - 1 , 1 , intra_pred_mode_chroma ) ; } if ( ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) { ps_tu -> b1_cr_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , x0 , y0 , log2_trafo_size - 1 , 2 , intra_pred_mode_chroma ) ; } } else if ( blk_idx == 3 ) { if ( ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] ) { ps_tu -> b1_cb_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , cu_x_base , cu_y_base , log2_trafo_size , 1 , intra_pred_mode_chroma ) ; } if ( ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) { ps_tu -> b1_cr_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , cu_x_base , cu_y_base , log2_trafo_size , 2 , intra_pred_mode_chroma ) ; } } else { ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; } } else { if ( ( 3 != blk_idx ) && ( 2 == log2_trafo_size ) ) { ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; } } { if ( ( ps_codec -> s_parse . s_cu . i4_pos_x << 3 ) == ( ps_tu -> b4_pos_x << 2 ) && ( ps_codec -> s_parse . s_cu . i4_pos_y << 3 ) == ( ps_tu -> b4_pos_y << 2 ) ) { ps_tu -> b1_first_tu_in_cu = 1 ; } else { ps_tu -> b1_first_tu_in_cu = 0 ; } } ps_codec -> s_parse . ps_tu ++ ; ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ; ps_codec -> s_parse . i4_pic_tu_idx ++ ; } } return ret ; }
","<S2SV_ModStart> cu_qp_delta_abs ; } if ( cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) ) { return IHEVCD_INVALID_PARAMETER ; }
",CWE-119
369,"CWE-125 static int serdes_probe ( struct platform_device * pdev ) { struct phy_provider * provider ; struct serdes_ctrl * ctrl ; unsigned int i ; int ret ; ctrl = devm_kzalloc ( & pdev -> dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( ! ctrl ) return - ENOMEM ; ctrl -> dev = & pdev -> dev ; ctrl -> regs = syscon_node_to_regmap ( pdev -> dev . parent -> of_node ) ; if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ; } dev_set_drvdata ( & pdev -> dev , ctrl ) ; provider = devm_of_phy_provider_register ( ctrl -> dev , serdes_simple_xlate ) ; return PTR_ERR_OR_ZERO ( provider ) ; }
","<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i
",CWE-125
370,"CWE-200 SYSCALL_DEFINE5 ( waitid , int , which , pid_t , upid , struct siginfo __user * , infop , int , options , struct rusage __user * , ru ) { struct rusage r ; struct waitid_info info = { . status = 0 } ; long err = kernel_waitid ( which , upid , & info , options , ru ? & r : NULL ) ; int signo = 0 ; if ( err > 0 ) { signo = SIGCHLD ; err = 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! err ) { if ( ru && copy_to_user ( ru , & r , sizeof ( struct rusage ) ) ) return - EFAULT ; } if ( ! infop ) return err ; user_access_begin ( ) ; unsafe_put_user ( signo , & infop -> si_signo , Efault ) ; unsafe_put_user ( 0 , & infop -> si_errno , Efault ) ; unsafe_put_user ( info . cause , & infop -> si_code , Efault ) ; unsafe_put_user ( info . pid , & infop -> si_pid , Efault ) ; unsafe_put_user ( info . uid , & infop -> si_uid , Efault ) ; unsafe_put_user ( info . status , & infop -> si_status , Efault ) ; user_access_end ( ) ; return err ; Efault : user_access_end ( ) ; return - EFAULT ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ru
",CWE-200
371,"CWE-119 <S2SV_StartBug> static void write_ref_frames ( const VP9_COMP * cpi , vp9_writer * w ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! is_compound ) ; <S2SV_EndBug> assert ( mbmi -> ref_frame [ 0 ] == vp9_get_segdata ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ; } else { <S2SV_StartBug> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { <S2SV_EndBug> vp9_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else { assert ( ! is_compound == ( cm -> reference_mode == SINGLE_REFERENCE ) ) ; } if ( is_compound ) { <S2SV_StartBug> vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , <S2SV_EndBug> vp9_get_pred_prob_comp_ref_p ( cm , xd ) ) ; } else { const int bit0 = mbmi -> ref_frame [ 0 ] != LAST_FRAME ; <S2SV_StartBug> vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ; <S2SV_EndBug> if ( bit0 ) { const int bit1 = mbmi -> ref_frame [ 0 ] != GOLDEN_FRAME ; <S2SV_StartBug> vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ; <S2SV_EndBug> } } } }
","<S2SV_ModStart> write_ref_frames ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) { const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { assert ( ! is_compound ) ; assert ( mbmi -> ref_frame [ 0 ] == get_segdata ( & <S2SV_ModEnd> cm -> seg <S2SV_ModStart> SEG_LVL_REF_FRAME ) ) ; } else { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { vpx_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else <S2SV_ModStart> ( ! is_compound == <S2SV_ModEnd> ( cm -> <S2SV_ModStart> -> reference_mode == <S2SV_ModEnd> SINGLE_REFERENCE ) ) <S2SV_ModStart> is_compound ) { vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> != LAST_FRAME ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> != GOLDEN_FRAME ; vpx_write <S2SV_ModEnd> ( w ,
",CWE-119
373,"CWE-119 <S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) { <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { ALOGE ( ""can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>*<S2SV_blank>%u<S2SV_blank>bytes"" , size , num ) ; android_errorWriteLog ( 0x534e4554 , ""27855419"" ) ; return NULL ; } <S2SV_ModEnd> return malloc ( <S2SV_ModStart> malloc ( size * num
",CWE-119
377,"CWE-119 void vp9_adapt_mv_probs ( VP9_COMMON * cm , int allow_hp ) { int i , j ; <S2SV_StartBug> nmv_context * fc = & cm -> fc . nmvc ; <S2SV_EndBug> const nmv_context * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] . nmvc ; const nmv_context_counts * counts = & cm -> counts . mv ; <S2SV_StartBug> adapt_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ; <S2SV_EndBug> for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * comp = & fc -> comps [ i ] ; const nmv_component * pre_comp = & pre_fc -> comps [ i ] ; const nmv_component_counts * c = & counts -> comps [ i ] ; <S2SV_StartBug> comp -> sign = adapt_prob ( pre_comp -> sign , c -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes , <S2SV_EndBug> comp -> classes ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ; <S2SV_EndBug> for ( j = 0 ; j < MV_OFFSET_BITS ; ++ j ) <S2SV_StartBug> comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ; <S2SV_EndBug> for ( j = 0 ; j < CLASS0_SIZE ; ++ j ) <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] , <S2SV_EndBug> comp -> class0_fp [ j ] ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ; <S2SV_EndBug> if ( allow_hp ) { <S2SV_StartBug> comp -> class0_hp = adapt_prob ( pre_comp -> class0_hp , c -> class0_hp ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> hp = adapt_prob ( pre_comp -> hp , c -> hp ) ; <S2SV_EndBug> } } }
","<S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> nmvc ; const <S2SV_ModStart> . mv ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_joint_tree , <S2SV_ModStart> -> sign = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> sign ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class_tree , <S2SV_ModStart> classes ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class0_tree , <S2SV_ModStart> j ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> ++ j ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , <S2SV_ModStart> ] ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , <S2SV_ModStart> -> class0_hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> -> hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp ->
",CWE-119
379,"CWE-835 static void urlParsePostBody ( struct URL * url , const struct HttpConnection * http , const char * buf , int len ) { struct HashMap contentType ; initHashMap ( & contentType , urlDestroyHashMapEntry , NULL ) ; const char * ctHeader = getFromHashMap ( & http -> header , ""content-type"" ) ; urlParseHeaderLine ( & contentType , ctHeader , ctHeader ? strlen ( ctHeader ) : 0 ) ; if ( getRefFromHashMap ( & contentType , ""application/x-www-form-urlencoded"" ) ) { urlParseQueryString ( & url -> args , buf , len ) ; } else if ( getRefFromHashMap ( & contentType , ""multipart/form-data"" ) ) { const char * boundary = getFromHashMap ( & contentType , ""boundary"" ) ; if ( boundary && * boundary ) { const char * lastPart = NULL ; for ( const char * part = buf ; len > 0 ; ) { const char * ptr ; if ( ( part == buf && ( ptr = urlMemstr ( part , len , ""--"" ) ) != NULL ) || ( ptr = urlMemstr ( part , len , ""\\r\\n--"" ) ) != NULL ) { len -= ptr - part + ( part == buf ? 2 : 4 ) ; part = ptr + ( part == buf ? 2 : 4 ) ; if ( ! urlMemcmp ( part , len , boundary ) ) { int i = strlen ( boundary ) ; len -= i ; part += i ; if ( ! urlMemcmp ( part , len , ""\\r\\n"" ) ) { len -= 2 ; part += 2 ; if ( lastPart ) { urlParsePart ( url , lastPart , ptr - lastPart ) ; } else { if ( ptr != buf ) { info ( ""[http]<S2SV_blank>Ignoring<S2SV_blank>prologue<S2SV_blank>before<S2SV_blank>\\""multipart/form-data\\""!"" ) ; } } lastPart = part ; } else if ( ! urlMemcmp ( part , len , ""--\\r\\n"" ) ) { len -= 4 ; part += 4 ; urlParsePart ( url , lastPart , ptr - lastPart ) ; lastPart = NULL ; if ( len > 0 ) { info ( ""[http]<S2SV_blank>Ignoring<S2SV_blank>epilogue<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>\\""multipart/"" ""form-data\\""!"" ) ; } } } } <S2SV_StartBug> } <S2SV_EndBug> if ( lastPart ) { <S2SV_StartBug> warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>final<S2SV_blank>\\""boundary\\""<S2SV_blank>for<S2SV_blank>\\""multipart/form-data\\""!"" ) ; <S2SV_EndBug> } } else { warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>\\""boundary\\""<S2SV_blank>information<S2SV_blank>for<S2SV_blank>\\""multipart/form-data\\""!"" ) ; } } destroyHashMap ( & contentType ) ; }
","<S2SV_ModStart> } } } else <S2SV_ModEnd> { warn ( <S2SV_ModStart> { warn ( ""[http]<S2SV_blank>Ignorning<S2SV_blank>broken<S2SV_blank>multipart/form-data"" ) ; break ; } } if ( lastPart ) { warn (
",CWE-835
380,"CWE-20 error_t rawSocketSendIpPacket ( Socket * socket , const SocketMsg * message , uint_t flags ) { error_t error ; size_t offset ; NetBuffer * buffer ; NetInterface * interface ; IpPseudoHeader pseudoHeader ; NetTxAncillary ancillary ; <S2SV_StartBug> interface = socket -> interface ; <S2SV_EndBug> buffer = ipAllocBuffer ( 0 , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; do { error = netBufferAppend ( buffer , message -> data , message -> length ) ; if ( error ) break ; # if ( IPV4_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv4Addr ) ) { Ipv4Addr srcIpAddr ; error = ipv4SelectSourceAddr ( & interface , message -> destIpAddr . ipv4Addr , & srcIpAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv4PseudoHeader ) ; pseudoHeader . ipv4Data . srcAddr = srcIpAddr ; pseudoHeader . ipv4Data . destAddr = message -> destIpAddr . ipv4Addr ; pseudoHeader . ipv4Data . reserved = 0 ; pseudoHeader . ipv4Data . protocol = socket -> protocol ; pseudoHeader . ipv4Data . length = htons ( message -> length ) ; } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv6Addr ) ) { error = ipv6SelectSourceAddr ( & interface , & message -> destIpAddr . ipv6Addr , & pseudoHeader . ipv6Data . srcAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv6PseudoHeader ) ; pseudoHeader . ipv6Data . destAddr = message -> destIpAddr . ipv6Addr ; pseudoHeader . ipv6Data . length = htonl ( message -> length ) ; pseudoHeader . ipv6Data . reserved [ 0 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 1 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 2 ] = 0 ; pseudoHeader . ipv6Data . nextHeader = socket -> protocol ; } else # endif { error = ERROR_FAILURE ; break ; } ancillary = NET_DEFAULT_TX_ANCILLARY ; if ( message -> ttl != 0 ) { ancillary . ttl = message -> ttl ; } else if ( ipIsMulticastAddr ( & message -> destIpAddr ) ) { ancillary . ttl = socket -> multicastTtl ; } else { ancillary . ttl = socket -> ttl ; } if ( flags & SOCKET_FLAG_DONT_ROUTE ) { ancillary . dontRoute = TRUE ; } # if ( IP_DIFF_SERV_SUPPORT == ENABLED ) ancillary . dscp = socket -> dscp ; # endif # if ( ETH_SUPPORT == ENABLED ) ancillary . srcMacAddr = message -> srcMacAddr ; ancillary . destMacAddr = message -> destMacAddr ; # endif # if ( ETH_VLAN_SUPPORT == ENABLED ) ancillary . vlanPcp = socket -> vlanPcp ; ancillary . vlanDei = socket -> vlanDei ; # endif # if ( ETH_VMAN_SUPPORT == ENABLED ) ancillary . vmanPcp = socket -> vmanPcp ; ancillary . vmanDei = socket -> vmanDei ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) ancillary . port = message -> switchPort ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) ancillary . timestampId = message -> timestampId ; # endif error = ipSendDatagram ( interface , & pseudoHeader , buffer , offset , & ancillary ) ; if ( error ) break ; } while ( 0 ) ; netBufferFree ( buffer ) ; return error ; }
","<S2SV_ModStart> NetTxAncillary ancillary ; if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModEnd> buffer = ipAllocBuffer
",CWE-20
381,"CWE-119 static void fill_variance_tree ( void * data , BLOCK_SIZE bsize ) { <S2SV_StartBug> variance_node node ; <S2SV_EndBug> tree_to_node ( data , bsize , & node ) ; sum_2_variances ( node . split [ 0 ] , node . split [ 1 ] , & node . part_variances -> horz [ 0 ] ) ; sum_2_variances ( node . split [ 2 ] , node . split [ 3 ] , & node . part_variances -> horz [ 1 ] ) ; sum_2_variances ( node . split [ 0 ] , node . split [ 2 ] , & node . part_variances -> vert [ 0 ] ) ; sum_2_variances ( node . split [ 1 ] , node . split [ 3 ] , & node . part_variances -> vert [ 1 ] ) ; sum_2_variances ( & node . part_variances -> vert [ 0 ] , & node . part_variances -> vert [ 1 ] , & node . part_variances -> none ) ; }
","<S2SV_ModStart> { variance_node node ; memset ( & node , 0 , sizeof ( node ) )
",CWE-119
382,"CWE-119 int vp9_prob_diff_update_savings_search_model ( const unsigned int * ct , <S2SV_StartBug> const vp9_prob * oldp , <S2SV_EndBug> vp9_prob * bestp , <S2SV_StartBug> vp9_prob upd ) { <S2SV_EndBug> int i , old_b , new_b , update_b , savings , bestsavings , step ; int newp ; <S2SV_StartBug> vp9_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ; <S2SV_EndBug> vp9_model_to_full_probs ( oldp , oldplist ) ; <S2SV_StartBug> vpx_memcpy ( newplist , oldp , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ; <S2SV_EndBug> for ( i = UNCONSTRAINED_NODES , old_b = 0 ; i < ENTROPY_NODES ; ++ i ) old_b += cost_branch256 ( ct + 2 * i , oldplist [ i ] ) ; old_b += cost_branch256 ( ct + 2 * PIVOT_NODE , oldplist [ PIVOT_NODE ] ) ; bestsavings = 0 ; bestnewp = oldp [ PIVOT_NODE ] ; <S2SV_StartBug> step = ( * bestp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ; <S2SV_EndBug> for ( newp = * bestp ; newp != oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } <S2SV_StartBug> * bestp = bestnewp ; <S2SV_EndBug> return bestsavings ; }
","<S2SV_ModStart> ct , const vpx_prob * oldp , vpx_prob <S2SV_ModEnd> * bestp , <S2SV_ModStart> * bestp , vpx_prob upd , int stepsize ) { int <S2SV_ModEnd> i , old_b <S2SV_ModStart> int newp ; vpx_prob <S2SV_ModEnd> bestnewp , newplist <S2SV_ModStart> oldplist ) ; memcpy <S2SV_ModEnd> ( newplist , <S2SV_ModStart> , sizeof ( vpx_prob <S2SV_ModEnd> ) * UNCONSTRAINED_NODES <S2SV_ModStart> PIVOT_NODE ] ; if ( * bestp > oldp [ PIVOT_NODE ] ) { step = - stepsize ; for ( newp = * bestp ; newp > <S2SV_ModEnd> oldp [ PIVOT_NODE <S2SV_ModStart> ; } } } else { step = stepsize ; for ( newp = * bestp ; newp < oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } } * bestp = bestnewp <S2SV_ModEnd> ; return bestsavings
",CWE-119
383,"CWE-22 <S2SV_StartBug> static int target_xcopy_locate_se_dev_e4 ( const unsigned char * dev_wwn , <S2SV_EndBug> <S2SV_StartBug> struct se_device * * found_dev ) <S2SV_EndBug> { <S2SV_StartBug> struct xcopy_dev_search_info info ; <S2SV_EndBug> int ret ; memset ( & info , 0 , sizeof ( info ) ) ; info . dev_wwn = dev_wwn ; ret = target_for_each_device ( target_xcopy_locate_se_dev_e4_iter , & info ) ; if ( ret == 1 ) { * found_dev = info . found_dev ; return 0 ; <S2SV_StartBug> } else { <S2SV_EndBug> pr_debug_ratelimited ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\n"" ) ; return - EINVAL ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> int target_xcopy_locate_se_dev_e4 ( struct se_session * sess , <S2SV_ModStart> se_device * * _found_dev , struct percpu_ref * * _found_lun_ref <S2SV_ModEnd> ) { struct <S2SV_ModStart> ) { struct se_dev_entry * deve ; struct se_node_acl * nacl ; struct se_lun * this_lun = NULL ; struct se_device * found_dev = NULL ; if ( ! sess ) goto err_out ; pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>searching<S2SV_blank>for:<S2SV_blank>%*ph\\n"" , XCOPY_NAA_IEEE_REGEX_LEN , dev_wwn ) ; nacl = sess -> se_node_acl ; rcu_read_lock ( ) ; hlist_for_each_entry_rcu ( deve , & nacl -> lun_entry_hlist , link ) { struct se_device * this_dev ; int rc ; this_lun = rcu_dereference ( deve -> se_lun ) ; this_dev = rcu_dereference_raw ( this_lun -> lun_se_dev ) ; rc = target_xcopy_locate_se_dev_e4_iter ( this_dev , dev_wwn ) ; if ( rc ) { if ( percpu_ref_tryget_live ( & this_lun -> lun_ref ) ) found_dev = this_dev ; break ; } } rcu_read_unlock ( ) ; if ( found_dev == NULL ) goto err_out ; pr_debug ( ""lun_ref<S2SV_blank>held<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\n"" , found_dev , & found_dev -> dev_group ) ; * _found_dev = found_dev ; * _found_lun_ref = & this_lun -> lun_ref <S2SV_ModEnd> ; return 0 <S2SV_ModStart> return 0 ; err_out : <S2SV_ModEnd> pr_debug_ratelimited ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\n"" <S2SV_ModStart> EINVAL ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",CWE-22
385,"CWE-787 static void ReadReason ( rfbClient * client ) { uint32_t reasonLen ; char * reason ; if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return ; reasonLen = rfbClientSwap32IfLE ( reasonLen ) ; <S2SV_StartBug> reason = malloc ( ( uint64_t ) reasonLen + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) { free ( reason ) ; return ; } reason [ reasonLen ] = 0 ; rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed:<S2SV_blank>%s\\n"" , reason ) ; free ( reason ) ; }
","<S2SV_ModStart> reasonLen ) ; if ( reasonLen > 1 << 20 ) { rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed,<S2SV_blank>but<S2SV_blank>sent<S2SV_blank>reason<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>exceeds<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB"" , ( unsigned int ) reasonLen ) ; return ; } <S2SV_ModStart> = malloc ( <S2SV_ModEnd> reasonLen + 1
",CWE-787
389,"CWE-125 static int validate_node ( node * tree ) { int type = TYPE ( tree ) ; int nch = NCH ( tree ) ; dfa * nt_dfa ; state * dfa_state ; int pos , arc ; assert ( ISNONTERMINAL ( type ) ) ; type -= NT_OFFSET ; if ( type >= _PyParser_Grammar . g_ndfas ) { PyErr_Format ( parser_error , ""Unrecognized<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d."" , TYPE ( tree ) ) ; return 0 ; } nt_dfa = & _PyParser_Grammar . g_dfa [ type ] ; REQ ( tree , nt_dfa -> d_type ) ; dfa_state = & nt_dfa -> d_state [ nt_dfa -> d_initial ] ; for ( pos = 0 ; pos < nch ; ++ pos ) { node * ch = CHILD ( tree , pos ) ; int ch_type = TYPE ( ch ) ; <S2SV_StartBug> for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { <S2SV_EndBug> short a_label = dfa_state -> s_arc [ arc ] . a_lbl ; assert ( a_label < _PyParser_Grammar . g_ll . ll_nlabels ) ; if ( _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type == ch_type ) { if ( ISNONTERMINAL ( ch_type ) && ! validate_node ( ch ) ) return 0 ; dfa_state = & nt_dfa -> d_state [ dfa_state -> s_arc [ arc ] . a_arrow ] ; goto arc_found ; } } { short a_label = dfa_state -> s_arc -> a_lbl ; int next_type ; if ( ! a_label ) goto illegal_num_children ; next_type = _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type ; if ( ISNONTERMINAL ( next_type ) ) PyErr_Format ( parser_error , ""Expected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d."" , next_type , ch_type ) ; else PyErr_Format ( parser_error , ""Illegal<S2SV_blank>terminal:<S2SV_blank>expected<S2SV_blank>%s."" , _PyParser_TokenNames [ next_type ] ) ; return 0 ; } arc_found : continue ; } for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { if ( ! dfa_state -> s_arc [ arc ] . a_lbl ) { return 1 ; } } illegal_num_children : PyErr_Format ( parser_error , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>children<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>node."" , nt_dfa -> d_name ) ; return 0 ; }
","<S2SV_ModStart> ch ) ; if ( ch_type == suite && TYPE ( tree ) == funcdef ) { ch_type = func_body_suite ; }
",CWE-125
390,"CWE-189 static VarBit * bit_catenate ( VarBit * arg1 , VarBit * arg2 ) { VarBit * result ; int bitlen1 , bitlen2 , bytelen , bit1pad , bit2shift ; bits8 * pr , * pa ; bitlen1 = VARBITLEN ( arg1 ) ; <S2SV_StartBug> bitlen2 = VARBITLEN ( arg2 ) ; <S2SV_EndBug> bytelen = VARBITTOTALLEN ( bitlen1 + bitlen2 ) ; result = ( VarBit * ) palloc ( bytelen ) ; SET_VARSIZE ( result , bytelen ) ; VARBITLEN ( result ) = bitlen1 + bitlen2 ; memcpy ( VARBITS ( result ) , VARBITS ( arg1 ) , VARBITBYTES ( arg1 ) ) ; bit1pad = VARBITPAD ( arg1 ) ; if ( bit1pad == 0 ) { memcpy ( VARBITS ( result ) + VARBITBYTES ( arg1 ) , VARBITS ( arg2 ) , VARBITBYTES ( arg2 ) ) ; } else if ( bitlen2 > 0 ) { bit2shift = BITS_PER_BYTE - bit1pad ; pr = VARBITS ( result ) + VARBITBYTES ( arg1 ) - 1 ; for ( pa = VARBITS ( arg2 ) ; pa < VARBITEND ( arg2 ) ; pa ++ ) { * pr |= ( ( * pa >> bit2shift ) & BITMASK ) ; pr ++ ; if ( pr < VARBITEND ( result ) ) * pr = ( * pa << bit1pad ) & BITMASK ; } } return result ; }
","<S2SV_ModStart> VARBITLEN ( arg2 ) ; if ( bitlen1 > VARBITMAXLEN - bitlen2 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) )
",CWE-189
391,"CWE-476 static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> alg -> cra_rng . seedsize : ralg -> seedsize ; }
","<S2SV_ModStart> ) ; return <S2SV_ModEnd> ralg -> seedsize
",CWE-476
395,"CWE-400 static void balloon_process ( struct work_struct * work ) { enum bp_state state = BP_DONE ; long credit ; do { mutex_lock ( & balloon_mutex ) ; credit = current_credit ( ) ; if ( credit > 0 ) { if ( balloon_is_inflated ( ) ) state = increase_reservation ( credit ) ; else state = reserve_additional_memory ( ) ; } <S2SV_StartBug> if ( credit < 0 ) <S2SV_EndBug> <S2SV_StartBug> state = decrease_reservation ( - credit , GFP_BALLOON ) ; <S2SV_EndBug> state = update_schedule ( state ) ; mutex_unlock ( & balloon_mutex ) ; cond_resched ( ) ; } while ( credit && state == BP_DONE ) ; if ( state == BP_EAGAIN ) schedule_delayed_work ( & balloon_worker , balloon_stats . schedule_delay * HZ ) ; }
","<S2SV_ModStart> < 0 ) { long n_pages ; n_pages = min ( - credit , si_mem_available ( ) ) ; <S2SV_ModStart> = decrease_reservation ( n_pages <S2SV_ModEnd> , GFP_BALLOON ) <S2SV_ModStart> GFP_BALLOON ) ; if ( state == BP_DONE && n_pages != - credit && n_pages < totalreserve_pages ) state = BP_EAGAIN ; }
",CWE-400
396,"CWE-000 WORD32 ih264d_parse_sps ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD8 i ; dec_seq_params_t * ps_seq = NULL ; UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ; UWORD16 i2_max_frm_num ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD8 u1_frm , uc_constraint_set0_flag , uc_constraint_set1_flag ; UWORD32 u4_temp ; WORD32 pic_height_in_map_units_minus1 = 0 ; UWORD32 u2_pic_wd = 0 ; UWORD32 u2_pic_ht = 0 ; UWORD32 u2_frm_wd_y = 0 ; UWORD32 u2_frm_ht_y = 0 ; UWORD32 u2_frm_wd_uv = 0 ; UWORD32 u2_frm_ht_uv = 0 ; UWORD32 u2_crop_offset_y = 0 ; UWORD32 u2_crop_offset_uv = 0 ; WORD32 ret ; WORD32 i4_i ; UWORD8 u1_frame_cropping_flag , u1_frame_cropping_rect_left_ofst , u1_frame_cropping_rect_right_ofst , u1_frame_cropping_rect_top_ofst , u1_frame_cropping_rect_bottom_ofst ; SWITCHONTRACE ; u1_profile_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>profile_idc"" , u1_profile_idc ) ; uc_constraint_set0_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; uc_constraint_set1_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bits_h264 ( ps_bitstrm , 5 ) ; if ( ( u1_profile_idc != MAIN_PROFILE_IDC ) && ( u1_profile_idc != BASE_PROFILE_IDC ) && ( u1_profile_idc != HIGH_PROFILE_IDC ) ) { if ( ( u1_profile_idc != EXTENDED_PROFILE_IDC ) || ( ( uc_constraint_set1_flag != 1 ) && ( uc_constraint_set0_flag != 1 ) ) ) { return ( ERROR_FEATURE_UNAVAIL ) ; } } u1_level_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>u4_level_idc"" , u1_level_idc ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_SEQ_SET_ID ) return ERROR_INV_SPS_PPS_T ; u1_seq_parameter_set_id = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>seq_parameter_set_id"" , u1_seq_parameter_set_id ) ; ps_seq = ps_dec -> pv_scratch_sps_pps ; * ps_seq = ps_dec -> ps_sps [ u1_seq_parameter_set_id ] ; if ( NULL == ps_dec -> ps_cur_sps ) ps_dec -> ps_cur_sps = ps_seq ; ps_seq -> u1_profile_idc = u1_profile_idc ; ps_seq -> u1_level_idc = u1_level_idc ; ps_seq -> u1_seq_parameter_set_id = u1_seq_parameter_set_id ; ps_seq -> i4_chroma_format_idc = 1 ; ps_seq -> i4_bit_depth_luma_minus8 = 0 ; ps_seq -> i4_bit_depth_chroma_minus8 = 0 ; ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = 0 ; ps_seq -> i4_seq_scaling_matrix_present_flag = 0 ; if ( u1_profile_idc == HIGH_PROFILE_IDC ) { ps_seq -> i4_chroma_format_idc = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_chroma_format_idc != 1 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_luma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_luma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_chroma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_chroma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_qpprime_y_zero_transform_bypass_flag != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_seq_scaling_matrix_present_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_seq_scaling_matrix_present_flag ) { for ( i4_i = 0 ; i4_i < 8 ; i4_i ++ ) { ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] = ih264d_get_bit_h264 ( ps_bitstrm ) ; ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] = 0 ; if ( ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] ) { if ( i4_i < 6 ) { ih264d_scaling_list ( ps_seq -> i2_scalinglist4x4 [ i4_i ] , 16 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } else { ih264d_scaling_list ( ps_seq -> i2_scalinglist8x8 [ i4_i - 6 ] , 64 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } } } } } u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_FRAME_NUM ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_bits_in_frm_num = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>log2_max_frame_num_minus4"" , ( ps_seq -> u1_bits_in_frm_num - 4 ) ) ; i2_max_frm_num = ( 1 << ( ps_seq -> u1_bits_in_frm_num ) ) ; ps_seq -> u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1 ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_PIC_ORDER_CNT_TYPE ) { return ERROR_INV_POC_TYPE_T ; } ps_seq -> u1_pic_order_cnt_type = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>pic_order_cnt_type"" , ps_seq -> u1_pic_order_cnt_type ) ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = 1 ; if ( ps_seq -> u1_pic_order_cnt_type == 0 ) { u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_POC_LSB ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus = u4_temp ; ps_seq -> i4_max_pic_order_cntLsb = ( 1 << u4_temp ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>log2_max_pic_order_cnt_lsb_minus4"" , ( u4_temp - 4 ) ) ; } else if ( ps_seq -> u1_pic_order_cnt_type == 1 ) { ps_seq -> u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>delta_pic_order_always_zero_flag"" , ps_seq -> u1_delta_pic_order_always_zero_flag ) ; ps_seq -> i4_ofst_for_non_ref_pic = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_non_ref_pic"" , ps_seq -> i4_ofst_for_non_ref_pic ) ; ps_seq -> i4_ofst_for_top_to_bottom_field = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_top_to_bottom_field"" , ps_seq -> i4_ofst_for_top_to_bottom_field ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 255 ) return ERROR_INV_SPS_PPS_T ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>num_ref_frames_in_pic_order_cnt_cycle"" , ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ) ; for ( i = 0 ; i < ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ; i ++ ) { ps_seq -> i4_ofst_for_ref_frame [ i ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_ref_frame"" , ps_seq -> i4_ofst_for_ref_frame [ i ] ) ; } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( u4_temp > H264_MAX_REF_PICS ) ) { return ERROR_NUM_REF ; } ps_seq -> u1_num_ref_frames = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>num_ref_frames"" , ps_seq -> u1_num_ref_frames ) ; ps_seq -> u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>gaps_in_frame_num_value_allowed_flag"" , ps_seq -> u1_gaps_in_frame_num_value_allowed_flag ) ; ps_seq -> u2_frm_wd_in_mbs = 1 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>pic_width_in_mbs_minus1"" , ps_seq -> u2_frm_wd_in_mbs - 1 ) ; u2_pic_wd = ( ps_seq -> u2_frm_wd_in_mbs << 4 ) ; pic_height_in_map_units_minus1 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_seq -> u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1 ; u2_pic_ht = ( ps_seq -> u2_frm_ht_in_mbs << 4 ) ; ps_seq -> u2_max_mb_addr = ( ps_seq -> u2_frm_wd_in_mbs * ps_seq -> u2_frm_ht_in_mbs ) - 1 ; ps_seq -> u2_total_num_of_mbs = ps_seq -> u2_max_mb_addr + 1 ; ps_seq -> u1_level_idc = ih264d_correct_level_idc ( u1_level_idc , ps_seq -> u2_total_num_of_mbs ) ; u1_frm = ih264d_get_bit_h264 ( ps_bitstrm ) ; ps_seq -> u1_frame_mbs_only_flag = u1_frm ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_mbs_only_flag"" , u1_frm ) ; if ( ! u1_frm ) { u2_pic_ht <<= 1 ; ps_seq -> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>mb_adaptive_frame_field_flag"" , ps_seq -> u1_mb_aff_flag ) ; } else ps_seq -> u1_mb_aff_flag = 0 ; ps_seq -> u1_direct_8x8_inference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>direct_8x8_inference_flag"" , ps_seq -> u1_direct_8x8_inference_flag ) ; u1_frame_cropping_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_flag"" , u1_frame_cropping_flag ) ; if ( u1_frame_cropping_flag ) { u1_frame_cropping_rect_left_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_left_offset"" , u1_frame_cropping_rect_left_ofst ) ; u1_frame_cropping_rect_right_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_right_offset"" , u1_frame_cropping_rect_right_ofst ) ; u1_frame_cropping_rect_top_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_top_offset"" , u1_frame_cropping_rect_top_ofst ) ; u1_frame_cropping_rect_bottom_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_bottom_offset"" , u1_frame_cropping_rect_bottom_ofst ) ; } ps_seq -> u1_vui_parameters_present_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>vui_parameters_present_flag"" , ps_seq -> u1_vui_parameters_present_flag ) ; u2_frm_wd_y = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_Y_H << 1 ) ; if ( 1 == ps_dec -> u4_share_disp_buf ) { if ( ps_dec -> u4_app_disp_width > u2_frm_wd_y ) u2_frm_wd_y = ps_dec -> u4_app_disp_width ; } u2_frm_ht_y = u2_pic_ht + ( UWORD8 ) ( PAD_LEN_Y_V << 2 ) ; u2_frm_wd_uv = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_UV_H << 2 ) ; u2_frm_wd_uv = MAX ( u2_frm_wd_uv , u2_frm_wd_y ) ; u2_frm_ht_uv = ( u2_pic_ht >> 1 ) + ( UWORD8 ) ( PAD_LEN_UV_V << 2 ) ; u2_frm_ht_uv = MAX ( u2_frm_ht_uv , ( u2_frm_ht_y >> 1 ) ) ; { UWORD16 u2_rgt_ofst = 0 ; UWORD16 u2_lft_ofst = 0 ; UWORD16 u2_top_ofst = 0 ; UWORD16 u2_btm_ofst = 0 ; UWORD8 u1_frm_mbs_flag ; UWORD8 u1_vert_mult_factor ; WORD32 i4_cropped_ht , i4_cropped_wd ; if ( u1_frame_cropping_flag ) { u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1 ; u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1 ; u1_frm_mbs_flag = ( 1 == ps_seq -> u1_frame_mbs_only_flag ) ; u1_vert_mult_factor = ( 2 - u1_frm_mbs_flag ) ; u2_btm_ofst = ( u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor ) ; u2_top_ofst = ( u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor ) ; } u2_crop_offset_y = ( u2_frm_wd_y * u2_top_ofst ) + ( u2_lft_ofst ) ; u2_crop_offset_uv = ( u2_frm_wd_uv * ( u2_top_ofst >> 1 ) ) + ( u2_lft_ofst >> 1 ) * YUV420SP_FACTOR ; i4_cropped_ht = u2_pic_ht - ( u2_btm_ofst + u2_top_ofst ) ; i4_cropped_wd = u2_pic_wd - ( u2_rgt_ofst + u2_lft_ofst ) ; if ( ( i4_cropped_ht < MB_SIZE ) || ( i4_cropped_wd < MB_SIZE ) ) { return ERROR_INV_SPS_PPS_T ; } if ( ( 3 == ps_dec -> i4_header_decoded ) && ( ps_dec -> u2_pic_wd != u2_pic_wd ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( 3 == ps_dec -> i4_header_decoded ) && ( ps_dec -> u2_pic_ht != u2_pic_ht ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( u2_pic_wd > H264_MAX_FRAME_WIDTH ) || ( u2_pic_ht > H264_MAX_FRAME_HEIGHT ) ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } <S2SV_StartBug> ps_dec -> u2_disp_height = i4_cropped_ht ; <S2SV_EndBug> ps_dec -> u2_disp_width = i4_cropped_wd ; } if ( 1 == ps_seq -> u1_vui_parameters_present_flag ) { ret = ih264d_parse_vui_parametres ( & ps_seq -> s_vui , ps_bitstrm ) ; if ( ret != OK ) return ret ; } ps_dec -> u2_pic_wd = u2_pic_wd ; ps_dec -> u2_pic_ht = u2_pic_ht ; ps_dec -> u2_frm_wd_y = u2_frm_wd_y ; ps_dec -> u2_frm_ht_y = u2_frm_ht_y ; ps_dec -> u2_frm_wd_uv = u2_frm_wd_uv ; ps_dec -> u2_frm_ht_uv = u2_frm_ht_uv ; ps_dec -> s_pad_mgr . u1_pad_len_y_v = ( UWORD8 ) ( PAD_LEN_Y_V << ( 1 - u1_frm ) ) ; ps_dec -> s_pad_mgr . u1_pad_len_cr_v = ( UWORD8 ) ( PAD_LEN_UV_V << ( 1 - u1_frm ) ) ; ps_dec -> u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; ps_dec -> u2_frm_ht_in_mbs = ps_seq -> u2_frm_ht_in_mbs ; ps_dec -> u2_crop_offset_y = u2_crop_offset_y ; ps_dec -> u2_crop_offset_uv = u2_crop_offset_uv ; if ( ps_bitstrm -> u4_ofst > ps_bitstrm -> u4_max_ofst ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_is_valid = TRUE ; ps_dec -> ps_sps [ u1_seq_parameter_set_id ] = * ps_seq ; return OK ; }
","<S2SV_ModStart> IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; }
",CWE-000
398,"CWE-119 int main ( int argc , char * * argv ) { u8 * byteStrmStart ; u8 * byteStrm ; u32 strmLen ; u32 picSize ; H264SwDecInst decInst ; H264SwDecRet ret ; H264SwDecInput decInput ; H264SwDecOutput decOutput ; H264SwDecPicture decPicture ; H264SwDecInfo decInfo ; u32 picNumber ; FILE * finput ; FILE * foutput ; if ( argc < 2 ) { printf ( ""Usage:<S2SV_blank>%s<S2SV_blank>file.h264\\n"" , argv [ 0 ] ) ; return - 1 ; } foutput = fopen ( ""out.yuv"" , ""wb"" ) ; if ( foutput == NULL ) { printf ( ""UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>OUTPUT<S2SV_blank>FILE\\n"" ) ; return - 1 ; } finput = fopen ( argv [ argc - 1 ] , ""rb"" ) ; if ( finput == NULL ) { printf ( ""UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>INPUT<S2SV_blank>FILE\\n"" ) ; return - 1 ; } fseek ( finput , 0L , SEEK_END ) ; strmLen = ( u32 ) ftell ( finput ) ; rewind ( finput ) ; <S2SV_StartBug> byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ; <S2SV_EndBug> if ( byteStrm == NULL ) { printf ( ""UNABLE<S2SV_blank>TO<S2SV_blank>ALLOCATE<S2SV_blank>MEMORY\\n"" ) ; return - 1 ; } fread ( byteStrm , sizeof ( u8 ) , strmLen , finput ) ; fclose ( finput ) ; ret = H264SwDecInit ( & decInst , 0 ) ; if ( ret != H264SWDEC_OK ) { printf ( ""DECODER<S2SV_blank>INITIALIZATION<S2SV_blank>FAILED\\n"" ) ; return - 1 ; } decInput . pStream = byteStrmStart ; decInput . dataLen = strmLen ; decInput . intraConcealmentMethod = 0 ; picNumber = 0 ; do { ret = H264SwDecDecode ( decInst , & decInput , & decOutput ) ; switch ( ret ) { case H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY : ret = H264SwDecGetInfo ( decInst , & decInfo ) ; if ( ret != H264SWDEC_OK ) return - 1 ; picSize = decInfo . picWidth * decInfo . picHeight ; picSize = ( 3 * picSize ) / 2 ; printf ( ""Width<S2SV_blank>%d<S2SV_blank>Height<S2SV_blank>%d\\n"" , decInfo . picWidth , decInfo . picHeight ) ; decInput . dataLen -= ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; decInput . pStream = decOutput . pStrmCurrPos ; break ; case H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY : case H264SWDEC_PIC_RDY : decInput . dataLen -= ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; decInput . pStream = decOutput . pStrmCurrPos ; while ( H264SwDecNextPicture ( decInst , & decPicture , 0 ) == H264SWDEC_PIC_RDY ) { picNumber ++ ; printf ( ""PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n"" , picNumber , decPicture . isIdrPicture ? ""IDR"" : ""NON-IDR"" , decPicture . nbrOfErrMBs ) ; fflush ( stdout ) ; WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , picSize ) ; } break ; case H264SWDEC_EVALUATION_LIMIT_EXCEEDED : printf ( ""EVALUATION<S2SV_blank>LIMIT<S2SV_blank>REACHED\\n"" ) ; goto end ; default : printf ( ""UNRECOVERABLE<S2SV_blank>ERROR\\n"" ) ; return - 1 ; } } while ( decInput . dataLen > 0 ) ; end : while ( H264SwDecNextPicture ( decInst , & decPicture , 1 ) == H264SWDEC_PIC_RDY ) { picNumber ++ ; printf ( ""PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n"" , picNumber , decPicture . isIdrPicture ? ""IDR"" : ""NON-IDR"" , decPicture . nbrOfErrMBs ) ; fflush ( stdout ) ; WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , picSize ) ; } H264SwDecRelease ( decInst ) ; fclose ( foutput ) ; free ( byteStrmStart ) ; return 0 ; }
","<S2SV_ModStart> ( u8 ) , <S2SV_ModEnd> strmLen ) ;
",CWE-119
399,"CWE-119 <S2SV_StartBug> static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree , <S2SV_EndBug> <S2SV_StartBug> int16_t extra , uint8_t token , <S2SV_EndBug> uint8_t skip_eob_node , unsigned int * counts ) { ( * t ) -> token = token ; ( * t ) -> extra = extra ; ( * t ) -> context_tree = context_tree ; ( * t ) -> skip_eob_node = skip_eob_node ; ( * t ) ++ ; ++ counts [ token ] ; }
","<S2SV_ModStart> t , const vpx_prob <S2SV_ModEnd> * context_tree , <S2SV_ModStart> * context_tree , int32_t <S2SV_ModEnd> extra , uint8_t
",CWE-119
400,"CWE-190 void jas_matrix_setall ( jas_matrix_t * matrix , jas_seqent_t val ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = val ; } } } }
","<S2SV_ModStart> val ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
",CWE-190
404,"CWE-119 static int64_t encode_inter_mb_segment ( VP9_COMP * cpi , MACROBLOCK * x , int64_t best_yrd , int i , int * labelyrate , int64_t * distortion , int64_t * sse , ENTROPY_CONTEXT * ta , ENTROPY_CONTEXT * tl , int mi_row , int mi_col ) { int k ; MACROBLOCKD * xd = & x -> e_mbd ; struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ; struct macroblock_plane * const p = & x -> plane [ 0 ] ; MODE_INFO * const mi = xd -> mi [ 0 ] ; const BLOCK_SIZE plane_bsize = get_plane_block_size ( mi -> mbmi . sb_type , pd ) ; const int width = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ; const int height = 4 * num_4x4_blocks_high_lookup [ plane_bsize ] ; int idx , idy ; <S2SV_StartBug> const uint8_t * const src = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> p -> src . stride ) ] ; <S2SV_StartBug> uint8_t * const dst = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> pd -> dst . stride ) ] ; int64_t thisdistortion = 0 , thissse = 0 ; int thisrate = 0 , ref ; const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; const int is_compound = has_second_ref ( & mi -> mbmi ) ; <S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ; <S2SV_EndBug> for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) { <S2SV_StartBug> const uint8_t * pre = & pd -> pre [ ref ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> pd -> pre [ ref ] . stride ) ] ; <S2SV_StartBug> vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , <S2SV_EndBug> dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , <S2SV_StartBug> & xd -> block_refs [ ref ] -> sf , width , height , ref , <S2SV_EndBug> kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , <S2SV_StartBug> mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; <S2SV_EndBug> } <S2SV_StartBug> vp9_subtract_block ( height , width , <S2SV_EndBug> raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , <S2SV_StartBug> dst , pd -> dst . stride ) ; <S2SV_EndBug> k = i ; for ( idy = 0 ; idy < height / 4 ; ++ idy ) { for ( idx = 0 ; idx < width / 4 ; ++ idx ) { int64_t ssz , rd , rd1 , rd2 ; <S2SV_StartBug> int16_t * coeff ; <S2SV_EndBug> k += ( idy * 2 + idx ) ; coeff = BLOCK_OFFSET ( p -> coeff , k ) ; <S2SV_StartBug> x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , <S2SV_EndBug> coeff , 8 ) ; <S2SV_StartBug> vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ; <S2SV_EndBug> thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ; <S2SV_StartBug> thissse += ssz ; <S2SV_EndBug> thisrate += cost_coeffs ( x , 0 , k , ta + ( k & 1 ) , tl + ( k >> 1 ) , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; rd1 = RDCOST ( x -> rdmult , x -> rddiv , thisrate , thisdistortion >> 2 ) ; rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , thissse >> 2 ) ; rd = MIN ( rd1 , rd2 ) ; if ( rd >= best_yrd ) return INT64_MAX ; } } * distortion = thisdistortion >> 2 ; * labelyrate = thisrate ; * sse = thissse >> 2 ; return RDCOST ( x -> rdmult , x -> rddiv , * labelyrate , * distortion ) ; }
","<S2SV_ModStart> . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> * kernel = vp9_filter_kernels [ <S2SV_ModEnd> mi -> mbmi <S2SV_ModStart> mbmi . interp_filter ] <S2SV_ModEnd> ; for ( <S2SV_ModStart> . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor <S2SV_ModEnd> ( pre , <S2SV_ModStart> , height , ref , <S2SV_ModEnd> kernel , MV_PRECISION_Q3 <S2SV_ModStart> / 2 ) , xd -> bd <S2SV_ModStart> ) ; } else { vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; } # else vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; # endif } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( height , width , vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> . stride , dst , pd -> dst . stride , xd -> bd ) ; } else { vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; } # else vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; # endif <S2SV_ModEnd> k = i <S2SV_ModStart> , rd2 ; tran_low_t <S2SV_ModEnd> * coeff ; <S2SV_ModStart> -> fwd_txm4x4 ( vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> iscan ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { thisdistortion += vp9_highbd_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz , xd -> bd ) ; } else { <S2SV_ModStart> ssz ) ; } # else thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ; # endif
",CWE-119
410,"CWE-787 GF_Err tenc_box_read ( GF_Box * s , GF_BitStream * bs ) { u8 iv_size ; GF_TrackEncryptionBox * ptr = ( GF_TrackEncryptionBox * ) s ; ISOM_DECREASE_SIZE ( ptr , 3 ) ; gf_bs_read_u8 ( bs ) ; if ( ! ptr -> version ) { gf_bs_read_u8 ( bs ) ; } else { ptr -> crypt_byte_block = gf_bs_read_int ( bs , 4 ) ; ptr -> skip_byte_block = gf_bs_read_int ( bs , 4 ) ; } ptr -> isProtected = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , 17 ) ; ptr -> key_info [ 0 ] = 0 ; ptr -> key_info [ 1 ] = 0 ; ptr -> key_info [ 2 ] = 0 ; ptr -> key_info [ 3 ] = iv_size = gf_bs_read_u8 ( bs ) ; gf_bs_read_data ( bs , ptr -> key_info + 4 , 16 ) ; if ( ! iv_size && ptr -> isProtected ) { ISOM_DECREASE_SIZE ( ptr , 1 ) ; iv_size = ptr -> key_info [ 20 ] = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , ptr -> key_info [ 20 ] ) ; <S2SV_StartBug> gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ; <S2SV_EndBug> } <S2SV_StartBug> return GF_OK ; <S2SV_EndBug> }
","<S2SV_ModStart> ] ) ; if ( ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>constant<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; ptr -> key_info [ 20 ] = 16 ; return GF_NON_COMPLIANT_BITSTREAM ; } <S2SV_ModStart> ) ; } else if ( ( iv_size != 0 ) && ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; return GF_NON_COMPLIANT_BITSTREAM ; }
",CWE-787
412,"CWE-119 WORD32 impeg2d_get_slice_pos ( dec_state_multi_core_t * ps_dec_state_multi_core ) { WORD32 u4_bits ; WORD32 i4_row ; dec_state_t * ps_dec = ps_dec_state_multi_core -> ps_dec_state [ 0 ] ; WORD32 i4_prev_row ; stream_t s_bitstrm ; WORD32 i4_start_row ; WORD32 i4_slice_bistream_ofst ; WORD32 i ; s_bitstrm = ps_dec -> s_bit_stream ; i4_prev_row = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 0 ] -> i4_start_mb_y = 0 ; ps_dec_state_multi_core -> ps_dec_state [ 1 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 2 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 3 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 0 ] -> i4_end_mb_y = ps_dec -> u2_num_vert_mb ; ps_dec_state_multi_core -> ps_dec_state [ 1 ] -> i4_end_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 2 ] -> i4_end_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 3 ] -> i4_end_mb_y = - 1 ; if ( ps_dec -> i4_num_cores == 1 ) return 0 ; impeg2_jobq_reset ( ( jobq_t * ) ps_dec -> pv_jobq ) ; i4_start_row = - 1 ; i4_slice_bistream_ofst = 0 ; while ( 1 ) { WORD32 i4_is_slice ; if ( s_bitstrm . u4_offset + START_CODE_LEN >= s_bitstrm . u4_max_offset ) { break ; } u4_bits = impeg2d_bit_stream_nxt ( & s_bitstrm , START_CODE_LEN ) ; i4_row = u4_bits & 0xFF ; i4_is_slice = ( ( ( u4_bits >> 8 ) == 0x01 ) && ( i4_row ) && ( i4_row <= ps_dec -> u2_num_vert_mb ) ) ; if ( ! i4_is_slice ) break ; i4_row -= 1 ; <S2SV_StartBug> if ( i4_prev_row != i4_row ) <S2SV_EndBug> { if ( i4_start_row != - 1 ) { job_t s_job ; IV_API_CALL_STATUS_T ret ; s_job . i2_start_mb_y = i4_start_row ; s_job . i2_end_mb_y = i4_row ; s_job . i4_cmd = CMD_PROCESS ; s_job . i4_bistream_ofst = i4_slice_bistream_ofst ; ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( ret != IV_SUCCESS ) return ret ; } i4_slice_bistream_ofst = s_bitstrm . u4_offset >> 3 ; i4_slice_bistream_ofst -= ( size_t ) s_bitstrm . pv_bs_buf & 3 ; i4_prev_row = i4_row ; i4_start_row = i4_row ; <S2SV_StartBug> } <S2SV_EndBug> impeg2d_bit_stream_flush ( & s_bitstrm , START_CODE_LEN ) ; while ( impeg2d_bit_stream_nxt ( & s_bitstrm , 24 ) != START_CODE_PREFIX ) { impeg2d_bit_stream_get ( & s_bitstrm , 8 ) ; if ( s_bitstrm . u4_offset >= s_bitstrm . u4_max_offset ) { break ; } } } { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; s_job . i2_start_mb_y = i4_start_row ; s_job . i2_end_mb_y = ps_dec -> u2_num_vert_mb ; s_job . i4_cmd = CMD_PROCESS ; s_job . i4_bistream_ofst = i4_slice_bistream_ofst ; e_ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( e_ret != IV_SUCCESS ) return e_ret ; } if ( ( NULL != ps_dec -> ps_disp_pic ) && ( ( 0 == ps_dec -> u4_share_disp_buf ) || ( IV_YUV_420P != ps_dec -> i4_chromaFormat ) ) ) { for ( i = 0 ; i < ps_dec -> u2_vertical_size ; i += 64 ) { job_t s_job ; IV_API_CALL_STATUS_T ret ; s_job . i2_start_mb_y = i ; s_job . i2_start_mb_y >>= 4 ; s_job . i2_end_mb_y = ( i + 64 ) ; s_job . i2_end_mb_y >>= 4 ; s_job . i4_cmd = CMD_FMTCONV ; s_job . i4_bistream_ofst = 0 ; ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( ret != IV_SUCCESS ) return ret ; } } impeg2_jobq_terminate ( ps_dec -> pv_jobq ) ; ps_dec -> i4_bytes_consumed = s_bitstrm . u4_offset >> 3 ; ps_dec -> i4_bytes_consumed -= ( ( size_t ) s_bitstrm . pv_bs_buf & 3 ) ; return 0 ; }
","<S2SV_ModStart> if ( i4_prev_row < <S2SV_ModEnd> i4_row ) { <S2SV_ModStart> i4_row ; } else if ( i4_prev_row > i4_row ) { android_errorWriteLog ( 0x534e4554 , ""26070014"" ) ; }
",CWE-119
413,"CWE-399 static struct page * alloc_huge_page ( struct vm_area_struct * vma , unsigned long addr , int avoid_reserve ) { <S2SV_StartBug> struct hstate * h = hstate_vma ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> struct page * page ; <S2SV_EndBug> struct address_space * mapping = vma -> vm_file -> f_mapping ; struct inode * inode = mapping -> host ; long chg ; chg = vma_needs_reservation ( h , vma , addr ) ; if ( chg < 0 ) return ERR_PTR ( - VM_FAULT_OOM ) ; if ( chg ) <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> return ERR_PTR ( - VM_FAULT_SIGBUS ) ; spin_lock ( & hugetlb_lock ) ; page = dequeue_huge_page_vma ( h , vma , addr , avoid_reserve ) ; spin_unlock ( & hugetlb_lock ) ; if ( ! page ) { page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ; if ( ! page ) { <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> return ERR_PTR ( - VM_FAULT_SIGBUS ) ; } } <S2SV_StartBug> set_page_private ( page , ( unsigned long ) mapping ) ; <S2SV_EndBug> vma_commit_reservation ( h , vma , addr ) ; return page ; }
","<S2SV_ModStart> ) { struct hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart> page * page <S2SV_ModEnd> ; long chg <S2SV_ModStart> ) if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> page ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> unsigned long ) spool <S2SV_ModEnd> ) ; vma_commit_reservation
",CWE-399
416,"CWE-125 static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) { EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , c ) ; switch ( type ) { case EVP_CTRL_INIT : cctx -> key_set = 0 ; cctx -> iv_set = 0 ; cctx -> L = 8 ; cctx -> M = 12 ; cctx -> tag_set = 0 ; cctx -> len_set = 0 ; cctx -> tls_aad_len = - 1 ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; cctx -> tls_aad_len = arg ; { uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ; <S2SV_StartBug> len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= cctx -> M ; <S2SV_EndBug> EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ; EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ; } return cctx -> M ; case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ; return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : arg = 15 - arg ; case EVP_CTRL_CCM_SET_L : if ( arg < 2 || arg > 8 ) return 0 ; cctx -> L = arg ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ; if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ; if ( ptr ) { cctx -> tag_set = 1 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; } cctx -> M = arg ; return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( ! EVP_CIPHER_CTX_encrypting ( c ) || ! cctx -> tag_set ) return 0 ; if ( ! CRYPTO_ccm128_tag ( & cctx -> ccm , ptr , ( size_t ) arg ) ) return 0 ; cctx -> tag_set = 0 ; cctx -> iv_set = 0 ; cctx -> len_set = 0 ; return 1 ; case EVP_CTRL_COPY : { EVP_CIPHER_CTX * out = ptr ; EVP_AES_CCM_CTX * cctx_out = EVP_C_DATA ( EVP_AES_CCM_CTX , out ) ; if ( cctx -> ccm . key ) { if ( cctx -> ccm . key != & cctx -> ks ) return 0 ; cctx_out -> ccm . key = & cctx_out -> ks ; } return 1 ; } default : return - 1 ; } }
","<S2SV_ModStart> 1 ] ; if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> c ) ) { if ( len < cctx -> M ) return 0 ; <S2SV_ModStart> -> M ; }
",CWE-125
417,"CWE-772 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; quantum_info = ( QuantumInfo * ) NULL ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) <S2SV_StartBug> MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_EndBug> filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( MATLAB_HDR . ObjectSize + filepos > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> 6 ) ) { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> ""ImproperImageHeader"" ) ; }
",CWE-772
418,"CWE-400 static int misaligned_fpu_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo , bufhi ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } buflo = * ( __u32 * ) & buffer ; bufhi = * ( 1 + ( __u32 * ) & buffer ) ; switch ( width_shift ) { case 2 : current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; break ; case 3 : if ( do_paired_load ) { current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = bufhi ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = buflo ; # else current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; # endif } break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_fpu_load,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } return 0 ; } else { die ( ""Misaligned<S2SV_blank>FPU<S2SV_blank>load<S2SV_blank>inside<S2SV_blank>kernel"" , regs , 0 ) ; return - 1 ; } }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",CWE-400
419,"CWE-134 int bad_format_imginfo ( char * fmt ) { <S2SV_StartBug> char * ptr ; <S2SV_EndBug> int n = 0 ; ptr = fmt ; while ( * ptr != '\\0' ) if ( * ptr ++ == '%' ) { if ( * ptr == '\\0' ) return 1 ; if ( * ptr == '%' ) ptr ++ ; else if ( * ptr == 's' || * ptr == 'S' ) { n = 1 ; ptr ++ ; } else { if ( * ptr == '<S2SV_blank>' ) ptr ++ ; while ( * ptr >= '0' && * ptr <= '9' ) ptr ++ ; if ( * ptr ++ != 'l' ) return 1 ; if ( * ptr == 'u' ) ptr ++ ; else return 1 ; n ++ ; } } return ( n != 3 ) ; }
","<S2SV_ModStart> fmt ) { return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt <S2SV_ModEnd> ) ; }
",CWE-134
420,"CWE-125 static int decoding_feof ( struct tok_state * tok ) { if ( tok -> decoding_state != STATE_NORMAL ) { return feof ( tok -> fp ) ; } else { PyObject * buf = tok -> decoding_buffer ; if ( buf == NULL ) { <S2SV_StartBug> buf = PyObject_CallObject ( tok -> decoding_readline , NULL ) ; <S2SV_EndBug> if ( buf == NULL ) { error_ret ( tok ) ; return 1 ; } else { tok -> decoding_buffer = buf ; } } return PyObject_Length ( buf ) == 0 ; } }
","<S2SV_ModStart> { buf = _PyObject_CallNoArg <S2SV_ModEnd> ( tok -> <S2SV_ModStart> tok -> decoding_readline <S2SV_ModEnd> ) ; if
",CWE-125
421,"CWE-400 static int simulate_rdhwr ( struct pt_regs * regs , unsigned int opcode ) { struct thread_info * ti = task_thread_info ( current ) ; if ( ( opcode & OPCODE ) == SPEC3 && ( opcode & FUNC ) == RDHWR ) { int rd = ( opcode & RD ) >> 11 ; int rt = ( opcode & RT ) >> 16 ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> switch ( rd ) { case 0 : regs -> regs [ rt ] = smp_processor_id ( ) ; return 0 ; case 1 : regs -> regs [ rt ] = min ( current_cpu_data . dcache . linesz , current_cpu_data . icache . linesz ) ; return 0 ; case 2 : regs -> regs [ rt ] = read_c0_count ( ) ; return 0 ; case 3 : switch ( current_cpu_data . cputype ) { case CPU_20KC : case CPU_25KF : regs -> regs [ rt ] = 1 ; break ; default : regs -> regs [ rt ] = 2 ; } return 0 ; case 29 : regs -> regs [ rt ] = ti -> tp_value ; return 0 ; default : return - 1 ; } } return - 1 ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
",CWE-400
422,"CWE-362 int cipso_v4_req_setattr ( struct request_sock * req , const struct cipso_v4_doi * doi_def , const struct netlbl_lsm_secattr * secattr ) { int ret_val = - EPERM ; unsigned char * buf = NULL ; u32 buf_len ; u32 opt_len ; <S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> struct inet_request_sock * req_inet ; buf_len = CIPSO_V4_OPT_LEN_MAX ; buf = kmalloc ( buf_len , GFP_ATOMIC ) ; if ( buf == NULL ) { ret_val = - ENOMEM ; goto req_setattr_failure ; } ret_val = cipso_v4_genopt ( buf , buf_len , doi_def , secattr ) ; if ( ret_val < 0 ) goto req_setattr_failure ; buf_len = ret_val ; opt_len = ( buf_len + 3 ) & ~ 3 ; opt = kzalloc ( sizeof ( * opt ) + opt_len , GFP_ATOMIC ) ; if ( opt == NULL ) { ret_val = - ENOMEM ; goto req_setattr_failure ; } <S2SV_StartBug> memcpy ( opt -> __data , buf , buf_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = opt_len ; <S2SV_EndBug> <S2SV_StartBug> opt -> cipso = sizeof ( struct iphdr ) ; <S2SV_EndBug> kfree ( buf ) ; buf = NULL ; req_inet = inet_rsk ( req ) ; opt = xchg ( & req_inet -> opt , opt ) ; <S2SV_StartBug> kfree ( opt ) ; <S2SV_EndBug> return 0 ; req_setattr_failure : kfree ( buf ) ; kfree ( opt ) ; return ret_val ; }
","<S2SV_ModStart> opt_len ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> opt ) ; if ( opt ) call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; return
",CWE-362
423,"CWE-78 R_API char * r_socket_http_get ( const char * url , int * code , int * rlen ) { <S2SV_StartBug> char * curl_env = r_sys_getenv ( ""R2_CURL"" ) ; <S2SV_EndBug> if ( curl_env && * curl_env ) { char * encoded_url = r_str_escape ( url ) ; char * res = r_sys_cmd_strf ( ""curl<S2SV_blank>\'%s\'"" , encoded_url ) ; free ( encoded_url ) ; if ( res ) { if ( code ) { * code = 200 ; } if ( rlen ) { * rlen = strlen ( res ) ; } <S2SV_StartBug> } <S2SV_EndBug> free ( curl_env ) ; return res ; } free ( curl_env ) ; RSocket * s ; int ssl = r_str_startswith ( url , ""https://"" ) ; char * response , * host , * path , * port = ""80"" ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } if ( code ) { * code = 0 ; } if ( rlen ) { * rlen = 0 ; } host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; eprintf ( ""r_socket_http_get:<S2SV_blank>Invalid<S2SV_blank>URI"" ) ; return NULL ; } host += 3 ; port = strchr ( host , ':' ) ; if ( ! port ) { port = ssl ? ""443"" : ""80"" ; path = host ; } else { * port ++ = 0 ; path = port ; } path = strchr ( path , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { eprintf ( ""r_socket_http_get:<S2SV_blank>Cannot<S2SV_blank>create<S2SV_blank>socket\\n"" ) ; free ( uri ) ; return NULL ; } if ( r_socket_connect_tcp ( s , host , port , 0 ) ) { r_socket_printf ( s , ""GET<S2SV_blank>/%s<S2SV_blank>HTTP/1.1\\r\\n"" ""User-Agent:<S2SV_blank>radare2<S2SV_blank>"" R2_VERSION ""\\r\\n"" ""Accept:<S2SV_blank>*/*\\r\\n"" ""Host:<S2SV_blank>%s:%s\\r\\n"" ""\\r\\n"" , path , host , port ) ; response = r_socket_http_answer ( s , code , rlen ) ; } else { eprintf ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\n"" , host , port ) ; response = NULL ; } free ( uri ) ; r_socket_free ( s ) ; return response ; }
","<S2SV_ModStart> rlen ) { return socket_http_get_recursive ( url , code , rlen , SOCKET_HTTP_MAX_REDIRECTS <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",CWE-78
426,"CWE-119 <S2SV_StartBug> int file_is_raw ( struct VpxInputContext * input ) { <S2SV_EndBug> uint8_t buf [ 32 ] ; int is_raw = 0 ; vpx_codec_stream_info_t si ; si . sz = sizeof ( si ) ; if ( fread ( buf , 1 , 32 , input -> file ) == 32 ) { int i ; if ( mem_get_le32 ( buf ) < 256 * 1024 * 1024 ) { for ( i = 0 ; i < get_vpx_decoder_count ( ) ; ++ i ) { const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ; <S2SV_StartBug> if ( ! vpx_codec_peek_stream_info ( decoder -> interface ( ) , <S2SV_EndBug> buf + 4 , 32 - 4 , & si ) ) { is_raw = 1 ; input -> fourcc = decoder -> fourcc ; input -> width = si . w ; input -> height = si . h ; input -> framerate . numerator = 30 ; input -> framerate . denominator = 1 ; break ; } } } } rewind ( input -> file ) ; return is_raw ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ,
",CWE-119
427,"CWE-119 void vp9_set_segment_data ( struct segmentation * seg , signed char * feature_data , unsigned char abs_delta ) { seg -> abs_delta = abs_delta ; <S2SV_StartBug> vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> = abs_delta ; memcpy <S2SV_ModEnd> ( seg ->
",CWE-119
429,"CWE-190 int mem_check_range ( struct rxe_mem * mem , u64 iova , size_t length ) { switch ( mem -> type ) { case RXE_MEM_TYPE_DMA : return 0 ; case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR : <S2SV_StartBug> return ( ( iova < mem -> iova ) || <S2SV_EndBug> <S2SV_StartBug> ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ? <S2SV_EndBug> - EFAULT : 0 ; default : return - EFAULT ; } }
","<S2SV_ModStart> case RXE_MEM_TYPE_FMR : if <S2SV_ModEnd> ( iova < <S2SV_ModStart> mem -> iova || length > mem -> length || iova > <S2SV_ModEnd> mem -> iova <S2SV_ModStart> mem -> length - length ) return - EFAULT ; return <S2SV_ModEnd> 0 ; default
",CWE-190
430,"CWE-119 static int http_open ( URLContext * h , const char * uri , int flags , AVDictionary * * options ) { HTTPContext * s = h -> priv_data ; int ret ; if ( s -> seekable == 1 ) h -> is_streamed = 0 ; else h -> is_streamed = 1 ; <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> location = av_strdup ( uri ) ; if ( ! s -> location ) return AVERROR ( ENOMEM ) ; if ( options ) av_dict_copy ( & s -> chained_options , * options , 0 ) ; if ( s -> headers ) { int len = strlen ( s -> headers ) ; if ( len < 2 || strcmp ( ""\\r\\n"" , s -> headers + len - 2 ) ) { av_log ( h , AV_LOG_WARNING , ""No<S2SV_blank>trailing<S2SV_blank>CRLF<S2SV_blank>found<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>header.\\n"" ) ; ret = av_reallocp ( & s -> headers , len + 3 ) ; if ( ret < 0 ) return ret ; s -> headers [ len ] = '\\r' ; s -> headers [ len + 1 ] = '\\n' ; s -> headers [ len + 2 ] = '\\0' ; } } if ( s -> listen ) { return http_listen ( h , uri , flags , options ) ; } ret = http_open_cnx ( h , options ) ; if ( ret < 0 ) av_dict_free ( & s -> chained_options ) ; return ret ; }
","<S2SV_ModStart> -> filesize = UINT64_MAX <S2SV_ModEnd> ; s ->
",CWE-119
431,"CWE-119 <S2SV_StartBug> static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> int min_log2_tile_cols , max_log2_tile_cols , ones ; vp9_get_tile_n_bits ( cm -> mi_cols , & min_log2_tile_cols , & max_log2_tile_cols ) ; ones = cm -> log2_tile_cols - min_log2_tile_cols ; while ( ones -- ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> if ( cm -> log2_tile_cols < max_log2_tile_cols ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ; <S2SV_EndBug> if ( cm -> log2_tile_rows != 0 ) <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> void write_tile_info ( const VP9_COMMON * const <S2SV_ModEnd> cm , struct <S2SV_ModStart> cm , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> ones -- ) vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> < max_log2_tile_cols ) vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> 0 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> != 0 ) vpx_wb_write_bit <S2SV_ModEnd> ( wb ,
",CWE-119
432,"CWE-295 void options_apply ( ) { unsigned num = 0 ; SERVICE_OPTIONS * section ; CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; <S2SV_StartBug> memcpy ( & global_options , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ; <S2SV_EndBug> for ( section = new_service_options . next ; section ; section = section -> next ) section -> section_number = num ++ ; memcpy ( & service_options , & new_service_options , sizeof ( SERVICE_OPTIONS ) ) ; <S2SV_StartBug> number_of_sections = num ; <S2SV_EndBug> CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; }
","<S2SV_ModStart> , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ; memset ( & new_global_options , 0 <S2SV_ModStart> ) ) ; memset ( & new_service_options , 0 , sizeof ( SERVICE_OPTIONS ) ) ;
",CWE-295
436,"CWE-476 static SSL * open_ssl_connection ( rfbClient * client , int sockfd , rfbBool anonTLS , rfbCredential * cred ) { SSL_CTX * ssl_ctx = NULL ; SSL * ssl = NULL ; int n , finished = 0 ; X509_VERIFY_PARAM * param ; <S2SV_StartBug> uint8_t verify_crls = cred -> x509Credential . x509CrlVerifyMode ; <S2SV_EndBug> if ( ! ( ssl_ctx = SSL_CTX_new ( SSLv23_client_method ( ) ) ) ) { rfbClientLog ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>new<S2SV_blank>SSL<S2SV_blank>context.\\n"" ) ; return NULL ; } param = X509_VERIFY_PARAM_new ( ) ; if ( ! anonTLS ) <S2SV_StartBug> { <S2SV_EndBug> if ( cred -> x509Credential . x509CACertFile ) { if ( ! SSL_CTX_load_verify_locations ( ssl_ctx , cred -> x509Credential . x509CACertFile , NULL ) ) { rfbClientLog ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>from<S2SV_blank>%s.\\n"" , cred -> x509Credential . x509CACertFile ) ; goto error_free_ctx ; } } else { rfbClientLog ( ""Using<S2SV_blank>default<S2SV_blank>paths<S2SV_blank>for<S2SV_blank>certificate<S2SV_blank>verification.\\n"" ) ; SSL_CTX_set_default_verify_paths ( ssl_ctx ) ; } if ( cred -> x509Credential . x509CACrlFile ) { if ( ! load_crls_from_file ( cred -> x509Credential . x509CACrlFile , ssl_ctx ) ) { rfbClientLog ( ""CRLs<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n"" ) ; goto error_free_ctx ; } if ( verify_crls == rfbX509CrlVerifyNone ) verify_crls = rfbX509CrlVerifyAll ; } if ( cred -> x509Credential . x509ClientCertFile && cred -> x509Credential . x509ClientKeyFile ) { if ( SSL_CTX_use_certificate_chain_file ( ssl_ctx , cred -> x509Credential . x509ClientCertFile ) != 1 ) { rfbClientLog ( ""Client<S2SV_blank>certificate<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n"" ) ; goto error_free_ctx ; } if ( SSL_CTX_use_PrivateKey_file ( ssl_ctx , cred -> x509Credential . x509ClientKeyFile , SSL_FILETYPE_PEM ) != 1 ) { rfbClientLog ( ""Client<S2SV_blank>private<S2SV_blank>key<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n"" ) ; goto error_free_ctx ; } if ( SSL_CTX_check_private_key ( ssl_ctx ) == 0 ) { rfbClientLog ( ""Client<S2SV_blank>certificate<S2SV_blank>and<S2SV_blank>private<S2SV_blank>key<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.\\n"" ) ; goto error_free_ctx ; } } SSL_CTX_set_verify ( ssl_ctx , SSL_VERIFY_PEER , NULL ) ; if ( verify_crls == rfbX509CrlVerifyClient ) X509_VERIFY_PARAM_set_flags ( param , X509_V_FLAG_CRL_CHECK ) ; else if ( verify_crls == rfbX509CrlVerifyAll ) X509_VERIFY_PARAM_set_flags ( param , X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL ) ; if ( ! X509_VERIFY_PARAM_set1_host ( param , client -> serverHost , strlen ( client -> serverHost ) ) ) { rfbClientLog ( ""Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>server<S2SV_blank>name<S2SV_blank>for<S2SV_blank>verification.\\n"" ) ; goto error_free_ctx ; } SSL_CTX_set1_param ( ssl_ctx , param ) ; } if ( ! ( ssl = SSL_new ( ssl_ctx ) ) ) { rfbClientLog ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>SSL<S2SV_blank>session.\\n"" ) ; goto error_free_ctx ; } SSL_set_cipher_list ( ssl , ""ALL"" ) ; SSL_set_fd ( ssl , sockfd ) ; SSL_CTX_set_app_data ( ssl_ctx , client ) ; do { n = SSL_connect ( ssl ) ; if ( n != 1 ) { if ( wait_for_data ( ssl , n , 1 ) != 1 ) { finished = 1 ; SSL_shutdown ( ssl ) ; goto error_free_ssl ; } } } while ( n != 1 && finished != 1 ) ; X509_VERIFY_PARAM_free ( param ) ; return ssl ; error_free_ssl : SSL_free ( ssl ) ; error_free_ctx : X509_VERIFY_PARAM_free ( param ) ; SSL_CTX_free ( ssl_ctx ) ; return NULL ; }
","<S2SV_ModStart> ; uint8_t verify_crls <S2SV_ModEnd> ; if ( <S2SV_ModStart> anonTLS ) { verify_crls = cred -> x509Credential . x509CrlVerifyMode ;
",CWE-476
438,"CWE-000 static int translate_desc ( struct vhost_dev * dev , u64 addr , u32 len , struct iovec iov [ ] , int iov_size ) { const struct vhost_memory_region * reg ; struct vhost_memory * mem ; struct iovec * _iov ; u64 s = 0 ; int ret = 0 ; rcu_read_lock ( ) ; mem = rcu_dereference ( dev -> memory ) ; while ( ( u64 ) len > s ) { u64 size ; if ( unlikely ( ret >= iov_size ) ) { ret = - ENOBUFS ; break ; } reg = find_region ( mem , addr , len ) ; if ( unlikely ( ! reg ) ) { ret = - EFAULT ; break ; } _iov = iov + ret ; size = reg -> memory_size - addr + reg -> guest_phys_addr ; <S2SV_StartBug> _iov -> iov_len = min ( ( u64 ) len , size ) ; <S2SV_EndBug> _iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ; s += size ; addr += size ; ++ ret ; } rcu_read_unlock ( ) ; return ret ; }
","<S2SV_ModStart> u64 ) len - s
",CWE-000
439,"CWE-401 static int sof_set_get_large_ctrl_data ( struct snd_sof_dev * sdev , struct sof_ipc_ctrl_data * cdata , struct sof_ipc_ctrl_data_params * sparams , bool send ) { struct sof_ipc_ctrl_data * partdata ; size_t send_bytes ; size_t offset = 0 ; size_t msg_bytes ; size_t pl_size ; int err ; int i ; partdata = kzalloc ( SOF_IPC_MSG_MAX_SIZE , GFP_KERNEL ) ; if ( ! partdata ) return - ENOMEM ; if ( send ) err = sof_get_ctrl_copy_params ( cdata -> type , cdata , partdata , sparams ) ; else err = sof_get_ctrl_copy_params ( cdata -> type , partdata , cdata , sparams ) ; <S2SV_StartBug> if ( err < 0 ) <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> msg_bytes = sparams -> msg_bytes ; pl_size = sparams -> pl_size ; memcpy ( partdata , cdata , sparams -> hdr_bytes ) ; mutex_lock ( & sdev -> ipc -> tx_mutex ) ; for ( i = 0 ; i < sparams -> num_msg ; i ++ ) { send_bytes = min ( msg_bytes , pl_size ) ; partdata -> num_elems = send_bytes ; partdata -> rhdr . hdr . size = sparams -> hdr_bytes + send_bytes ; partdata -> msg_index = i ; msg_bytes -= send_bytes ; partdata -> elems_remaining = msg_bytes ; if ( send ) memcpy ( sparams -> dst , sparams -> src + offset , send_bytes ) ; err = sof_ipc_tx_message_unlocked ( sdev -> ipc , partdata -> rhdr . hdr . cmd , partdata , partdata -> rhdr . hdr . size , partdata , partdata -> rhdr . hdr . size ) ; if ( err < 0 ) break ; if ( ! send ) memcpy ( sparams -> dst + offset , sparams -> src , send_bytes ) ; offset += pl_size ; } mutex_unlock ( & sdev -> ipc -> tx_mutex ) ; kfree ( partdata ) ; return err ; }
","<S2SV_ModStart> < 0 ) { kfree ( partdata ) ; <S2SV_ModStart> return err ; }
",CWE-401
440,"CWE-399 static inline int sctp_chunk_length_valid ( struct sctp_chunk * chunk , __u16 required_length ) { __u16 chunk_length = ntohs ( chunk -> chunk_hdr -> length ) ; <S2SV_StartBug> if ( unlikely ( chunk_length < required_length ) ) <S2SV_EndBug> return 0 ; return 1 ; }
","<S2SV_ModStart> ( unlikely ( chunk -> pdiscard ) ) return 0 ; if ( unlikely (
",CWE-399
444,"CWE-125 static void rpl_dio_printopt ( netdissect_options * ndo , const struct rpl_dio_genoption * opt , u_int length ) { if ( length < RPL_DIO_GENOPTION_LEN ) return ; length -= RPL_DIO_GENOPTION_LEN ; ND_TCHECK ( opt -> rpl_dio_len ) ; while ( ( opt -> rpl_dio_type == RPL_OPT_PAD0 && ( const u_char * ) opt < ndo -> ndo_snapend ) || ND_TTEST2 ( * opt , ( opt -> rpl_dio_len + 2 ) ) ) { unsigned int optlen = opt -> rpl_dio_len + 2 ; if ( opt -> rpl_dio_type == RPL_OPT_PAD0 ) { optlen = 1 ; ND_PRINT ( ( ndo , ""<S2SV_blank>opt:pad0"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>opt:%s<S2SV_blank>len:%u<S2SV_blank>"" , tok2str ( rpl_subopt_values , ""subopt:%u"" , opt -> rpl_dio_type ) , optlen ) ) ; if ( ndo -> ndo_vflag > 2 ) { unsigned int paylen = opt -> rpl_dio_len ; if ( paylen > length ) paylen = length ; hex_print ( ndo , ""<S2SV_blank>"" , ( ( const uint8_t * ) opt ) + RPL_DIO_GENOPTION_LEN , paylen ) ; } } opt = ( const struct rpl_dio_genoption * ) ( ( ( const char * ) opt ) + optlen ) ; length -= optlen ; <S2SV_StartBug> } <S2SV_EndBug> return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> return ; }
","<S2SV_ModStart> -= optlen ; ND_TCHECK ( opt -> rpl_dio_len ) ; <S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",CWE-125
451,"CWE-189 Datum txid_current_snapshot ( PG_FUNCTION_ARGS ) { TxidSnapshot * snap ; uint32 nxip , i , size ; TxidEpoch state ; Snapshot cur ; cur = GetActiveSnapshot ( ) ; if ( cur == NULL ) elog ( ERROR , ""no<S2SV_blank>active<S2SV_blank>snapshot<S2SV_blank>set"" ) ; <S2SV_StartBug> load_xid_epoch ( & state ) ; <S2SV_EndBug> nxip = cur -> xcnt ; size = TXID_SNAPSHOT_SIZE ( nxip ) ; snap = palloc ( size ) ; SET_VARSIZE ( snap , size ) ; snap -> xmin = convert_xid ( cur -> xmin , & state ) ; snap -> xmax = convert_xid ( cur -> xmax , & state ) ; snap -> nxip = nxip ; for ( i = 0 ; i < nxip ; i ++ ) snap -> xip [ i ] = convert_xid ( cur -> xip [ i ] , & state ) ; sort_snapshot ( snap ) ; PG_RETURN_POINTER ( snap ) ; }
","<S2SV_ModStart> ( & state ) ; StaticAssertStmt ( MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP , ""possible<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>txid_current_snapshot()""
",CWE-189
453,"CWE-476 static void filter_session_io ( struct io * io , int evt , void * arg ) { struct filter_session * fs = arg ; char * line = NULL ; ssize_t len ; log_trace ( TRACE_IO , ""filter<S2SV_blank>session:<S2SV_blank>%p:<S2SV_blank>%s<S2SV_blank>%s"" , fs , io_strevent ( evt ) , io_strio ( io ) ) ; switch ( evt ) { case IO_DATAIN : nextline : line = io_getline ( fs -> io , & len ) ; if ( line == NULL ) return ; filter_data ( fs -> id , line ) ; goto nextline ; <S2SV_StartBug> case IO_DISCONNECTED : <S2SV_EndBug> io_free ( fs -> io ) ; fs -> io = NULL ; break ; } }
","<S2SV_ModStart> goto nextline ; <S2SV_ModEnd> } } <S2SV_null>
",CWE-476
455,"CWE-200 inline int web_client_api_request_v1_data ( RRDHOST * host , struct web_client * w , char * url ) { debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>with<S2SV_blank>URL<S2SV_blank>\'%s\'"" , w -> id , url ) ; int ret = 400 ; BUFFER * dimensions = NULL ; buffer_flush ( w -> response . data ) ; char * google_version = ""0.6"" , * google_reqId = ""0"" , * google_sig = ""0"" , * google_out = ""json"" , * responseHandler = NULL , * outFileName = NULL ; time_t last_timestamp_in_data = 0 , google_timestamp = 0 ; char * chart = NULL , * before_str = NULL , * after_str = NULL , * group_time_str = NULL , * points_str = NULL ; int group = RRDR_GROUPING_AVERAGE ; uint32_t format = DATASOURCE_JSON ; uint32_t options = 0x00000000 ; while ( url ) { char * value = mystrsep ( & url , ""?&"" ) ; if ( ! value || ! * value ) continue ; char * name = mystrsep ( & value , ""="" ) ; if ( ! name || ! * name ) continue ; if ( ! value || ! * value ) continue ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>query<S2SV_blank>param<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>value<S2SV_blank>\'%s\'"" , w -> id , name , value ) ; if ( ! strcmp ( name , ""chart"" ) ) chart = value ; else if ( ! strcmp ( name , ""dimension"" ) || ! strcmp ( name , ""dim"" ) || ! strcmp ( name , ""dimensions"" ) || ! strcmp ( name , ""dims"" ) ) { if ( ! dimensions ) dimensions = buffer_create ( 100 ) ; buffer_strcat ( dimensions , ""|"" ) ; buffer_strcat ( dimensions , value ) ; } else if ( ! strcmp ( name , ""after"" ) ) after_str = value ; else if ( ! strcmp ( name , ""before"" ) ) before_str = value ; else if ( ! strcmp ( name , ""points"" ) ) points_str = value ; else if ( ! strcmp ( name , ""gtime"" ) ) group_time_str = value ; else if ( ! strcmp ( name , ""group"" ) ) { group = web_client_api_request_v1_data_group ( value , RRDR_GROUPING_AVERAGE ) ; } else if ( ! strcmp ( name , ""format"" ) ) { format = web_client_api_request_v1_data_format ( value ) ; } else if ( ! strcmp ( name , ""options"" ) ) { options |= web_client_api_request_v1_data_options ( value ) ; } else if ( ! strcmp ( name , ""callback"" ) ) { responseHandler = value ; } else if ( ! strcmp ( name , ""filename"" ) ) { outFileName = value ; } else if ( ! strcmp ( name , ""tqx"" ) ) { char * tqx_name , * tqx_value ; while ( value ) { tqx_value = mystrsep ( & value , "";"" ) ; if ( ! tqx_value || ! * tqx_value ) continue ; tqx_name = mystrsep ( & tqx_value , "":"" ) ; if ( ! tqx_name || ! * tqx_name ) continue ; if ( ! tqx_value || ! * tqx_value ) continue ; if ( ! strcmp ( tqx_name , ""version"" ) ) google_version = tqx_value ; else if ( ! strcmp ( tqx_name , ""reqId"" ) ) google_reqId = tqx_value ; else if ( ! strcmp ( tqx_name , ""sig"" ) ) { google_sig = tqx_value ; google_timestamp = strtoul ( google_sig , NULL , 0 ) ; } else if ( ! strcmp ( tqx_name , ""out"" ) ) { google_out = tqx_value ; format = web_client_api_request_v1_data_google_format ( google_out ) ; } else if ( ! strcmp ( tqx_name , ""responseHandler"" ) ) responseHandler = tqx_value ; else if ( ! strcmp ( tqx_name , ""outFileName"" ) ) outFileName = tqx_value ; } } } <S2SV_StartBug> if ( ! chart || ! * chart ) { <S2SV_EndBug> buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ; goto cleanup ; } RRDSET * st = rrdset_find ( host , chart ) ; if ( ! st ) st = rrdset_find_byname ( host , chart ) ; if ( ! st ) { buffer_strcat ( w -> response . data , ""Chart<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>"" ) ; buffer_strcat_htmlescape ( w -> response . data , chart ) ; ret = 404 ; goto cleanup ; } st -> last_accessed_time = now_realtime_sec ( ) ; long long before = ( before_str && * before_str ) ? str2l ( before_str ) : 0 ; long long after = ( after_str && * after_str ) ? str2l ( after_str ) : 0 ; int points = ( points_str && * points_str ) ? str2i ( points_str ) : 0 ; long group_time = ( group_time_str && * group_time_str ) ? str2l ( group_time_str ) : 0 ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>command<S2SV_blank>\'data\'<S2SV_blank>for<S2SV_blank>chart<S2SV_blank>\'%s\',<S2SV_blank>dimensions<S2SV_blank>\'%s\',<S2SV_blank>after<S2SV_blank>\'%lld\',<S2SV_blank>before<S2SV_blank>\'%lld\',<S2SV_blank>points<S2SV_blank>\'%d\',<S2SV_blank>group<S2SV_blank>\'%d\',<S2SV_blank>format<S2SV_blank>\'%u\',<S2SV_blank>options<S2SV_blank>\'0x%08x\'"" , w -> id , chart , ( dimensions ) ? buffer_tostring ( dimensions ) : """" , after , before , points , group , format , options ) ; if ( outFileName && * outFileName ) { buffer_sprintf ( w -> response . header , ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\""%s\\""\\r\\n"" , outFileName ) ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>generating<S2SV_blank>outfilename<S2SV_blank>header:<S2SV_blank>\'%s\'"" , w -> id , outFileName ) ; } if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( responseHandler == NULL ) responseHandler = ""google.visualization.Query.setResponse"" ; debug ( D_WEB_CLIENT_ACCESS , ""%llu:<S2SV_blank>GOOGLE<S2SV_blank>JSON/JSONP:<S2SV_blank>version<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>reqId<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>sig<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>out<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>responseHandler<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>outFileName<S2SV_blank>=<S2SV_blank>\'%s\'"" , w -> id , google_version , google_reqId , google_sig , google_out , responseHandler , outFileName ) ; buffer_sprintf ( w -> response . data , ""%s({version:\'%s\',reqId:\'%s\',status:\'ok\',sig:\'%ld\',table:"" , responseHandler , google_version , google_reqId , st -> last_updated . tv_sec ) ; } else if ( format == DATASOURCE_JSONP ) { if ( responseHandler == NULL ) responseHandler = ""callback"" ; buffer_strcat ( w -> response . data , responseHandler ) ; buffer_strcat ( w -> response . data , ""("" ) ; } ret = rrdset2anything_api_v1 ( st , w -> response . data , dimensions , format , points , after , before , group , group_time , options , & last_timestamp_in_data ) ; if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( google_timestamp < last_timestamp_in_data ) buffer_strcat ( w -> response . data , ""});"" ) ; else { buffer_flush ( w -> response . data ) ; buffer_sprintf ( w -> response . data , ""%s({version:\'%s\',reqId:\'%s\',status:\'error\',errors:[{reason:\'not_modified\',message:\'Data<S2SV_blank>not<S2SV_blank>modified\'}]});"" , responseHandler , google_version , google_reqId ) ; } } else if ( format == DATASOURCE_JSONP ) buffer_strcat ( w -> response . data , "");"" ) ; cleanup : buffer_free ( dimensions ) ; return ret ; }
","<S2SV_ModStart> } } } fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ;
",CWE-200
456,"CWE-125 static void ttm_put_pages ( struct page * * pages , unsigned npages , int flags , enum ttm_caching_state cstate ) { struct ttm_page_pool * pool = ttm_get_pool ( flags , false , cstate ) ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool * huge = ttm_get_pool ( flags , true , cstate ) ; # endif unsigned long irq_flags ; unsigned i ; if ( pool == NULL ) { i = 0 ; while ( i < npages ) { # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ; # endif unsigned order = 0 , j ; if ( ! pages [ i ] ) { ++ i ; continue ; } # ifdef CONFIG_TRANSPARENT_HUGEPAGE <S2SV_StartBug> if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) ) { <S2SV_EndBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ; } # endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; __free_pages ( pages [ i ] , order ) ; j = 1 << order ; while ( j ) { pages [ i ++ ] = NULL ; -- j ; } } return ; } i = 0 ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) { unsigned max_size , n2free ; spin_lock_irqsave ( & huge -> lock , irq_flags ) ; <S2SV_StartBug> while ( i < npages ) { <S2SV_EndBug> struct page * p = pages [ i ] ; unsigned j ; if ( ! p ) break ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j != HPAGE_PMD_NR ) break ; list_add_tail ( & pages [ i ] -> lru , & huge -> list ) ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) pages [ i ++ ] = NULL ; huge -> npages ++ ; } max_size = _manager -> options . max_size ; max_size /= HPAGE_PMD_NR ; if ( huge -> npages > max_size ) n2free = huge -> npages - max_size ; else n2free = 0 ; spin_unlock_irqrestore ( & huge -> lock , irq_flags ) ; if ( n2free ) ttm_page_pool_free ( huge , n2free , false ) ; } # endif spin_lock_irqsave ( & pool -> lock , irq_flags ) ; while ( i < npages ) { if ( pages [ i ] ) { if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; list_add_tail ( & pages [ i ] -> lru , & pool -> list ) ; pages [ i ] = NULL ; pool -> npages ++ ; } ++ i ; } npages = 0 ; if ( pool -> npages > _manager -> options . max_size ) { npages = pool -> npages - _manager -> options . max_size ; if ( npages < NUM_PAGES_TO_ALLOC ) npages = NUM_PAGES_TO_ALLOC ; } spin_unlock_irqrestore ( & pool -> lock , irq_flags ) ; if ( npages ) ttm_page_pool_free ( pool , npages , false ) ; }
","<S2SV_ModStart> & TTM_PAGE_FLAG_DMA32 ) && ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModStart> ; while ( ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModEnd> ) { struct
",CWE-125
457,"CWE-000 asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) <S2SV_StartBug> { <S2SV_EndBug> console_verbose ( ) ; pr_crit ( ""Bad<S2SV_blank>mode<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>handler<S2SV_blank>detected,<S2SV_blank>code<S2SV_blank>0x%08x\\n"" , handler [ reason ] , esr ) ; <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug> local_irq_disable ( ) ; panic ( ""bad<S2SV_blank>mode"" ) ; }
","<S2SV_ModStart> esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , <S2SV_ModStart> , regs , & info , 0 <S2SV_ModEnd> ) ; }
",CWE-000
458,"CWE-20 void bdt_enable ( void ) { bdt_log ( ""ENABLE<S2SV_blank>BT"" ) ; if ( bt_enabled ) { bdt_log ( ""Bluetooth<S2SV_blank>is<S2SV_blank>already<S2SV_blank>enabled"" ) ; return ; } <S2SV_StartBug> status = sBtInterface -> enable ( ) ; <S2SV_EndBug> check_return_status ( status ) ; }
","<S2SV_ModStart> -> enable ( false
",CWE-20
460,"CWE-20 static void icmp6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , const struct in6_addr * force_saddr ) { struct net * net = dev_net ( skb -> dev ) ; struct inet6_dev * idev = NULL ; struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; struct sock * sk ; struct ipv6_pinfo * np ; const struct in6_addr * saddr = NULL ; struct dst_entry * dst ; struct icmp6hdr tmp_hdr ; struct flowi6 fl6 ; struct icmpv6_msg msg ; struct sockcm_cookie sockc_unused = { 0 } ; struct ipcm6_cookie ipc6 ; int iif = 0 ; int addr_type = 0 ; int len ; int err = 0 ; u32 mark = IP6_REPLY_MARK ( net , skb -> mark ) ; if ( ( u8 * ) hdr < skb -> head || ( skb_network_header ( skb ) + sizeof ( * hdr ) ) > skb_tail_pointer ( skb ) ) return ; addr_type = ipv6_addr_type ( & hdr -> daddr ) ; if ( ipv6_chk_addr ( net , & hdr -> daddr , skb -> dev , 0 ) || ipv6_chk_acast_addr_src ( net , skb -> dev , & hdr -> daddr ) ) saddr = & hdr -> daddr ; if ( addr_type & IPV6_ADDR_MULTICAST || skb -> pkt_type != PACKET_HOST ) { if ( type != ICMPV6_PKT_TOOBIG && ! ( type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && ( opt_unrec ( skb , info ) ) ) ) return ; saddr = NULL ; } addr_type = ipv6_addr_type ( & hdr -> saddr ) ; if ( __ipv6_addr_needs_scope_id ( addr_type ) ) iif = skb -> dev -> ifindex ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug> if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) { net_dbg_ratelimited ( ""icmp6_send:<S2SV_blank>addr_any/mcast<S2SV_blank>source<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; return ; } if ( is_ineligible ( skb ) ) { net_dbg_ratelimited ( ""icmp6_send:<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>icmp<S2SV_blank>error<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; return ; } mip6_addr_swap ( skb ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_ICMPV6 ; fl6 . daddr = hdr -> saddr ; if ( force_saddr ) saddr = force_saddr ; if ( saddr ) fl6 . saddr = * saddr ; fl6 . flowi6_mark = mark ; fl6 . flowi6_oif = iif ; fl6 . fl6_icmp_type = type ; fl6 . fl6_icmp_code = code ; security_skb_classify_flow ( skb , flowi6_to_flowi ( & fl6 ) ) ; sk = icmpv6_xmit_lock ( net ) ; if ( ! sk ) return ; sk -> sk_mark = mark ; np = inet6_sk ( sk ) ; if ( ! icmpv6_xrlim_allow ( sk , type , & fl6 ) ) goto out ; tmp_hdr . icmp6_type = type ; tmp_hdr . icmp6_code = code ; tmp_hdr . icmp6_cksum = 0 ; tmp_hdr . icmp6_pointer = htonl ( info ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; ipc6 . tclass = np -> tclass ; fl6 . flowlabel = ip6_make_flowinfo ( ipc6 . tclass , fl6 . flowlabel ) ; dst = icmpv6_route_lookup ( net , skb , sk , & fl6 ) ; if ( IS_ERR ( dst ) ) goto out ; ipc6 . hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; ipc6 . dontfrag = np -> dontfrag ; ipc6 . opt = NULL ; msg . skb = skb ; msg . offset = skb_network_offset ( skb ) ; msg . type = type ; len = skb -> len - msg . offset ; len = min_t ( unsigned int , len , IPV6_MIN_MTU - sizeof ( struct ipv6hdr ) - sizeof ( struct icmp6hdr ) ) ; if ( len < 0 ) { net_dbg_ratelimited ( ""icmp:<S2SV_blank>len<S2SV_blank>problem<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; goto out_dst_release ; } rcu_read_lock ( ) ; idev = __in6_dev_get ( skb -> dev ) ; err = ip6_append_data ( sk , icmpv6_getfrag , & msg , len + sizeof ( struct icmp6hdr ) , sizeof ( struct icmp6hdr ) , & ipc6 , & fl6 , ( struct rt6_info * ) dst , MSG_DONTWAIT , & sockc_unused ) ; if ( err ) { ICMP6_INC_STATS ( net , idev , ICMP6_MIB_OUTERRORS ) ; ip6_flush_pending_frames ( sk ) ; } else { err = icmpv6_push_pending_frames ( sk , & fl6 , & tmp_hdr , len + sizeof ( struct icmp6hdr ) ) ; } rcu_read_unlock ( ) ; out_dst_release : dst_release ( dst ) ; out : icmpv6_xmit_unlock ( sk ) ; }
","<S2SV_ModStart> ifindex ; else { dst = skb_dst ( skb ) ; <S2SV_ModStart> = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ; } <S2SV_ModEnd> if ( (
",CWE-20
465,"CWE-119 static krb5_int32 prep_reprocess_req ( krb5_kdc_req * request , krb5_principal * krbtgt_princ ) { krb5_error_code retval = KRB5KRB_AP_ERR_BADMATCH ; char * * realms , * * cpp , * temp_buf = NULL ; krb5_data * comp1 = NULL , * comp2 = NULL ; char * comp1_str = NULL ; if ( isflagset ( request -> kdc_options , KDC_OPT_CANONICALIZE ) && ! isflagset ( request -> kdc_options , KDC_OPT_ENC_TKT_IN_SKEY ) && krb5_princ_size ( kdc_context , request -> server ) == 2 ) { comp1 = krb5_princ_component ( kdc_context , request -> server , 0 ) ; comp2 = krb5_princ_component ( kdc_context , request -> server , 1 ) ; comp1_str = calloc ( 1 , comp1 -> length + 1 ) ; if ( ! comp1_str ) { retval = ENOMEM ; goto cleanup ; } <S2SV_StartBug> strlcpy ( comp1_str , comp1 -> data , comp1 -> length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_HST || <S2SV_EndBug> krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_INST || ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_UNKNOWN && kdc_active_realm -> realm_host_based_services != NULL && ( krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , comp1_str ) == TRUE || krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , KRB5_CONF_ASTERISK ) == TRUE ) ) ) && ( kdc_active_realm -> realm_no_host_referral == NULL || ( krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , KRB5_CONF_ASTERISK ) == FALSE && krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , comp1_str ) == FALSE ) ) ) { if ( memchr ( comp2 -> data , '.' , comp2 -> length ) == NULL ) goto cleanup ; temp_buf = calloc ( 1 , comp2 -> length + 1 ) ; if ( ! temp_buf ) { retval = ENOMEM ; goto cleanup ; } <S2SV_StartBug> strlcpy ( temp_buf , comp2 -> data , comp2 -> length + 1 ) ; <S2SV_EndBug> retval = krb5int_get_domain_realm_mapping ( kdc_context , temp_buf , & realms ) ; free ( temp_buf ) ; if ( retval ) { kdc_err ( kdc_context , retval , ""unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>realm<S2SV_blank>of<S2SV_blank>host"" ) ; goto cleanup ; } if ( realms == 0 ) { retval = KRB5KRB_AP_ERR_BADMATCH ; goto cleanup ; } if ( realms [ 0 ] == 0 || data_eq_string ( request -> server -> realm , realms [ 0 ] ) ) { free ( realms [ 0 ] ) ; free ( realms ) ; retval = KRB5KRB_AP_ERR_BADMATCH ; goto cleanup ; } retval = krb5_build_principal ( kdc_context , krbtgt_princ , ( * request -> server ) . realm . length , ( * request -> server ) . realm . data , ""krbtgt"" , realms [ 0 ] , ( char * ) 0 ) ; for ( cpp = realms ; * cpp ; cpp ++ ) free ( * cpp ) ; } } cleanup : free ( comp1_str ) ; return retval ; }
","<S2SV_ModStart> cleanup ; } if ( <S2SV_ModEnd> comp1 -> data <S2SV_ModStart> comp1 -> data != NULL ) memcpy ( comp1_str , comp1 -> data , comp1 -> length ) ; if ( ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_HST || krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_INST || ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_UNKNOWN && kdc_active_realm -> realm_host_based_services != NULL && ( krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , comp1_str ) == TRUE || krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , KRB5_CONF_ASTERISK ) == TRUE ) ) ) && ( kdc_active_realm -> realm_no_host_referral == NULL || ( krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , KRB5_CONF_ASTERISK ) == FALSE && krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , comp1_str ) == FALSE ) ) ) { if ( memchr ( comp2 -> data , '.' , comp2 -> length ) == NULL ) goto cleanup ; temp_buf = calloc ( 1 , comp2 <S2SV_ModEnd> -> length + <S2SV_ModStart> ; if ( <S2SV_ModEnd> ! temp_buf ) <S2SV_ModStart> cleanup ; } if ( comp2 -> data != NULL ) memcpy <S2SV_ModEnd> ( temp_buf , <S2SV_ModStart> comp2 -> length <S2SV_ModEnd> ) ; retval
",CWE-119
468,"CWE-119 GF_Err stbl_GetSampleInfos ( GF_SampleTableBox * stbl , u32 sampleNumber , u64 * offset , u32 * chunkNumber , u32 * descIndex , GF_StscEntry * * out_ent ) { GF_Err e ; u32 i , k , offsetInChunk , size , chunk_num ; GF_ChunkOffsetBox * stco ; GF_ChunkLargeOffsetBox * co64 ; GF_StscEntry * ent ; ( * offset ) = 0 ; ( * chunkNumber ) = ( * descIndex ) = 0 ; if ( out_ent ) ( * out_ent ) = NULL ; if ( ! stbl || ! sampleNumber ) return GF_BAD_PARAM ; if ( ! stbl -> ChunkOffset || ! stbl -> SampleToChunk || ! stbl -> SampleSize ) return GF_ISOM_INVALID_FILE ; if ( stbl -> SampleSize && stbl -> SampleToChunk -> nb_entries == stbl -> SampleSize -> sampleCount ) { ent = & stbl -> SampleToChunk -> entries [ sampleNumber - 1 ] ; if ( ! ent ) return GF_BAD_PARAM ; ( * descIndex ) = ent -> sampleDescriptionIndex ; ( * chunkNumber ) = sampleNumber ; if ( out_ent ) * out_ent = ent ; if ( stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { stco = ( GF_ChunkOffsetBox * ) stbl -> ChunkOffset ; if ( ! stco -> offsets ) return GF_ISOM_INVALID_FILE ; <S2SV_StartBug> ( * offset ) = ( u64 ) stco -> offsets [ sampleNumber - 1 ] ; <S2SV_EndBug> } else { co64 = ( GF_ChunkLargeOffsetBox * ) stbl -> ChunkOffset ; <S2SV_StartBug> if ( ! co64 -> offsets ) return GF_ISOM_INVALID_FILE ; <S2SV_EndBug> ( * offset ) = co64 -> offsets [ sampleNumber - 1 ] ; } return GF_OK ; } if ( stbl -> SampleToChunk -> firstSampleInCurrentChunk && ( stbl -> SampleToChunk -> firstSampleInCurrentChunk <= sampleNumber ) ) { i = stbl -> SampleToChunk -> currentIndex ; ent = & stbl -> SampleToChunk -> entries [ stbl -> SampleToChunk -> currentIndex ] ; GetGhostNum ( ent , i , stbl -> SampleToChunk -> nb_entries , stbl ) ; k = stbl -> SampleToChunk -> currentChunk ; } else { i = 0 ; stbl -> SampleToChunk -> currentIndex = 0 ; stbl -> SampleToChunk -> currentChunk = 1 ; stbl -> SampleToChunk -> ghostNumber = 1 ; stbl -> SampleToChunk -> firstSampleInCurrentChunk = 1 ; ent = & stbl -> SampleToChunk -> entries [ 0 ] ; GetGhostNum ( ent , 0 , stbl -> SampleToChunk -> nb_entries , stbl ) ; k = stbl -> SampleToChunk -> currentChunk ; } for ( ; i < stbl -> SampleToChunk -> nb_entries ; i ++ ) { assert ( stbl -> SampleToChunk -> firstSampleInCurrentChunk <= sampleNumber ) ; if ( k > stbl -> SampleToChunk -> ghostNumber ) { return GF_ISOM_INVALID_FILE ; } u32 max_chunks_in_entry = stbl -> SampleToChunk -> ghostNumber - k ; u32 nb_chunks_for_sample = sampleNumber - stbl -> SampleToChunk -> firstSampleInCurrentChunk ; if ( ent -> samplesPerChunk ) nb_chunks_for_sample /= ent -> samplesPerChunk ; if ( ( nb_chunks_for_sample <= max_chunks_in_entry ) && ( stbl -> SampleToChunk -> firstSampleInCurrentChunk + ( nb_chunks_for_sample + 1 ) * ent -> samplesPerChunk > sampleNumber ) ) { stbl -> SampleToChunk -> firstSampleInCurrentChunk += nb_chunks_for_sample * ent -> samplesPerChunk ; stbl -> SampleToChunk -> currentChunk += nb_chunks_for_sample ; goto sample_found ; } max_chunks_in_entry += 1 ; stbl -> SampleToChunk -> firstSampleInCurrentChunk += max_chunks_in_entry * ent -> samplesPerChunk ; stbl -> SampleToChunk -> currentChunk += max_chunks_in_entry ; if ( i + 1 != stbl -> SampleToChunk -> nb_entries ) { ent = & stbl -> SampleToChunk -> entries [ i + 1 ] ; GetGhostNum ( ent , i + 1 , stbl -> SampleToChunk -> nb_entries , stbl ) ; stbl -> SampleToChunk -> currentIndex = i + 1 ; stbl -> SampleToChunk -> currentChunk = 1 ; k = 1 ; } } return GF_ISOM_INVALID_FILE ; sample_found : ( * descIndex ) = ent -> sampleDescriptionIndex ; ( * chunkNumber ) = chunk_num = ent -> firstChunk + stbl -> SampleToChunk -> currentChunk - 1 ; if ( out_ent ) * out_ent = ent ; if ( ! * chunkNumber ) return GF_ISOM_INVALID_FILE ; offsetInChunk = 0 ; if ( stbl -> SampleSize && stbl -> SampleSize -> sampleSize ) { u32 diff = sampleNumber - stbl -> SampleToChunk -> firstSampleInCurrentChunk ; offsetInChunk += diff * stbl -> SampleSize -> sampleSize ; } else if ( ( stbl -> r_last_chunk_num == chunk_num ) && ( stbl -> r_last_sample_num == sampleNumber ) ) { offsetInChunk = stbl -> r_last_offset_in_chunk ; } else if ( ( stbl -> r_last_chunk_num == chunk_num ) && ( stbl -> r_last_sample_num + 1 == sampleNumber ) ) { e = stbl_GetSampleSize ( stbl -> SampleSize , stbl -> r_last_sample_num , & size ) ; if ( e ) return e ; stbl -> r_last_offset_in_chunk += size ; stbl -> r_last_sample_num = sampleNumber ; offsetInChunk = stbl -> r_last_offset_in_chunk ; } else { for ( i = stbl -> SampleToChunk -> firstSampleInCurrentChunk ; i < sampleNumber ; i ++ ) { e = stbl_GetSampleSize ( stbl -> SampleSize , i , & size ) ; if ( e ) return e ; offsetInChunk += size ; } stbl -> r_last_chunk_num = chunk_num ; stbl -> r_last_sample_num = sampleNumber ; stbl -> r_last_offset_in_chunk = offsetInChunk ; } if ( stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { stco = ( GF_ChunkOffsetBox * ) stbl -> ChunkOffset ; if ( stco -> nb_entries < ( * chunkNumber ) ) return GF_ISOM_INVALID_FILE ; ( * offset ) = ( u64 ) stco -> offsets [ ( * chunkNumber ) - 1 ] + ( u64 ) offsetInChunk ; } else { co64 = ( GF_ChunkLargeOffsetBox * ) stbl -> ChunkOffset ; if ( co64 -> nb_entries < ( * chunkNumber ) ) return GF_ISOM_INVALID_FILE ; ( * offset ) = co64 -> offsets [ ( * chunkNumber ) - 1 ] + ( u64 ) offsetInChunk ; } return GF_OK ; }
","<S2SV_ModStart> return GF_ISOM_INVALID_FILE ; if ( stco -> nb_entries < sampleNumber ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> co64 -> offsets ) return GF_ISOM_INVALID_FILE ; if ( co64 -> nb_entries < sampleNumber
",CWE-119
469,"CWE-000 static struct sock * sctp_v6_create_accept_sk ( struct sock * sk , struct sctp_association * asoc , bool kern ) { struct sock * newsk ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct sctp6_sock * newsctp6sk ; struct ipv6_txoptions * opt ; newsk = sk_alloc ( sock_net ( sk ) , PF_INET6 , GFP_KERNEL , sk -> sk_prot , kern ) ; if ( ! newsk ) goto out ; sock_init_data ( NULL , newsk ) ; sctp_copy_sock ( newsk , sk , asoc ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; newsctp6sk = ( struct sctp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newsctp6sk -> inet6 ; sctp_sk ( newsk ) -> v4mapped = sctp_sk ( sk ) -> v4mapped ; newnp = inet6_sk ( newsk ) ; <S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug> rcu_read_lock ( ) ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; rcu_read_unlock ( ) ; sctp_v6_to_sk_daddr ( & asoc -> peer . primary_addr , newsk ) ; newsk -> sk_v6_rcv_saddr = sk -> sk_v6_rcv_saddr ; sk_refcnt_debug_inc ( newsk ) ; if ( newsk -> sk_prot -> init ( newsk ) ) { sk_common_release ( newsk ) ; newsk = NULL ; } out : return newsk ; }
","<S2SV_ModStart> ipv6_pinfo ) ) ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL
",CWE-000
470,"CWE-119 void vp8_setup_key_frame ( VP8_COMP * cpi ) { vp8_default_coef_probs ( & cpi -> common ) ; <S2SV_StartBug> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> { int flag [ 2 ] = { 1 , 1 } ; vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cpi -> common . fc . mvc , flag ) ; } <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ; if ( cpi -> auto_gold ) cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; else cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; cpi -> common . refresh_golden_frame = 1 ; cpi -> common . refresh_alt_ref_frame = 1 ; }
","<S2SV_ModStart> common ) ; memcpy <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ; } memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi
",CWE-119
472,"CWE-000 static int kvm_vm_ioctl_set_pit2 ( struct kvm * kvm , struct kvm_pit_state2 * ps ) { <S2SV_StartBug> int start = 0 ; <S2SV_EndBug> u32 prev_legacy , cur_legacy ; mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ; prev_legacy = kvm -> arch . vpit -> pit_state . flags & KVM_PIT_FLAGS_HPET_LEGACY ; cur_legacy = ps -> flags & KVM_PIT_FLAGS_HPET_LEGACY ; if ( ! prev_legacy && cur_legacy ) start = 1 ; memcpy ( & kvm -> arch . vpit -> pit_state . channels , & ps -> channels , sizeof ( kvm -> arch . vpit -> pit_state . channels ) ) ; kvm -> arch . vpit -> pit_state . flags = ps -> flags ; <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; <S2SV_EndBug> mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; return 0 ; }
","<S2SV_ModStart> start = 0 ; int i <S2SV_ModStart> -> flags ; for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> ( kvm , i <S2SV_ModEnd> , kvm -> <S2SV_ModStart> . channels [ i <S2SV_ModEnd> ] . count
",CWE-000
479,"CWE-125 void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; <S2SV_StartBug> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ; remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }
","<S2SV_ModStart> ; sig_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
",CWE-125
481,"CWE-476 jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; <S2SV_StartBug> if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_EndBug> return 0 ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = numrows * numcols ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; }
","<S2SV_ModStart> ; if ( numrows < 0 || numcols < 0 ) { return 0 ; } if (
",CWE-476
483,"CWE-787 static int l2cap_sock_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_l2 la ; int len , err = 0 ; BT_DBG ( ""sk<S2SV_blank>%p"" , sk ) ; if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ; memset ( & la , 0 , sizeof ( la ) ) ; len = min_t ( unsigned int , sizeof ( la ) , alen ) ; memcpy ( & la , addr , len ) ; if ( la . l2_cid ) return - EINVAL ; lock_sock ( sk ) ; if ( sk -> sk_type == SOCK_SEQPACKET && ! la . l2_psm ) { err = - EINVAL ; goto done ; } switch ( l2cap_pi ( sk ) -> mode ) { case L2CAP_MODE_BASIC : break ; case L2CAP_MODE_ERTM : <S2SV_StartBug> if ( enable_ertm ) <S2SV_EndBug> break ; default : err = - ENOTSUPP ; goto done ; } switch ( sk -> sk_state ) { case BT_CONNECT : case BT_CONNECT2 : case BT_CONFIG : goto wait ; case BT_CONNECTED : goto done ; case BT_OPEN : case BT_BOUND : break ; default : err = - EBADFD ; goto done ; } bacpy ( & bt_sk ( sk ) -> dst , & la . l2_bdaddr ) ; l2cap_pi ( sk ) -> psm = la . l2_psm ; err = l2cap_do_connect ( sk ) ; if ( err ) goto done ; wait : err = bt_sock_wait_state ( sk , BT_CONNECTED , sock_sndtimeo ( sk , flags & O_NONBLOCK ) ) ; done : release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING :
",CWE-787
484,"CWE-476 static ExprList * exprListAppendList ( Parse * pParse , ExprList * pList , ExprList * pAppend , int bIntToNull ) { if ( pAppend ) { int i ; int nInit = pList ? pList -> nExpr : 0 ; for ( i = 0 ; i < pAppend -> nExpr ; i ++ ) { Expr * pDup = sqlite3ExprDup ( pParse -> db , pAppend -> a [ i ] . pExpr , 0 ) ; <S2SV_StartBug> if ( bIntToNull && pDup && pDup -> op == TK_INTEGER ) { <S2SV_EndBug> pDup -> op = TK_NULL ; <S2SV_StartBug> pDup -> flags &= ~ ( EP_IntValue | EP_IsTrue | EP_IsFalse ) ; <S2SV_EndBug> } pList = sqlite3ExprListAppend ( pParse , pList , pDup ) ; if ( pList ) pList -> a [ nInit + i ] . sortFlags = pAppend -> a [ i ] . sortFlags ; } } return pList ; }
","<S2SV_ModStart> 0 ) ; assert ( pDup == 0 || ! ExprHasProperty ( pDup , EP_MemToken ) ) ; <S2SV_ModStart> | EP_IsFalse ) ; pDup -> u . zToken = 0
",CWE-476
487,"CWE-125 static u_int ldp_pdu_print ( netdissect_options * ndo , register const u_char * pptr ) { const struct ldp_common_header * ldp_com_header ; const struct ldp_msg_header * ldp_msg_header ; const u_char * tptr , * msg_tptr ; u_short tlen ; u_short pdu_len , msg_len , msg_type , msg_tlen ; int hexdump , processed ; ldp_com_header = ( const struct ldp_common_header * ) pptr ; ND_TCHECK ( * ldp_com_header ) ; if ( EXTRACT_16BITS ( & ldp_com_header -> version ) != LDP_VERSION ) { ND_PRINT ( ( ndo , ""%sLDP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , ( ndo -> ndo_vflag < 1 ) ? """" : ""\\n\\t"" , EXTRACT_16BITS ( & ldp_com_header -> version ) ) ) ; return 0 ; } pdu_len = EXTRACT_16BITS ( & ldp_com_header -> pdu_length ) ; if ( pdu_len < sizeof ( const struct ldp_common_header ) - 4 ) { ND_PRINT ( ( ndo , ""%sLDP,<S2SV_blank>pdu-length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( ndo -> ndo_vflag < 1 ) ? """" : ""\\n\\t"" , pdu_len , ( u_int ) ( sizeof ( const struct ldp_common_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""%sLDP,<S2SV_blank>Label-Space-ID:<S2SV_blank>%s:%u,<S2SV_blank>pdu-length:<S2SV_blank>%u"" , ( ndo -> ndo_vflag < 1 ) ? """" : ""\\n\\t"" , ipaddr_string ( ndo , & ldp_com_header -> lsr_id ) , EXTRACT_16BITS ( & ldp_com_header -> label_space ) , pdu_len ) ) ; if ( ndo -> ndo_vflag < 1 ) return 0 ; tptr = pptr + sizeof ( const struct ldp_common_header ) ; tlen = pdu_len - ( sizeof ( const struct ldp_common_header ) - 4 ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct ldp_msg_header ) ) ; ldp_msg_header = ( const struct ldp_msg_header * ) tptr ; msg_len = EXTRACT_16BITS ( ldp_msg_header -> length ) ; msg_type = LDP_MASK_MSG_TYPE ( EXTRACT_16BITS ( ldp_msg_header -> type ) ) ; if ( msg_len < sizeof ( struct ldp_msg_header ) - 4 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( ldp_msg_values , ""Unknown"" , msg_type ) , msg_type , msg_len , ( u_int ) ( sizeof ( struct ldp_msg_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u,<S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>if<S2SV_blank>unknown]"" , tok2str ( ldp_msg_values , ""Unknown"" , msg_type ) , msg_type , msg_len , EXTRACT_32BITS ( & ldp_msg_header -> id ) , LDP_MASK_U_BIT ( EXTRACT_16BITS ( & ldp_msg_header -> type ) ) ? ""continue<S2SV_blank>processing"" : ""ignore"" ) ) ; msg_tptr = tptr + sizeof ( struct ldp_msg_header ) ; msg_tlen = msg_len - ( sizeof ( struct ldp_msg_header ) - 4 ) ; ND_TCHECK2 ( * tptr , msg_len ) ; hexdump = FALSE ; switch ( msg_type ) { case LDP_MSG_NOTIF : case LDP_MSG_HELLO : case LDP_MSG_INIT : case LDP_MSG_KEEPALIVE : case LDP_MSG_ADDRESS : case LDP_MSG_LABEL_MAPPING : case LDP_MSG_ADDRESS_WITHDRAW : case LDP_MSG_LABEL_WITHDRAW : while ( msg_tlen >= 4 ) { processed = ldp_tlv_print ( ndo , msg_tptr , msg_tlen ) ; if ( processed == 0 ) break ; msg_tlen -= processed ; msg_tptr += processed ; } break ; case LDP_MSG_LABEL_REQUEST : case LDP_MSG_LABEL_RELEASE : case LDP_MSG_LABEL_ABORT_REQUEST : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , msg_tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct ldp_msg_header ) , ""\\n\\t<S2SV_blank><S2SV_blank>"" , msg_len ) ; tptr += msg_len + 4 ; tlen -= msg_len + 4 ; } return pdu_len + 4 ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> ( ndo , ""%s"" , tstr <S2SV_ModEnd> ) ) ;
",CWE-125
491,"CWE-284 ssize_t socket_bytes_available ( const socket_t * socket ) { assert ( socket != NULL ) ; int size = 0 ; <S2SV_StartBug> if ( ioctl ( socket -> fd , FIONREAD , & size ) == - 1 ) <S2SV_EndBug> return - 1 ; return size ; }
","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & size )
",CWE-284
492,"CWE-119 <S2SV_StartBug> static void write_partition ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> int hbs , int mi_row , int mi_col , <S2SV_StartBug> PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) { <S2SV_EndBug> const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ; <S2SV_EndBug> const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ; const int has_cols = ( mi_col + hbs ) < cm -> mi_cols ; if ( has_rows && has_cols ) { vp9_write_token ( w , vp9_partition_tree , probs , & partition_encodings [ p ] ) ; } else if ( ! has_rows && has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_HORZ ) ; <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ; <S2SV_EndBug> } else if ( has_rows && ! has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_VERT ) ; <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ; <S2SV_EndBug> } else { assert ( p == PARTITION_SPLIT ) ; } }
","<S2SV_ModStart> void write_partition ( const VP9_COMMON * const cm , const MACROBLOCKD * const <S2SV_ModEnd> xd , int <S2SV_ModStart> BLOCK_SIZE bsize , vpx_writer <S2SV_ModEnd> * w ) <S2SV_ModStart> ) ; const vpx_prob * const probs = xd -> partition_probs [ ctx ] <S2SV_ModEnd> ; const int <S2SV_ModStart> PARTITION_HORZ ) ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> PARTITION_VERT ) ; vpx_write <S2SV_ModEnd> ( w ,
",CWE-119
493,"CWE-119 static vpx_codec_err_t vp8_destroy ( vpx_codec_alg_priv_t * ctx ) { <S2SV_StartBug> int i ; <S2SV_EndBug> vp8_remove_decoder_instances ( & ctx -> yv12_frame_buffers ) ; <S2SV_StartBug> for ( i = NELEMENTS ( ctx -> mmaps ) - 1 ; i >= 0 ; i -- ) <S2SV_EndBug> { if ( ctx -> mmaps [ i ] . dtor ) ctx -> mmaps [ i ] . dtor ( & ctx -> mmaps [ i ] ) ; } return VPX_CODEC_OK ; }
","<S2SV_ModStart> ctx ) { <S2SV_ModEnd> vp8_remove_decoder_instances ( & <S2SV_ModStart> yv12_frame_buffers ) ; vpx_free ( ctx ) ; <S2SV_ModEnd> return VPX_CODEC_OK ;
",CWE-119
494,"CWE-125 <S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",CWE-125
496,"CWE-119 void vp8_multiframe_quality_enhance ( VP8_COMMON * cm ) { YV12_BUFFER_CONFIG * show = cm -> frame_to_show ; YV12_BUFFER_CONFIG * dest = & cm -> post_proc_buffer ; FRAME_TYPE frame_type = cm -> frame_type ; const MODE_INFO * mode_info_context = cm -> show_frame_mi ; int mb_row ; int mb_col ; int totmap , map [ 4 ] ; int qcurr = cm -> base_qindex ; int qprev = cm -> postproc_state . last_base_qindex ; unsigned char * y_ptr , * u_ptr , * v_ptr ; unsigned char * yd_ptr , * ud_ptr , * vd_ptr ; y_ptr = show -> y_buffer ; u_ptr = show -> u_buffer ; v_ptr = show -> v_buffer ; yd_ptr = dest -> y_buffer ; ud_ptr = dest -> u_buffer ; vd_ptr = dest -> v_buffer ; for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( frame_type == INTER_FRAME ) totmap = qualify_inter_mb ( mode_info_context , map ) ; else totmap = ( frame_type == KEY_FRAME ? 4 : 0 ) ; if ( totmap ) { if ( totmap < 4 ) { int i , j ; for ( i = 0 ; i < 2 ; ++ i ) for ( j = 0 ; j < 2 ; ++ j ) { if ( map [ i * 2 + j ] ) { multiframe_quality_enhance_block ( 8 , qcurr , qprev , y_ptr + 8 * ( i * show -> y_stride + j ) , u_ptr + 4 * ( i * show -> uv_stride + j ) , v_ptr + 4 * ( i * show -> uv_stride + j ) , show -> y_stride , show -> uv_stride , yd_ptr + 8 * ( i * dest -> y_stride + j ) , ud_ptr + 4 * ( i * dest -> uv_stride + j ) , vd_ptr + 4 * ( i * dest -> uv_stride + j ) , dest -> y_stride , dest -> uv_stride ) ; } else { int k ; unsigned char * up = u_ptr + 4 * ( i * show -> uv_stride + j ) ; unsigned char * udp = ud_ptr + 4 * ( i * dest -> uv_stride + j ) ; unsigned char * vp = v_ptr + 4 * ( i * show -> uv_stride + j ) ; unsigned char * vdp = vd_ptr + 4 * ( i * dest -> uv_stride + j ) ; vp8_copy_mem8x8 ( y_ptr + 8 * ( i * show -> y_stride + j ) , show -> y_stride , yd_ptr + 8 * ( i * dest -> y_stride + j ) , dest -> y_stride ) ; for ( k = 0 ; k < 4 ; ++ k , up += show -> uv_stride , udp += dest -> uv_stride , vp += show -> uv_stride , vdp += dest -> uv_stride ) { <S2SV_StartBug> vpx_memcpy ( udp , up , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vdp , vp , 4 ) ; <S2SV_EndBug> } } } } else { multiframe_quality_enhance_block ( 16 , qcurr , qprev , y_ptr , u_ptr , v_ptr , show -> y_stride , show -> uv_stride , yd_ptr , ud_ptr , vd_ptr , dest -> y_stride , dest -> uv_stride ) ; } } else { vp8_copy_mem16x16 ( y_ptr , show -> y_stride , yd_ptr , dest -> y_stride ) ; vp8_copy_mem8x8 ( u_ptr , show -> uv_stride , ud_ptr , dest -> uv_stride ) ; vp8_copy_mem8x8 ( v_ptr , show -> uv_stride , vd_ptr , dest -> uv_stride ) ; } y_ptr += 16 ; u_ptr += 8 ; v_ptr += 8 ; yd_ptr += 16 ; ud_ptr += 8 ; vd_ptr += 8 ; mode_info_context ++ ; } y_ptr += show -> y_stride * 16 - 16 * cm -> mb_cols ; u_ptr += show -> uv_stride * 8 - 8 * cm -> mb_cols ; v_ptr += show -> uv_stride * 8 - 8 * cm -> mb_cols ; yd_ptr += dest -> y_stride * 16 - 16 * cm -> mb_cols ; ud_ptr += dest -> uv_stride * 8 - 8 * cm -> mb_cols ; vd_ptr += dest -> uv_stride * 8 - 8 * cm -> mb_cols ; mode_info_context ++ ; } }
","<S2SV_ModStart> uv_stride ) { memcpy <S2SV_ModEnd> ( udp , <S2SV_ModStart> 4 ) ; memcpy <S2SV_ModEnd> ( vdp ,
",CWE-119
497,"CWE-119 static int check_mem_access ( struct bpf_verifier_env * env , int insn_idx , u32 regno , int off , int bpf_size , enum bpf_access_type t , int value_regno ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = cur_regs ( env ) ; struct bpf_reg_state * reg = regs + regno ; int size , err = 0 ; size = bpf_size_to_bytes ( bpf_size ) ; if ( size < 0 ) return size ; err = check_ptr_alignment ( env , reg , off , size ) ; if ( err ) return err ; off += reg -> off ; if ( reg -> type == PTR_TO_MAP_VALUE ) { if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , ""R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>map\\n"" , value_regno ) ; return - EACCES ; } err = check_map_access ( env , regno , off , size , false ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) mark_reg_unknown ( env , regs , value_regno ) ; } else if ( reg -> type == PTR_TO_CTX ) { enum bpf_reg_type reg_type = SCALAR_VALUE ; if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , ""R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>ctx\\n"" , value_regno ) ; return - EACCES ; } if ( reg -> off ) { verbose ( env , ""dereference<S2SV_blank>of<S2SV_blank>modified<S2SV_blank>ctx<S2SV_blank>ptr<S2SV_blank>R%d<S2SV_blank>off=%d+%d,<S2SV_blank>ctx+const<S2SV_blank>is<S2SV_blank>allowed,<S2SV_blank>ctx+const+const<S2SV_blank>is<S2SV_blank>not\\n"" , regno , reg -> off , off - reg -> off ) ; return - EACCES ; } if ( ! tnum_is_const ( reg -> var_off ) || reg -> var_off . value ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; verbose ( env , ""variable<S2SV_blank>ctx<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d"" , tn_buf , off , size ) ; return - EACCES ; } err = check_ctx_access ( env , insn_idx , off , size , t , & reg_type ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) { if ( reg_type == SCALAR_VALUE ) mark_reg_unknown ( env , regs , value_regno ) ; else mark_reg_known_zero ( env , regs , value_regno ) ; regs [ value_regno ] . id = 0 ; regs [ value_regno ] . off = 0 ; regs [ value_regno ] . range = 0 ; regs [ value_regno ] . type = reg_type ; } } else if ( reg -> type == PTR_TO_STACK ) { if ( ! tnum_is_const ( reg -> var_off ) ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; verbose ( env , ""variable<S2SV_blank>stack<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d"" , tn_buf , off , size ) ; return - EACCES ; } off += reg -> var_off . value ; if ( off >= 0 || off < - MAX_BPF_STACK ) { verbose ( env , ""invalid<S2SV_blank>stack<S2SV_blank>off=%d<S2SV_blank>size=%d\\n"" , off , size ) ; return - EACCES ; } if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ; if ( t == BPF_WRITE ) err = check_stack_write ( env , state , off , size , value_regno ) ; else err = check_stack_read ( env , state , off , size , value_regno ) ; } else if ( reg_is_pkt_pointer ( reg ) ) { if ( t == BPF_WRITE && ! may_access_direct_pkt_data ( env , NULL , t ) ) { verbose ( env , ""cannot<S2SV_blank>write<S2SV_blank>into<S2SV_blank>packet\\n"" ) ; return - EACCES ; } if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , ""R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>packet\\n"" , value_regno ) ; return - EACCES ; } err = check_packet_access ( env , regno , off , size , false ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) mark_reg_unknown ( env , regs , value_regno ) ; } else { verbose ( env , ""R%d<S2SV_blank>invalid<S2SV_blank>mem<S2SV_blank>access<S2SV_blank>\'%s\'\\n"" , regno , reg_type_str [ reg -> type ] ) ; return - EACCES ; } if ( ! err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ && regs [ value_regno ] . type == SCALAR_VALUE ) { <S2SV_StartBug> regs [ value_regno ] . var_off = <S2SV_EndBug> tnum_cast ( regs [ value_regno ] . var_off , size ) ; __update_reg_bounds ( & regs [ value_regno ] ) ; } return err ; }
","<S2SV_ModStart> SCALAR_VALUE ) { coerce_reg_to_size ( & <S2SV_ModStart> [ value_regno ] , size <S2SV_ModEnd> ) ; }
",CWE-119
498,"CWE-20 static gboolean netscreen_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { gint64 offset ; <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; offset = netscreen_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> cap_dst , err , err_info ) ; if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> return FALSE ; if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN ) wth -> file_encap = wth -> phdr . pkt_encap ; else { if ( wth -> file_encap != wth -> phdr . pkt_encap ) wth -> file_encap = WTAP_ENCAP_PER_PACKET ; } * data_offset = offset ; return TRUE ; }
","<S2SV_ModStart> gint64 offset ; <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; offset <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! parse_netscreen_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> wth -> fh <S2SV_ModEnd> , & wth <S2SV_ModStart> wth -> frame_buffer , line
",CWE-20
500,"CWE-552 int oe_iov_pack ( const struct oe_iovec * iov , int iovcnt , void * * buf_out , <S2SV_StartBug> size_t * buf_size_out ) <S2SV_EndBug> { int ret = - 1 ; struct oe_iovec * buf = NULL ; size_t buf_size = 0 ; size_t data_size = 0 ; if ( buf_out ) * buf_out = NULL ; if ( buf_size_out ) * buf_size_out = 0 ; <S2SV_StartBug> if ( iovcnt < 0 || ( iovcnt > 0 && ! iov ) || ! buf_out || ! buf_size_out ) <S2SV_EndBug> goto done ; if ( iovcnt == 0 ) { if ( iov ) { if ( ! ( buf = oe_calloc ( 1 , sizeof ( uint64_t ) ) ) ) goto done ; buf_size = sizeof ( uint64_t ) ; } * buf_out = buf ; <S2SV_StartBug> * buf_size_out = buf_size ; <S2SV_EndBug> buf = NULL ; ret = 0 ; goto done ; } for ( int i = 0 ; i < iovcnt ; i ++ ) data_size += iov [ i ] . iov_len ; buf_size = ( sizeof ( struct oe_iovec ) * ( size_t ) iovcnt ) + data_size ; if ( ! ( buf = oe_calloc ( 1 , buf_size ) ) ) goto done ; { uint8_t * p = ( uint8_t * ) & buf [ iovcnt ] ; size_t n = data_size ; int i ; for ( i = 0 ; i < iovcnt ; i ++ ) { const size_t iov_len = iov [ i ] . iov_len ; const void * iov_base = iov [ i ] . iov_base ; if ( iov_len ) { buf [ i ] . iov_len = iov_len ; buf [ i ] . iov_base = ( void * ) ( p - ( uint8_t * ) buf ) ; if ( ! iov_base ) goto done ; if ( oe_memcpy_s ( p , n , iov_base , iov_len ) != OE_OK ) goto done ; p += iov_len ; n -= iov_len ; } } if ( n != 0 ) goto done ; } * buf_out = buf ; * buf_size_out = buf_size ; <S2SV_StartBug> buf = NULL ; <S2SV_EndBug> ret = 0 ; done : if ( buf ) oe_free ( buf ) ; return ret ; }
","<S2SV_ModStart> size_t * buf_size_out , size_t * data_size_out <S2SV_ModStart> ; if ( data_size_out ) * data_size_out = 0 ; if ( <S2SV_ModStart> || ! buf_size_out || ! data_size_out <S2SV_ModStart> buf_size_out = buf_size ; * data_size_out = data_size <S2SV_ModStart> = buf_size ; * data_size_out = data_size ;
",CWE-552
507,"CWE-119 static void cyclic_background_refresh ( VP8_COMP * cpi , int Q , int lf_adjustment ) { unsigned char * seg_map = cpi -> segmentation_map ; signed char feature_data [ MB_LVL_MAX ] [ MAX_MB_SEGMENTS ] ; int i ; int block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; int mbs_in_frame = cpi -> common . mb_rows * cpi -> common . mb_cols ; cpi -> cyclic_refresh_q = Q / 2 ; <S2SV_StartBug> vpx_memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . frame_type != KEY_FRAME ) <S2SV_EndBug> { i = cpi -> cyclic_refresh_mode_index ; assert ( i < mbs_in_frame ) ; do { if ( cpi -> cyclic_refresh_map [ i ] == 0 ) { seg_map [ i ] = 1 ; block_count -- ; } else if ( cpi -> cyclic_refresh_map [ i ] < 0 ) cpi -> cyclic_refresh_map [ i ] ++ ; i ++ ; if ( i == mbs_in_frame ) i = 0 ; } while ( block_count && i != cpi -> cyclic_refresh_mode_index ) ; <S2SV_StartBug> cpi -> cyclic_refresh_mode_index = i ; <S2SV_EndBug> } cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; enable_segmentation ( cpi ) ; feature_data [ MB_LVL_ALT_Q ] [ 0 ] = 0 ; feature_data [ MB_LVL_ALT_Q ] [ 1 ] = ( cpi -> cyclic_refresh_q - Q ) ; feature_data [ MB_LVL_ALT_Q ] [ 2 ] = 0 ; feature_data [ MB_LVL_ALT_Q ] [ 3 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 0 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 1 ] = lf_adjustment ; feature_data [ MB_LVL_ALT_LF ] [ 2 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 3 ] = 0 ; set_segment_data ( cpi , & feature_data [ 0 ] [ 0 ] , SEGMENT_DELTADATA ) ; }
","<S2SV_ModStart> / 2 ; if ( cpi -> oxcf . screen_content_mode ) { int qp_thresh = ( cpi -> oxcf . screen_content_mode == 2 ) ? 80 : 100 ; if ( Q >= qp_thresh ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } else if ( cpi -> frames_since_key > 250 && Q < 20 && cpi -> mb . skip_true_count > ( int ) ( 0.95 * mbs_in_frame ) ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = 0 ; } else { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; } memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> frame_type != KEY_FRAME && block_count > 0 <S2SV_ModStart> = i ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { if ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive && Q < ( int ) cpi -> denoiser . denoise_pars . qp_thresh && ( cpi -> frames_since_key > 2 * cpi -> denoiser . denoise_pars . consec_zerolast ) ) { cpi -> cyclic_refresh_q = Q ; lf_adjustment = - 40 ; for ( i = 0 ; i < mbs_in_frame ; ++ i ) { seg_map [ i ] = ( cpi -> consec_zero_last [ i ] > cpi -> denoiser . denoise_pars . consec_zerolast ) ? 1 : 0 ; } } } # endif
",CWE-119
510,"CWE-78 void openscript ( char_u * name , int directly ) { if ( curscript + 1 == NSCRIPT ) { emsg ( _ ( e_nesting ) ) ; return ; <S2SV_StartBug> } <S2SV_EndBug> # ifdef FEAT_EVAL if ( ignore_script ) return ; # endif if ( scriptin [ curscript ] != NULL ) ++ curscript ; expand_env ( name , NameBuff , MAXPATHL ) ; if ( ( scriptin [ curscript ] = mch_fopen ( ( char * ) NameBuff , READBIN ) ) == NULL ) { semsg ( _ ( e_notopen ) , name ) ; if ( curscript ) -- curscript ; return ; } if ( save_typebuf ( ) == FAIL ) return ; if ( directly ) { oparg_T oa ; int oldcurscript ; int save_State = State ; int save_restart_edit = restart_edit ; int save_insertmode = p_im ; int save_finish_op = finish_op ; int save_msg_scroll = msg_scroll ; State = NORMAL ; msg_scroll = FALSE ; restart_edit = 0 ; p_im = FALSE ; clear_oparg ( & oa ) ; finish_op = FALSE ; oldcurscript = curscript ; do { update_topline_cursor ( ) ; normal_cmd ( & oa , FALSE ) ; vpeekc ( ) ; } while ( scriptin [ oldcurscript ] != NULL ) ; State = save_State ; msg_scroll = save_msg_scroll ; restart_edit = save_restart_edit ; p_im = save_insertmode ; finish_op = save_finish_op ; } }
","<S2SV_ModStart> return ; } if ( check_secure ( ) ) return ;
",CWE-78
514,"CWE-401 static int rtl8xxxu_submit_int_urb ( struct ieee80211_hw * hw ) { struct rtl8xxxu_priv * priv = hw -> priv ; struct urb * urb ; u32 val32 ; int ret ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) return - ENOMEM ; usb_fill_int_urb ( urb , priv -> udev , priv -> pipe_interrupt , priv -> int_buf , USB_INTR_CONTENT_LENGTH , rtl8xxxu_int_complete , priv , 1 ) ; usb_anchor_urb ( urb , & priv -> int_anchor ) ; ret = usb_submit_urb ( urb , GFP_KERNEL ) ; if ( ret ) { usb_unanchor_urb ( urb ) ; <S2SV_StartBug> goto error ; <S2SV_EndBug> } val32 = rtl8xxxu_read32 ( priv , REG_USB_HIMR ) ; val32 |= USB_HIMR_CPWM ; rtl8xxxu_write32 ( priv , REG_USB_HIMR , val32 ) ; error : return ret ; }
","<S2SV_ModStart> urb ) ; usb_free_urb ( urb ) ;
",CWE-401
517,"CWE-119 <S2SV_StartBug> void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> fadst16_8col ( in0 ) ; fadst16_8col ( in1 ) ; array_transpose_16x16 ( in0 , in1 ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",CWE-119
518,"CWE-20 int ssl3_write_bytes ( SSL * s , int type , const void * buf_ , int len ) { const unsigned char * buf = buf_ ; int tot ; unsigned int n , split_send_fragment , maxpipes ; # if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK unsigned int max_send_fragment , nw ; unsigned int u_len = ( unsigned int ) len ; # endif SSL3_BUFFER * wb = & s -> rlayer . wbuf [ 0 ] ; int i ; if ( len < 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_SSL_NEGATIVE_LENGTH ) ; return - 1 ; } s -> rwstate = SSL_NOTHING ; tot = s -> rlayer . wnum ; if ( ( unsigned int ) len < s -> rlayer . wnum ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_BAD_LENGTH ) ; return - 1 ; } s -> rlayer . wnum = 0 ; if ( SSL_in_init ( s ) && ! ossl_statem_get_in_handshake ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return - 1 ; } } if ( wb -> left != 0 ) { i = ssl3_write_pending ( s , type , & buf [ tot ] , s -> rlayer . wpend_tot ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } tot += i ; } # if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK if ( type == SSL3_RT_APPLICATION_DATA && u_len >= 4 * ( max_send_fragment = s -> max_send_fragment ) && s -> compress == NULL && s -> msg_callback == NULL && <S2SV_StartBug> ! SSL_USE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) && <S2SV_EndBug> EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) { unsigned char aad [ 13 ] ; EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param ; int packlen ; if ( ( max_send_fragment & 0xfff ) == 0 ) max_send_fragment -= 512 ; if ( tot == 0 || wb -> buf == NULL ) { ssl3_release_write_buffer ( s ) ; packlen = EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE , max_send_fragment , NULL ) ; if ( u_len >= 8 * max_send_fragment ) packlen *= 8 ; else packlen *= 4 ; if ( ! ssl3_setup_write_buffer ( s , 1 , packlen ) ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_MALLOC_FAILURE ) ; return - 1 ; } } else if ( tot == len ) { ssl3_release_write_buffer ( s ) ; return tot ; } n = ( len - tot ) ; for ( ; ; ) { if ( n < 4 * max_send_fragment ) { ssl3_release_write_buffer ( s ) ; break ; } if ( s -> s3 -> alert_dispatch ) { i = s -> method -> ssl_dispatch_alert ( s ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } } if ( n >= 8 * max_send_fragment ) nw = max_send_fragment * ( mb_param . interleave = 8 ) ; else nw = max_send_fragment * ( mb_param . interleave = 4 ) ; memcpy ( aad , s -> rlayer . write_sequence , 8 ) ; aad [ 8 ] = type ; aad [ 9 ] = ( unsigned char ) ( s -> version >> 8 ) ; aad [ 10 ] = ( unsigned char ) ( s -> version ) ; aad [ 11 ] = 0 ; aad [ 12 ] = 0 ; mb_param . out = NULL ; mb_param . inp = aad ; mb_param . len = nw ; packlen = EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_AAD , sizeof ( mb_param ) , & mb_param ) ; if ( packlen <= 0 || packlen > ( int ) wb -> len ) { ssl3_release_write_buffer ( s ) ; break ; } mb_param . out = wb -> buf ; mb_param . inp = & buf [ tot ] ; mb_param . len = nw ; if ( EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT , sizeof ( mb_param ) , & mb_param ) <= 0 ) return - 1 ; s -> rlayer . write_sequence [ 7 ] += mb_param . interleave ; if ( s -> rlayer . write_sequence [ 7 ] < mb_param . interleave ) { int j = 6 ; while ( j >= 0 && ( ++ s -> rlayer . write_sequence [ j -- ] ) == 0 ) ; } wb -> offset = 0 ; wb -> left = packlen ; s -> rlayer . wpend_tot = nw ; s -> rlayer . wpend_buf = & buf [ tot ] ; s -> rlayer . wpend_type = type ; s -> rlayer . wpend_ret = nw ; i = ssl3_write_pending ( s , type , & buf [ tot ] , nw ) ; if ( i <= 0 ) { if ( i < 0 && ( ! s -> wbio || ! BIO_should_retry ( s -> wbio ) ) ) { ssl3_release_write_buffer ( s ) ; } s -> rlayer . wnum = tot ; return i ; } if ( i == ( int ) n ) { ssl3_release_write_buffer ( s ) ; return tot + i ; } n -= i ; tot += i ; } } else # endif if ( tot == len ) { if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) ssl3_release_write_buffer ( s ) ; return tot ; } n = ( len - tot ) ; split_send_fragment = s -> split_send_fragment ; maxpipes = s -> max_pipelines ; if ( maxpipes > SSL_MAX_PIPELINES ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( maxpipes == 0 || s -> enc_write_ctx == NULL || ! ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_PIPELINE ) || ! SSL_USE_EXPLICIT_IV ( s ) ) maxpipes = 1 ; if ( s -> max_send_fragment == 0 || split_send_fragment > s -> max_send_fragment || split_send_fragment == 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } for ( ; ; ) { unsigned int pipelens [ SSL_MAX_PIPELINES ] , tmppipelen , remain ; unsigned int numpipes , j ; if ( n == 0 ) numpipes = 1 ; else numpipes = ( ( n - 1 ) / split_send_fragment ) + 1 ; if ( numpipes > maxpipes ) numpipes = maxpipes ; if ( n / numpipes >= s -> max_send_fragment ) { for ( j = 0 ; j < numpipes ; j ++ ) { pipelens [ j ] = s -> max_send_fragment ; } } else { tmppipelen = n / numpipes ; remain = n % numpipes ; for ( j = 0 ; j < numpipes ; j ++ ) { pipelens [ j ] = tmppipelen ; if ( j < remain ) pipelens [ j ] ++ ; } } i = do_ssl3_write ( s , type , & ( buf [ tot ] ) , pipelens , numpipes , 0 ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } if ( ( i == ( int ) n ) || ( type == SSL3_RT_APPLICATION_DATA && ( s -> mode & SSL_MODE_ENABLE_PARTIAL_WRITE ) ) ) { s -> s3 -> empty_fragment_done = 0 ; if ( ( i == ( int ) n ) && s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) ssl3_release_write_buffer ( s ) ; return tot + i ; } n -= i ; tot += i ; } }
","<S2SV_ModStart> NULL && ! SSL_WRITE_ETM <S2SV_ModEnd> ( s )
",CWE-20
521,"CWE-476 rfbClientPtr rfbClientIteratorNext ( rfbClientIteratorPtr i ) <S2SV_StartBug> { <S2SV_EndBug> if ( i -> next == 0 ) { LOCK ( rfbClientListMutex ) ; i -> next = i -> screen -> clientHead ; UNLOCK ( rfbClientListMutex ) ; } else { rfbClientPtr cl = i -> next ; i -> next = i -> next -> next ; rfbDecrClientRef ( cl ) ; } # if defined ( LIBVNCSERVER_HAVE_LIBPTHREAD ) || defined ( LIBVNCSERVER_HAVE_WIN32THREADS ) if ( ! i -> closedToo ) while ( i -> next && i -> next -> sock < 0 ) i -> next = i -> next -> next ; if ( i -> next ) rfbIncrClientRef ( i -> next ) ; # endif return i -> next ; }
","<S2SV_ModStart> i ) { if ( ! i ) return NULL ;
",CWE-476
522,"CWE-119 static int xwd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { AVFrame * p = data ; const uint8_t * buf = avpkt -> data ; int i , ret , buf_size = avpkt -> size ; uint32_t version , header_size , vclass , ncolors ; uint32_t xoffset , be , bpp , lsize , rsize ; uint32_t pixformat , pixdepth , bunit , bitorder , bpad ; uint32_t rgb [ 3 ] ; uint8_t * ptr ; GetByteContext gb ; if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ; bytestream2_init ( & gb , buf , buf_size ) ; header_size = bytestream2_get_be32u ( & gb ) ; version = bytestream2_get_be32u ( & gb ) ; if ( version != XWD_VERSION ) { av_log ( avctx , AV_LOG_ERROR , ""unsupported<S2SV_blank>version\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( buf_size < header_size || header_size < XWD_HEADER_SIZE ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>header<S2SV_blank>size\\n"" ) ; return AVERROR_INVALIDDATA ; } pixformat = bytestream2_get_be32u ( & gb ) ; pixdepth = bytestream2_get_be32u ( & gb ) ; avctx -> width = bytestream2_get_be32u ( & gb ) ; avctx -> height = bytestream2_get_be32u ( & gb ) ; xoffset = bytestream2_get_be32u ( & gb ) ; be = bytestream2_get_be32u ( & gb ) ; bunit = bytestream2_get_be32u ( & gb ) ; bitorder = bytestream2_get_be32u ( & gb ) ; bpad = bytestream2_get_be32u ( & gb ) ; bpp = bytestream2_get_be32u ( & gb ) ; lsize = bytestream2_get_be32u ( & gb ) ; vclass = bytestream2_get_be32u ( & gb ) ; rgb [ 0 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 1 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 2 ] = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , 8 ) ; ncolors = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , header_size - ( XWD_HEADER_SIZE - 20 ) ) ; av_log ( avctx , AV_LOG_DEBUG , ""pixformat<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bunit<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bitorder<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpad<S2SV_blank>%"" PRIu32 ""\\n"" , pixformat , pixdepth , bunit , bitorder , bpad ) ; av_log ( avctx , AV_LOG_DEBUG , ""vclass<S2SV_blank>%"" PRIu32 "",<S2SV_blank>ncolors<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>be<S2SV_blank>%"" PRIu32 "",<S2SV_blank>lsize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>xoffset<S2SV_blank>%"" PRIu32 ""\\n"" , vclass , ncolors , bpp , be , lsize , xoffset ) ; av_log ( avctx , AV_LOG_DEBUG , ""red<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>green<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>blue<S2SV_blank>%0"" PRIx32 ""\\n"" , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; if ( pixformat > XWD_Z_PIXMAP ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>format\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixdepth == 0 || pixdepth > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>depth\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( xoffset ) { avpriv_request_sample ( avctx , ""xoffset<S2SV_blank>%"" PRIu32 """" , xoffset ) ; return AVERROR_PATCHWELCOME ; } if ( be > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>byte<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bitorder > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>bit<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bunit != 8 && bunit != 16 && bunit != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>unit\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpad != 8 && bpad != 16 && bpad != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>scan-line<S2SV_blank>pad\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpp == 0 || bpp > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ncolors > 256 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>colormap\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = av_image_check_size ( avctx -> width , avctx -> height , 0 , NULL ) ) < 0 ) return ret ; rsize = FFALIGN ( avctx -> width * bpp , bpad ) / 8 ; if ( lsize < rsize ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>scan-line\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & gb ) < ncolors * XWD_CMAP_SIZE + ( uint64_t ) avctx -> height * lsize ) { av_log ( avctx , AV_LOG_ERROR , ""input<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixformat != XWD_Z_PIXMAP ) { avpriv_report_missing_feature ( avctx , ""Pixmap<S2SV_blank>format<S2SV_blank>%"" PRIu32 , pixformat ) ; return AVERROR_PATCHWELCOME ; } avctx -> pix_fmt = AV_PIX_FMT_NONE ; switch ( vclass ) { case XWD_STATIC_GRAY : case XWD_GRAY_SCALE : if ( bpp != 1 && bpp != 8 ) return AVERROR_INVALIDDATA ; <S2SV_StartBug> if ( pixdepth == 1 ) { <S2SV_EndBug> avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ; <S2SV_StartBug> } else if ( pixdepth == 8 ) { <S2SV_EndBug> avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; } break ; case XWD_STATIC_COLOR : case XWD_PSEUDO_COLOR : if ( bpp == 8 ) avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; break ; case XWD_TRUE_COLOR : case XWD_DIRECT_COLOR : if ( bpp != 16 && bpp != 24 && bpp != 32 ) return AVERROR_INVALIDDATA ; if ( bpp == 16 && pixdepth == 15 ) { if ( rgb [ 0 ] == 0x7C00 && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x7C00 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE ; } else if ( bpp == 16 && pixdepth == 16 ) { if ( rgb [ 0 ] == 0xF800 && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0xF800 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE ; } else if ( bpp == 24 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24 ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24 ; } else if ( bpp == 32 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA ; } bytestream2_skipu ( & gb , ncolors * XWD_CMAP_SIZE ) ; break ; default : av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>visual<S2SV_blank>class\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( avctx -> pix_fmt == AV_PIX_FMT_NONE ) { avpriv_request_sample ( avctx , ""Unknown<S2SV_blank>file:<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>vclass<S2SV_blank>%"" PRIu32 """" , bpp , pixdepth , vclass ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> key_frame = 1 ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { uint32_t * dst = ( uint32_t * ) p -> data [ 1 ] ; uint8_t red , green , blue ; for ( i = 0 ; i < ncolors ; i ++ ) { bytestream2_skipu ( & gb , 4 ) ; red = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; green = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; blue = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 3 ) ; dst [ i ] = red << 16 | green << 8 | blue ; } } ptr = p -> data [ 0 ] ; for ( i = 0 ; i < avctx -> height ; i ++ ) { bytestream2_get_bufferu ( & gb , ptr , rsize ) ; bytestream2_skipu ( & gb , lsize - rsize ) ; ptr += p -> linesize [ 0 ] ; } * got_frame = 1 ; return buf_size ; }
","<S2SV_ModStart> ; if ( bpp == 1 && <S2SV_ModStart> else if ( bpp == 8 &&
",CWE-119
523,"CWE-119 <S2SV_StartBug> void vp9_loop_filter_frame ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> int frame_filter_level , int y_only , int partial_frame ) { int start_mi_row , end_mi_row , mi_rows_to_filter ; if ( ! frame_filter_level ) return ; start_mi_row = 0 ; mi_rows_to_filter = cm -> mi_rows ; if ( partial_frame && cm -> mi_rows > 8 ) { start_mi_row = cm -> mi_rows >> 1 ; start_mi_row &= 0xfffffff8 ; mi_rows_to_filter = MAX ( cm -> mi_rows / 8 , 8 ) ; } end_mi_row = start_mi_row + mi_rows_to_filter ; vp9_loop_filter_frame_init ( cm , frame_filter_level ) ; <S2SV_StartBug> vp9_loop_filter_rows ( cm -> frame_to_show , cm , xd , <S2SV_EndBug> start_mi_row , end_mi_row , y_only ) ; }
","<S2SV_ModStart> void vp9_loop_filter_frame ( YV12_BUFFER_CONFIG * frame , <S2SV_ModStart> ; vp9_loop_filter_rows ( frame <S2SV_ModEnd> , cm , <S2SV_ModStart> cm , xd -> plane
",CWE-119
524,"CWE-20 error_t udpProcessDatagram ( NetInterface * interface , IpPseudoHeader * pseudoHeader , const NetBuffer * buffer , size_t offset , NetRxAncillary * ancillary ) { error_t error ; uint_t i ; size_t length ; UdpHeader * header ; Socket * socket ; SocketQueueItem * queueItem ; NetBuffer * p ; length = netBufferGetLength ( buffer ) - offset ; if ( length < sizeof ( UdpHeader ) ) { MIB2_INC_COUNTER32 ( udpGroup . udpInErrors , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInErrors , 1 ) ; return ERROR_INVALID_HEADER ; } header = netBufferAt ( buffer , offset ) ; if ( header == NULL ) return ERROR_FAILURE ; TRACE_INFO ( ""UDP<S2SV_blank>datagram<S2SV_blank>received<S2SV_blank>(%"" PRIuSIZE ""<S2SV_blank>bytes)...\\r\\n"" , length ) ; udpDumpHeader ( header ) ; if ( header -> checksum != 0x0000 || pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { if ( ipCalcUpperLayerChecksumEx ( pseudoHeader -> data , pseudoHeader -> length , buffer , offset , length ) != 0x0000 ) { TRACE_WARNING ( ""Wrong<S2SV_blank>UDP<S2SV_blank>header<S2SV_blank>checksum!\\r\\n"" ) ; MIB2_INC_COUNTER32 ( udpGroup . udpInErrors , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInErrors , 1 ) ; return ERROR_WRONG_CHECKSUM ; } } for ( i = 0 ; i < SOCKET_MAX_COUNT ; i ++ ) { socket = socketTable + i ; if ( socket -> type != SOCKET_TYPE_DGRAM ) continue ; if ( socket -> interface && socket -> interface != interface ) continue ; if ( socket -> localPort == 0 || socket -> localPort != ntohs ( header -> destPort ) ) continue ; if ( socket -> remotePort != 0 && socket -> remotePort != ntohs ( header -> srcPort ) ) continue ; # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> localIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . destAddr ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> remoteIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . srcAddr ) continue ; } } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> localIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . destAddr ) ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> remoteIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . srcAddr ) ) continue ; } } else # endif { continue ; } break ; } offset += sizeof ( UdpHeader ) ; length -= sizeof ( UdpHeader ) ; if ( i >= SOCKET_MAX_COUNT ) { error = udpInvokeRxCallback ( interface , pseudoHeader , header , buffer , offset , ancillary ) ; return error ; } if ( socket -> receiveQueue == NULL ) { p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem = netBufferAt ( p , 0 ) ; queueItem -> buffer = p ; socket -> receiveQueue = queueItem ; } else { queueItem = NULL ; } } else { queueItem = socket -> receiveQueue ; for ( i = 1 ; queueItem -> next ; i ++ ) { queueItem = queueItem -> next ; } if ( i >= UDP_RX_QUEUE_SIZE ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_RECEIVE_QUEUE_FULL ; } p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem -> next = netBufferAt ( p , 0 ) ; queueItem = queueItem -> next ; queueItem -> buffer = p ; } else { queueItem = NULL ; } } if ( queueItem == NULL ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_OUT_OF_MEMORY ; } queueItem -> next = NULL ; <S2SV_StartBug> queueItem -> srcPort = ntohs ( header -> srcPort ) ; <S2SV_EndBug> # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> srcIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> destIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . destAddr ; } # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> srcIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> destIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . destAddr ; } # endif queueItem -> offset = sizeof ( SocketQueueItem ) ; netBufferCopy ( queueItem -> buffer , queueItem -> offset , buffer , offset , length ) ; queueItem -> ancillary = * ancillary ; udpUpdateEvents ( socket ) ; MIB2_INC_COUNTER32 ( udpGroup . udpInDatagrams , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInDatagrams , 1 ) ; UDP_MIB_INC_COUNTER64 ( udpHCInDatagrams , 1 ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; queueItem -> interface = interface ; queueItem ->
",CWE-20
525,"CWE-20 void initServerConfig ( ) { server . port = REDIS_SERVERPORT ; server . bindaddr = NULL ; server . unixsocket = NULL ; server . ipfd = - 1 ; server . sofd = - 1 ; server . dbnum = REDIS_DEFAULT_DBNUM ; server . verbosity = REDIS_VERBOSE ; server . maxidletime = REDIS_MAXIDLETIME ; server . saveparams = NULL ; server . loading = 0 ; server . logfile = NULL ; server . syslog_enabled = 0 ; server . syslog_ident = zstrdup ( ""redis"" ) ; server . syslog_facility = LOG_LOCAL0 ; server . glueoutputbuf = 1 ; server . daemonize = 0 ; server . appendonly = 0 ; server . appendfsync = APPENDFSYNC_EVERYSEC ; server . no_appendfsync_on_rewrite = 0 ; server . lastfsync = time ( NULL ) ; server . appendfd = - 1 ; server . appendseldb = - 1 ; server . pidfile = zstrdup ( ""/var/run/redis.pid"" ) ; server . dbfilename = zstrdup ( ""dump.rdb"" ) ; server . appendfilename = zstrdup ( ""appendonly.aof"" ) ; server . requirepass = NULL ; server . rdbcompression = 1 ; server . activerehashing = 1 ; server . maxclients = 0 ; server . bpop_blocked_clients = 0 ; server . maxmemory = 0 ; server . maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU ; server . maxmemory_samples = 3 ; <S2SV_StartBug> server . vm_enabled = 0 ; <S2SV_EndBug> <S2SV_StartBug> server . vm_swap_file = zstrdup ( ""/tmp/redis-%p.vm"" ) ; <S2SV_EndBug> server . vm_page_size = 256 ; server . vm_pages = 1024 * 1024 * 100 ; <S2SV_StartBug> server . vm_max_memory = 1024LL * 1024 * 1024 * 1 ; <S2SV_EndBug> server . vm_max_threads = 4 ; server . vm_blocked_clients = 0 ; server . hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES ; server . hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE ; server . list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES ; server . list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE ; server . set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES ; server . shutdown_asap = 0 ; updateLRUClock ( ) ; resetServerSaveParams ( ) ; appendServerSaveParams ( 60 * 60 , 1 ) ; appendServerSaveParams ( 300 , 100 ) ; appendServerSaveParams ( 60 , 10000 ) ; server . isslave = 0 ; server . masterauth = NULL ; server . masterhost = NULL ; server . masterport = 6379 ; server . master = NULL ; server . replstate = REDIS_REPL_NONE ; server . repl_serve_stale_data = 1 ; R_Zero = 0.0 ; R_PosInf = 1.0 / R_Zero ; R_NegInf = - 1.0 / R_Zero ; R_Nan = R_Zero / R_Zero ; server . commands = dictCreate ( & commandTableDictType , NULL ) ; populateCommandTable ( ) ; server . delCommand = lookupCommandByCString ( ""del"" ) ; server . multiCommand = lookupCommandByCString ( ""multi"" ) ; }
","<S2SV_ModStart> ; server . ds_enabled = 0 ; server . ds_path <S2SV_ModEnd> = zstrdup ( <S2SV_ModStart> = zstrdup ( ""/tmp/redis.ds"" ) ; server . cache_max_memory = 64LL <S2SV_ModEnd> * 1024 * <S2SV_ModStart> 1024 * 1024 ; server . cache_blocked_clients <S2SV_ModEnd> = 0 ;
",CWE-20
526,"CWE-119 static int evaluate_inter_mode ( unsigned int * sse , int rate2 , int * distortion2 , VP8_COMP * cpi , MACROBLOCK * x , int rd_adj ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; int_mv mv = x -> e_mbd . mode_info_context -> mbmi . mv ; <S2SV_StartBug> int this_rd ; <S2SV_EndBug> if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) { * sse = 0 ; * distortion2 = 0 ; x -> skip = 1 ; return INT_MAX ; } if ( ( this_mode != NEWMV ) || ! ( cpi -> sf . half_pixel_search ) || cpi -> common . full_pixel == 1 ) * distortion2 = vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , sse , mv ) ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , * distortion2 ) ; <S2SV_StartBug> if ( this_mode == ZEROMV ) <S2SV_EndBug> { <S2SV_StartBug> if ( ( cpi -> ref_frame_flags & VP8_LAST_FRAME & <S2SV_EndBug> cpi -> common . refresh_last_frame ) && x -> e_mbd . mode_info_context -> mbmi . ref_frame != LAST_FRAME ) rd_adj = 100 ; this_rd = ( ( int64_t ) this_rd ) * rd_adj / 100 ; } check_for_encode_breakout ( * sse , x ) ; return this_rd ; }
","<S2SV_ModStart> ; int this_rd ; int denoise_aggressive = 0 <S2SV_ModStart> distortion2 ) ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { denoise_aggressive = ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive ) ? 1 : 0 ; } # endif if ( ! cpi -> oxcf . screen_content_mode && <S2SV_ModEnd> this_mode == ZEROMV <S2SV_ModStart> this_mode == ZEROMV && x -> e_mbd . mode_info_context -> mbmi . ref_frame == LAST_FRAME && ( denoise_aggressive || ( cpi -> closest_reference_frame == LAST_FRAME ) ) <S2SV_ModStart> { if ( x -> is_skin <S2SV_ModEnd> ) rd_adj =
",CWE-119
527,"CWE-401 int adis_update_scan_mode ( struct iio_dev * indio_dev , const unsigned long * scan_mask ) { struct adis * adis = iio_device_get_drvdata ( indio_dev ) ; const struct iio_chan_spec * chan ; unsigned int scan_count ; unsigned int i , j ; __be16 * tx , * rx ; kfree ( adis -> xfer ) ; kfree ( adis -> buffer ) ; if ( adis -> burst && adis -> burst -> en ) return adis_update_scan_mode_burst ( indio_dev , scan_mask ) ; scan_count = indio_dev -> scan_bytes / 2 ; adis -> xfer = kcalloc ( scan_count + 1 , sizeof ( * adis -> xfer ) , GFP_KERNEL ) ; if ( ! adis -> xfer ) return - ENOMEM ; adis -> buffer = kcalloc ( indio_dev -> scan_bytes , 2 , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! adis -> buffer ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> rx = adis -> buffer ; <S2SV_EndBug> tx = rx + scan_count ; spi_message_init ( & adis -> msg ) ; for ( j = 0 ; j <= scan_count ; j ++ ) { adis -> xfer [ j ] . bits_per_word = 8 ; if ( j != scan_count ) adis -> xfer [ j ] . cs_change = 1 ; adis -> xfer [ j ] . len = 2 ; adis -> xfer [ j ] . delay_usecs = adis -> data -> read_delay ; if ( j < scan_count ) adis -> xfer [ j ] . tx_buf = & tx [ j ] ; if ( j >= 1 ) adis -> xfer [ j ] . rx_buf = & rx [ j - 1 ] ; spi_message_add_tail ( & adis -> xfer [ j ] , & adis -> msg ) ; } chan = indio_dev -> channels ; for ( i = 0 ; i < indio_dev -> num_channels ; i ++ , chan ++ ) { if ( ! test_bit ( chan -> scan_index , scan_mask ) ) continue ; if ( chan -> scan_type . storagebits == 32 ) * tx ++ = cpu_to_be16 ( ( chan -> address + 2 ) << 8 ) ; * tx ++ = cpu_to_be16 ( chan -> address << 8 ) ; } return 0 ; }
","<S2SV_ModStart> -> buffer ) { kfree ( adis -> xfer ) ; adis -> xfer = NULL ; <S2SV_ModStart> - ENOMEM ; }
",CWE-401
529,"CWE-401 static int8_t parse_ext_option ( uint16_t * dst , uint8_t * * packet_data_pptr , uint8_t * packet_data_start_ptr , uint16_t packet_len , uint16_t * message_left ) { uint16_t option_number = * dst ; if ( option_number == 13 ) { uint8_t option_ext ; int8_t read_result = sn_coap_parser_read_packet_u8 ( & option_ext , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } else { <S2SV_StartBug> option_number += option_ext ; <S2SV_EndBug> * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; } } else if ( option_number == 14 ) { int8_t read_result = sn_coap_parser_read_packet_u16 ( & option_number , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } else { <S2SV_StartBug> option_number += 269 ; <S2SV_EndBug> * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 2 ) ; } } else if ( option_number == 15 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>option<S2SV_blank>number(15)!"" ) ; return - 1 ; } * dst = option_number ; return 0 ; }
","<S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , option_ext , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left = <S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , 269 , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left =
",CWE-401
530,"CWE-416 void usb_sg_cancel ( struct usb_sg_request * io ) { unsigned long flags ; int i , retval ; spin_lock_irqsave ( & io -> lock , flags ) ; <S2SV_StartBug> if ( io -> status ) { <S2SV_EndBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; return ; } io -> status = - ECONNRESET ; <S2SV_StartBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; <S2SV_EndBug> for ( i = io -> entries - 1 ; i >= 0 ; -- i ) { usb_block_urb ( io -> urbs [ i ] ) ; retval = usb_unlink_urb ( io -> urbs [ i ] ) ; if ( retval != - EINPROGRESS && retval != - ENODEV && retval != - EBUSY && retval != - EIDRM ) dev_warn ( & io -> dev -> dev , ""%s,<S2SV_blank>unlink<S2SV_blank>--><S2SV_blank>%d\\n"" , __func__ , retval ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> io -> status || io -> count == 0 <S2SV_ModStart> - ECONNRESET ; io -> count ++ ; <S2SV_ModStart> ) ; } spin_lock_irqsave ( & io -> lock , flags ) ; io -> count -- ; if ( ! io -> count ) complete ( & io -> complete ) ; spin_unlock_irqrestore ( & io -> lock , flags ) ;
",CWE-416
531,"CWE-20 error_t getHostByName ( NetInterface * interface , const char_t * name , IpAddr * ipAddr , uint_t flags ) { error_t error ; HostType type ; HostnameResolver protocol ; # if ( IPV4_SUPPORT == ENABLED ) type = HOST_TYPE_IPV4 ; # elif ( IPV6_SUPPORT == ENABLED ) type = HOST_TYPE_IPV6 ; # else type = HOST_TYPE_ANY ; # endif # if ( DNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_DNS ; # elif ( MDNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_MDNS ; # elif ( NBNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_NBNS ; # elif ( LLMNR_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_LLMNR ; # else protocol = HOST_NAME_RESOLVER_ANY ; # endif if ( name == NULL || ipAddr == NULL ) return ERROR_INVALID_PARAMETER ; if ( interface == NULL ) interface = netGetDefaultInterface ( ) ; error = ipStringToAddr ( name , ipAddr ) ; if ( error ) { if ( flags & HOST_TYPE_IPV4 ) type = HOST_TYPE_IPV4 ; else if ( flags & HOST_TYPE_IPV6 ) type = HOST_TYPE_IPV6 ; if ( flags & HOST_NAME_RESOLVER_DNS ) { protocol = HOST_NAME_RESOLVER_DNS ; } else if ( flags & HOST_NAME_RESOLVER_MDNS ) { protocol = HOST_NAME_RESOLVER_MDNS ; } else if ( flags & HOST_NAME_RESOLVER_NBNS ) { protocol = HOST_NAME_RESOLVER_NBNS ; } else if ( flags & HOST_NAME_RESOLVER_LLMNR ) { protocol = HOST_NAME_RESOLVER_LLMNR ; } else { size_t n = osStrlen ( name ) ; if ( n >= 6 && ! osStrcasecmp ( name + n - 6 , "".local"" ) ) { # if ( MDNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_MDNS ; # endif } <S2SV_StartBug> else if ( n <= 15 && ! strchr ( name , '.' ) && type == HOST_TYPE_IPV4 ) <S2SV_EndBug> { # if ( NBNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_NBNS ; # endif } <S2SV_StartBug> else if ( ! strchr ( name , '.' ) ) <S2SV_EndBug> { # if ( LLMNR_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_LLMNR ; # endif } } # if ( DNS_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_DNS ) { error = dnsResolve ( interface , name , type , ipAddr ) ; } else # endif # if ( MDNS_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_MDNS ) { error = mdnsClientResolve ( interface , name , type , ipAddr ) ; } else # endif # if ( NBNS_CLIENT_SUPPORT == ENABLED && IPV4_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_NBNS ) { error = nbnsResolve ( interface , name , ipAddr ) ; } else # endif # if ( LLMNR_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_LLMNR ) { error = llmnrResolve ( interface , name , type , ipAddr ) ; } else # endif { error = ERROR_INVALID_PARAMETER ; } } return error ; }
","<S2SV_ModStart> 15 && ! osStrchr <S2SV_ModEnd> ( name , <S2SV_ModStart> if ( ! osStrchr <S2SV_ModEnd> ( name ,
",CWE-20
532,"CWE-125 int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; int hroom , troom ; __be32 frag_id ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; <S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) goto fail_toobig ; if ( IP6CB ( skb ) -> frag_max_size ) { if ( IP6CB ( skb ) -> frag_max_size > mtu ) goto fail_toobig ; mtu = IP6CB ( skb ) -> frag_max_size ; if ( mtu < IPV6_MIN_MTU ) mtu = IPV6_MIN_MTU ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) goto fail_toobig ; mtu -= hlen + sizeof ( struct frag_hdr ) ; frag_id = ipv6_select_ident ( net , & ipv6_hdr ( skb ) -> daddr , & ipv6_hdr ( skb ) -> saddr ) ; if ( skb -> ip_summed == CHECKSUM_PARTIAL && ( err = skb_checksum_help ( skb ) ) ) goto fail ; hroom = LL_RESERVED_SPACE ( rt -> dst . dev ) ; if ( skb_has_frag_list ( skb ) ) { unsigned int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) || skb_headroom ( skb ) < ( hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < ( hlen + hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; fh -> identification = frag_id ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( net , sk , skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; ip6_rt_put ( rt ) ; return 0 ; } kfree_skb_list ( frag ) ; IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; ip6_rt_put ( rt ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; troom = rt -> dst . dev -> needed_tailroom ; while ( left > 0 ) { u8 * fragnexthdr_offset ; len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + hroom + troom , GFP_ATOMIC ) ; if ( ! frag ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , hroom ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fragnexthdr_offset = skb_network_header ( frag ) ; fragnexthdr_offset += prevhdr - skb_network_header ( skb ) ; * fragnexthdr_offset = NEXTHDR_FRAGMENT ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> identification = frag_id ; BUG_ON ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( net , sk , frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; consume_skb ( skb ) ; return err ; fail_toobig : if ( skb -> sk && dst_allfrag ( skb_dst ( skb ) ) ) sk_nocaps_add ( skb -> sk , NETIF_F_GSO_MASK ) ; skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; err = - EMSGSIZE ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }
","<S2SV_ModStart> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }
",CWE-125
535,"CWE-119 <S2SV_StartBug> void fadst8_sse2 ( __m128i * in ) { <S2SV_EndBug> const __m128i k__cospi_p02_p30 = pair_set_epi16 ( cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_p30_m02 = pair_set_epi16 ( cospi_30_64 , - cospi_2_64 ) ; const __m128i k__cospi_p10_p22 = pair_set_epi16 ( cospi_10_64 , cospi_22_64 ) ; const __m128i k__cospi_p22_m10 = pair_set_epi16 ( cospi_22_64 , - cospi_10_64 ) ; const __m128i k__cospi_p18_p14 = pair_set_epi16 ( cospi_18_64 , cospi_14_64 ) ; const __m128i k__cospi_p14_m18 = pair_set_epi16 ( cospi_14_64 , - cospi_18_64 ) ; const __m128i k__cospi_p26_p06 = pair_set_epi16 ( cospi_26_64 , cospi_6_64 ) ; const __m128i k__cospi_p06_m26 = pair_set_epi16 ( cospi_6_64 , - cospi_26_64 ) ; const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ; const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> const __m128i k__const_0 = _mm_set1_epi16 ( 0 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; __m128i u0 , u1 , u2 , u3 , u4 , u5 , u6 , u7 , u8 , u9 , u10 , u11 , u12 , u13 , u14 , u15 ; __m128i v0 , v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 ; __m128i w0 , w1 , w2 , w3 , w4 , w5 , w6 , w7 , w8 , w9 , w10 , w11 , w12 , w13 , w14 , w15 ; __m128i s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; __m128i in0 , in1 , in2 , in3 , in4 , in5 , in6 , in7 ; in0 = in [ 7 ] ; in1 = in [ 0 ] ; in2 = in [ 5 ] ; in3 = in [ 2 ] ; in4 = in [ 3 ] ; in5 = in [ 4 ] ; in6 = in [ 1 ] ; in7 = in [ 6 ] ; s0 = _mm_unpacklo_epi16 ( in0 , in1 ) ; s1 = _mm_unpackhi_epi16 ( in0 , in1 ) ; s2 = _mm_unpacklo_epi16 ( in2 , in3 ) ; s3 = _mm_unpackhi_epi16 ( in2 , in3 ) ; s4 = _mm_unpacklo_epi16 ( in4 , in5 ) ; s5 = _mm_unpackhi_epi16 ( in4 , in5 ) ; s6 = _mm_unpacklo_epi16 ( in6 , in7 ) ; s7 = _mm_unpackhi_epi16 ( in6 , in7 ) ; u0 = _mm_madd_epi16 ( s0 , k__cospi_p02_p30 ) ; u1 = _mm_madd_epi16 ( s1 , k__cospi_p02_p30 ) ; u2 = _mm_madd_epi16 ( s0 , k__cospi_p30_m02 ) ; u3 = _mm_madd_epi16 ( s1 , k__cospi_p30_m02 ) ; u4 = _mm_madd_epi16 ( s2 , k__cospi_p10_p22 ) ; u5 = _mm_madd_epi16 ( s3 , k__cospi_p10_p22 ) ; u6 = _mm_madd_epi16 ( s2 , k__cospi_p22_m10 ) ; u7 = _mm_madd_epi16 ( s3 , k__cospi_p22_m10 ) ; u8 = _mm_madd_epi16 ( s4 , k__cospi_p18_p14 ) ; u9 = _mm_madd_epi16 ( s5 , k__cospi_p18_p14 ) ; u10 = _mm_madd_epi16 ( s4 , k__cospi_p14_m18 ) ; u11 = _mm_madd_epi16 ( s5 , k__cospi_p14_m18 ) ; u12 = _mm_madd_epi16 ( s6 , k__cospi_p26_p06 ) ; u13 = _mm_madd_epi16 ( s7 , k__cospi_p26_p06 ) ; u14 = _mm_madd_epi16 ( s6 , k__cospi_p06_m26 ) ; u15 = _mm_madd_epi16 ( s7 , k__cospi_p06_m26 ) ; w0 = _mm_add_epi32 ( u0 , u8 ) ; w1 = _mm_add_epi32 ( u1 , u9 ) ; w2 = _mm_add_epi32 ( u2 , u10 ) ; w3 = _mm_add_epi32 ( u3 , u11 ) ; w4 = _mm_add_epi32 ( u4 , u12 ) ; w5 = _mm_add_epi32 ( u5 , u13 ) ; w6 = _mm_add_epi32 ( u6 , u14 ) ; w7 = _mm_add_epi32 ( u7 , u15 ) ; w8 = _mm_sub_epi32 ( u0 , u8 ) ; w9 = _mm_sub_epi32 ( u1 , u9 ) ; w10 = _mm_sub_epi32 ( u2 , u10 ) ; w11 = _mm_sub_epi32 ( u3 , u11 ) ; w12 = _mm_sub_epi32 ( u4 , u12 ) ; w13 = _mm_sub_epi32 ( u5 , u13 ) ; w14 = _mm_sub_epi32 ( u6 , u14 ) ; w15 = _mm_sub_epi32 ( u7 , u15 ) ; v0 = _mm_add_epi32 ( w0 , k__DCT_CONST_ROUNDING ) ; v1 = _mm_add_epi32 ( w1 , k__DCT_CONST_ROUNDING ) ; v2 = _mm_add_epi32 ( w2 , k__DCT_CONST_ROUNDING ) ; v3 = _mm_add_epi32 ( w3 , k__DCT_CONST_ROUNDING ) ; v4 = _mm_add_epi32 ( w4 , k__DCT_CONST_ROUNDING ) ; v5 = _mm_add_epi32 ( w5 , k__DCT_CONST_ROUNDING ) ; v6 = _mm_add_epi32 ( w6 , k__DCT_CONST_ROUNDING ) ; v7 = _mm_add_epi32 ( w7 , k__DCT_CONST_ROUNDING ) ; v8 = _mm_add_epi32 ( w8 , k__DCT_CONST_ROUNDING ) ; v9 = _mm_add_epi32 ( w9 , k__DCT_CONST_ROUNDING ) ; v10 = _mm_add_epi32 ( w10 , k__DCT_CONST_ROUNDING ) ; v11 = _mm_add_epi32 ( w11 , k__DCT_CONST_ROUNDING ) ; v12 = _mm_add_epi32 ( w12 , k__DCT_CONST_ROUNDING ) ; v13 = _mm_add_epi32 ( w13 , k__DCT_CONST_ROUNDING ) ; v14 = _mm_add_epi32 ( w14 , k__DCT_CONST_ROUNDING ) ; v15 = _mm_add_epi32 ( w15 , k__DCT_CONST_ROUNDING ) ; u0 = _mm_srai_epi32 ( v0 , DCT_CONST_BITS ) ; u1 = _mm_srai_epi32 ( v1 , DCT_CONST_BITS ) ; u2 = _mm_srai_epi32 ( v2 , DCT_CONST_BITS ) ; u3 = _mm_srai_epi32 ( v3 , DCT_CONST_BITS ) ; u4 = _mm_srai_epi32 ( v4 , DCT_CONST_BITS ) ; u5 = _mm_srai_epi32 ( v5 , DCT_CONST_BITS ) ; u6 = _mm_srai_epi32 ( v6 , DCT_CONST_BITS ) ; u7 = _mm_srai_epi32 ( v7 , DCT_CONST_BITS ) ; u8 = _mm_srai_epi32 ( v8 , DCT_CONST_BITS ) ; u9 = _mm_srai_epi32 ( v9 , DCT_CONST_BITS ) ; u10 = _mm_srai_epi32 ( v10 , DCT_CONST_BITS ) ; u11 = _mm_srai_epi32 ( v11 , DCT_CONST_BITS ) ; u12 = _mm_srai_epi32 ( v12 , DCT_CONST_BITS ) ; u13 = _mm_srai_epi32 ( v13 , DCT_CONST_BITS ) ; u14 = _mm_srai_epi32 ( v14 , DCT_CONST_BITS ) ; u15 = _mm_srai_epi32 ( v15 , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u0 , u1 ) ; in [ 1 ] = _mm_packs_epi32 ( u2 , u3 ) ; in [ 2 ] = _mm_packs_epi32 ( u4 , u5 ) ; in [ 3 ] = _mm_packs_epi32 ( u6 , u7 ) ; in [ 4 ] = _mm_packs_epi32 ( u8 , u9 ) ; in [ 5 ] = _mm_packs_epi32 ( u10 , u11 ) ; in [ 6 ] = _mm_packs_epi32 ( u12 , u13 ) ; in [ 7 ] = _mm_packs_epi32 ( u14 , u15 ) ; s0 = _mm_add_epi16 ( in [ 0 ] , in [ 2 ] ) ; s1 = _mm_add_epi16 ( in [ 1 ] , in [ 3 ] ) ; s2 = _mm_sub_epi16 ( in [ 0 ] , in [ 2 ] ) ; s3 = _mm_sub_epi16 ( in [ 1 ] , in [ 3 ] ) ; u0 = _mm_unpacklo_epi16 ( in [ 4 ] , in [ 5 ] ) ; u1 = _mm_unpackhi_epi16 ( in [ 4 ] , in [ 5 ] ) ; u2 = _mm_unpacklo_epi16 ( in [ 6 ] , in [ 7 ] ) ; u3 = _mm_unpackhi_epi16 ( in [ 6 ] , in [ 7 ] ) ; v0 = _mm_madd_epi16 ( u0 , k__cospi_p08_p24 ) ; v1 = _mm_madd_epi16 ( u1 , k__cospi_p08_p24 ) ; v2 = _mm_madd_epi16 ( u0 , k__cospi_p24_m08 ) ; v3 = _mm_madd_epi16 ( u1 , k__cospi_p24_m08 ) ; v4 = _mm_madd_epi16 ( u2 , k__cospi_m24_p08 ) ; v5 = _mm_madd_epi16 ( u3 , k__cospi_m24_p08 ) ; v6 = _mm_madd_epi16 ( u2 , k__cospi_p08_p24 ) ; v7 = _mm_madd_epi16 ( u3 , k__cospi_p08_p24 ) ; w0 = _mm_add_epi32 ( v0 , v4 ) ; w1 = _mm_add_epi32 ( v1 , v5 ) ; w2 = _mm_add_epi32 ( v2 , v6 ) ; w3 = _mm_add_epi32 ( v3 , v7 ) ; w4 = _mm_sub_epi32 ( v0 , v4 ) ; w5 = _mm_sub_epi32 ( v1 , v5 ) ; w6 = _mm_sub_epi32 ( v2 , v6 ) ; w7 = _mm_sub_epi32 ( v3 , v7 ) ; v0 = _mm_add_epi32 ( w0 , k__DCT_CONST_ROUNDING ) ; v1 = _mm_add_epi32 ( w1 , k__DCT_CONST_ROUNDING ) ; v2 = _mm_add_epi32 ( w2 , k__DCT_CONST_ROUNDING ) ; v3 = _mm_add_epi32 ( w3 , k__DCT_CONST_ROUNDING ) ; v4 = _mm_add_epi32 ( w4 , k__DCT_CONST_ROUNDING ) ; v5 = _mm_add_epi32 ( w5 , k__DCT_CONST_ROUNDING ) ; v6 = _mm_add_epi32 ( w6 , k__DCT_CONST_ROUNDING ) ; v7 = _mm_add_epi32 ( w7 , k__DCT_CONST_ROUNDING ) ; u0 = _mm_srai_epi32 ( v0 , DCT_CONST_BITS ) ; u1 = _mm_srai_epi32 ( v1 , DCT_CONST_BITS ) ; u2 = _mm_srai_epi32 ( v2 , DCT_CONST_BITS ) ; u3 = _mm_srai_epi32 ( v3 , DCT_CONST_BITS ) ; u4 = _mm_srai_epi32 ( v4 , DCT_CONST_BITS ) ; u5 = _mm_srai_epi32 ( v5 , DCT_CONST_BITS ) ; u6 = _mm_srai_epi32 ( v6 , DCT_CONST_BITS ) ; u7 = _mm_srai_epi32 ( v7 , DCT_CONST_BITS ) ; s4 = _mm_packs_epi32 ( u0 , u1 ) ; s5 = _mm_packs_epi32 ( u2 , u3 ) ; s6 = _mm_packs_epi32 ( u4 , u5 ) ; s7 = _mm_packs_epi32 ( u6 , u7 ) ; u0 = _mm_unpacklo_epi16 ( s2 , s3 ) ; u1 = _mm_unpackhi_epi16 ( s2 , s3 ) ; u2 = _mm_unpacklo_epi16 ( s6 , s7 ) ; u3 = _mm_unpackhi_epi16 ( s6 , s7 ) ; v0 = _mm_madd_epi16 ( u0 , k__cospi_p16_p16 ) ; v1 = _mm_madd_epi16 ( u1 , k__cospi_p16_p16 ) ; v2 = _mm_madd_epi16 ( u0 , k__cospi_p16_m16 ) ; v3 = _mm_madd_epi16 ( u1 , k__cospi_p16_m16 ) ; v4 = _mm_madd_epi16 ( u2 , k__cospi_p16_p16 ) ; v5 = _mm_madd_epi16 ( u3 , k__cospi_p16_p16 ) ; v6 = _mm_madd_epi16 ( u2 , k__cospi_p16_m16 ) ; v7 = _mm_madd_epi16 ( u3 , k__cospi_p16_m16 ) ; u0 = _mm_add_epi32 ( v0 , k__DCT_CONST_ROUNDING ) ; u1 = _mm_add_epi32 ( v1 , k__DCT_CONST_ROUNDING ) ; u2 = _mm_add_epi32 ( v2 , k__DCT_CONST_ROUNDING ) ; u3 = _mm_add_epi32 ( v3 , k__DCT_CONST_ROUNDING ) ; u4 = _mm_add_epi32 ( v4 , k__DCT_CONST_ROUNDING ) ; u5 = _mm_add_epi32 ( v5 , k__DCT_CONST_ROUNDING ) ; u6 = _mm_add_epi32 ( v6 , k__DCT_CONST_ROUNDING ) ; u7 = _mm_add_epi32 ( v7 , k__DCT_CONST_ROUNDING ) ; v0 = _mm_srai_epi32 ( u0 , DCT_CONST_BITS ) ; v1 = _mm_srai_epi32 ( u1 , DCT_CONST_BITS ) ; v2 = _mm_srai_epi32 ( u2 , DCT_CONST_BITS ) ; v3 = _mm_srai_epi32 ( u3 , DCT_CONST_BITS ) ; v4 = _mm_srai_epi32 ( u4 , DCT_CONST_BITS ) ; v5 = _mm_srai_epi32 ( u5 , DCT_CONST_BITS ) ; v6 = _mm_srai_epi32 ( u6 , DCT_CONST_BITS ) ; v7 = _mm_srai_epi32 ( u7 , DCT_CONST_BITS ) ; s2 = _mm_packs_epi32 ( v0 , v1 ) ; s3 = _mm_packs_epi32 ( v2 , v3 ) ; s6 = _mm_packs_epi32 ( v4 , v5 ) ; s7 = _mm_packs_epi32 ( v6 , v7 ) ; in [ 0 ] = s0 ; in [ 1 ] = _mm_sub_epi16 ( k__const_0 , s4 ) ; in [ 2 ] = s6 ; in [ 3 ] = _mm_sub_epi16 ( k__const_0 , s2 ) ; in [ 4 ] = s3 ; in [ 5 ] = _mm_sub_epi16 ( k__const_0 , s7 ) ; in [ 6 ] = s5 ; in [ 7 ] = _mm_sub_epi16 ( k__const_0 , s1 ) ; array_transpose_8x8 ( in , in ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t )
",CWE-119
538,"CWE-835 void dwg_free_object ( Dwg_Object * obj ) { int error = 0 ; long unsigned int j ; Dwg_Data * dwg ; Bit_Chain * dat = & pdat ; if ( obj && obj -> parent ) { dwg = obj -> parent ; dat -> version = dwg -> header . version ; } else return ; if ( obj -> type == DWG_TYPE_FREED || obj -> tio . object == NULL ) return ; dat -> from_version = dat -> version ; if ( obj -> supertype == DWG_SUPERTYPE_UNKNOWN ) goto unhandled ; switch ( obj -> type ) { case DWG_TYPE_TEXT : dwg_free_TEXT ( dat , obj ) ; break ; case DWG_TYPE_ATTRIB : dwg_free_ATTRIB ( dat , obj ) ; break ; case DWG_TYPE_ATTDEF : dwg_free_ATTDEF ( dat , obj ) ; break ; case DWG_TYPE_BLOCK : dwg_free_BLOCK ( dat , obj ) ; break ; case DWG_TYPE_ENDBLK : dwg_free_ENDBLK ( dat , obj ) ; break ; case DWG_TYPE_SEQEND : dwg_free_SEQEND ( dat , obj ) ; break ; case DWG_TYPE_INSERT : dwg_free_INSERT ( dat , obj ) ; break ; case DWG_TYPE_MINSERT : dwg_free_MINSERT ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_2D : dwg_free_VERTEX_2D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_3D : dwg_free_VERTEX_3D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_MESH : dwg_free_VERTEX_MESH ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE : dwg_free_VERTEX_PFACE ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE_FACE : dwg_free_VERTEX_PFACE_FACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_2D : dwg_free_POLYLINE_2D ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_3D : dwg_free_POLYLINE_3D ( dat , obj ) ; break ; case DWG_TYPE_ARC : dwg_free_ARC ( dat , obj ) ; break ; case DWG_TYPE_CIRCLE : dwg_free_CIRCLE ( dat , obj ) ; break ; case DWG_TYPE_LINE : dwg_free_LINE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ORDINATE : dwg_free_DIMENSION_ORDINATE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_LINEAR : dwg_free_DIMENSION_LINEAR ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ALIGNED : dwg_free_DIMENSION_ALIGNED ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG3PT : dwg_free_DIMENSION_ANG3PT ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG2LN : dwg_free_DIMENSION_ANG2LN ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_RADIUS : dwg_free_DIMENSION_RADIUS ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_DIAMETER : dwg_free_DIMENSION_DIAMETER ( dat , obj ) ; break ; case DWG_TYPE_POINT : dwg_free_POINT ( dat , obj ) ; break ; case DWG_TYPE__3DFACE : dwg_free__3DFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_PFACE : dwg_free_POLYLINE_PFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_MESH : dwg_free_POLYLINE_MESH ( dat , obj ) ; break ; case DWG_TYPE_SOLID : dwg_free_SOLID ( dat , obj ) ; break ; case DWG_TYPE_TRACE : dwg_free_TRACE ( dat , obj ) ; break ; case DWG_TYPE_SHAPE : dwg_free_SHAPE ( dat , obj ) ; break ; case DWG_TYPE_VIEWPORT : dwg_free_VIEWPORT ( dat , obj ) ; break ; case DWG_TYPE_ELLIPSE : dwg_free_ELLIPSE ( dat , obj ) ; break ; case DWG_TYPE_SPLINE : dwg_free_SPLINE ( dat , obj ) ; break ; case DWG_TYPE_REGION : dwg_free_REGION ( dat , obj ) ; break ; case DWG_TYPE__3DSOLID : dwg_free__3DSOLID ( dat , obj ) ; break ; case DWG_TYPE_BODY : dwg_free_BODY ( dat , obj ) ; break ; case DWG_TYPE_RAY : dwg_free_RAY ( dat , obj ) ; break ; case DWG_TYPE_XLINE : dwg_free_XLINE ( dat , obj ) ; break ; case DWG_TYPE_DICTIONARY : dwg_free_DICTIONARY ( dat , obj ) ; break ; case DWG_TYPE_MTEXT : dwg_free_MTEXT ( dat , obj ) ; break ; case DWG_TYPE_LEADER : dwg_free_LEADER ( dat , obj ) ; break ; case DWG_TYPE_TOLERANCE : dwg_free_TOLERANCE ( dat , obj ) ; break ; case DWG_TYPE_MLINE : dwg_free_MLINE ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_CONTROL : dwg_free_BLOCK_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_HEADER : dwg_free_BLOCK_HEADER ( dat , obj ) ; break ; case DWG_TYPE_LAYER_CONTROL : dwg_free_LAYER_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LAYER : dwg_free_LAYER ( dat , obj ) ; break ; case DWG_TYPE_STYLE_CONTROL : dwg_free_STYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_STYLE : dwg_free_STYLE ( dat , obj ) ; break ; case DWG_TYPE_LTYPE_CONTROL : dwg_free_LTYPE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LTYPE : dwg_free_LTYPE ( dat , obj ) ; break ; case DWG_TYPE_VIEW_CONTROL : dwg_free_VIEW_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VIEW : dwg_free_VIEW ( dat , obj ) ; break ; case DWG_TYPE_UCS_CONTROL : dwg_free_UCS_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_UCS : dwg_free_UCS ( dat , obj ) ; break ; case DWG_TYPE_VPORT_CONTROL : dwg_free_VPORT_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT : dwg_free_VPORT ( dat , obj ) ; break ; case DWG_TYPE_APPID_CONTROL : dwg_free_APPID_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_APPID : dwg_free_APPID ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE_CONTROL : dwg_free_DIMSTYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE : dwg_free_DIMSTYLE ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_CONTROL : dwg_free_VPORT_ENTITY_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_HEADER : dwg_free_VPORT_ENTITY_HEADER ( dat , obj ) ; break ; case DWG_TYPE_GROUP : dwg_free_GROUP ( dat , obj ) ; break ; case DWG_TYPE_MLINESTYLE : dwg_free_MLINESTYLE ( dat , obj ) ; break ; case DWG_TYPE_OLE2FRAME : dwg_free_OLE2FRAME ( dat , obj ) ; break ; case DWG_TYPE_DUMMY : dwg_free_DUMMY ( dat , obj ) ; break ; case DWG_TYPE_LONG_TRANSACTION : dwg_free_LONG_TRANSACTION ( dat , obj ) ; break ; case DWG_TYPE_LWPOLYLINE : dwg_free_LWPOLYLINE ( dat , obj ) ; break ; case DWG_TYPE_HATCH : dwg_free_HATCH ( dat , obj ) ; break ; case DWG_TYPE_XRECORD : dwg_free_XRECORD ( dat , obj ) ; break ; case DWG_TYPE_PLACEHOLDER : dwg_free_PLACEHOLDER ( dat , obj ) ; break ; case DWG_TYPE_OLEFRAME : dwg_free_OLEFRAME ( dat , obj ) ; break ; # ifdef DEBUG_VBA_PROJECT case DWG_TYPE_VBA_PROJECT : dwg_free_VBA_PROJECT ( dat , obj ) ; break ; # endif case DWG_TYPE_LAYOUT : dwg_free_LAYOUT ( dat , obj ) ; break ; case DWG_TYPE_PROXY_ENTITY : dwg_free_PROXY_ENTITY ( dat , obj ) ; break ; case DWG_TYPE_PROXY_OBJECT : dwg_free_PROXY_OBJECT ( dat , obj ) ; break ; default : if ( obj -> type == obj -> parent -> layout_type ) { SINCE ( R_13 ) { dwg_free_LAYOUT ( dat , obj ) ; } } else if ( ( error = dwg_free_variable_type ( obj -> parent , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) { <S2SV_StartBug> int is_entity ; <S2SV_EndBug> int i ; Dwg_Class * klass ; unhandled : is_entity = 0 ; i = obj -> type - 500 ; klass = NULL ; dwg = obj -> parent ; if ( dwg -> dwg_class && i >= 0 && i < ( int ) dwg -> num_classes ) { klass = & dwg -> dwg_class [ i ] ; is_entity = klass ? dwg_class_is_entity ( klass ) : 0 ; } <S2SV_StartBug> if ( obj -> fixedtype == DWG_TYPE_TABLE ) <S2SV_EndBug> { dwg_free_UNKNOWN_ENT ( dat , obj ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> else if ( obj -> fixedtype == DWG_TYPE_DATATABLE ) <S2SV_EndBug> { dwg_free_UNKNOWN_OBJ ( dat , obj ) ; <S2SV_StartBug> } <S2SV_EndBug> else if ( klass && ! is_entity ) { dwg_free_UNKNOWN_OBJ ( dat , obj ) ; } else if ( klass && is_entity ) { dwg_free_UNKNOWN_ENT ( dat , obj ) ; } else { FREE_IF ( obj -> tio . unknown ) ; } } } if ( dwg -> opts & DWG_OPTS_INDXF ) FREE_IF ( obj -> dxfname ) ; obj -> type = DWG_TYPE_FREED ; }
","<S2SV_ModStart> DWG_ERR_UNHANDLEDCLASS ) { unhandled : <S2SV_ModEnd> if ( obj <S2SV_ModStart> -> fixedtype == DWG_TYPE_UNKNOWN_ENT ) <S2SV_ModEnd> dwg_free_UNKNOWN_ENT ( dat <S2SV_ModStart> obj ) ; <S2SV_ModEnd> else if ( <S2SV_ModStart> -> fixedtype == DWG_TYPE_UNKNOWN_OBJ ) <S2SV_ModEnd> dwg_free_UNKNOWN_OBJ ( dat <S2SV_ModStart> obj ) ; <S2SV_ModEnd> } } if
",CWE-835
539,"CWE-362 static int set_evtchn_to_irq ( evtchn_port_t evtchn , unsigned int irq ) { unsigned row ; unsigned col ; if ( evtchn >= xen_evtchn_max_channels ( ) ) return - EINVAL ; row = EVTCHN_ROW ( evtchn ) ; col = EVTCHN_COL ( evtchn ) ; if ( evtchn_to_irq [ row ] == NULL ) { if ( irq == - 1 ) return 0 ; evtchn_to_irq [ row ] = ( int * ) get_zeroed_page ( GFP_KERNEL ) ; if ( evtchn_to_irq [ row ] == NULL ) return - ENOMEM ; clear_evtchn_to_irq_row ( row ) ; } <S2SV_StartBug> evtchn_to_irq [ row ] [ col ] = irq ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> ) ; } WRITE_ONCE ( <S2SV_ModStart> [ col ] , irq ) <S2SV_ModEnd> ; return 0
",CWE-362
544,"CWE-476 static bool assoc_array_insert_into_terminal_node ( struct assoc_array_edit * edit , const struct assoc_array_ops * ops , const void * index_key , struct assoc_array_walk_result * result ) { struct assoc_array_shortcut * shortcut , * new_s0 ; struct assoc_array_node * node , * new_n0 , * new_n1 , * side ; struct assoc_array_ptr * ptr ; unsigned long dissimilarity , base_seg , blank ; size_t keylen ; bool have_meta ; int level , diff ; int slot , next_slot , free_slot , i , j ; node = result -> terminal_node . node ; level = result -> terminal_node . level ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = result -> terminal_node . slot ; pr_devel ( ""-->%s()\\n"" , __func__ ) ; free_slot = - 1 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( ! ptr ) { free_slot = i ; continue ; } if ( assoc_array_ptr_is_leaf ( ptr ) && ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { pr_devel ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\n"" , i ) ; edit -> leaf_p = & node -> slots [ i ] ; edit -> dead_leaf = node -> slots [ i ] ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[replace]\\n"" , __func__ ) ; return true ; } } if ( free_slot >= 0 ) { pr_devel ( ""insert<S2SV_blank>in<S2SV_blank>free<S2SV_blank>slot<S2SV_blank>%d\\n"" , free_slot ) ; edit -> leaf_p = & node -> slots [ free_slot ] ; edit -> adjust_count_on = node ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert]\\n"" , __func__ ) ; return true ; } new_n0 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n0 ) return false ; edit -> new_meta [ 0 ] = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n1 ) return false ; edit -> new_meta [ 1 ] = assoc_array_node_to_ptr ( new_n1 ) ; pr_devel ( ""no<S2SV_blank>spare<S2SV_blank>slots\\n"" ) ; have_meta = false ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( assoc_array_ptr_is_meta ( ptr ) ) { edit -> segment_cache [ i ] = 0xff ; have_meta = true ; continue ; } base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } if ( have_meta ) { pr_devel ( ""have<S2SV_blank>meta\\n"" ) ; goto split_node ; } dissimilarity = 0 ; base_seg = edit -> segment_cache [ 0 ] ; for ( i = 1 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) dissimilarity |= edit -> segment_cache [ i ] ^ base_seg ; pr_devel ( ""only<S2SV_blank>leaves;<S2SV_blank>dissimilarity=%lx\\n"" , dissimilarity ) ; if ( ( dissimilarity & ASSOC_ARRAY_FAN_MASK ) == 0 ) { if ( ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ^ base_seg ) == 0 ) goto all_leaves_cluster_together ; <S2SV_StartBug> goto present_leaves_cluster_but_not_new_leaf ; <S2SV_EndBug> } split_node : pr_devel ( ""split<S2SV_blank>node\\n"" ) ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; do_split_node : pr_devel ( ""do_split_node\\n"" ) ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> nr_leaves_on_branch = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { slot = edit -> segment_cache [ i ] ; if ( slot != 0xff ) for ( j = i + 1 ; j < ASSOC_ARRAY_FAN_OUT + 1 ; j ++ ) if ( edit -> segment_cache [ j ] == slot ) goto found_slot_for_multiple_occupancy ; } found_slot_for_multiple_occupancy : pr_devel ( ""same<S2SV_blank>slot:<S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>[%02x]\\n"" , i , j , slot ) ; BUG_ON ( i >= ASSOC_ARRAY_FAN_OUT ) ; BUG_ON ( j >= ASSOC_ARRAY_FAN_OUT + 1 ) ; BUG_ON ( slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n1 -> parent_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) new_n0 -> slots [ i ] = node -> slots [ i ] ; else new_n0 -> slots [ i ] = NULL ; BUG_ON ( new_n0 -> slots [ slot ] != NULL ) ; new_n0 -> slots [ slot ] = assoc_array_node_to_ptr ( new_n1 ) ; free_slot = - 1 ; next_slot = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) continue ; if ( edit -> segment_cache [ i ] == slot ) { new_n1 -> slots [ next_slot ++ ] = node -> slots [ i ] ; new_n1 -> nr_leaves_on_branch ++ ; } else { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; new_n0 -> slots [ free_slot ] = node -> slots [ i ] ; } } pr_devel ( ""filtered:<S2SV_blank>f=%x<S2SV_blank>n=%x\\n"" , free_slot , next_slot ) ; if ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] != slot ) { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; edit -> leaf_p = & new_n0 -> slots [ free_slot ] ; edit -> adjust_count_on = new_n0 ; } else { edit -> leaf_p = & new_n1 -> slots [ next_slot ++ ] ; edit -> adjust_count_on = new_n1 ; } BUG_ON ( next_slot <= 1 ) ; edit -> set_backpointers_to = assoc_array_node_to_ptr ( new_n0 ) ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( edit -> segment_cache [ i ] == 0xff ) { ptr = node -> slots [ i ] ; BUG_ON ( assoc_array_ptr_is_leaf ( ptr ) ) ; if ( assoc_array_ptr_is_node ( ptr ) ) { side = assoc_array_ptr_to_node ( ptr ) ; edit -> set_backpointers [ i ] = & side -> back_pointer ; } else { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; edit -> set_backpointers [ i ] = & shortcut -> back_pointer ; } } } ptr = node -> back_pointer ; if ( ! ptr ) edit -> set [ 0 ] . ptr = & edit -> array -> root ; else if ( assoc_array_ptr_is_node ( ptr ) ) edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( ptr ) -> slots [ node -> parent_slot ] ; else edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_shortcut ( ptr ) -> next_node ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[split<S2SV_blank>node]\\n"" , __func__ ) ; return true ; <S2SV_StartBug> present_leaves_cluster_but_not_new_leaf : <S2SV_EndBug> pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = edit -> segment_cache [ 0 ] ; new_n1 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; edit -> adjust_count_on = new_n0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) new_n1 -> slots [ i ] = node -> slots [ i ] ; new_n0 -> slots [ edit -> segment_cache [ 0 ] ] = assoc_array_node_to_ptr ( new_n0 ) ; edit -> leaf_p = & new_n0 -> slots [ edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ] ; edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( node -> back_pointer ) -> slots [ node -> parent_slot ] ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert<S2SV_blank>node<S2SV_blank>before]\\n"" , __func__ ) ; return true ; all_leaves_cluster_together : pr_devel ( ""all<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>together\\n"" ) ; diff = INT_MAX ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { int x = ops -> diff_objects ( assoc_array_ptr_to_leaf ( node -> slots [ i ] ) , index_key ) ; if ( x < diff ) { BUG_ON ( x < 0 ) ; diff = x ; } } BUG_ON ( diff == INT_MAX ) ; BUG_ON ( diff < level + ASSOC_ARRAY_LEVEL_STEP ) ; keylen = round_up ( diff , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s0 = kzalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s0 ) return false ; edit -> new_meta [ 2 ] = assoc_array_shortcut_to_ptr ( new_s0 ) ; edit -> set [ 0 ] . to = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_s0 -> back_pointer = node -> back_pointer ; new_s0 -> parent_slot = node -> parent_slot ; new_s0 -> next_node = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_n0 -> parent_slot = 0 ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; new_s0 -> skip_to_level = level = diff & ~ ASSOC_ARRAY_LEVEL_STEP_MASK ; pr_devel ( ""skip_to_level<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[diff<S2SV_blank>%d]\\n"" , level , diff ) ; BUG_ON ( level <= 0 ) ; for ( i = 0 ; i < keylen ; i ++ ) new_s0 -> index_key [ i ] = ops -> get_key_chunk ( index_key , i * ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; blank = ULONG_MAX << ( level & ASSOC_ARRAY_KEY_CHUNK_MASK ) ; pr_devel ( ""blank<S2SV_blank>off<S2SV_blank>[%zu]<S2SV_blank>%d:<S2SV_blank>%lx\\n"" , keylen - 1 , level , blank ) ; new_s0 -> index_key [ keylen - 1 ] &= ~ blank ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } base_seg = ops -> get_key_chunk ( index_key , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = base_seg & ASSOC_ARRAY_FAN_MASK ; goto do_split_node ; }
","<S2SV_ModStart> goto all_leaves_cluster_together ; pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) <S2SV_ModEnd> ; } split_node <S2SV_ModStart> return true ; <S2SV_ModEnd> all_leaves_cluster_together : pr_devel
",CWE-476
550,"CWE-19 int xfs_attr3_leaf_lookup_int ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; xfs_dahash_t hashval ; int probe ; int span ; trace_xfs_attr_leaf_lookup ( args ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; hashval = args -> hashval ; probe = span = ichdr . count / 2 ; for ( entry = & entries [ probe ] ; span > 4 ; entry = & entries [ probe ] ) { span /= 2 ; if ( be32_to_cpu ( entry -> hashval ) < hashval ) probe += span ; else if ( be32_to_cpu ( entry -> hashval ) > hashval ) probe -= span ; else break ; } ASSERT ( probe >= 0 && ( ! ichdr . count || probe < ichdr . count ) ) ; ASSERT ( span <= 4 || be32_to_cpu ( entry -> hashval ) == hashval ) ; while ( probe > 0 && be32_to_cpu ( entry -> hashval ) >= hashval ) { entry -- ; probe -- ; } while ( probe < ichdr . count && be32_to_cpu ( entry -> hashval ) < hashval ) { entry ++ ; probe ++ ; } if ( probe == ichdr . count || be32_to_cpu ( entry -> hashval ) != hashval ) { args -> index = probe ; return XFS_ERROR ( ENOATTR ) ; } for ( ; probe < ichdr . count && ( be32_to_cpu ( entry -> hashval ) == hashval ) ; entry ++ , probe ++ ) { if ( ( args -> flags & XFS_ATTR_INCOMPLETE ) != ( entry -> flags & XFS_ATTR_INCOMPLETE ) ) { continue ; } if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , probe ) ; if ( name_loc -> namelen != args -> namelen ) continue ; if ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) != 0 ) continue ; if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ; args -> index = probe ; return XFS_ERROR ( EEXIST ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , probe ) ; if ( name_rmt -> namelen != args -> namelen ) continue ; if ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) != 0 ) continue ; if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ; args -> index = probe ; <S2SV_StartBug> args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , <S2SV_StartBug> args -> valuelen ) ; <S2SV_EndBug> return XFS_ERROR ( EEXIST ) ; } } args -> index = probe ; return XFS_ERROR ( ENOATTR ) ; }
","<S2SV_ModStart> ; args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno <S2SV_ModEnd> = be32_to_cpu ( <S2SV_ModStart> ( name_rmt -> <S2SV_ModEnd> valueblk ) ; <S2SV_ModStart> , args -> rmtvaluelen <S2SV_ModEnd> ) ; return
",CWE-19
551,"CWE-119 <S2SV_StartBug> void sum_2_variances ( const var * a , const var * b , var * r ) { <S2SV_EndBug> fill_variance ( a -> sum_square_error + b -> sum_square_error , <S2SV_StartBug> a -> sum_error + b -> sum_error , a -> count + b -> count , r ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> r ) { assert ( a -> log2_count == b -> log2_count ) ; <S2SV_ModStart> , a -> log2_count + 1 <S2SV_ModEnd> , r )
",CWE-119
556,"CWE-190 int drm_mode_dirtyfb_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct drm_clip_rect __user * clips_ptr ; struct drm_clip_rect * clips = NULL ; struct drm_mode_fb_dirty_cmd * r = data ; struct drm_mode_object * obj ; struct drm_framebuffer * fb ; unsigned flags ; int num_clips ; int ret = 0 ; if ( ! drm_core_check_feature ( dev , DRIVER_MODESET ) ) return - EINVAL ; mutex_lock ( & dev -> mode_config . mutex ) ; obj = drm_mode_object_find ( dev , r -> fb_id , DRM_MODE_OBJECT_FB ) ; if ( ! obj ) { DRM_ERROR ( ""invalid<S2SV_blank>framebuffer<S2SV_blank>id\\n"" ) ; ret = - EINVAL ; goto out_err1 ; } fb = obj_to_fb ( obj ) ; num_clips = r -> num_clips ; clips_ptr = ( struct drm_clip_rect * ) ( unsigned long ) r -> clips_ptr ; if ( ! num_clips != ! clips_ptr ) { ret = - EINVAL ; goto out_err1 ; } flags = DRM_MODE_FB_DIRTY_FLAGS & r -> flags ; if ( flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && ( num_clips % 2 ) ) { ret = - EINVAL ; goto out_err1 ; } if ( num_clips && clips_ptr ) { <S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! clips ) { ret = - ENOMEM ; goto out_err1 ; } ret = copy_from_user ( clips , clips_ptr , num_clips * sizeof ( * clips ) ) ; if ( ret ) { ret = - EFAULT ; goto out_err2 ; } } if ( fb -> funcs -> dirty ) { ret = fb -> funcs -> dirty ( fb , file_priv , flags , r -> color , clips , num_clips ) ; } else { ret = - ENOSYS ; goto out_err2 ; } out_err2 : kfree ( clips ) ; out_err1 : mutex_unlock ( & dev -> mode_config . mutex ) ; return ret ; }
","<S2SV_ModStart> clips_ptr ) { if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; }
",CWE-190
561,"CWE-404 static int install_process_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; <S2SV_StartBug> return ret != - EEXIST ? ret : 0 ; <S2SV_EndBug> } return commit_creds ( new ) ; }
","<S2SV_ModStart> ; return ret <S2SV_ModEnd> ; } return
",CWE-404
564,"CWE-119 void vp8_rtcd ( ) { <S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> once ( setup_rtcd_internal ) ; }
","<S2SV_ModStart> ( ) { <S2SV_ModEnd> once ( setup_rtcd_internal
",CWE-119
567,"CWE-264 int perf_event_task_disable ( void ) <S2SV_StartBug> { <S2SV_EndBug> struct perf_event * event ; mutex_lock ( & current -> perf_event_mutex ) ; <S2SV_StartBug> list_for_each_entry ( event , & current -> perf_event_list , owner_entry ) <S2SV_EndBug> <S2SV_StartBug> perf_event_for_each_child ( event , perf_event_disable ) ; <S2SV_EndBug> mutex_unlock ( & current -> perf_event_mutex ) ; return 0 ; }
","<S2SV_ModStart> void ) { struct perf_event_context * ctx ; <S2SV_ModStart> , owner_entry ) { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> ( event , _perf_event_disable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> mutex_unlock ( &
",CWE-264
569,"CWE-617 static krb5_error_code kdc_process_s4u_x509_user ( krb5_context context , krb5_kdc_req * request , krb5_pa_data * pa_data , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_pa_s4u_x509_user * * s4u_x509_user , const char * * status ) { krb5_error_code code ; krb5_data req_data ; req_data . length = pa_data -> length ; req_data . data = ( char * ) pa_data -> contents ; code = decode_krb5_pa_s4u_x509_user ( & req_data , s4u_x509_user ) ; if ( code ) <S2SV_StartBug> return code ; <S2SV_EndBug> code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ; if ( code ) { * status = ""INVALID_S4U2SELF_CHECKSUM"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return code ; } if ( krb5_princ_size ( context , ( * s4u_x509_user ) -> user_id . user ) == 0 || ( * s4u_x509_user ) -> user_id . subject_cert . length != 0 ) { * status = ""INVALID_S4U2SELF_REQUEST"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } return 0 ; }
","<S2SV_ModStart> ( code ) { * status = ""DECODE_PA_S4U_X509_USER"" ; return code ; } <S2SV_ModEnd> code = verify_s4u_x509_user_checksum
",CWE-617
570,"CWE-125 arg_ty <S2SV_StartBug> arg ( identifier arg , expr_ty annotation , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { arg_ty p ; if ( ! arg ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>arg<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>arg"" ) ; return NULL ; } p = ( arg_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> arg = arg ; p -> annotation = annotation ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
","<S2SV_ModStart> expr_ty annotation , string type_comment , <S2SV_ModStart> ; p -> type_comment = type_comment ; p ->
",CWE-125
572,"CWE-125 static void <S2SV_StartBug> l2tp_framing_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_ASYNC_MASK ) { ND_PRINT ( ( ndo , ""A"" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_SYNC_MASK ) { ND_PRINT ( ( ndo , ""S"" ) ) ; } }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",CWE-125
573,"CWE-119 void vp8cx_pick_filter_level ( YV12_BUFFER_CONFIG * sd , VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int best_err = 0 ; int filt_err = 0 ; int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filter_step ; int filt_high = 0 ; <S2SV_StartBug> int filt_mid = cm -> filter_level ; <S2SV_EndBug> int filt_low = 0 ; int filt_best ; int filt_direction = 0 ; int Bias = 0 ; int ss_err [ MAX_LOOP_FILTER + 1 ] ; YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; <S2SV_StartBug> vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <S2SV_EndBug> cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ; if ( cm -> frame_type == KEY_FRAME ) cm -> sharpness_level = 0 ; else cm -> sharpness_level = cpi -> oxcf . Sharpness ; filt_mid = cm -> filter_level ; if ( filt_mid < min_filter_level ) filt_mid = min_filter_level ; else if ( filt_mid > max_filter_level ) filt_mid = max_filter_level ; filter_step = ( filt_mid < 16 ) ? 4 : filt_mid / 4 ; vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_mid ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_mid ) ; best_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_mid ] = best_err ; filt_best = filt_mid ; while ( filter_step > 0 ) { Bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ; if ( cpi -> twopass . section_intra_rating < 20 ) Bias = Bias * cpi -> twopass . section_intra_rating / 20 ; filt_high = ( ( filt_mid + filter_step ) > max_filter_level ) ? max_filter_level : ( filt_mid + filter_step ) ; filt_low = ( ( filt_mid - filter_step ) < min_filter_level ) ? min_filter_level : ( filt_mid - filter_step ) ; if ( ( filt_direction <= 0 ) && ( filt_low != filt_mid ) ) { if ( ss_err [ filt_low ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_low ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_low ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_low ] = filt_err ; } else filt_err = ss_err [ filt_low ] ; if ( ( filt_err - Bias ) < best_err ) { if ( filt_err < best_err ) best_err = filt_err ; filt_best = filt_low ; } } if ( ( filt_direction >= 0 ) && ( filt_high != filt_mid ) ) { if ( ss_err [ filt_high ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_high ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_high ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_high ] = filt_err ; } else filt_err = ss_err [ filt_high ] ; if ( filt_err < ( best_err - Bias ) ) { best_err = filt_err ; filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step = filter_step / 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } } cm -> filter_level = filt_best ; cm -> frame_to_show = saved_frame ; }
","<S2SV_ModStart> ; int filt_mid <S2SV_ModEnd> ; int filt_low <S2SV_ModStart> -> frame_to_show ; memset <S2SV_ModEnd> ( ss_err ,
",CWE-119
574,"CWE-000 static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; <S2SV_StartBug> strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ; <S2SV_EndBug> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher .
",CWE-000
575,"CWE-119 static void unset_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { <S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> map . rows = ( cfg -> g_h + 15 ) / 16 ; map . cols = ( cfg -> g_w + 15 ) / 16 ; map . active_map = NULL ; if ( vpx_codec_control ( codec , VP8E_SET_ACTIVEMAP , & map ) ) die_codec ( codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>active<S2SV_blank>map"" ) ; }
","<S2SV_ModStart> map = { 0 , 0 ,
",CWE-119
576,"CWE-400 static int nghttp2_session_upgrade_internal ( nghttp2_session * session , const uint8_t * settings_payload , size_t settings_payloadlen , void * stream_user_data ) { nghttp2_stream * stream ; nghttp2_frame frame ; nghttp2_settings_entry * iv ; size_t niv ; int rv ; nghttp2_priority_spec pri_spec ; nghttp2_mem * mem ; mem = & session -> mem ; if ( ( ! session -> server && session -> next_stream_id != 1 ) || ( session -> server && session -> last_recv_stream_id >= 1 ) ) { return NGHTTP2_ERR_PROTO ; } if ( settings_payloadlen % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) { <S2SV_StartBug> return NGHTTP2_ERR_INVALID_ARGUMENT ; <S2SV_EndBug> } rv = nghttp2_frame_unpack_settings_payload2 ( & iv , & niv , settings_payload , settings_payloadlen , mem ) ; if ( rv != 0 ) { return rv ; } if ( session -> server ) { nghttp2_frame_hd_init ( & frame . hd , settings_payloadlen , NGHTTP2_SETTINGS , NGHTTP2_FLAG_NONE , 0 ) ; frame . settings . iv = iv ; frame . settings . niv = niv ; rv = nghttp2_session_on_settings_received ( session , & frame , 1 ) ; } else { rv = nghttp2_submit_settings ( session , NGHTTP2_FLAG_NONE , iv , niv ) ; } nghttp2_mem_free ( mem , iv ) ; if ( rv != 0 ) { return rv ; } nghttp2_priority_spec_default_init ( & pri_spec ) ; stream = nghttp2_session_open_stream ( session , 1 , NGHTTP2_STREAM_FLAG_NONE , & pri_spec , NGHTTP2_STREAM_OPENING , session -> server ? NULL : stream_user_data ) ; if ( stream == NULL ) { return NGHTTP2_ERR_NOMEM ; } if ( session -> server ) { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_RD ) ; session -> last_recv_stream_id = 1 ; session -> last_proc_stream_id = 1 ; } else { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_WR ) ; session -> last_sent_stream_id = 1 ; session -> next_stream_id += 2 ; } return 0 ; }
","<S2SV_ModStart> { return NGHTTP2_ERR_INVALID_ARGUMENT ; } if ( settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH > session -> max_settings ) { return NGHTTP2_ERR_TOO_MANY_SETTINGS
",CWE-400
577,"CWE-119 void update_rate_histogram ( struct rate_hist * hist , const vpx_codec_enc_cfg_t * cfg , const vpx_codec_cx_pkt_t * pkt ) { int i ; int64_t then = 0 ; int64_t avg_bitrate = 0 ; int64_t sum_sz = 0 ; const int64_t now = pkt -> data . frame . pts * 1000 * ( uint64_t ) cfg -> g_timebase . num / ( uint64_t ) cfg -> g_timebase . den ; int idx = hist -> frames ++ % hist -> samples ; hist -> pts [ idx ] = now ; hist -> sz [ idx ] = ( int ) pkt -> data . frame . sz ; if ( now < cfg -> rc_buf_initial_sz ) return ; <S2SV_StartBug> then = now ; <S2SV_EndBug> for ( i = hist -> frames ; i > 0 && hist -> frames - i < hist -> samples ; i -- ) { const int i_idx = ( i - 1 ) % hist -> samples ; then = hist -> pts [ i_idx ] ; if ( now - then > cfg -> rc_buf_sz ) break ; sum_sz += hist -> sz [ i_idx ] ; } if ( now == then ) return ; avg_bitrate = sum_sz * 8 * 1000 / ( now - then ) ; idx = ( int ) ( avg_bitrate * ( RATE_BINS / 2 ) / ( cfg -> rc_target_bitrate * 1000 ) ) ; if ( idx < 0 ) idx = 0 ; if ( idx > RATE_BINS - 1 ) idx = RATE_BINS - 1 ; if ( hist -> bucket [ idx ] . low > avg_bitrate ) hist -> bucket [ idx ] . low = ( int ) avg_bitrate ; if ( hist -> bucket [ idx ] . high < avg_bitrate ) hist -> bucket [ idx ] . high = ( int ) avg_bitrate ; hist -> bucket [ idx ] . count ++ ; hist -> total ++ ; }
","<S2SV_ModStart> ) return ; if ( ! cfg -> rc_target_bitrate ) return ;
",CWE-119
578,"CWE-119 int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , ""Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n"" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
","<S2SV_ModStart> out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ;
",CWE-119
587,"CWE-119 <S2SV_StartBug> static double get_prediction_decay_rate ( const VP9_COMMON * cm , <S2SV_EndBug> const FIRSTPASS_STATS * next_frame ) { <S2SV_StartBug> const double mb_sr_err_diff = ( next_frame -> sr_coded_error - <S2SV_EndBug> next_frame -> coded_error ) / cm -> MBs ; <S2SV_StartBug> const double second_ref_decay = mb_sr_err_diff <= 512.0 <S2SV_EndBug> <S2SV_StartBug> ? fclamp ( pow ( 1.0 - ( mb_sr_err_diff / 512.0 ) , 0.5 ) , 0.85 , 1.0 ) <S2SV_EndBug> : 0.85 ; return MIN ( second_ref_decay , next_frame -> pcnt_inter ) ; }
","<S2SV_ModStart> get_prediction_decay_rate ( const VP9_COMP * cpi <S2SV_ModEnd> , const FIRSTPASS_STATS <S2SV_ModStart> { const double sr_decay_rate = get_sr_decay_rate ( cpi , next_frame ) <S2SV_ModEnd> ; const double <S2SV_ModStart> ; const double zero_motion_factor = ( 0.95 * pow ( ( next_frame -> pcnt_inter - next_frame -> pcnt_motion ) , ZM_POWER_FACTOR ) ) ; return MAX ( zero_motion_factor , ( sr_decay_rate + ( <S2SV_ModEnd> ( 1.0 - <S2SV_ModStart> ( 1.0 - sr_decay_rate ) * zero_motion_factor ) ) <S2SV_ModEnd> ) ; }
",CWE-119
588,"CWE-264 long arch_ptrace ( struct task_struct * child , long request , unsigned long addr , unsigned long data ) { int ret ; unsigned long __user * datap = ( unsigned long __user * ) data ; switch ( request ) { case PTRACE_PEEKUSR : ret = ptrace_read_user ( child , addr , datap ) ; break ; case PTRACE_POKEUSR : ret = ptrace_write_user ( child , addr , data ) ; break ; case PTRACE_GETREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_SETREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_GETFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; case PTRACE_SETFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; # ifdef CONFIG_IWMMXT case PTRACE_GETWMMXREGS : ret = ptrace_getwmmxregs ( child , datap ) ; break ; case PTRACE_SETWMMXREGS : ret = ptrace_setwmmxregs ( child , datap ) ; break ; # endif case PTRACE_GET_THREAD_AREA : <S2SV_StartBug> ret = put_user ( task_thread_info ( child ) -> tp_value , <S2SV_EndBug> datap ) ; break ; case PTRACE_SET_SYSCALL : task_thread_info ( child ) -> syscall = data ; ret = 0 ; break ; # ifdef CONFIG_CRUNCH case PTRACE_GETCRUNCHREGS : ret = ptrace_getcrunchregs ( child , datap ) ; break ; case PTRACE_SETCRUNCHREGS : ret = ptrace_setcrunchregs ( child , datap ) ; break ; # endif # ifdef CONFIG_VFP case PTRACE_GETVFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; case PTRACE_SETVFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; # endif # ifdef CONFIG_HAVE_HW_BREAKPOINT case PTRACE_GETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_gethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; case PTRACE_SETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_sethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; # endif default : ret = ptrace_request ( child , request , addr , data ) ; break ; } return ret ; }
","<S2SV_ModStart> ) -> tp_value [ 0 ]
",CWE-264
589,"CWE-119 static void initialize_encoder ( struct stream_state * stream , struct VpxEncoderConfig * global ) { int i ; int flags = 0 ; flags |= global -> show_psnr ? VPX_CODEC_USE_PSNR : 0 ; flags |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ; <S2SV_StartBug> vpx_codec_enc_init ( & stream -> encoder , global -> codec -> interface ( ) , <S2SV_EndBug> & stream -> config . cfg , flags ) ; ctx_exit_on_error ( & stream -> encoder , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; for ( i = 0 ; i < stream -> config . arg_ctrl_cnt ; i ++ ) { int ctrl = stream -> config . arg_ctrls [ i ] [ 0 ] ; int value = stream -> config . arg_ctrls [ i ] [ 1 ] ; if ( vpx_codec_control_ ( & stream -> encoder , ctrl , value ) ) fprintf ( stderr , ""Error:<S2SV_blank>Tried<S2SV_blank>to<S2SV_blank>set<S2SV_blank>control<S2SV_blank>%d<S2SV_blank>=<S2SV_blank>%d\\n"" , ctrl , value ) ; ctx_exit_on_error ( & stream -> encoder , ""Failed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>codec"" ) ; } # if CONFIG_DECODERS if ( global -> test_decode != TEST_DECODE_OFF ) { const VpxInterface * decoder = get_vpx_decoder_by_name ( global -> codec -> name ) ; <S2SV_StartBug> vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ; <S2SV_EndBug> } # endif }
","<S2SV_ModStart> : 0 ; # if CONFIG_VP9_HIGHBITDEPTH flags |= stream -> config . use_16bit_internal ? VPX_CODEC_USE_HIGHBITDEPTH : 0 ; # endif <S2SV_ModStart> -> codec -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,
",CWE-119
590,"CWE-125 void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
",CWE-125
592,"CWE-416 <S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> int id ) { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> if ( handle ) ion_handle_get ( handle ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct ion_handle * <S2SV_ModStart> ; handle = ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ; return handle <S2SV_ModEnd> ; } <S2SV_null>
",CWE-416
595,"CWE-119 static void y4m_convert_null ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) { <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> _aux ) { ( void ) _y4m ; ( void ) _dst ; ( void ) _aux ;
",CWE-119
596,"CWE-19 void ext2_xattr_delete_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> down_write ( & EXT2_I ( inode ) -> xattr_sem ) ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; if ( ! bh ) { ext2_error ( inode -> i_sb , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%d<S2SV_blank>read<S2SV_blank>error"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; goto cleanup ; } ea_bdebug ( bh , ""b_count=%d"" , atomic_read ( & ( bh -> b_count ) ) ) ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { ext2_error ( inode -> i_sb , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; goto cleanup ; } <S2SV_StartBug> ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ; <S2SV_EndBug> lock_buffer ( bh ) ; if ( HDR ( bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; ext2_free_blocks ( inode , EXT2_I ( inode ) -> i_file_acl , 1 ) ; get_bh ( bh ) ; bforget ( bh ) ; unlock_buffer ( bh ) ; } else { <S2SV_StartBug> le32_add_cpu ( & HDR ( bh ) -> h_refcount , - 1 ) ; <S2SV_EndBug> if ( ce ) mb_cache_entry_release ( ce ) ; ea_bdebug ( bh , ""refcount<S2SV_blank>now=%d"" , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; unlock_buffer ( bh ) ; mark_buffer_dirty ( bh ) ; if ( IS_SYNC ( inode ) ) sync_dirty_buffer ( bh ) ; dquot_free_block_nodirty ( inode , 1 ) ; } EXT2_I ( inode ) -> i_file_acl = 0 ; cleanup : brelse ( bh ) ; up_write ( & EXT2_I ( inode ) -> xattr_sem ) ; }
","<S2SV_ModStart> = NULL ; <S2SV_ModEnd> down_write ( & <S2SV_ModStart> cleanup ; } <S2SV_ModEnd> lock_buffer ( bh <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( HDR ( bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( EXT2_SB ( inode -> i_sb ) -> s_mb_cache , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; ext2_free_blocks <S2SV_ModStart> , - 1 <S2SV_ModEnd> ) ; ea_bdebug
",CWE-19
597,"CWE-369 static OPJ_BOOL opj_pi_next_pcrl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { comp = & pi -> comps [ pi -> compno ] ; for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < opj_uint_min ( pi -> poc . resno1 , comp -> numresolutions ) ; pi -> resno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
","<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
",CWE-369
601,"CWE-125 static stmt_ty ast_for_import_stmt ( struct compiling * c , const node * n ) { int lineno ; int col_offset ; int i ; asdl_seq * aliases ; REQ ( n , import_stmt ) ; lineno = LINENO ( n ) ; col_offset = n -> n_col_offset ; n = CHILD ( n , 0 ) ; if ( TYPE ( n ) == import_name ) { n = CHILD ( n , 1 ) ; REQ ( n , dotted_as_names ) ; aliases = _Py_asdl_seq_new ( ( NCH ( n ) + 1 ) / 2 , c -> c_arena ) ; if ( ! aliases ) return NULL ; for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { alias_ty import_alias = alias_for_import_name ( c , CHILD ( n , i ) , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , i / 2 , import_alias ) ; } return Import ( aliases , lineno , col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( n ) == import_from ) { int n_children ; int idx , ndots = 0 ; const node * n_copy = n ; alias_ty mod = NULL ; identifier modname = NULL ; for ( idx = 1 ; idx < NCH ( n ) ; idx ++ ) { if ( TYPE ( CHILD ( n , idx ) ) == dotted_name ) { mod = alias_for_import_name ( c , CHILD ( n , idx ) , 0 ) ; if ( ! mod ) return NULL ; idx ++ ; break ; } else if ( TYPE ( CHILD ( n , idx ) ) == ELLIPSIS ) { ndots += 3 ; continue ; } else if ( TYPE ( CHILD ( n , idx ) ) != DOT ) { break ; } ndots ++ ; } idx ++ ; switch ( TYPE ( CHILD ( n , idx ) ) ) { case STAR : n = CHILD ( n , idx ) ; n_children = 1 ; break ; case LPAR : n = CHILD ( n , idx + 1 ) ; n_children = NCH ( n ) ; break ; case import_as_names : n = CHILD ( n , idx ) ; n_children = NCH ( n ) ; if ( n_children % 2 == 0 ) { ast_error ( c , n , ""trailing<S2SV_blank>comma<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>without"" ""<S2SV_blank>surrounding<S2SV_blank>parentheses"" ) ; return NULL ; } break ; default : ast_error ( c , n , ""Unexpected<S2SV_blank>node-type<S2SV_blank>in<S2SV_blank>from-import"" ) ; return NULL ; } aliases = _Py_asdl_seq_new ( ( n_children + 1 ) / 2 , c -> c_arena ) ; if ( ! aliases ) return NULL ; if ( TYPE ( n ) == STAR ) { alias_ty import_alias = alias_for_import_name ( c , n , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , 0 , import_alias ) ; } else { for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { alias_ty import_alias = alias_for_import_name ( c , CHILD ( n , i ) , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , i / 2 , import_alias ) ; } } if ( mod != NULL ) modname = mod -> name ; return ImportFrom ( modname , aliases , ndots , lineno , col_offset , n_copy -> n_end_lineno , n_copy -> n_end_col_offset , c -> c_arena ) ; } PyErr_Format ( PyExc_SystemError , ""unknown<S2SV_blank>import<S2SV_blank>statement:<S2SV_blank>starts<S2SV_blank>with<S2SV_blank>command<S2SV_blank>\'%s\'"" , STR ( CHILD ( n , 0 ) ) ) ; return NULL ; }
","
",CWE-125
608,"CWE-119 int vp9_rc_pick_q_and_bounds ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { int q ; <S2SV_StartBug> if ( cpi -> pass == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) <S2SV_EndBug> q = rc_pick_q_and_bounds_one_pass_cbr ( cpi , bottom_index , top_index ) ; else q = rc_pick_q_and_bounds_one_pass_vbr ( cpi , bottom_index , top_index ) ; } else { q = rc_pick_q_and_bounds_two_pass ( cpi , bottom_index , top_index ) ; } if ( cpi -> sf . use_nonrd_pick_mode ) { <S2SV_StartBug> if ( q == 0 ) <S2SV_EndBug> q ++ ; if ( cpi -> sf . force_frame_boost == 1 ) q -= cpi -> sf . max_delta_qindex ; if ( q < * bottom_index ) * bottom_index = q ; else if ( q > * top_index ) * top_index = q ; } return q ; }
","<S2SV_ModStart> ( cpi -> oxcf . <S2SV_ModStart> -> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> ) q = <S2SV_ModStart> { if ( <S2SV_ModEnd> cpi -> sf
",CWE-119
609,"CWE-119 int add_control_packet ( struct mt_packet * packet , enum mt_cptype cptype , void * cpdata , unsigned short data_len ) { unsigned char * data = packet -> data + packet -> size ; unsigned int act_size = data_len + ( cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN ) ; <S2SV_StartBug> if ( packet -> size + act_size > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"" ) , MT_PACKET_LEN ) ; return - 1 ; } if ( cptype == MT_CPTYPE_PLAINDATA ) { memcpy ( data , cpdata , data_len ) ; packet -> size += data_len ; return data_len ; } memcpy ( data , mt_mactelnet_cpmagic , sizeof ( mt_mactelnet_cpmagic ) ) ; data [ 4 ] = cptype ; # if BYTE_ORDER == LITTLE_ENDIAN { unsigned int templen ; templen = htonl ( data_len ) ; memcpy ( data + 5 , & templen , sizeof ( templen ) ) ; } # else memcpy ( data + 5 , & data_len , sizeof ( data_len ) ) ; # endif if ( data_len > 0 ) { memcpy ( data + MT_CPHEADER_LEN , cpdata , data_len ) ; } packet -> size += act_size ; return act_size ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> act_size > MT_PACKET_LEN <S2SV_ModStart> act_size > MT_PACKET_LEN - packet -> size
",CWE-119
611,"CWE-732 static M_bool M_fs_check_overwrite_allowed ( const char * p1 , const char * p2 , M_uint32 mode ) { M_fs_info_t * info = NULL ; char * pold = NULL ; char * pnew = NULL ; M_fs_type_t type ; M_bool ret = M_TRUE ; if ( mode & M_FS_FILE_MODE_OVERWRITE ) return M_TRUE ; if ( M_fs_info ( & info , p1 , M_FS_PATH_INFO_FLAGS_BASIC ) != M_FS_ERROR_SUCCESS ) return M_FALSE ; type = M_fs_info_get_type ( info ) ; M_fs_info_destroy ( info ) ; if ( type != M_FS_TYPE_DIR ) { if ( M_fs_perms_can_access ( p2 , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { ret = M_FALSE ; goto done ; } } pold = M_fs_path_basename ( p1 , M_FS_SYSTEM_AUTO ) ; pnew = M_fs_path_join ( p2 , pnew , M_FS_SYSTEM_AUTO ) ; if ( M_fs_perms_can_access ( pnew , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { ret = M_FALSE ; goto done ; } done : M_free ( pnew ) ; M_free ( pold ) ; return ret ; }
","
",CWE-732
612,"CWE-190 static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
","<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
",CWE-190
613,"CWE-20 static int ssl_scan_clienthello_tlsext ( SSL * s , PACKET * pkt , int * al ) { unsigned int type ; int renegotiate_seen = 0 ; PACKET extensions ; * al = SSL_AD_DECODE_ERROR ; s -> servername_done = 0 ; s -> tlsext_status_type = - 1 ; # ifndef OPENSSL_NO_NEXTPROTONEG s -> s3 -> next_proto_neg_seen = 0 ; # endif OPENSSL_free ( s -> s3 -> alpn_selected ) ; s -> s3 -> alpn_selected = NULL ; s -> s3 -> alpn_selected_len = 0 ; OPENSSL_free ( s -> s3 -> alpn_proposed ) ; s -> s3 -> alpn_proposed = NULL ; s -> s3 -> alpn_proposed_len = 0 ; # ifndef OPENSSL_NO_HEARTBEATS s -> tlsext_heartbeat &= ~ ( SSL_DTLSEXT_HB_ENABLED | SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ) ; # endif # ifndef OPENSSL_NO_EC if ( s -> options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG ) ssl_check_for_safari ( s , pkt ) ; # endif OPENSSL_free ( s -> s3 -> tmp . peer_sigalgs ) ; s -> s3 -> tmp . peer_sigalgs = NULL ; <S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> # ifndef OPENSSL_NO_SRP OPENSSL_free ( s -> srp_ctx . login ) ; s -> srp_ctx . login = NULL ; # endif s -> srtp_profile = NULL ; if ( PACKET_remaining ( pkt ) == 0 ) goto ri_check ; if ( ! PACKET_as_length_prefixed_2 ( pkt , & extensions ) ) return 0 ; if ( ! tls1_check_duplicate_extensions ( & extensions ) ) return 0 ; while ( PACKET_get_net_2 ( & extensions , & type ) ) { PACKET extension ; if ( ! PACKET_get_length_prefixed_2 ( & extensions , & extension ) ) return 0 ; if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 0 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tlsext_debug_arg ) ; if ( type == TLSEXT_TYPE_renegotiate ) { if ( ! ssl_parse_clienthello_renegotiate_ext ( s , & extension , al ) ) return 0 ; renegotiate_seen = 1 ; } else if ( s -> version == SSL3_VERSION ) { } else if ( type == TLSEXT_TYPE_server_name ) { unsigned int servname_type ; PACKET sni , hostname ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & sni ) || PACKET_remaining ( & sni ) == 0 ) { return 0 ; } if ( ! PACKET_get_1 ( & sni , & servname_type ) || servname_type != TLSEXT_NAMETYPE_host_name || ! PACKET_as_length_prefixed_2 ( & sni , & hostname ) ) { return 0 ; } if ( ! s -> hit ) { if ( PACKET_remaining ( & hostname ) > TLSEXT_MAXLEN_host_name ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if ( PACKET_contains_zero_byte ( & hostname ) ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if ( ! PACKET_strndup ( & hostname , & s -> session -> tlsext_hostname ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } s -> servername_done = 1 ; } else { s -> servername_done = s -> session -> tlsext_hostname && PACKET_equal ( & hostname , s -> session -> tlsext_hostname , strlen ( s -> session -> tlsext_hostname ) ) ; } } # ifndef OPENSSL_NO_SRP else if ( type == TLSEXT_TYPE_srp ) { PACKET srp_I ; if ( ! PACKET_as_length_prefixed_1 ( & extension , & srp_I ) ) return 0 ; if ( PACKET_contains_zero_byte ( & srp_I ) ) return 0 ; if ( ! PACKET_strndup ( & srp_I , & s -> srp_ctx . login ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } # endif # ifndef OPENSSL_NO_EC else if ( type == TLSEXT_TYPE_ec_point_formats ) { PACKET ec_point_format_list ; if ( ! PACKET_as_length_prefixed_1 ( & extension , & ec_point_format_list ) || PACKET_remaining ( & ec_point_format_list ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! PACKET_memdup ( & ec_point_format_list , & s -> session -> tlsext_ecpointformatlist , & s -> session -> tlsext_ecpointformatlist_length ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } } else if ( type == TLSEXT_TYPE_elliptic_curves ) { PACKET elliptic_curve_list ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & elliptic_curve_list ) || PACKET_remaining ( & elliptic_curve_list ) == 0 || ( PACKET_remaining ( & elliptic_curve_list ) % 2 ) != 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! PACKET_memdup ( & elliptic_curve_list , & s -> session -> tlsext_ellipticcurvelist , & s -> session -> tlsext_ellipticcurvelist_length ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } } # endif else if ( type == TLSEXT_TYPE_session_ticket ) { if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tls_session_ticket_ext_cb_arg ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } else if ( type == TLSEXT_TYPE_signature_algorithms ) { PACKET supported_sig_algs ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & supported_sig_algs ) || ( PACKET_remaining ( & supported_sig_algs ) % 2 ) != 0 || PACKET_remaining ( & supported_sig_algs ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! tls1_save_sigalgs ( s , PACKET_data ( & supported_sig_algs ) , PACKET_remaining ( & supported_sig_algs ) ) ) { return 0 ; } } } else if ( type == TLSEXT_TYPE_status_request ) { if ( ! PACKET_get_1 ( & extension , ( unsigned int * ) & s -> tlsext_status_type ) ) { return 0 ; } # ifndef OPENSSL_NO_OCSP if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp ) { const unsigned char * ext_data ; PACKET responder_id_list , exts ; if ( ! PACKET_get_length_prefixed_2 ( & extension , & responder_id_list ) ) return 0 ; sk_OCSP_RESPID_pop_free ( s -> tlsext_ocsp_ids , OCSP_RESPID_free ) ; if ( PACKET_remaining ( & responder_id_list ) > 0 ) { s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ; if ( s -> tlsext_ocsp_ids == NULL ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } else { s -> tlsext_ocsp_ids = NULL ; } while ( PACKET_remaining ( & responder_id_list ) > 0 ) { OCSP_RESPID * id ; PACKET responder_id ; const unsigned char * id_data ; if ( ! PACKET_get_length_prefixed_2 ( & responder_id_list , & responder_id ) || PACKET_remaining ( & responder_id ) == 0 ) { return 0 ; } id_data = PACKET_data ( & responder_id ) ; id = d2i_OCSP_RESPID ( NULL , & id_data , PACKET_remaining ( & responder_id ) ) ; if ( id == NULL ) return 0 ; if ( id_data != PACKET_end ( & responder_id ) ) { OCSP_RESPID_free ( id ) ; return 0 ; } if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) ) { OCSP_RESPID_free ( id ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } if ( ! PACKET_as_length_prefixed_2 ( & extension , & exts ) ) return 0 ; if ( PACKET_remaining ( & exts ) > 0 ) { ext_data = PACKET_data ( & exts ) ; sk_X509_EXTENSION_pop_free ( s -> tlsext_ocsp_exts , X509_EXTENSION_free ) ; s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & ext_data , PACKET_remaining ( & exts ) ) ; if ( s -> tlsext_ocsp_exts == NULL || ext_data != PACKET_end ( & exts ) ) { return 0 ; } } } else # endif { s -> tlsext_status_type = - 1 ; } } # ifndef OPENSSL_NO_HEARTBEATS else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_heartbeat ) { unsigned int hbtype ; if ( ! PACKET_get_1 ( & extension , & hbtype ) || PACKET_remaining ( & extension ) ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } switch ( hbtype ) { case 0x01 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; break ; case 0x02 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ; break ; default : * al = SSL_AD_ILLEGAL_PARAMETER ; return 0 ; } } # endif # ifndef OPENSSL_NO_NEXTPROTONEG else if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) { s -> s3 -> next_proto_neg_seen = 1 ; } # endif else if ( type == TLSEXT_TYPE_application_layer_protocol_negotiation && s -> s3 -> tmp . finish_md_len == 0 ) { if ( ! tls1_alpn_handle_client_hello ( s , & extension , al ) ) return 0 ; } # ifndef OPENSSL_NO_SRTP else if ( SSL_IS_DTLS ( s ) && SSL_get_srtp_profiles ( s ) && type == TLSEXT_TYPE_use_srtp ) { if ( ssl_parse_clienthello_use_srtp_ext ( s , & extension , al ) ) return 0 ; } # endif else if ( type == TLSEXT_TYPE_encrypt_then_mac ) <S2SV_StartBug> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> else if ( ! s -> hit ) { if ( custom_ext_parse ( s , 1 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , al ) <= 0 ) return 0 ; } } if ( PACKET_remaining ( pkt ) != 0 ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } ri_check : if ( ! renegotiate_seen && s -> renegotiate && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) { * al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT , SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED ) ; return 0 ; } return 1 ; }
","<S2SV_ModStart> ; s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; # ifndef <S2SV_ModStart> ) s -> tlsext_use_etm = 1 <S2SV_ModEnd> ; else if
",CWE-20
614,"CWE-362 static void __xen_evtchn_do_upcall ( void ) { struct vcpu_info * vcpu_info = __this_cpu_read ( xen_vcpu ) ; <S2SV_StartBug> int cpu = smp_processor_id ( ) ; <S2SV_EndBug> do { vcpu_info -> evtchn_upcall_pending = 0 ; xen_evtchn_handle_events ( cpu ) ; BUG_ON ( ! irqs_disabled ( ) ) ; virt_rmb ( ) ; } while ( vcpu_info -> evtchn_upcall_pending ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> = smp_processor_id ( ) ; read_lock ( & evtchn_rwlock <S2SV_ModStart> evtchn_upcall_pending ) ; read_unlock ( & evtchn_rwlock ) ;
",CWE-362
615,"CWE-89 static CURLcode smtp_connect ( struct connectdata * conn , bool * done ) { CURLcode result ; struct smtp_conn * smtpc = & conn -> proto . smtpc ; struct SessionHandle * data = conn -> data ; struct pingpong * pp = & smtpc -> pp ; <S2SV_StartBug> const char * path = conn -> data -> state . path ; <S2SV_EndBug> int len ; char localhost [ HOSTNAME_MAX + 1 ] ; * done = FALSE ; Curl_reset_reqproto ( conn ) ; result = smtp_init ( conn ) ; if ( CURLE_OK != result ) return result ; conn -> bits . close = FALSE ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( conn -> bits . tunnel_proxy && conn -> bits . httpproxy ) { struct HTTP http_proxy ; struct FTP * smtp_save ; smtp_save = data -> state . proto . smtp ; memset ( & http_proxy , 0 , sizeof ( http_proxy ) ) ; data -> state . proto . http = & http_proxy ; result = Curl_proxyCONNECT ( conn , FIRSTSOCKET , conn -> host . name , conn -> remote_port ) ; data -> state . proto . smtp = smtp_save ; if ( CURLE_OK != result ) return result ; } if ( ( conn -> handler -> protocol & CURLPROTO_SMTPS ) && data -> state . used_interface != Curl_if_multi ) { result = Curl_ssl_connect ( conn , FIRSTSOCKET ) ; if ( result ) return result ; } Curl_pp_init ( pp ) ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( ! * path ) { if ( ! Curl_gethostname ( localhost , sizeof localhost ) ) path = localhost ; else path = ""localhost"" ; } <S2SV_StartBug> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; <S2SV_EndBug> if ( ! smtpc -> domain ) return CURLE_OUT_OF_MEMORY ; state ( conn , SMTP_SERVERGREET ) ; if ( data -> state . used_interface == Curl_if_multi ) result = smtp_multi_statemach ( conn , done ) ; else { result = smtp_easy_statemach ( conn ) ; if ( ! result ) * done = TRUE ; } return result ; }
","<S2SV_ModStart> state . path <S2SV_ModEnd> ; char localhost <S2SV_ModStart> ""localhost"" ; } result = Curl_urldecode ( conn -> data , path , 0 , & <S2SV_ModStart> smtpc -> domain , NULL , TRUE ) ; if ( result ) return result <S2SV_ModEnd> ; state (
",CWE-89
616,"CWE-125 int mutt_seqset_iterator_next ( struct SeqsetIterator * iter , unsigned int * next ) { if ( ! iter || ! next ) return - 1 ; if ( iter -> in_range ) { if ( ( iter -> down && ( iter -> range_cur == ( iter -> range_end - 1 ) ) ) || ( ! iter -> down && ( iter -> range_cur == ( iter -> range_end + 1 ) ) ) ) { iter -> in_range = 0 ; } } if ( ! iter -> in_range ) { iter -> substr_cur = iter -> substr_end ; if ( iter -> substr_cur == iter -> eostr ) return 1 ; <S2SV_StartBug> while ( ! * ( iter -> substr_cur ) ) <S2SV_EndBug> iter -> substr_cur ++ ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ) = '\\0' ; char * range_sep = strchr ( iter -> substr_cur , ':' ) ; if ( range_sep ) * range_sep ++ = '\\0' ; if ( mutt_str_atoui ( iter -> substr_cur , & iter -> range_cur ) != 0 ) return - 1 ; if ( range_sep ) { if ( mutt_str_atoui ( range_sep , & iter -> range_end ) != 0 ) return - 1 ; } else iter -> range_end = iter -> range_cur ; iter -> down = ( iter -> range_end < iter -> range_cur ) ; iter -> in_range = 1 ; } * next = iter -> range_cur ; if ( iter -> down ) iter -> range_cur -- ; else iter -> range_cur ++ ; return 0 ; }
","<S2SV_ModStart> return 1 ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ++ <S2SV_ModEnd> ) = '\\0'
",CWE-125
621,"CWE-119 void vp9_rc_set_frame_target ( VP9_COMP * cpi , int target ) { const VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; rc -> this_frame_target = target ; <S2SV_StartBug> rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / <S2SV_EndBug> ( cm -> width * cm -> height ) ; }
","<S2SV_ModStart> = target ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ;
",CWE-119
622,"CWE-189 static void diff_bytes_c ( uint8_t * dst , const uint8_t * src1 , const uint8_t * src2 , int w ) { long i ; # if ! HAVE_FAST_UNALIGNED if ( ( long ) src2 & ( sizeof ( long ) - 1 ) ) { for ( i = 0 ; i + 7 < w ; i += 8 ) { dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; dst [ i + 1 ] = src1 [ i + 1 ] - src2 [ i + 1 ] ; dst [ i + 2 ] = src1 [ i + 2 ] - src2 [ i + 2 ] ; dst [ i + 3 ] = src1 [ i + 3 ] - src2 [ i + 3 ] ; dst [ i + 4 ] = src1 [ i + 4 ] - src2 [ i + 4 ] ; dst [ i + 5 ] = src1 [ i + 5 ] - src2 [ i + 5 ] ; dst [ i + 6 ] = src1 [ i + 6 ] - src2 [ i + 6 ] ; dst [ i + 7 ] = src1 [ i + 7 ] - src2 [ i + 7 ] ; } } else # endif <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; }
","<S2SV_ModStart> <= w - ( int )
",CWE-189
623,"CWE-000 int fit_check_format ( const void * fit , ulong size ) { int ret ; ret = fdt_check_header ( fit ) ; if ( ret ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>flattened<S2SV_blank>device<S2SV_blank>tree<S2SV_blank>(err=%d)\\n"" , ret ) ; return - ENOEXEC ; } <S2SV_StartBug> if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { <S2SV_EndBug> log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\n"" ) ; return - ENOMSG ; } if ( IMAGE_ENABLE_TIMESTAMP ) { if ( ! fdt_getprop ( fit , 0 , FIT_TIMESTAMP_PROP , NULL ) ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>timestamp\\n"" ) ; return - ENODATA ; } } if ( fdt_path_offset ( fit , FIT_IMAGES_PATH ) < 0 ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>images<S2SV_blank>parent<S2SV_blank>node\\n"" ) ; return - ENOENT ; } return 0 ; }
","<S2SV_ModStart> } if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; if ( ret ) { log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; return - EINVAL ; } } if (
",CWE-000
626,"CWE-20 int bt_sock_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int err = 0 ; size_t target , copied = 0 ; long timeo ; if ( flags & MSG_OOB ) <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> msg -> msg_namelen = 0 ; BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%zu"" , sk , size ) ; lock_sock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { struct sk_buff * skb ; int chunk ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( ! skb ) { if ( copied >= target ) break ; err = sock_error ( sk ) ; if ( err ) break ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; err = - EAGAIN ; if ( ! timeo ) break ; timeo = bt_sock_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( ! copied ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { int skb_len = skb_headlen ( skb ) ; if ( chunk <= skb_len ) { __skb_pull ( skb , chunk ) ; } else { struct sk_buff * frag ; __skb_pull ( skb , skb_len ) ; chunk -= skb_len ; skb_walk_frags ( skb , frag ) { if ( chunk <= frag -> len ) { skb -> len -= chunk ; skb -> data_len -= chunk ; __skb_pull ( frag , chunk ) ; break ; } else if ( frag -> len ) { chunk -= frag -> len ; skb -> len -= frag -> len ; skb -> data_len -= frag -> len ; __skb_pull ( frag , frag -> len ) ; } } } if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; out : release_sock ( sk ) ; return copied ? : err ; }
","<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
",CWE-20
628,"CWE-119 static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , ""Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n"" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , ""Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n"" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; <S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n"" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>"" ""resource.\\n"" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , ""Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n"" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , ""Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n"" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }
","<S2SV_ModStart> ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ;
",CWE-119
629,"CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ip6t_entry * e = ( struct ip6t_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ip6t_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( ""iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> unconditional ( & e -> ipv6 ) ) || visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( ""Back<S2SV_blank>unset<S2SV_blank>"" ""on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>"" ""rule<S2SV_blank>%u\\n"" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ip6t_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ip6t_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ip6t_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ip6t_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }
","<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
",CWE-119
631,"CWE-476 static void <S2SV_StartBug> sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) { <S2SV_EndBug> newspan -> _next = before ; newspan -> _prev = before -> _prev ; before -> _prev -> _next = newspan ; before -> _prev = newspan ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> , sraSpan * before ) { if ( newspan && <S2SV_ModStart> newspan ; } }
",CWE-476
633,"CWE-362 struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , const u8 * addr , gfp_t gfp ) { struct ieee80211_local * local = sdata -> local ; struct sta_info * sta ; struct timespec uptime ; struct ieee80211_tx_latency_bin_ranges * tx_latency ; int i ; sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; if ( ! sta ) return NULL ; rcu_read_lock ( ) ; tx_latency = rcu_dereference ( local -> tx_latency ) ; if ( tx_latency ) { sta -> tx_lat = kzalloc ( IEEE80211_NUM_TIDS * sizeof ( struct ieee80211_tx_latency_stat ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat ) { rcu_read_unlock ( ) ; goto free ; } if ( tx_latency -> n_ranges ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> tx_lat [ i ] . bin_count = tx_latency -> n_ranges + 1 ; sta -> tx_lat [ i ] . bins = kcalloc ( sta -> tx_lat [ i ] . bin_count , sizeof ( u32 ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat [ i ] . bins ) { rcu_read_unlock ( ) ; goto free ; } } } } rcu_read_unlock ( ) ; <S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ; INIT_WORK ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; mutex_init ( & sta -> ampdu_mlme . mtx ) ; # ifdef CONFIG_MAC80211_MESH if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && ! sdata -> u . mesh . user_mpm ) init_timer ( & sta -> plink_timer ) ; sta -> nonpeer_pm = NL80211_MESH_POWER_ACTIVE ; # endif memcpy ( sta -> sta . addr , addr , ETH_ALEN ) ; sta -> local = local ; sta -> sdata = sdata ; sta -> last_rx = jiffies ; sta -> sta_state = IEEE80211_STA_NONE ; do_posix_clock_monotonic_gettime ( & uptime ) ; sta -> last_connected = uptime . tv_sec ; ewma_init ( & sta -> avg_signal , 1024 , 8 ) ; for ( i = 0 ; i < ARRAY_SIZE ( sta -> chain_signal_avg ) ; i ++ ) ewma_init ( & sta -> chain_signal_avg [ i ] , 1024 , 8 ) ; if ( sta_prepare_rate_control ( local , sta , gfp ) ) goto free ; for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> timer_to_tid [ i ] = i ; } for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { skb_queue_head_init ( & sta -> ps_tx_buf [ i ] ) ; skb_queue_head_init ( & sta -> tx_filtered [ i ] ) ; } for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) sta -> last_seq_ctrl [ i ] = cpu_to_le16 ( USHRT_MAX ) ; sta -> sta . smps_mode = IEEE80211_SMPS_OFF ; if ( sdata -> vif . type == NL80211_IFTYPE_AP || sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) { struct ieee80211_supported_band * sband = local -> hw . wiphy -> bands [ ieee80211_get_sdata_band ( sdata ) ] ; u8 smps = ( sband -> ht_cap . cap & IEEE80211_HT_CAP_SM_PS ) >> IEEE80211_HT_CAP_SM_PS_SHIFT ; switch ( smps ) { case WLAN_HT_SMPS_CONTROL_DISABLED : sta -> known_smps_mode = IEEE80211_SMPS_OFF ; break ; case WLAN_HT_SMPS_CONTROL_STATIC : sta -> known_smps_mode = IEEE80211_SMPS_STATIC ; break ; case WLAN_HT_SMPS_CONTROL_DYNAMIC : sta -> known_smps_mode = IEEE80211_SMPS_DYNAMIC ; break ; default : WARN_ON ( 1 ) ; } } sta_dbg ( sdata , ""Allocated<S2SV_blank>STA<S2SV_blank>%pM\\n"" , sta -> sta . addr ) ; return sta ; free : if ( sta -> tx_lat ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) kfree ( sta -> tx_lat [ i ] . bins ) ; kfree ( sta -> tx_lat ) ; } kfree ( sta ) ; return NULL ; }
","<S2SV_ModStart> sta -> lock ) ; spin_lock_init ( & sta -> ps_lock
",CWE-362
634,"CWE-787 int flb_gzip_compress ( void * in_data , size_t in_len , void * * out_data , size_t * out_len ) { int flush ; int status ; int footer_start ; uint8_t * pb ; size_t out_size ; void * out_buf ; z_stream strm ; mz_ulong crc ; <S2SV_StartBug> out_size = in_len + 32 ; <S2SV_EndBug> out_buf = flb_malloc ( out_size ) ; if ( ! out_buf ) { flb_errno ( ) ; flb_error ( ""[gzip]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>outgoing<S2SV_blank>buffer"" ) ; return - 1 ; } memset ( & strm , '\\0' , sizeof ( strm ) ) ; strm . zalloc = Z_NULL ; strm . zfree = Z_NULL ; strm . opaque = Z_NULL ; strm . next_in = in_data ; strm . avail_in = in_len ; strm . total_out = 0 ; deflateInit2 ( & strm , Z_DEFAULT_COMPRESSION , Z_DEFLATED , - Z_DEFAULT_WINDOW_BITS , 9 , Z_DEFAULT_STRATEGY ) ; gzip_header ( out_buf ) ; pb = ( uint8_t * ) out_buf + FLB_GZIP_HEADER_OFFSET ; flush = Z_NO_FLUSH ; while ( 1 ) { strm . next_out = pb + strm . total_out ; strm . avail_out = out_size - ( pb - ( uint8_t * ) out_buf ) ; if ( strm . avail_in == 0 ) { flush = Z_FINISH ; } status = deflate ( & strm , flush ) ; if ( status == Z_STREAM_END ) { break ; } else if ( status != Z_OK ) { deflateEnd ( & strm ) ; return - 1 ; } } if ( deflateEnd ( & strm ) != Z_OK ) { flb_free ( out_buf ) ; return - 1 ; } * out_len = strm . total_out ; footer_start = FLB_GZIP_HEADER_OFFSET + * out_len ; pb = ( uint8_t * ) out_buf + footer_start ; crc = mz_crc32 ( MZ_CRC32_INIT , in_data , in_len ) ; * pb ++ = crc & 0xFF ; * pb ++ = ( crc >> 8 ) & 0xFF ; * pb ++ = ( crc >> 16 ) & 0xFF ; * pb ++ = ( crc >> 24 ) & 0xFF ; * pb ++ = in_len & 0xFF ; * pb ++ = ( in_len >> 8 ) & 0xFF ; * pb ++ = ( in_len >> 16 ) & 0xFF ; * pb ++ = ( in_len >> 24 ) & 0xFF ; * out_len += FLB_GZIP_HEADER_OFFSET + 8 ; * out_data = out_buf ; return 0 ; }
","<S2SV_ModStart> mz_ulong crc ; int max_input_expansion = ( ( int ) ( in_len / 32000 ) + 1 ) * 5 ; out_size = 10 + 8 + max_input_expansion + in_len <S2SV_ModEnd> ; out_buf =
",CWE-787
635,"CWE-787 static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; <S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> cmap_entry_size = tga [ 7 ] ; # if 0 <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug> # endif <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader:<S2SV_blank>memory<S2SV_blank>out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry,<S2SV_blank>compressed<S2SV_blank>tga<S2SV_blank>files<S2SV_blank>are<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>palette<S2SV_blank>-<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
","<S2SV_ModStart> ; cmap_len = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> 0 x_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; y_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> endif image_w = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_h = get_tga_ushort <S2SV_ModEnd> ( & tga
",CWE-787
638,"CWE-400 int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; struct xfs_mount * mp = context -> dp -> i_mount ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( mp -> m_attr_geo , & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . geo = context -> dp -> i_mount -> m_attr_geo ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ; args . rmtvaluelen = valuelen ; args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ; <S2SV_StartBug> if ( retval ) <S2SV_EndBug> return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }
","<S2SV_ModStart> ; if ( ! retval ) <S2SV_ModEnd> retval = context
",CWE-400
639,"CWE-119 static void set_default_lf_deltas ( VP8_COMP * cpi ) { cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 1 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 1 ; <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> cpi -> mb . e_mbd . ref_lf_deltas [ INTRA_FRAME ] = 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ LAST_FRAME ] = 0 ; cpi -> mb . e_mbd . ref_lf_deltas [ GOLDEN_FRAME ] = - 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ ALTREF_FRAME ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 0 ] = 4 ; if ( cpi -> oxcf . Mode == MODE_REALTIME ) cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 12 ; else cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 2 ] = 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 3 ] = 4 ; }
","<S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi ->
",CWE-119
642,"CWE-119 <S2SV_StartBug> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> { u8 obuf [ ] = { 0x51 } ; u8 ibuf [ ] = { 0 } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> return - EIO ; <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> & dw2104_ts2020_config , <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ; return 0 ; } info ( ""Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>RS2000/TS2020!"" ) ; return - EIO ; }
","<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )
",CWE-119
651,"CWE-125 static u64 __skb_get_nlattr ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; <S2SV_StartBug> if ( skb_is_nonlinear ( skb ) ) <S2SV_EndBug> return 0 ; if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ; nla = nla_find ( ( struct nlattr * ) & skb -> data [ A ] , skb -> len - A , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }
","<S2SV_ModStart> skb_is_nonlinear ( skb ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr
",CWE-125
654,"CWE-190 <S2SV_StartBug> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <S2SV_EndBug> { jas_stream_t * in ; jas_iccprof_t * prof ; if ( ! ( in = jas_stream_memopen ( JAS_CAST ( char * , buf ) , len ) ) ) goto error ; if ( ! ( prof = jas_iccprof_load ( in ) ) ) goto error ; jas_stream_close ( in ) ; return prof ; error : if ( in ) jas_stream_close ( in ) ; return 0 ; }
","<S2SV_ModStart> * jas_iccprof_createfrombuf ( jas_uchar <S2SV_ModEnd> * buf ,
",CWE-190
656,"CWE-190 TfLiteIntArray * TfLiteIntArrayCreate ( int size ) { <S2SV_StartBug> TfLiteIntArray * ret = <S2SV_EndBug> <S2SV_StartBug> ( TfLiteIntArray * ) malloc ( TfLiteIntArrayGetSizeInBytes ( size ) ) ; <S2SV_EndBug> ret -> size = size ; return ret ; }
","<S2SV_ModStart> size ) { int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ; if ( alloc_size <= 0 ) return NULL ; <S2SV_ModStart> ) malloc ( alloc_size ) ; if ( ! ret ) return ret <S2SV_ModEnd> ; ret ->
",CWE-190
659,"CWE-119 static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { s = ROUNDUP ( s , sizeof ( uint32_t ) ) ; if ( ADD_OVERFLOW ( req_mem , s , & req_mem ) ) return TEE_ERROR_BAD_PARAMETERS ; ta_private_memref [ n ] = true ; break ; } res = tee_mmu_vbuf_to_mobj_offs ( utc , va , s , & param -> u [ n ] . mem . mobj , & param -> u [ n ] . mem . offs ) ; if ( res != TEE_SUCCESS ) return res ; break ; default : break ; } } if ( req_mem == 0 ) return TEE_SUCCESS ; res = alloc_temp_sec_mem ( req_mem , mobj_tmp , & dst ) ; if ( res != TEE_SUCCESS ) return res ; dst_offs = 0 ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { if ( ! ta_private_memref [ n ] ) continue ; s = ROUNDUP ( param -> u [ n ] . mem . size , sizeof ( uint32_t ) ) ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { res = tee_svc_copy_from_user ( dst , va , param -> u [ n ] . mem . size ) ; if ( res != TEE_SUCCESS ) return res ; param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; case TEE_PARAM_TYPE_MEMREF_OUTPUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; default : continue ; } } return TEE_SUCCESS ; }
","<S2SV_ModStart> return res ; res = utee_param_to_param ( utc , <S2SV_ModEnd> param , callee_params <S2SV_ModStart> , callee_params ) ; if ( res != TEE_SUCCESS ) return res
",CWE-119
660,"CWE-119 static Image * ReadDIBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { DIBInfo dib_info ; Image * image ; IndexPacket index ; ssize_t bit , y ; MagickBooleanType status ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_line , length ; ssize_t count ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & dib_info , 0 , sizeof ( dib_info ) ) ; dib_info . size = ReadBlobLSBLong ( image ) ; if ( dib_info . size != 40 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; dib_info . width = ( short ) ReadBlobLSBLong ( image ) ; dib_info . height = ( short ) ReadBlobLSBLong ( image ) ; dib_info . planes = ReadBlobLSBShort ( image ) ; dib_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; dib_info . compression = ReadBlobLSBLong ( image ) ; dib_info . image_size = ReadBlobLSBLong ( image ) ; dib_info . x_pixels = ReadBlobLSBLong ( image ) ; dib_info . y_pixels = ReadBlobLSBLong ( image ) ; dib_info . number_colors = ReadBlobLSBLong ( image ) ; dib_info . colors_important = ReadBlobLSBLong ( image ) ; if ( ( dib_info . compression == BI_BITFIELDS ) && ( ( dib_info . bits_per_pixel == 16 ) || ( dib_info . bits_per_pixel == 32 ) ) ) { dib_info . red_mask = ReadBlobLSBLong ( image ) ; dib_info . green_mask = ReadBlobLSBLong ( image ) ; dib_info . blue_mask = ReadBlobLSBLong ( image ) ; } image -> matte = dib_info . bits_per_pixel == 32 ? MagickTrue : MagickFalse ; image -> columns = ( size_t ) MagickAbsoluteValue ( dib_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( dib_info . height ) ; image -> depth = 8 ; if ( ( dib_info . number_colors != 0 ) || ( dib_info . bits_per_pixel < 16 ) ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = dib_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << dib_info . bits_per_pixel ; } if ( image_info -> size ) { RectangleInfo geometry ; MagickStatusType flags ; flags = ParseAbsoluteGeometry ( image_info -> size , & geometry ) ; if ( flags & WidthValue ) if ( ( geometry . width != 0 ) && ( geometry . width < image -> columns ) ) image -> columns = geometry . width ; if ( flags & HeightValue ) if ( ( geometry . height != 0 ) && ( geometry . height < image -> rows ) ) image -> rows = geometry . height ; } <S2SV_StartBug> if ( image -> storage_class == PseudoClass ) <S2SV_EndBug> { size_t length , packet_size ; unsigned char * dib_colormap ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) image -> colors ; dib_colormap = ( unsigned char * ) AcquireQuantumMemory ( length , 4 * sizeof ( * dib_colormap ) ) ; if ( dib_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; packet_size = 4 ; count = ReadBlob ( image , packet_size * image -> colors , dib_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = dib_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } dib_colormap = ( unsigned char * ) RelinquishMagickMemory ( dib_colormap ) ; } if ( dib_info . compression == BI_RLE4 ) dib_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * dib_info . bits_per_pixel + 31 ) / 32 ) ; length = bytes_per_line * image -> rows ; pixel_info = AcquireVirtualMemory ( ( size_t ) image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( dib_info . compression == BI_RGB ) || ( dib_info . compression == BI_BITFIELDS ) ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) ( length ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } else { status = DecodeImage ( image , dib_info . compression ? MagickTrue : MagickFalse , pixels ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } image -> units = PixelsPerCentimeterResolution ; image -> x_resolution = ( double ) dib_info . x_pixels / 100.0 ; image -> y_resolution = ( double ) dib_info . y_pixels / 100.0 ; switch ( dib_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( IndexPacket ) ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( IndexPacket ) ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf ) ; SetPixelIndex ( indexes + x , index ) ; index = ConstrainColormapIndex ( image , * p & 0xf ) ; SetPixelIndex ( indexes + x + 1 , index ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf ) ; SetPixelIndex ( indexes + x , index ) ; p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 8 : { if ( ( dib_info . compression == BI_RLE8 ) || ( dib_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 16 : { unsigned short word ; image -> storage_class = DirectClass ; if ( dib_info . compression == BI_RLE8 ) bytes_per_line = 2 * image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { word = ( * p ++ ) ; word |= ( * p ++ << 8 ) ; if ( dib_info . red_mask == 0 ) { SetPixelRed ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 10 ) & 0x1f ) ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 5 ) & 0x1f ) ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( word & 0x1f ) ) ) ) ; } else { SetPixelRed ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 11 ) & 0x1f ) ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ScaleColor6to8 ( ( unsigned char ) ( ( word >> 5 ) & 0x3f ) ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( word & 0x1f ) ) ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : case 32 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelOpacity ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; if ( dib_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; image = DestroyImage ( image ) ; image = flipped_image ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> height ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",CWE-119
663,"CWE-000 bool_t xdr_krb5_principal ( XDR * xdrs , krb5_principal * objp ) { int ret ; char * p = NULL ; krb5_principal pr = NULL ; static krb5_context context = NULL ; if ( ! context && kadm5_init_krb5_context ( & context ) ) return ( FALSE ) ; switch ( xdrs -> x_op ) { case XDR_ENCODE : if ( * objp ) { if ( ( ret = krb5_unparse_name ( context , * objp , & p ) ) != 0 ) return FALSE ; } if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) free ( p ) ; break ; case XDR_DECODE : if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) { ret = krb5_parse_name ( context , p , & pr ) ; if ( ret != 0 ) return FALSE ; * objp = pr ; free ( p ) ; } else * objp = NULL ; break ; case XDR_FREE : if ( * objp != NULL ) krb5_free_principal ( context , * objp ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } return TRUE ; }
","<S2SV_ModStart> objp ) ; * objp = NULL ;
",CWE-000
665,"CWE-59 static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , <S2SV_StartBug> const char * data , int optional ) <S2SV_EndBug> { # ifdef HAVE_STATVFS struct statvfs sb ; # endif <S2SV_StartBug> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s"" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , fsname , target ) ; return - 1 ; } } if ( ( mountflags & MS_REMOUNT ) || ( mountflags & MS_BIND ) ) { DEBUG ( ""remounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>respect<S2SV_blank>bind<S2SV_blank>or<S2SV_blank>remount<S2SV_blank>options"" , fsname ? fsname : ""(none)"" , target ? target : ""(none)"" ) ; unsigned long rqd_flags = 0 ; if ( mountflags & MS_RDONLY ) rqd_flags |= MS_RDONLY ; # ifdef HAVE_STATVFS if ( statvfs ( fsname , & sb ) == 0 ) { unsigned long required_flags = rqd_flags ; if ( sb . f_flag & MS_NOSUID ) required_flags |= MS_NOSUID ; if ( sb . f_flag & MS_NODEV ) required_flags |= MS_NODEV ; if ( sb . f_flag & MS_RDONLY ) required_flags |= MS_RDONLY ; if ( sb . f_flag & MS_NOEXEC ) required_flags |= MS_NOEXEC ; DEBUG ( ""(at<S2SV_blank>remount)<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>required<S2SV_blank>extra<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>%lu"" , fsname , sb . f_flag , required_flags ) ; if ( ! ( mountflags & MS_REMOUNT ) ) { if ( ! ( required_flags & ~ mountflags ) && rqd_flags == 0 ) { DEBUG ( ""mountflags<S2SV_blank>already<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>skipping<S2SV_blank>remount"" , mountflags ) ; goto skipremount ; } } mountflags |= required_flags ; } # endif if ( mount ( fsname , target , fstype , <S2SV_StartBug> mountflags | MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s"" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , fsname , target ) ; return - 1 ; } } } # ifdef HAVE_STATVFS skipremount : # endif DEBUG ( ""mounted<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\',<S2SV_blank>type<S2SV_blank>\'%s\'"" , fsname , target , fstype ) ; return 0 ; }
","<S2SV_ModStart> , int optional , const char * rootfs <S2SV_ModStart> endif if ( safe_mount <S2SV_ModEnd> ( fsname , <S2SV_ModStart> MS_REMOUNT , data , rootfs <S2SV_ModStart> , data ) < 0
",CWE-59
668,"CWE-119 <S2SV_StartBug> void vp9_fht4x4_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <S2SV_StartBug> vp9_fdct4x4_c ( input , output , stride ) ; <S2SV_EndBug> } else { <S2SV_StartBug> int16_t out [ 4 * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> int i , j ; <S2SV_StartBug> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <S2SV_EndBug> const transform_2d ht = FHT_4 [ tx_type ] ; for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ; if ( i == 0 && temp_in [ 0 ] ) temp_in [ 0 ] += 1 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) <S2SV_StartBug> outptr [ j * 4 + i ] = temp_out [ j ] ; <S2SV_EndBug> } for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = out [ j + i * 4 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) output [ j + i * 4 ] = ( temp_out [ j ] + 1 ) >> 2 ; } } }
","<S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output , <S2SV_ModStart> DCT_DCT ) { vpx_fdct4x4_c <S2SV_ModEnd> ( input , <S2SV_ModStart> } else { tran_low_t <S2SV_ModEnd> out [ 4 <S2SV_ModStart> 4 ] ; <S2SV_ModEnd> int i , <S2SV_ModStart> , j ; tran_low_t <S2SV_ModEnd> temp_in [ 4 <S2SV_ModStart> ++ j ) out <S2SV_ModEnd> [ j *
",CWE-119
669,"CWE-119 <S2SV_StartBug> static const char * parse_array ( cJSON * item , const char * value ) <S2SV_EndBug> { cJSON * child ; if ( * value != '[' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } item -> type = cJSON_Array ; value = skip ( value + 1 ) ; if ( * value == ']' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value ) ) ) ) ) <S2SV_EndBug> return 0 ; while ( * value == ',' ) { cJSON * new_item ; if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ; child -> next = new_item ; new_item -> prev = child ; <S2SV_StartBug> child = new_item ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; } if ( * value == ']' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> ep = value ; return 0 ; }
","<S2SV_ModStart> char * value , const char * * ep <S2SV_ModStart> '[' ) { * ep = value ; return 0 ; <S2SV_ModEnd> } item -> <S2SV_ModStart> == ']' ) return value + 1 ; <S2SV_ModEnd> item -> child <S2SV_ModStart> cJSON_New_Item ( ) ; if ( ! item -> child ) return 0 ; <S2SV_ModEnd> value = skip <S2SV_ModStart> ( value ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> = child ; child = new_item ; <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> == ']' ) return value + 1 ; * ep = value ; <S2SV_ModEnd> return 0 ;
",CWE-119
675,"CWE-125 int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { <S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? ""RF64"" : ""RIFF"" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , ""WAVE"" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ; <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , ""data"" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , ""junk"" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , ""ds64"" , sizeof ( ds64hdr . ckID ) ) ; <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ; <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; } <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } return TRUE ; }
","<S2SV_ModStart> write_junk = 1 , table_length = 0 <S2SV_ModStart> ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> sizeof ( junkchunk <S2SV_ModStart> ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) ) ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk &&
",CWE-125
677,"CWE-416 int wwunpack ( uint8_t * exe , uint32_t exesz , uint8_t * wwsect , struct cli_exe_section * sects , uint16_t scount , uint32_t pe , int desc ) { uint8_t * structs = wwsect + 0x2a1 , * compd , * ccur , * unpd , * ucur , bc ; uint32_t src , srcend , szd , bt , bits ; int error = 0 , i ; cli_dbgmsg ( ""in<S2SV_blank>wwunpack\\n"" ) ; while ( 1 ) { if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , structs , 17 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Array<S2SV_blank>of<S2SV_blank>structs<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section\\n"" ) ; break ; } src = sects [ scount ] . rva - cli_readint32 ( structs ) ; structs += 8 ; szd = cli_readint32 ( structs ) * 4 ; structs += 4 ; srcend = cli_readint32 ( structs ) ; structs += 4 ; unpd = ucur = exe + src + srcend + 4 - szd ; if ( ! szd || ! CLI_ISCONTAINED ( exe , exesz , unpd , szd ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Compressed<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>file\\n"" ) ; break ; } cli_dbgmsg ( ""WWP:<S2SV_blank>src:<S2SV_blank>%x,<S2SV_blank>szd:<S2SV_blank>%x,<S2SV_blank>srcend:<S2SV_blank>%x<S2SV_blank>-<S2SV_blank>%x\\n"" , src , szd , srcend , srcend + 4 - szd ) ; if ( ! ( compd = cli_malloc ( szd ) ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>compd\\n"" ) ; break ; } memcpy ( compd , unpd , szd ) ; memset ( unpd , - 1 , szd ) ; ccur = compd ; RESEED ; while ( ! error ) { uint32_t backbytes , backsize ; uint8_t saved ; BIT ; if ( ! bits ) { if ( ccur - compd >= szd || ! CLI_ISCONTAINED ( exe , exesz , ucur , 1 ) ) error = 1 ; else * ucur ++ = * ccur ++ ; continue ; } BITS ( 2 ) ; if ( bits == 3 ) { uint8_t shifted , subbed = 31 ; BITS ( 2 ) ; shifted = bits + 5 ; if ( bits >= 2 ) { shifted ++ ; subbed += 0x80 ; } backbytes = ( 1 << shifted ) - subbed ; BITS ( shifted ) ; if ( error || bits == 0x1ff ) break ; backbytes += bits ; if ( ! CLI_ISCONTAINED ( exe , exesz , ucur , 2 ) || ! CLI_ISCONTAINED ( exe , exesz , ucur - backbytes , 2 ) ) { error = 1 ; } else { ucur [ 0 ] = * ( ucur - backbytes ) ; ucur [ 1 ] = * ( ucur - backbytes + 1 ) ; ucur += 2 ; } continue ; } saved = bits ; BITS ( 3 ) ; if ( bits < 6 ) { backbytes = bits ; switch ( bits ) { case 4 : backbytes ++ ; case 3 : BIT ; backbytes += bits ; case 0 : case 1 : case 2 : backbytes += 5 ; break ; case 5 : backbytes = 12 ; break ; } BITS ( backbytes ) ; bits += ( 1 << backbytes ) - 31 ; } else if ( bits == 6 ) { BITS ( 0x0e ) ; bits += 0x1fe1 ; } else { BITS ( 0x0f ) ; bits += 0x5fe1 ; } backbytes = bits ; if ( ! saved ) { BIT ; if ( ! bits ) { BIT ; bits += 5 ; } else { BITS ( 3 ) ; if ( bits ) { bits += 6 ; } else { BITS ( 4 ) ; if ( bits ) { bits += 13 ; } else { uint8_t cnt = 4 ; uint16_t shifted = 0x0d ; do { if ( cnt == 7 ) { cnt = 0x0e ; shifted = 0 ; break ; } shifted = ( ( shifted + 2 ) << 1 ) - 1 ; BIT ; cnt ++ ; } while ( ! bits ) ; BITS ( cnt ) ; bits += shifted ; } } } backsize = bits ; } else { backsize = saved + 2 ; } if ( ! CLI_ISCONTAINED ( exe , exesz , ucur , backsize ) || ! CLI_ISCONTAINED ( exe , exesz , ucur - backbytes , backsize ) ) error = 1 ; else while ( backsize -- ) { * ucur = * ( ucur - backbytes ) ; ucur ++ ; } } free ( compd ) ; if ( error ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>decompression<S2SV_blank>error\\n"" ) ; break ; } if ( error || ! * structs ++ ) break ; } if ( ! error ) { if ( pe + 6 > exesz || pe + 7 > exesz || pe + 0x28 > exesz || pe + 0x50 > exesz || pe + 0x14 > exesz ) return CL_EFORMAT ; exe [ pe + 6 ] = ( uint8_t ) scount ; exe [ pe + 7 ] = ( uint8_t ) ( scount >> 8 ) ; <S2SV_StartBug> cli_writeint32 ( & exe [ pe + 0x28 ] , cli_readint32 ( wwsect + 0x295 ) + sects [ scount ] . rva + 0x299 ) ; <S2SV_EndBug> cli_writeint32 ( & exe [ pe + 0x50 ] , cli_readint32 ( & exe [ pe + 0x50 ] ) - sects [ scount ] . vsz ) ; structs = & exe [ ( 0xffff & cli_readint32 ( & exe [ pe + 0x14 ] ) ) + pe + 0x18 ] ; for ( i = 0 ; i < scount ; i ++ ) { if ( ! CLI_ISCONTAINED ( exe , exesz , structs , 0x28 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>structs<S2SV_blank>pointer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return CL_EFORMAT ; } cli_writeint32 ( structs + 8 , sects [ i ] . vsz ) ; cli_writeint32 ( structs + 12 , sects [ i ] . rva ) ; cli_writeint32 ( structs + 16 , sects [ i ] . vsz ) ; cli_writeint32 ( structs + 20 , sects [ i ] . rva ) ; structs += 0x28 ; } if ( ! CLI_ISCONTAINED ( exe , exesz , structs , 0x28 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>structs<S2SV_blank>pointer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return CL_EFORMAT ; } memset ( structs , 0 , 0x28 ) ; error = ( uint32_t ) cli_writen ( desc , exe , exesz ) != exesz ; } return error ; }
","<S2SV_ModStart> 8 ) ; if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva + 0x299 , 4 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>unpack<S2SV_blank>memory<S2SV_blank>address<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.\\n"" ) ; return CL_EFORMAT ; }
",CWE-416
681,"CWE-119 void cJSON_AddItemToObject ( cJSON * object , const char * string , cJSON * item ) { if ( ! item ) return ; if ( item -> string ) cJSON_free ( item -> string ) ; item -> string = cJSON_strdup ( string ) ; cJSON_AddItemToArray ( object , item ) ; }
","
",CWE-119
684,"CWE-287 <S2SV_StartBug> static void oidc_scrub_headers ( request_rec * r ) { <S2SV_EndBug> oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ; if ( cfg -> scrub_request_headers != 0 ) { oidc_scrub_request_headers ( r , OIDC_DEFAULT_HEADER_PREFIX , oidc_cfg_dir_authn_header ( r ) ) ; if ( ( strstr ( cfg -> claim_prefix , OIDC_DEFAULT_HEADER_PREFIX ) != cfg -> claim_prefix ) ) { oidc_scrub_request_headers ( r , cfg -> claim_prefix , NULL ) ; } } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void oidc_scrub_headers (
",CWE-287
685,"CWE-119 TpktState CotpConnection_readToTpktBuffer ( CotpConnection * self ) { uint8_t * buffer = self -> readBuffer -> buffer ; int bufferSize = self -> readBuffer -> maxSize ; int bufPos = self -> readBuffer -> size ; assert ( bufferSize > 4 ) ; int readBytes ; if ( bufPos < 4 ) { readBytes = readFromSocket ( self , buffer + bufPos , 4 - bufPos ) ; if ( readBytes < 0 ) goto exit_closed ; if ( DEBUG_COTP ) { if ( readBytes > 0 ) printf ( ""TPKT:<S2SV_blank>read<S2SV_blank>%i<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>socket\\n"" , readBytes ) ; } bufPos += readBytes ; if ( bufPos == 4 ) { if ( ( buffer [ 0 ] == 3 ) && ( buffer [ 1 ] == 0 ) ) { self -> packetSize = ( buffer [ 2 ] * 0x100 ) + buffer [ 3 ] ; if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>header<S2SV_blank>complete<S2SV_blank>(msg<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%i)\\n"" , self -> packetSize ) ; if ( self -> packetSize > bufferSize ) { if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>large\\n"" ) ; goto exit_error ; } } else { if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>TPKT<S2SV_blank>header.\\n"" ) ; goto exit_error ; } } else goto exit_waiting ; } <S2SV_StartBug> readBytes = readFromSocket ( self , buffer + bufPos , self -> packetSize - bufPos ) ; <S2SV_EndBug> if ( readBytes < 0 ) goto exit_closed ; bufPos += readBytes ; if ( bufPos < self -> packetSize ) goto exit_waiting ; if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>message<S2SV_blank>complete<S2SV_blank>(size<S2SV_blank>=<S2SV_blank>%i)\\n"" , self -> packetSize ) ; self -> readBuffer -> size = bufPos ; return TPKT_PACKET_COMPLETE ; exit_closed : if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>or<S2SV_blank>socket<S2SV_blank>error\\n"" ) ; return TPKT_ERROR ; exit_error : if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>Error<S2SV_blank>parsing<S2SV_blank>message\\n"" ) ; return TPKT_ERROR ; exit_waiting : if ( DEBUG_COTP ) if ( bufPos != 0 ) printf ( ""TPKT:<S2SV_blank>waiting<S2SV_blank>(read<S2SV_blank>%i<S2SV_blank>of<S2SV_blank>%i)\\n"" , bufPos , self -> packetSize ) ; self -> readBuffer -> size = bufPos ; return TPKT_WAITING ; }
","<S2SV_ModStart> exit_waiting ; } if ( self -> packetSize <= bufPos ) goto exit_error ;
",CWE-119
689,"CWE-119 private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , <S2SV_StartBug> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> { cdf_summary_info_header_t si ; cdf_property_info_t * info ; size_t count ; int m ; if ( cdf_unpack_summary_info ( sst , h , & si , & info , & count ) == - 1 ) return - 1 ; if ( NOTMIME ( ms ) ) { const char * str ; if ( file_printf ( ms , ""Composite<S2SV_blank>Document<S2SV_blank>File<S2SV_blank>V2<S2SV_blank>Document"" ) == - 1 ) return - 1 ; if ( file_printf ( ms , "",<S2SV_blank>%s<S2SV_blank>Endian"" , si . si_byte_order == 0xfffe ? ""Little"" : ""Big"" ) == - 1 ) return - 2 ; switch ( si . si_os ) { case 2 : if ( file_printf ( ms , "",<S2SV_blank>Os:<S2SV_blank>Windows,<S2SV_blank>Version<S2SV_blank>%d.%d"" , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; case 1 : if ( file_printf ( ms , "",<S2SV_blank>Os:<S2SV_blank>MacOS,<S2SV_blank>Version<S2SV_blank>%d.%d"" , ( uint32_t ) si . si_os_version >> 8 , si . si_os_version & 0xff ) == - 1 ) return - 2 ; break ; default : if ( file_printf ( ms , "",<S2SV_blank>Os<S2SV_blank>%d,<S2SV_blank>Version:<S2SV_blank>%d.%d"" , si . si_os , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; } <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2desc ) ; <S2SV_EndBug> if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 ) <S2SV_StartBug> return - 2 ; <S2SV_EndBug> } <S2SV_StartBug> m = cdf_file_property_info ( ms , info , count , clsid ) ; <S2SV_EndBug> free ( info ) ; return m == - 1 ? - 2 : m ; }
","<S2SV_ModStart> sst , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { cdf_summary_info_header_t <S2SV_ModStart> break ; } if ( root_storage ) { <S2SV_ModStart> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2desc ) <S2SV_ModStart> - 2 ; } <S2SV_ModStart> , count , root_storage <S2SV_ModEnd> ) ; free
",CWE-119
694,"CWE-255 kadm5_ret_t kadm5_randkey_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * * keyblocks , int * n_keys ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; krb5_int32 now ; kadm5_policy_ent_rec pol ; <S2SV_StartBug> int ret , last_pwd ; <S2SV_EndBug> krb5_boolean have_pol = FALSE ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; if ( keyblocks ) * keyblocks = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; if ( principal == NULL ) return EINVAL ; if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ; ret = apply_keysalt_policy ( handle , adb . policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto done ; if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) { if ( keepold ) return KADM5_PROTECT_PRINCIPAL ; new_n_ks_tuple = 1 ; } ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto done ; ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ; if ( ret ) goto done ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto done ; kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ; ret = krb5_timeofday ( handle -> context , & now ) ; if ( ret ) goto done ; if ( ( adb . aux_attributes & KADM5_POLICY ) ) { ret = get_policy ( handle , adb . policy , & pol , & have_pol ) ; if ( ret ) goto done ; } if ( have_pol ) { ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & last_pwd ) ; if ( ret ) goto done ; # if 0 if ( ( now - last_pwd ) < pol . pw_min_life && ! ( kdb -> attributes & KRB5_KDB_REQUIRES_PWCHANGE ) ) { ret = KADM5_PASS_TOOSOON ; goto done ; } # endif if ( pol . pw_max_life ) kdb -> pw_expiration = now + pol . pw_max_life ; else kdb -> pw_expiration = 0 ; } else { kdb -> pw_expiration = 0 ; } ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ; if ( ret ) goto done ; kdb -> fail_auth_count = 0 ; if ( keyblocks ) { <S2SV_StartBug> ret = decrypt_key_data ( handle -> context , <S2SV_EndBug> <S2SV_StartBug> kdb -> n_key_data , kdb -> key_data , <S2SV_EndBug> keyblocks , n_keys ) ; if ( ret ) goto done ; } kdb -> mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT ; ; ret = k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ; if ( ret ) goto done ; if ( ( ret = kdb_put_entry ( handle , kdb , & adb ) ) ) goto done ; ( void ) k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ; ret = KADM5_OK ; done : free ( new_ks_tuple ) ; kdb_free_entry ( handle , kdb , & adb ) ; if ( have_pol ) kadm5_free_policy_ent ( handle -> lhandle , & pol ) ; return ret ; }
","<S2SV_ModStart> ret , last_pwd , n_new_keys <S2SV_ModStart> keyblocks ) { n_new_keys = count_new_keys ( kdb -> n_key_data , kdb -> key_data ) ; <S2SV_ModStart> -> context , n_new_keys <S2SV_ModEnd> , kdb ->
",CWE-255
696,"CWE-125 static int print_bacp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case BACPOPT_FPEER : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|bacp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> len ; } ND_TCHECK_32BITS <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 <S2SV_ModEnd> ) ; ND_PRINT
",CWE-125
697,"CWE-119 static void update_alt_ref_frame_stats ( VP9_COMP * cpi ) { RATE_CONTROL * const rc = & cpi -> rc ; rc -> frames_since_golden = 0 ; <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> if ( ! cpi -> multi_arf_enabled ) # endif rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 1 ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> rc -> source_alt_ref_pending
",CWE-119
700,"CWE-416 static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MagickPathExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; pwp_image = AcquireImage ( image_info , exception ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , ""SFW95"" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for ( ; ; ) { for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) == 0 ) break ; } if ( c == EOF ) break ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MagickPathExtent , ""slide_%02ld.sfw"" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; <S2SV_StartBug> ( void ) CloseBlob ( pwp_image ) ; <S2SV_EndBug> pwp_image = DestroyImage ( pwp_image ) ; if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""UnexpectedEndOfFile"" , ""`%s\':<S2SV_blank>%s"" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> read_info ) ; <S2SV_ModEnd> if ( EOFBlob
",CWE-416
702,"CWE-119 static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; <S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> int ret ; if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> return ERR_PTR ( - EINVAL ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>struct<S2SV_blank>vhost_scsi_tpg"" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }
","<S2SV_ModStart> * tpg ; u16 <S2SV_ModEnd> tpgt ; int <S2SV_ModStart> ; if ( kstrtou16 <S2SV_ModEnd> ( name + <S2SV_ModStart> ) || tpgt >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> ) return ERR_PTR
",CWE-119
703,"CWE-345 static <S2SV_StartBug> void headerMergeLegacySigs ( Header h , Header sigh ) <S2SV_EndBug> { HeaderIterator hi ; struct rpmtd_s td ; <S2SV_StartBug> hi = headerInitIterator ( sigh ) ; <S2SV_EndBug> for ( ; headerNext ( hi , & td ) ; rpmtdFreeData ( & td ) ) { switch ( td . tag ) { case RPMSIGTAG_SIZE : <S2SV_StartBug> td . tag = RPMTAG_SIGSIZE ; <S2SV_EndBug> break ; case RPMSIGTAG_PGP : <S2SV_StartBug> td . tag = RPMTAG_SIGPGP ; <S2SV_EndBug> break ; case RPMSIGTAG_MD5 : td . tag = RPMTAG_SIGMD5 ; break ; case RPMSIGTAG_GPG : td . tag = RPMTAG_SIGGPG ; break ; case RPMSIGTAG_PGP5 : td . tag = RPMTAG_SIGPGP5 ; break ; case RPMSIGTAG_PAYLOADSIZE : td . tag = RPMTAG_ARCHIVESIZE ; break ; case RPMSIGTAG_FILESIGNATURES : td . tag = RPMTAG_FILESIGNATURES ; break ; case RPMSIGTAG_FILESIGNATURELENGTH : td . tag = RPMTAG_FILESIGNATURELENGTH ; break ; case RPMSIGTAG_VERITYSIGNATURES : case RPMSIGTAG_VERITYSIGNATUREALGO : case RPMSIGTAG_SHA1 : case RPMSIGTAG_SHA256 : case RPMSIGTAG_DSA : case RPMSIGTAG_RSA : default : <S2SV_StartBug> if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) ) <S2SV_EndBug> continue ; break ; } <S2SV_StartBug> if ( ! headerIsEntry ( h , td . tag ) ) { <S2SV_EndBug> switch ( td . type ) { case RPM_NULL_TYPE : continue ; break ; case RPM_CHAR_TYPE : case RPM_INT8_TYPE : case RPM_INT16_TYPE : case RPM_INT32_TYPE : case RPM_INT64_TYPE : if ( td . count != 1 ) continue ; break ; case RPM_STRING_TYPE : case RPM_STRING_ARRAY_TYPE : case RPM_BIN_TYPE : if ( td . count >= 16 * 1024 ) continue ; break ; case RPM_I18NSTRING_TYPE : continue ; break ; } <S2SV_StartBug> ( void ) headerPut ( h , & td , HEADERPUT_DEFAULT ) ; <S2SV_EndBug> } } headerFreeIterator ( hi ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static rpmTagVal <S2SV_ModEnd> headerMergeLegacySigs ( Header <S2SV_ModStart> , Header sigh , char * * msg ) { const struct taglate_s * xl <S2SV_ModEnd> ; struct rpmtd_s <S2SV_ModStart> rpmtd_s td ; rpmtdReset ( & td ) ; for ( xl = xlateTags ; xl -> stag ; xl ++ ) { if ( headerIsEntry ( h , xl -> xtag ) ) break ; if ( headerGet ( sigh , xl -> stag , & td , HEADERGET_RAW | HEADERGET_MINMEM ) ) { if ( xl -> stag != xl -> xtag ) <S2SV_ModEnd> td . tag <S2SV_ModStart> . tag = xl -> xtag ; if ( td . type != rpmTagGetTagType ( <S2SV_ModEnd> td . tag <S2SV_ModStart> td . tag ) ) break ; if ( td . count < 1 || td . count > 16 * 1024 * 1024 ) break ; if ( xl -> count && td . count != xl -> count ) break ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! headerPut <S2SV_ModEnd> ( h , <S2SV_ModStart> ( h , <S2SV_ModEnd> & td , <S2SV_ModStart> , HEADERPUT_DEFAULT ) ) break ; rpmtdFreeData ( & td ) ; } } rpmtdFreeData ( & td ) ; if ( xl -> stag ) { rasprintf ( msg , ""invalid<S2SV_blank>signature<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>(%d)"" , rpmTagGetName ( xl -> xtag ) , xl -> xtag ) ; } return xl -> stag <S2SV_ModEnd> ; } <S2SV_null>
",CWE-345
704,"CWE-835 int xmlPushInput ( xmlParserCtxtPtr ctxt , xmlParserInputPtr input ) { int ret ; if ( input == NULL ) return ( - 1 ) ; if ( xmlParserDebugEntities ) { if ( ( ctxt -> input != NULL ) && ( ctxt -> input -> filename ) ) xmlGenericError ( xmlGenericErrorContext , ""%s(%d):<S2SV_blank>"" , ctxt -> input -> filename , ctxt -> input -> line ) ; xmlGenericError ( xmlGenericErrorContext , <S2SV_StartBug> ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\n"" , ctxt -> inputNr + 1 , input -> cur ) ; <S2SV_EndBug> } ret = inputPush ( ctxt , input ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( - 1 ) ; GROW ; return ( ret ) ; }
","<S2SV_ModStart> input -> cur ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1
",CWE-835
717,"CWE-269 uint32_t virtio_config_readl ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint32_t val ; <S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = ldl_p ( vdev -> config + addr ) ; return val ; }
","<S2SV_ModStart> uint32_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart> -> config ) <S2SV_ModEnd> ; val =
",CWE-269
718,"CWE-119 <S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame."" ) ; <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_EndBug> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>frame."" ) ; printf ( keyframe ? ""K"" : ""."" ) ; fflush ( stdout ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( vpx_codec_ctx_t <S2SV_ModStart> writer ) { int got_pkts = 0 ; <S2SV_ModStart> NULL ) { got_pkts = 1 ; <S2SV_ModStart> ; } } return got_pkts ;
",CWE-119
719,"CWE-119 <S2SV_StartBug> static double calc_frame_boost ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame , <S2SV_EndBug> <S2SV_StartBug> double this_frame_mv_in_out ) { <S2SV_EndBug> double frame_boost ; <S2SV_StartBug> if ( this_frame -> intra_error > cpi -> twopass . gf_intra_err_min ) <S2SV_EndBug> <S2SV_StartBug> frame_boost = ( IIFACTOR * this_frame -> intra_error / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; <S2SV_EndBug> else frame_boost = ( IIFACTOR * cpi -> twopass . gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; if ( this_frame_mv_in_out > 0.0 ) frame_boost += frame_boost * ( this_frame_mv_in_out * 2.0 ) ; else frame_boost += frame_boost * ( this_frame_mv_in_out / 2.0 ) ; <S2SV_StartBug> return MIN ( frame_boost , GF_RMAX ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * cpi , const <S2SV_ModStart> , double this_frame_mv_in_out , double max_boost <S2SV_ModStart> double frame_boost ; const double lq = vp9_convert_qindex_to_q ( cpi -> rc . avg_frame_qindex [ INTER_FRAME ] , cpi -> common . bit_depth ) ; const double boost_q_correction = MIN ( ( 0.5 + ( lq * 0.015 ) ) , 1.5 ) ; int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; num_mbs = ( int ) MAX ( 1 , num_mbs * calculate_active_area ( cpi , this_frame ) ) ; <S2SV_ModEnd> frame_boost = ( <S2SV_ModStart> frame_boost = ( BASELINE_ERR_PER_MB * num_mbs ) <S2SV_ModEnd> / DOUBLE_DIVIDE_CHECK ( <S2SV_ModStart> -> coded_error ) ; frame_boost = frame_boost * BOOST_FACTOR * boost_q_correction <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( frame_boost , max_boost * boost_q_correction <S2SV_ModEnd> ) ; }
",CWE-119
720,"CWE-000 <S2SV_StartBug> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <S2SV_EndBug> { write_seqlock ( & state -> seqlock ) ; if ( deleg_stateid != NULL ) { memcpy ( state -> stateid . data , deleg_stateid -> data , sizeof ( state -> stateid . data ) ) ; set_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } if ( open_stateid != NULL ) <S2SV_StartBug> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <S2SV_EndBug> write_sequnlock ( & state -> seqlock ) ; spin_lock ( & state -> owner -> so_lock ) ; <S2SV_StartBug> update_open_stateflags ( state , open_flags ) ; <S2SV_EndBug> spin_unlock ( & state -> owner -> so_lock ) ; }
","<S2SV_ModStart> * deleg_stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , open_stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock <S2SV_ModStart> ( state , fmode <S2SV_ModEnd> ) ; spin_unlock
",CWE-000
721,"CWE-787 PHP_FUNCTION ( imagegammacorrect ) { zval * IM ; gdImagePtr im ; int i ; double input , output ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""rdd"" , & IM , & input , & output ) == FAILURE ) { return ; } <S2SV_StartBug> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; <S2SV_EndBug> if ( gdImageTrueColor ( im ) ) { int x , y , c ; for ( y = 0 ; y < gdImageSY ( im ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( im ) ; x ++ ) { c = gdImageGetPixel ( im , x , y ) ; gdImageSetPixel ( im , x , y , gdTrueColorAlpha ( ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetRed ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetGreen ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetBlue ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , gdTrueColorGetAlpha ( c ) ) ) ; } } RETURN_TRUE ; } for ( i = 0 ; i < gdImageColorsTotal ( im ) ; i ++ ) { im -> red [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> red [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> green [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> green [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> blue [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> blue [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; } RETURN_TRUE ; }
","<S2SV_ModStart> return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ; RETURN_FALSE ; }
",CWE-787
722,"CWE-119 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { <S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> ( ( const char * ) ( const void * ) p + <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; <S2SV_StartBug> DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_EndBug> inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
","<S2SV_ModStart> ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ) p + ofs <S2SV_ModEnd> - 2 * <S2SV_ModStart> sizeof ( uint32_t ) <S2SV_ModStart> SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_ModEnd> inp [ i <S2SV_ModStart> - p , offs <S2SV_ModEnd> ) ) ;
",CWE-119
726,"CWE-284 static int ndp_sock_open ( struct ndp * ndp ) { int sock ; int ret ; int err ; int val ; sock = socket ( PF_INET6 , SOCK_RAW , IPPROTO_ICMPV6 ) ; if ( sock == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>ICMP6<S2SV_blank>socket."" ) ; return - errno ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVPKTINFO , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVPKTINFO."" ) ; err = - errno ; goto close_sock ; } val = 255 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_MULTICAST_HOPS , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { <S2SV_StartBug> err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; <S2SV_EndBug> err = - errno ; goto close_sock ; } ndp -> sock = sock ; return 0 ; close_sock : close ( sock ) ; return err ; }
","<S2SV_ModStart> ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,.""
",CWE-284
728,"CWE-119 static int temporal_filter_find_matching_mb_c ( VP9_COMP * cpi , uint8_t * arf_frame_buf , uint8_t * frame_ptr_buf , int stride ) { <S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> int step_param ; <S2SV_EndBug> int sadpb = x -> sadperbit16 ; <S2SV_StartBug> int bestsme = INT_MAX ; <S2SV_EndBug> MV best_ref_mv1 = { 0 , 0 } ; MV best_ref_mv1_full ; MV * ref_mv = & x -> e_mbd . mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv ; struct buf_2d src = x -> plane [ 0 ] . src ; struct buf_2d pre = xd -> plane [ 0 ] . pre [ 0 ] ; best_ref_mv1_full . col = best_ref_mv1 . col >> 3 ; best_ref_mv1_full . row = best_ref_mv1 . row >> 3 ; x -> plane [ 0 ] . src . buf = arf_frame_buf ; x -> plane [ 0 ] . src . stride = stride ; xd -> plane [ 0 ] . pre [ 0 ] . buf = frame_ptr_buf ; xd -> plane [ 0 ] . pre [ 0 ] . stride = stride ; <S2SV_StartBug> if ( cpi -> speed < 8 ) <S2SV_EndBug> step_param = cpi -> sf . reduce_first_step_size + ( ( cpi -> speed > 5 ) ? 1 : 0 ) ; else step_param = cpi -> sf . reduce_first_step_size + 2 ; <S2SV_StartBug> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ; <S2SV_EndBug> vp9_hex_search ( x , & best_ref_mv1_full , step_param , sadpb , 1 , <S2SV_StartBug> & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> int distortion ; unsigned int sse ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion , & sse ) ; } x -> plane [ 0 ] . src = src ; xd -> plane [ 0 ] . pre [ 0 ] = pre ; return bestsme ; }
","<S2SV_ModStart> { MACROBLOCK * const x = & cpi -> td . <S2SV_ModEnd> mb ; MACROBLOCKD <S2SV_ModStart> -> e_mbd ; const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; <S2SV_ModStart> bestsme = INT_MAX ; int distortion ; unsigned int sse ; int cost_list [ 5 ] <S2SV_ModStart> = stride ; step_param = mv_sf -> reduce_first_step_size ; step_param = MIN ( step_param , MAX_MVSEARCH_STEPS <S2SV_ModEnd> - 2 ) <S2SV_ModStart> - 2 ) <S2SV_ModEnd> ; vp9_hex_search ( <S2SV_ModStart> , 1 , cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> ref_mv ) ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ; <S2SV_ModEnd> x -> plane
",CWE-119
729,"CWE-476 static int stv06xx_start ( struct gspca_dev * gspca_dev ) { struct sd * sd = ( struct sd * ) gspca_dev ; struct usb_host_interface * alt ; struct usb_interface * intf ; int err , packet_size ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , ""Couldn\'t<S2SV_blank>get<S2SV_blank>altsetting\\n"" ) ; return - EIO ; } <S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ; if ( err < 0 ) return err ; err = sd -> sensor -> start ( sd ) ; if ( err < 0 ) goto out ; err = stv06xx_write_bridge ( sd , STV_ISO_ENABLE , 1 ) ; out : if ( err < 0 ) gspca_dbg ( gspca_dev , D_STREAM , ""Starting<S2SV_blank>stream<S2SV_blank>failed\\n"" ) ; else gspca_dbg ( gspca_dev , D_STREAM , ""Started<S2SV_blank>streaming\\n"" ) ; return ( err < 0 ) ? err : 0 ; }
","<S2SV_ModStart> EIO ; } if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;
",CWE-476
731,"CWE-119 int vp8_yv12_realloc_frame_buffer ( YV12_BUFFER_CONFIG * ybf , int width , int height , int border ) { if ( ybf ) { int aligned_width = ( width + 15 ) & ~ 15 ; int aligned_height = ( height + 15 ) & ~ 15 ; int y_stride = ( ( aligned_width + 2 * border ) + 31 ) & ~ 31 ; int yplane_size = ( aligned_height + 2 * border ) * y_stride ; int uv_width = aligned_width >> 1 ; int uv_height = aligned_height >> 1 ; int uv_stride = y_stride >> 1 ; int uvplane_size = ( uv_height + border ) * uv_stride ; const int frame_size = yplane_size + 2 * uvplane_size ; if ( ! ybf -> buffer_alloc ) { ybf -> buffer_alloc = ( uint8_t * ) vpx_memalign ( 32 , frame_size ) ; ybf -> buffer_alloc_sz = frame_size ; } if ( ! ybf -> buffer_alloc || ybf -> buffer_alloc_sz < frame_size ) return - 1 ; if ( border & 0x1f ) return - 3 ; ybf -> y_crop_width = width ; ybf -> y_crop_height = height ; ybf -> y_width = aligned_width ; ybf -> y_height = aligned_height ; ybf -> y_stride = y_stride ; <S2SV_StartBug> ybf -> uv_width = uv_width ; <S2SV_EndBug> ybf -> uv_height = uv_height ; ybf -> uv_stride = uv_stride ; ybf -> alpha_width = 0 ; ybf -> alpha_height = 0 ; ybf -> alpha_stride = 0 ; ybf -> border = border ; ybf -> frame_size = frame_size ; ybf -> y_buffer = ybf -> buffer_alloc + ( border * y_stride ) + border ; ybf -> u_buffer = ybf -> buffer_alloc + yplane_size + ( border / 2 * uv_stride ) + border / 2 ; ybf -> v_buffer = ybf -> buffer_alloc + yplane_size + uvplane_size + ( border / 2 * uv_stride ) + border / 2 ; ybf -> alpha_buffer = NULL ; ybf -> corrupted = 0 ; return 0 ; } return - 2 ; }
","<S2SV_ModStart> ; ybf -> uv_crop_width = ( width + 1 ) / 2 ; ybf -> uv_crop_height = ( height + 1 ) / 2 ; ybf ->
",CWE-119
733,"CWE-347 err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return ""2"" ""exponentiation<S2SV_blank>failed;<S2SV_blank>too<S2SV_blank>many<S2SV_blank>octets"" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( ""verify_sh<S2SV_blank>decrypted<S2SV_blank>SIG1:"" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( ""pad_len<S2SV_blank>calculated:<S2SV_blank>%d<S2SV_blank>hash_len:<S2SV_blank>%d"" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return ""3"" ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } <S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } ( * psig ) = s + <S2SV_ModEnd> padlen + 3 <S2SV_ModStart> + 3 ; { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ; } <S2SV_ModEnd> return NULL ;
",CWE-347
735,"CWE-476 static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( ""Interrupt<S2SV_blank>%d,<S2SV_blank>without<S2SV_blank>any<S2SV_blank>data\\n"" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( ""MUX<S2SV_blank>error,<S2SV_blank>status<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>data<S2SV_blank>is<S2SV_blank>%02x\\n"" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT && ! i8042_notimeout ) ? SERIO_TIMEOUT : 0 ) ; port_no = ( str & I8042_STR_AUXDATA ) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO ; } port = & i8042_ports [ port_no ] ; serio = port -> exists ? port -> serio : NULL ; filter_dbg ( port -> driver_bound , data , ""<-<S2SV_blank>i8042<S2SV_blank>(interrupt,<S2SV_blank>%d,<S2SV_blank>%d%s%s)\\n"" , port_no , irq , dfl & SERIO_PARITY ? "",<S2SV_blank>bad<S2SV_blank>parity"" : """" , dfl & SERIO_TIMEOUT ? "",<S2SV_blank>timeout"" : """" ) ; filtered = i8042_filter ( data , str , serio ) ; spin_unlock_irqrestore ( & i8042_lock , flags ) ; <S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> serio_interrupt ( serio , data , dfl ) ; out : return IRQ_RETVAL ( ret ) ; }
","<S2SV_ModStart> ( likely ( serio <S2SV_ModEnd> && ! filtered
",CWE-476
736,"CWE-000 int ff_jpeg2000_init_component ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty , Jpeg2000QuantStyle * qntsty , int cbps , int dx , int dy , AVCodecContext * avctx ) { uint8_t log2_band_prec_width , log2_band_prec_height ; int reslevelno , bandno , gbandno = 0 , ret , i , j ; uint32_t csize ; if ( codsty -> nreslevels2decode <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""nreslevels2decode<S2SV_blank>%d<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>uninitialized\\n"" , codsty -> nreslevels2decode ) ; return AVERROR_INVALIDDATA ; } if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) ) return ret ; csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ) ; if ( codsty -> transform == FF_DWT97 ) { comp -> i_data = NULL ; comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ) ; if ( ! comp -> f_data ) return AVERROR ( ENOMEM ) ; } else { comp -> f_data = NULL ; comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ) ; if ( ! comp -> i_data ) return AVERROR ( ENOMEM ) ; } comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ) ; if ( ! comp -> reslevel ) return AVERROR ( ENOMEM ) ; for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { int declvl = codsty -> nreslevels - reslevelno ; Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ) ; reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ] ; reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ] ; if ( reslevelno == 0 ) reslevel -> nbands = 1 ; else reslevel -> nbands = 3 ; if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] ) reslevel -> num_precincts_x = 0 ; else reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ) ; if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] ) reslevel -> num_precincts_y = 0 ; else reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ) ; <S2SV_StartBug> reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ; <S2SV_EndBug> if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ , gbandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; int cblkno , precno ; int nb_precincts ; switch ( qntsty -> quantsty ) { uint8_t gain ; int numbps ; case JPEG2000_QSTY_NONE : band -> f_stepsize = 1 ; break ; case JPEG2000_QSTY_SI : numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ] ; band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ) ; break ; case JPEG2000_QSTY_SE : gain = cbps ; band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ) ; band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0 ; break ; default : band -> f_stepsize = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>quantization<S2SV_blank>format\\n"" ) ; break ; } if ( ! av_codec_is_encoder ( avctx -> codec ) ) band -> f_stepsize *= 0.5 ; band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ) ; if ( reslevelno == 0 ) { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width ; log2_band_prec_height = reslevel -> log2_prec_height ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ) ; } else { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ) ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width - 1 ; log2_band_prec_height = reslevel -> log2_prec_height - 1 ; } for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ) ; for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ) ; <S2SV_StartBug> band -> prec = av_malloc_array ( reslevel -> num_precincts_x * <S2SV_EndBug> ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ; if ( ! band -> prec ) return AVERROR ( ENOMEM ) ; nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y ; for ( precno = 0 ; precno < nb_precincts ; precno ++ ) { Jpeg2000Prec * prec = band -> prec + precno ; prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ) ; prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ) ; prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ) ; prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ) ; prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ) ; prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ) ; prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> cblkincl ) return AVERROR ( ENOMEM ) ; prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> zerobits ) return AVERROR ( ENOMEM ) ; prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ) ; if ( ! prec -> cblk ) return AVERROR ( ENOMEM ) ; for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_width * prec -> nb_codeblocks_height ; cblkno ++ ) { Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; uint16_t Cx0 , Cy0 ; Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width ; Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ) ; cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ) ; Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height ; Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ) ; cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ) ; cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ) ; cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ) ; if ( ( bandno + ! ! reslevelno ) & 1 ) { cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; } if ( ( bandno + ! ! reslevelno ) & 2 ) { cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; } cblk -> zero = 0 ; cblk -> lblock = 3 ; cblk -> length = 0 ; cblk -> lengthinc = 0 ; cblk -> npasses = 0 ; } } } } return 0 ; }
","<S2SV_ModStart> -> band = av_calloc <S2SV_ModEnd> ( reslevel -> <S2SV_ModStart> -> prec = av_calloc <S2SV_ModEnd> ( reslevel ->
",CWE-000
737,"CWE-000 int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , ""blacklisted<S2SV_blank>by<S2SV_blank>%s\\n"" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev -> bh . func = usbnet_bh ; dev -> bh . data = ( unsigned long ) dev ; INIT_WORK ( & dev -> kevent , usbnet_deferred_kevent ) ; init_usb_anchor ( & dev -> deferred ) ; dev -> delay . function = usbnet_bh ; dev -> delay . data = ( unsigned long ) dev ; init_timer ( & dev -> delay ) ; mutex_init ( & dev -> phy_mutex ) ; mutex_init ( & dev -> interrupt_mutex ) ; dev -> interrupt_count = 0 ; dev -> net = net ; strcpy ( net -> name , ""usb%d"" ) ; memcpy ( net -> dev_addr , node_id , sizeof node_id ) ; dev -> hard_mtu = net -> mtu + net -> hard_header_len ; net -> netdev_ops = & usbnet_netdev_ops ; net -> watchdog_timeo = TX_TIMEOUT_JIFFIES ; net -> ethtool_ops = & usbnet_ethtool_ops ; if ( info -> bind ) { status = info -> bind ( dev , udev ) ; if ( status < 0 ) goto out1 ; if ( ( dev -> driver_info -> flags & FLAG_ETHER ) != 0 && ( ( dev -> driver_info -> flags & FLAG_POINTTOPOINT ) == 0 || ( net -> dev_addr [ 0 ] & 0x02 ) == 0 ) ) strcpy ( net -> name , ""eth%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) strcpy ( net -> name , ""wlan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) strcpy ( net -> name , ""wwan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_NOARP ) != 0 ) net -> flags |= IFF_NOARP ; if ( net -> mtu > ( dev -> hard_mtu - net -> hard_header_len ) ) net -> mtu = dev -> hard_mtu - net -> hard_header_len ; } else if ( ! info -> in || ! info -> out ) status = usbnet_get_endpoints ( dev , udev ) ; else { dev -> in = usb_rcvbulkpipe ( xdev , info -> in ) ; dev -> out = usb_sndbulkpipe ( xdev , info -> out ) ; if ( ! ( info -> flags & FLAG_NO_SETINT ) ) status = usb_set_interface ( xdev , interface -> desc . bInterfaceNumber , interface -> desc . bAlternateSetting ) ; else status = 0 ; } if ( status >= 0 && dev -> status ) status = init_status ( dev , udev ) ; if ( status < 0 ) goto out3 ; if ( ! dev -> rx_urb_size ) dev -> rx_urb_size = dev -> hard_mtu ; dev -> maxpacket = usb_maxpacket ( dev -> udev , dev -> out , 1 ) ; if ( ether_addr_equal ( net -> dev_addr , node_id ) ) net -> addr_assign_type = NET_ADDR_RANDOM ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wlan_type ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wwan_type ) ; usbnet_update_max_qlen ( dev ) ; if ( dev -> can_dma_sg && ! ( info -> flags & FLAG_SEND_ZLP ) && ! ( info -> flags & FLAG_MULTI_PACKET ) ) { dev -> padding_pkt = kzalloc ( 1 , GFP_KERNEL ) ; if ( ! dev -> padding_pkt ) { status = - ENOMEM ; goto out4 ; } } status = register_netdev ( net ) ; if ( status ) goto out5 ; netif_info ( dev , probe , dev -> net , ""register<S2SV_blank>\'%s\'<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%s,<S2SV_blank>%pM\\n"" , udev -> dev . driver -> name , xdev -> bus -> bus_name , xdev -> devpath , dev -> driver_info -> description , net -> dev_addr ) ; usb_set_intfdata ( udev , dev ) ; netif_device_attach ( net ) ; if ( dev -> driver_info -> flags & FLAG_LINK_INTR ) usbnet_link_change ( dev , 0 , 0 ) ; return 0 ; out5 : kfree ( dev -> padding_pkt ) ; out4 : usb_free_urb ( dev -> interrupt ) ; out3 : if ( info -> unbind ) info -> unbind ( dev , udev ) ; out1 : <S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> out : return status ; }
","<S2SV_ModStart> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;
",CWE-000
740,"CWE-000 static void nfs4_close_done ( struct rpc_task * task , void * data ) { struct nfs4_closedata * calldata = data ; struct nfs4_state * state = calldata -> state ; struct nfs_server * server = NFS_SERVER ( calldata -> inode ) ; if ( RPC_ASSASSINATED ( task ) ) return ; switch ( task -> tk_status ) { case 0 : nfs_set_open_stateid ( state , & calldata -> res . stateid , 0 ) ; renew_lease ( server , calldata -> timestamp ) ; break ; case - NFS4ERR_STALE_STATEID : case - NFS4ERR_OLD_STATEID : case - NFS4ERR_BAD_STATEID : case - NFS4ERR_EXPIRED : <S2SV_StartBug> if ( calldata -> arg . open_flags == 0 ) <S2SV_EndBug> break ; default : if ( nfs4_async_handle_error ( task , server , state ) == - EAGAIN ) { rpc_restart_call ( task ) ; return ; } } nfs_refresh_inode ( calldata -> inode , calldata -> res . fattr ) ; }
","<S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> == 0 )
",CWE-000
741,"CWE-000 static int ip6_frag_queue ( struct frag_queue * fq , struct sk_buff * skb , struct frag_hdr * fhdr , int nhoff ) { struct sk_buff * prev , * next ; struct net_device * dev ; int offset , end ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; if ( fq -> q . last_in & INET_FRAG_COMPLETE ) goto err ; offset = ntohs ( fhdr -> frag_off ) & ~ 0x7 ; end = offset + ( ntohs ( ipv6_hdr ( skb ) -> payload_len ) - ( ( u8 * ) ( fhdr + 1 ) - ( u8 * ) ( ipv6_hdr ( skb ) + 1 ) ) ) ; if ( ( unsigned int ) end > IPV6_MAXPLEN ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , ( ( u8 * ) & fhdr -> frag_off - skb_network_header ( skb ) ) ) ; return - 1 ; } if ( skb -> ip_summed == CHECKSUM_COMPLETE ) { const unsigned char * nh = skb_network_header ( skb ) ; skb -> csum = csum_sub ( skb -> csum , csum_partial ( nh , ( u8 * ) ( fhdr + 1 ) - nh , 0 ) ) ; } if ( ! ( fhdr -> frag_off & htons ( IP6_MF ) ) ) { if ( end < fq -> q . len || ( ( fq -> q . last_in & INET_FRAG_LAST_IN ) && end != fq -> q . len ) ) goto err ; fq -> q . last_in |= INET_FRAG_LAST_IN ; fq -> q . len = end ; } else { if ( end & 0x7 ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , offsetof ( struct ipv6hdr , payload_len ) ) ; return - 1 ; } if ( end > fq -> q . len ) { if ( fq -> q . last_in & INET_FRAG_LAST_IN ) goto err ; fq -> q . len = end ; } } if ( end == offset ) goto err ; if ( ! pskb_pull ( skb , ( u8 * ) ( fhdr + 1 ) - skb -> data ) ) goto err ; if ( pskb_trim_rcsum ( skb , end - offset ) ) goto err ; prev = fq -> q . fragments_tail ; if ( ! prev || FRAG6_CB ( prev ) -> offset < offset ) { next = NULL ; goto found ; } prev = NULL ; for ( next = fq -> q . fragments ; next != NULL ; next = next -> next ) { if ( FRAG6_CB ( next ) -> offset >= offset ) break ; prev = next ; } found : <S2SV_StartBug> if ( prev ) { <S2SV_EndBug> <S2SV_StartBug> int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ; <S2SV_EndBug> <S2SV_StartBug> if ( i > 0 ) { <S2SV_EndBug> offset += i ; if ( end <= offset ) goto err ; if ( ! pskb_pull ( skb , i ) ) goto err ; if ( skb -> ip_summed != CHECKSUM_UNNECESSARY ) skb -> ip_summed = CHECKSUM_NONE ; } } <S2SV_StartBug> while ( next && FRAG6_CB ( next ) -> offset < end ) { <S2SV_EndBug> int i = end - FRAG6_CB ( next ) -> offset ; if ( i < next -> len ) { if ( ! pskb_pull ( next , i ) ) goto err ; FRAG6_CB ( next ) -> offset += i ; fq -> q . meat -= i ; if ( next -> ip_summed != CHECKSUM_UNNECESSARY ) next -> ip_summed = CHECKSUM_NONE ; break ; } else { struct sk_buff * free_it = next ; next = next -> next ; if ( prev ) prev -> next = next ; else fq -> q . fragments = next ; fq -> q . meat -= free_it -> len ; frag_kfree_skb ( fq -> q . net , free_it ) ; } } FRAG6_CB ( skb ) -> offset = offset ; skb -> next = next ; if ( ! next ) fq -> q . fragments_tail = skb ; if ( prev ) prev -> next = skb ; else fq -> q . fragments = skb ; dev = skb -> dev ; if ( dev ) { fq -> iif = dev -> ifindex ; skb -> dev = NULL ; } fq -> q . stamp = skb -> tstamp ; fq -> q . meat += skb -> len ; atomic_add ( skb -> truesize , & fq -> q . net -> mem ) ; if ( offset == 0 ) { fq -> nhoffset = nhoff ; fq -> q . last_in |= INET_FRAG_FIRST_IN ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) return ip6_frag_reasm ( fq , prev , dev ) ; write_lock ( & ip6_frags . lock ) ; list_move_tail ( & fq -> q . lru_list , & fq -> q . net -> lru_list ) ; write_unlock ( & ip6_frags . lock ) ; return - 1 ; <S2SV_StartBug> err : <S2SV_EndBug> IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ; kfree_skb ( skb ) ; return - 1 ; }
","<S2SV_ModStart> if ( prev && <S2SV_ModEnd> ( FRAG6_CB ( <S2SV_ModStart> ) - offset <S2SV_ModEnd> > 0 ) <S2SV_ModStart> > 0 ) goto discard_fq ; if <S2SV_ModEnd> ( next && <S2SV_ModStart> < end ) goto discard_fq ; <S2SV_ModEnd> FRAG6_CB ( skb <S2SV_ModStart> - 1 ; discard_fq : fq_kill ( fq ) ;
",CWE-000
744,"CWE-20 WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u2_cur_mb_addr != 0 ) && ( ps_dec -> u4_first_slice_in_pic != 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SPS_PPS_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SPS_PPS_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SPS_PPS_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ; if ( ! ps_seq -> u1_frame_mbs_only_flag ) { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SPS_PPS_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SPS_PPS_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; if ( ( ps_dec -> u4_first_slice_in_pic == 2 ) && ( i1_is_end_of_poc == 0 ) ) { ps_dec -> ps_dec_err_status -> u1_err_flag |= REJECT_CUR_PIC ; i1_is_end_of_poc = 1 ; } else { ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; } } u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u1_slice_header_done = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; # if WIN32 H264_DEC_DEBUG_PRINT ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n"" ) ; # endif return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } <S2SV_StartBug> ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; <S2SV_EndBug> if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }
","<S2SV_ModStart> pv_parse_tu_coeff_data ; } <S2SV_ModEnd> if ( u1_slice_type
",CWE-20
745,"CWE-119 void vp8mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd ) { VP8_COMMON * pc = & pbi -> common ; unsigned int i ; int j ; int filter_level = pc -> filter_level ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; if ( filter_level ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> for ( j = 1 ; j < pc -> mb_rows ; j ++ ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> } for ( j = 0 ; j < pc -> mb_rows ; j ++ ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> } vp8_loop_filter_frame_init ( pc , & pbi -> mb , filter_level ) ; } else vp8_setup_intra_recon_top_line ( yv12_fb_new ) ; setup_decoding_thread_data ( pbi , xd , pbi -> mb_row_di , pbi -> decoding_thread_count ) ; for ( i = 0 ; i < pbi -> decoding_thread_count ; i ++ ) sem_post ( & pbi -> h_event_start_decoding [ i ] ) ; mt_decode_mb_rows ( pbi , xd , 0 ) ; sem_wait ( & pbi -> h_event_end_decoding ) ; }
","<S2SV_ModStart> filter_level ) { memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 5 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 5 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 1 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 1 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 16 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 8 ) ; memset <S2SV_ModEnd> ( pbi ->
",CWE-119
746,"CWE-125 int yyparse ( void * yyscanner , YR_COMPILER * compiler ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , compiler ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 8 : # line 230 ""grammar.y"" { int result = yr_parser_reduce_import ( yyscanner , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; } # line 1661 ""grammar.c"" break ; case 9 : # line 242 ""grammar.y"" { YR_RULE * rule = yr_parser_reduce_rule_declaration_phase_1 ( yyscanner , ( int32_t ) ( yyvsp [ - 2 ] . integer ) , ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( rule == NULL ) ; ( yyval . rule ) = rule ; } # line 1674 ""grammar.c"" break ; case 10 : # line 251 ""grammar.y"" { YR_RULE * rule = ( yyvsp [ - 4 ] . rule ) ; rule -> tags = ( yyvsp [ - 3 ] . c_string ) ; rule -> metas = ( yyvsp [ - 1 ] . meta ) ; rule -> strings = ( yyvsp [ 0 ] . string ) ; } # line 1686 ""grammar.c"" break ; case 11 : # line 259 ""grammar.y"" { YR_RULE * rule = ( yyvsp [ - 7 ] . rule ) ; compiler -> last_result = yr_parser_reduce_rule_declaration_phase_2 ( yyscanner , rule ) ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1701 ""grammar.c"" break ; case 12 : # line 274 ""grammar.y"" { ( yyval . meta ) = NULL ; } # line 1709 ""grammar.c"" break ; case 13 : # line 278 ""grammar.y"" { YR_META null_meta ; memset ( & null_meta , 0xFF , sizeof ( YR_META ) ) ; null_meta . type = META_TYPE_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> metas_arena , & null_meta , sizeof ( YR_META ) , NULL ) ; ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1736 ""grammar.c"" break ; case 14 : # line 305 ""grammar.y"" { ( yyval . string ) = NULL ; } # line 1744 ""grammar.c"" break ; case 15 : # line 309 ""grammar.y"" { YR_STRING null_string ; memset ( & null_string , 0xFF , sizeof ( YR_STRING ) ) ; null_string . g_flags = STRING_GFLAGS_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> strings_arena , & null_string , sizeof ( YR_STRING ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1771 ""grammar.c"" break ; case 17 : # line 340 ""grammar.y"" { ( yyval . integer ) = 0 ; } # line 1777 ""grammar.c"" break ; case 18 : # line 341 ""grammar.y"" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 1783 ""grammar.c"" break ; case 19 : # line 346 ""grammar.y"" { ( yyval . integer ) = RULE_GFLAGS_PRIVATE ; } # line 1789 ""grammar.c"" break ; case 20 : # line 347 ""grammar.y"" { ( yyval . integer ) = RULE_GFLAGS_GLOBAL ; } # line 1795 ""grammar.c"" break ; case 21 : # line 353 ""grammar.y"" { ( yyval . c_string ) = NULL ; } # line 1803 ""grammar.c"" break ; case 22 : # line 357 ""grammar.y"" { compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , """" , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 1821 ""grammar.c"" break ; case 23 : # line 375 ""grammar.y"" { char * identifier ; compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & identifier ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = identifier ; } # line 1838 ""grammar.c"" break ; case 24 : # line 388 ""grammar.y"" { char * tag_name = ( yyvsp [ - 1 ] . c_string ) ; size_t tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; while ( tag_length > 0 ) { if ( strcmp ( tag_name , ( yyvsp [ 0 ] . c_string ) ) == 0 ) { yr_compiler_set_error_extra_info ( compiler , tag_name ) ; compiler -> last_result = ERROR_DUPLICATED_TAG_IDENTIFIER ; break ; } tag_name = ( char * ) yr_arena_next_address ( yyget_extra ( yyscanner ) -> sz_arena , tag_name , tag_length + 1 ) ; tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; } if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , NULL ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 1 ] . c_string ) ; } # line 1874 ""grammar.c"" break ; case 25 : # line 424 ""grammar.y"" { ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; } # line 1880 ""grammar.c"" break ; case 26 : # line 425 ""grammar.y"" { ( yyval . meta ) = ( yyvsp [ - 1 ] . meta ) ; } # line 1886 ""grammar.c"" break ; case 27 : # line 431 ""grammar.y"" { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_STRING , ( yyvsp [ - 2 ] . c_string ) , sized_string -> c_string , 0 ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1906 ""grammar.c"" break ; case 28 : # line 447 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 2 ] . c_string ) , NULL , ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1923 ""grammar.c"" break ; case 29 : # line 460 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 3 ] . c_string ) , NULL , - ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1940 ""grammar.c"" break ; case 30 : # line 473 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , TRUE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1957 ""grammar.c"" break ; case 31 : # line 486 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , FALSE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1974 ""grammar.c"" break ; case 32 : # line 502 ""grammar.y"" { ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1980 ""grammar.c"" break ; case 33 : # line 503 ""grammar.y"" { ( yyval . string ) = ( yyvsp [ - 1 ] . string ) ; } # line 1986 ""grammar.c"" break ; case 34 : # line 509 ""grammar.y"" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 1994 ""grammar.c"" break ; case 35 : # line 513 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2009 ""grammar.c"" break ; case 36 : # line 524 ""grammar.y"" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 2017 ""grammar.c"" break ; case 37 : # line 528 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) | STRING_GFLAGS_REGEXP , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2033 ""grammar.c"" break ; case 38 : # line 540 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , STRING_GFLAGS_HEXADECIMAL , ( yyvsp [ - 2 ] . c_string ) , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; } # line 2047 ""grammar.c"" break ; case 39 : # line 553 ""grammar.y"" { ( yyval . integer ) = 0 ; } # line 2053 ""grammar.c"" break ; case 40 : # line 554 ""grammar.y"" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 2059 ""grammar.c"" break ; case 41 : # line 559 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_WIDE ; } # line 2065 ""grammar.c"" break ; case 42 : # line 560 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_ASCII ; } # line 2071 ""grammar.c"" break ; case 43 : # line 561 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_NO_CASE ; } # line 2077 ""grammar.c"" break ; case 44 : # line 562 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_FULL_WORD ; } # line 2083 ""grammar.c"" break ; case 45 : # line 568 ""grammar.y"" { int var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; if ( var_index >= 0 ) { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , LOOP_LOCAL_VARS * var_index , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = compiler -> loop_identifier [ var_index ] ; } else { YR_OBJECT * object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , NULL ) ; if ( object == NULL ) { char * ns = compiler -> current_namespace -> name ; object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , ns ) ; } if ( object != NULL ) { char * id ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & id ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_LOAD , id , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = object ; ( yyval . expression ) . identifier = object -> identifier ; } else { YR_RULE * rule = ( YR_RULE * ) yr_hash_table_lookup ( compiler -> rules_table , ( yyvsp [ 0 ] . c_string ) , compiler -> current_namespace -> name ) ; if ( rule != NULL ) { compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH_RULE , rule , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = rule -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_UNDEFINED_IDENTIFIER ; } } } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2172 ""grammar.c"" break ; case 46 : # line 653 ""grammar.y"" { YR_OBJECT * field = NULL ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 2 ] . expression ) . value . object -> type == OBJECT_TYPE_STRUCTURE ) { field = yr_object_lookup_field ( ( yyvsp [ - 2 ] . expression ) . value . object , ( yyvsp [ 0 ] . c_string ) ) ; if ( field != NULL ) { char * ident ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & ident ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_FIELD , ident , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = field ; ( yyval . expression ) . identifier = field -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_INVALID_FIELD_NAME ; } } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 2 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_STRUCTURE ; } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2222 ""grammar.c"" break ; case 47 : # line 699 ""grammar.y"" { YR_OBJECT_ARRAY * array ; YR_OBJECT_DICTIONARY * dict ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_ARRAY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""array<S2SV_blank>indexes<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>integer<S2SV_blank>type"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INDEX_ARRAY , NULL ) ; array = ( YR_OBJECT_ARRAY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = array -> prototype_item ; ( yyval . expression ) . identifier = array -> identifier ; } else if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_DICTIONARY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_STRING ) { yr_compiler_set_error_extra_info ( compiler , ""dictionary<S2SV_blank>keys<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>string<S2SV_blank>type"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_LOOKUP_DICT , NULL ) ; dict = ( YR_OBJECT_DICTIONARY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = dict -> prototype_item ; ( yyval . expression ) . identifier = dict -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_INDEXABLE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2283 ""grammar.c"" break ; case 48 : # line 757 ""grammar.y"" { YR_OBJECT_FUNCTION * function ; char * args_fmt ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_FUNCTION ) { compiler -> last_result = yr_parser_check_types ( compiler , ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object , ( yyvsp [ - 1 ] . c_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ - 1 ] . c_string ) , & args_fmt ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_CALL , args_fmt , NULL , NULL ) ; function = ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = function -> return_obj ; ( yyval . expression ) . identifier = function -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_FUNCTION ; } yr_free ( ( yyvsp [ - 1 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2328 ""grammar.c"" break ; case 49 : # line 801 ""grammar.y"" { ( yyval . c_string ) = yr_strdup ( """" ) ; } # line 2334 ""grammar.c"" break ; case 50 : # line 802 ""grammar.y"" { ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 2340 ""grammar.c"" break ; case 51 : # line 807 ""grammar.y"" { ( yyval . c_string ) = ( char * ) yr_malloc ( MAX_FUNCTION_ARGS + 1 ) ; switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcpy ( ( yyval . c_string ) , ""i"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcpy ( ( yyval . c_string ) , ""f"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcpy ( ( yyval . c_string ) , ""b"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcpy ( ( yyval . c_string ) , ""s"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcpy ( ( yyval . c_string ) , ""r"" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> ERROR_IF ( ( yyval . c_string ) == NULL ) ; } <S2SV_StartBug> # line 2369 ""grammar.c"" <S2SV_EndBug> break ; case 52 : <S2SV_StartBug> # line 832 ""grammar.y"" <S2SV_EndBug> { if ( strlen ( ( yyvsp [ - 2 ] . c_string ) ) == MAX_FUNCTION_ARGS ) { compiler -> last_result = ERROR_TOO_MANY_ARGUMENTS ; } else { switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""i"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""f"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""b"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""s"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""r"" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 2 ] . c_string ) ; } <S2SV_StartBug> # line 2405 ""grammar.c"" <S2SV_EndBug> break ; case 53 : <S2SV_StartBug> # line 868 ""grammar.y"" <S2SV_EndBug> { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; RE * re ; RE_ERROR error ; int re_flags = 0 ; if ( sized_string -> flags & SIZED_STRING_FLAGS_NO_CASE ) re_flags |= RE_FLAGS_NO_CASE ; if ( sized_string -> flags & SIZED_STRING_FLAGS_DOT_ALL ) re_flags |= RE_FLAGS_DOT_ALL ; compiler -> last_result = yr_re_compile ( sized_string -> c_string , re_flags , compiler -> re_code_arena , & re , & error ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_INVALID_REGULAR_EXPRESSION ) yr_compiler_set_error_extra_info ( compiler , error . message ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , re -> root_node -> forward_code , NULL , NULL ) ; yr_re_destroy ( re ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_REGEXP ; } <S2SV_StartBug> # line 2451 ""grammar.c"" <S2SV_EndBug> break ; case 54 : <S2SV_StartBug> # line 914 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_STRING ) { if ( ( yyvsp [ 0 ] . expression ) . value . sized_string != NULL ) { yywarning ( yyscanner , ""Using<S2SV_blank>literal<S2SV_blank>string<S2SV_blank>\\""%s\\""<S2SV_blank>in<S2SV_blank>a<S2SV_blank>boolean<S2SV_blank>operation."" , ( yyvsp [ 0 ] . expression ) . value . sized_string -> c_string ) ; } compiler -> last_result = yr_parser_emit ( yyscanner , OP_STR_TO_BOOL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2474 ""grammar.c"" <S2SV_EndBug> break ; case 55 : <S2SV_StartBug> # line 936 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2487 ""grammar.c"" <S2SV_EndBug> break ; case 56 : <S2SV_StartBug> # line 945 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 0 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2500 ""grammar.c"" <S2SV_EndBug> break ; case 57 : <S2SV_StartBug> # line 954 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , ""matches"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_REGEXP , ""matches"" ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit ( yyscanner , OP_MATCHES , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2519 ""grammar.c"" <S2SV_EndBug> break ; case 58 : <S2SV_StartBug> # line 969 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , ""contains"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_STRING , ""contains"" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_CONTAINS , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2535 ""grammar.c"" <S2SV_EndBug> break ; case 59 : <S2SV_StartBug> # line 981 ""grammar.y"" <S2SV_EndBug> { int result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_FOUND , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2553 ""grammar.c"" <S2SV_EndBug> break ; case 60 : <S2SV_StartBug> # line 995 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""at"" ) ; compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_AT , ( yyvsp [ 0 ] . expression ) . value . integer ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2570 ""grammar.c"" <S2SV_EndBug> break ; case 61 : <S2SV_StartBug> # line 1008 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_IN , UNDEFINED ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2585 ""grammar.c"" <S2SV_EndBug> break ; case 62 : <S2SV_StartBug> # line 1019 ""grammar.y"" <S2SV_EndBug> { if ( compiler -> loop_depth > 0 ) { compiler -> loop_depth -- ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; } <S2SV_StartBug> } <S2SV_EndBug> # line 2597 ""grammar.c"" break ; case 63 : <S2SV_StartBug> # line 1027 ""grammar.y"" <S2SV_EndBug> { int var_index ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ - 1 ] . c_string ) ) ; if ( var_index >= 0 ) { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 1 ] . c_string ) ) ; compiler -> last_result = ERROR_DUPLICATED_LOOP_IDENTIFIER ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 2631 ""grammar.c"" <S2SV_EndBug> break ; case 64 : <S2SV_StartBug> # line 1057 ""grammar.y"" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 1 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset + 3 , & addr , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , NULL , NULL ) ; } compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = ( yyvsp [ - 4 ] . c_string ) ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2670 ""grammar.c"" <S2SV_EndBug> break ; case 65 : <S2SV_StartBug> # line 1092 ""grammar.y"" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 5 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 3 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JLE , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; } yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2753 ""grammar.c"" <S2SV_EndBug> break ; case 66 : <S2SV_StartBug> # line 1171 ""grammar.y"" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; if ( compiler -> loop_for_of_mem_offset != - 1 ) compiler -> last_result = ERROR_NESTED_FOR_OF_LOOP ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; compiler -> loop_for_of_mem_offset = mem_offset ; compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2787 ""grammar.c"" <S2SV_EndBug> break ; case 67 : <S2SV_StartBug> # line 1201 ""grammar.y"" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; compiler -> loop_for_of_mem_offset = - 1 ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2840 ""grammar.c"" <S2SV_EndBug> break ; case 68 : <S2SV_StartBug> # line 1250 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_OF , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2850 ""grammar.c"" <S2SV_EndBug> break ; case 69 : <S2SV_StartBug> # line 1256 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2860 ""grammar.c"" <S2SV_EndBug> break ; case 70 : <S2SV_StartBug> # line 1262 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JFALSE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2890 ""grammar.c"" <S2SV_EndBug> break ; case 71 : <S2SV_StartBug> # line 1288 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * and_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_AND , & and_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( and_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2930 ""grammar.c"" <S2SV_EndBug> break ; case 72 : <S2SV_StartBug> # line 1324 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JTRUE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2959 ""grammar.c"" <S2SV_EndBug> break ; case 73 : <S2SV_StartBug> # line 1349 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * or_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_OR , & or_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( or_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2999 ""grammar.c"" <S2SV_EndBug> break ; case 74 : <S2SV_StartBug> # line 1385 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""<"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3012 ""grammar.c"" <S2SV_EndBug> break ; case 75 : <S2SV_StartBug> # line 1394 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "">"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3025 ""grammar.c"" <S2SV_EndBug> break ; case 76 : <S2SV_StartBug> # line 1403 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""<="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3038 ""grammar.c"" <S2SV_EndBug> break ; case 77 : <S2SV_StartBug> # line 1412 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "">="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3051 ""grammar.c"" <S2SV_EndBug> break ; case 78 : <S2SV_StartBug> # line 1421 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""=="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3064 ""grammar.c"" <S2SV_EndBug> break ; case 79 : <S2SV_StartBug> # line 1430 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""!="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3077 ""grammar.c"" <S2SV_EndBug> break ; case 80 : <S2SV_StartBug> # line 1439 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3085 ""grammar.c"" <S2SV_EndBug> break ; case 81 : <S2SV_StartBug> # line 1443 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3093 ""grammar.c"" <S2SV_EndBug> break ; case 82 : <S2SV_StartBug> # line 1450 ""grammar.y"" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_ENUMERATION ; } <S2SV_StartBug> # line 3099 ""grammar.c"" <S2SV_EndBug> break ; case 83 : <S2SV_StartBug> # line 1451 ""grammar.y"" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_RANGE ; } <S2SV_StartBug> # line 3105 ""grammar.c"" <S2SV_EndBug> break ; case 84 : <S2SV_StartBug> # line 1457 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ - 3 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\'s<S2SV_blank>lower<S2SV_blank>bound"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\'s<S2SV_blank>upper<S2SV_blank>bound"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3127 ""grammar.c"" <S2SV_EndBug> break ; case 85 : <S2SV_StartBug> # line 1479 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3143 ""grammar.c"" <S2SV_EndBug> break ; case 86 : <S2SV_StartBug> # line 1491 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3158 ""grammar.c"" <S2SV_EndBug> break ; case 87 : <S2SV_StartBug> # line 1506 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3167 ""grammar.c"" <S2SV_EndBug> break ; case 89 : <S2SV_StartBug> # line 1512 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; yr_parser_emit_pushes_for_strings ( yyscanner , ""$*"" ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3178 ""grammar.c"" <S2SV_EndBug> break ; case 92 : <S2SV_StartBug> # line 1529 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3189 ""grammar.c"" <S2SV_EndBug> break ; case 93 : <S2SV_StartBug> # line 1536 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3200 ""grammar.c"" <S2SV_EndBug> break ; case 95 : <S2SV_StartBug> # line 1548 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3208 ""grammar.c"" <S2SV_EndBug> break ; case 96 : <S2SV_StartBug> # line 1552 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; } <S2SV_StartBug> # line 3216 ""grammar.c"" <S2SV_EndBug> break ; case 97 : <S2SV_StartBug> # line 1560 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3224 ""grammar.c"" <S2SV_EndBug> break ; case 98 : <S2SV_StartBug> # line 1564 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit ( yyscanner , OP_FILESIZE , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3238 ""grammar.c"" <S2SV_EndBug> break ; case 99 : <S2SV_StartBug> # line 1574 ""grammar.y"" <S2SV_EndBug> { yywarning ( yyscanner , ""Using<S2SV_blank>deprecated<S2SV_blank>\\""entrypoint\\""<S2SV_blank>keyword.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>\\""entry_point\\""<S2SV_blank>"" ""function<S2SV_blank>from<S2SV_blank>PE<S2SV_blank>module<S2SV_blank>instead."" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_ENTRYPOINT , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3256 ""grammar.c"" <S2SV_EndBug> break ; case 100 : <S2SV_StartBug> # line 1588 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 1 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""intXXXX<S2SV_blank>or<S2SV_blank>uintXXXX"" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , ( uint8_t ) ( OP_READ_INT + ( yyvsp [ - 3 ] . integer ) ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3276 ""grammar.c"" <S2SV_EndBug> break ; case 101 : <S2SV_StartBug> # line 1604 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . integer ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 3290 ""grammar.c"" <S2SV_EndBug> break ; case 102 : <S2SV_StartBug> # line 1614 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg_double ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . double_ ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } <S2SV_StartBug> # line 3303 ""grammar.c"" <S2SV_EndBug> break ; case 103 : <S2SV_StartBug> # line 1623 ""grammar.y"" <S2SV_EndBug> { SIZED_STRING * sized_string ; compiler -> last_result = yr_arena_write_data ( compiler -> sz_arena , ( yyvsp [ 0 ] . sized_string ) , ( yyvsp [ 0 ] . sized_string ) -> length + sizeof ( SIZED_STRING ) , ( void * * ) & sized_string ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , sized_string , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = sized_string ; } <S2SV_StartBug> # line 3332 ""grammar.c"" <S2SV_EndBug> break ; case 104 : <S2SV_StartBug> # line 1648 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_COUNT , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3348 ""grammar.c"" <S2SV_EndBug> break ; case 105 : <S2SV_StartBug> # line 1660 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3364 ""grammar.c"" <S2SV_EndBug> break ; case 106 : <S2SV_StartBug> # line 1672 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3384 ""grammar.c"" <S2SV_EndBug> break ; case 107 : <S2SV_StartBug> # line 1688 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3400 ""grammar.c"" <S2SV_EndBug> break ; case 108 : <S2SV_StartBug> # line 1700 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3420 ""grammar.c"" <S2SV_EndBug> break ; case 109 : <S2SV_StartBug> # line 1716 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_BOOLEAN ) { ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_OBJECT ) { compiler -> last_result = yr_parser_emit ( yyscanner , OP_OBJ_VALUE , NULL ) ; switch ( ( yyvsp [ 0 ] . expression ) . value . object -> type ) { case OBJECT_TYPE_INTEGER : ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; break ; case OBJECT_TYPE_FLOAT : ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; break ; case OBJECT_TYPE_STRING : ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = NULL ; break ; default : yr_compiler_set_error_extra_info_fmt ( compiler , ""wrong<S2SV_blank>usage<S2SV_blank>of<S2SV_blank>identifier<S2SV_blank>\\""%s\\"""" , ( yyvsp [ 0 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } } else { assert ( FALSE ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3469 ""grammar.c"" <S2SV_EndBug> break ; case 110 : <S2SV_StartBug> # line 1761 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT , ""-"" ) ; if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : - ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INT_MINUS , NULL ) ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_FLOAT ) { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_DBL_MINUS , NULL ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3492 ""grammar.c"" <S2SV_EndBug> break ; case 111 : <S2SV_StartBug> # line 1780 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""+"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( + , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3514 ""grammar.c"" <S2SV_EndBug> break ; case 112 : <S2SV_StartBug> # line 1798 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""-"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( - , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3536 ""grammar.c"" <S2SV_EndBug> break ; case 113 : <S2SV_StartBug> # line 1816 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""*"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( * , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3558 ""grammar.c"" <S2SV_EndBug> break ; case 114 : <S2SV_StartBug> # line 1834 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""\\\\"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( / , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3588 ""grammar.c"" <S2SV_EndBug> break ; case 115 : <S2SV_StartBug> # line 1860 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""%"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""%"" ) ; yr_parser_emit ( yyscanner , OP_MOD , NULL ) ; if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( % , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } <S2SV_StartBug> # line 3610 ""grammar.c"" <S2SV_EndBug> break ; case 116 : <S2SV_StartBug> # line 1878 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_XOR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( ^ , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3624 ""grammar.c"" <S2SV_EndBug> break ; case 117 : <S2SV_StartBug> # line 1888 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_AND , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( & , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3638 ""grammar.c"" <S2SV_EndBug> break ; case 118 : <S2SV_StartBug> # line 1898 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""|"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""|"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_OR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( | , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3652 ""grammar.c"" <S2SV_EndBug> break ; case 119 : <S2SV_StartBug> # line 1908 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""~"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : ~ ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3666 ""grammar.c"" <S2SV_EndBug> break ; case 120 : <S2SV_StartBug> # line 1918 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""<<"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""<<"" ) ; yr_parser_emit ( yyscanner , OP_SHL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( << , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3680 ""grammar.c"" <S2SV_EndBug> break ; case 121 : <S2SV_StartBug> # line 1928 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , "">>"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "">>"" ) ; yr_parser_emit ( yyscanner , OP_SHR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( >> , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3694 ""grammar.c"" <S2SV_EndBug> break ; case 122 : <S2SV_StartBug> # line 1938 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3702 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> # line 3706 ""grammar.c"" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , compiler , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , compiler , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , compiler ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , compiler , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , compiler ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }
","<S2SV_ModStart> ; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2371 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 834 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> ; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2409 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 872 <S2SV_ModEnd> ""grammar.y"" { SIZED_STRING <S2SV_ModStart> } # line 2455 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 918 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 2478 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 940 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 2491 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 949 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 2504 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 958 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 2523 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 973 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 2539 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 985 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2557 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 999 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 2574 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1012 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 2589 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1023 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> NULL ; } YYERROR ; } # line 2603 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1033 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2637 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1063 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2676 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1098 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2759 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1177 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2793 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1207 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2846 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1256 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit <S2SV_ModStart> } # line 2856 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1262 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit <S2SV_ModStart> } # line 2866 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1268 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2896 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1294 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2936 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1330 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2965 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1355 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 3005 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1391 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3018 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1400 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3031 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1409 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3044 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1418 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3057 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1427 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3070 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1436 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3083 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1445 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3091 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1449 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3099 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1456 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3105 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1457 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3111 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1463 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3133 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1485 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3149 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1497 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3164 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1512 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3173 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1518 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3184 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1535 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3195 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1542 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3206 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1554 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3214 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1558 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3222 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1566 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3230 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1570 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3244 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1580 <S2SV_ModEnd> ""grammar.y"" { yywarning <S2SV_ModStart> } # line 3262 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1594 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3282 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1610 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3296 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1620 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3309 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1629 <S2SV_ModEnd> ""grammar.y"" { SIZED_STRING <S2SV_ModStart> } # line 3338 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1654 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3354 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1666 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3370 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1678 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3390 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1694 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3406 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1706 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3426 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1722 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3475 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1767 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3498 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1786 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3520 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1804 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3542 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1822 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3564 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1840 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3594 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1866 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3616 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1884 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3630 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1894 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3644 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1904 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3658 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1914 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3672 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1924 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3686 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1934 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3700 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1944 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3708 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> ; # line 3712 <S2SV_ModEnd> ""grammar.c"" default :
",CWE-125
748,"CWE-119 <S2SV_StartBug> static void get_frame_stats ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> vpx_fixed_buf_t * stats ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>frame<S2SV_blank>stats."" ) ; while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_StartBug> if ( pkt -> kind == VPX_CODEC_STATS_PKT ) { <S2SV_EndBug> const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ; const size_t pkt_size = pkt -> data . twopass_stats . sz ; stats -> buf = realloc ( stats -> buf , stats -> sz + pkt_size ) ; memcpy ( ( uint8_t * ) stats -> buf + stats -> sz , pkt_buf , pkt_size ) ; stats -> sz += pkt_size ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> get_frame_stats ( vpx_codec_ctx_t <S2SV_ModStart> stats ) { int got_pkts = 0 ; <S2SV_ModStart> NULL ) { got_pkts = 1 ; <S2SV_ModStart> ; } } return got_pkts ;
",CWE-119
749,"CWE-119 <S2SV_StartBug> int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) { <S2SV_EndBug> <S2SV_StartBug> LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ; <S2SV_EndBug> <S2SV_StartBug> ( void ) arg2 ; <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , & lf_data -> xd , <S2SV_EndBug> lf_data -> start , lf_data -> stop , lf_data -> y_only ) ; return 1 ; }
","<S2SV_ModStart> int vp9_loop_filter_worker ( <S2SV_ModEnd> LFWorkerData * const <S2SV_ModStart> * const lf_data , void * unused ) { <S2SV_ModEnd> ( void ) <S2SV_ModStart> ( void ) unused <S2SV_ModEnd> ; vp9_loop_filter_rows ( <S2SV_ModStart> -> cm , lf_data -> planes <S2SV_ModEnd> , lf_data ->
",CWE-119
751,"CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_ARP_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct arpt_entry * e = ( struct arpt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) arpt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_ARP_NUMHOOKS ) ) { pr_notice ( ""arptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_ARP_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> arp ) ) || <S2SV_EndBug> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_ARP_NUMHOOKS ) ; oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct arpt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct arpt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct arpt_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct arpt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }
","<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
",CWE-119
753,"CWE-119 static future_t * init ( void ) { pthread_mutex_init ( & lock , NULL ) ; config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>load<S2SV_blank>config<S2SV_blank>file;<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file."" , __func__ ) ; config = btif_config_transcode ( LEGACY_CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file,<S2SV_blank>starting<S2SV_blank>unconfigured."" , __func__ ) ; config = config_new_empty ( ) ; if ( ! config ) { LOG_ERROR ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>config<S2SV_blank>object."" , __func__ ) ; goto error ; } } if ( config_save ( config , CONFIG_FILE_PATH ) ) unlink ( LEGACY_CONFIG_FILE_PATH ) ; } <S2SV_StartBug> alarm_timer = alarm_new ( ) ; <S2SV_EndBug> if ( ! alarm_timer ) { LOG_ERROR ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alarm."" , __func__ ) ; goto error ; } return future_new_immediate ( FUTURE_SUCCESS ) ; error : ; alarm_free ( alarm_timer ) ; config_free ( config ) ; pthread_mutex_destroy ( & lock ) ; alarm_timer = NULL ; config = NULL ; return future_new_immediate ( FUTURE_FAIL ) ; }
","<S2SV_ModStart> ) ; } btif_config_devcache_cleanup ( ) ;
",CWE-119
754,"CWE-189 static int ext4_fill_flex_info ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_group_desc * gdp = NULL ; ext4_group_t flex_group_count ; ext4_group_t flex_group ; <S2SV_StartBug> int groups_per_flex = 0 ; <S2SV_EndBug> size_t size ; int i ; sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex ; <S2SV_StartBug> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <S2SV_EndBug> <S2SV_StartBug> if ( groups_per_flex < 2 ) { <S2SV_EndBug> sbi -> s_log_groups_per_flex = 0 ; return 1 ; } flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex ; size = flex_group_count * sizeof ( struct flex_groups ) ; sbi -> s_flex_groups = ext4_kvzalloc ( size , GFP_KERNEL ) ; if ( sbi -> s_flex_groups == NULL ) { ext4_msg ( sb , KERN_ERR , ""not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>flex<S2SV_blank>groups"" , flex_group_count ) ; goto failed ; } for ( i = 0 ; i < sbi -> s_groups_count ; i ++ ) { gdp = ext4_get_group_desc ( sb , i , NULL ) ; flex_group = ext4_flex_group ( sbi , i ) ; atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ) ; atomic_add ( ext4_free_group_clusters ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_clusters ) ; atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . used_dirs ) ; } return 1 ; failed : return 0 ; }
","<S2SV_ModStart> ext4_group_t flex_group ; unsigned <S2SV_ModStart> -> s_log_groups_per_flex ; if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <S2SV_ModStart> -> s_log_groups_per_flex ; <S2SV_ModEnd> flex_group_count = (
",CWE-189
757,"CWE-119 static int smbhash ( unsigned char * out , const unsigned char * in , unsigned char * key ) { <S2SV_StartBug> int rc ; <S2SV_EndBug> unsigned char key2 [ 8 ] ; <S2SV_StartBug> struct crypto_skcipher * tfm_des ; <S2SV_EndBug> struct scatterlist sgin , sgout ; struct skcipher_request * req ; str_to_key ( key , key2 ) ; <S2SV_StartBug> tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ; <S2SV_EndBug> if ( IS_ERR ( tfm_des ) ) { <S2SV_StartBug> rc = PTR_ERR ( tfm_des ) ; <S2SV_EndBug> cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; <S2SV_StartBug> goto smbhash_err ; <S2SV_EndBug> } req = skcipher_request_alloc ( tfm_des , GFP_KERNEL ) ; if ( ! req ) { rc = - ENOMEM ; cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; goto smbhash_free_skcipher ; } crypto_skcipher_setkey ( tfm_des , key2 , 8 ) ; <S2SV_StartBug> sg_init_one ( & sgin , in , 8 ) ; <S2SV_EndBug> sg_init_one ( & sgout , out , 8 ) ; skcipher_request_set_callback ( req , 0 , NULL , NULL ) ; skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ; rc = crypto_skcipher_encrypt ( req ) ; if ( rc ) cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>encrypt<S2SV_blank>crypt<S2SV_blank>key<S2SV_blank>rc:<S2SV_blank>%d\\n"" , rc ) ; skcipher_request_free ( req ) ; smbhash_free_skcipher : crypto_free_skcipher ( tfm_des ) ; <S2SV_StartBug> smbhash_err : <S2SV_EndBug> return rc ; }
","<S2SV_ModStart> key ) { <S2SV_ModEnd> unsigned char key2 <S2SV_ModStart> ] ; struct crypto_cipher * tfm_des <S2SV_ModEnd> ; str_to_key ( <S2SV_ModStart> ; tfm_des = crypto_alloc_cipher ( ""des"" <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) { <S2SV_ModEnd> cifs_dbg ( VFS <S2SV_ModStart> ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <S2SV_ModEnd> ( tfm_des , <S2SV_ModStart> 8 ) ; crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <S2SV_ModEnd> ( tfm_des ) <S2SV_ModStart> tfm_des ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>
",CWE-119
758,"CWE-000 void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { <S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }
","<S2SV_ModStart> ++ ) { if ( band -> prec ) { <S2SV_ModStart> ) ; } }
",CWE-000
759,"CWE-000 int fit_check_format ( const void * fit , ulong size ) { int ret ; ret = fdt_check_header ( fit ) ; if ( ret ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>flattened<S2SV_blank>device<S2SV_blank>tree<S2SV_blank>(err=%d)\\n"" , ret ) ; return - ENOEXEC ; } if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; <S2SV_StartBug> if ( ret ) { <S2SV_EndBug> log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> } } if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\n"" ) ; return - ENOMSG ; } if ( IMAGE_ENABLE_TIMESTAMP ) { if ( ! fdt_getprop ( fit , 0 , FIT_TIMESTAMP_PROP , NULL ) ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>timestamp\\n"" ) ; return - ENODATA ; } } if ( fdt_path_offset ( fit , FIT_IMAGES_PATH ) < 0 ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>images<S2SV_blank>parent<S2SV_blank>node\\n"" ) ; return - ENOENT ; } return 0 ; }
","<S2SV_ModStart> ( ret ) ret = - EINVAL ; if ( ! ret && CONFIG_IS_ENABLED ( FIT_SIGNATURE ) ) { ret = fdt_check_no_at ( fit , 0 ) ; if ( ret ) <S2SV_ModStart> ) ; return ret ; } } if ( ret ) { log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; return ret <S2SV_ModEnd> ; } }
",CWE-000
761,"CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; int i , j , offset ; uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; <S2SV_StartBug> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <S2SV_EndBug> ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; <S2SV_StartBug> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <S2SV_EndBug> i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { uint32_t loc ; struct sparingTable * st ; struct sparablePartitionMap * spm = ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }
","<S2SV_ModStart> * bh ; unsigned int table_len ; <S2SV_ModStart> -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <S2SV_ModStart> && offset < table_len <S2SV_ModEnd> ; i ++
",CWE-119
762,"CWE-119 void vp8dx_bool_decoder_fill ( BOOL_DECODER * br ) { const unsigned char * bufptr = br -> user_buffer ; VP8_BD_VALUE value = br -> value ; int count = br -> count ; <S2SV_StartBug> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <S2SV_EndBug> size_t bytes_left = br -> user_buffer_end - bufptr ; size_t bits_left = bytes_left * CHAR_BIT ; int x = ( int ) ( shift + CHAR_BIT - bits_left ) ; int loop_end = 0 ; unsigned char decrypted [ sizeof ( VP8_BD_VALUE ) + 1 ] ; if ( br -> decrypt_cb ) { <S2SV_StartBug> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <S2SV_EndBug> br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ; bufptr = decrypted ; } if ( x >= 0 ) { count += VP8_LOTS_OF_BITS ; loop_end = x ; } if ( x < 0 || bits_left ) { while ( shift >= loop_end ) { count += CHAR_BIT ; value |= ( VP8_BD_VALUE ) * bufptr << shift ; ++ bufptr ; ++ br -> user_buffer ; shift -= CHAR_BIT ; } } br -> value = value ; br -> count = count ; }
","<S2SV_ModStart> = VP8_BD_VALUE_SIZE - CHAR_BIT <S2SV_ModEnd> - ( count <S2SV_ModStart> ( count + CHAR_BIT <S2SV_ModEnd> ) ; size_t <S2SV_ModStart> size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) <S2SV_ModEnd> ; br ->
",CWE-119
765,"CWE-000 <S2SV_StartBug> static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) <S2SV_EndBug> { struct nfs_delegation * delegation ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( inode ) -> delegation ) ; <S2SV_StartBug> if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) { <S2SV_EndBug> rcu_read_unlock ( ) ; return ; } rcu_read_unlock ( ) ; nfs_inode_return_delegation ( inode ) ; }
","<S2SV_ModStart> * inode , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> -> type & fmode ) == fmode <S2SV_ModEnd> ) { rcu_read_unlock
",CWE-000
766,"CWE-787 <S2SV_StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <S2SV_EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <S2SV_StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ; return ; <S2SV_EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <S2SV_StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <S2SV_EndBug> return ; } <S2SV_StartBug> assert ( len >= 10 ) ; <S2SV_EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
","<S2SV_ModStart> len ) { assert ( len > 28 ) ; <S2SV_ModStart> case LEX_EOF : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""EOF"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_ID : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""ID"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_INT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""INT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_FLOAT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""FLOAT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_COMMENT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>COMMENT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) ; strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> [ p ] <S2SV_ModEnd> ) ; return <S2SV_ModStart> return ; } <S2SV_ModEnd> espruino_snprintf ( str
",CWE-787
767,"CWE-476 void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }
","<S2SV_ModStart> ( ! handle || ! SecIsValidHandle ( handle )
",CWE-476
769,"CWE-190 <S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }
","<S2SV_ModStart> int n , jas_ulonglong <S2SV_ModEnd> val ) {
",CWE-190
771,"CWE-295 NOEXPORT char * parse_service_option ( CMD cmd , SERVICE_OPTIONS * * section_ptr , char * opt , char * arg ) { SERVICE_OPTIONS * section ; int endpoints = 0 ; # ifndef USE_WIN32 struct group * gr ; struct passwd * pw ; # endif section = section_ptr ? * section_ptr : NULL ; if ( cmd == CMD_SET_DEFAULTS || cmd == CMD_SET_COPY ) { section -> ref = 1 ; <S2SV_StartBug> } else if ( cmd == CMD_FREE ) { <S2SV_EndBug> <S2SV_StartBug> if ( section == & service_options || section == & new_service_options ) <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>defaults"" ) ; <S2SV_EndBug> else s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>[%s]"" , section -> servname ) ; } else if ( cmd == CMD_PRINT_DEFAULTS || cmd == CMD_PRINT_HELP ) { s_log ( LOG_NOTICE , ""<S2SV_blank>"" ) ; s_log ( LOG_NOTICE , ""Service-level<S2SV_blank>options:"" ) ; } switch ( cmd ) { case CMD_SET_DEFAULTS : addrlist_clear ( & section -> local_addr , 1 ) ; section -> local_fd = NULL ; break ; case CMD_SET_COPY : addrlist_clear ( & section -> local_addr , 1 ) ; section -> local_fd = NULL ; name_list_dup ( & section -> local_addr . names , new_service_options . local_addr . names ) ; break ; case CMD_FREE : name_list_free ( section -> local_addr . names ) ; str_free ( section -> local_addr . addr ) ; str_free ( section -> local_fd ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""accept"" ) ) break ; section -> option . accept = 1 ; name_list_append ( & section -> local_addr . names , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> local_addr . names ) { unsigned i ; if ( ! addrlist_resolve ( & section -> local_addr ) ) return ""Cannot<S2SV_blank>resolve<S2SV_blank>accept<S2SV_blank>target"" ; section -> local_fd = str_alloc_detached ( section -> local_addr . num * sizeof ( SOCKET ) ) ; for ( i = 0 ; i < section -> local_addr . num ; ++ i ) section -> local_fd [ i ] = INVALID_SOCKET ; ++ endpoints ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>accept<S2SV_blank>connections<S2SV_blank>on<S2SV_blank>specified<S2SV_blank>host:port"" , ""accept"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : # if 0 section -> ca_dir = ( char * ) X509_get_default_cert_dir ( ) ; # endif section -> ca_dir = NULL ; break ; case CMD_SET_COPY : section -> ca_dir = str_dup_detached ( new_service_options . ca_dir ) ; break ; case CMD_FREE : str_free ( section -> ca_dir ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""CApath"" ) ) break ; str_free ( section -> ca_dir ) ; if ( arg [ 0 ] ) section -> ca_dir = str_dup_detached ( arg ) ; else section -> ca_dir = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : # if 0 s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""CApath"" , section -> ca_dir ? section -> ca_dir : ""(none)"" ) ; # endif break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>\'verify\'<S2SV_blank>option"" , ""CApath"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : # if 0 section -> ca_file = ( char * ) X509_get_default_certfile ( ) ; # endif section -> ca_file = NULL ; break ; case CMD_SET_COPY : section -> ca_file = str_dup_detached ( new_service_options . ca_file ) ; break ; case CMD_FREE : str_free ( section -> ca_file ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""CAfile"" ) ) break ; str_free ( section -> ca_file ) ; if ( arg [ 0 ] ) section -> ca_file = str_dup_detached ( arg ) ; else section -> ca_file = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : # if 0 s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""CAfile"" , section -> ca_file ? section -> ca_file : ""(none)"" ) ; # endif break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>file<S2SV_blank>for<S2SV_blank>\'verify\'<S2SV_blank>option"" , ""CAfile"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> cert = NULL ; break ; case CMD_SET_COPY : section -> cert = str_dup_detached ( new_service_options . cert ) ; break ; case CMD_FREE : str_free ( section -> cert ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""cert"" ) ) break ; str_free ( section -> cert ) ; section -> cert = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : # ifndef OPENSSL_NO_PSK if ( section -> psk_keys ) break ; # endif # ifndef OPENSSL_NO_ENGINE if ( section -> engine ) break ; # endif if ( ! section -> option . client && ! section -> cert ) return ""TLS<S2SV_blank>server<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>certificate"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>certificate<S2SV_blank>chain"" , ""cert"" ) ; break ; } # if OPENSSL_VERSION_NUMBER >= 0x10002000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> check_email = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> check_email , new_service_options . check_email ) ; break ; case CMD_FREE : name_list_free ( section -> check_email ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""checkEmail"" ) ) break ; name_list_append ( & section -> check_email , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> check_email && ! section -> option . verify_chain && ! section -> option . verify_peer ) return ""Either<S2SV_blank>\\""verifyChain\\""<S2SV_blank>or<S2SV_blank>\\""verifyPeer\\""<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>email<S2SV_blank>address"" , ""checkEmail"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> check_host = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> check_host , new_service_options . check_host ) ; break ; case CMD_FREE : name_list_free ( section -> check_host ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""checkHost"" ) ) break ; name_list_append ( & section -> check_host , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> check_host && ! section -> option . verify_chain && ! section -> option . verify_peer ) return ""Either<S2SV_blank>\\""verifyChain\\""<S2SV_blank>or<S2SV_blank>\\""verifyPeer\\""<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>host<S2SV_blank>name<S2SV_blank>pattern"" , ""checkHost"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> check_ip = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> check_ip , new_service_options . check_ip ) ; break ; case CMD_FREE : name_list_free ( section -> check_ip ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""checkIP"" ) ) break ; name_list_append ( & section -> check_ip , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> check_ip && ! section -> option . verify_chain && ! section -> option . verify_peer ) return ""Either<S2SV_blank>\\""verifyChain\\""<S2SV_blank>or<S2SV_blank>\\""verifyPeer\\""<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>IP<S2SV_blank>address"" , ""checkIP"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> cipher_list = NULL ; break ; case CMD_SET_COPY : section -> cipher_list = str_dup_detached ( new_service_options . cipher_list ) ; break ; case CMD_FREE : str_free ( section -> cipher_list ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ciphers"" ) ) break ; str_free ( section -> cipher_list ) ; section -> cipher_list = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( ! section -> cipher_list ) { # ifdef USE_FIPS if ( new_global_options . option . fips ) section -> cipher_list = str_dup_detached ( ""FIPS"" ) ; else # endif section -> cipher_list = str_dup_detached ( stunnel_cipher_list ) ; } break ; case CMD_PRINT_DEFAULTS : # ifdef USE_FIPS s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s<S2SV_blank>%s"" , ""ciphers"" , ""FIPS"" , ""(with<S2SV_blank>\\""fips<S2SV_blank>=<S2SV_blank>yes\\"")"" ) ; s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s<S2SV_blank>%s"" , ""ciphers"" , stunnel_cipher_list , ""(with<S2SV_blank>\\""fips<S2SV_blank>=<S2SV_blank>no\\"")"" ) ; # else s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""ciphers"" , stunnel_cipher_list ) ; # endif break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>permitted<S2SV_blank>ciphers<S2SV_blank>for<S2SV_blank>TLS<S2SV_blank>1.2<S2SV_blank>or<S2SV_blank>older"" , ""ciphers"" ) ; break ; } # ifndef OPENSSL_NO_TLS1_3 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ciphersuites = NULL ; break ; case CMD_SET_COPY : section -> ciphersuites = str_dup_detached ( new_service_options . ciphersuites ) ; break ; case CMD_FREE : str_free ( section -> ciphersuites ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ciphersuites"" ) ) break ; str_free ( section -> ciphersuites ) ; section -> ciphersuites = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( ! section -> ciphersuites ) { section -> ciphersuites = str_dup_detached ( stunnel_ciphersuites ) ; } break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s<S2SV_blank>%s"" , ""ciphersuites"" , stunnel_ciphersuites , ""(with<S2SV_blank>TLSv1.3)"" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>permitted<S2SV_blank>ciphersuites<S2SV_blank>for<S2SV_blank>TLS<S2SV_blank>1.3"" , ""ciphersuites"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . client = 0 ; break ; case CMD_SET_COPY : section -> option . client = new_service_options . option . client ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""client"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . client = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . client = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>client<S2SV_blank>mode<S2SV_blank>(remote<S2SV_blank>service<S2SV_blank>uses<S2SV_blank>TLS)"" , ""client"" ) ; break ; } # if OPENSSL_VERSION_NUMBER >= 0x10002000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> config = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> config , new_service_options . config ) ; break ; case CMD_FREE : name_list_free ( section -> config ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""config"" ) ) break ; name_list_append ( & section -> config , arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>command[:parameter]<S2SV_blank>to<S2SV_blank>execute"" , ""config"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : addrlist_clear ( & section -> connect_addr , 0 ) ; section -> connect_session = NULL ; break ; case CMD_SET_COPY : addrlist_clear ( & section -> connect_addr , 0 ) ; section -> connect_session = NULL ; name_list_dup ( & section -> connect_addr . names , new_service_options . connect_addr . names ) ; break ; case CMD_FREE : name_list_free ( section -> connect_addr . names ) ; str_free ( section -> connect_addr . addr ) ; str_free ( section -> connect_session ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""connect"" ) ) break ; name_list_append ( & section -> connect_addr . names , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> connect_addr . names ) { if ( ! section -> option . delayed_lookup && ! addrlist_resolve ( & section -> connect_addr ) ) { s_log ( LOG_INFO , ""Cannot<S2SV_blank>resolve<S2SV_blank>connect<S2SV_blank>target<S2SV_blank>-<S2SV_blank>delaying<S2SV_blank>DNS<S2SV_blank>lookup"" ) ; section -> connect_addr . num = 0 ; section -> redirect_addr . num = 0 ; section -> option . delayed_lookup = 1 ; } if ( section -> option . client ) section -> connect_session = str_alloc_detached ( section -> connect_addr . num * sizeof ( SSL_SESSION * ) ) ; ++ endpoints ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>to<S2SV_blank>connect"" , ""connect"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> crl_dir = NULL ; break ; case CMD_SET_COPY : section -> crl_dir = str_dup_detached ( new_service_options . crl_dir ) ; break ; case CMD_FREE : str_free ( section -> crl_dir ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""CRLpath"" ) ) break ; str_free ( section -> crl_dir ) ; if ( arg [ 0 ] ) section -> crl_dir = str_dup_detached ( arg ) ; else section -> crl_dir = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>CRL<S2SV_blank>directory"" , ""CRLpath"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> crl_file = NULL ; break ; case CMD_SET_COPY : section -> crl_file = str_dup_detached ( new_service_options . crl_file ) ; break ; case CMD_FREE : str_free ( section -> crl_file ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""CRLfile"" ) ) break ; str_free ( section -> crl_file ) ; if ( arg [ 0 ] ) section -> crl_file = str_dup_detached ( arg ) ; else section -> crl_file = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>CRL<S2SV_blank>file"" , ""CRLfile"" ) ; break ; } # ifndef OPENSSL_NO_ECDH switch ( cmd ) { case CMD_SET_DEFAULTS : section -> curves = str_dup_detached ( DEFAULT_CURVES ) ; break ; case CMD_SET_COPY : section -> curves = str_dup_detached ( new_service_options . curves ) ; break ; case CMD_FREE : str_free ( section -> curves ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""curves"" ) && strcasecmp ( opt , ""curve"" ) ) break ; str_free ( section -> curves ) ; section -> curves = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""curves"" , DEFAULT_CURVES ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>ECDH<S2SV_blank>curve<S2SV_blank>names"" , ""curves"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> log_level = LOG_NOTICE ; # if ! defined ( USE_WIN32 ) && ! defined ( __vms ) new_global_options . log_facility = LOG_DAEMON ; # endif break ; case CMD_SET_COPY : section -> log_level = new_service_options . log_level ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""debug"" ) ) break ; return parse_debug_level ( arg , section ) ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : # if ! defined ( USE_WIN32 ) && ! defined ( __vms ) s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""debug"" , ""daemon.notice"" ) ; # else s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""debug"" , ""notice"" ) ; # endif break ; case CMD_PRINT_HELP : # if ! defined ( USE_WIN32 ) && ! defined ( __vms ) s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>[facility].level<S2SV_blank>(e.g.<S2SV_blank>daemon.info)"" , ""debug"" ) ; # else s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>level<S2SV_blank>(e.g.<S2SV_blank>info)"" , ""debug"" ) ; # endif break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . delayed_lookup = 0 ; break ; case CMD_SET_COPY : section -> option . delayed_lookup = new_service_options . option . delayed_lookup ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""delay"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . delayed_lookup = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . delayed_lookup = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>delay<S2SV_blank>DNS<S2SV_blank>lookup<S2SV_blank>for<S2SV_blank>\'connect\'<S2SV_blank>option"" , ""delay"" ) ; break ; } # ifndef OPENSSL_NO_ENGINE switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : section -> engine = new_service_options . engine ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""engineId"" ) ) break ; section -> engine = engine_get_by_id ( arg ) ; if ( ! section -> engine ) return ""Engine<S2SV_blank>ID<S2SV_blank>not<S2SV_blank>found"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>ID<S2SV_blank>of<S2SV_blank>engine<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>key<S2SV_blank>from"" , ""engineId"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : section -> engine = new_service_options . engine ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""engineNum"" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>engine<S2SV_blank>number"" ; section -> engine = engine_get_by_num ( tmp_int - 1 ) ; } if ( ! section -> engine ) return ""Illegal<S2SV_blank>engine<S2SV_blank>number"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>number<S2SV_blank>of<S2SV_blank>engine<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>key<S2SV_blank>from"" , ""engineNum"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> exec_name = NULL ; break ; case CMD_SET_COPY : section -> exec_name = str_dup_detached ( new_service_options . exec_name ) ; break ; case CMD_FREE : str_free ( section -> exec_name ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""exec"" ) ) break ; str_free ( section -> exec_name ) ; section -> exec_name = str_dup_detached ( arg ) ; # ifdef USE_WIN32 section -> exec_args = str_dup_detached ( arg ) ; # else if ( ! section -> exec_args ) { section -> exec_args = str_alloc_detached ( 2 * sizeof ( char * ) ) ; section -> exec_args [ 0 ] = str_dup_detached ( section -> exec_name ) ; section -> exec_args [ 1 ] = NULL ; } # endif return NULL ; case CMD_INITIALIZE : if ( section -> exec_name ) ++ endpoints ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>file<S2SV_blank>execute<S2SV_blank>local<S2SV_blank>inetd-type<S2SV_blank>program"" , ""exec"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> exec_args = NULL ; break ; case CMD_SET_COPY : # ifdef USE_WIN32 section -> exec_args = str_dup_detached ( new_service_options . exec_args ) ; # else section -> exec_args = arg_dup ( new_service_options . exec_args ) ; # endif break ; case CMD_FREE : # ifdef USE_WIN32 str_free ( section -> exec_args ) ; # else arg_free ( section -> exec_args ) ; # endif break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""execArgs"" ) ) break ; # ifdef USE_WIN32 str_free ( section -> exec_args ) ; section -> exec_args = str_dup_detached ( arg ) ; # else arg_free ( section -> exec_args ) ; section -> exec_args = arg_alloc ( arg ) ; # endif return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>\'exec\'<S2SV_blank>(including<S2SV_blank>$0)"" , ""execArgs"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> failover = FAILOVER_PRIO ; section -> rr = 0 ; break ; case CMD_SET_COPY : section -> failover = new_service_options . failover ; section -> rr = new_service_options . rr ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""failover"" ) ) break ; if ( ! strcasecmp ( arg , ""rr"" ) ) section -> failover = FAILOVER_RR ; else if ( ! strcasecmp ( arg , ""prio"" ) ) section -> failover = FAILOVER_PRIO ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'rr\'<S2SV_blank>or<S2SV_blank>\'prio\'"" ; return NULL ; case CMD_INITIALIZE : if ( section -> option . delayed_lookup ) section -> failover = FAILOVER_PRIO ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>rr|prio<S2SV_blank>failover<S2SV_blank>strategy"" , ""failover"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> username = NULL ; break ; case CMD_SET_COPY : section -> username = str_dup_detached ( new_service_options . username ) ; break ; case CMD_FREE : str_free ( section -> username ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ident"" ) ) break ; str_free ( section -> username ) ; section -> username = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>username<S2SV_blank>for<S2SV_blank>IDENT<S2SV_blank>(RFC<S2SV_blank>1413)<S2SV_blank>checking"" , ""ident"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""include"" ) ) break ; return include_config ( arg , section_ptr ) ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>directory<S2SV_blank>with<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>snippets"" , ""include"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> key = NULL ; break ; case CMD_SET_COPY : section -> key = str_dup_detached ( new_service_options . key ) ; break ; case CMD_FREE : str_free ( section -> key ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""key"" ) ) break ; str_free ( section -> key ) ; section -> key = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> cert && ! section -> key ) section -> key = str_dup_detached ( section -> cert ) ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>certificate<S2SV_blank>private<S2SV_blank>key"" , ""key"" ) ; break ; } # ifdef USE_LIBWRAP switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . libwrap = 0 ; break ; case CMD_SET_COPY : section -> option . libwrap = new_service_options . option . libwrap ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""libwrap"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . libwrap = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . libwrap = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>use<S2SV_blank>/etc/hosts.allow<S2SV_blank>and<S2SV_blank>/etc/hosts.deny"" , ""libwrap"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . local = 0 ; break ; case CMD_SET_COPY : section -> option . local = new_service_options . option . local ; memcpy ( & section -> source_addr , & new_service_options . source_addr , sizeof ( SOCKADDR_UNION ) ) ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""local"" ) ) break ; if ( ! hostport2addr ( & section -> source_addr , arg , ""0"" , 1 ) ) return ""Failed<S2SV_blank>to<S2SV_blank>resolve<S2SV_blank>local<S2SV_blank>address"" ; section -> option . local = 1 ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>IP<S2SV_blank>address<S2SV_blank>to<S2SV_blank>be<S2SV_blank>used<S2SV_blank>as<S2SV_blank>source<S2SV_blank>for<S2SV_blank>remote"" ""<S2SV_blank>connections"" , ""local"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> log_id = LOG_ID_SEQUENTIAL ; break ; case CMD_SET_COPY : section -> log_id = new_service_options . log_id ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""logId"" ) ) break ; if ( ! strcasecmp ( arg , ""sequential"" ) ) section -> log_id = LOG_ID_SEQUENTIAL ; else if ( ! strcasecmp ( arg , ""unique"" ) ) section -> log_id = LOG_ID_UNIQUE ; else if ( ! strcasecmp ( arg , ""thread"" ) ) section -> log_id = LOG_ID_THREAD ; else if ( ! strcasecmp ( arg , ""process"" ) ) section -> log_id = LOG_ID_PROCESS ; else return ""Invalid<S2SV_blank>connection<S2SV_blank>identifier<S2SV_blank>type"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""logId"" , ""sequential"" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>connection<S2SV_blank>identifier<S2SV_blank>type"" , ""logId"" ) ; break ; } # ifndef OPENSSL_NO_OCSP switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ocsp_url = NULL ; break ; case CMD_SET_COPY : section -> ocsp_url = str_dup_detached ( new_service_options . ocsp_url ) ; break ; case CMD_FREE : str_free ( section -> ocsp_url ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ocsp"" ) ) break ; str_free ( section -> ocsp_url ) ; section -> ocsp_url = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>OCSP<S2SV_blank>responder<S2SV_blank>URL"" , ""OCSP"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . aia = 0 ; break ; case CMD_SET_COPY : section -> option . aia = new_service_options . option . aia ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""OCSPaia"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . aia = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . aia = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>check<S2SV_blank>the<S2SV_blank>AIA<S2SV_blank>responders<S2SV_blank>from<S2SV_blank>certificates"" , ""OCSPaia"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ocsp_flags = 0 ; break ; case CMD_SET_COPY : section -> ocsp_flags = new_service_options . ocsp_flags ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""OCSPflag"" ) ) break ; { unsigned long tmp_ulong = parse_ocsp_flag ( arg ) ; if ( ! tmp_ulong ) return ""Illegal<S2SV_blank>OCSP<S2SV_blank>flag"" ; section -> ocsp_flags |= tmp_ulong ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>OCSP<S2SV_blank>responder<S2SV_blank>flags"" , ""OCSPflag"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . nonce = 0 ; break ; case CMD_SET_COPY : section -> option . nonce = new_service_options . option . nonce ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""OCSPnonce"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . nonce = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . nonce = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>send<S2SV_blank>and<S2SV_blank>verify<S2SV_blank>the<S2SV_blank>OCSP<S2SV_blank>nonce<S2SV_blank>extension"" , ""OCSPnonce"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ssl_options_set = 0 ; # if OPENSSL_VERSION_NUMBER >= 0x009080dfL section -> ssl_options_clear = 0 ; # endif break ; case CMD_SET_COPY : section -> ssl_options_set = new_service_options . ssl_options_set ; # if OPENSSL_VERSION_NUMBER >= 0x009080dfL section -> ssl_options_clear = new_service_options . ssl_options_clear ; # endif break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""options"" ) ) break ; # if OPENSSL_VERSION_NUMBER >= 0x009080dfL if ( * arg == '-' ) { long unsigned tmp = parse_ssl_option ( arg + 1 ) ; if ( tmp == INVALID_SSL_OPTION ) return ""Illegal<S2SV_blank>TLS<S2SV_blank>option"" ; section -> ssl_options_clear |= tmp ; return NULL ; } # endif { long unsigned tmp = parse_ssl_option ( arg ) ; if ( tmp == INVALID_SSL_OPTION ) return ""Illegal<S2SV_blank>TLS<S2SV_blank>option"" ; section -> ssl_options_set |= tmp ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""options"" , ""NO_SSLv2"" ) ; s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""options"" , ""NO_SSLv3"" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>TLS<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set/reset"" , ""options"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol = NULL ; break ; case CMD_SET_COPY : section -> protocol = str_dup_detached ( new_service_options . protocol ) ; break ; case CMD_FREE : str_free ( section -> protocol ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocol"" ) ) break ; str_free ( section -> protocol ) ; section -> protocol = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : { char * tmp_str = protocol ( NULL , section , PROTOCOL_CHECK ) ; if ( tmp_str ) return tmp_str ; } endpoints += section -> option . protocol_endpoint ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>protocol<S2SV_blank>to<S2SV_blank>negotiate<S2SV_blank>before<S2SV_blank>TLS<S2SV_blank>initialization"" , ""protocol"" ) ; s_log ( LOG_NOTICE , ""%25scurrently<S2SV_blank>supported:<S2SV_blank>cifs,<S2SV_blank>connect,<S2SV_blank>imap,"" , """" ) ; s_log ( LOG_NOTICE , ""%25s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nntp,<S2SV_blank>pgsql,<S2SV_blank>pop3,<S2SV_blank>proxy,<S2SV_blank>smtp,<S2SV_blank>socks"" , """" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_authentication = str_dup_detached ( ""basic"" ) ; break ; case CMD_SET_COPY : section -> protocol_authentication = str_dup_detached ( new_service_options . protocol_authentication ) ; break ; case CMD_FREE : str_free ( section -> protocol_authentication ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocolAuthentication"" ) ) break ; str_free ( section -> protocol_authentication ) ; section -> protocol_authentication = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>authentication<S2SV_blank>type<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations"" , ""protocolAuthentication"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_domain = NULL ; break ; case CMD_SET_COPY : section -> protocol_domain = str_dup_detached ( new_service_options . protocol_domain ) ; break ; case CMD_FREE : str_free ( section -> protocol_domain ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocolDomain"" ) ) break ; str_free ( section -> protocol_domain ) ; section -> protocol_domain = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>domain<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations"" , ""protocolDomain"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_host = NULL ; break ; case CMD_SET_COPY : section -> protocol_host = str_dup_detached ( new_service_options . protocol_host ) ; break ; case CMD_FREE : str_free ( section -> protocol_host ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocolHost"" ) ) break ; str_free ( section -> protocol_host ) ; section -> protocol_host = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>host:port<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations"" , ""protocolHost"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_password = NULL ; break ; case CMD_SET_COPY : section -> protocol_password = str_dup_detached ( new_service_options . protocol_password ) ; break ; case CMD_FREE : str_free ( section -> protocol_password ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocolPassword"" ) ) break ; str_free ( section -> protocol_password ) ; section -> protocol_password = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>password<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations"" , ""protocolPassword"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_username = NULL ; break ; case CMD_SET_COPY : section -> protocol_username = str_dup_detached ( new_service_options . protocol_username ) ; break ; case CMD_FREE : str_free ( section -> protocol_username ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocolUsername"" ) ) break ; str_free ( section -> protocol_username ) ; section -> protocol_username = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>username<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations"" , ""protocolUsername"" ) ; break ; } # ifndef OPENSSL_NO_PSK switch ( cmd ) { case CMD_SET_DEFAULTS : section -> psk_identity = NULL ; section -> psk_selected = NULL ; section -> psk_sorted . val = NULL ; section -> psk_sorted . num = 0 ; break ; case CMD_SET_COPY : section -> psk_identity = str_dup_detached ( new_service_options . psk_identity ) ; break ; case CMD_FREE : str_free ( section -> psk_identity ) ; str_free ( section -> psk_sorted . val ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""PSKidentity"" ) ) break ; str_free ( section -> psk_identity ) ; section -> psk_identity = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( ! section -> psk_keys ) break ; psk_sort ( & section -> psk_sorted , section -> psk_keys ) ; if ( section -> option . client ) { if ( section -> psk_identity ) { section -> psk_selected = psk_find ( & section -> psk_sorted , section -> psk_identity ) ; if ( ! section -> psk_selected ) return ""No<S2SV_blank>key<S2SV_blank>found<S2SV_blank>for<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>PSK<S2SV_blank>identity"" ; } else { section -> psk_selected = section -> psk_keys ; } } else { if ( section -> psk_identity ) s_log ( LOG_NOTICE , ""PSK<S2SV_blank>identity<S2SV_blank>is<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>the<S2SV_blank>server<S2SV_blank>mode"" ) ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>identity<S2SV_blank>for<S2SV_blank>PSK<S2SV_blank>authentication"" , ""PSKidentity"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> psk_keys = NULL ; break ; case CMD_SET_COPY : section -> psk_keys = psk_dup ( new_service_options . psk_keys ) ; break ; case CMD_FREE : psk_free ( section -> psk_keys ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""PSKsecrets"" ) ) break ; section -> psk_keys = psk_read ( arg ) ; if ( ! section -> psk_keys ) return ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>PSK<S2SV_blank>secrets"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>secrets<S2SV_blank>for<S2SV_blank>PSK<S2SV_blank>authentication"" , ""PSKsecrets"" ) ; break ; } # endif # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . pty = 0 ; break ; case CMD_SET_COPY : section -> option . pty = new_service_options . option . pty ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""pty"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . pty = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . pty = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>allocate<S2SV_blank>pseudo<S2SV_blank>terminal<S2SV_blank>for<S2SV_blank>\'exec\'<S2SV_blank>option"" , ""pty"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : addrlist_clear ( & section -> redirect_addr , 0 ) ; break ; case CMD_SET_COPY : addrlist_clear ( & section -> redirect_addr , 0 ) ; name_list_dup ( & section -> redirect_addr . names , new_service_options . redirect_addr . names ) ; break ; case CMD_FREE : name_list_free ( section -> redirect_addr . names ) ; str_free ( section -> redirect_addr . addr ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""redirect"" ) ) break ; name_list_append ( & section -> redirect_addr . names , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> redirect_addr . names ) { if ( section -> option . client ) return ""\\""redirect\\""<S2SV_blank>is<S2SV_blank>unsupported<S2SV_blank>in<S2SV_blank>client<S2SV_blank>sections"" ; if ( section -> option . connect_before_ssl ) return ""\\""redirect\\""<S2SV_blank>is<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>protocol<S2SV_blank>negotiation"" ; if ( ! section -> option . delayed_lookup && ! addrlist_resolve ( & section -> redirect_addr ) ) { s_log ( LOG_INFO , ""Cannot<S2SV_blank>resolve<S2SV_blank>redirect<S2SV_blank>target<S2SV_blank>-<S2SV_blank>delaying<S2SV_blank>DNS<S2SV_blank>lookup"" ) ; section -> connect_addr . num = 0 ; section -> redirect_addr . num = 0 ; section -> option . delayed_lookup = 1 ; } if ( ! section -> option . verify_chain && ! section -> option . verify_peer ) return ""Either<S2SV_blank>\\""verifyChain\\""<S2SV_blank>or<S2SV_blank>\\""verifyPeer\\""<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled<S2SV_blank>for<S2SV_blank>\\""redirect\\""<S2SV_blank>to<S2SV_blank>work"" ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>to<S2SV_blank>redirect<S2SV_blank>on<S2SV_blank>authentication<S2SV_blank>failures"" , ""redirect"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . renegotiation = 1 ; break ; case CMD_SET_COPY : section -> option . renegotiation = new_service_options . option . renegotiation ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""renegotiation"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . renegotiation = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . renegotiation = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>support<S2SV_blank>renegotiation"" , ""renegotiation"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . require_cert = 0 ; break ; case CMD_SET_COPY : section -> option . require_cert = new_service_options . option . require_cert ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""requireCert"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) { section -> option . request_cert = 1 ; section -> option . require_cert = 1 ; } else if ( ! strcasecmp ( arg , ""no"" ) ) { section -> option . require_cert = 0 ; } else { return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>require<S2SV_blank>client<S2SV_blank>certificate"" , ""requireCert"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . reset = 1 ; break ; case CMD_SET_COPY : section -> option . reset = new_service_options . option . reset ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""reset"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . reset = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . reset = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>send<S2SV_blank>TCP<S2SV_blank>RST<S2SV_blank>on<S2SV_blank>error"" , ""reset"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . retry = 0 ; break ; case CMD_SET_COPY : section -> option . retry = new_service_options . option . retry ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""retry"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . retry = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . retry = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>retry<S2SV_blank>connect+exec<S2SV_blank>section"" , ""retry"" ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> servname = str_dup_detached ( ""stunnel"" ) ; break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""service"" ) ) break ; str_free ( section -> servname ) ; section -> servname = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>service<S2SV_blank>name"" , ""service"" ) ; break ; } # endif # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> gid = 0 ; break ; case CMD_SET_COPY : section -> gid = new_service_options . gid ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""setgid"" ) ) break ; gr = getgrnam ( arg ) ; if ( gr ) { section -> gid = gr -> gr_gid ; return NULL ; } { char * tmp_str ; section -> gid = ( gid_t ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>GID"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>groupname<S2SV_blank>for<S2SV_blank>setgid()"" , ""setgid"" ) ; break ; } # endif # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> uid = 0 ; break ; case CMD_SET_COPY : section -> uid = new_service_options . uid ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""setuid"" ) ) break ; pw = getpwnam ( arg ) ; if ( pw ) { section -> uid = pw -> pw_uid ; return NULL ; } { char * tmp_str ; section -> uid = ( uid_t ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>UID"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>username<S2SV_blank>for<S2SV_blank>setuid()"" , ""setuid"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> session_size = 1000L ; break ; case CMD_SET_COPY : section -> session_size = new_service_options . session_size ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sessionCacheSize"" ) ) break ; { char * tmp_str ; section -> session_size = strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>size"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%ld"" , ""sessionCacheSize"" , 1000L ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>size"" , ""sessionCacheSize"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> session_timeout = 300L ; break ; case CMD_SET_COPY : section -> session_timeout = new_service_options . session_timeout ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sessionCacheTimeout"" ) && strcasecmp ( opt , ""session"" ) ) break ; { char * tmp_str ; section -> session_timeout = strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>timeout"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%ld<S2SV_blank>seconds"" , ""sessionCacheTimeout"" , 300L ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>timeout<S2SV_blank>(in<S2SV_blank>seconds)"" , ""sessionCacheTimeout"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . sessiond = 0 ; memset ( & section -> sessiond_addr , 0 , sizeof ( SOCKADDR_UNION ) ) ; section -> sessiond_addr . in . sin_family = AF_INET ; break ; case CMD_SET_COPY : section -> option . sessiond = new_service_options . option . sessiond ; memcpy ( & section -> sessiond_addr , & new_service_options . sessiond_addr , sizeof ( SOCKADDR_UNION ) ) ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sessiond"" ) ) break ; section -> option . sessiond = 1 ; # ifdef SSL_OP_NO_TICKET section -> ssl_options_set |= SSL_OP_NO_TICKET ; # endif if ( ! name2addr ( & section -> sessiond_addr , arg , 0 ) ) return ""Failed<S2SV_blank>to<S2SV_blank>resolve<S2SV_blank>sessiond<S2SV_blank>server<S2SV_blank>address"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>use<S2SV_blank>sessiond<S2SV_blank>at<S2SV_blank>host:port"" , ""sessiond"" ) ; break ; } # ifndef OPENSSL_NO_TLSEXT switch ( cmd ) { case CMD_SET_DEFAULTS : section -> servername_list_head = NULL ; section -> servername_list_tail = NULL ; break ; case CMD_SET_COPY : section -> sni = str_dup_detached ( new_service_options . sni ) ; break ; case CMD_FREE : str_free ( section -> sni ) ; sni_free ( section ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sni"" ) ) break ; str_free ( section -> sni ) ; section -> sni = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : { char * tmp_str = sni_init ( section ) ; if ( tmp_str ) return tmp_str ; } if ( ! section -> option . client && section -> sni ) ++ endpoints ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>master_service:host_name<S2SV_blank>for<S2SV_blank>an<S2SV_blank>SNI<S2SV_blank>virtual<S2SV_blank>service"" , ""sni"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> sock_opts = socket_options_init ( ) ; break ; case CMD_SET_COPY : section -> sock_opts = socket_options_dup ( new_service_options . sock_opts ) ; break ; case CMD_FREE : socket_options_free ( section -> sock_opts ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""socket"" ) ) break ; if ( socket_option_parse ( section -> sock_opts , arg ) ) return ""Illegal<S2SV_blank>socket<S2SV_blank>option"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>a|l|r:option=value[:value]"" , ""socket"" ) ; s_log ( LOG_NOTICE , ""%25sset<S2SV_blank>an<S2SV_blank>option<S2SV_blank>on<S2SV_blank>accept/local/remote<S2SV_blank>socket"" , """" ) ; break ; } # if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sslVersion"" ) ) break ; section -> max_proto_version = section -> min_proto_version = str_to_proto_version ( arg ) ; if ( section -> max_proto_version == - 1 ) return ""Invalid<S2SV_blank>protocol<S2SV_blank>version"" ; return NULL ; case CMD_INITIALIZE : if ( section -> max_proto_version && section -> min_proto_version && section -> max_proto_version < section -> min_proto_version ) return ""Invalid<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>range"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>all"" ""|SSLv3|TLSv1|TLSv1.1|TLSv1.2"" # ifdef TLS1_3_VERSION ""|TLSv1.3"" # endif ""<S2SV_blank>TLS<S2SV_blank>version"" , ""sslVersion"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> max_proto_version = 0 ; break ; case CMD_SET_COPY : section -> max_proto_version = new_service_options . max_proto_version ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sslVersionMax"" ) ) break ; section -> max_proto_version = str_to_proto_version ( arg ) ; if ( section -> max_proto_version == - 1 ) return ""Invalid<S2SV_blank>protocol<S2SV_blank>version"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>all"" ""|SSLv3|TLSv1|TLSv1.1|TLSv1.2"" # ifdef TLS1_3_VERSION ""|TLSv1.3"" # endif ""<S2SV_blank>TLS<S2SV_blank>version"" , ""sslVersionMax"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> min_proto_version = TLS1_VERSION ; break ; case CMD_SET_COPY : section -> min_proto_version = new_service_options . min_proto_version ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sslVersionMin"" ) ) break ; section -> min_proto_version = str_to_proto_version ( arg ) ; if ( section -> min_proto_version == - 1 ) return ""Invalid<S2SV_blank>protocol<S2SV_blank>version"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>all"" ""|SSLv3|TLSv1|TLSv1.1|TLSv1.2"" # ifdef TLS1_3_VERSION ""|TLSv1.3"" # endif ""<S2SV_blank>TLS<S2SV_blank>version"" , ""sslVersionMin"" ) ; break ; } # else switch ( cmd ) { case CMD_SET_DEFAULTS : tls_methods_set ( section , NULL ) ; break ; case CMD_SET_COPY : section -> client_method = new_service_options . client_method ; section -> server_method = new_service_options . server_method ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sslVersion"" ) ) break ; return tls_methods_set ( section , arg ) ; case CMD_INITIALIZE : { char * tmp_str = tls_methods_check ( section ) ; if ( tmp_str ) return tmp_str ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>all"" ""|SSLv2|SSLv3|TLSv1"" # if OPENSSL_VERSION_NUMBER >= 0x10001000L ""|TLSv1.1|TLSv1.2"" # endif ""<S2SV_blank>TLS<S2SV_blank>method"" , ""sslVersion"" ) ; break ; } # endif # ifndef USE_FORK switch ( cmd ) { case CMD_SET_DEFAULTS : section -> stack_size = DEFAULT_STACK_SIZE ; break ; case CMD_SET_COPY : section -> stack_size = new_service_options . stack_size ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""stack"" ) ) break ; { char * tmp_str ; section -> stack_size = ( size_t ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>thread<S2SV_blank>stack<S2SV_blank>size"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes"" , ""stack"" , DEFAULT_STACK_SIZE ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>thread<S2SV_blank>stack<S2SV_blank>size<S2SV_blank>(in<S2SV_blank>bytes)"" , ""stack"" ) ; break ; } # endif # if OPENSSL_VERSION_NUMBER >= 0x10000000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ticket_key = NULL ; break ; case CMD_SET_COPY : section -> ticket_key = key_dup ( new_service_options . ticket_key ) ; break ; case CMD_FREE : key_free ( section -> ticket_key ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ticketKeySecret"" ) ) break ; section -> ticket_key = key_read ( arg , ""ticketKeySecret"" ) ; if ( ! section -> ticket_key ) return ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>ticketKeySecret"" ; return NULL ; case CMD_INITIALIZE : if ( ! section -> ticket_key ) break ; if ( section -> option . client ) { s_log ( LOG_NOTICE , ""ticketKeySecret<S2SV_blank>is<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>the<S2SV_blank>client<S2SV_blank>mode"" ) ; break ; } if ( section -> ticket_key && ! section -> ticket_mac ) return ""\\""ticketKeySecret\\""<S2SV_blank>and<S2SV_blank>\\""ticketMacSecret\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>set<S2SV_blank>together"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>secret<S2SV_blank>key<S2SV_blank>for<S2SV_blank>encryption/decryption<S2SV_blank>TLSv1.3<S2SV_blank>tickets"" , ""ticketKeySecret"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ticket_mac = NULL ; break ; case CMD_SET_COPY : section -> ticket_mac = key_dup ( new_service_options . ticket_mac ) ; break ; case CMD_FREE : key_free ( section -> ticket_mac ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ticketMacSecret"" ) ) break ; section -> ticket_mac = key_read ( arg , ""ticketMacSecret"" ) ; if ( ! section -> ticket_mac ) return ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>ticketMacSecret"" ; return NULL ; case CMD_INITIALIZE : if ( ! section -> ticket_mac ) break ; if ( section -> option . client ) { s_log ( LOG_NOTICE , ""ticketMacSecret<S2SV_blank>is<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>the<S2SV_blank>client<S2SV_blank>mode"" ) ; break ; } if ( section -> ticket_mac && ! section -> ticket_key ) return ""\\""ticketKeySecret\\""<S2SV_blank>and<S2SV_blank>\\""ticketMacSecret\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>set<S2SV_blank>together"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>key<S2SV_blank>for<S2SV_blank>HMAC<S2SV_blank>operations<S2SV_blank>on<S2SV_blank>TLSv1.3<S2SV_blank>tickets"" , ""ticketMacSecret"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_busy = 300 ; break ; case CMD_SET_COPY : section -> timeout_busy = new_service_options . timeout_busy ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""TIMEOUTbusy"" ) ) break ; { char * tmp_str ; section -> timeout_busy = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>busy<S2SV_blank>timeout"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds"" , ""TIMEOUTbusy"" , 300 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>wait<S2SV_blank>for<S2SV_blank>expected<S2SV_blank>data"" , ""TIMEOUTbusy"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_close = 60 ; break ; case CMD_SET_COPY : section -> timeout_close = new_service_options . timeout_close ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""TIMEOUTclose"" ) ) break ; { char * tmp_str ; section -> timeout_close = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>close<S2SV_blank>timeout"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds"" , ""TIMEOUTclose"" , 60 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>wait<S2SV_blank>for<S2SV_blank>close_notify"" , ""TIMEOUTclose"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_connect = 10 ; break ; case CMD_SET_COPY : section -> timeout_connect = new_service_options . timeout_connect ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""TIMEOUTconnect"" ) ) break ; { char * tmp_str ; section -> timeout_connect = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>connect<S2SV_blank>timeout"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds"" , ""TIMEOUTconnect"" , 10 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>connect<S2SV_blank>remote<S2SV_blank>host"" , ""TIMEOUTconnect"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_idle = 43200 ; break ; case CMD_SET_COPY : section -> timeout_idle = new_service_options . timeout_idle ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""TIMEOUTidle"" ) ) break ; { char * tmp_str ; section -> timeout_idle = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>idle<S2SV_blank>timeout"" ; return NULL ; } case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds"" , ""TIMEOUTidle"" , 43200 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>keep<S2SV_blank>an<S2SV_blank>idle<S2SV_blank>connection"" , ""TIMEOUTidle"" ) ; break ; } # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . transparent_src = 0 ; section -> option . transparent_dst = 0 ; break ; case CMD_SET_COPY : section -> option . transparent_src = new_service_options . option . transparent_src ; section -> option . transparent_dst = new_service_options . option . transparent_dst ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""transparent"" ) ) break ; if ( ! strcasecmp ( arg , ""none"" ) || ! strcasecmp ( arg , ""no"" ) ) { section -> option . transparent_src = 0 ; section -> option . transparent_dst = 0 ; } else if ( ! strcasecmp ( arg , ""source"" ) || ! strcasecmp ( arg , ""yes"" ) ) { section -> option . transparent_src = 1 ; section -> option . transparent_dst = 0 ; } else if ( ! strcasecmp ( arg , ""destination"" ) ) { section -> option . transparent_src = 0 ; section -> option . transparent_dst = 1 ; } else if ( ! strcasecmp ( arg , ""both"" ) ) { section -> option . transparent_src = 1 ; section -> option . transparent_dst = 1 ; } else return ""Selected<S2SV_blank>transparent<S2SV_blank>proxy<S2SV_blank>mode<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ; return NULL ; case CMD_INITIALIZE : if ( section -> option . transparent_dst ) ++ endpoints ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>none|source|destination|both<S2SV_blank>transparent<S2SV_blank>proxy<S2SV_blank>mode"" , ""transparent"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . request_cert = 0 ; break ; case CMD_SET_COPY : section -> option . request_cert = new_service_options . option . request_cert ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""verify"" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 4 ) return ""Bad<S2SV_blank>verify<S2SV_blank>level"" ; section -> option . request_cert = 1 ; section -> option . require_cert = ( tmp_int >= 2 ) ; section -> option . verify_chain = ( tmp_int >= 1 && tmp_int <= 3 ) ; section -> option . verify_peer = ( tmp_int >= 3 ) ; } return NULL ; case CMD_INITIALIZE : if ( ( section -> option . verify_chain || section -> option . verify_peer ) && ! section -> ca_file && ! section -> ca_dir ) return ""Either<S2SV_blank>\\""CAfile\\""<S2SV_blank>or<S2SV_blank>\\""CApath\\""<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>configured"" ; break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>none"" , ""verify"" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>level<S2SV_blank>of<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>verification"" , ""verify"" ) ; <S2SV_StartBug> s_log ( LOG_NOTICE , <S2SV_EndBug> ""%25slevel<S2SV_blank>0<S2SV_blank>-<S2SV_blank>request<S2SV_blank>and<S2SV_blank>ignore<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ; s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>1<S2SV_blank>-<S2SV_blank>only<S2SV_blank>validate<S2SV_blank>peer<S2SV_blank>cert<S2SV_blank>if<S2SV_blank>present"" , """" ) ; s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>2<S2SV_blank>-<S2SV_blank>always<S2SV_blank>require<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ; s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>3<S2SV_blank>-<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>with<S2SV_blank>locally<S2SV_blank>installed<S2SV_blank>cert"" , """" ) ; s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>4<S2SV_blank>-<S2SV_blank>ignore<S2SV_blank>CA<S2SV_blank>chain<S2SV_blank>and<S2SV_blank>only<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . verify_chain = 0 ; break ; case CMD_SET_COPY : section -> option . verify_chain = new_service_options . option . verify_chain ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""verifyChain"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) { section -> option . request_cert = 1 ; section -> option . require_cert = 1 ; section -> option . verify_chain = 1 ; } else if ( ! strcasecmp ( arg , ""no"" ) ) { section -> option . verify_chain = 0 ; } else { return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>verify<S2SV_blank>certificate<S2SV_blank>chain"" , ""verifyChain"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . verify_peer = 0 ; break ; case CMD_SET_COPY : section -> option . verify_peer = new_service_options . option . verify_peer ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""verifyPeer"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) { section -> option . request_cert = 1 ; section -> option . require_cert = 1 ; section -> option . verify_peer = 1 ; } else if ( ! strcasecmp ( arg , ""no"" ) ) { section -> option . verify_peer = 0 ; } else { return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>certificate"" , ""verifyPeer"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : str_free ( section -> chain ) ; if ( section -> session ) SSL_SESSION_free ( section -> session ) ; if ( section -> ctx ) SSL_CTX_free ( section -> ctx ) ; str_free ( section -> servname ) ; <S2SV_StartBug> if ( section == & service_options ) <S2SV_EndBug> memset ( section , 0 , sizeof ( SERVICE_OPTIONS ) ) ; else str_free ( section ) ; break ; case CMD_SET_VALUE : return option_not_found ; case CMD_INITIALIZE : if ( section != & new_service_options ) { if ( endpoints != 2 ) return ""Each<S2SV_blank>service<S2SV_blank>must<S2SV_blank>define<S2SV_blank>two<S2SV_blank>endpoints"" ; } else { if ( section -> option . accept ) return ""\'accept\'<S2SV_blank>option<S2SV_blank>is<S2SV_blank>only<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>a<S2SV_blank>[section]"" ; if ( endpoints != 1 ) return ""Inetd<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>define<S2SV_blank>one<S2SV_blank>endpoint"" ; } # ifdef SSL_OP_NO_TICKET if ( OpenSSL_version_num ( ) < 0x10101000L && ! section -> option . client && ! section -> option . connect_before_ssl ) section -> ssl_options_set |= SSL_OP_NO_TICKET ; # endif if ( context_init ( section ) ) return ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>TLS<S2SV_blank>context"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : break ; } return NULL ; }
","<S2SV_ModStart> = 1 ; if ( section == & service_options ) s_log ( LOG_ERR , ""INTERNAL<S2SV_blank>ERROR:<S2SV_blank>Initializing<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults"" ) ; else if ( section == & new_service_options ) s_log ( LOG_INFO , ""Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration"" ) ; else s_log ( LOG_INFO , ""Initializing<S2SV_blank>service<S2SV_blank>[%s]"" , section -> servname ) ; <S2SV_ModStart> == & service_options ) s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults"" ) ; else if ( <S2SV_ModEnd> section == & <S2SV_ModStart> ( LOG_DEBUG , ""Deallocating<S2SV_blank>temporary<S2SV_blank>section<S2SV_blank>defaults"" <S2SV_ModEnd> ) ; else <S2SV_ModStart> break ; } # if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> security_level = - 1 ; break ; case CMD_SET_COPY : section -> security_level = new_service_options . security_level ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""securityLevel"" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 5 ) return ""Illegal<S2SV_blank>security<S2SV_blank>level"" ; section -> security_level = tmp_int ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d"" , ""securityLevel"" , DEFAULT_SECURITY_LEVEL ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>set<S2SV_blank>the<S2SV_blank>security<S2SV_blank>level"" , ""securityLevel"" ) ; break ; } # endif <S2SV_ModStart> ""verify"" ) ; <S2SV_ModEnd> break ; } <S2SV_ModStart> == & service_options || section == & new_service_options
",CWE-295
772,"CWE-787 static void __local_bh_enable ( unsigned int cnt ) { <S2SV_StartBug> lockdep_assert_irqs_disabled ( ) ; <S2SV_EndBug> if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ; <S2SV_StartBug> preempt_count_sub ( cnt ) ; <S2SV_EndBug> }
","<S2SV_ModStart> { lockdep_assert_irqs_disabled ( ) ; if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) <S2SV_ModStart> _RET_IP_ ) ; __preempt_count_sub <S2SV_ModEnd> ( cnt )
",CWE-787
773,"CWE-119 int vp8_hex_search ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvsadcost [ 2 ] , int * mvcost [ 2 ] , int_mv * center_mv ) { MV hex [ 6 ] = { { - 1 , - 2 } , { 1 , - 2 } , { 2 , 0 } , { 1 , 2 } , { - 1 , 2 } , { - 2 , 0 } } ; MV neighbors [ 4 ] = { { 0 , - 1 } , { - 1 , 0 } , { 1 , 0 } , { 0 , 1 } } ; int i , j ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int br , bc ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; unsigned char * base_offset ; unsigned char * this_offset ; int k = - 1 ; int all_in ; int best_site = - 1 ; int hex_range = 127 ; int dia_range = 8 ; int_mv fcenter_mv ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; <S2SV_StartBug> vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; <S2SV_EndBug> br = ref_mv -> as_mv . row ; bc = ref_mv -> as_mv . col ; base_offset = ( unsigned char * ) ( base_pre + d -> offset ) ; this_offset = base_offset + ( br * ( pre_stride ) ) + bc ; this_mv . as_mv . row = br ; this_mv . as_mv . col = bc ; <S2SV_StartBug> bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; # if CONFIG_MULTI_RES_ENCODING if ( search_param >= 6 ) goto cal_neighbors ; else if ( search_param >= 5 ) hex_range = 4 ; else if ( search_param >= 4 ) hex_range = 6 ; else if ( search_param >= 3 ) hex_range = 15 ; else if ( search_param >= 2 ) hex_range = 31 ; else if ( search_param >= 1 ) hex_range = 63 ; dia_range = 8 ; <S2SV_StartBug> # endif <S2SV_EndBug> CHECK_BOUNDS ( 2 ) if ( all_in ) { for ( i = 0 ; i < 6 ; i ++ ) { this_mv . as_mv . row = br + hex [ i ] . row ; this_mv . as_mv . col = bc + hex [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 6 ; i ++ ) { this_mv . as_mv . row = br + hex [ i ] . row ; this_mv . as_mv . col = bc + hex [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) goto cal_neighbors ; else { br += hex [ best_site ] . row ; bc += hex [ best_site ] . col ; k = best_site ; } for ( j = 1 ; j < hex_range ; j ++ ) { best_site = - 1 ; CHECK_BOUNDS ( 2 ) if ( all_in ) { for ( i = 0 ; i < 3 ; i ++ ) { this_mv . as_mv . row = br + next_chkpts [ k ] [ i ] . row ; this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 3 ; i ++ ) { this_mv . as_mv . row = br + next_chkpts [ k ] [ i ] . row ; this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) break ; else { br += next_chkpts [ k ] [ best_site ] . row ; bc += next_chkpts [ k ] [ best_site ] . col ; k += 5 + best_site ; if ( k >= 12 ) k -= 12 ; else if ( k >= 6 ) k -= 6 ; } } cal_neighbors : for ( j = 0 ; j < dia_range ; j ++ ) { best_site = - 1 ; CHECK_BOUNDS ( 1 ) if ( all_in ) { for ( i = 0 ; i < 4 ; i ++ ) { this_mv . as_mv . row = br + neighbors [ i ] . row ; this_mv . as_mv . col = bc + neighbors [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 4 ; i ++ ) { this_mv . as_mv . row = br + neighbors [ i ] . row ; this_mv . as_mv . col = bc + neighbors [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) break ; else { br += neighbors [ best_site ] . row ; bc += neighbors [ best_site ] . col ; } } best_mv -> as_mv . row = br ; best_mv -> as_mv . col = bc ; return bestsad ; }
","<S2SV_ModStart> >> 3 ; ( void ) mvcost ; <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> 8 ; # else ( void ) search_param ; # <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER
",CWE-119
774,"CWE-400 static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ; <S2SV_StartBug> struct mount * child , * p ; <S2SV_EndBug> struct hlist_node * n ; int err ; <S2SV_StartBug> if ( IS_MNT_SHARED ( dest_mnt ) ) { <S2SV_EndBug> err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_StartBug> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <S2SV_EndBug> lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ; <S2SV_StartBug> umount_tree ( child , UMOUNT_SYNC ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; cleanup_group_ids ( source_mnt , NULL ) ; out : <S2SV_StartBug> return err ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; struct mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ; if ( ! parent_path ) { err = count_mounts ( ns , source_mnt <S2SV_ModEnd> ) ; if <S2SV_ModStart> goto out ; } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_ModStart> mnt_hash ) ; child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> ; out : ns -> pending_mounts = 0 ;
",CWE-400
777,"CWE-000 <S2SV_StartBug> static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state ) <S2SV_EndBug> { struct file * filp ; int ret ; <S2SV_StartBug> if ( nd -> intent . open . flags & FMODE_EXEC ) { <S2SV_EndBug> ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , nd -> intent . open . flags ) ; if ( ret < 0 ) goto out_close ; } filp = lookup_instantiate_filp ( nd , path -> dentry , NULL ) ; if ( ! IS_ERR ( filp ) ) { struct nfs_open_context * ctx ; ctx = nfs_file_open_context ( filp ) ; ctx -> state = state ; return 0 ; } ret = PTR_ERR ( filp ) ; out_close : <S2SV_StartBug> nfs4_close_sync ( path , state , nd -> intent . open . flags ) ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> nfs4_state * state , fmode_t fmode <S2SV_ModStart> ; if ( fmode <S2SV_ModEnd> & FMODE_EXEC ) <S2SV_ModStart> , state , fmode & ( FMODE_READ | FMODE_WRITE ) <S2SV_ModEnd> ) ; return
",CWE-000
778,"CWE-000 struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; <S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> fdput ( f ) ; return map ; }
","<S2SV_ModStart> return map ; map =
",CWE-000
779,"CWE-20 static inline void VectorClamp ( DDSVector4 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> w = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,
",CWE-20
780,"CWE-125 static node * parsetok ( struct tok_state * tok , grammar * g , int start , perrdetail * err_ret , int * flags ) { parser_state * ps ; node * n ; int started = 0 ; <S2SV_StartBug> int col_offset , end_col_offset ; <S2SV_EndBug> if ( ( ps = PyParser_New ( g , start ) ) == NULL ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) <S2SV_StartBug> ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; <S2SV_EndBug> # endif for ( ; ; ) { char * a , * b ; int type ; size_t len ; char * str ; col_offset = - 1 ; int lineno ; const char * line_start ; type = PyTokenizer_Get ( tok , & a , & b ) ; if ( type == ERRORTOKEN ) { err_ret -> error = tok -> done ; break ; } if ( type == ENDMARKER && started ) { type = NEWLINE ; started = 0 ; if ( tok -> indent && ! ( * flags & PyPARSE_DONT_IMPLY_DEDENT ) ) { tok -> pendin = - tok -> indent ; tok -> indent = 0 ; } } else started = 1 ; len = ( a != NULL && b != NULL ) ? b - a : 0 ; str = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( str == NULL ) { err_ret -> error = E_NOMEM ; break ; } if ( len > 0 ) strncpy ( str , a , len ) ; str [ len ] = '\\0' ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( type == NOTEQUAL ) { if ( ! ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""!="" ) ) { PyObject_FREE ( str ) ; err_ret -> error = E_SYNTAX ; break ; } else if ( ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""<>"" ) ) { PyObject_FREE ( str ) ; err_ret -> expected = NOTEQUAL ; err_ret -> error = E_SYNTAX ; break ; } } # endif lineno = type == STRING ? tok -> first_lineno : tok -> lineno ; line_start = type == STRING ? tok -> multi_line_start : tok -> line_start ; if ( a != NULL && a >= line_start ) { col_offset = Py_SAFE_DOWNCAST ( a - line_start , intptr_t , int ) ; } else { col_offset = - 1 ; } if ( b != NULL && b >= tok -> line_start ) { end_col_offset = Py_SAFE_DOWNCAST ( b - tok -> line_start , intptr_t , int ) ; } else { end_col_offset = - 1 ; } <S2SV_StartBug> if ( ( err_ret -> error = <S2SV_EndBug> PyParser_AddToken ( ps , ( int ) type , str , lineno , col_offset , tok -> lineno , end_col_offset , & ( err_ret -> expected ) ) ) != E_OK ) { if ( err_ret -> error != E_DONE ) { PyObject_FREE ( str ) ; err_ret -> token = type ; } break ; } } if ( err_ret -> error == E_DONE ) { n = ps -> p_tree ; <S2SV_StartBug> ps -> p_tree = NULL ; <S2SV_EndBug> # ifndef PGEN if ( start == single_input ) { char * cur = tok -> cur ; char c = * tok -> cur ; for ( ; ; ) { while ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\014' ) c = * ++ cur ; if ( ! c ) break ; if ( c != '#' ) { err_ret -> error = E_BADSINGLE ; PyNode_Free ( n ) ; n = NULL ; break ; } while ( c && c != '\\n' ) c = * ++ cur ; } } # endif } else n = NULL ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD * flags = ps -> p_flags ; # endif PyParser_Delete ( ps ) ; if ( n == NULL ) { if ( tok -> done == E_EOF ) err_ret -> error = E_EOF ; err_ret -> lineno = tok -> lineno ; if ( tok -> buf != NULL ) { size_t len ; assert ( tok -> cur - tok -> buf < INT_MAX ) ; err_ret -> offset = col_offset != - 1 ? col_offset + 1 : ( ( int ) ( tok -> cur - tok -> buf ) ) ; len = tok -> inp - tok -> buf ; err_ret -> text = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( err_ret -> text != NULL ) { if ( len > 0 ) strncpy ( err_ret -> text , tok -> buf , len ) ; err_ret -> text [ len ] = '\\0' ; } } } else if ( tok -> encoding != NULL ) { node * r = PyNode_New ( encoding_decl ) ; if ( r ) r -> n_str = PyObject_MALLOC ( strlen ( tok -> encoding ) + 1 ) ; if ( ! r || ! r -> n_str ) { err_ret -> error = E_NOMEM ; if ( r ) PyObject_FREE ( r ) ; n = NULL ; goto done ; } strcpy ( r -> n_str , tok -> encoding ) ; PyMem_FREE ( tok -> encoding ) ; tok -> encoding = NULL ; r -> n_nchildren = 1 ; r -> n_child = n ; n = r ; } done : PyTokenizer_Free ( tok ) ; if ( n != NULL ) { _PyNode_FinalizeEndPos ( n ) ; } return n ; }
","<S2SV_ModStart> , end_col_offset ; growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } <S2SV_ModStart> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; if ( * flags & PyPARSE_TYPE_COMMENTS ) ps -> p_flags |= PyCF_TYPE_COMMENTS <S2SV_ModStart> } if ( type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( <S2SV_ModStart> p_tree = NULL ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { PyNode_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores )
",CWE-125
781,"CWE-119 static void set_segmentation_map ( VP8_COMP * cpi , unsigned char * segmentation_map ) { <S2SV_StartBug> vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_EndBug> cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; }
","<S2SV_ModStart> segmentation_map ) { memcpy <S2SV_ModEnd> ( cpi ->
",CWE-119
782,"CWE-119 void vp9_rc_postencode_update_drop_frame ( VP9_COMP * cpi ) { update_buffer_level ( cpi , 0 ) ; <S2SV_StartBug> cpi -> common . last_frame_type = cpi -> common . frame_type ; <S2SV_EndBug> cpi -> rc . frames_since_key ++ ; cpi -> rc . frames_to_key -- ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ; cpi -> <S2SV_ModEnd> rc . frames_since_key <S2SV_ModStart> frames_to_key -- ; cpi -> rc . rc_2_frame = 0 ; cpi -> rc . rc_1_frame = 0 ;
",CWE-119
783,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_StartBug> height ) ; <S2SV_EndBug> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; number_pixels <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }
",CWE-125
784,"CWE-17 static ssize_t pipe_read ( struct kiocb * iocb , const struct iovec * _iov , unsigned long nr_segs , loff_t pos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; int do_wakeup ; ssize_t ret ; struct iovec * iov = ( struct iovec * ) _iov ; size_t total_len ; <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> if ( unlikely ( total_len == 0 ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; for ( ; ; ) { int bufs = pipe -> nrbufs ; if ( bufs ) { int curbuf = pipe -> curbuf ; struct pipe_buffer * buf = pipe -> bufs + curbuf ; const struct pipe_buf_operations * ops = buf -> ops ; <S2SV_StartBug> void * addr ; <S2SV_EndBug> <S2SV_StartBug> size_t chars = buf -> len ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic ; <S2SV_EndBug> if ( chars > total_len ) chars = total_len ; error = ops -> confirm ( pipe , buf ) ; if ( error ) { if ( ! ret ) ret = error ; break ; } <S2SV_StartBug> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; <S2SV_EndBug> redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; if ( unlikely ( error ) ) { if ( atomic ) { atomic = 0 ; goto redo ; } if ( ! ret ) ret = error ; break ; } ret += chars ; buf -> offset += chars ; buf -> len -= chars ; if ( buf -> flags & PIPE_BUF_FLAG_PACKET ) { total_len = chars ; buf -> len = 0 ; } if ( ! buf -> len ) { buf -> ops = NULL ; ops -> release ( pipe , buf ) ; curbuf = ( curbuf + 1 ) & ( pipe -> buffers - 1 ) ; pipe -> curbuf = curbuf ; pipe -> nrbufs = -- bufs ; do_wakeup = 1 ; } total_len -= chars ; if ( ! total_len ) break ; } if ( bufs ) continue ; if ( ! pipe -> writers ) break ; if ( ! pipe -> waiting_writers ) { if ( ret ) break ; if ( filp -> f_flags & O_NONBLOCK ) { ret = - EAGAIN ; break ; } } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - ERESTARTSYS ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } pipe_wait ( pipe ) ; } __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } if ( ret > 0 ) file_accessed ( filp ) ; return ret ; }
","<S2SV_ModStart> size_t total_len ; struct iov_iter iter ; <S2SV_ModStart> ) return 0 ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <S2SV_ModStart> -> ops ; <S2SV_ModEnd> size_t chars = <S2SV_ModStart> buf -> len ; size_t written <S2SV_ModStart> ; int error <S2SV_ModEnd> ; if ( <S2SV_ModStart> break ; } written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ;
",CWE-17
785,"CWE-20 stf_status ikev2parent_inI1outR1 ( struct msg_digest * md ) { struct state * st = md -> st ; lset_t policy = POLICY_IKEV2_ALLOW ; struct connection * c = find_host_connection ( & md -> iface -> ip_addr , md -> iface -> port , & md -> sender , md -> sender_port , POLICY_IKEV2_ALLOW ) ; # if 0 if ( c == NULL ) { pb_stream pre_sa_pbs = sa_pd -> pbs ; policy = preparse_isakmp_sa_body ( & pre_sa_pbs ) ; c = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; } # endif if ( c == NULL ) { { struct connection * d ; d = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; for ( ; d != NULL ; d = d -> hp_next ) { if ( d -> kind == CK_GROUP ) { } else { if ( d -> kind == CK_TEMPLATE && ! ( d -> policy & POLICY_OPPO ) ) { c = d ; break ; } if ( addrinsubnet ( & md -> sender , & d -> spd . that . client ) && ( c == NULL || ! subnetinsubnet ( & c -> spd . that . client , & d -> spd . that . client ) ) ) c = d ; } } } if ( c == NULL ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>no<S2SV_blank>connection<S2SV_blank>has<S2SV_blank>been<S2SV_blank>authorized%s%s"" , ip_str ( & md -> iface -> ip_addr ) , ntohs ( portof ( & md -> iface -> ip_addr ) ) , ( policy != LEMPTY ) ? ""<S2SV_blank>with<S2SV_blank>policy="" : """" , ( policy != LEMPTY ) ? bitnamesof ( sa_policy_bit_names , policy ) : """" ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } if ( c -> kind != CK_TEMPLATE ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>\\""%s\\""<S2SV_blank>forbids<S2SV_blank>connection"" , ip_str ( & md -> iface -> ip_addr ) , pluto_port , c -> name ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else { if ( ( c -> kind == CK_TEMPLATE ) && c -> spd . that . virt ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>virt<S2SV_blank>(vnet/vhost)<S2SV_blank>set<S2SV_blank>without<S2SV_blank>wildcards<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else if ( ( c -> kind == CK_TEMPLATE ) && ( c -> policy & POLICY_IKEV2_ALLOW_NARROWING ) ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>narrowing=yes<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } } DBG_log ( ""found<S2SV_blank>connection:<S2SV_blank>%s\\n"" , c ? c -> name : ""<none>"" ) ; if ( ! st ) { st = new_state ( ) ; memcpy ( st -> st_icookie , md -> hdr . isa_icookie , COOKIE_SIZE ) ; get_cookie ( FALSE , st -> st_rcookie , COOKIE_SIZE , & md -> sender ) ; initialize_new_state ( st , c , policy , 0 , NULL_FD , pcim_stranger_crypto ) ; st -> st_ikev2 = TRUE ; change_state ( st , STATE_PARENT_R1 ) ; st -> st_msgid_lastack = INVALID_MSGID ; st -> st_msgid_nextuse = 0 ; md -> st = st ; md -> from_state = STATE_IKEv2_BASE ; } if ( force_busy == TRUE ) { u_char dcookie [ SHA1_DIGEST_SIZE ] ; chunk_t dc ; ikev2_get_dcookie ( dcookie , st -> st_ni , & md -> sender , st -> st_icookie ) ; dc . ptr = dcookie ; dc . len = SHA1_DIGEST_SIZE ; if ( md -> chain [ ISAKMP_NEXT_v2KE ] && md -> chain [ ISAKMP_NEXT_v2N ] && ( md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type == v2N_COOKIE ) ) { u_int8_t spisize ; const pb_stream * dc_pbs ; chunk_t blob ; DBG ( DBG_CONTROLMORE , DBG_log ( ""received<S2SV_blank>a<S2SV_blank>DOS<S2SV_blank>cookie<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>verify<S2SV_blank>it"" ) ) ; spisize = md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_spisize ; dc_pbs = & md -> chain [ ISAKMP_NEXT_v2N ] -> pbs ; blob . ptr = dc_pbs -> cur + spisize ; blob . len = pbs_left ( dc_pbs ) - spisize ; DBG ( DBG_CONTROLMORE , DBG_dump_chunk ( ""dcookie<S2SV_blank>received<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>Packet"" , blob ) ; DBG_dump ( ""dcookie<S2SV_blank>computed"" , dcookie , SHA1_DIGEST_SIZE ) ) ; if ( memcmp ( blob . ptr , dcookie , SHA1_DIGEST_SIZE ) != 0 ) { libreswan_log ( ""mismatch<S2SV_blank>in<S2SV_blank>DOS<S2SV_blank>v2N_COOKIE,send<S2SV_blank>a<S2SV_blank>new<S2SV_blank>one"" ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL + v2N_INVALID_IKE_SPI ; } DBG ( DBG_CONTROLMORE , DBG_log ( ""dcookie<S2SV_blank>received<S2SV_blank>match<S2SV_blank>with<S2SV_blank>computed<S2SV_blank>one"" ) ) ; } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""busy<S2SV_blank>mode<S2SV_blank>on.<S2SV_blank>receieved<S2SV_blank>I1<S2SV_blank>without<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>dcookie"" ) ; DBG_log ( ""send<S2SV_blank>a<S2SV_blank>dcookie<S2SV_blank>and<S2SV_blank>forget<S2SV_blank>this<S2SV_blank>state"" ) ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL ; } } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""will<S2SV_blank>not<S2SV_blank>send/process<S2SV_blank>a<S2SV_blank>dcookie"" ) ) ; } { struct ikev2_ke * ke ; <S2SV_StartBug> ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; <S2SV_EndBug> st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { char fromname [ ADDRTOT_BUF ] ; addrtot ( & md -> sender , 0 , fromname , ADDRTOT_BUF ) ; <S2SV_StartBug> libreswan_log ( <S2SV_EndBug> ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ; <S2SV_StartBug> return v2N_INVALID_KE_PAYLOAD ; <S2SV_EndBug> } } { struct ke_continuation * ke = alloc_thing ( struct ke_continuation , ""ikev2_inI1outR1<S2SV_blank>KE"" ) ; stf_status e ; ke -> md = md ; set_suspended ( st , ke -> md ) ; if ( ! st -> st_sec_in_use ) { pcrc_init ( & ke -> ke_pcrc ) ; ke -> ke_pcrc . pcrc_func = ikev2_parent_inI1outR1_continue ; e = build_ke ( & ke -> ke_pcrc , st , st -> st_oakley . group , pcim_stranger_crypto ) ; if ( e != STF_SUSPEND && e != STF_INLINE ) { loglog ( RC_CRYPTOFAILED , ""system<S2SV_blank>too<S2SV_blank>busy"" ) ; delete_state ( st ) ; } } else { e = ikev2_parent_inI1outR1_tail ( ( struct pluto_crypto_req_cont * ) ke , NULL ) ; } reset_globals ( ) ; return e ; } }
","<S2SV_ModStart> * ke ; <S2SV_ModEnd> char fromname [ <S2SV_ModStart> ADDRTOT_BUF ) ; if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( ""Received<S2SV_blank>Notify(%d):<S2SV_blank>%s"" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present"" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModEnd> ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname <S2SV_ModStart> ) ; return STF_FAIL +
",CWE-20
791,"CWE-000 int DetectEngineContentInspection ( DetectEngineCtx * de_ctx , DetectEngineThreadCtx * det_ctx , const Signature * s , const SigMatchData * smd , Flow * f , uint8_t * buffer , uint32_t buffer_len , uint32_t stream_start_offset , uint8_t inspection_mode , void * data ) { SCEnter ( ) ; KEYWORD_PROFILING_START ; det_ctx -> inspection_recursion_counter ++ ; if ( det_ctx -> inspection_recursion_counter == de_ctx -> inspection_recursion_limit ) { det_ctx -> discontinue_matching = 1 ; KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd == NULL || buffer_len == 0 ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd -> type == DETECT_CONTENT ) { DetectContentData * cd = ( DetectContentData * ) smd -> ctx ; SCLogDebug ( ""inspecting<S2SV_blank>content<S2SV_blank>%"" PRIu32 ""<S2SV_blank>buffer_len<S2SV_blank>%"" PRIu32 , cd -> id , buffer_len ) ; # ifdef DEBUG BUG_ON ( cd -> depth != 0 && cd -> depth <= cd -> offset ) ; # endif uint8_t * found = NULL ; uint32_t offset = 0 ; uint32_t depth = buffer_len ; uint32_t prev_offset = 0 ; uint32_t prev_buffer_offset = det_ctx -> buffer_offset ; do { if ( ( cd -> flags & DETECT_CONTENT_DISTANCE ) || ( cd -> flags & DETECT_CONTENT_WITHIN ) ) { SCLogDebug ( ""det_ctx->buffer_offset<S2SV_blank>%"" PRIu32 , det_ctx -> buffer_offset ) ; offset = prev_buffer_offset ; depth = buffer_len ; int distance = cd -> distance ; if ( cd -> flags & DETECT_CONTENT_DISTANCE ) { if ( cd -> flags & DETECT_CONTENT_DISTANCE_BE ) { distance = det_ctx -> bj_values [ cd -> distance ] ; } if ( distance < 0 && ( uint32_t ) ( abs ( distance ) ) > offset ) offset = 0 ; else offset += distance ; SCLogDebug ( ""cd->distance<S2SV_blank>%"" PRIi32 "",<S2SV_blank>offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , distance , offset , depth ) ; } if ( cd -> flags & DETECT_CONTENT_WITHIN ) { if ( cd -> flags & DETECT_CONTENT_WITHIN_BE ) { if ( ( int32_t ) depth > ( int32_t ) ( prev_buffer_offset + det_ctx -> bj_values [ cd -> within ] + distance ) ) { depth = prev_buffer_offset + det_ctx -> bj_values [ cd -> within ] + distance ; } } else { if ( ( int32_t ) depth > ( int32_t ) ( prev_buffer_offset + cd -> within + distance ) ) { depth = prev_buffer_offset + cd -> within + distance ; } SCLogDebug ( ""cd->within<S2SV_blank>%"" PRIi32 "",<S2SV_blank>det_ctx->buffer_offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , cd -> within , prev_buffer_offset , depth ) ; } if ( stream_start_offset != 0 && prev_buffer_offset == 0 ) { if ( depth <= stream_start_offset ) { goto no_match ; } else if ( depth >= ( stream_start_offset + buffer_len ) ) { ; } else { depth = depth - stream_start_offset ; } } } if ( cd -> flags & DETECT_CONTENT_DEPTH_BE ) { if ( ( det_ctx -> bj_values [ cd -> depth ] + prev_buffer_offset ) < depth ) { depth = prev_buffer_offset + det_ctx -> bj_values [ cd -> depth ] ; } } else { if ( cd -> depth != 0 ) { if ( ( cd -> depth + prev_buffer_offset ) < depth ) { depth = prev_buffer_offset + cd -> depth ; } SCLogDebug ( ""cd->depth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , cd -> depth , depth ) ; } } if ( cd -> flags & DETECT_CONTENT_OFFSET_BE ) { if ( det_ctx -> bj_values [ cd -> offset ] > offset ) offset = det_ctx -> bj_values [ cd -> offset ] ; } else { if ( cd -> offset > offset ) { offset = cd -> offset ; SCLogDebug ( ""setting<S2SV_blank>offset<S2SV_blank>%"" PRIu32 , offset ) ; } } } else { if ( cd -> flags & DETECT_CONTENT_DEPTH_BE ) { depth = det_ctx -> bj_values [ cd -> depth ] ; } else { if ( cd -> depth != 0 ) { depth = cd -> depth ; } } if ( stream_start_offset != 0 && cd -> flags & DETECT_CONTENT_DEPTH ) { if ( depth <= stream_start_offset ) { goto no_match ; } else if ( depth >= ( stream_start_offset + buffer_len ) ) { ; } else { depth = depth - stream_start_offset ; } } if ( cd -> flags & DETECT_CONTENT_OFFSET_BE ) offset = det_ctx -> bj_values [ cd -> offset ] ; else offset = cd -> offset ; prev_buffer_offset = 0 ; } SCLogDebug ( ""offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>prev_offset<S2SV_blank>%"" PRIu32 , offset , prev_offset ) ; if ( prev_offset != 0 ) offset = prev_offset ; SCLogDebug ( ""offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , offset , depth ) ; if ( depth > buffer_len ) depth = buffer_len ; if ( offset > depth || depth == 0 ) { if ( cd -> flags & DETECT_CONTENT_NEGATED ) { goto match ; } else { goto no_match ; } } uint8_t * sbuffer = buffer + offset ; uint32_t sbuffer_len = depth - offset ; uint32_t match_offset = 0 ; SCLogDebug ( ""sbuffer_len<S2SV_blank>%"" PRIu32 , sbuffer_len ) ; # ifdef DEBUG BUG_ON ( sbuffer_len > buffer_len ) ; # endif found = SpmScan ( cd -> spm_ctx , det_ctx -> spm_thread_ctx , sbuffer , sbuffer_len ) ; SCLogDebug ( ""found<S2SV_blank>%p<S2SV_blank>cd<S2SV_blank>negated<S2SV_blank>%s"" , found , cd -> flags & DETECT_CONTENT_NEGATED ? ""true"" : ""false"" ) ; if ( found == NULL && ! ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { <S2SV_StartBug> goto no_match ; <S2SV_EndBug> } else if ( found == NULL && ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { goto match ; } else if ( found != NULL && ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { SCLogDebug ( ""content<S2SV_blank>%"" PRIu32 ""<S2SV_blank>matched<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>but<S2SV_blank>negated<S2SV_blank>so<S2SV_blank>no<S2SV_blank>match"" , cd -> id , match_offset ) ; if ( DETECT_CONTENT_IS_SINGLE ( cd ) ) det_ctx -> discontinue_matching = 1 ; goto no_match ; } else { match_offset = ( uint32_t ) ( ( found - buffer ) + cd -> content_len ) ; SCLogDebug ( ""content<S2SV_blank>%"" PRIu32 ""<S2SV_blank>matched<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%"" PRIu32 """" , cd -> id , match_offset ) ; det_ctx -> buffer_offset = match_offset ; if ( cd -> flags & DETECT_CONTENT_REPLACE ) { if ( inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD ) { det_ctx -> replist = DetectReplaceAddToList ( det_ctx -> replist , found , cd ) ; } else { SCLogWarning ( SC_ERR_INVALID_VALUE , ""Can\'t<S2SV_blank>modify<S2SV_blank>payload<S2SV_blank>without<S2SV_blank>packet"" ) ; } } <S2SV_StartBug> if ( ! ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) ) { <S2SV_EndBug> SCLogDebug ( ""no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match"" ) ; goto match ; } if ( smd -> is_last ) { goto no_match ; } SCLogDebug ( ""content<S2SV_blank>%"" PRIu32 , cd -> id ) ; KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; int r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; if ( r == 1 ) { SCReturnInt ( 1 ) ; } <S2SV_StartBug> if ( det_ctx -> discontinue_matching ) <S2SV_EndBug> goto no_match ; prev_offset = ( match_offset - ( cd -> content_len - 1 ) ) ; SCLogDebug ( ""trying<S2SV_blank>to<S2SV_blank>see<S2SV_blank>if<S2SV_blank>there<S2SV_blank>is<S2SV_blank>another<S2SV_blank>match<S2SV_blank>after<S2SV_blank>prev_offset<S2SV_blank>%"" PRIu32 , prev_offset ) ; } } while ( 1 ) ; } else if ( smd -> type == DETECT_ISDATAAT ) { SCLogDebug ( ""inspecting<S2SV_blank>isdataat"" ) ; DetectIsdataatData * id = ( DetectIsdataatData * ) smd -> ctx ; if ( id -> flags & ISDATAAT_RELATIVE ) { if ( det_ctx -> buffer_offset + id -> dataat > buffer_len ) { SCLogDebug ( ""det_ctx->buffer_offset<S2SV_blank>+<S2SV_blank>id->dataat<S2SV_blank>%"" PRIu32 ""<S2SV_blank>><S2SV_blank>%"" PRIu32 , det_ctx -> buffer_offset + id -> dataat , buffer_len ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto match ; goto no_match ; } else { SCLogDebug ( ""relative<S2SV_blank>isdataat<S2SV_blank>match"" ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto no_match ; goto match ; } } else { if ( id -> dataat < buffer_len ) { SCLogDebug ( ""absolute<S2SV_blank>isdataat<S2SV_blank>match"" ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto no_match ; goto match ; } else { SCLogDebug ( ""absolute<S2SV_blank>isdataat<S2SV_blank>mismatch,<S2SV_blank>id->isdataat<S2SV_blank>%"" PRIu32 "",<S2SV_blank>buffer_len<S2SV_blank>%"" PRIu32 """" , id -> dataat , buffer_len ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto match ; goto no_match ; } } } else if ( smd -> type == DETECT_PCRE ) { SCLogDebug ( ""inspecting<S2SV_blank>pcre"" ) ; DetectPcreData * pe = ( DetectPcreData * ) smd -> ctx ; uint32_t prev_buffer_offset = det_ctx -> buffer_offset ; uint32_t prev_offset = 0 ; int r = 0 ; det_ctx -> pcre_match_start_offset = 0 ; do { Packet * p = NULL ; if ( inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD ) p = ( Packet * ) data ; r = DetectPcrePayloadMatch ( det_ctx , s , smd , p , f , buffer , buffer_len ) ; if ( r == 0 ) { goto no_match ; } if ( ! ( pe -> flags & DETECT_PCRE_RELATIVE_NEXT ) ) { SCLogDebug ( ""no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match"" ) ; goto match ; } KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; prev_offset = det_ctx -> pcre_match_start_offset ; r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; if ( r == 1 ) { SCReturnInt ( 1 ) ; } if ( det_ctx -> discontinue_matching ) goto no_match ; det_ctx -> buffer_offset = prev_buffer_offset ; det_ctx -> pcre_match_start_offset = prev_offset ; } while ( 1 ) ; } else if ( smd -> type == DETECT_BYTETEST ) { DetectBytetestData * btd = ( DetectBytetestData * ) smd -> ctx ; uint8_t flags = btd -> flags ; int32_t offset = btd -> offset ; uint64_t value = btd -> value ; if ( flags & DETECT_BYTETEST_OFFSET_BE ) { offset = det_ctx -> bj_values [ offset ] ; } if ( flags & DETECT_BYTETEST_VALUE_BE ) { value = det_ctx -> bj_values [ value ] ; } if ( flags & DETECT_BYTETEST_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; flags |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] & 0x10 ) ? DETECT_BYTETEST_LITTLE : 0 ) ; } if ( DetectBytetestDoMatch ( det_ctx , s , smd -> ctx , buffer , buffer_len , flags , offset , value ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_BYTEJUMP ) { DetectBytejumpData * bjd = ( DetectBytejumpData * ) smd -> ctx ; uint8_t flags = bjd -> flags ; int32_t offset = bjd -> offset ; if ( flags & DETECT_BYTEJUMP_OFFSET_BE ) { offset = det_ctx -> bj_values [ offset ] ; } if ( flags & DETECT_BYTEJUMP_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; flags |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] & 0x10 ) ? DETECT_BYTEJUMP_LITTLE : 0 ) ; } if ( DetectBytejumpDoMatch ( det_ctx , s , smd -> ctx , buffer , buffer_len , flags , offset ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_BYTE_EXTRACT ) { DetectByteExtractData * bed = ( DetectByteExtractData * ) smd -> ctx ; uint8_t endian = bed -> endian ; if ( ( bed -> flags & DETECT_BYTE_EXTRACT_FLAG_ENDIAN ) && endian == DETECT_BYTE_EXTRACT_ENDIAN_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; endian |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] == 0x10 ) ? DETECT_BYTE_EXTRACT_ENDIAN_LITTLE : DETECT_BYTE_EXTRACT_ENDIAN_BIG ) ; } if ( DetectByteExtractDoMatch ( det_ctx , smd , s , buffer , buffer_len , & det_ctx -> bj_values [ bed -> local_id ] , endian ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_AL_URILEN ) { SCLogDebug ( ""inspecting<S2SV_blank>uri<S2SV_blank>len"" ) ; int r = 0 ; DetectUrilenData * urilend = ( DetectUrilenData * ) smd -> ctx ; switch ( urilend -> mode ) { case DETECT_URILEN_EQ : if ( buffer_len == urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_LT : if ( buffer_len < urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_GT : if ( buffer_len > urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_RA : if ( buffer_len > urilend -> urilen1 && buffer_len < urilend -> urilen2 ) { r = 1 ; } break ; } if ( r == 1 ) { goto match ; } det_ctx -> discontinue_matching = 0 ; goto no_match ; # ifdef HAVE_LUA } else if ( smd -> type == DETECT_LUA ) { SCLogDebug ( ""lua<S2SV_blank>starting"" ) ; if ( DetectLuaMatchBuffer ( det_ctx , s , smd , buffer , buffer_len , det_ctx -> buffer_offset , f ) != 1 ) { SCLogDebug ( ""lua<S2SV_blank>no_match"" ) ; goto no_match ; } SCLogDebug ( ""lua<S2SV_blank>match"" ) ; goto match ; # endif } else if ( smd -> type == DETECT_BASE64_DECODE ) { if ( DetectBase64DecodeDoMatch ( det_ctx , s , smd , buffer , buffer_len ) ) { if ( s -> sm_arrays [ DETECT_SM_LIST_BASE64_DATA ] != NULL ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; if ( DetectBase64DataDoMatch ( de_ctx , det_ctx , s , f ) ) { goto final_match ; } } } } else { SCLogDebug ( ""sm->type<S2SV_blank>%u"" , smd -> type ) ; # ifdef DEBUG BUG_ON ( 1 ) ; # endif } no_match : KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; match : if ( ! smd -> is_last ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; int r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; SCReturnInt ( r ) ; } final_match : KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; SCReturnInt ( 1 ) ; }
","<S2SV_ModStart> ) ) { if ( ( cd -> flags & ( DETECT_CONTENT_DISTANCE | DETECT_CONTENT_WITHIN ) ) == 0 ) { det_ctx -> discontinue_matching = 1 ; } <S2SV_ModStart> } if ( smd -> is_last ) { goto match <S2SV_ModEnd> ; } SCLogDebug <S2SV_ModStart> ) ; } SCLogDebug ( ""no<S2SV_blank>match<S2SV_blank>for<S2SV_blank>\'next<S2SV_blank>sm\'"" ) ; <S2SV_ModStart> -> discontinue_matching ) { SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>said<S2SV_blank>to<S2SV_blank>discontinue<S2SV_blank>this<S2SV_blank>right<S2SV_blank>now"" ) ; goto no_match ; } if ( ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) == 0 ) { SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>depend<S2SV_blank>on<S2SV_blank>me,<S2SV_blank>so<S2SV_blank>we<S2SV_blank>can<S2SV_blank>give<S2SV_blank>up"" ) ; det_ctx -> discontinue_matching = 1 ; goto no_match ; } SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>depends<S2SV_blank>on<S2SV_blank>me<S2SV_blank>%p,<S2SV_blank>lets<S2SV_blank>see<S2SV_blank>what<S2SV_blank>we<S2SV_blank>can<S2SV_blank>do<S2SV_blank>(flags<S2SV_blank>%u)"" , cd , cd -> flags ) <S2SV_ModEnd> ; prev_offset =
",CWE-000
792,"CWE-284 static void command_timed_out ( UNUSED_ATTR void * context ) { pthread_mutex_lock ( & commands_pending_response_lock ) ; if ( list_is_empty ( commands_pending_response ) ) { LOG_ERROR ( ""%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>commands<S2SV_blank>pending<S2SV_blank>response"" , __func__ ) ; } else { waiting_command_t * wait_entry = list_front ( commands_pending_response ) ; pthread_mutex_unlock ( & commands_pending_response_lock ) ; LOG_ERROR ( ""%s<S2SV_blank>hci<S2SV_blank>layer<S2SV_blank>timeout<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>to<S2SV_blank>a<S2SV_blank>command.<S2SV_blank>opcode:<S2SV_blank>0x%x"" , __func__ , wait_entry -> opcode ) ; } LOG_ERROR ( ""%s<S2SV_blank>restarting<S2SV_blank>the<S2SV_blank>bluetooth<S2SV_blank>process."" , __func__ ) ; <S2SV_StartBug> usleep ( 10000 ) ; <S2SV_EndBug> kill ( getpid ( ) , SIGKILL ) ; }
","<S2SV_ModStart> __func__ ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 10000 )
",CWE-284
793,"CWE-264 static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { <S2SV_StartBug> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct trusted_key_payload * new_p ; <S2SV_EndBug> struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kfree ( datablob ) ; kfree ( new_o ) ; return ret ; }
","<S2SV_ModStart> struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> if ( !
",CWE-264
799,"CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( npages && ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow_memslot ( kvm , slot ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow_all ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }
","<S2SV_ModStart> ( ! npages || base_gfn != old . base_gfn
",CWE-399
802,"CWE-674 static void renameColumnFunc ( sqlite3_context * context , int NotUsed , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; RenameCtx sCtx ; const char * zSql = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zDb = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * zTable = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; int iCol = sqlite3_value_int ( argv [ 5 ] ) ; const char * zNew = ( const char * ) sqlite3_value_text ( argv [ 6 ] ) ; int bQuote = sqlite3_value_int ( argv [ 7 ] ) ; int bTemp = sqlite3_value_int ( argv [ 8 ] ) ; const char * zOld ; int rc ; Parse sParse ; Walker sWalker ; Index * pIdx ; int i ; Table * pTab ; # ifndef SQLITE_OMIT_AUTHORIZATION sqlite3_xauth xAuth = db -> xAuth ; # endif UNUSED_PARAMETER ( NotUsed ) ; if ( zSql == 0 ) return ; if ( zTable == 0 ) return ; if ( zNew == 0 ) return ; if ( iCol < 0 ) return ; sqlite3BtreeEnterAll ( db ) ; pTab = sqlite3FindTable ( db , zTable , zDb ) ; if ( pTab == 0 || iCol >= pTab -> nCol ) { sqlite3BtreeLeaveAll ( db ) ; return ; } zOld = pTab -> aCol [ iCol ] . zName ; memset ( & sCtx , 0 , sizeof ( sCtx ) ) ; sCtx . iCol = ( ( iCol == pTab -> iPKey ) ? - 1 : iCol ) ; # ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = 0 ; # endif rc = renameParseSql ( & sParse , zDb , 0 , db , zSql , bTemp ) ; memset ( & sWalker , 0 , sizeof ( Walker ) ) ; sWalker . pParse = & sParse ; sWalker . xExprCallback = renameColumnExprCb ; sWalker . xSelectCallback = renameColumnSelectCb ; sWalker . u . pRename = & sCtx ; sCtx . pTab = pTab ; if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; if ( sParse . pNewTable ) { Select * pSelect = sParse . pNewTable -> pSelect ; if ( pSelect ) { <S2SV_StartBug> sParse . rc = SQLITE_OK ; <S2SV_EndBug> <S2SV_StartBug> sqlite3SelectPrep ( & sParse , sParse . pNewTable -> pSelect , 0 ) ; <S2SV_EndBug> rc = ( db -> mallocFailed ? SQLITE_NOMEM : sParse . rc ) ; if ( rc == SQLITE_OK ) { sqlite3WalkSelect ( & sWalker , pSelect ) ; } if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; } else { int bFKOnly = sqlite3_stricmp ( zTable , sParse . pNewTable -> zName ) ; FKey * pFKey ; assert ( sParse . pNewTable -> pSelect == 0 ) ; sCtx . pTab = sParse . pNewTable ; if ( bFKOnly == 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) sParse . pNewTable -> aCol [ iCol ] . zName ) ; if ( sCtx . iCol < 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) & sParse . pNewTable -> iPKey ) ; } sqlite3WalkExprList ( & sWalker , sParse . pNewTable -> pCheck ) ; for ( pIdx = sParse . pNewTable -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3WalkExprList ( & sWalker , pIdx -> aColExpr ) ; } for ( pIdx = sParse . pNewIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3WalkExprList ( & sWalker , pIdx -> aColExpr ) ; } } # ifndef SQLITE_OMIT_GENERATED_COLUMNS for ( i = 0 ; i < sParse . pNewTable -> nCol ; i ++ ) { sqlite3WalkExpr ( & sWalker , sParse . pNewTable -> aCol [ i ] . pDflt ) ; } # endif for ( pFKey = sParse . pNewTable -> pFKey ; pFKey ; pFKey = pFKey -> pNextFrom ) { for ( i = 0 ; i < pFKey -> nCol ; i ++ ) { if ( bFKOnly == 0 && pFKey -> aCol [ i ] . iFrom == iCol ) { renameTokenFind ( & sParse , & sCtx , ( void * ) & pFKey -> aCol [ i ] ) ; } if ( 0 == sqlite3_stricmp ( pFKey -> zTo , zTable ) && 0 == sqlite3_stricmp ( pFKey -> aCol [ i ] . zCol , zOld ) ) { renameTokenFind ( & sParse , & sCtx , ( void * ) pFKey -> aCol [ i ] . zCol ) ; } } } } } else if ( sParse . pNewIndex ) { sqlite3WalkExprList ( & sWalker , sParse . pNewIndex -> aColExpr ) ; sqlite3WalkExpr ( & sWalker , sParse . pNewIndex -> pPartIdxWhere ) ; } else { TriggerStep * pStep ; rc = renameResolveTrigger ( & sParse , ( bTemp ? 0 : zDb ) ) ; if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; for ( pStep = sParse . pNewTrigger -> step_list ; pStep ; pStep = pStep -> pNext ) { if ( pStep -> zTarget ) { Table * pTarget = sqlite3LocateTable ( & sParse , 0 , pStep -> zTarget , zDb ) ; if ( pTarget == pTab ) { if ( pStep -> pUpsert ) { ExprList * pUpsertSet = pStep -> pUpsert -> pUpsertSet ; renameColumnElistNames ( & sParse , & sCtx , pUpsertSet , zOld ) ; } renameColumnIdlistNames ( & sParse , & sCtx , pStep -> pIdList , zOld ) ; renameColumnElistNames ( & sParse , & sCtx , pStep -> pExprList , zOld ) ; } } } if ( sParse . pTriggerTab == pTab ) { renameColumnIdlistNames ( & sParse , & sCtx , sParse . pNewTrigger -> pColumns , zOld ) ; } renameWalkTrigger ( & sWalker , sParse . pNewTrigger ) ; } assert ( rc == SQLITE_OK ) ; rc = renameEditSql ( context , & sCtx , zSql , zNew , bQuote ) ; renameColumnFunc_done : if ( rc != SQLITE_OK ) { if ( sParse . zErrMsg ) { renameColumnParseError ( context , 0 , argv [ 1 ] , argv [ 2 ] , & sParse ) ; } else { sqlite3_result_error_code ( context , rc ) ; } } renameParseCleanup ( & sParse ) ; renameTokenFree ( db , sCtx . pList ) ; # ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = xAuth ; # endif sqlite3BtreeLeaveAll ( db ) ; }
","<S2SV_ModStart> pSelect ) { pSelect -> selFlags &= ~ SF_View ; <S2SV_ModStart> & sParse , <S2SV_ModEnd> pSelect , 0
",CWE-674
803,"CWE-119 void btif_config_flush ( void ) { assert ( config != NULL ) ; assert ( alarm_timer != NULL ) ; alarm_cancel ( alarm_timer ) ; <S2SV_StartBug> pthread_mutex_lock ( & lock ) ; <S2SV_EndBug> config_save ( config , CONFIG_FILE_PATH ) ; pthread_mutex_unlock ( & lock ) ; }
","<S2SV_ModStart> alarm_timer ) ; btif_config_write ( <S2SV_ModEnd> ) ; }
",CWE-119
808,"CWE-119 int vp9_get_raw_frame ( VP9Decoder * pbi , YV12_BUFFER_CONFIG * sd , <S2SV_StartBug> int64_t * time_stamp , int64_t * time_end_stamp , <S2SV_EndBug> <S2SV_StartBug> vp9_ppflags_t * flags ) { <S2SV_EndBug> <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> if ( pbi -> ready_for_new_data == 1 ) return ret ; <S2SV_StartBug> if ( pbi -> common . show_frame == 0 ) <S2SV_EndBug> return ret ; pbi -> ready_for_new_data = 1 ; <S2SV_StartBug> * time_stamp = pbi -> last_time_stamp ; <S2SV_EndBug> * time_end_stamp = 0 ; <S2SV_StartBug> # if CONFIG_VP9_POSTPROC <S2SV_EndBug> <S2SV_StartBug> ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ; <S2SV_EndBug> # else <S2SV_StartBug> * sd = * pbi -> common . frame_to_show ; <S2SV_EndBug> sd -> y_width = pbi -> common . width ; sd -> y_height = pbi -> common . height ; sd -> uv_width = sd -> y_width >> pbi -> common . subsampling_x ; sd -> uv_height = sd -> y_height >> pbi -> common . subsampling_y ; ret = 0 ; # endif <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> * sd , <S2SV_ModEnd> vp9_ppflags_t * flags <S2SV_ModStart> flags ) { VP9_COMMON * const cm = & pbi -> common ; <S2SV_ModStart> - 1 ; # if ! CONFIG_VP9_POSTPROC ( void ) * flags ; # endif <S2SV_ModStart> return ret ; pbi -> ready_for_new_data = 1 ; if ( ! cm -> show_frame <S2SV_ModEnd> ) return ret <S2SV_ModStart> = 1 ; <S2SV_ModEnd> # if CONFIG_VP9_POSTPROC <S2SV_ModStart> # if CONFIG_VP9_POSTPROC if ( ! cm -> show_existing_frame ) { <S2SV_ModStart> = vp9_post_proc_frame ( cm <S2SV_ModEnd> , sd , <S2SV_ModStart> flags ) ; } else { * sd = * cm -> frame_to_show ; ret = 0 ; } <S2SV_ModStart> sd = * cm -> frame_to_show <S2SV_ModEnd> ; ret = <S2SV_ModStart> ; # endif vpx_clear_system_state <S2SV_ModEnd> ( ) ;
",CWE-119
811,"CWE-119 static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } } <S2SV_StartBug> DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n"" , r -> req . tag , r -> iov . iov_len ) ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; <S2SV_StartBug> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <S2SV_EndBug> }
","<S2SV_ModStart> , r -> qiov . size <S2SV_ModEnd> ) ; n <S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> , r -> qiov . size <S2SV_ModEnd> ) ; }
",CWE-119
812,"CWE-119 void vp9_rc_get_one_pass_cbr_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; int target ; if ( ( cm -> current_video_frame == 0 || <S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> rc -> frames_to_key == 0 || <S2SV_StartBug> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <S2SV_EndBug> cm -> frame_type = KEY_FRAME ; rc -> this_key_frame_forced = cm -> current_video_frame != 0 && rc -> frames_to_key == 0 ; <S2SV_StartBug> rc -> frames_to_key = cpi -> key_frame_frequency ; <S2SV_EndBug> rc -> kf_boost = DEFAULT_KF_BOOST ; <S2SV_StartBug> rc -> source_alt_ref_active = 0 ; <S2SV_EndBug> target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } else { cm -> frame_type = INTER_FRAME ; <S2SV_StartBug> target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> vp9_rc_set_frame_target ( cpi , target ) ; <S2SV_StartBug> rc -> frames_till_gf_update_due = INT_MAX ; <S2SV_EndBug> rc -> baseline_gf_interval = INT_MAX ; }
","<S2SV_ModStart> 0 || ( cpi <S2SV_ModEnd> -> frame_flags & <S2SV_ModStart> . auto_key && 0 <S2SV_ModEnd> ) ) ) <S2SV_ModStart> = cpi -> oxcf . key_freq <S2SV_ModEnd> ; rc -> <S2SV_ModStart> source_alt_ref_active = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> = INTER_FRAME ; } if ( rc -> frames_till_gf_update_due == 0 ) { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_golden_update ( cpi ) ; else rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) rc -> frames_till_gf_update_due = rc -> frames_to_key ; cpi -> refresh_golden_frame = 1 ; rc -> gfu_boost = DEFAULT_GF_BOOST ; } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; if ( cm -> frame_type == KEY_FRAME ) target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; else target = <S2SV_ModEnd> calc_pframe_target_size_one_pass_cbr ( cpi <S2SV_ModStart> cpi ) ; <S2SV_ModEnd> vp9_rc_set_frame_target ( cpi <S2SV_ModStart> target ) ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC ) cpi -> resize_pending = vp9_resize_one_pass_cbr ( cpi ) ; else cpi -> resize_pending = 0 <S2SV_ModEnd> ; } <S2SV_null>
",CWE-119
813,"CWE-476 GF_Err latm_dmx_process ( GF_Filter * filter ) { GF_LATMDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u32 pos ; <S2SV_StartBug> u8 * data , * output ; <S2SV_EndBug> <S2SV_StartBug> u32 pck_size , prev_pck_size ; <S2SV_EndBug> u64 cts = GF_FILTER_NO_TS ; if ( ctx -> in_error ) return ctx -> in_error ; if ( ! ctx -> duration . num ) latm_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> latm_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } else { return GF_OK ; } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; <S2SV_EndBug> if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } prev_pck_size = ctx -> latm_buffer_size ; if ( pck && ! ctx -> resume_from ) { if ( ctx -> latm_buffer_size + pck_size > ctx -> latm_buffer_alloc ) { ctx -> latm_buffer_alloc = ctx -> latm_buffer_size + pck_size ; ctx -> latm_buffer = gf_realloc ( ctx -> latm_buffer , ctx -> latm_buffer_alloc ) ; } memcpy ( ctx -> latm_buffer + ctx -> latm_buffer_size , data , pck_size ) ; ctx -> latm_buffer_size += pck_size ; } if ( ! ctx -> bs ) ctx -> bs = gf_bs_new ( ctx -> latm_buffer , ctx -> latm_buffer_size , GF_BITSTREAM_READ ) ; else gf_bs_reassign_buffer ( ctx -> bs , ctx -> latm_buffer , ctx -> latm_buffer_size ) ; if ( ctx -> resume_from ) { gf_bs_seek ( ctx -> bs , ctx -> resume_from - 1 ) ; ctx -> resume_from = 0 ; } if ( cts == GF_FILTER_NO_TS ) prev_pck_size = 0 ; while ( 1 ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; u8 latm_buffer [ 4096 ] ; u32 latm_frame_size = 4096 ; if ( ! latm_dmx_sync_frame_bs ( ctx -> bs , & ctx -> acfg , & latm_frame_size , latm_buffer , NULL ) ) break ; if ( ctx -> in_seek ) { u64 nb_samples_at_seek = ( u64 ) ( ctx -> start_range * GF_M4ASampleRates [ ctx -> sr_idx ] ) ; if ( ctx -> cts + ctx -> dts_inc >= nb_samples_at_seek ) { ctx -> in_seek = GF_FALSE ; } } latm_dmx_check_pid ( filter , ctx ) ; if ( ! ctx -> is_playing ) { ctx -> resume_from = pos + 1 ; return GF_OK ; } if ( ! ctx -> in_seek ) { GF_FilterSAPType sap = GF_FILTER_SAP_1 ; dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , latm_frame_size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; memcpy ( output , latm_buffer , latm_frame_size ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_duration ( dst_pck , ctx -> dts_inc ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; if ( ctx -> acfg . base_object_type == GF_CODECID_USAC ) { if ( latm_frame_size && ( output [ 0 ] & 0x80 ) && ! ctx -> prev_sap ) { sap = GF_FILTER_SAP_1 ; ctx -> prev_sap = GF_TRUE ; } else { sap = GF_FILTER_SAP_NONE ; ctx -> prev_sap = GF_FALSE ; } } gf_filter_pck_set_sap ( dst_pck , sap ) ; gf_filter_pck_send ( dst_pck ) ; } latm_dmx_update_cts ( ctx ) ; if ( prev_pck_size ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; if ( prev_pck_size <= pos ) { prev_pck_size = 0 ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = pck ; if ( pck ) gf_filter_pck_ref_props ( & ctx -> src_pck ) ; } } } if ( pck ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; assert ( ctx -> latm_buffer_size >= pos ) ; memmove ( ctx -> latm_buffer , ctx -> latm_buffer + pos , ctx -> latm_buffer_size - pos ) ; ctx -> latm_buffer_size -= pos ; gf_filter_pid_drop_packet ( ctx -> ipid ) ; assert ( ! ctx -> resume_from ) ; } else { ctx -> latm_buffer_size = 0 ; return latm_dmx_process ( filter ) ; } return GF_OK ; }
","<S2SV_ModStart> u8 * data = NULL <S2SV_ModStart> ; u32 pck_size = 0 <S2SV_ModStart> ; } } else { <S2SV_ModStart> pck_size ) ; }
",CWE-476
814,"CWE-119 int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) { <S2SV_StartBug> if ( radiotap_header -> it_version ) <S2SV_EndBug> return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg - <S2SV_StartBug> ( unsigned long ) iterator -> _rtheader > <S2SV_EndBug> ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }
","<S2SV_ModStart> { if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> iterator -> _rtheader + sizeof ( uint32_t )
",CWE-119
818,"CWE-190 void jas_matrix_divpow2 ( jas_matrix_t * matrix , int n ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = ( * data >= 0 ) ? ( ( * data ) >> n ) : ( - ( ( - ( * data ) ) >> n ) ) ; } } } }
","<S2SV_ModStart> n ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
",CWE-190
820,"CWE-119 static copyFunc pickCopyFunc ( TIFF * in , TIFF * out , uint16 bitspersample , uint16 samplesperpixel ) { uint16 shortv ; uint32 w , l , tw , tl ; int bychunk ; <S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug> if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>different<S2SV_blank>planar<S2SV_blank>configuration<S2SV_blank>w/<S2SV_blank>bits/sample<S2SV_blank>!=<S2SV_blank>8\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & w ) ; TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & l ) ; if ( ! ( TIFFIsTiled ( out ) || TIFFIsTiled ( in ) ) ) { uint32 irps = ( uint32 ) - 1L ; TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & irps ) ; bychunk = ! bias && ( rowsperstrip == irps ) ; } else { if ( bias ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>tiled<S2SV_blank>configuration<S2SV_blank>w/bias<S2SV_blank>image\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } if ( TIFFIsTiled ( out ) ) { if ( ! TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ) tw = w ; if ( ! TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ) tl = l ; bychunk = ( tw == tilewidth && tl == tilelength ) ; } else { TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; bychunk = ( tw == w && tl == rowsperstrip ) ; } } # define T 1 # define F 0 # define pack ( a , b , c , d , e ) ( ( long ) ( ( ( a ) << 11 ) | ( ( b ) << 3 ) | ( ( c ) << 2 ) | ( ( d ) << 1 ) | ( e ) ) ) switch ( pack ( shortv , config , TIFFIsTiled ( in ) , TIFFIsTiled ( out ) , bychunk ) ) { case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , T ) : return cpContigStrips2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , T ) : return cpContigStrips2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , T ) : return cpSeparateStrips2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , T ) : return cpSeparateStrips2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , T ) : return cpContigTiles2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , T ) : return cpContigTiles2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , T ) : return cpSeparateTiles2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , T ) : return cpSeparateTiles2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , T ) : return cpContigTiles2ContigStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , T ) : return cpContigTiles2SeparateStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , T ) : return cpSeparateTiles2ContigStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , T ) : return cpSeparateTiles2SeparateStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , F ) : return bias ? cpBiasedContig2Contig : cpContig2ContigByRow ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , T ) : return cpDecodedStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , T ) : return cpContig2SeparateByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , T ) : return cpSeparate2ContigByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , T ) : return cpSeparate2SeparateByRow ; } # undef pack # undef F # undef T fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>copy/convert<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; }
","<S2SV_ModStart> ( void ) TIFFGetFieldDefaulted <S2SV_ModEnd> ( in ,
",CWE-119
822,"CWE-125 stmt_ty <S2SV_StartBug> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! value ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>value<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>Assign"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Assign_kind ; p -> v . Assign . targets = targets ; p -> v . Assign . value = value ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
","<S2SV_ModStart> expr_ty value , string type_comment , <S2SV_ModStart> ; p -> v . Assign . type_comment = type_comment ; p ->
",CWE-125
823,"CWE-119 static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } else { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif context -> frbuff_p . p8 ++ ; # ifndef NGIFLIB_INDEXED_ONLY } else { context -> frbuff_p . p32 ++ ; } # endif } }
","<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
",CWE-119
824,"CWE-400 static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , <S2SV_StartBug> u64 nr , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { struct swevent_htable * swhash = & __get_cpu_var ( swevent_htable ) ; struct perf_event * event ; struct hlist_node * node ; struct hlist_head * head ; rcu_read_lock ( ) ; head = find_swevent_head_rcu ( swhash , type , event_id ) ; if ( ! head ) goto end ; hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { if ( perf_swevent_match ( event , type , event_id , data , regs ) ) <S2SV_StartBug> perf_swevent_event ( event , nr , nmi , data , regs ) ; <S2SV_EndBug> } end : rcu_read_unlock ( ) ; }
","<S2SV_ModStart> , u64 nr <S2SV_ModEnd> , struct perf_sample_data <S2SV_ModStart> , nr , <S2SV_ModEnd> data , regs
",CWE-400
825,"CWE-125 <S2SV_StartBug> uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) { <S2SV_EndBug> uint32_t ret_cnt = 0 ; uint8_t command = 0 ; uint8_t channel = 0 ; uint8_t data_1 = 0 ; uint8_t data_2 = 0 ; char * text = NULL ; <S2SV_StartBug> if ( event_data [ 0 ] >= 0x80 ) { <S2SV_EndBug> command = * event_data & 0xf0 ; channel = * event_data ++ & 0x0f ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } else { command = running_event & 0xf0 ; channel = running_event & 0x0f ; } switch ( command ) { case 0x80 : _SETUP_NOTEOFF : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; _WM_midi_setup_noteoff ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0x90 : if ( event_data [ 1 ] == 0 ) goto _SETUP_NOTEOFF ; <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_noteon ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xa0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_aftertouch ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xb0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_control ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xc0 : data_1 = * event_data ++ ; midi_setup_patch ( mdi , channel , data_1 ) ; ret_cnt ++ ; break ; case 0xd0 : data_1 = * event_data ++ ; midi_setup_channel_pressure ( mdi , channel , data_1 ) ; ret_cnt ++ ; break ; case 0xe0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_pitch ( mdi , channel , ( ( data_2 << 7 ) | ( data_1 & 0x7f ) ) ) ; ret_cnt += 2 ; break ; case 0xf0 : if ( channel == 0x0f ) { uint32_t tmp_length = 0 ; if ( ( event_data [ 0 ] == 0x00 ) && ( event_data [ 1 ] == 0x02 ) ) { <S2SV_StartBug> midi_setup_sequenceno ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> ret_cnt += 4 ; } else if ( event_data [ 0 ] == 0x01 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_text ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x02 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> if ( mdi -> extra_info . copyright ) { mdi -> extra_info . copyright = realloc ( mdi -> extra_info . copyright , ( strlen ( mdi -> extra_info . copyright ) + 1 + tmp_length + 1 ) ) ; memcpy ( & mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) + 1 ] , event_data , tmp_length ) ; mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) + 1 + tmp_length ] = '\\0' ; mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) ] = '\\n' ; } else { mdi -> extra_info . copyright = malloc ( tmp_length + 1 ) ; memcpy ( mdi -> extra_info . copyright , event_data , tmp_length ) ; mdi -> extra_info . copyright [ tmp_length ] = '\\0' ; } text = malloc ( tmp_length + 1 ) ; memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_copyright ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x03 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_trackname ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x04 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_instrumentname ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x05 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_lyric ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x06 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_marker ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x07 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_cuepoint ( mdi , text ) ; ret_cnt += tmp_length ; <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x20 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_EndBug> midi_setup_channelprefix ( mdi , event_data [ 2 ] ) ; ret_cnt += 3 ; } else if ( ( event_data [ 0 ] == 0x21 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_StartBug> midi_setup_portprefix ( mdi , event_data [ 2 ] ) ; <S2SV_EndBug> ret_cnt += 3 ; } else if ( ( event_data [ 0 ] == 0x2F ) && ( event_data [ 1 ] == 0x00 ) ) { <S2SV_StartBug> _WM_midi_setup_endoftrack ( mdi ) ; <S2SV_EndBug> ret_cnt += 2 ; } else if ( ( event_data [ 0 ] == 0x51 ) && ( event_data [ 1 ] == 0x03 ) ) { <S2SV_StartBug> _WM_midi_setup_tempo ( mdi , ( ( event_data [ 2 ] << 16 ) + ( event_data [ 3 ] << 8 ) + event_data [ 4 ] ) ) ; <S2SV_EndBug> ret_cnt += 5 ; <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x54 ) && ( event_data [ 1 ] == 0x05 ) ) { <S2SV_EndBug> midi_setup_smpteoffset ( mdi , ( ( event_data [ 3 ] << 24 ) + ( event_data [ 4 ] << 16 ) + ( event_data [ 5 ] << 8 ) + event_data [ 6 ] ) ) ; mdi -> events [ mdi -> events_size - 1 ] . event_data . channel = event_data [ 2 ] ; ret_cnt += 7 ; } else if ( ( event_data [ 0 ] == 0x58 ) && ( event_data [ 1 ] == 0x04 ) ) { <S2SV_StartBug> midi_setup_timesignature ( mdi , ( ( event_data [ 2 ] << 24 ) + ( event_data [ 3 ] << 16 ) + ( event_data [ 4 ] << 8 ) + event_data [ 5 ] ) ) ; <S2SV_EndBug> ret_cnt += 6 ; } else if ( ( event_data [ 0 ] == 0x59 ) && ( event_data [ 1 ] == 0x02 ) ) { <S2SV_StartBug> midi_setup_keysignature ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> ret_cnt += 4 ; } else { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; ret_cnt ++ ; ret_cnt += tmp_length ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( ( channel == 0 ) || ( channel == 7 ) ) { uint32_t sysex_len = 0 ; uint8_t * sysex_store = NULL ; if ( * event_data > 0x7f ) { <S2SV_StartBug> do { <S2SV_EndBug> sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ; event_data ++ ; <S2SV_StartBug> if ( ! sysex_len ) break ; <S2SV_EndBug> ret_cnt ++ ; sysex_store = malloc ( sizeof ( uint8_t ) * sysex_len ) ; memcpy ( sysex_store , event_data , sysex_len ) ; if ( sysex_store [ sysex_len - 1 ] == 0xF7 ) { uint8_t rolandsysexid [ ] = { 0x41 , 0x10 , 0x42 , 0x12 } ; if ( memcmp ( rolandsysexid , sysex_store , 4 ) == 0 ) { uint8_t sysex_cs = 0 ; uint32_t sysex_ofs = 4 ; do { sysex_cs += sysex_store [ sysex_ofs ] ; if ( sysex_cs > 0x7F ) { sysex_cs -= 0x80 ; } sysex_ofs ++ ; } while ( sysex_store [ sysex_ofs + 1 ] != 0xf7 ) ; sysex_cs = 128 - sysex_cs ; if ( sysex_cs == sysex_store [ sysex_ofs ] ) { if ( sysex_store [ 4 ] == 0x40 ) { if ( ( ( sysex_store [ 5 ] & 0xf0 ) == 0x10 ) && ( sysex_store [ 6 ] == 0x15 ) ) { uint8_t sysex_ch = 0x0f & sysex_store [ 5 ] ; if ( sysex_ch == 0x00 ) { sysex_ch = 0x09 ; } else if ( sysex_ch <= 0x09 ) { sysex_ch -= 1 ; } midi_setup_sysex_roland_drum_track ( mdi , sysex_ch , sysex_store [ 7 ] ) ; } else if ( ( sysex_store [ 5 ] == 0x00 ) && ( sysex_store [ 6 ] == 0x7F ) && ( sysex_store [ 7 ] == 0x00 ) ) { midi_setup_sysex_roland_reset ( mdi ) ; } } } } else { uint8_t gm_reset [ ] = { 0x7e , 0x7f , 0x09 , 0x01 , 0xf7 } ; uint8_t yamaha_reset [ ] = { 0x43 , 0x10 , 0x4c , 0x00 , 0x00 , 0x7e , 0x00 , 0xf7 } ; if ( memcmp ( gm_reset , sysex_store , 5 ) == 0 ) { midi_setup_sysex_gm_reset ( mdi ) ; } else if ( memcmp ( yamaha_reset , sysex_store , 8 ) == 0 ) { midi_setup_sysex_yamaha_reset ( mdi ) ; } } } free ( sysex_store ) ; sysex_store = NULL ; ret_cnt += sysex_len ; } else { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(unrecognized<S2SV_blank>meta<S2SV_blank>type<S2SV_blank>event)"" , 0 ) ; return 0 ; } break ; default : ret_cnt = 0 ; break ; } if ( ret_cnt == 0 ) _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>event)"" , 0 ) ; return ret_cnt ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> * event_data , uint32_t siz , <S2SV_ModStart> ; if ( ! siz ) goto shortbuf ; if ( <S2SV_ModStart> ; ret_cnt ++ ; if ( -- siz == 0 ) goto shortbuf <S2SV_ModStart> : _SETUP_NOTEOFF : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> goto _SETUP_NOTEOFF ; if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xa0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xb0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xe0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ; ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ) ) { if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 5 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 7 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 6 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> += tmp_length ; if ( -- siz < tmp_length ) goto shortbuf ; <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> event_data ++ ; ret_cnt ++ ; if ( -- siz < sysex_len ) goto shortbuf ; <S2SV_ModStart> sysex_len ) break <S2SV_ModEnd> ; sysex_store = <S2SV_ModStart> return ret_cnt ; shortbuf : _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(input<S2SV_blank>too<S2SV_blank>short)"" , 0 ) ; return 0 ;
",CWE-125
826,"CWE-119 int main ( int argc , char * argv [ ] ) { opj_dinfo_t * dinfo ; opj_event_mgr_t event_mgr ; int tnum ; unsigned int snum ; opj_mj2_t * movie ; mj2_tk_t * track ; mj2_sample_t * sample ; unsigned char * frame_codestream ; FILE * file , * outfile ; char outfilename [ 50 ] ; mj2_dparameters_t parameters ; if ( argc != 3 ) { printf ( ""Usage:<S2SV_blank>%s<S2SV_blank>mj2filename<S2SV_blank>output_location\\n"" , argv [ 0 ] ) ; printf ( ""Example:<S2SV_blank>%s<S2SV_blank>foreman.mj2<S2SV_blank>output/foreman\\n"" , argv [ 0 ] ) ; return 1 ; } file = fopen ( argv [ 1 ] , ""rb"" ) ; if ( ! file ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading\\n"" , argv [ 1 ] ) ; return 1 ; } memset ( & event_mgr , 0 , sizeof ( opj_event_mgr_t ) ) ; event_mgr . error_handler = error_callback ; event_mgr . warning_handler = warning_callback ; event_mgr . info_handler = info_callback ; dinfo = mj2_create_decompress ( ) ; opj_set_event_mgr ( ( opj_common_ptr ) dinfo , & event_mgr , stderr ) ; memset ( & parameters , 0 , sizeof ( mj2_dparameters_t ) ) ; movie = ( opj_mj2_t * ) dinfo -> mj2_handle ; mj2_setup_decoder ( movie , & parameters ) ; if ( mj2_read_struct ( file , movie ) ) { return 1 ; } tnum = 0 ; while ( movie -> tk [ tnum ] . track_type != 0 ) { tnum ++ ; } track = & movie -> tk [ tnum ] ; fprintf ( stdout , ""Extracting<S2SV_blank>%d<S2SV_blank>frames<S2SV_blank>from<S2SV_blank>file...\\n"" , track -> num_samples ) ; for ( snum = 0 ; snum < track -> num_samples ; snum ++ ) { sample = & track -> sample [ snum ] ; frame_codestream = ( unsigned char * ) malloc ( sample -> sample_size - 8 ) ; fseek ( file , sample -> offset + 8 , SEEK_SET ) ; fread ( frame_codestream , sample -> sample_size - 8 , 1 , file ) ; <S2SV_StartBug> sprintf ( outfilename , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ; <S2SV_EndBug> outfile = fopen ( outfilename , ""wb"" ) ; if ( ! outfile ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n"" , outfilename ) ; return 1 ; } fwrite ( frame_codestream , sample -> sample_size - 8 , 1 , outfile ) ; fclose ( outfile ) ; free ( frame_codestream ) ; } fclose ( file ) ; fprintf ( stdout , ""%d<S2SV_blank>frames<S2SV_blank>correctly<S2SV_blank>extracted\\n"" , snum ) ; if ( dinfo ) { mj2_destroy_decompress ( ( opj_mj2_t * ) dinfo -> mj2_handle ) ; } return 0 ; }
","<S2SV_ModStart> file ) ; int num = snprintf <S2SV_ModEnd> ( outfilename , <S2SV_ModStart> ( outfilename , sizeof ( outfilename ) , <S2SV_ModStart> snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , ""maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n"" ) ; return 1 ; }
",CWE-119
828,"CWE-125 int obj2ast_comprehension ( PyObject * obj , comprehension_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty target ; expr_ty iter ; asdl_seq * ifs ; int is_async ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_ifs ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_ifs ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; ifs = _Ta3_asdl_seq_new ( len , arena ) ; if ( ifs == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( ifs , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_is_async ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_int ( tmp , & is_async , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } * out = comprehension ( target , iter , ifs , is_async , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_iter , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_is_async , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } *
",CWE-125
830,"CWE-119 static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) { MACROBLOCKD * xd = & x -> e_mbd ; <S2SV_StartBug> VP9_COMMON * cm = & cpi -> common ; <S2SV_EndBug> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; <S2SV_EndBug> int bestsme = INT_MAX ; <S2SV_StartBug> int further_steps , step_param ; <S2SV_EndBug> int sadpb = x -> sadperbit16 ; MV mvp_full ; int ref = mbmi -> ref_frame [ 0 ] ; <S2SV_StartBug> MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; <S2SV_StartBug> int tmp_row_max = x -> mv_row_max ; <S2SV_EndBug> const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ; MV pred_mv [ 3 ] ; <S2SV_StartBug> pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; <S2SV_EndBug> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) backup_yv12 [ i ] = xd -> plane [ i ] . pre [ 0 ] ; vp9_setup_pre_planes ( xd , 0 , scaled_ref_frame , mi_row , mi_col , NULL ) ; } vp9_set_mv_search_range ( x , & ref_mv ) ; <S2SV_StartBug> if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) { <S2SV_EndBug> <S2SV_StartBug> step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) + <S2SV_EndBug> <S2SV_StartBug> cpi -> mv_step_param ) >> 1 ; <S2SV_EndBug> } else { step_param = cpi -> mv_step_param ; } <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 && <S2SV_EndBug> cpi -> common . show_frame ) { <S2SV_StartBug> int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) , <S2SV_EndBug> b_width_log2 ( bsize ) ) ) ; step_param = MAX ( step_param , boffset ) ; } if ( cpi -> sf . adaptive_motion_search ) { int bwl = b_width_log2_lookup [ bsize ] ; <S2SV_StartBug> int bhl = b_height_log2_lookup [ bsize ] ; <S2SV_EndBug> int i ; int tlevel = x -> pred_mv_sad [ ref ] >> ( bwl + bhl + 4 ) ; if ( tlevel < 5 ) step_param += 2 ; <S2SV_StartBug> for ( i = LAST_FRAME ; i <= ALTREF_FRAME && cpi -> common . show_frame ; ++ i ) { <S2SV_EndBug> if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) { <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = 0 ; <S2SV_EndBug> tmp_mv -> as_int = INVALID_MV ; if ( scaled_ref_frame ) { int i ; <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) <S2SV_EndBug> xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } <S2SV_StartBug> return ; <S2SV_EndBug> } } } mvp_full = pred_mv [ x -> mv_best_ref_index [ ref ] ] ; mvp_full . col >>= 3 ; mvp_full . row >>= 3 ; <S2SV_StartBug> further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; <S2SV_EndBug> if ( cpi -> sf . search_method == FAST_DIAMOND ) { bestsme = vp9_fast_dia_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) <S2SV_StartBug> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , <S2SV_EndBug> <S2SV_StartBug> & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . search_method == FAST_HEX ) { <S2SV_EndBug> bestsme = vp9_fast_hex_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_StartBug> } else if ( cpi -> sf . search_method == HEX ) { <S2SV_EndBug> bestsme = vp9_hex_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == SQUARE ) { bestsme = vp9_square_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == BIGDIA ) { bestsme = vp9_bigdia_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else { bestsme = vp9_full_pixel_diamond ( cpi , x , & mvp_full , step_param , sadpb , further_steps , 1 , & cpi -> fn_ptr [ bsize ] , & ref_mv , & tmp_mv -> as_mv ) ; } x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . subpel_force_stop , cpi -> sf . subpel_iters_per_step , x -> nmvjointcost , x -> mvcost , <S2SV_StartBug> & dis , & x -> pred_sse [ ref ] ) ; <S2SV_EndBug> } * rate_mv = vp9_mv_bit_cost ( & tmp_mv -> as_mv , & ref_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ; <S2SV_EndBug> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } }
","<S2SV_ModStart> * x , <S2SV_ModEnd> BLOCK_SIZE bsize , <S2SV_ModStart> -> e_mbd ; const <S2SV_ModStart> { { 0 , 0 <S2SV_ModStart> INT_MAX ; int <S2SV_ModEnd> step_param ; int <S2SV_ModStart> MV ref_mv = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> x -> mv_row_max ; int cost_list [ 5 ] <S2SV_ModStart> 0 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> 1 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> [ ref ] <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> sf . mv . auto_mv_step_size && cm -> <S2SV_ModEnd> show_frame ) { <S2SV_ModStart> ( vp9_init_search_range ( <S2SV_ModEnd> x -> max_mv_context <S2SV_ModStart> -> mv_step_param ) / 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> bsize < BLOCK_64X64 <S2SV_ModEnd> ) { int <S2SV_ModStart> 2 * ( b_width_log2_lookup [ BLOCK_64X64 ] <S2SV_ModEnd> - MIN ( <S2SV_ModStart> - MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ) ) ; <S2SV_ModStart> [ bsize ] <S2SV_ModEnd> ; int tlevel <S2SV_ModStart> += 2 ; if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { int i ; <S2SV_ModStart> <= ALTREF_FRAME && cm -> <S2SV_ModEnd> show_frame ; ++ <S2SV_ModStart> ref ] . row = 0 ; x -> pred_mv [ ref ] . col <S2SV_ModEnd> = 0 ; <S2SV_ModStart> < MAX_MB_PLANE ; ++ i <S2SV_ModEnd> ) xd -> <S2SV_ModStart> } return ; } <S2SV_ModStart> >>= 3 ; bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max <S2SV_ModEnd> ; if ( <S2SV_ModStart> < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step <S2SV_ModEnd> ( x , <S2SV_ModStart> & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , <S2SV_ModStart> bsize ] , <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> -> sf . mv . subpel_force_stop , <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis <S2SV_ModEnd> , & x <S2SV_ModStart> [ ref ] , NULL , 0 , 0 <S2SV_ModStart> sf . adaptive_motion_search <S2SV_ModEnd> ) x -> <S2SV_ModStart> [ ref ] <S2SV_ModEnd> = tmp_mv -> <S2SV_ModStart> = tmp_mv -> as_mv <S2SV_ModEnd> ; if (
",CWE-119
833,"CWE-918 static int daemon_msg_open_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen , char * source , size_t sourcelen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; pcap_t * fp ; int nread ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; struct rpcap_openreply * openreply ; if ( plen > sourcelen - 1 ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long"" ) ; goto error ; } nread = sock_recv ( pars -> sockctrl , source , plen , SOCK_RECEIVEALL_YES | SOCK_EOF_IS_ERROR , errbuf , PCAP_ERRBUF_SIZE ) ; if ( nread == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Read<S2SV_blank>from<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } source [ nread ] = '\\0' ; plen -= nread ; <S2SV_StartBug> if ( ( fp = pcap_open_live ( source , <S2SV_EndBug> 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_OPEN_REPLY , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply = ( struct rpcap_openreply * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_openreply ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( openreply , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply -> linktype = htonl ( pcap_datalink ( fp ) ) ; openreply -> tzoff = 0 ; pcap_close ( fp ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; error : if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_OPEN , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } return 0 ; }
","<S2SV_ModStart> ; if ( is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device"" ) ; goto error ; } if (
",CWE-918
836,"CWE-200 static void make_response ( struct xen_blkif_ring * ring , u64 id , unsigned short op , int st ) { <S2SV_StartBug> struct blkif_response resp ; <S2SV_EndBug> unsigned long flags ; union blkif_back_rings * blk_rings ; int notify ; <S2SV_StartBug> resp . id = id ; <S2SV_EndBug> resp . operation = op ; resp . status = st ; spin_lock_irqsave ( & ring -> blk_ring_lock , flags ) ; blk_rings = & ring -> blk_rings ; switch ( ring -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_32 : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_64 : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; default : BUG ( ) ; <S2SV_StartBug> } <S2SV_EndBug> blk_rings -> common . rsp_prod_pvt ++ ; RING_PUSH_RESPONSES_AND_CHECK_NOTIFY ( & blk_rings -> common , notify ) ; spin_unlock_irqrestore ( & ring -> blk_ring_lock , flags ) ; if ( notify ) notify_remote_via_irq ( ring -> irq ) ; }
","<S2SV_ModStart> { struct blkif_response * <S2SV_ModStart> int notify ; <S2SV_ModEnd> spin_lock_irqsave ( & <S2SV_ModStart> case BLKIF_PROTOCOL_NATIVE : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> native . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_32 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> x86_32 . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_64 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> . rsp_prod_pvt ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> ) ; } resp -> id = id ; resp -> operation = op ; resp -> status = st ;
",CWE-200
837,"CWE-476 void dump_isom_sdp ( GF_ISOFile * file , char * inName , Bool is_final_name ) { const char * sdp ; u32 size , i ; FILE * dump ; if ( inName ) { char szBuf [ 1024 ] ; strcpy ( szBuf , inName ) ; if ( ! is_final_name ) { char * ext = strchr ( szBuf , '.' ) ; if ( ext ) ext [ 0 ] = 0 ; strcat ( szBuf , ""_sdp.txt"" ) ; } dump = gf_fopen ( szBuf , ""wt"" ) ; if ( ! dump ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>dumping\\n"" , szBuf ) ; return ; } } else { dump = stdout ; fprintf ( dump , ""*<S2SV_blank>File<S2SV_blank>SDP<S2SV_blank>content<S2SV_blank>*\\n\\n"" ) ; } gf_isom_sdp_get ( file , & sdp , & size ) ; <S2SV_StartBug> fprintf ( dump , ""%s"" , sdp ) ; <S2SV_EndBug> fprintf ( dump , ""\\r\\n"" ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( gf_isom_get_media_type ( file , i + 1 ) != GF_ISOM_MEDIA_HINT ) continue ; gf_isom_sdp_track_get ( file , i + 1 , & sdp , & size ) ; fprintf ( dump , ""%s"" , sdp ) ; } fprintf ( dump , ""\\n\\n"" ) ; if ( inName ) gf_fclose ( dump ) ; }
","<S2SV_ModStart> size ) ; if ( sdp && size )
",CWE-476
