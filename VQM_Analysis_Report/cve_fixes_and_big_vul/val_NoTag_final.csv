index,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,localization_target
3667,CWE-119,"bool f2fs_init_extent_tree ( struct inode * inode , struct f2fs_extent * i_ext ) { struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; struct extent_tree * et ; struct extent_node * en ; struct extent_info ei ; if ( ! f2fs_may_extent_tree ( inode ) ) { if ( i_ext && i_ext -> len ) { i_ext -> len = 0 ; return true ; } return false ; } et = __grab_extent_tree ( inode ) ; if ( ! i_ext || ! i_ext -> len ) return false ; get_extent_info ( & ei , i_ext ) ; write_lock ( & et -> lock ) ; if ( atomic_read ( & et -> node_cnt ) ) goto out ; en = __init_extent_tree ( sbi , et , & ei ) ; if ( en ) { spin_lock ( & sbi -> extent_lock ) ; list_add_tail ( & en -> list , & sbi -> extent_list ) ; spin_unlock ( & sbi -> extent_lock ) ; } out : write_unlock ( & et -> lock ) ; return false ; }
","<S2SV_ModStart> i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/dad48e73127ba10279ea33e6dbc8d3905c4d31c0,CVE-2017-18193,https://github.com/torvalds/linux/commit/dad48e73127ba10279ea33e6dbc8d3905c4d31c0,2018-02-22T15:29Z,<S2SV_StartBug> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i_ext || ! i_ext -> len ) <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug>
7005,CWE-400,"static void listdir ( unsigned int depth , int f , void * const tls_fd , const char * name ) { PureFileInfo * dir ; char * names ; PureFileInfo * s ; PureFileInfo * r ; int d ; if ( depth >= max_ls_depth || matches >= max_ls_files ) { return ; } if ( ( dir = sreaddir ( & names ) ) == NULL ) { addreply ( 226 , MSG_CANT_READ_FILE , name ) ; return ; } s = dir ; while ( s -> name_offset != ( size_t ) - 1 ) { d = 0 ; if ( FI_NAME ( s ) [ 0 ] != '.' ) { d = listfile ( s , NULL ) ; } else if ( opt_a ) { if ( FI_NAME ( s ) [ 1 ] == 0 || ( FI_NAME ( s ) [ 1 ] == '.' && FI_NAME ( s ) [ 2 ] == 0 ) ) { listfile ( s , NULL ) ; } else { d = listfile ( s , NULL ) ; } } if ( ! d ) { s -> name_offset = ( size_t ) - 1 ; } s ++ ; } outputfiles ( f , tls_fd ) ; r = dir ; while ( opt_R && r != s ) { if ( r -> name_offset != ( size_t ) - 1 && ! chdir ( FI_NAME ( r ) ) ) { char * alloca_subdir ; const size_t sizeof_subdir = PATH_MAX + 1U ; if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) { goto toomany ; } if ( SNCHECK ( snprintf ( alloca_subdir , sizeof_subdir , ""%s/%s"" , name , FI_NAME ( r ) ) , sizeof_subdir ) ) { goto nolist ; } wrstr ( f , tls_fd , ""\\r\\n\\r\\n"" ) ; wrstr ( f , tls_fd , alloca_subdir ) ; wrstr ( f , tls_fd , "":\\r\\n\\r\\n"" ) ; listdir ( depth + 1U , f , tls_fd , alloca_subdir ) ; nolist : ALLOCA_FREE ( alloca_subdir ) ; if ( matches >= max_ls_files ) { goto toomany ; } if ( chdir ( "".."" ) ) { if ( chdir ( wd ) || chdir ( name ) ) { die ( 421 , LOG_ERR , ""chdir:<S2SV_blank>%s"" , strerror ( errno ) ) ; } } } r ++ ; } toomany : free ( names ) ; free ( dir ) ; names = NULL ; }
","<S2SV_ModStart> PureFileInfo * r ; char * alloca_subdir ; size_t sizeof_subdir <S2SV_ModStart> = dir ; sizeof_subdir = PATH_MAX + 1U ; if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) { goto toomany ; } <S2SV_ModStart> ) ) { <S2SV_ModEnd> if ( SNCHECK <S2SV_ModStart> ; nolist : <S2SV_ModEnd> if ( matches <S2SV_ModStart> } toomany : ALLOCA_FREE ( alloca_subdir ) ;
",jedisct1@pure-ftpd/aea56f4bcb9948d456f3fae4d044fd3fa2e19706,CVE-2019-20176,https://github.com/jedisct1/pure-ftpd/commit/aea56f4bcb9948d456f3fae4d044fd3fa2e19706,2019-12-31T15:15Z,<S2SV_StartBug> PureFileInfo * r ; <S2SV_EndBug> <S2SV_StartBug> while ( opt_R && r != s ) { <S2SV_EndBug> <S2SV_StartBug> char * alloca_subdir ; <S2SV_EndBug> <S2SV_StartBug> ALLOCA_FREE ( alloca_subdir ) ; <S2SV_EndBug> <S2SV_StartBug> free ( names ) ; <S2SV_EndBug>
8415,CWE-125,"int mutt_seqset_iterator_next ( struct SeqsetIterator * iter , unsigned int * next ) { if ( ! iter || ! next ) return - 1 ; if ( iter -> in_range ) { if ( ( iter -> down && ( iter -> range_cur == ( iter -> range_end - 1 ) ) ) || ( ! iter -> down && ( iter -> range_cur == ( iter -> range_end + 1 ) ) ) ) { iter -> in_range = 0 ; } } if ( ! iter -> in_range ) { iter -> substr_cur = iter -> substr_end ; if ( iter -> substr_cur == iter -> eostr ) return 1 ; while ( ! * ( iter -> substr_cur ) ) iter -> substr_cur ++ ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ) = '\\0' ; char * range_sep = strchr ( iter -> substr_cur , ':' ) ; if ( range_sep ) * range_sep ++ = '\\0' ; if ( mutt_str_atoui ( iter -> substr_cur , & iter -> range_cur ) != 0 ) return - 1 ; if ( range_sep ) { if ( mutt_str_atoui ( range_sep , & iter -> range_end ) != 0 ) return - 1 ; } else iter -> range_end = iter -> range_cur ; iter -> down = ( iter -> range_end < iter -> range_cur ) ; iter -> in_range = 1 ; } * next = iter -> range_cur ; if ( iter -> down ) iter -> range_cur -- ; else iter -> range_cur ++ ; return 0 ; }
","<S2SV_ModStart> return 1 ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ++ <S2SV_ModEnd> ) = '\\0'
",neomutt@neomutt/fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc,CVE-2021-32055,https://github.com/neomutt/neomutt/commit/fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc,2021-05-05T16:15Z,<S2SV_StartBug> while ( ! * ( iter -> substr_cur ) ) <S2SV_EndBug>
401,CWE-200,"static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { ValidateColormapValue ( image , * p & mask , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { ValidateColormapValue ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;
",ImageMagick@ImageMagick/1c358ffe0049f768dd49a8a889c1cbf99ac9849b,CVE-2017-9098,https://github.com/ImageMagick/ImageMagick/commit/1c358ffe0049f768dd49a8a889c1cbf99ac9849b,2017-05-19T19:29Z,<S2SV_StartBug> if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) <S2SV_EndBug>
2422,CWE-119,"static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ; ncomponents = bytestream2_get_be16u ( & s -> g ) ; if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n"" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components"" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n"" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; if ( ! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>separation<S2SV_blank>%d/%d\\n"" , s -> cdx [ i ] , s -> cdy [ i ] ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>"" ""components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>"" ""cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n"" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } s -> avctx -> bits_per_raw_sample = s -> precision ; return 0 ; }
","<S2SV_ModStart> g ) ; if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ; return AVERROR_PATCHWELCOME ; }
",FFmpeg@FFmpeg/780669ef7c23c00836a24921fcc6b03be2b8ca4a,CVE-2013-7012,https://github.com/FFmpeg/FFmpeg/commit/780669ef7c23c00836a24921fcc6b03be2b8ca4a,2013-12-09T16:36Z,<S2SV_StartBug> ncomponents = bytestream2_get_be16u ( & s -> g ) ; <S2SV_EndBug>
3305,CWE-119,"static int wdm_post_reset ( struct usb_interface * intf ) { struct wdm_device * desc = wdm_find_device ( intf ) ; int rv ; clear_bit ( WDM_RESETTING , & desc -> flags ) ; rv = recover_from_urb_loss ( desc ) ; mutex_unlock ( & desc -> wlock ) ; mutex_unlock ( & desc -> rlock ) ; return 0 ; }
","<S2SV_ModStart> ; int rv ; clear_bit ( WDM_OVERFLOW , & desc -> flags )
",torvalds@linux/c0f5ecee4e741667b2493c742b60b6218d40b3aa,CVE-2013-1860,https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa,2013-03-22T11:59Z,<S2SV_StartBug> int rv ; <S2SV_EndBug>
65,CWE-362,"static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }
","<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock
",torvalds@linux/04f5866e41fb70690e28397487d8bd8eea7d712a,CVE-2019-11599,https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a,2019-04-29T18:29Z,<S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug>
4941,CWE-617,"static void pci_lintr_route ( struct pci_vdev * dev ) { struct businfo * bi ; struct intxinfo * ii ; if ( dev -> lintr . pin == 0 ) return ; bi = pci_businfo [ dev -> bus ] ; assert ( bi != NULL ) ; ii = & bi -> slotinfo [ dev -> slot ] . si_intpins [ dev -> lintr . pin - 1 ] ; if ( ii -> ii_ioapic_irq == 0 ) ii -> ii_ioapic_irq = ioapic_pci_alloc_irq ( dev ) ; assert ( ii -> ii_ioapic_irq > 0 ) ; if ( ii -> ii_pirq_pin == 0 ) ii -> ii_pirq_pin = pirq_alloc_pin ( dev ) ; assert ( ii -> ii_pirq_pin > 0 ) ; dev -> lintr . ioapic_irq = ii -> ii_ioapic_irq ; dev -> lintr . pirq_pin = ii -> ii_pirq_pin ; pci_set_cfgdata8 ( dev , PCIR_INTLINE , pirq_irq ( ii -> ii_pirq_pin ) ) ; }
","<S2SV_ModStart> bus ] ; if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> ii = & <S2SV_ModStart> dev ) ; <S2SV_ModEnd> if ( ii <S2SV_ModStart> pirq_alloc_pin ( dev <S2SV_ModEnd> ) ; dev
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,<S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ii -> ii_ioapic_irq > 0 ) ; <S2SV_EndBug> <S2SV_StartBug> ii -> ii_pirq_pin = pirq_alloc_pin ( dev ) ; <S2SV_EndBug>
4665,CWE-787,"int pdf_is_pdf ( FILE * fp ) { int is_pdf ; char * header ; header = get_header ( fp ) ; if ( header && strstr ( header , ""%PDF-"" ) ) is_pdf = 1 ; else is_pdf = 0 ; free ( header ) ; return is_pdf ; }
","<S2SV_ModStart> fp ) { <S2SV_ModEnd> char * header <S2SV_ModStart> * header ; if ( ! ( <S2SV_ModStart> ( fp ) ) ) return 0 ; const char * c = <S2SV_ModEnd> strstr ( header <S2SV_ModStart> , ""%PDF-"" ) ; const int is_pdf = c && ( ( c - header + strlen ( ""%PDF-M.m"" ) ) < 1024 ) <S2SV_ModEnd> ; free (
",enferex@pdfresurrect/1b422459f07353adce2878806d5247d9e91fb397,CVE-2020-20740,https://github.com/enferex/pdfresurrect/commit/1b422459f07353adce2878806d5247d9e91fb397,2020-11-20T19:15Z,"<S2SV_StartBug> int is_pdf ; <S2SV_EndBug> <S2SV_StartBug> header = get_header ( fp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( header && strstr ( header , ""%PDF-"" ) ) <S2SV_EndBug>"
6339,CWE-772,"gpols_ret * get_pols_2_svc ( gpols_arg * arg , struct svc_req * rqstp ) { static gpols_ret ret ; char * prime_arg ; gss_buffer_desc client_name , service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gpols_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> exp ; if ( prime_arg == NULL ) prime_arg = ""*"" ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_LIST , NULL , NULL ) ) { ret . code = KADM5_AUTH_LIST ; log_unauth ( ""kadm5_get_policies"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_policies ( ( void * ) handle , arg -> exp , & ret . pols , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_policies"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug>"
4641,CWE-190,"static bcon_error_t bson_append_bcon_with_state ( bson * b , const bcon * bc , bcon_state_t start_state ) { bcon_error_t ret = BCON_OK ; bcon_state_t state = start_state ; char * key = 0 ; char * typespec = 0 ; unsigned char doc_stack [ DOC_STACK_SIZE ] ; size_t doc_stack_pointer = 0 ; size_t array_index = 0 ; unsigned int array_index_stack [ ARRAY_INDEX_STACK_SIZE ] ; size_t array_index_stack_pointer = 0 ; char array_index_buffer [ ARRAY_INDEX_BUFFER_SIZE ] ; int end_of_data ; const bcon * bcp ; for ( end_of_data = 0 , bcp = bc ; ret == BCON_OK && ! end_of_data ; bcp ++ ) { bcon bci = * bcp ; char * s = bci . s ; switch ( state ) { case State_Element : switch ( bcon_token ( s ) ) { case Token_CloseBrace : bson_append_finish_object ( b ) ; DOC_POP_STATE ; break ; case Token_End : end_of_data = 1 ; break ; default : key = s ; state = State_DocSpecValue ; break ; } break ; case State_DocSpecValue : switch ( bcon_token ( s ) ) { case Token_Typespec : typespec = s ; state = State_DocValue ; break ; case Token_OpenBrace : bson_append_start_object ( b , key ) ; DOC_PUSH_STATE ( State_Element ) ; state = State_Element ; break ; case Token_OpenBracket : bson_append_start_array ( b , key ) ; ARRAY_PUSH_RESET_INDEX_STATE ( State_Element ) ; state = State_ArraySpecValue ; break ; case Token_End : end_of_data = 1 ; break ; default : ret = bson_bcon_key_value ( b , key , typespec , bci ) ; state = State_Element ; break ; } break ; case State_DocValue : ret = bson_bcon_key_value ( b , key , typespec , bci ) ; state = State_Element ; typespec = 0 ; break ; case State_ArraySpecValue : switch ( bcon_token ( s ) ) { case Token_Typespec : typespec = s ; state = State_ArrayValue ; break ; case Token_OpenBrace : key = ARRAY_KEY_STRING ( array_index ++ ) ; bson_append_start_object ( b , key ) ; DOC_PUSH_STATE ( State_ArraySpecValue ) ; state = State_Element ; break ; case Token_OpenBracket : key = ARRAY_KEY_STRING ( array_index ++ ) ; bson_append_start_array ( b , key ) ; ARRAY_PUSH_RESET_INDEX_STATE ( State_ArraySpecValue ) ; break ; case Token_CloseBracket : bson_append_finish_array ( b ) ; ARRAY_POP_INDEX_STATE ; break ; case Token_End : end_of_data = 1 ; break ; default : key = ARRAY_KEY_STRING ( array_index ++ ) ; ret = bson_bcon_key_value ( b , key , typespec , bci ) ; break ; } break ; case State_ArrayValue : key = ARRAY_KEY_STRING ( array_index ++ ) ; ret = bson_bcon_key_value ( b , key , typespec , bci ) ; state = State_ArraySpecValue ; typespec = 0 ; break ; default : assert ( NOT_REACHED ) ; break ; } } return state == start_state ? BCON_OK : BCON_DOCUMENT_INCOMPLETE ; }
","<S2SV_ModStart> = 0 ; size_t <S2SV_ModEnd> array_index_stack [ ARRAY_INDEX_STACK_SIZE
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,<S2SV_StartBug> unsigned int array_index_stack [ ARRAY_INDEX_STACK_SIZE ] ; <S2SV_EndBug>
2226,CWE-189,"static int efx_register_netdev ( struct efx_nic * efx ) { struct net_device * net_dev = efx -> net_dev ; struct efx_channel * channel ; int rc ; net_dev -> watchdog_timeo = 5 * HZ ; net_dev -> irq = efx -> pci_dev -> irq ; net_dev -> netdev_ops = & efx_netdev_ops ; SET_ETHTOOL_OPS ( net_dev , & efx_ethtool_ops ) ; efx -> mac_op -> update_stats ( efx ) ; memset ( & efx -> mac_stats , 0 , sizeof ( efx -> mac_stats ) ) ; rtnl_lock ( ) ; rc = dev_alloc_name ( net_dev , net_dev -> name ) ; if ( rc < 0 ) goto fail_locked ; efx_update_name ( efx ) ; rc = register_netdevice ( net_dev ) ; if ( rc ) goto fail_locked ; efx_for_each_channel ( channel , efx ) { struct efx_tx_queue * tx_queue ; efx_for_each_channel_tx_queue ( tx_queue , channel ) efx_init_tx_queue_core_txq ( tx_queue ) ; } netif_carrier_off ( efx -> net_dev ) ; rtnl_unlock ( ) ; rc = device_create_file ( & efx -> pci_dev -> dev , & dev_attr_phy_type ) ; if ( rc ) { netif_err ( efx , drv , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>init<S2SV_blank>net<S2SV_blank>dev<S2SV_blank>attributes\\n"" ) ; goto fail_registered ; } return 0 ; fail_locked : rtnl_unlock ( ) ; netif_err ( efx , drv , efx -> net_dev , ""could<S2SV_blank>not<S2SV_blank>register<S2SV_blank>net<S2SV_blank>dev\\n"" ) ; return rc ; fail_registered : unregister_netdev ( net_dev ) ; return rc ; }
","<S2SV_ModStart> efx_ethtool_ops ) ; net_dev -> gso_max_segs = EFX_TSO_MAX_SEGS ;
",torvalds@linux/68cb695ccecf949d48949e72f8ce591fdaaa325c,CVE-2012-3412,https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c,2012-10-03T11:02Z,<S2SV_StartBug> efx -> mac_op -> update_stats ( efx ) ; <S2SV_EndBug>
2259,CWE-20,"static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> break ; } if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
",ImageMagick@ImageMagick/6b6bff054d569a77973f2140c0e86366e6168a6c,CVE-2018-16643,https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c,2018-09-06T22:29Z,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug>"
3239,CWE-200,"int udpv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; bool slow ; if ( addr_len ) * addr_len = sizeof ( struct sockaddr_in6 ) ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov , copied ) ; else { err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { struct sockaddr_in6 * sin6 ; sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ; } } if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; if ( noblock ) return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
","<S2SV_ModStart> ; bool slow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } * addr_len = sizeof ( * sin6 ) ;
",torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69,CVE-2013-7281,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,2014-01-08T16:55Z,<S2SV_StartBug> bool slow ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
4090,CWE-200,"static int rfcomm_get_dev_list ( void __user * arg ) { struct rfcomm_dev * dev ; struct rfcomm_dev_list_req * dl ; struct rfcomm_dev_info * di ; int n = 0 , size , err ; u16 dev_num ; BT_DBG ( """" ) ; if ( get_user ( dev_num , ( u16 __user * ) arg ) ) return - EFAULT ; if ( ! dev_num || dev_num > ( PAGE_SIZE * 4 ) / sizeof ( * di ) ) return - EINVAL ; size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ; dl = kmalloc ( size , GFP_KERNEL ) ; if ( ! dl ) return - ENOMEM ; di = dl -> dev_info ; spin_lock ( & rfcomm_dev_lock ) ; list_for_each_entry ( dev , & rfcomm_dev_list , list ) { if ( test_bit ( RFCOMM_TTY_RELEASED , & dev -> flags ) ) continue ; ( di + n ) -> id = dev -> id ; ( di + n ) -> flags = dev -> flags ; ( di + n ) -> state = dev -> dlc -> state ; ( di + n ) -> channel = dev -> channel ; bacpy ( & ( di + n ) -> src , & dev -> src ) ; bacpy ( & ( di + n ) -> dst , & dev -> dst ) ; if ( ++ n >= dev_num ) break ; } spin_unlock ( & rfcomm_dev_lock ) ; dl -> dev_num = n ; size = sizeof ( * dl ) + n * sizeof ( * di ) ; err = copy_to_user ( arg , dl , size ) ; kfree ( dl ) ; return err ? - EFAULT : 0 ; }
","<S2SV_ModStart> ; dl = kzalloc <S2SV_ModEnd> ( size ,
",torvalds@linux/f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a,CVE-2012-6545,https://github.com/torvalds/linux/commit/f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a,2013-03-15T20:55Z,"<S2SV_StartBug> dl = kmalloc ( size , GFP_KERNEL ) ; <S2SV_EndBug>"
7475,CWE-476,"VTerm * vterm_new_with_allocator ( int rows , int cols , VTermAllocatorFunctions * funcs , void * allocdata ) { VTerm * vt = ( * funcs -> malloc ) ( sizeof ( VTerm ) , allocdata ) ; vt -> allocator = funcs ; vt -> allocdata = allocdata ; vt -> rows = rows ; vt -> cols = cols ; vt -> parser . state = NORMAL ; vt -> parser . callbacks = NULL ; vt -> parser . cbdata = NULL ; vt -> parser . strbuffer_len = 500 ; vt -> parser . strbuffer_cur = 0 ; vt -> parser . strbuffer = vterm_allocator_malloc ( vt , vt -> parser . strbuffer_len ) ; vt -> outbuffer_len = 200 ; vt -> outbuffer_cur = 0 ; vt -> outbuffer = vterm_allocator_malloc ( vt , vt -> outbuffer_len ) ; return vt ; }
","<S2SV_ModStart> allocdata ) ; if ( vt == NULL ) return NULL ; <S2SV_ModStart> strbuffer_len ) ; if ( vt -> parser . strbuffer == NULL ) { vterm_allocator_free ( vt , vt ) ; return NULL ; } <S2SV_ModStart> outbuffer_len ) ; if ( vt -> outbuffer == NULL ) { vterm_allocator_free ( vt , vt -> parser . strbuffer ) ; vterm_allocator_free ( vt , vt ) ; return NULL ; }
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,"<S2SV_StartBug> vt -> allocator = funcs ; <S2SV_EndBug> <S2SV_StartBug> vt -> outbuffer_len = 200 ; <S2SV_EndBug> <S2SV_StartBug> vt -> outbuffer = vterm_allocator_malloc ( vt , vt -> outbuffer_len ) ; <S2SV_EndBug>"
3751,CWE-20,"static int rose_parse_ccitt ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char l , n = 0 ; char callsign [ 11 ] ; do { switch ( * p & 0xC0 ) { case 0x00 : p += 2 ; n += 2 ; len -= 2 ; break ; case 0x40 : p += 3 ; n += 3 ; len -= 3 ; break ; case 0x80 : p += 4 ; n += 4 ; len -= 4 ; break ; case 0xC0 : l = p [ 1 ] ; if ( l < 10 || l > 20 ) return - 1 ; if ( * p == FAC_CCITT_DEST_NSAP ) { memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> source_call , callsign ) ; } if ( * p == FAC_CCITT_SRC_NSAP ) { memcpy ( & facilities -> dest_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> dest_call , callsign ) ; } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }
","<S2SV_ModStart> case 0x00 : if ( len < 2 ) return - 1 ; <S2SV_ModStart> case 0x40 : if ( len < 3 ) return - 1 ; <S2SV_ModStart> case 0x80 : if ( len < 4 ) return - 1 ; <S2SV_ModStart> case 0xC0 : if ( len < 2 ) return - 1 ;
",torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,CVE-2011-4914,https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,2012-06-21T23:55Z,<S2SV_StartBug> p += 2 ; <S2SV_EndBug> <S2SV_StartBug> p += 3 ; <S2SV_EndBug> <S2SV_StartBug> p += 4 ; <S2SV_EndBug> <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug>
1461,CWE-119,"int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) { # if HAVE_NEON int64_t store_reg [ 8 ] ; # endif VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct vpx_usec_timer ticktimer ; struct vpx_usec_timer cmptimer ; YV12_BUFFER_CONFIG * force_src_buffer = NULL ; if ( ! cpi ) return - 1 ; cm = & cpi -> common ; if ( setjmp ( cpi -> common . error . jmp ) ) { cpi -> common . error . setjmp = 0 ; return VPX_CODEC_CORRUPT_FRAME ; } cpi -> common . error . setjmp = 1 ; # if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & cmptimer ) ; cpi -> source = NULL ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) { if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) { cpi -> alt_ref_source = cpi -> source ; if ( cpi -> oxcf . arnr_max_frames > 0 ) { vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ; force_src_buffer = & cpi -> alt_ref_buffer ; } cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; cm -> refresh_alt_ref_frame = 1 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; cm -> show_frame = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> is_src_frame_alt_ref = 0 ; } } # endif if ( ! cpi -> source ) { if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ; } if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) { cm -> show_frame = 1 ; cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ; if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ; } } if ( cpi -> source ) { cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; cpi -> un_scaled_source = cpi -> Source ; * time_stamp = cpi -> source -> ts_start ; * time_end = cpi -> source -> ts_end ; * frame_flags = cpi -> source -> flags ; if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) { cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; } } else { * size = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) { vp8_end_first_pass ( cpi ) ; cpi -> twopass . first_pass_done = 1 ; } # endif # if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return - 1 ; } if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) { cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; } if ( cm -> show_frame ) { int64_t this_duration ; int step = 0 ; if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) { this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; step = 1 ; } else { int64_t last_duration ; this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ; if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * 10 / last_duration ) ) ; } if ( this_duration ) { if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ; else { double avg_duration , interval ; interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ; if ( interval > 10000000.0 ) interval = 10000000 ; avg_duration = 10000000.0 / cpi -> ref_framerate ; avg_duration *= ( interval - avg_duration + this_duration ) ; avg_duration /= interval ; cpi -> ref_framerate = 10000000.0 / avg_duration ; } if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ; for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; } cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; } if ( cpi -> oxcf . number_of_layers > 1 ) { int layer ; update_layer_contexts ( cpi ) ; layer = cpi -> oxcf . layer_id [ cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ; restore_layer_context ( cpi , layer ) ; vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; } if ( cpi -> compressor_speed == 2 ) { vpx_usec_timer_start ( & tsctimer ) ; vpx_usec_timer_start ( & ticktimer ) ; } cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int i ; const int num_part = ( 1 << cm -> multi_token_partition ) ; const unsigned long dest_size = dest_end - dest ; const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; unsigned char * dp = dest ; cpi -> partition_d [ 0 ] = dp ; dp += dest_size / 10 ; cpi -> partition_d_end [ 0 ] = dp ; for ( i = 0 ; i < num_part ; i ++ ) { cpi -> partition_d [ i + 1 ] = dp ; dp += tok_part_buff_size ; cpi -> partition_d_end [ i + 1 ] = dp ; } } # endif * size = 0 ; vp8_clear_system_state ( ) ; cm -> frame_type = INTER_FRAME ; cm -> frame_flags = * frame_flags ; # if 0 if ( cm -> refresh_alt_ref_frame ) { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 0 ; } else { cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; } # endif { int i = 0 ; for ( ; i < NUM_YV12_BUFFERS ; i ++ ) { if ( ! cm -> yv12_fb [ i ] . flags ) { cm -> new_fb_idx = i ; break ; } } assert ( i < NUM_YV12_BUFFERS ) ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { Pass1Encode ( cpi , size , dest , frame_flags ) ; } else if ( cpi -> pass == 2 ) { Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; } else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; if ( cpi -> compressor_speed == 2 ) { unsigned int duration , duration2 ; vpx_usec_timer_mark ( & tsctimer ) ; vpx_usec_timer_mark ( & ticktimer ) ; duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ; else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; } if ( duration2 ) { { if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ; else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; } } } if ( cm -> refresh_entropy_probs == 0 ) { vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ; } if ( cm -> refresh_alt_ref_frame ) vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ; if ( cm -> refresh_golden_frame ) vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ; if ( cm -> refresh_last_frame ) vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ; if ( * size > 0 ) { cpi -> droppable = ! frame_is_reference ( cpi ) ; cm -> refresh_entropy_probs = 1 ; cm -> refresh_alt_ref_frame = 0 ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> frame_type = INTER_FRAME ; } if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ; vpx_usec_timer_mark ( & cmptimer ) ; cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) { generate_psnr_packet ( cpi ) ; } # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { cpi -> bytes += * size ; if ( cm -> show_frame ) { cpi -> common . show_frame_mi = cpi -> common . mi ; cpi -> count ++ ; if ( cpi -> b_calculate_psnr ) { uint64_t ye , ue , ve ; double frame_psnr ; YV12_BUFFER_CONFIG * orig = cpi -> Source ; YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ; int y_samples = orig -> y_height * orig -> y_width ; int uv_samples = orig -> uv_height * orig -> uv_width ; int t_samples = y_samples + 2 * uv_samples ; double sq_error , sq_error2 ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ; ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error = ( double ) ( ye + ue + ve ) ; frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error += sq_error ; cpi -> total += frame_psnr ; # if CONFIG_POSTPROC { YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ; double frame_psnr2 , frame_ssim2 = 0 ; double weight = 0 ; vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; vp8_clear_system_state ( ) ; ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ; ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; sq_error2 = ( double ) ( ye + ue + ve ) ; frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; cpi -> total_sq_error2 += sq_error2 ; cpi -> totalp += frame_psnr2 ; frame_ssim2 = vp8_calc_ssim ( cpi -> Source , & cm -> post_proc_buffer , 1 , & weight ) ; cpi -> summed_quality += frame_ssim2 * weight ; cpi -> summed_weights += weight ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { cpi -> frames_in_layer [ i ] ++ ; cpi -> bytes_in_layer [ i ] += * size ; cpi -> sum_psnr [ i ] += frame_psnr ; cpi -> sum_psnr_p [ i ] += frame_psnr2 ; cpi -> total_error2 [ i ] += sq_error ; cpi -> total_error2_p [ i ] += sq_error2 ; cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; cpi -> sum_weights [ i ] += weight ; } } } # endif } if ( cpi -> b_calculate_ssimg ) { double y , u , v , frame_all ; frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show , & y , & u , & v ) ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer ; i < cpi -> oxcf . number_of_layers ; i ++ ) { if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ; cpi -> total_ssimg_y_in_layer [ i ] += y ; cpi -> total_ssimg_u_in_layer [ i ] += u ; cpi -> total_ssimg_v_in_layer [ i ] += v ; cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; } } else { cpi -> total_ssimg_y += y ; cpi -> total_ssimg_u += u ; cpi -> total_ssimg_v += v ; cpi -> total_ssimg_all += frame_all ; } } } } # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) { skiptruecount += cpi -> skip_true_count ; skipfalsecount += cpi -> skip_false_count ; } # endif # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n"" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , ""skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n"" , cpi -> skip_true_count , * size ) ; fclose ( f ) ; } # endif # endif # if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif cpi -> common . error . setjmp = 0 ; return 0 ; }
","<S2SV_ModStart> flush ) { <S2SV_ModEnd> VP8_COMMON * cm <S2SV_ModStart> = 0 ; vp8_clear_system_state ( ) ; <S2SV_ModStart> = 1 ; <S2SV_ModEnd> vpx_usec_timer_start ( & <S2SV_ModStart> } # endif <S2SV_ModEnd> return - 1 <S2SV_ModStart> avg_duration ; } # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_total_resolutions > 1 ) { LOWER_RES_FRAME_INFO * low_res_frame_info = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ; if ( cpi -> oxcf . mr_encoder_id ) { cpi -> ref_framerate = low_res_frame_info -> low_res_framerate ; } else { low_res_frame_info -> low_res_framerate = cpi -> ref_framerate ; } } # endif <S2SV_ModStart> oxcf . number_of_layers && i < VPX_TS_MAX_LAYERS ; ++ i <S2SV_ModEnd> ) { LAYER_CONTEXT <S2SV_ModStart> cpi ) ; if ( cpi -> temporal_layer_id >= 0 ) { layer = cpi -> temporal_layer_id ; } else { <S2SV_ModStart> periodicity ] ; } <S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & cm <S2SV_ModStart> -> refresh_alt_ref_frame ) memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> -> refresh_golden_frame ) memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> -> refresh_last_frame ) memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> . frame_to_show ; unsigned int y_width = cpi -> common . Width ; unsigned int y_height = cpi -> common . Height ; unsigned int uv_width = ( y_width + 1 ) / 2 ; unsigned int uv_height = ( y_height + 1 ) / 2 ; <S2SV_ModStart> int y_samples = y_height * <S2SV_ModEnd> y_width ; int <S2SV_ModStart> int uv_samples = uv_height * <S2SV_ModEnd> uv_width ; int <S2SV_ModStart> ; double sq_error <S2SV_ModEnd> ; ye = <S2SV_ModStart> -> y_stride , y_width , y_height ) ; ue = calc_plane_error ( orig -> u_buffer <S2SV_ModEnd> , orig -> <S2SV_ModStart> , orig -> uv_stride , recon -> u_buffer , recon -> uv_stride , uv_width , uv_height ) ; ve <S2SV_ModEnd> = calc_plane_error ( <S2SV_ModStart> ( orig -> v_buffer <S2SV_ModEnd> , orig -> <S2SV_ModStart> , recon -> v_buffer <S2SV_ModEnd> , recon -> <S2SV_ModStart> -> uv_stride , uv_width , <S2SV_ModEnd> uv_height ) ; <S2SV_ModStart> post_proc_buffer ; double sq_error2 ; double <S2SV_ModStart> -> y_stride , y_width , y_height ) ; ue = calc_plane_error ( orig -> u_buffer <S2SV_ModEnd> , orig -> <S2SV_ModStart> , orig -> uv_stride , pp -> u_buffer , pp -> uv_stride , uv_width , uv_height ) ; ve <S2SV_ModEnd> = calc_plane_error ( <S2SV_ModStart> ( orig -> v_buffer <S2SV_ModEnd> , orig -> <S2SV_ModStart> , pp -> v_buffer <S2SV_ModEnd> , pp -> <S2SV_ModStart> -> uv_stride , uv_width , <S2SV_ModEnd> uv_height ) ; <S2SV_ModStart> ; frame_ssim2 = vpx_calc_ssim <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> cm -> post_proc_buffer <S2SV_ModEnd> , & weight <S2SV_ModStart> ; frame_all = vpx_calc_ssimg <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> endif # endif <S2SV_ModEnd> cpi -> common
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_CORRUPT_FRAME ; <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . number_of_layers > 1 ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> layer = cpi -> oxcf . layer_id [ <S2SV_EndBug> <S2SV_StartBug> cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> int y_samples = orig -> y_height * orig -> y_width ; <S2SV_EndBug> <S2SV_StartBug> int uv_samples = orig -> uv_height * orig -> uv_width ; <S2SV_EndBug> <S2SV_StartBug> double sq_error , sq_error2 ; <S2SV_EndBug> <S2SV_StartBug> recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ; <S2SV_EndBug> <S2SV_StartBug> ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , <S2SV_EndBug> <S2SV_StartBug> recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; <S2SV_EndBug> <S2SV_StartBug> double frame_psnr2 , frame_ssim2 = 0 ; <S2SV_EndBug> <S2SV_StartBug> pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ; <S2SV_EndBug> <S2SV_StartBug> ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , <S2SV_EndBug> <S2SV_StartBug> pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; <S2SV_EndBug> <S2SV_StartBug> frame_ssim2 = vp8_calc_ssim ( cpi -> Source , <S2SV_EndBug> <S2SV_StartBug> & cm -> post_proc_buffer , 1 , & weight ) ; <S2SV_EndBug> <S2SV_StartBug> frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show , <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug>"
7180,CWE-552,"static ssize_t _hostsock_readv ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( oe_syscall_recvv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret > 0 ) { if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) ; } done : if ( buf ) oe_free ( buf ) ; return ret ; }
","<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ( ret > ( ssize_t ) ( data_size ) ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret >
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,"<S2SV_StartBug> if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret > 0 ) <S2SV_EndBug>"
905,CWE-119,"static int hns_gmac_get_sset_count ( int stringset ) { if ( stringset == ETH_SS_STATS ) return ARRAY_SIZE ( g_gmac_stats_string ) ; return 0 ; }
","<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
",torvalds@linux/412b65d15a7f8a93794653968308fc100f2aa87c,CVE-2017-18222,https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c,2018-03-08T14:29Z,<S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug>
702,CWE-000,"static void sas_eh_finish_cmd ( struct scsi_cmnd * cmd ) { struct sas_ha_struct * sas_ha = SHOST_TO_SAS_HA ( cmd -> device -> host ) ; struct sas_task * task = TO_SAS_TASK ( cmd ) ; sas_end_task ( cmd , task ) ; scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; }
","<S2SV_ModStart> ) ; struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> task ) ; if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; }
",torvalds@linux/318aaf34f1179b39fa9c30fa0f3288b645beee39,CVE-2018-10021,https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39,2018-04-11T17:29Z,"<S2SV_StartBug> struct sas_task * task = TO_SAS_TASK ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; <S2SV_EndBug>"
3133,CWE-125,"int SMB2_negotiate ( const unsigned int xid , struct cifs_ses * ses ) { struct smb_rqst rqst ; struct smb2_negotiate_req * req ; struct smb2_negotiate_rsp * rsp ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; int rc = 0 ; int resp_buftype ; struct TCP_Server_Info * server = ses -> server ; int blob_offset , blob_length ; char * security_blob ; int flags = CIFS_NEG_OP ; unsigned int total_len ; cifs_dbg ( FYI , ""Negotiate<S2SV_blank>protocol\\n"" ) ; if ( ! server ) { WARN ( 1 , ""%s:<S2SV_blank>server<S2SV_blank>is<S2SV_blank>NULL!\\n"" , __func__ ) ; return - EIO ; } rc = smb2_plain_req_init ( SMB2_NEGOTIATE , NULL , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; req -> sync_hdr . SessionId = 0 ; memset ( server -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; memset ( ses -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 2 ) ; total_len += 4 ; } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB21_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 2 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> Dialects [ 3 ] = cpu_to_le16 ( SMB311_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 4 ) ; total_len += 8 ; } else { req -> Dialects [ 0 ] = cpu_to_le16 ( ses -> server -> vals -> protocol_id ) ; req -> DialectCount = cpu_to_le16 ( 1 ) ; total_len += 2 ; } if ( ses -> sign ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_REQUIRED ) ; else if ( global_secflags & CIFSSEC_MAY_SIGN ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_ENABLED ) ; else req -> SecurityMode = 0 ; req -> Capabilities = cpu_to_le32 ( ses -> server -> vals -> req_capabilities ) ; if ( ses -> server -> vals -> protocol_id == SMB20_PROT_ID ) memset ( req -> ClientGUID , 0 , SMB2_CLIENT_GUID_SIZE ) ; else { memcpy ( req -> ClientGUID , server -> client_guid , SMB2_CLIENT_GUID_SIZE ) ; if ( ( ses -> server -> vals -> protocol_id == SMB311_PROT_ID ) || ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) ) assemble_neg_contexts ( req , & total_len ) ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; cifs_small_buf_release ( req ) ; rsp = ( struct smb2_negotiate_rsp * ) rsp_iov . iov_base ; if ( rc == - EOPNOTSUPP ) { cifs_dbg ( VFS , ""Dialect<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server.<S2SV_blank>Consider<S2SV_blank>"" ""specifying<S2SV_blank>vers=1.0<S2SV_blank>or<S2SV_blank>vers=2.0<S2SV_blank>on<S2SV_blank>mount<S2SV_blank>for<S2SV_blank>accessing"" ""<S2SV_blank>older<S2SV_blank>servers\\n"" ) ; goto neg_exit ; } else if ( rc != 0 ) goto neg_exit ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2.1<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { ses -> server -> ops = & smb21_operations ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) ses -> server -> ops = & smb311_operations ; } else if ( le16_to_cpu ( rsp -> DialectRevision ) != ses -> server -> vals -> protocol_id ) { cifs_dbg ( VFS , ""Illegal<S2SV_blank>0x%x<S2SV_blank>dialect<S2SV_blank>returned:<S2SV_blank>not<S2SV_blank>requested\\n"" , le16_to_cpu ( rsp -> DialectRevision ) ) ; return - EIO ; } cifs_dbg ( FYI , ""mode<S2SV_blank>0x%x\\n"" , rsp -> SecurityMode ) ; if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb2.0<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb2.1<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB30_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.0<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB302_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.02<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.1.1<S2SV_blank>dialect\\n"" ) ; else { cifs_dbg ( VFS , ""Illegal<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>by<S2SV_blank>server<S2SV_blank>0x%x\\n"" , le16_to_cpu ( rsp -> DialectRevision ) ) ; rc = - EIO ; goto neg_exit ; } server -> dialect = le16_to_cpu ( rsp -> DialectRevision ) ; memcpy ( server -> preauth_sha_hash , ses -> preauth_sha_hash , SMB2_PREAUTH_HASH_SIZE ) ; server -> negflavor = CIFS_NEGFLAVOR_EXTENDED ; server -> maxBuf = min_t ( unsigned int , le32_to_cpu ( rsp -> MaxTransactSize ) , SMB2_MAX_BUFFER_SIZE ) ; server -> max_read = le32_to_cpu ( rsp -> MaxReadSize ) ; server -> max_write = le32_to_cpu ( rsp -> MaxWriteSize ) ; server -> sec_mode = le16_to_cpu ( rsp -> SecurityMode ) ; if ( ( server -> sec_mode & SMB2_SEC_MODE_FLAGS_ALL ) != server -> sec_mode ) cifs_dbg ( FYI , ""Server<S2SV_blank>returned<S2SV_blank>unexpected<S2SV_blank>security<S2SV_blank>mode<S2SV_blank>0x%x\\n"" , server -> sec_mode ) ; server -> capabilities = le32_to_cpu ( rsp -> Capabilities ) ; server -> capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES ; security_blob = smb2_get_data_area_len ( & blob_offset , & blob_length , ( struct smb2_sync_hdr * ) rsp ) ; if ( blob_length == 0 ) { cifs_dbg ( FYI , ""missing<S2SV_blank>security<S2SV_blank>blob<S2SV_blank>on<S2SV_blank>negprot\\n"" ) ; server -> sec_ntlmssp = true ; } rc = cifs_enable_signing ( server , ses -> sign ) ; if ( rc ) goto neg_exit ; if ( blob_length ) { rc = decode_negTokenInit ( security_blob , blob_length , server ) ; if ( rc == 1 ) rc = 0 ; else if ( rc == 0 ) rc = - EIO ; } if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) { if ( rsp -> NegotiateContextCount ) rc = smb311_decode_neg_context ( rsp , server , rsp_iov . iov_len ) ; else cifs_dbg ( VFS , ""Missing<S2SV_blank>expected<S2SV_blank>negotiate<S2SV_blank>contexts\\n"" ) ; } neg_exit : free_rsp_buf ( resp_buftype , rsp ) ; return rc ; }
","<S2SV_ModStart> & smb21_operations ; ses -> server -> vals = & smb21_values ; <S2SV_ModStart> SMB311_PROT_ID ) ) { <S2SV_ModStart> & smb311_operations ; ses -> server -> vals = & smb311_values ; }
",torvalds@linux/b57a55e2200ede754e4dc9cce4ba9402544b9365,CVE-2019-15918,https://github.com/torvalds/linux/commit/b57a55e2200ede754e4dc9cce4ba9402544b9365,2019-09-04T19:15Z,<S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug>
3223,CWE-254,"int bzrtp_packetParser ( bzrtpContext_t * zrtpContext , bzrtpChannelContext_t * zrtpChannelContext , const uint8_t * input , uint16_t inputLength , bzrtpPacket_t * zrtpPacket ) { int i ; uint8_t * messageContent = ( uint8_t * ) ( input + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH ) ; switch ( zrtpPacket -> messageType ) { case MSGTYPE_HELLO : { bzrtpHelloMessage_t * messageData ; messageData = ( bzrtpHelloMessage_t * ) malloc ( sizeof ( bzrtpHelloMessage_t ) ) ; memcpy ( messageData -> version , messageContent , 4 ) ; messageContent += 4 ; memcpy ( messageData -> clientIdentifier , messageContent , 16 ) ; messageContent += 16 ; memcpy ( messageData -> H3 , messageContent , 32 ) ; messageContent += 32 ; memcpy ( messageData -> ZID , messageContent , 12 ) ; messageContent += 12 ; messageData -> S = ( ( * messageContent ) >> 6 ) & 0x01 ; messageData -> M = ( ( * messageContent ) >> 5 ) & 0x01 ; messageData -> P = ( ( * messageContent ) >> 4 ) & 0x01 ; messageContent += 1 ; messageData -> hc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; messageData -> cc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; messageData -> ac = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; messageData -> kc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; messageData -> sc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; if ( zrtpPacket -> messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4 * ( ( uint16_t ) ( messageData -> hc ) + ( uint16_t ) ( messageData -> cc ) + ( uint16_t ) ( messageData -> ac ) + ( uint16_t ) ( messageData -> kc ) + ( uint16_t ) ( messageData -> sc ) ) ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } for ( i = 0 ; i < messageData -> hc ; i ++ ) { messageData -> supportedHash [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> cc ; i ++ ) { messageData -> supportedCipher [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> ac ; i ++ ) { messageData -> supportedAuthTag [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> kc ; i ++ ) { messageData -> supportedKeyAgreement [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> sc ; i ++ ) { messageData -> supportedSas [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; messageContent += 4 ; } addMandatoryCryptoTypesIfNeeded ( ZRTP_HASH_TYPE , messageData -> supportedHash , & messageData -> hc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_CIPHERBLOCK_TYPE , messageData -> supportedCipher , & messageData -> cc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_AUTHTAG_TYPE , messageData -> supportedAuthTag , & messageData -> ac ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_KEYAGREEMENT_TYPE , messageData -> supportedKeyAgreement , & messageData -> kc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_SAS_TYPE , messageData -> supportedSas , & messageData -> sc ) ; memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_HELLOACK : { if ( zrtpPacket -> messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH ) { return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } } break ; case MSGTYPE_COMMIT : { uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; uint16_t variableLength = 0 ; bzrtpCommitMessage_t * messageData ; messageData = ( bzrtpCommitMessage_t * ) malloc ( sizeof ( bzrtpCommitMessage_t ) ) ; memcpy ( messageData -> H2 , messageContent , 32 ) ; messageContent += 32 ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } memcpy ( messageData -> ZID , messageContent , 12 ) ; messageContent += 12 ; messageData -> hashAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; messageContent += 4 ; messageData -> cipherAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; messageContent += 4 ; messageData -> authTagAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; messageContent += 4 ; messageData -> keyAgreementAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; messageContent += 4 ; switch ( messageData -> keyAgreementAlgo ) { case ZRTP_KEYAGREEMENT_DH2k : case ZRTP_KEYAGREEMENT_EC25 : case ZRTP_KEYAGREEMENT_DH3k : case ZRTP_KEYAGREEMENT_EC38 : case ZRTP_KEYAGREEMENT_EC52 : variableLength = 32 ; break ; case ZRTP_KEYAGREEMENT_Prsh : variableLength = 24 ; break ; case ZRTP_KEYAGREEMENT_Mult : variableLength = 16 ; break ; default : free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } if ( zrtpPacket -> messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } messageData -> sasAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; messageContent += 4 ; if ( ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) || ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) ) { memcpy ( messageData -> nonce , messageContent , 16 ) ; messageContent += 16 ; if ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) { memcpy ( messageData -> keyID , messageContent , 8 ) ; messageContent += 8 ; } } else { memcpy ( messageData -> hvi , messageContent , 32 ) ; messageContent += 32 ; } memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_DHPART1 : case MSGTYPE_DHPART2 : { bzrtpDHPartMessage_t * messageData ; uint16_t pvLength = computeKeyAgreementPrivateValueLength ( zrtpChannelContext -> keyAgreementAlgo ) ; if ( pvLength == 0 ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } if ( zrtpPacket -> messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH + pvLength ) { return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } messageData = ( bzrtpDHPartMessage_t * ) malloc ( sizeof ( bzrtpDHPartMessage_t ) ) ; messageData -> pv = ( uint8_t * ) malloc ( pvLength * sizeof ( uint8_t ) ) ; memcpy ( messageData -> H1 , messageContent , 32 ) ; messageContent += 32 ; if ( zrtpChannelContext -> role == RESPONDER ) { uint8_t checkH2 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpCommitMessage_t * peerCommitMessageData ; if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } else { uint8_t checkH2 [ 32 ] ; uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } memcpy ( messageData -> rs1ID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> rs2ID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> auxsecretID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> pbxsecretID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> pv , messageContent , pvLength ) ; messageContent += pvLength ; memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_CONFIRM1 : case MSGTYPE_CONFIRM2 : { uint8_t * confirmMessageKey = NULL ; uint8_t * confirmMessageMacKey = NULL ; bzrtpConfirmMessage_t * messageData ; uint16_t cipherTextLength ; uint8_t computedHmac [ 8 ] ; uint8_t * confirmPlainMessageBuffer ; uint8_t * confirmPlainMessage ; if ( zrtpChannelContext -> role == RESPONDER ) { if ( ( zrtpChannelContext -> zrtpkeyi == NULL ) || ( zrtpChannelContext -> mackeyi == NULL ) ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } confirmMessageKey = zrtpChannelContext -> zrtpkeyi ; confirmMessageMacKey = zrtpChannelContext -> mackeyi ; } if ( zrtpChannelContext -> role == INITIATOR ) { if ( ( zrtpChannelContext -> zrtpkeyr == NULL ) || ( zrtpChannelContext -> mackeyr == NULL ) ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } confirmMessageKey = zrtpChannelContext -> zrtpkeyr ; confirmMessageMacKey = zrtpChannelContext -> mackeyr ; } messageData = ( bzrtpConfirmMessage_t * ) malloc ( sizeof ( bzrtpConfirmMessage_t ) ) ; memcpy ( messageData -> confirm_mac , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> CFBIV , messageContent , 16 ) ; messageContent += 16 ; cipherTextLength = zrtpPacket -> messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24 ; zrtpChannelContext -> hmacFunction ( confirmMessageMacKey , zrtpChannelContext -> hashLength , messageContent , cipherTextLength , 8 , computedHmac ) ; if ( memcmp ( computedHmac , messageData -> confirm_mac , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC ; } confirmPlainMessageBuffer = ( uint8_t * ) malloc ( cipherTextLength * sizeof ( uint8_t ) ) ; zrtpChannelContext -> cipherDecryptionFunction ( confirmMessageKey , messageData -> CFBIV , messageContent , cipherTextLength , confirmPlainMessageBuffer ) ; confirmPlainMessage = confirmPlainMessageBuffer ; memcpy ( messageData -> H0 , confirmPlainMessage , 32 ) ; confirmPlainMessage += 33 ; if ( zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) { uint8_t checkH1 [ 32 ] ; bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; if ( zrtpChannelContext -> role == RESPONDER ) { uint8_t checkH2 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpCommitMessage_t * peerCommitMessageData ; if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } else { uint8_t checkH2 [ 32 ] ; uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } } else { uint8_t checkH1 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpDHPartMessage_t * peerDHPartMessageData ; if ( zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerDHPartMessageData = ( bzrtpDHPartMessage_t * ) zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; if ( memcmp ( checkH1 , peerDHPartMessageData -> H1 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H0 , 32 , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerDHPartMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } messageData -> sig_len = ( ( uint16_t ) ( confirmPlainMessage [ 0 ] & 0x01 ) ) << 8 | ( ( ( uint16_t ) confirmPlainMessage [ 1 ] ) & 0x00FF ) ; confirmPlainMessage += 2 ; messageData -> E = ( ( * confirmPlainMessage ) & 0x08 ) >> 3 ; messageData -> V = ( ( * confirmPlainMessage ) & 0x04 ) >> 2 ; messageData -> A = ( ( * confirmPlainMessage ) & 0x02 ) >> 1 ; messageData -> D = ( * confirmPlainMessage ) & 0x01 ; confirmPlainMessage += 1 ; messageData -> cacheExpirationInterval = ( ( ( uint32_t ) confirmPlainMessage [ 0 ] ) << 24 ) | ( ( ( uint32_t ) confirmPlainMessage [ 1 ] ) << 16 ) | ( ( ( uint32_t ) confirmPlainMessage [ 2 ] ) << 8 ) | ( ( uint32_t ) confirmPlainMessage [ 3 ] ) ; confirmPlainMessage += 4 ; if ( messageData -> sig_len > 0 ) { memcpy ( messageData -> signatureBlockType , confirmPlainMessage , 4 ) ; confirmPlainMessage += 4 ; messageData -> signatureBlock = ( uint8_t * ) malloc ( 4 * ( messageData -> sig_len - 1 ) * sizeof ( uint8_t ) ) ; memcpy ( messageData -> signatureBlock , confirmPlainMessage , 4 * ( messageData -> sig_len - 1 ) ) ; } else { messageData -> signatureBlock = NULL ; } free ( confirmPlainMessageBuffer ) ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; zrtpPacket -> messageData = ( void * ) messageData ; } break ; case MSGTYPE_CONF2ACK : break ; case MSGTYPE_PING : { bzrtpPingMessage_t * messageData ; messageData = ( bzrtpPingMessage_t * ) malloc ( sizeof ( bzrtpPingMessage_t ) ) ; memcpy ( messageData -> version , messageContent , 4 ) ; messageContent += 4 ; memcpy ( messageData -> endpointHash , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; } break ; } return 0 ; }
","<S2SV_ModStart> BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } }
",BelledonneCommunications@bzrtp/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,CVE-2016-6271,https://github.com/BelledonneCommunications/bzrtp/commit/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,2017-01-18T22:59Z,<S2SV_StartBug> } else { <S2SV_EndBug>
3198,CWE-362,"static int newque ( struct ipc_namespace * ns , struct ipc_params * params ) { struct msg_queue * msq ; int id , retval ; key_t key = params -> key ; int msgflg = params -> flg ; msq = ipc_rcu_alloc ( sizeof ( * msq ) ) ; if ( ! msq ) return - ENOMEM ; msq -> q_perm . mode = msgflg & S_IRWXUGO ; msq -> q_perm . key = key ; msq -> q_perm . security = NULL ; retval = security_msg_queue_alloc ( msq ) ; if ( retval ) { ipc_rcu_putref ( msq , ipc_rcu_free ) ; return retval ; } id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ; if ( id < 0 ) { ipc_rcu_putref ( msq , msg_rcu_free ) ; return id ; } msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; ipc_unlock_object ( & msq -> q_perm ) ; rcu_read_unlock ( ) ; return msq -> q_perm . id ; }
","<S2SV_ModStart> retval ; } msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; <S2SV_ModStart> id ; } <S2SV_ModEnd> ipc_unlock_object ( &
",torvalds@linux/b9a532277938798b53178d5a66af6e2915cb27cf,CVE-2015-7613,https://github.com/torvalds/linux/commit/b9a532277938798b53178d5a66af6e2915cb27cf,2015-10-19T10:59Z,"<S2SV_StartBug> id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ; <S2SV_EndBug> <S2SV_StartBug> msq -> q_stime = msq -> q_rtime = 0 ; <S2SV_EndBug>"
3697,CWE-20,"long kernel_wait4 ( pid_t upid , int __user * stat_addr , int options , struct rusage * ru ) { struct wait_opts wo ; struct pid * pid = NULL ; enum pid_type type ; long ret ; if ( options & ~ ( WNOHANG | WUNTRACED | WCONTINUED | __WNOTHREAD | __WCLONE | __WALL ) ) return - EINVAL ; if ( upid == - 1 ) type = PIDTYPE_MAX ; else if ( upid < 0 ) { type = PIDTYPE_PGID ; pid = find_get_pid ( - upid ) ; } else if ( upid == 0 ) { type = PIDTYPE_PGID ; pid = get_task_pid ( current , PIDTYPE_PGID ) ; } else { type = PIDTYPE_PID ; pid = find_get_pid ( upid ) ; } wo . wo_type = type ; wo . wo_pid = pid ; wo . wo_flags = options | WEXITED ; wo . wo_info = NULL ; wo . wo_stat = 0 ; wo . wo_rusage = ru ; ret = do_wait ( & wo ) ; put_pid ( pid ) ; if ( ret > 0 && stat_addr && put_user ( wo . wo_stat , stat_addr ) ) ret = - EFAULT ; return ret ; }
","<S2SV_ModStart> ( upid == INT_MIN ) return - ESRCH ; if ( upid ==
",torvalds@linux/dd83c161fbcc5d8be637ab159c0de015cbff5ba4,CVE-2018-10087,https://github.com/torvalds/linux/commit/dd83c161fbcc5d8be637ab159c0de015cbff5ba4,2018-04-13T13:29Z,<S2SV_StartBug> if ( upid == - 1 ) <S2SV_EndBug>
4108,CWE-190,"static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; DEFINE_WAKE_Q ( wake_q ) ; if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( refill_pi_state_cache ( ) ) return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & FLAGS_SHARED ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - EAGAIN ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { WARN_ON ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( uaddr2 , ret , hb2 , & key2 , & pi_state ) ; } switch ( ret ) { case 0 : break ; case - EFAULT : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - EAGAIN : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - EINVAL ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { mark_wake_futex ( & wake_q , this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - EINVAL ; break ; } if ( requeue_pi ) { get_pi_state ( pi_state ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = NULL ; put_pi_state ( pi_state ) ; break ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } put_pi_state ( pi_state ) ; out_unlock : double_unlock_hb ( hb1 , hb2 ) ; wake_up_q ( & wake_q ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : return ret ? ret : task_count ; }
","<S2SV_ModStart> ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL
",torvalds@linux/fbe0e839d1e22d88810f3ee3e2f1479be4c0aa4a,CVE-2018-6927,https://github.com/torvalds/linux/commit/fbe0e839d1e22d88810f3ee3e2f1479be4c0aa4a,2018-02-12T19:29Z,<S2SV_StartBug> DEFINE_WAKE_Q ( wake_q ) ; <S2SV_EndBug>
1166,CWE-125,"static int get_debug_info ( struct PE_ ( r_bin_pe_obj_t ) * bin , PE_ ( image_debug_directory_entry ) * dbg_dir_entry , ut8 * dbg_data , int dbg_data_len , SDebugInfo * res ) { # define SIZEOF_FILE_NAME 255 int i = 0 ; const char * basename ; if ( ! dbg_data ) { return 0 ; } switch ( dbg_dir_entry -> Type ) { case IMAGE_DEBUG_TYPE_CODEVIEW : if ( ! strncmp ( ( char * ) dbg_data , ""RSDS"" , 4 ) ) { SCV_RSDS_HEADER rsds_hdr ; init_rsdr_hdr ( & rsds_hdr ) ; if ( ! get_rsds ( dbg_data , dbg_data_len , & rsds_hdr ) ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>read<S2SV_blank>PE<S2SV_blank>debug<S2SV_blank>info\\n"" ) ; return 0 ; } snprintf ( res -> guidstr , GUIDSTR_LEN , ""%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x"" , rsds_hdr . guid . data1 , rsds_hdr . guid . data2 , rsds_hdr . guid . data3 , rsds_hdr . guid . data4 [ 0 ] , rsds_hdr . guid . data4 [ 1 ] , rsds_hdr . guid . data4 [ 2 ] , rsds_hdr . guid . data4 [ 3 ] , rsds_hdr . guid . data4 [ 4 ] , rsds_hdr . guid . data4 [ 5 ] , rsds_hdr . guid . data4 [ 6 ] , rsds_hdr . guid . data4 [ 7 ] , rsds_hdr . age ) ; basename = r_file_basename ( ( char * ) rsds_hdr . file_name ) ; strncpy ( res -> file_name , ( const char * ) basename , sizeof ( res -> file_name ) ) ; res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; rsds_hdr . free ( ( struct SCV_RSDS_HEADER * ) & rsds_hdr ) ; } else if ( strncmp ( ( const char * ) dbg_data , ""NB10"" , 4 ) == 0 ) { SCV_NB10_HEADER nb10_hdr ; init_cv_nb10_header ( & nb10_hdr ) ; get_nb10 ( dbg_data , & nb10_hdr ) ; snprintf ( res -> guidstr , sizeof ( res -> guidstr ) , ""%x%x"" , nb10_hdr . timestamp , nb10_hdr . age ) ; strncpy ( res -> file_name , ( const char * ) nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ; res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; nb10_hdr . free ( ( struct SCV_NB10_HEADER * ) & nb10_hdr ) ; } else { bprintf ( ""CodeView<S2SV_blank>section<S2SV_blank>not<S2SV_blank>NB10<S2SV_blank>or<S2SV_blank>RSDS\\n"" ) ; return 0 ; } break ; default : return 0 ; } while ( i < 33 ) { res -> guidstr [ i ] = toupper ( ( int ) res -> guidstr [ i ] ) ; i ++ ; } return 1 ; }
","<S2SV_ModStart> 0 ) { if ( dbg_data_len < 20 ) { eprintf ( ""Truncated<S2SV_blank>NB10<S2SV_blank>entry,<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>parse\\n"" ) ; return 0 ; } SCV_NB10_HEADER nb10_hdr = { { 0 } } <S2SV_ModEnd> ; init_cv_nb10_header ( <S2SV_ModStart> age ) ; res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) { <S2SV_ModStart> 1 ) ; }
",radare@radare2/4e1cf0d3e6f6fe2552a269def0af1cd2403e266c,CVE-2018-11379,https://github.com/radare/radare2/commit/4e1cf0d3e6f6fe2552a269def0af1cd2403e266c,2018-05-22T19:29Z,"<S2SV_StartBug> SCV_NB10_HEADER nb10_hdr ; <S2SV_EndBug> <S2SV_StartBug> ""%x%x"" , nb10_hdr . timestamp , nb10_hdr . age ) ; <S2SV_EndBug> <S2SV_StartBug> nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ; <S2SV_EndBug>"
3068,CWE-362,"int sctp_rcv ( struct sk_buff * skb ) { struct sock * sk ; struct sctp_association * asoc ; struct sctp_endpoint * ep = NULL ; struct sctp_ep_common * rcvr ; struct sctp_transport * transport = NULL ; struct sctp_chunk * chunk ; struct sctphdr * sh ; union sctp_addr src ; union sctp_addr dest ; int family ; struct sctp_af * af ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; SCTP_INC_STATS_BH ( SCTP_MIB_INSCTPPACKS ) ; if ( skb_linearize ( skb ) ) goto discard_it ; sh = sctp_hdr ( skb ) ; __skb_pull ( skb , skb_transport_offset ( skb ) ) ; if ( skb -> len < sizeof ( struct sctphdr ) ) goto discard_it ; if ( ! skb_csum_unnecessary ( skb ) && sctp_rcv_checksum ( skb ) < 0 ) goto discard_it ; skb_pull ( skb , sizeof ( struct sctphdr ) ) ; if ( skb -> len < sizeof ( struct sctp_chunkhdr ) ) goto discard_it ; family = ipver2af ( ip_hdr ( skb ) -> version ) ; af = sctp_get_af_specific ( family ) ; if ( unlikely ( ! af ) ) goto discard_it ; af -> from_skb ( & src , skb , 1 ) ; af -> from_skb ( & dest , skb , 0 ) ; if ( ! af -> addr_valid ( & src , NULL , skb ) || ! af -> addr_valid ( & dest , NULL , skb ) ) goto discard_it ; asoc = __sctp_rcv_lookup ( skb , & src , & dest , & transport ) ; if ( ! asoc ) ep = __sctp_rcv_lookup_endpoint ( & dest ) ; rcvr = asoc ? & asoc -> base : & ep -> base ; sk = rcvr -> sk ; if ( sk -> sk_bound_dev_if && ( sk -> sk_bound_dev_if != af -> skb_iif ( skb ) ) ) { if ( asoc ) { sctp_association_put ( asoc ) ; asoc = NULL ; } else { sctp_endpoint_put ( ep ) ; ep = NULL ; } sk = sctp_get_ctl_sock ( ) ; ep = sctp_sk ( sk ) -> ep ; sctp_endpoint_hold ( ep ) ; rcvr = & ep -> base ; } if ( ! asoc ) { if ( sctp_rcv_ootb ( skb ) ) { SCTP_INC_STATS_BH ( SCTP_MIB_OUTOFBLUES ) ; goto discard_release ; } } if ( ! xfrm_policy_check ( sk , XFRM_POLICY_IN , skb , family ) ) goto discard_release ; nf_reset ( skb ) ; if ( sk_filter ( sk , skb ) ) goto discard_release ; chunk = sctp_chunkify ( skb , asoc , sk ) ; if ( ! chunk ) goto discard_release ; SCTP_INPUT_CB ( skb ) -> chunk = chunk ; chunk -> rcvr = rcvr ; chunk -> sctp_hdr = sh ; sctp_init_addrs ( chunk , & src , & dest ) ; chunk -> transport = transport ; sctp_bh_lock_sock ( sk ) ; if ( sock_owned_by_user ( sk ) ) { SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_BACKLOG ) ; sctp_add_backlog ( sk , skb ) ; } else { SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_SOFTIRQ ) ; sctp_inq_push ( & chunk -> rcvr -> inqueue , chunk ) ; } sctp_bh_unlock_sock ( sk ) ; if ( asoc ) sctp_association_put ( asoc ) ; else sctp_endpoint_put ( ep ) ; return 0 ; discard_it : SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_DISCARDS ) ; kfree_skb ( skb ) ; return 0 ; discard_release : if ( asoc ) sctp_association_put ( asoc ) ; else sctp_endpoint_put ( ep ) ; goto discard_it ; }
","<S2SV_ModStart> ; if ( sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if (
",torvalds@linux/ae53b5bd77719fed58086c5be60ce4f22bffe1c6,CVE-2011-4348,https://github.com/torvalds/linux/commit/ae53b5bd77719fed58086c5be60ce4f22bffe1c6,2013-06-08T13:05Z,<S2SV_StartBug> if ( sock_owned_by_user ( sk ) ) { <S2SV_EndBug>
4577,CWE-125,"static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug>"
1693,CWE-119,"static int check_dual_ref_flags ( VP9_COMP * cpi ) { const int ref_flags = cpi -> ref_frame_flags ; if ( vp9_segfeature_active ( & cpi -> common . seg , 1 , SEG_LVL_REF_FRAME ) ) { return 0 ; } else { return ( ! ! ( ref_flags & VP9_GOLD_FLAG ) + ! ! ( ref_flags & VP9_LAST_FLAG ) + ! ! ( ref_flags & VP9_ALT_FLAG ) ) >= 2 ; } }
","<S2SV_ModStart> ; if ( segfeature_active <S2SV_ModEnd> ( & cpi
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> if ( vp9_segfeature_active ( & cpi -> common . seg , 1 , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug>"
5816,CWE-000,"static int ext4_ext_convert_to_initialized ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path ) { struct ext4_extent * ex , newex , orig_ex ; struct ext4_extent * ex1 = NULL ; struct ext4_extent * ex2 = NULL ; struct ext4_extent * ex3 = NULL ; struct ext4_extent_header * eh ; ext4_lblk_t ee_block , eof_block ; unsigned int allocated , ee_len , depth ; ext4_fsblk_t newblock ; int err = 0 ; int ret = 0 ; int may_zeroout ; ext_debug ( ""ext4_ext_convert_to_initialized:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len ) ; eof_block = ( inode -> i_size + inode -> i_sb -> s_blocksize - 1 ) >> inode -> i_sb -> s_blocksize_bits ; if ( eof_block < map -> m_lblk + map -> m_len ) eof_block = map -> m_lblk + map -> m_len ; depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; allocated = ee_len - ( map -> m_lblk - ee_block ) ; newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ; ex2 = ex ; orig_ex . ee_block = ex -> ee_block ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_store_pblock ( & orig_ex , ext4_ext_pblock ( ex ) ) ; may_zeroout = ee_block + ee_len <= eof_block ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; if ( ee_len <= 2 * EXT4_EXT_ZERO_LEN && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } if ( map -> m_lblk > ee_block ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } if ( ! ex1 && allocated > map -> m_len ) ex2 -> ee_len = cpu_to_le16 ( map -> m_len ) ; if ( allocated > map -> m_len ) { unsigned int newdepth ; if ( allocated <= EXT4_EXT_ZERO_LEN && may_zeroout ) { ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = cpu_to_le16 ( ee_len - allocated ) ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; ex3 = & newex ; ex3 -> ee_block = cpu_to_le32 ( map -> m_lblk ) ; ext4_ext_store_pblock ( ex3 , newblock ) ; ex3 -> ee_len = cpu_to_le16 ( allocated ) ; err = ext4_ext_insert_extent ( handle , inode , path , ex3 , 0 ) ; if ( err == - ENOSPC ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; err = ext4_ext_zeroout ( inode , ex3 ) ; if ( err ) { depth = ext_depth ( inode ) ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; return err ; } ex = path [ depth ] . p_ext ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) return err ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; } return allocated ; } ex3 = & newex ; ex3 -> ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; ext4_ext_store_pblock ( ex3 , newblock + map -> m_len ) ; ex3 -> ee_len = cpu_to_le16 ( allocated - map -> m_len ) ; ext4_ext_mark_uninitialized ( ex3 ) ; err = ext4_ext_insert_extent ( handle , inode , path , ex3 , 0 ) ; if ( err == - ENOSPC && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; newdepth = ext_depth ( inode ) ; ee_len -= ext4_ext_get_actual_len ( ex3 ) ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; may_zeroout = ee_block + ee_len <= eof_block ; depth = newdepth ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } eh = path [ depth ] . p_hdr ; ex = path [ depth ] . p_ext ; if ( ex2 != & newex ) ex2 = ex ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; allocated = map -> m_len ; if ( le16_to_cpu ( orig_ex . ee_len ) <= EXT4_EXT_ZERO_LEN && map -> m_lblk != ee_block && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } } if ( ex1 && ex1 != ex ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } ex2 -> ee_block = cpu_to_le32 ( map -> m_lblk ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; ex2 -> ee_len = cpu_to_le16 ( allocated ) ; if ( ex2 != ex ) goto insert ; if ( ex2 > EXT_FIRST_EXTENT ( eh ) ) { ret = ext4_ext_try_to_merge ( inode , path , ex2 - 1 ) ; if ( ret ) { err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto out ; depth = ext_depth ( inode ) ; ex2 -- ; } } if ( ! ex3 ) { ret = ext4_ext_try_to_merge ( inode , path , ex2 ) ; if ( ret ) { err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto out ; } } err = ext4_ext_dirty ( handle , inode , path + depth ) ; goto out ; insert : err = ext4_ext_insert_extent ( handle , inode , path , & newex , 0 ) ; if ( err == - ENOSPC && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ? err : allocated ; fix_extent_len : ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }
","<S2SV_ModStart> ) { struct ext4_map_blocks split_map ; struct ext4_extent zero_ex <S2SV_ModEnd> ; struct ext4_extent <S2SV_ModStart> struct ext4_extent * ex <S2SV_ModEnd> ; ext4_lblk_t ee_block <S2SV_ModStart> , depth ; <S2SV_ModEnd> int err = <S2SV_ModStart> 0 ; int split_flag = 0 <S2SV_ModEnd> ; ext_debug ( <S2SV_ModStart> inode ) ; ex <S2SV_ModEnd> = path [ <S2SV_ModStart> depth ] . <S2SV_ModEnd> p_ext ; ee_block <S2SV_ModStart> ee_block ) ; WARN_ON ( map -> m_lblk < ee_block ) ; split_flag |= <S2SV_ModEnd> ee_block + ee_len <S2SV_ModStart> ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> * EXT4_EXT_ZERO_LEN && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) <S2SV_ModEnd> ) { err <S2SV_ModStart> ( inode , ex <S2SV_ModEnd> ) ; if <S2SV_ModStart> err ) goto out ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( inode , path , ex ) ; err = <S2SV_ModEnd> ext4_ext_dirty ( handle <S2SV_ModStart> depth ) ; goto out ; } split_map . m_lblk = map -> m_lblk ; split_map . m_len = map -> m_len ; if ( allocated > map -> m_len ) { <S2SV_ModEnd> if ( allocated <S2SV_ModStart> <= EXT4_EXT_ZERO_LEN && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { zero_ex . ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; zero_ex . <S2SV_ModEnd> ee_len = cpu_to_le16 <S2SV_ModStart> = cpu_to_le16 ( allocated - map -> m_len <S2SV_ModEnd> ) ; ext4_ext_store_pblock <S2SV_ModStart> ; ext4_ext_store_pblock ( & zero_ex , ext4_ext_pblock ( ex ) + map -> m_lblk - ee_block ) ; <S2SV_ModEnd> err = ext4_ext_zeroout <S2SV_ModStart> inode , & zero_ex <S2SV_ModEnd> ) ; if <S2SV_ModStart> err ) goto out ; split_map . m_lblk = map -> m_lblk ; split_map . m_len = <S2SV_ModEnd> allocated ; } <S2SV_ModStart> else if ( ( map -> m_lblk - ee_block + map -> m_len < EXT4_EXT_ZERO_LEN ) && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { if ( map -> m_lblk != ee_block ) { zero_ex . ee_block = ex -> ee_block ; zero_ex . ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_store_pblock ( & zero_ex , ext4_ext_pblock ( ex ) ) <S2SV_ModEnd> ; err = <S2SV_ModStart> ( inode , & zero_ex ) ; if ( err ) <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } allocated = map -> m_lblk - ee_block + map -> m_len ; split_map . m_lblk = ee_block ; split_map . m_len = allocated ; } } allocated = ext4_split_extent ( handle , inode , path , & split_map , split_flag <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ; if ( allocated < 0 ) err = allocated <S2SV_ModEnd> ; out : <S2SV_ModStart> ; out : <S2SV_ModEnd> return err ? <S2SV_ModStart> err : allocated <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3,CVE-2011-3638,https://github.com/torvalds/linux/commit/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3,2013-03-01T12:37Z,"<S2SV_StartBug> struct ext4_extent * ex , newex , orig_ex ; <S2SV_EndBug> <S2SV_StartBug> struct ext4_extent * ex1 = NULL ; <S2SV_EndBug> <S2SV_StartBug> ext4_fsblk_t newblock ; <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> eh = path [ depth ] . p_hdr ; <S2SV_EndBug> <S2SV_StartBug> newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ; <S2SV_EndBug> <S2SV_StartBug> may_zeroout = ee_block + ee_len <= eof_block ; <S2SV_EndBug> <S2SV_StartBug> if ( ee_len <= 2 * EXT4_EXT_ZERO_LEN && may_zeroout ) { <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> <S2SV_StartBug> goto fix_extent_len ; <S2SV_EndBug> <S2SV_StartBug> return allocated ; <S2SV_EndBug> <S2SV_StartBug> if ( allocated <= EXT4_EXT_ZERO_LEN && may_zeroout ) { <S2SV_EndBug> <S2SV_StartBug> ex -> ee_len = cpu_to_le16 ( ee_len - allocated ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> <S2SV_StartBug> goto fix_extent_len ; <S2SV_EndBug> <S2SV_StartBug> } else if ( err ) <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , ex3 ) ; <S2SV_EndBug> <S2SV_StartBug> eh = path [ depth ] . p_hdr ; <S2SV_EndBug> <S2SV_StartBug> if ( err == - ENOSPC && may_zeroout ) { <S2SV_EndBug> <S2SV_StartBug> ext4_ext_show_leaf ( inode , path ) ; <S2SV_EndBug> <S2SV_StartBug> return err ? err : allocated ; <S2SV_EndBug>"
2246,CWE-399,"static int br_multicast_add_group ( struct net_bridge * br , struct net_bridge_port * port , struct br_ip * group ) { struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; unsigned long now = jiffies ; int err ; spin_lock ( & br -> multicast_lock ) ; if ( ! netif_running ( br -> dev ) || ( port && port -> state == BR_STATE_DISABLED ) ) goto out ; mp = br_multicast_new_group ( br , port , group ) ; err = PTR_ERR ( mp ) ; if ( IS_ERR ( mp ) ) goto err ; if ( ! port ) { hlist_add_head ( & mp -> mglist , & br -> mglist ) ; mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ; goto out ; } for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( p -> port == port ) goto found ; if ( ( unsigned long ) p -> port < ( unsigned long ) port ) break ; } p = kzalloc ( sizeof ( * p ) , GFP_ATOMIC ) ; err = - ENOMEM ; if ( unlikely ( ! p ) ) goto err ; p -> addr = * group ; p -> port = port ; p -> next = * pp ; hlist_add_head ( & p -> mglist , & port -> mglist ) ; setup_timer ( & p -> timer , br_multicast_port_group_expired , ( unsigned long ) p ) ; setup_timer ( & p -> query_timer , br_multicast_port_group_query_expired , ( unsigned long ) p ) ; rcu_assign_pointer ( * pp , p ) ; found : mod_timer ( & p -> timer , now + br -> multicast_membership_interval ) ; out : err = 0 ; err : spin_unlock ( & br -> multicast_lock ) ; return err ; }
","<S2SV_ModStart> port ) { if ( hlist_unhashed ( & mp -> mglist ) )
",torvalds@linux/6b0d6a9b4296fa16a28d10d416db7a770fc03287,CVE-2011-0716,https://github.com/torvalds/linux/commit/6b0d6a9b4296fa16a28d10d416db7a770fc03287,2012-06-21T23:55Z,"<S2SV_StartBug> hlist_add_head ( & mp -> mglist , & br -> mglist ) ; <S2SV_EndBug>"
7315,CWE-787,"static int blosc_c ( struct thread_context * thread_context , int32_t bsize , int32_t leftoverblock , int32_t ntbytes , int32_t maxbytes , const uint8_t * src , const int32_t offset , uint8_t * dest , uint8_t * tmp , uint8_t * tmp2 ) { blosc2_context * context = thread_context -> parent_context ; int dont_split = ( context -> header_flags & 0x10 ) >> 4 ; int dict_training = context -> use_dict && context -> dict_cdict == NULL ; int32_t j , neblock , nstreams ; int32_t cbytes ; int32_t ctbytes = 0 ; int64_t maxout ; int32_t typesize = context -> typesize ; const char * compname ; int accel ; const uint8_t * _src ; uint8_t * _tmp = tmp , * _tmp2 = tmp2 ; uint8_t * _tmp3 = thread_context -> tmp4 ; int last_filter_index = last_filter ( context -> filters , 'c' ) ; bool memcpyed = context -> header_flags & ( uint8_t ) BLOSC_MEMCPYED ; if ( last_filter_index >= 0 || context -> prefilter != NULL ) { if ( memcpyed && context -> prefilter != NULL ) { _src = pipeline_c ( thread_context , bsize , src , offset , dest , _tmp2 , _tmp3 ) ; if ( _src == NULL ) { return - 9 ; } return bsize ; } _src = pipeline_c ( thread_context , bsize , src , offset , _tmp , _tmp2 , _tmp3 ) ; if ( _src == NULL ) { return - 9 ; } } else { _src = src + offset ; } assert ( context -> clevel > 0 ) ; accel = get_accel ( context ) ; if ( ! dont_split && ! leftoverblock && ! dict_training ) { nstreams = ( int32_t ) typesize ; } else { nstreams = 1 ; } neblock = bsize / nstreams ; for ( j = 0 ; j < nstreams ; j ++ ) { if ( ! dict_training ) { dest += sizeof ( int32_t ) ; ntbytes += sizeof ( int32_t ) ; ctbytes += sizeof ( int32_t ) ; } const uint8_t * ip = ( uint8_t * ) _src + j * neblock ; const uint8_t * ipbound = ( uint8_t * ) _src + ( j + 1 ) * neblock ; if ( get_run ( ip , ipbound ) ) { int32_t value = _src [ j * neblock ] ; _sw32 ( dest - 4 , - value ) ; continue ; } maxout = neblock ; # if defined ( HAVE_SNAPPY ) if ( context -> compcode == BLOSC_SNAPPY ) { maxout = ( int32_t ) snappy_max_compressed_length ( ( size_t ) neblock ) ; } # endif if ( ntbytes + maxout > maxbytes ) { maxout = ( int64_t ) maxbytes - ( int64_t ) ntbytes ; if ( maxout <= 0 ) { return 0 ; } } if ( dict_training ) { memcpy ( dest , _src + j * neblock , ( unsigned int ) neblock ) ; cbytes = ( int32_t ) neblock ; } else if ( context -> compcode == BLOSC_BLOSCLZ ) { cbytes = blosclz_compress ( context -> clevel , _src + j * neblock , ( int ) neblock , dest , ( int ) maxout ) ; } # if defined ( HAVE_LZ4 ) else if ( context -> compcode == BLOSC_LZ4 ) { void * hash_table = NULL ; # ifdef HAVE_IPP hash_table = ( void * ) thread_context -> lz4_hash_table ; # endif cbytes = lz4_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , accel , hash_table ) ; } else if ( context -> compcode == BLOSC_LZ4HC ) { cbytes = lz4hc_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , context -> clevel ) ; } # endif # if defined ( HAVE_LIZARD ) else if ( context -> compcode == BLOSC_LIZARD ) { cbytes = lizard_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , accel ) ; } # endif # if defined ( HAVE_SNAPPY ) else if ( context -> compcode == BLOSC_SNAPPY ) { cbytes = snappy_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout ) ; } # endif # if defined ( HAVE_ZLIB ) else if ( context -> compcode == BLOSC_ZLIB ) { cbytes = zlib_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , context -> clevel ) ; } # endif # if defined ( HAVE_ZSTD ) else if ( context -> compcode == BLOSC_ZSTD ) { cbytes = zstd_wrap_compress ( thread_context , ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , context -> clevel ) ; } # endif else { blosc_compcode_to_compname ( context -> compcode , & compname ) ; fprintf ( stderr , ""Blosc<S2SV_blank>has<S2SV_blank>not<S2SV_blank>been<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>\'%s\'<S2SV_blank>"" , compname ) ; fprintf ( stderr , ""compression<S2SV_blank>support.<S2SV_blank><S2SV_blank>Please<S2SV_blank>use<S2SV_blank>one<S2SV_blank>having<S2SV_blank>it."" ) ; return - 5 ; } if ( cbytes > maxout ) { return - 1 ; } if ( cbytes < 0 ) { return - 2 ; } if ( ! dict_training ) { if ( cbytes == 0 || cbytes == neblock ) { if ( ( ntbytes + neblock ) > maxbytes ) { return 0 ; } memcpy ( dest , _src + j * neblock , ( unsigned int ) neblock ) ; cbytes = neblock ; } _sw32 ( dest - 4 , cbytes ) ; } dest += cbytes ; ntbytes += cbytes ; ctbytes += cbytes ; } return ctbytes ; }
","<S2SV_ModStart> ntbytes , int32_t destsize <S2SV_ModEnd> , const uint8_t <S2SV_ModStart> neblock ] ; if ( ntbytes > destsize ) { return - 1 ; } <S2SV_ModStart> + maxout > destsize <S2SV_ModEnd> ) { maxout <S2SV_ModStart> ( int64_t ) destsize <S2SV_ModEnd> - ( int64_t <S2SV_ModStart> neblock ) > destsize <S2SV_ModEnd> ) { return
",Blosc@c-blosc2/c4c6470e88210afc95262c8b9fcc27e30ca043ee,CVE-2020-29367,https://github.com/Blosc/c-blosc2/commit/c4c6470e88210afc95262c8b9fcc27e30ca043ee,2020-11-27T20:15Z,"<S2SV_StartBug> int32_t leftoverblock , int32_t ntbytes , int32_t maxbytes , <S2SV_EndBug> <S2SV_StartBug> _sw32 ( dest - 4 , - value ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ntbytes + maxout > maxbytes ) { <S2SV_EndBug> <S2SV_StartBug> maxout = ( int64_t ) maxbytes - ( int64_t ) ntbytes ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ntbytes + neblock ) > maxbytes ) { <S2SV_EndBug>"
1996,CWE-119,"const vpx_image_t * vpx_codec_get_preview_frame ( vpx_codec_ctx_t * ctx ) { vpx_image_t * img = NULL ; if ( ctx ) { if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else if ( ! ctx -> iface -> enc . get_preview ) ctx -> err = VPX_CODEC_INCAPABLE ; else img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ; } return img ; }
","<S2SV_ModStart> . get_preview ( get_alg_priv ( ctx ) <S2SV_ModEnd> ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug>
806,CWE-254,"static int follow_dotdot_rcu ( struct nameidata * nd ) { struct inode * inode = nd -> inode ; if ( ! nd -> root . mnt ) set_root_rcu ( nd ) ; while ( 1 ) { if ( path_equal ( & nd -> path , & nd -> root ) ) break ; if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { struct dentry * old = nd -> path . dentry ; struct dentry * parent = old -> d_parent ; unsigned seq ; inode = parent -> d_inode ; seq = read_seqcount_begin ( & parent -> d_seq ) ; if ( unlikely ( read_seqcount_retry ( & old -> d_seq , nd -> seq ) ) ) return - ECHILD ; nd -> path . dentry = parent ; nd -> seq = seq ; break ; } else { struct mount * mnt = real_mount ( nd -> path . mnt ) ; struct mount * mparent = mnt -> mnt_parent ; struct dentry * mountpoint = mnt -> mnt_mountpoint ; struct inode * inode2 = mountpoint -> d_inode ; unsigned seq = read_seqcount_begin ( & mountpoint -> d_seq ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( & mparent -> mnt == nd -> path . mnt ) break ; nd -> path . dentry = mountpoint ; nd -> path . mnt = & mparent -> mnt ; inode = inode2 ; nd -> seq = seq ; } } while ( unlikely ( d_mountpoint ( nd -> path . dentry ) ) ) { struct mount * mounted ; mounted = __lookup_mnt ( nd -> path . mnt , nd -> path . dentry ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( ! mounted ) break ; nd -> path . mnt = & mounted -> mnt ; nd -> path . dentry = mounted -> mnt . mnt_root ; inode = nd -> path . dentry -> d_inode ; nd -> seq = read_seqcount_begin ( & nd -> path . dentry -> d_seq ) ; } nd -> inode = inode ; return 0 ; }
","<S2SV_ModStart> = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
",torvalds@linux/397d425dc26da728396e66d392d5dcb8dac30c37,CVE-2015-2925,https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37,2015-11-16T11:59Z,<S2SV_StartBug> break ; <S2SV_EndBug>
1098,CWE-264,"static inline int unuse_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , swp_entry_t entry , struct page * page ) { pmd_t * pmd ; unsigned long next ; int ret ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( unlikely ( pmd_trans_huge ( * pmd ) ) ) continue ; if ( pmd_none_or_clear_bad ( pmd ) ) continue ; ret = unuse_pte_range ( vma , pmd , addr , next , entry , page ) ; if ( ret ) return ret ; } while ( pmd ++ , addr = next , addr != end ) ; return 0 ; }
","<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z,<S2SV_StartBug> if ( unlikely ( pmd_trans_huge ( * pmd ) ) ) <S2SV_EndBug>
3434,CWE-369,"static int iwgif_read_image ( struct iwgifrcontext * rctx ) { int retval = 0 ; struct lzwdeccontext d ; size_t subblocksize ; int has_local_ct ; int local_ct_size ; unsigned int root_codesize ; if ( ! iwgif_read ( rctx , rctx -> rbuf , 9 ) ) goto done ; rctx -> image_left = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 0 ] ) ; rctx -> image_top = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 2 ] ) ; rctx -> image_width = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 4 ] ) ; rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ; rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ; has_local_ct = ( int ) ( ( rctx -> rbuf [ 8 ] >> 7 ) & 0x01 ) ; if ( has_local_ct ) { local_ct_size = ( int ) ( rctx -> rbuf [ 8 ] & 0x07 ) ; rctx -> colortable . num_entries = 1 << ( 1 + local_ct_size ) ; } if ( has_local_ct ) { if ( ! iwgif_read_color_table ( rctx , & rctx -> colortable ) ) goto done ; } if ( rctx -> has_transparency ) { rctx -> colortable . entry [ rctx -> trans_color_index ] . a = 0 ; } if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; root_codesize = ( unsigned int ) rctx -> rbuf [ 0 ] ; if ( root_codesize < 2 || root_codesize > 11 ) { iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>LZW<S2SV_blank>minimum<S2SV_blank>code<S2SV_blank>size"" ) ; goto done ; } if ( ! iwgif_init_screen ( rctx ) ) goto done ; rctx -> total_npixels = ( size_t ) rctx -> image_width * ( size_t ) rctx -> image_height ; if ( ! iwgif_make_row_pointers ( rctx ) ) goto done ; lzw_init ( & d , root_codesize ) ; lzw_clear ( & d ) ; while ( 1 ) { if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; subblocksize = ( size_t ) rctx -> rbuf [ 0 ] ; if ( subblocksize == 0 ) break ; if ( ! iwgif_read ( rctx , rctx -> rbuf , subblocksize ) ) goto done ; if ( ! lzw_process_bytes ( rctx , & d , rctx -> rbuf , subblocksize ) ) goto done ; if ( d . eoi_flag ) break ; if ( rctx -> pixels_set >= rctx -> total_npixels ) break ; } retval = 1 ; done : return retval ; }
","<S2SV_ModStart> ] ) ; if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>image<S2SV_blank>dimensions"" ) ; goto done ; }
",jsummers@imageworsener/ca3356eb49fee03e2eaf6b6aff826988c1122d93,CVE-2017-7962,https://github.com/jsummers/imageworsener/commit/ca3356eb49fee03e2eaf6b6aff826988c1122d93,2017-04-19T15:59Z,<S2SV_StartBug> rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ; <S2SV_EndBug>
231,CWE-17,"int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , int flen ) { struct ustr * filename , * unifilename ; int len = 0 ; filename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! filename ) return 0 ; unifilename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! unifilename ) goto out1 ; if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) goto out2 ; if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_UTF8 ) ) { if ( ! udf_CS0toUTF8 ( filename , unifilename ) ) { udf_debug ( ""Failed<S2SV_blank>in<S2SV_blank>udf_get_filename:<S2SV_blank>sname<S2SV_blank>=<S2SV_blank>%s\\n"" , sname ) ; goto out2 ; } } else if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_NLS_MAP ) ) { if ( ! udf_CS0toNLS ( UDF_SB ( sb ) -> s_nls_map , filename , unifilename ) ) { udf_debug ( ""Failed<S2SV_blank>in<S2SV_blank>udf_get_filename:<S2SV_blank>sname<S2SV_blank>=<S2SV_blank>%s\\n"" , sname ) ; goto out2 ; } } else goto out2 ; len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , unifilename -> u_name , unifilename -> u_len ) ; out2 : kfree ( unifilename ) ; out1 : kfree ( filename ) ; return len ; }
","<S2SV_ModStart> * sname , int slen , <S2SV_ModStart> * dname , int dlen <S2SV_ModEnd> ) { struct <S2SV_ModStart> , sname , slen <S2SV_ModEnd> ) ) goto <S2SV_ModStart> ( dname , dlen ,
",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z,"<S2SV_StartBug> int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , <S2SV_EndBug> <S2SV_StartBug> int flen ) <S2SV_EndBug> <S2SV_StartBug> if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) <S2SV_EndBug> <S2SV_StartBug> len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , <S2SV_EndBug>"
7072,CWE-763,"static OM_uint32 init_ctx_new ( OM_uint32 * minor_status , spnego_gss_cred_id_t spcred , gss_ctx_id_t * ctx , send_token_flag * tokflag ) { OM_uint32 ret ; spnego_gss_ctx_id_t sc = NULL ; sc = create_spnego_ctx ( ) ; if ( sc == NULL ) return GSS_S_FAILURE ; ret = get_negotiable_mechs ( minor_status , spcred , GSS_C_INITIATE , & sc -> mech_set ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; sc -> internal_mech = & sc -> mech_set -> elements [ 0 ] ; if ( put_mech_set ( sc -> mech_set , & sc -> DER_mechTypes ) < 0 ) { ret = GSS_S_FAILURE ; goto cleanup ; } sc -> ctx_handle = GSS_C_NO_CONTEXT ; * ctx = ( gss_ctx_id_t ) sc ; sc = NULL ; * tokflag = INIT_TOKEN_SEND ; ret = GSS_S_CONTINUE_NEEDED ; cleanup : release_spnego_ctx ( & sc ) ; return ret ; }
","<S2SV_ModStart> = create_spnego_ctx ( 1
",krb5@krb5/b51b33f2bc5d1497ddf5bd107f791c101695000d,CVE-2015-2695,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,2015-11-09T03:59Z,<S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug>
723,CWE-476,"static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( ""Interrupt<S2SV_blank>%d,<S2SV_blank>without<S2SV_blank>any<S2SV_blank>data\\n"" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( ""MUX<S2SV_blank>error,<S2SV_blank>status<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>data<S2SV_blank>is<S2SV_blank>%02x\\n"" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT && ! i8042_notimeout ) ? SERIO_TIMEOUT : 0 ) ; port_no = ( str & I8042_STR_AUXDATA ) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO ; } port = & i8042_ports [ port_no ] ; serio = port -> exists ? port -> serio : NULL ; filter_dbg ( port -> driver_bound , data , ""<-<S2SV_blank>i8042<S2SV_blank>(interrupt,<S2SV_blank>%d,<S2SV_blank>%d%s%s)\\n"" , port_no , irq , dfl & SERIO_PARITY ? "",<S2SV_blank>bad<S2SV_blank>parity"" : """" , dfl & SERIO_TIMEOUT ? "",<S2SV_blank>timeout"" : """" ) ; filtered = i8042_filter ( data , str , serio ) ; spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( likely ( port -> exists && ! filtered ) ) serio_interrupt ( serio , data , dfl ) ; out : return IRQ_RETVAL ( ret ) ; }
","<S2SV_ModStart> ( likely ( serio <S2SV_ModEnd> && ! filtered
",torvalds@linux/340d394a789518018f834ff70f7534fc463d3226,CVE-2017-18079,https://github.com/torvalds/linux/commit/340d394a789518018f834ff70f7534fc463d3226,2018-01-29T05:29Z,<S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug>
2859,CWE-125,"int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
","<S2SV_ModStart> ++ ) { <S2SV_ModEnd> if ( bytes_matched <S2SV_ModStart> max_bytes_matched ) break ; next_input = input + i * input_incr <S2SV_ModStart> -> min ; bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ;
",VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661,CVE-2017-9465,https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661,2017-06-06T21:29Z,<S2SV_StartBug> next_input = input + i * input_incr ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ip = next_opcode ; <S2SV_EndBug>
675,CWE-611,"void xmlParsePEReference ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; xmlEntityPtr entity = NULL ; xmlParserInputPtr input ; if ( RAW != '%' ) return ; NEXT ; name = xmlParseName ( ctxt ) ; if ( name == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , ""xmlParsePEReference:<S2SV_blank>no<S2SV_blank>name\\n"" ) ; return ; } if ( RAW != ';' ) { xmlFatalErr ( ctxt , XML_ERR_ENTITYREF_SEMICOL_MISSING , NULL ) ; return ; } NEXT ; ctxt -> nbentities ++ ; if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> getParameterEntity != NULL ) ) entity = ctxt -> sax -> getParameterEntity ( ctxt -> userData , name ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( entity == NULL ) { if ( ( ctxt -> standalone == 1 ) || ( ( ctxt -> hasExternalSubset == 0 ) && ( ctxt -> hasPErefs == 0 ) ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_UNDECLARED_ENTITY , ""PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n"" , name ) ; } else { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n"" , name , NULL ) ; ctxt -> valid = 0 ; } xmlParserEntityCheck ( ctxt , 0 , NULL , 0 ) ; } else { if ( ( entity -> etype != XML_INTERNAL_PARAMETER_ENTITY ) && ( entity -> etype != XML_EXTERNAL_PARAMETER_ENTITY ) ) { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""Internal:<S2SV_blank>%%%s;<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>parameter<S2SV_blank>entity\\n"" , name , NULL ) ; } else if ( ctxt -> input -> free != deallocblankswrapper ) { input = xmlNewBlanksWrapperInputStream ( ctxt , entity ) ; if ( xmlPushInput ( ctxt , input ) < 0 ) return ; } else { input = xmlNewEntityInputStream ( ctxt , entity ) ; if ( xmlPushInput ( ctxt , input ) < 0 ) return ; if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( CMP5 ( CUR_PTR , '<' , '?' , 'x' , 'm' , 'l' ) ) && ( IS_BLANK_CH ( NXT ( 5 ) ) ) ) { xmlParseTextDecl ( ctxt ) ; if ( ctxt -> errNo == XML_ERR_UNSUPPORTED_ENCODING ) { xmlHaltParser ( ctxt ) ; return ; } } } } ctxt -> hasPErefs = 1 ; }
","<S2SV_ModStart> } else { if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ;
",external@libxml2/308396a55280f69ad4112d4f9892f4cbeff042aa,CVE-2017-7375,https://android.googlesource.com/platform/external/libxml2/+/308396a55280f69ad4112d4f9892f4cbeff042aa,2018-02-19T19:29Z,"<S2SV_StartBug> input = xmlNewEntityInputStream ( ctxt , entity ) ; <S2SV_EndBug>"
1845,CWE-119,"static int64_t handle_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , const TileInfo * const tile , BLOCK_SIZE bsize , int64_t txfm_cache [ ] , int * rate2 , int64_t * distortion , int * skippable , int * rate_y , int64_t * distortion_y , int * rate_uv , int64_t * distortion_uv , int * mode_excluded , int * disable_skip , INTERP_FILTER * best_filter , int_mv ( * mode_mv ) [ MAX_REF_FRAMES ] , int mi_row , int mi_col , int_mv single_newmv [ MAX_REF_FRAMES ] , int64_t * psse , const int64_t ref_best_rd ) { VP9_COMMON * cm = & cpi -> common ; MACROBLOCKD * xd = & x -> e_mbd ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_comp_pred = has_second_ref ( mbmi ) ; const int num_refs = is_comp_pred ? 2 : 1 ; const int this_mode = mbmi -> mode ; int_mv * frame_mv = mode_mv [ this_mode ] ; int i ; int refs [ 2 ] = { mbmi -> ref_frame [ 0 ] , ( mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] ) } ; int_mv cur_mv [ 2 ] ; int64_t this_rd = 0 ; DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , tmp_buf , MAX_MB_PLANE * 64 * 64 ) ; int pred_exists = 0 ; int intpel_mv ; int64_t rd , best_rd = INT64_MAX ; int best_needs_copy = 0 ; uint8_t * orig_dst [ MAX_MB_PLANE ] ; int orig_dst_stride [ MAX_MB_PLANE ] ; int rs = 0 ; if ( is_comp_pred ) { if ( frame_mv [ refs [ 0 ] ] . as_int == INVALID_MV || frame_mv [ refs [ 1 ] ] . as_int == INVALID_MV ) return INT64_MAX ; } if ( this_mode == NEWMV ) { int rate_mv ; if ( is_comp_pred ) { frame_mv [ refs [ 0 ] ] . as_int = single_newmv [ refs [ 0 ] ] . as_int ; frame_mv [ refs [ 1 ] ] . as_int = single_newmv [ refs [ 1 ] ] . as_int ; if ( cpi -> sf . comp_inter_joint_search_thresh <= bsize ) { joint_motion_search ( cpi , x , bsize , frame_mv , mi_row , mi_col , single_newmv , & rate_mv ) ; } else { rate_mv = vp9_mv_bit_cost ( & frame_mv [ refs [ 0 ] ] . as_mv , & mbmi -> ref_mvs [ refs [ 0 ] ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ 1 ] ] . as_mv , & mbmi -> ref_mvs [ refs [ 1 ] ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; } * rate2 += rate_mv ; } else { int_mv tmp_mv ; single_motion_search ( cpi , x , tile , bsize , mi_row , mi_col , & tmp_mv , & rate_mv ) ; if ( tmp_mv . as_int == INVALID_MV ) return INT64_MAX ; * rate2 += rate_mv ; frame_mv [ refs [ 0 ] ] . as_int = xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = tmp_mv . as_int ; single_newmv [ refs [ 0 ] ] . as_int = tmp_mv . as_int ; } } for ( i = 0 ; i < num_refs ; ++ i ) { cur_mv [ i ] = frame_mv [ refs [ i ] ] ; if ( this_mode != NEWMV ) clamp_mv2 ( & cur_mv [ i ] . as_mv , xd ) ; if ( mv_check_bounds ( x , & cur_mv [ i ] . as_mv ) ) return INT64_MAX ; mbmi -> mv [ i ] . as_int = cur_mv [ i ] . as_int ; } for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { orig_dst [ i ] = xd -> plane [ i ] . dst . buf ; orig_dst_stride [ i ] = xd -> plane [ i ] . dst . stride ; } * rate2 += cost_mv_ref ( cpi , this_mode , mbmi -> mode_context [ refs [ 0 ] ] ) ; if ( ! ( * mode_excluded ) ) * mode_excluded = is_comp_pred ? cm -> reference_mode == SINGLE_REFERENCE : cm -> reference_mode == COMPOUND_REFERENCE ; pred_exists = 0 ; intpel_mv = ! mv_has_subpel ( & mbmi -> mv [ 0 ] . as_mv ) ; if ( is_comp_pred ) intpel_mv &= ! mv_has_subpel ( & mbmi -> mv [ 1 ] . as_mv ) ; cpi -> mask_filter_rd = 0 ; for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) cpi -> rd_filter_cache [ i ] = INT64_MAX ; if ( cm -> interp_filter != BILINEAR ) { * best_filter = EIGHTTAP ; if ( x -> source_variance < cpi -> sf . disable_filter_search_var_thresh ) { * best_filter = EIGHTTAP ; } else { int newbest ; int tmp_rate_sum = 0 ; int64_t tmp_dist_sum = 0 ; for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { int j ; int64_t rs_rd ; mbmi -> interp_filter = i ; rs = vp9_get_switchable_rate ( x ) ; rs_rd = RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ; if ( i > 0 && intpel_mv ) { rd = RDCOST ( x -> rdmult , x -> rddiv , tmp_rate_sum , tmp_dist_sum ) ; cpi -> rd_filter_cache [ i ] = rd ; cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; if ( cm -> interp_filter == SWITCHABLE ) rd += rs_rd ; cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ; } else { int rate_sum = 0 ; int64_t dist_sum = 0 ; if ( ( cm -> interp_filter == SWITCHABLE && ( ! i || best_needs_copy ) ) || ( cm -> interp_filter != SWITCHABLE && ( cm -> interp_filter == mbmi -> interp_filter || ( i == 0 && intpel_mv ) ) ) ) { restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; } else { for ( j = 0 ; j < MAX_MB_PLANE ; j ++ ) { xd -> plane [ j ] . dst . buf = tmp_buf + j * 64 * 64 ; xd -> plane [ j ] . dst . stride = 64 ; } } vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ; model_rd_for_sb ( cpi , bsize , x , xd , & rate_sum , & dist_sum ) ; rd = RDCOST ( x -> rdmult , x -> rddiv , rate_sum , dist_sum ) ; cpi -> rd_filter_cache [ i ] = rd ; cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; if ( cm -> interp_filter == SWITCHABLE ) rd += rs_rd ; cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ; if ( i == 0 && intpel_mv ) { tmp_rate_sum = rate_sum ; tmp_dist_sum = dist_sum ; } } if ( i == 0 && cpi -> sf . use_rd_breakout && ref_best_rd < INT64_MAX ) { if ( rd / 2 > ref_best_rd ) { restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } } newbest = i == 0 || rd < best_rd ; if ( newbest ) { best_rd = rd ; * best_filter = mbmi -> interp_filter ; if ( cm -> interp_filter == SWITCHABLE && i && ! intpel_mv ) best_needs_copy = ! best_needs_copy ; } if ( ( cm -> interp_filter == SWITCHABLE && newbest ) || ( cm -> interp_filter != SWITCHABLE && cm -> interp_filter == mbmi -> interp_filter ) ) { pred_exists = 1 ; } } restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; } } mbmi -> interp_filter = cm -> interp_filter != SWITCHABLE ? cm -> interp_filter : * best_filter ; rs = cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( x ) : 0 ; if ( pred_exists ) { if ( best_needs_copy ) { for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { xd -> plane [ i ] . dst . buf = tmp_buf + i * 64 * 64 ; xd -> plane [ i ] . dst . stride = 64 ; } } } else { vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ; } if ( cpi -> sf . use_rd_breakout && ref_best_rd < INT64_MAX ) { int tmp_rate ; int64_t tmp_dist ; model_rd_for_sb ( cpi , bsize , x , xd , & tmp_rate , & tmp_dist ) ; rd = RDCOST ( x -> rdmult , x -> rddiv , rs + tmp_rate , tmp_dist ) ; if ( rd / 2 > ref_best_rd ) { restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } } if ( cm -> interp_filter == SWITCHABLE ) * rate2 += vp9_get_switchable_rate ( x ) ; if ( ! is_comp_pred ) { if ( ! x -> in_active_map ) { if ( psse ) * psse = 0 ; * distortion = 0 ; x -> skip = 1 ; } else if ( cpi -> allow_encode_breakout && x -> encode_breakout ) { const BLOCK_SIZE y_size = get_plane_block_size ( bsize , & xd -> plane [ 0 ] ) ; const BLOCK_SIZE uv_size = get_plane_block_size ( bsize , & xd -> plane [ 1 ] ) ; unsigned int var , sse ; unsigned int thresh_ac ; const unsigned int max_thresh = ( cpi -> allow_encode_breakout == ENCODE_BREAKOUT_LIMITED ) ? 128 : 36000 ; const unsigned int min_thresh = MIN ( ( ( unsigned int ) x -> encode_breakout << 4 ) , max_thresh ) ; thresh_ac = ( xd -> plane [ 0 ] . dequant [ 1 ] * xd -> plane [ 0 ] . dequant [ 1 ] ) / 9 ; thresh_ac = clamp ( thresh_ac , min_thresh , max_thresh ) ; var = cpi -> fn_ptr [ y_size ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , & sse ) ; thresh_ac >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ; if ( sse < thresh_ac || sse == 0 ) { unsigned int thresh_dc ; thresh_dc = ( xd -> plane [ 0 ] . dequant [ 0 ] * xd -> plane [ 0 ] . dequant [ 0 ] >> 6 ) ; if ( ( sse - var ) < thresh_dc || sse == var ) { unsigned int sse_u , sse_v ; unsigned int var_u , var_v ; var_u = cpi -> fn_ptr [ uv_size ] . vf ( x -> plane [ 1 ] . src . buf , x -> plane [ 1 ] . src . stride , xd -> plane [ 1 ] . dst . buf , xd -> plane [ 1 ] . dst . stride , & sse_u ) ; if ( ( sse_u * 4 < thresh_ac || sse_u == 0 ) && ( sse_u - var_u < thresh_dc || sse_u == var_u ) ) { var_v = cpi -> fn_ptr [ uv_size ] . vf ( x -> plane [ 2 ] . src . buf , x -> plane [ 2 ] . src . stride , xd -> plane [ 2 ] . dst . buf , xd -> plane [ 2 ] . dst . stride , & sse_v ) ; if ( ( sse_v * 4 < thresh_ac || sse_v == 0 ) && ( sse_v - var_v < thresh_dc || sse_v == var_v ) ) { x -> skip = 1 ; * rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; * distortion_uv = ( sse_u + sse_v ) << 4 ; * distortion = ( sse << 4 ) + * distortion_uv ; * disable_skip = 1 ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ; } } } } } } if ( ! x -> skip ) { int skippable_y , skippable_uv ; int64_t sseuv = INT64_MAX ; int64_t rdcosty = INT64_MAX ; inter_super_block_yrd ( cpi , x , rate_y , distortion_y , & skippable_y , psse , bsize , txfm_cache , ref_best_rd ) ; if ( * rate_y == INT_MAX ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * rate2 += * rate_y ; * distortion += * distortion_y ; rdcosty = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ; rdcosty = MIN ( rdcosty , RDCOST ( x -> rdmult , x -> rddiv , 0 , * psse ) ) ; super_block_uvrd ( cpi , x , rate_uv , distortion_uv , & skippable_uv , & sseuv , bsize , ref_best_rd - rdcosty ) ; if ( * rate_uv == INT_MAX ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * psse += sseuv ; * rate2 += * rate_uv ; * distortion += * distortion_uv ; * skippable = skippable_y && skippable_uv ; } restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return this_rd ; }
","<S2SV_ModStart> * x , <S2SV_ModEnd> BLOCK_SIZE bsize , <S2SV_ModStart> BLOCK_SIZE bsize , int * rate2 , int64_t * distortion <S2SV_ModEnd> , int * <S2SV_ModStart> , int * skippable <S2SV_ModEnd> , int * <S2SV_ModStart> , int * rate_y , int * rate_uv <S2SV_ModEnd> , int * <S2SV_ModStart> , int * disable_skip <S2SV_ModEnd> , int_mv ( <S2SV_ModStart> , int_mv single_newmv [ MAX_REF_FRAMES ] , INTERP_FILTER ( * single_filter ) [ MAX_REF_FRAMES ] , int ( * single_skippable ) <S2SV_ModStart> const int64_t ref_best_rd , int64_t * mask_filter , int64_t filter_cache [ ] <S2SV_ModStart> ] -> mbmi ; MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext <S2SV_ModStart> ; const int <S2SV_ModEnd> this_mode = mbmi <S2SV_ModStart> 2 ] ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> ( 16 , uint16_t , tmp_buf16 [ MAX_MB_PLANE * 64 * 64 ] ) ; uint8_t * tmp_buf ; # else DECLARE_ALIGNED ( 16 , uint8_t , tmp_buf [ <S2SV_ModEnd> MAX_MB_PLANE * 64 <S2SV_ModStart> 64 * 64 ] ) ; # endif <S2SV_ModEnd> int pred_exists = <S2SV_ModStart> int64_t rd , tmp_rd , <S2SV_ModStart> = 0 ; INTERP_FILTER best_filter = SWITCHABLE ; uint8_t skip_txfm [ MAX_MB_PLANE << 2 ] = { 0 } ; int64_t bsse [ MAX_MB_PLANE << 2 ] = { 0 } ; int bsl = mi_width_log2_lookup [ bsize ] ; int pred_filter_search = cpi -> sf . cb_pred_filter_search ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ; int skip_txfm_sb = 0 ; int64_t skip_sse_sb = INT64_MAX ; int64_t distortion_y = 0 , distortion_uv = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { tmp_buf = CONVERT_TO_BYTEPTR ( tmp_buf16 ) ; } else { tmp_buf = ( uint8_t * ) tmp_buf16 ; } # endif if ( pred_filter_search ) { INTERP_FILTER af = SWITCHABLE , lf = SWITCHABLE ; if ( xd -> up_available ) af = xd -> mi [ - xd -> mi_stride ] -> mbmi . interp_filter ; if ( xd -> left_available ) lf = xd -> mi [ - 1 ] -> mbmi . interp_filter ; if ( ( this_mode != NEWMV ) || ( af == lf ) ) best_filter = af ; } <S2SV_ModStart> return INT64_MAX ; if ( cpi -> sf . adaptive_mode_search ) { if ( single_filter [ this_mode ] [ refs [ 0 ] ] == single_filter [ this_mode ] [ refs [ 1 ] ] ) best_filter = single_filter [ this_mode ] [ refs [ 0 ] ] ; } <S2SV_ModStart> as_mv , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> as_mv , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> , x , <S2SV_ModEnd> bsize , mi_row <S2SV_ModStart> return INT64_MAX ; frame_mv [ refs [ 0 ] ] . as_int = xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = tmp_mv . as_int ; single_newmv [ refs [ 0 ] ] . as_int = tmp_mv . as_int ; if ( discount_newmv_test ( cpi , this_mode , tmp_mv , mode_mv , refs [ 0 ] ) ) { * rate2 += MAX ( ( rate_mv / NEW_MV_DISCOUNT_FACTOR ) , 1 ) ; } else { <S2SV_ModStart> += rate_mv ; } <S2SV_ModEnd> } } for <S2SV_ModStart> ; i < is_comp_pred + 1 <S2SV_ModEnd> ; ++ i <S2SV_ModStart> stride ; } if ( discount_newmv_test ( cpi , this_mode , frame_mv [ refs [ 0 ] ] , mode_mv , refs [ 0 ] ) ) { * rate2 += MIN ( cost_mv_ref ( cpi , this_mode , mbmi_ext -> mode_context [ refs [ 0 ] ] ) , cost_mv_ref ( cpi , NEARESTMV , mbmi_ext -> mode_context [ refs [ 0 ] ] ) ) ; } else { <S2SV_ModStart> , this_mode , mbmi_ext -> mode_context [ refs [ 0 ] ] ) ; } if ( RDCOST ( x -> rdmult , x -> rddiv , * rate2 , 0 ) > ref_best_rd && mbmi -> mode != NEARESTMV ) return INT64_MAX <S2SV_ModEnd> ; pred_exists = <S2SV_ModStart> as_mv ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ++ i ) filter_cache <S2SV_ModEnd> [ i ] <S2SV_ModStart> BILINEAR ) { <S2SV_ModEnd> if ( x <S2SV_ModStart> disable_filter_search_var_thresh ) { <S2SV_ModEnd> best_filter = EIGHTTAP <S2SV_ModStart> ; } else if ( best_filter == SWITCHABLE ) <S2SV_ModStart> int64_t rs_rd ; int tmp_skip_sb = 0 ; int64_t tmp_skip_sse = INT64_MAX ; <S2SV_ModStart> = vp9_get_switchable_rate ( cpi , xd <S2SV_ModEnd> ) ; rs_rd <S2SV_ModStart> tmp_dist_sum ) ; filter_cache <S2SV_ModEnd> [ i ] <S2SV_ModStart> = rd ; filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS ] <S2SV_ModStart> = MIN ( filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS ] <S2SV_ModStart> += rs_rd ; * mask_filter <S2SV_ModEnd> = MAX ( <S2SV_ModStart> = MAX ( * mask_filter <S2SV_ModEnd> , rd ) <S2SV_ModStart> = 0 ; if ( i > 0 && cpi -> sf . adaptive_interp_filter_search && ( cpi -> sf . interp_filter_search_mask & ( 1 << i ) ) ) { rate_sum = INT_MAX ; dist_sum = INT64_MAX ; continue ; } <S2SV_ModStart> , & dist_sum , & tmp_skip_sb , & tmp_skip_sse <S2SV_ModStart> dist_sum ) ; filter_cache <S2SV_ModEnd> [ i ] <S2SV_ModStart> = rd ; filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS ] <S2SV_ModStart> = MIN ( filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS ] <S2SV_ModStart> += rs_rd ; * mask_filter <S2SV_ModEnd> = MAX ( <S2SV_ModStart> = MAX ( * mask_filter <S2SV_ModEnd> , rd ) <S2SV_ModStart> = rd ; <S2SV_ModEnd> best_filter = mbmi <S2SV_ModStart> = 1 ; tmp_rd = best_rd ; skip_txfm_sb = tmp_skip_sb ; skip_sse_sb = tmp_skip_sse ; memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ; <S2SV_ModStart> -> interp_filter : <S2SV_ModEnd> best_filter ; rs <S2SV_ModStart> ? vp9_get_switchable_rate ( cpi , xd <S2SV_ModEnd> ) : 0 <S2SV_ModStart> ; } } rd = tmp_rd + RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ; <S2SV_ModStart> } else { int tmp_rate ; int64_t tmp_dist ; <S2SV_ModStart> bsize ) ; model_rd_for_sb ( cpi , bsize , x , xd , & tmp_rate , & tmp_dist , & skip_txfm_sb , & skip_sse_sb ) ; rd = RDCOST ( x -> rdmult , x -> rddiv , rs + tmp_rate , tmp_dist ) ; memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ; } if ( ! is_comp_pred ) single_filter [ this_mode ] [ refs [ 0 ] ] = mbmi -> interp_filter ; if ( cpi -> sf . adaptive_mode_search ) if ( is_comp_pred ) if ( single_skippable [ this_mode ] [ refs [ 0 ] ] && single_skippable [ this_mode ] [ refs [ 1 ] ] ) memset ( skip_txfm , SKIP_TXFM_AC_DC , sizeof ( skip_txfm ) ) ; <S2SV_ModEnd> if ( cpi <S2SV_ModStart> INT64_MAX ) { <S2SV_ModEnd> if ( rd <S2SV_ModStart> * rate2 += rs ; memcpy ( x -> skip_txfm , skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( x -> bsse , bsse , sizeof ( bsse ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! skip_txfm_sb ) { int skippable_y , skippable_uv ; int64_t sseuv = INT64_MAX ; int64_t rdcosty = INT64_MAX ; vp9_subtract_plane ( x , bsize , 0 ) ; super_block_yrd ( cpi , x , rate_y , & distortion_y , & skippable_y , psse , bsize , ref_best_rd ) ; if ( * rate_y == INT_MAX ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * rate2 += * rate_y ; * distortion += distortion_y ; rdcosty = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ; rdcosty = MIN ( rdcosty , RDCOST ( x -> rdmult , x -> rddiv , 0 , * psse ) ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! super_block_uvrd ( cpi , x , rate_uv , & distortion_uv , & skippable_uv , & sseuv , bsize , ref_best_rd - rdcosty ) ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * psse += sseuv ; * rate2 += * rate_uv <S2SV_ModEnd> ; * distortion <S2SV_ModStart> ; * distortion += distortion_uv ; * skippable = skippable_y && skippable_uv ; } else { <S2SV_ModEnd> x -> skip <S2SV_ModStart> = 1 ; * disable_skip <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ) ; * distortion = skip_sse_sb ; <S2SV_ModEnd> } if ( <S2SV_ModStart> if ( ! is_comp_pred ) single_skippable [ this_mode ] [ refs [ 0 ] ] = * skippable <S2SV_ModEnd> ; restore_dst_buf ( <S2SV_ModStart> ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int64_t txfm_cache [ ] , <S2SV_EndBug> <S2SV_StartBug> int * rate2 , int64_t * distortion , <S2SV_EndBug> <S2SV_StartBug> int * skippable , <S2SV_EndBug> <S2SV_StartBug> int * rate_uv , int64_t * distortion_uv , <S2SV_EndBug> <S2SV_StartBug> int_mv single_newmv [ MAX_REF_FRAMES ] , <S2SV_EndBug> <S2SV_StartBug> const int64_t ref_best_rd ) { <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> const int num_refs = is_comp_pred ? 2 : 1 ; <S2SV_EndBug> <S2SV_StartBug> int64_t this_rd = 0 ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , tmp_buf , MAX_MB_PLANE * 64 * 64 ) ; <S2SV_EndBug> <S2SV_StartBug> int64_t rd , best_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> int rs = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> & mbmi -> ref_mvs [ refs [ 0 ] ] [ 0 ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> & mbmi -> ref_mvs [ refs [ 1 ] ] [ 0 ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> single_motion_search ( cpi , x , tile , bsize , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> * rate2 += rate_mv ; <S2SV_EndBug> <S2SV_StartBug> frame_mv [ refs [ 0 ] ] . as_int = <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < num_refs ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> * rate2 += cost_mv_ref ( cpi , this_mode , mbmi -> mode_context [ refs [ 0 ] ] ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> mask_filter_rd = 0 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ i ] = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> * best_filter = EIGHTTAP ; <S2SV_EndBug> <S2SV_StartBug> * best_filter = EIGHTTAP ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> mbmi -> interp_filter = i ; <S2SV_EndBug> <S2SV_StartBug> rs = vp9_get_switchable_rate ( x ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ i ] = rd ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = <S2SV_EndBug> <S2SV_StartBug> MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ; <S2SV_EndBug> <S2SV_StartBug> int64_t dist_sum = 0 ; <S2SV_EndBug> <S2SV_StartBug> model_rd_for_sb ( cpi , bsize , x , xd , & rate_sum , & dist_sum ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ i ] = rd ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = <S2SV_EndBug> <S2SV_StartBug> MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ; <S2SV_EndBug> <S2SV_StartBug> * best_filter = mbmi -> interp_filter ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cm -> interp_filter : * best_filter ; <S2SV_EndBug> <S2SV_StartBug> rs = cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( x ) : 0 ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> int tmp_rate ; <S2SV_EndBug> <S2SV_StartBug> * rate2 += vp9_get_switchable_rate ( x ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! is_comp_pred ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> in_active_map ) { <S2SV_EndBug> <S2SV_StartBug> * distortion = 0 ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> allow_encode_breakout && x -> encode_breakout ) { <S2SV_EndBug> <S2SV_StartBug> * distortion_uv = ( sse_u + sse_v ) << 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> skip ) { <S2SV_EndBug> <S2SV_StartBug> return INT64_MAX ; <S2SV_EndBug>"
352,CWE-119,"ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ; ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ; return len ; }
","<S2SV_ModStart> id ) { size_t ss = <S2SV_ModEnd> CDF_SHORT_SEC_SIZE ( h <S2SV_ModStart> ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> len ) ; if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( ""bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n"" , id , sst -> sst_len ) ) ; return - 1 ; } <S2SV_ModStart> sst_tab ) + pos <S2SV_ModEnd> , len )
",glensc@file/1859fdb4e67c49c463c4e0078054335cd46ba295,CVE-2012-1571,https://github.com/glensc/file/commit/1859fdb4e67c49c463c4e0078054335cd46ba295,2012-07-17T21:55Z,"<S2SV_StartBug> assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ; <S2SV_EndBug>"
5022,CWE-119,"static int ssh_packet_set_postauth ( struct ssh * ssh ) { struct sshcomp * comp ; int r , mode ; debug ( ""%s:<S2SV_blank>called"" , __func__ ) ; ssh -> state -> after_authentication = 1 ; ssh -> state -> rekeying = 0 ; for ( mode = 0 ; mode < MODE_MAX ; mode ++ ) { if ( ssh -> state -> newkeys [ mode ] == NULL ) continue ; comp = & ssh -> state -> newkeys [ mode ] -> comp ; if ( comp && comp -> enabled && ( r = ssh_packet_init_compression ( ssh ) ) != 0 ) return r ; } return 0 ; }
","<S2SV_ModStart> ssh ) { int r <S2SV_ModEnd> ; debug ( <S2SV_ModStart> = 0 ; if ( <S2SV_ModEnd> ( r = <S2SV_ModStart> ( r = ssh_packet_enable_delayed_compress <S2SV_ModEnd> ( ssh ) <S2SV_ModStart> return r ; <S2SV_ModEnd> return 0 ;
",openbsd@src/3095060f479b86288e31c79ecbc5131a66bcd2f9,CVE-2016-10012,https://github.com/openbsd/src/commit/3095060f479b86288e31c79ecbc5131a66bcd2f9,2017-01-05T02:59Z,<S2SV_StartBug> struct sshcomp * comp ; <S2SV_EndBug> <S2SV_StartBug> for ( mode = 0 ; mode < MODE_MAX ; mode ++ ) { <S2SV_EndBug> <S2SV_StartBug> ( r = ssh_packet_init_compression ( ssh ) ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
513,CWE-119,"static int start_decoder ( vorb * f ) { uint8 header [ 6 ] , x , y ; int len , i , j , k , max_submaps = 0 ; int longest_floorlist = 0 ; if ( ! start_page ( f ) ) return FALSE ; if ( ! ( f -> page_flag & PAGEFLAG_first_page ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_last_page ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_continued_packet ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segment_count != 1 ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segments [ 0 ] != 30 ) return error ( f , VORBIS_invalid_first_page ) ; if ( get8 ( f ) != VORBIS_packet_id ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! getn ( f , header , 6 ) ) return error ( f , VORBIS_unexpected_eof ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( get32 ( f ) != 0 ) return error ( f , VORBIS_invalid_first_page ) ; f -> channels = get8 ( f ) ; if ( ! f -> channels ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> channels > STB_VORBIS_MAX_CHANNELS ) return error ( f , VORBIS_too_many_channels ) ; f -> sample_rate = get32 ( f ) ; if ( ! f -> sample_rate ) return error ( f , VORBIS_invalid_first_page ) ; get32 ( f ) ; get32 ( f ) ; get32 ( f ) ; x = get8 ( f ) ; { int log0 , log1 ; log0 = x & 15 ; log1 = x >> 4 ; f -> blocksize_0 = 1 << log0 ; f -> blocksize_1 = 1 << log1 ; if ( log0 < 6 || log0 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log1 < 6 || log1 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log0 > log1 ) return error ( f , VORBIS_invalid_setup ) ; } x = get8 ( f ) ; if ( ! ( x & 1 ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! start_page ( f ) ) return FALSE ; if ( ! start_packet ( f ) ) return FALSE ; do { len = next_segment ( f ) ; skip ( f , len ) ; f -> bytes_in_seg = 0 ; } while ( len ) ; if ( ! start_packet ( f ) ) return FALSE ; # ifndef STB_VORBIS_NO_PUSHDATA_API if ( IS_PUSH_MODE ( f ) ) { if ( ! is_whole_packet_present ( f , TRUE ) ) { if ( f -> error == VORBIS_invalid_stream ) f -> error = VORBIS_invalid_setup ; return FALSE ; } } # endif crc32_init ( ) ; if ( get8_packet ( f ) != VORBIS_packet_setup ) return error ( f , VORBIS_invalid_setup ) ; for ( i = 0 ; i < 6 ; ++ i ) header [ i ] = get8_packet ( f ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_setup ) ; f -> codebook_count = get_bits ( f , 8 ) + 1 ; f -> codebooks = ( Codebook * ) setup_malloc ( f , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; if ( f -> codebooks == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> codebooks , 0 , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; for ( i = 0 ; i < f -> codebook_count ; ++ i ) { uint32 * values ; int ordered , sorted_count ; int total = 0 ; uint8 * lengths ; Codebook * c = f -> codebooks + i ; CHECK ( f ) ; x = get_bits ( f , 8 ) ; if ( x != 0x42 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x43 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x56 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; c -> dimensions = ( get_bits ( f , 8 ) << 8 ) + x ; x = get_bits ( f , 8 ) ; y = get_bits ( f , 8 ) ; c -> entries = ( get_bits ( f , 8 ) << 16 ) + ( y << 8 ) + x ; ordered = get_bits ( f , 1 ) ; c -> sparse = ordered ? 0 : get_bits ( f , 1 ) ; if ( c -> dimensions == 0 && c -> entries != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> sparse ) lengths = ( uint8 * ) setup_temp_malloc ( f , c -> entries ) ; else lengths = c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( ! lengths ) return error ( f , VORBIS_outofmem ) ; if ( ordered ) { int current_entry = 0 ; int current_length = get_bits ( f , 5 ) + 1 ; while ( current_entry < c -> entries ) { int limit = c -> entries - current_entry ; int n = get_bits ( f , ilog ( limit ) ) ; if ( current_entry + n > ( int ) c -> entries ) { return error ( f , VORBIS_invalid_setup ) ; } memset ( lengths + current_entry , current_length , n ) ; current_entry += n ; ++ current_length ; } } else { for ( j = 0 ; j < c -> entries ; ++ j ) { int present = c -> sparse ? get_bits ( f , 1 ) : 1 ; if ( present ) { lengths [ j ] = get_bits ( f , 5 ) + 1 ; ++ total ; if ( lengths [ j ] == 32 ) return error ( f , VORBIS_invalid_setup ) ; } else { lengths [ j ] = NO_CODE ; } } } if ( c -> sparse && total >= c -> entries >> 2 ) { if ( c -> entries > ( int ) f -> setup_temp_memory_required ) f -> setup_temp_memory_required = c -> entries ; c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( c -> codeword_lengths == NULL ) return error ( f , VORBIS_outofmem ) ; memcpy ( c -> codeword_lengths , lengths , c -> entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; lengths = c -> codeword_lengths ; c -> sparse = 0 ; } if ( c -> sparse ) { sorted_count = total ; } else { sorted_count = 0 ; # ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH for ( j = 0 ; j < c -> entries ; ++ j ) if ( lengths [ j ] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths [ j ] != NO_CODE ) ++ sorted_count ; # endif } c -> sorted_entries = sorted_count ; values = NULL ; CHECK ( f ) ; if ( ! c -> sparse ) { c -> codewords = ( uint32 * ) setup_malloc ( f , sizeof ( c -> codewords [ 0 ] ) * c -> entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; } else { unsigned int size ; if ( c -> sorted_entries ) { c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> sorted_entries ) ; if ( ! c -> codeword_lengths ) return error ( f , VORBIS_outofmem ) ; c -> codewords = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; values = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * values ) * c -> sorted_entries ) ; if ( ! values ) return error ( f , VORBIS_outofmem ) ; } size = c -> entries + ( sizeof ( * c -> codewords ) + sizeof ( * values ) ) * c -> sorted_entries ; if ( size > f -> setup_temp_memory_required ) f -> setup_temp_memory_required = size ; } if ( ! compute_codewords ( c , lengths , c -> entries , values ) ) { if ( c -> sparse ) setup_temp_free ( f , values , 0 ) ; return error ( f , VORBIS_invalid_setup ) ; } if ( c -> sorted_entries ) { c -> sorted_codewords = ( uint32 * ) setup_malloc ( f , sizeof ( * c -> sorted_codewords ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_codewords == NULL ) return error ( f , VORBIS_outofmem ) ; c -> sorted_values = ( int * ) setup_malloc ( f , sizeof ( * c -> sorted_values ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_values == NULL ) return error ( f , VORBIS_outofmem ) ; ++ c -> sorted_values ; c -> sorted_values [ - 1 ] = - 1 ; compute_sorted_huffman ( c , lengths , values ) ; } if ( c -> sparse ) { setup_temp_free ( f , values , sizeof ( * values ) * c -> sorted_entries ) ; setup_temp_free ( f , c -> codewords , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; c -> codewords = NULL ; } compute_accelerated_huffman ( c ) ; CHECK ( f ) ; c -> lookup_type = get_bits ( f , 4 ) ; if ( c -> lookup_type > 2 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> lookup_type > 0 ) { uint16 * mults ; c -> minimum_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> delta_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> value_bits = get_bits ( f , 4 ) + 1 ; c -> sequence_p = get_bits ( f , 1 ) ; if ( c -> lookup_type == 1 ) { c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ; } else { c -> lookup_values = c -> entries * c -> dimensions ; } if ( c -> lookup_values == 0 ) return error ( f , VORBIS_invalid_setup ) ; mults = ( uint16 * ) setup_temp_malloc ( f , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; if ( mults == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { int q = get_bits ( f , c -> value_bits ) ; if ( q == EOP ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } mults [ j ] = q ; } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK if ( c -> lookup_type == 1 ) { int len , sparse = c -> sparse ; float last = 0 ; if ( sparse ) { if ( c -> sorted_entries == 0 ) goto skip ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> sorted_entries * c -> dimensions ) ; } else c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> entries * c -> dimensions ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } len = sparse ? c -> sorted_entries : c -> entries ; for ( j = 0 ; j < len ; ++ j ) { unsigned int z = sparse ? c -> sorted_values [ j ] : j ; unsigned int div = 1 ; for ( k = 0 ; k < c -> dimensions ; ++ k ) { int off = ( z / div ) % c -> lookup_values ; float val = mults [ off ] ; val = mults [ off ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j * c -> dimensions + k ] = val ; if ( c -> sequence_p ) last = val ; if ( k + 1 < c -> dimensions ) { if ( div > UINT_MAX / ( unsigned int ) c -> lookup_values ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } div *= c -> lookup_values ; } } } c -> lookup_type = 2 ; } else # endif { float last = 0 ; CHECK ( f ) ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> lookup_values ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { float val = mults [ j ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j ] = val ; if ( c -> sequence_p ) last = val ; } } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK skip : ; # endif setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; CHECK ( f ) ; } CHECK ( f ) ; } x = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < x ; ++ i ) { uint32 z = get_bits ( f , 16 ) ; if ( z != 0 ) return error ( f , VORBIS_invalid_setup ) ; } f -> floor_count = get_bits ( f , 6 ) + 1 ; f -> floor_config = ( Floor * ) setup_malloc ( f , f -> floor_count * sizeof ( * f -> floor_config ) ) ; if ( f -> floor_config == NULL ) return error ( f , VORBIS_outofmem ) ; for ( i = 0 ; i < f -> floor_count ; ++ i ) { f -> floor_types [ i ] = get_bits ( f , 16 ) ; if ( f -> floor_types [ i ] > 1 ) return error ( f , VORBIS_invalid_setup ) ; if ( f -> floor_types [ i ] == 0 ) { Floor0 * g = & f -> floor_config [ i ] . floor0 ; g -> order = get_bits ( f , 8 ) ; g -> rate = get_bits ( f , 16 ) ; g -> bark_map_size = get_bits ( f , 16 ) ; g -> amplitude_bits = get_bits ( f , 6 ) ; g -> amplitude_offset = get_bits ( f , 8 ) ; g -> number_of_books = get_bits ( f , 4 ) + 1 ; for ( j = 0 ; j < g -> number_of_books ; ++ j ) g -> book_list [ j ] = get_bits ( f , 8 ) ; return error ( f , VORBIS_feature_not_supported ) ; } else { stbv__floor_ordering p [ 31 * 8 + 2 ] ; Floor1 * g = & f -> floor_config [ i ] . floor1 ; int max_class = - 1 ; g -> partitions = get_bits ( f , 5 ) ; for ( j = 0 ; j < g -> partitions ; ++ j ) { g -> partition_class_list [ j ] = get_bits ( f , 4 ) ; if ( g -> partition_class_list [ j ] > max_class ) max_class = g -> partition_class_list [ j ] ; } for ( j = 0 ; j <= max_class ; ++ j ) { g -> class_dimensions [ j ] = get_bits ( f , 3 ) + 1 ; g -> class_subclasses [ j ] = get_bits ( f , 2 ) ; if ( g -> class_subclasses [ j ] ) { g -> class_masterbooks [ j ] = get_bits ( f , 8 ) ; if ( g -> class_masterbooks [ j ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } for ( k = 0 ; k < 1 << g -> class_subclasses [ j ] ; ++ k ) { g -> subclass_books [ j ] [ k ] = get_bits ( f , 8 ) - 1 ; if ( g -> subclass_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } } g -> floor1_multiplier = get_bits ( f , 2 ) + 1 ; g -> rangebits = get_bits ( f , 4 ) ; g -> Xlist [ 0 ] = 0 ; g -> Xlist [ 1 ] = 1 << g -> rangebits ; g -> values = 2 ; for ( j = 0 ; j < g -> partitions ; ++ j ) { int c = g -> partition_class_list [ j ] ; for ( k = 0 ; k < g -> class_dimensions [ c ] ; ++ k ) { g -> Xlist [ g -> values ] = get_bits ( f , g -> rangebits ) ; ++ g -> values ; } } for ( j = 0 ; j < g -> values ; ++ j ) { p [ j ] . x = g -> Xlist [ j ] ; p [ j ] . id = j ; } qsort ( p , g -> values , sizeof ( p [ 0 ] ) , point_compare ) ; for ( j = 0 ; j < g -> values ; ++ j ) g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ; for ( j = 2 ; j < g -> values ; ++ j ) { int low , hi ; neighbors ( g -> Xlist , j , & low , & hi ) ; g -> neighbors [ j ] [ 0 ] = low ; g -> neighbors [ j ] [ 1 ] = hi ; } if ( g -> values > longest_floorlist ) longest_floorlist = g -> values ; } } f -> residue_count = get_bits ( f , 6 ) + 1 ; f -> residue_config = ( Residue * ) setup_malloc ( f , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; if ( f -> residue_config == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> residue_config , 0 , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { uint8 residue_cascade [ 64 ] ; Residue * r = f -> residue_config + i ; f -> residue_types [ i ] = get_bits ( f , 16 ) ; if ( f -> residue_types [ i ] > 2 ) return error ( f , VORBIS_invalid_setup ) ; r -> begin = get_bits ( f , 24 ) ; r -> end = get_bits ( f , 24 ) ; if ( r -> end < r -> begin ) return error ( f , VORBIS_invalid_setup ) ; r -> part_size = get_bits ( f , 24 ) + 1 ; r -> classifications = get_bits ( f , 6 ) + 1 ; r -> classbook = get_bits ( f , 8 ) ; if ( r -> classbook >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { uint8 high_bits = 0 ; uint8 low_bits = get_bits ( f , 3 ) ; if ( get_bits ( f , 1 ) ) high_bits = get_bits ( f , 5 ) ; residue_cascade [ j ] = high_bits * 8 + low_bits ; } r -> residue_books = ( short ( * ) [ 8 ] ) setup_malloc ( f , sizeof ( r -> residue_books [ 0 ] ) * r -> classifications ) ; if ( r -> residue_books == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { for ( k = 0 ; k < 8 ; ++ k ) { if ( residue_cascade [ j ] & ( 1 << k ) ) { r -> residue_books [ j ] [ k ] = get_bits ( f , 8 ) ; if ( r -> residue_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } else { r -> residue_books [ j ] [ k ] = - 1 ; } } } r -> classdata = ( uint8 * * ) setup_malloc ( f , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; if ( ! r -> classdata ) return error ( f , VORBIS_outofmem ) ; memset ( r -> classdata , 0 , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; for ( j = 0 ; j < f -> codebooks [ r -> classbook ] . entries ; ++ j ) { int classwords = f -> codebooks [ r -> classbook ] . dimensions ; int temp = j ; r -> classdata [ j ] = ( uint8 * ) setup_malloc ( f , sizeof ( r -> classdata [ j ] [ 0 ] ) * classwords ) ; if ( r -> classdata [ j ] == NULL ) return error ( f , VORBIS_outofmem ) ; for ( k = classwords - 1 ; k >= 0 ; -- k ) { r -> classdata [ j ] [ k ] = temp % r -> classifications ; temp /= r -> classifications ; } } } f -> mapping_count = get_bits ( f , 6 ) + 1 ; f -> mapping = ( Mapping * ) setup_malloc ( f , f -> mapping_count * sizeof ( * f -> mapping ) ) ; if ( f -> mapping == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> mapping , 0 , f -> mapping_count * sizeof ( * f -> mapping ) ) ; for ( i = 0 ; i < f -> mapping_count ; ++ i ) { Mapping * m = f -> mapping + i ; int mapping_type = get_bits ( f , 16 ) ; if ( mapping_type != 0 ) return error ( f , VORBIS_invalid_setup ) ; m -> chan = ( MappingChannel * ) setup_malloc ( f , f -> channels * sizeof ( * m -> chan ) ) ; if ( m -> chan == NULL ) return error ( f , VORBIS_outofmem ) ; if ( get_bits ( f , 1 ) ) m -> submaps = get_bits ( f , 4 ) + 1 ; else m -> submaps = 1 ; if ( m -> submaps > max_submaps ) max_submaps = m -> submaps ; if ( get_bits ( f , 1 ) ) { m -> coupling_steps = get_bits ( f , 8 ) + 1 ; for ( k = 0 ; k < m -> coupling_steps ; ++ k ) { m -> chan [ k ] . magnitude = get_bits ( f , ilog ( f -> channels - 1 ) ) ; m -> chan [ k ] . angle = get_bits ( f , ilog ( f -> channels - 1 ) ) ; if ( m -> chan [ k ] . magnitude >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . angle >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . magnitude == m -> chan [ k ] . angle ) return error ( f , VORBIS_invalid_setup ) ; } } else m -> coupling_steps = 0 ; if ( get_bits ( f , 2 ) ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submaps > 1 ) { for ( j = 0 ; j < f -> channels ; ++ j ) { m -> chan [ j ] . mux = get_bits ( f , 4 ) ; if ( m -> chan [ j ] . mux >= m -> submaps ) return error ( f , VORBIS_invalid_setup ) ; } } else for ( j = 0 ; j < f -> channels ; ++ j ) m -> chan [ j ] . mux = 0 ; for ( j = 0 ; j < m -> submaps ; ++ j ) { get_bits ( f , 8 ) ; m -> submap_floor [ j ] = get_bits ( f , 8 ) ; m -> submap_residue [ j ] = get_bits ( f , 8 ) ; if ( m -> submap_floor [ j ] >= f -> floor_count ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submap_residue [ j ] >= f -> residue_count ) return error ( f , VORBIS_invalid_setup ) ; } } f -> mode_count = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < f -> mode_count ; ++ i ) { Mode * m = f -> mode_config + i ; m -> blockflag = get_bits ( f , 1 ) ; m -> windowtype = get_bits ( f , 16 ) ; m -> transformtype = get_bits ( f , 16 ) ; m -> mapping = get_bits ( f , 8 ) ; if ( m -> windowtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> transformtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> mapping >= f -> mapping_count ) return error ( f , VORBIS_invalid_setup ) ; } flush_packet ( f ) ; f -> previous_length = 0 ; for ( i = 0 ; i < f -> channels ; ++ i ) { f -> channel_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 ) ; f -> previous_window [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; f -> finalY [ i ] = ( int16 * ) setup_malloc ( f , sizeof ( int16 ) * longest_floorlist ) ; if ( f -> channel_buffers [ i ] == NULL || f -> previous_window [ i ] == NULL || f -> finalY [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; # ifdef STB_VORBIS_NO_DEFER_FLOOR f -> floor_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; if ( f -> floor_buffers [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; # endif } if ( ! init_blocksize ( f , 0 , f -> blocksize_0 ) ) return FALSE ; if ( ! init_blocksize ( f , 1 , f -> blocksize_1 ) ) return FALSE ; f -> blocksize [ 0 ] = f -> blocksize_0 ; f -> blocksize [ 1 ] = f -> blocksize_1 ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( integer_divide_table [ 1 ] [ 1 ] == 0 ) for ( i = 0 ; i < DIVTAB_NUMER ; ++ i ) for ( j = 1 ; j < DIVTAB_DENOM ; ++ j ) integer_divide_table [ i ] [ j ] = i / j ; # endif { uint32 imdct_mem = ( f -> blocksize_1 * sizeof ( float ) >> 1 ) ; uint32 classify_mem ; int i , max_part_read = 0 ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { Residue * r = f -> residue_config + i ; int n_read = r -> end - r -> begin ; int part_read = n_read / r -> part_size ; if ( part_read > max_part_read ) max_part_read = part_read ; } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( uint8 * ) ) ; # else classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( int * ) ) ; # endif f -> temp_memory_required = classify_mem ; if ( imdct_mem > f -> temp_memory_required ) f -> temp_memory_required = imdct_mem ; } f -> first_decode = TRUE ; if ( f -> alloc . alloc_buffer ) { assert ( f -> temp_offset == f -> alloc . alloc_buffer_length_in_bytes ) ; if ( f -> setup_offset + sizeof ( * f ) + f -> temp_memory_required > ( unsigned ) f -> temp_offset ) return error ( f , VORBIS_outofmem ) ; } f -> first_audio_page_offset = stb_vorbis_get_file_offset ( f ) ; return TRUE ; }
","<S2SV_ModStart> + i ; unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; <S2SV_ModStart> int n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int part_read
",nothings@stb/244d83bc3d859293f55812d48b3db168e581f6ab,CVE-2018-1000050,https://github.com/nothings/stb/commit/244d83bc3d859293f55812d48b3db168e581f6ab,2018-02-09T23:29Z,<S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug>
8472,CWE-787,"void gps_tracker ( void ) { ssize_t unused ; int gpsd_sock ; char line [ 256 ] , * temp ; struct sockaddr_in gpsd_addr ; int ret , is_json , pos ; fd_set read_fd ; struct timeval timeout ; pos = 0 ; gpsd_sock = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( gpsd_sock < 0 ) { return ; } gpsd_addr . sin_family = AF_INET ; gpsd_addr . sin_port = htons ( 2947 ) ; gpsd_addr . sin_addr . s_addr = inet_addr ( ""127.0.0.1"" ) ; if ( connect ( gpsd_sock , ( struct sockaddr * ) & gpsd_addr , sizeof ( gpsd_addr ) ) < 0 ) { return ; } FD_ZERO ( & read_fd ) ; FD_SET ( gpsd_sock , & read_fd ) ; timeout . tv_sec = 1 ; timeout . tv_usec = 0 ; is_json = select ( gpsd_sock + 1 , & read_fd , NULL , NULL , & timeout ) ; if ( is_json ) { if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; is_json = ( line [ 0 ] == '{' ) ; if ( is_json ) { memset ( line , 0 , sizeof ( line ) ) ; strcpy ( line , ""?WATCH={\\""json\\"":true};\\n"" ) ; if ( send ( gpsd_sock , line , 22 , 0 ) != 22 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( strncmp ( line , ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"" , 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } else { pos = strlen ( line ) ; } } } while ( G . do_exit == 0 ) { usleep ( 500000 ) ; memset ( G . gps_loc , 0 , sizeof ( float ) * 5 ) ; if ( is_json ) { if ( pos == sizeof ( line ) ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; temp = strstr ( line , ""{\\""class\\"":\\""TPV\\"""" ) ; if ( temp == NULL ) { continue ; } if ( strchr ( temp , '}' ) == NULL ) { pos = strlen ( temp ) ; if ( temp != line ) { memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } temp = strstr ( temp , ""\\""lat\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 0 ] ) ; temp = strstr ( temp , ""\\""lon\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 1 ] ) ; temp = strstr ( temp , ""\\""alt\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 4 ] ) ; temp = strstr ( temp , ""\\""speed\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 2 ] ) ; temp = strstr ( temp , ""{\\""class\\"":\\""TPV\\"""" ) ; if ( temp == NULL ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } else { pos = strlen ( temp ) ; memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } else { memset ( line , 0 , sizeof ( line ) ) ; snprintf ( line , sizeof ( line ) - 1 , ""PVTAD\\r\\n"" ) ; if ( send ( gpsd_sock , line , 7 , 0 ) != 7 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( memcmp ( line , ""GPSD,P="" , 7 ) != 0 ) continue ; if ( line [ 7 ] == '?' ) continue ; ret = sscanf ( line + 7 , ""%f<S2SV_blank>%f"" , & G . gps_loc [ 0 ] , & G . gps_loc [ 1 ] ) ; if ( ( temp = strstr ( line , ""V="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 2 ] ) ; if ( ( temp = strstr ( line , ""T="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 3 ] ) ; if ( ( temp = strstr ( line , ""A="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 4 ] ) ; } if ( G . record_data ) fputs ( line , G . f_gps ) ; G . save_gps = 1 ; if ( G . do_exit == 0 ) { unused = write ( G . gc_pipe [ 1 ] , G . gps_loc , sizeof ( float ) * 5 ) ; kill ( getppid ( ) , SIGUSR2 ) ; } } }
","<S2SV_ModStart> line ) - pos -
",aircrack-ng@aircrack-ng/ff70494dd389ba570dbdbf36f217c28d4381c6b5,CVE-2014-8321,https://github.com/aircrack-ng/aircrack-ng/commit/ff70494dd389ba570dbdbf36f217c28d4381c6b5,2020-01-31T22:15Z,"<S2SV_StartBug> if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 ) <S2SV_EndBug>"
1417,CWE-119,"static unsigned int tt_activity_measure ( VP8_COMP * cpi , MACROBLOCK * x ) { unsigned int act ; unsigned int sse ; act = vp8_variance16x16 ( x -> src . y_buffer , x -> src . y_stride , VP8_VAR_OFFS , 0 , & sse ) ; act = act << 4 ; if ( act < 8 << 12 ) act = act < 5 << 12 ? act : 5 << 12 ; return act ; }
","<S2SV_ModStart> int sse ; ( void ) cpi ; act = vpx_variance16x16 <S2SV_ModEnd> ( x ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> act = vp8_variance16x16 ( x -> src . y_buffer , <S2SV_EndBug>"
7640,CWE-190,"int pgx_validate ( jas_stream_t * in ) { uchar buf [ PGX_MAGICLEN ] ; uint_fast32_t magic ; int i ; int n ; assert ( JAS_STREAM_MAXPUTBACK >= PGX_MAGICLEN ) ; if ( ( n = jas_stream_read ( in , buf , PGX_MAGICLEN ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < PGX_MAGICLEN ) { return - 1 ; } magic = ( buf [ 0 ] << 8 ) | buf [ 1 ] ; if ( magic != PGX_MAGIC ) { return - 1 ; } return 0 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ PGX_MAGICLEN
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> uchar buf [ PGX_MAGICLEN ] ; <S2SV_EndBug>
3171,CWE-190,"static pngquant_error rwpng_read_image24_libpng ( FILE * infile , png24_image * mainprog_ptr , int verbose ) { png_structp png_ptr = NULL ; png_infop info_ptr = NULL ; png_size_t rowbytes ; int color_type , bit_depth ; png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , mainprog_ptr , rwpng_error_handler , verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler ) ; if ( ! png_ptr ) { return PNG_OUT_OF_MEMORY_ERROR ; } info_ptr = png_create_info_struct ( png_ptr ) ; if ( ! info_ptr ) { png_destroy_read_struct ( & png_ptr , NULL , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( setjmp ( mainprog_ptr -> jmpbuf ) ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return LIBPNG_FATAL_ERROR ; } # if defined ( PNG_SKIP_sRGB_CHECK_PROFILE ) && defined ( PNG_SET_OPTION_SUPPORTED ) png_set_option ( png_ptr , PNG_SKIP_sRGB_CHECK_PROFILE , PNG_OPTION_ON ) ; # endif # if PNG_LIBPNG_VER >= 10500 && defined ( PNG_UNKNOWN_CHUNKS_SUPPORTED ) png_set_keep_unknown_chunks ( png_ptr , PNG_HANDLE_CHUNK_IF_SAFE , ( png_const_bytep ) ""pHYs\\0iTXt\\0tEXt\\0zTXt"" , 4 ) ; # endif png_set_read_user_chunk_fn ( png_ptr , & mainprog_ptr -> chunks , read_chunk_callback ) ; struct rwpng_read_data read_data = { infile , 0 } ; png_set_read_fn ( png_ptr , & read_data , user_read_data ) ; png_read_info ( png_ptr , info_ptr ) ; png_get_IHDR ( png_ptr , info_ptr , & mainprog_ptr -> width , & mainprog_ptr -> height , & bit_depth , & color_type , NULL , NULL , NULL ) ; if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( ! ( color_type & PNG_COLOR_MASK_ALPHA ) ) { # ifdef PNG_READ_FILLER_SUPPORTED png_set_expand ( png_ptr ) ; png_set_filler ( png_ptr , 65535L , PNG_FILLER_AFTER ) ; # else fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>image<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>RGBA<S2SV_blank>nor<S2SV_blank>GA\\n"" ) ; png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; mainprog_ptr -> retval = WRONG_INPUT_COLOR_TYPE ; return mainprog_ptr -> retval ; # endif } if ( bit_depth == 16 ) { png_set_strip_16 ( png_ptr ) ; } if ( ! ( color_type & PNG_COLOR_MASK_COLOR ) ) { png_set_gray_to_rgb ( png_ptr ) ; } double gamma = 0.45455 ; if ( png_get_valid ( png_ptr , info_ptr , PNG_INFO_sRGB ) ) { mainprog_ptr -> input_color = RWPNG_SRGB ; mainprog_ptr -> output_color = RWPNG_SRGB ; } else { png_get_gAMA ( png_ptr , info_ptr , & gamma ) ; if ( gamma > 0 && gamma <= 1.0 ) { mainprog_ptr -> input_color = RWPNG_GAMA_ONLY ; mainprog_ptr -> output_color = RWPNG_GAMA_ONLY ; } else { fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>ignored<S2SV_blank>out-of-range<S2SV_blank>gamma<S2SV_blank>%f\\n"" , gamma ) ; mainprog_ptr -> input_color = RWPNG_NONE ; mainprog_ptr -> output_color = RWPNG_NONE ; gamma = 0.45455 ; } } mainprog_ptr -> gamma = gamma ; png_set_interlace_handling ( png_ptr ) ; png_read_update_info ( png_ptr , info_ptr ) ; rowbytes = png_get_rowbytes ( png_ptr , info_ptr ) ; if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) { fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\n"" ) ; png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } png_bytepp row_pointers = rwpng_create_row_pointers ( info_ptr , png_ptr , mainprog_ptr -> rgba_data , mainprog_ptr -> height , 0 ) ; png_read_image ( png_ptr , row_pointers ) ; png_read_end ( png_ptr , NULL ) ; # if USE_LCMS # if PNG_LIBPNG_VER < 10500 png_charp ProfileData ; # else png_bytep ProfileData ; # endif png_uint_32 ProfileLen ; cmsHPROFILE hInProfile = NULL ; int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR ; if ( png_get_iCCP ( png_ptr , info_ptr , & ( png_charp ) { 0 } , & ( int ) { 0 } , & ProfileData , & ProfileLen ) ) { hInProfile = cmsOpenProfileFromMem ( ProfileData , ProfileLen ) ; cmsColorSpaceSignature colorspace = cmsGetColorSpace ( hInProfile ) ; if ( colorspace == cmsSigRgbData && COLOR_PNG ) { mainprog_ptr -> input_color = RWPNG_ICCP ; mainprog_ptr -> output_color = RWPNG_SRGB ; } else { if ( colorspace == cmsSigGrayData && ! COLOR_PNG ) { mainprog_ptr -> input_color = RWPNG_ICCP_WARN_GRAY ; mainprog_ptr -> output_color = RWPNG_SRGB ; } cmsCloseProfile ( hInProfile ) ; hInProfile = NULL ; } } if ( hInProfile == NULL && COLOR_PNG && ! png_get_valid ( png_ptr , info_ptr , PNG_INFO_sRGB ) && png_get_valid ( png_ptr , info_ptr , PNG_INFO_gAMA ) && png_get_valid ( png_ptr , info_ptr , PNG_INFO_cHRM ) ) { cmsCIExyY WhitePoint ; cmsCIExyYTRIPLE Primaries ; png_get_cHRM ( png_ptr , info_ptr , & WhitePoint . x , & WhitePoint . y , & Primaries . Red . x , & Primaries . Red . y , & Primaries . Green . x , & Primaries . Green . y , & Primaries . Blue . x , & Primaries . Blue . y ) ; WhitePoint . Y = Primaries . Red . Y = Primaries . Green . Y = Primaries . Blue . Y = 1.0 ; cmsToneCurve * GammaTable [ 3 ] ; GammaTable [ 0 ] = GammaTable [ 1 ] = GammaTable [ 2 ] = cmsBuildGamma ( NULL , 1 / gamma ) ; hInProfile = cmsCreateRGBProfile ( & WhitePoint , & Primaries , GammaTable ) ; cmsFreeToneCurve ( GammaTable [ 0 ] ) ; mainprog_ptr -> input_color = RWPNG_GAMA_CHRM ; mainprog_ptr -> output_color = RWPNG_SRGB ; } if ( hInProfile != NULL ) { cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile ( ) ; cmsHTRANSFORM hTransform = cmsCreateTransform ( hInProfile , TYPE_RGBA_8 , hOutProfile , TYPE_RGBA_8 , INTENT_PERCEPTUAL , omp_get_max_threads ( ) > 1 ? cmsFLAGS_NOCACHE : 0 ) ; # pragma omp parallel for if ( mainprog_ptr -> height * mainprog_ptr -> width > 8000 ) schedule ( static ) for ( unsigned int i = 0 ; i < mainprog_ptr -> height ; i ++ ) { cmsDoTransform ( hTransform , row_pointers [ i ] , row_pointers [ i ] , mainprog_ptr -> width ) ; } cmsDeleteTransform ( hTransform ) ; cmsCloseProfile ( hOutProfile ) ; cmsCloseProfile ( hInProfile ) ; mainprog_ptr -> gamma = 0.45455 ; } # endif png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; mainprog_ptr -> file_size = read_data . bytes_read ; mainprog_ptr -> row_pointers = ( unsigned char * * ) row_pointers ; return SUCCESS ; }
","<S2SV_ModStart> NULL ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if (
",pornel@pngquant/b7c217680cda02dddced245d237ebe8c383be285,CVE-2016-5735,https://github.com/pornel/pngquant/commit/b7c217680cda02dddced245d237ebe8c383be285,2017-05-23T04:29Z,<S2SV_StartBug> if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) { <S2SV_EndBug>
3279,CWE-189,"static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; struct page * localpage = NULL ; int ret ; if ( buflen < PAGE_SIZE ) { localpage = alloc_page ( GFP_KERNEL ) ; resp_buf = page_address ( localpage ) ; if ( localpage == NULL ) return - ENOMEM ; args . acl_pages [ 0 ] = localpage ; args . acl_pgbase = 0 ; args . acl_len = PAGE_SIZE ; } else { resp_buf = buf ; buf_to_pages ( buf , buflen , args . acl_pages , & args . acl_pgbase ) ; } ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; if ( res . acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ; else nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ; if ( buf ) { ret = - ERANGE ; if ( res . acl_len > buflen ) goto out_free ; if ( localpage ) memcpy ( buf , resp_buf , res . acl_len ) ; } ret = res . acl_len ; out_free : if ( localpage ) __free_page ( localpage ) ; return ret ; }
","<S2SV_ModStart> [ NFS4ACL_MAXPAGES ] = { NULL , } <S2SV_ModStart> , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { args . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! args . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; <S2SV_ModEnd> ret = nfs4_call_sync <S2SV_ModStart> goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( <S2SV_ModEnd> acl_len > args <S2SV_ModStart> , NULL , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> inode , resp_buf + res . acl_data_offset , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> acl_len > buflen <S2SV_ModStart> goto out_free ; _copy_from_pages <S2SV_ModEnd> ( buf , <S2SV_ModStart> ( buf , pages , res . acl_data_offset , res . acl_len ) ; } ret = <S2SV_ModEnd> acl_len ; out_free <S2SV_ModStart> ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] <S2SV_ModEnd> ) __free_page ( <S2SV_ModStart> ) __free_page ( pages [ i ] ) ; if ( args . acl_scratch ) __free_page ( args . acl_scratch <S2SV_ModEnd> ) ; return
",torvalds@linux/bf118a342f10dafe44b14451a1392c3254629a1f,CVE-2011-4131,https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f,2012-05-17T11:00Z,"<S2SV_StartBug> struct page * pages [ NFS4ACL_MAXPAGES ] ; <S2SV_EndBug> <S2SV_StartBug> struct page * localpage = NULL ; <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> if ( res . acl_len > args . acl_len ) <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res . acl_len > buflen ) <S2SV_EndBug> <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( buf , resp_buf , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> __free_page ( localpage ) ; <S2SV_EndBug>"
7946,CWE-18,"static krb5_error_code iakerb_alloc_context ( iakerb_ctx_id_t * pctx ) { iakerb_ctx_id_t ctx ; krb5_error_code code ; * pctx = NULL ; ctx = k5alloc ( sizeof ( * ctx ) , & code ) ; if ( ctx == NULL ) goto cleanup ; ctx -> defcred = GSS_C_NO_CREDENTIAL ; ctx -> magic = KG_IAKERB_CONTEXT ; ctx -> state = IAKERB_AS_REQ ; ctx -> count = 0 ; code = krb5_gss_init_context ( & ctx -> k5c ) ; if ( code != 0 ) goto cleanup ; * pctx = ctx ; cleanup : if ( code != 0 ) iakerb_release_context ( ctx ) ; return code ; }
","<S2SV_ModStart> iakerb_ctx_id_t * pctx , int initiate <S2SV_ModStart> = 0 ; ctx -> initiate = initiate ; ctx -> established = 0 ;
",krb5@krb5/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,CVE-2015-2696,https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,2015-11-09T03:59Z,<S2SV_StartBug> iakerb_alloc_context ( iakerb_ctx_id_t * pctx ) <S2SV_EndBug> <S2SV_StartBug> code = krb5_gss_init_context ( & ctx -> k5c ) ; <S2SV_EndBug>
2861,CWE-476,"static int crypto_skcipher_init_tfm ( struct crypto_tfm * tfm ) { struct crypto_skcipher * skcipher = __crypto_skcipher_cast ( tfm ) ; struct skcipher_alg * alg = crypto_skcipher_alg ( skcipher ) ; if ( tfm -> __crt_alg -> cra_type == & crypto_blkcipher_type ) return crypto_init_skcipher_ops_blkcipher ( tfm ) ; if ( tfm -> __crt_alg -> cra_type == & crypto_ablkcipher_type || tfm -> __crt_alg -> cra_type == & crypto_givcipher_type ) return crypto_init_skcipher_ops_ablkcipher ( tfm ) ; skcipher -> setkey = alg -> setkey ; skcipher -> encrypt = alg -> encrypt ; skcipher -> decrypt = alg -> decrypt ; skcipher -> ivsize = alg -> ivsize ; skcipher -> keysize = alg -> max_keysize ; if ( alg -> exit ) skcipher -> base . exit = crypto_skcipher_exit_tfm ; if ( alg -> init ) return alg -> init ( skcipher ) ; return 0 ; }
","<S2SV_ModStart> -> setkey = skcipher_setkey <S2SV_ModEnd> ; skcipher ->
",torvalds@linux/9933e113c2e87a9f46a40fde8dafbf801dca1ab9,CVE-2017-9211,https://github.com/torvalds/linux/commit/9933e113c2e87a9f46a40fde8dafbf801dca1ab9,2017-05-23T05:29Z,<S2SV_StartBug> skcipher -> setkey = alg -> setkey ; <S2SV_EndBug>
6490,CWE-000,"void sink ( int argc , char * * argv ) { static BUF buffer ; struct stat stb ; enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , mask , mode , ofd , omode ; off_t size , statbytes ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) do { why = str ; goto screwup ; } while ( 0 ) setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( ""ambiguous<S2SV_blank>target"" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ; if ( * cp ++ == '\\n' ) SCREWUP ( ""unexpected<S2SV_blank><newline>"" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ; if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { if ( iamremote == 0 ) ( void ) atomicio ( vwrite , STDERR_FILENO , buf + 1 , strlen ( buf + 1 ) ) ; if ( buf [ 0 ] == '\\02' ) exit ( 1 ) ; ++ errs ; continue ; } if ( buf [ 0 ] == 'E' ) { ( void ) atomicio ( vwrite , remout , """" , 1 ) ; return ; } if ( ch == '\\n' ) * -- cp = 0 ; cp = buf ; if ( * cp == 'T' ) { setimes ++ ; cp ++ ; mtime . tv_sec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; mtime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; atime . tv_sec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; atime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '\\0' ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; continue ; } if ( * cp != 'C' && * cp != 'D' ) { if ( first ) { run_err ( ""%s"" , cp ) ; exit ( 1 ) ; } SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ; } mode = 0 ; for ( ++ cp ; cp < buf + 5 ; cp ++ ) { if ( * cp < '0' || * cp > '7' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ; mode = ( mode << 3 ) | ( * cp - '0' ) ; } if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ; for ( size = 0 ; isdigit ( * cp ) ; ) size = size * 10 + ( * cp ++ - '0' ) ; if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) { run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ; exit ( 1 ) ; } if ( targisdir ) { static char * namebuf = NULL ; static size_t cursize = 0 ; size_t need ; need = strlen ( targ ) + strlen ( cp ) + 250 ; if ( need > cursize ) { if ( namebuf ) xfree ( namebuf ) ; namebuf = xmalloc ( need ) ; cursize = need ; } ( void ) snprintf ( namebuf , need , ""%s%s%s"" , targ , strcmp ( targ , ""/"" ) ? ""/"" : """" , cp ) ; np = namebuf ; } else np = targ ; curfile = cp ; exists = stat ( np , & stb ) == 0 ; if ( buf [ 0 ] == 'D' ) { int mod_flag = pflag ; if ( ! iamrecursive ) SCREWUP ( ""received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r"" ) ; if ( exists ) { if ( ! S_ISDIR ( stb . st_mode ) ) { errno = ENOTDIR ; goto bad ; } if ( pflag ) ( void ) chmod ( np , mode ) ; } else { mod_flag = 1 ; if ( mkdir ( np , mode | S_IRWXU ) < 0 ) goto bad ; } vect [ 0 ] = xstrdup ( np ) ; sink ( 1 , vect ) ; if ( setimes ) { setimes = 0 ; if ( utimes ( vect [ 0 ] , tv ) < 0 ) run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ; } if ( mod_flag ) ( void ) chmod ( vect [ 0 ] , mode ) ; if ( vect [ 0 ] ) xfree ( vect [ 0 ] ) ; continue ; } omode = mode ; mode |= S_IWUSR ; if ( ( ofd = open ( np , O_WRONLY | O_CREAT , mode ) ) < 0 ) { bad : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; continue ; } ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( ( bp = allocbuf ( & buffer , ofd , 4096 ) ) == NULL ) { ( void ) close ( ofd ) ; continue ; } cp = bp -> buf ; wrerr = NO ; statbytes = 0 ; # ifdef PROGRESS_METER if ( showprogress ) start_progress_meter ( curfile , size , & statbytes ) ; # endif for ( count = i = 0 ; i < size ; i += 4096 ) { amt = 4096 ; if ( i + amt > size ) amt = size - i ; count += amt ; do { j = atomicio ( read , remin , cp , amt ) ; if ( j == 0 ) { run_err ( ""%s"" , j ? strerror ( errno ) : ""dropped<S2SV_blank>connection"" ) ; exit ( 1 ) ; } amt -= j ; cp += j ; statbytes += j ; } while ( amt > 0 ) ; if ( limit_rate ) bwlimit ( 4096 ) ; if ( count == bp -> cnt ) { if ( wrerr == NO ) { if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } } count = 0 ; cp = bp -> buf ; } } # ifdef PROGRESS_METER if ( showprogress ) stop_progress_meter ( ) ; # endif if ( count != 0 && wrerr == NO && atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } if ( wrerr == NO && ftruncate ( ofd , size ) != 0 ) { run_err ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } if ( pflag ) { if ( exists || omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode ) ) { # else if ( chmod ( np , omode ) ) { # endif run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } else { if ( ! exists && omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode & ~ mask ) ) { # else if ( chmod ( np , omode & ~ mask ) ) { # endif run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } if ( close ( ofd ) == - 1 ) { wrerr = YES ; wrerrno = errno ; } ( void ) response ( ) ; if ( setimes && wrerr == NO ) { setimes = 0 ; if ( utimes ( np , tv ) < 0 ) { run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } switch ( wrerr ) { case YES : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( wrerrno ) ) ; break ; case NO : ( void ) atomicio ( vwrite , remout , """" , 1 ) ; break ; case DISPLAYED : break ; } } screwup : run_err ( ""protocol<S2SV_blank>error:<S2SV_blank>%s"" , why ) ; exit ( 1 ) ; }
","<S2SV_ModStart> ; if ( * cp == '\\0' || <S2SV_ModEnd> strchr ( cp <S2SV_ModStart> ) != NULL || <S2SV_ModEnd> strcmp ( cp <S2SV_ModStart> ( cp , ""."" ) == 0 || strcmp ( cp , <S2SV_ModStart> ) == 0 <S2SV_ModEnd> ) { run_err
",mkj@dropbear/8f8a3dff705fad774a10864a2e3dbcfa9779ceff,CVE-2020-36254,https://github.com/mkj/dropbear/commit/8f8a3dff705fad774a10864a2e3dbcfa9779ceff,2021-02-25T09:15Z,"<S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) { <S2SV_EndBug>"
325,CWE-125,"int imagetobmp ( opj_image_t * image , const char * outfile ) { int w , h ; int i , pad ; FILE * fdest = NULL ; int adjustR , adjustG , adjustB ; if ( image -> comps [ 0 ] . prec < 8 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n"" , image -> comps [ 0 ] . prec ) ; return 1 ; } if ( image -> numcomps >= 3 && image -> comps [ 0 ] . dx == image -> comps [ 1 ] . dx && image -> comps [ 1 ] . dx == image -> comps [ 2 ] . dx && image -> comps [ 0 ] . dy == image -> comps [ 1 ] . dy && image -> comps [ 1 ] . dy == image -> comps [ 2 ] . dy && image -> comps [ 0 ] . prec == image -> comps [ 1 ] . prec && image -> comps [ 1 ] . prec == image -> comps [ 2 ] . prec ) { fdest = fopen ( outfile , ""wb"" ) ; if ( ! fdest ) { fprintf ( stderr , ""ERROR<S2SV_blank>-><S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n"" , outfile ) ; return 1 ; } w = ( int ) image -> comps [ 0 ] . w ; h = ( int ) image -> comps [ 0 ] . h ; fprintf ( fdest , ""BM"" ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w * 3 + 3 * h * ( w % 2 ) + 54 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) + 54 ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) + 54 ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) + 54 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 54 ) & 0xff , ( ( 54 ) >> 8 ) & 0xff , ( ( 54 ) >> 16 ) & 0xff , ( ( 54 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 40 ) & 0xff , ( ( 40 ) >> 8 ) & 0xff , ( ( 40 ) >> 16 ) & 0xff , ( ( 40 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( w ) & 0xff ) , ( OPJ_UINT8 ) ( ( w ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( h ) & 0xff ) , ( OPJ_UINT8 ) ( ( h ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c"" , ( 1 ) & 0xff , ( ( 1 ) >> 8 ) & 0xff ) ; fprintf ( fdest , ""%c%c"" , ( 24 ) & 0xff , ( ( 24 ) >> 8 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( 3 * h * w + 3 * h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; if ( image -> comps [ 0 ] . prec > 8 ) { adjustR = ( int ) image -> comps [ 0 ] . prec - 8 ; printf ( ""BMP<S2SV_blank>CONVERSION:<S2SV_blank>Truncating<S2SV_blank>component<S2SV_blank>0<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>bits<S2SV_blank>to<S2SV_blank>8<S2SV_blank>bits\\n"" , image -> comps [ 0 ] . prec ) ; } else adjustR = 0 ; if ( image -> comps [ 1 ] . prec > 8 ) { adjustG = ( int ) image -> comps [ 1 ] . prec - 8 ; printf ( ""BMP<S2SV_blank>CONVERSION:<S2SV_blank>Truncating<S2SV_blank>component<S2SV_blank>1<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>bits<S2SV_blank>to<S2SV_blank>8<S2SV_blank>bits\\n"" , image -> comps [ 1 ] . prec ) ; } else adjustG = 0 ; if ( image -> comps [ 2 ] . prec > 8 ) { adjustB = ( int ) image -> comps [ 2 ] . prec - 8 ; printf ( ""BMP<S2SV_blank>CONVERSION:<S2SV_blank>Truncating<S2SV_blank>component<S2SV_blank>2<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>bits<S2SV_blank>to<S2SV_blank>8<S2SV_blank>bits\\n"" , image -> comps [ 2 ] . prec ) ; } else adjustB = 0 ; for ( i = 0 ; i < w * h ; i ++ ) { OPJ_UINT8 rc , gc , bc ; int r , g , b ; r = image -> comps [ 0 ] . data [ w * h - ( ( i ) / ( w ) + 1 ) * w + ( i ) % ( w ) ] ; r += ( image -> comps [ 0 ] . sgnd ? 1 << ( image -> comps [ 0 ] . prec - 1 ) : 0 ) ; r = ( ( r >> adjustR ) + ( ( r >> ( adjustR - 1 ) ) % 2 ) ) ; if ( r > 255 ) r = 255 ; else if ( r < 0 ) r = 0 ; rc = ( OPJ_UINT8 ) r ; g = image -> comps [ 1 ] . data [ w * h - ( ( i ) / ( w ) + 1 ) * w + ( i ) % ( w ) ] ; g += ( image -> comps [ 1 ] . sgnd ? 1 << ( image -> comps [ 1 ] . prec - 1 ) : 0 ) ; g = ( ( g >> adjustG ) + ( ( g >> ( adjustG - 1 ) ) % 2 ) ) ; if ( g > 255 ) g = 255 ; else if ( g < 0 ) g = 0 ; gc = ( OPJ_UINT8 ) g ; b = image -> comps [ 2 ] . data [ w * h - ( ( i ) / ( w ) + 1 ) * w + ( i ) % ( w ) ] ; b += ( image -> comps [ 2 ] . sgnd ? 1 << ( image -> comps [ 2 ] . prec - 1 ) : 0 ) ; b = ( ( b >> adjustB ) + ( ( b >> ( adjustB - 1 ) ) % 2 ) ) ; if ( b > 255 ) b = 255 ; else if ( b < 0 ) b = 0 ; bc = ( OPJ_UINT8 ) b ; fprintf ( fdest , ""%c%c%c"" , bc , gc , rc ) ; if ( ( i + 1 ) % w == 0 ) { for ( pad = ( ( 3 * w ) % 4 ) ? ( 4 - ( 3 * w ) % 4 ) : 0 ; pad > 0 ; pad -- ) fprintf ( fdest , ""%c"" , 0 ) ; } } fclose ( fdest ) ; } else { fdest = fopen ( outfile , ""wb"" ) ; if ( ! fdest ) { fprintf ( stderr , ""ERROR<S2SV_blank>-><S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n"" , outfile ) ; return 1 ; } w = ( int ) image -> comps [ 0 ] . w ; h = ( int ) image -> comps [ 0 ] . h ; fprintf ( fdest , ""BM"" ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w + 54 + 1024 + h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + w * ( w % 2 ) ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 54 + 1024 ) & 0xff , ( ( 54 + 1024 ) >> 8 ) & 0xff , ( ( 54 + 1024 ) >> 16 ) & 0xff , ( ( 54 + 1024 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 40 ) & 0xff , ( ( 40 ) >> 8 ) & 0xff , ( ( 40 ) >> 16 ) & 0xff , ( ( 40 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( w ) & 0xff ) , ( OPJ_UINT8 ) ( ( w ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( h ) & 0xff ) , ( OPJ_UINT8 ) ( ( h ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c"" , ( 1 ) & 0xff , ( ( 1 ) >> 8 ) & 0xff ) ; fprintf ( fdest , ""%c%c"" , ( 8 ) & 0xff , ( ( 8 ) >> 8 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w + h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 256 ) & 0xff , ( ( 256 ) >> 8 ) & 0xff , ( ( 256 ) >> 16 ) & 0xff , ( ( 256 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 256 ) & 0xff , ( ( 256 ) >> 8 ) & 0xff , ( ( 256 ) >> 16 ) & 0xff , ( ( 256 ) >> 24 ) & 0xff ) ; if ( image -> comps [ 0 ] . prec > 8 ) { adjustR = ( int ) image -> comps [ 0 ] . prec - 8 ; printf ( ""BMP<S2SV_blank>CONVERSION:<S2SV_blank>Truncating<S2SV_blank>component<S2SV_blank>0<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>bits<S2SV_blank>to<S2SV_blank>8<S2SV_blank>bits\\n"" , image -> comps [ 0 ] . prec ) ; } else adjustR = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { fprintf ( fdest , ""%c%c%c%c"" , i , i , i , 0 ) ; } for ( i = 0 ; i < w * h ; i ++ ) { int r ; r = image -> comps [ 0 ] . data [ w * h - ( ( i ) / ( w ) + 1 ) * w + ( i ) % ( w ) ] ; r += ( image -> comps [ 0 ] . sgnd ? 1 << ( image -> comps [ 0 ] . prec - 1 ) : 0 ) ; r = ( ( r >> adjustR ) + ( ( r >> ( adjustR - 1 ) ) % 2 ) ) ; if ( r > 255 ) r = 255 ; else if ( r < 0 ) r = 0 ; fprintf ( fdest , ""%c"" , ( OPJ_UINT8 ) r ) ; if ( ( i + 1 ) % w == 0 ) { for ( ( pad = w % 4 ) ? ( 4 - w % 4 ) : 0 ; pad > 0 ; pad -- ) fprintf ( fdest , ""%c"" , 0 ) ; } } fclose ( fdest ) ; } return 0 ; }
","<S2SV_ModStart> { for ( pad = ( <S2SV_ModEnd> w % 4
",uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767,CVE-2016-3183,https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767,2017-02-03T16:59Z,<S2SV_StartBug> for ( ( pad = w % 4 ) ? ( 4 - w % 4 ) : 0 ; pad > 0 ; pad -- ) <S2SV_EndBug>
4526,CWE-125,"PyObject * ast2obj_comprehension ( void * _o ) { comprehension_ty o = ( comprehension_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_INCREF ( Py_None ) ; return Py_None ; } result = PyType_GenericNew ( comprehension_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_expr ( o -> target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> ifs , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_ifs , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> is_async ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_is_async , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug>
152,CWE-119,"int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; } } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , ""Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n"" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
","<S2SV_ModStart> out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ;
",torvalds@linux/0926f91083f34d047abc74f1ca4fa6a9c161f7db,CVE-2010-5332,https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db,2019-07-27T22:15Z,<S2SV_StartBug> } <S2SV_EndBug>
597,CWE-476,"static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb ) { s -> avctx -> profile = get_bits ( gb , 4 ) ; s -> avctx -> level = get_bits ( gb , 4 ) ; if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) { s -> avctx -> level = 0 ; } return 0 ; }
","<S2SV_ModStart> GetBitContext * gb , int * profile , int * level ) { * <S2SV_ModEnd> profile = get_bits <S2SV_ModStart> 4 ) ; * <S2SV_ModEnd> level = get_bits <S2SV_ModStart> ; if ( * <S2SV_ModEnd> profile == 0 <S2SV_ModStart> == 0 && * <S2SV_ModEnd> level == 8 <S2SV_ModStart> 8 ) { * <S2SV_ModEnd> level = 0
",FFmpeg@FFmpeg/2aa9047486dbff12d9e040f917e5f799ed2fd78b,CVE-2018-13301,https://github.com/FFmpeg/FFmpeg/commit/2aa9047486dbff12d9e040f917e5f799ed2fd78b,2018-07-05T17:29Z,"<S2SV_StartBug> static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = get_bits ( gb , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) { <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = 0 ; <S2SV_EndBug>"
156,CWE-264,"static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; int ret = 0 ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kfree ( buf ) ; return ret ; }
","<S2SV_ModStart> ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY
",torvalds@linux/096fe9eaea40a17e125569f9e657e34cdb6d73bd,CVE-2015-8539,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,2016-02-08T03:59Z,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug>
588,CWE-119,"static int http_read_header ( URLContext * h , int * new_location ) { HTTPContext * s = h -> priv_data ; char line [ MAX_URL_SIZE ] ; int err = 0 ; s -> chunksize = - 1 ; for ( ; ; ) { if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) return err ; av_log ( h , AV_LOG_TRACE , ""header=\'%s\'\\n"" , line ) ; err = process_line ( h , line , s -> line_count , new_location ) ; if ( err < 0 ) return err ; if ( err == 0 ) break ; s -> line_count ++ ; } if ( s -> seekable == - 1 && s -> is_mediagateway && s -> filesize == 2000000000 ) h -> is_streamed = 1 ; cookie_string ( s -> cookie_dict , & s -> cookies ) ; av_dict_free ( & s -> cookie_dict ) ; return err ; }
","<S2SV_ModStart> -> chunksize = UINT64_MAX <S2SV_ModEnd> ; for (
",FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa,CVE-2016-10190,https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa,2017-02-09T15:59Z,<S2SV_StartBug> s -> chunksize = - 1 ; <S2SV_EndBug>
877,CWE-20,"static int wb_id ( netdissect_options * ndo , const struct pkt_id * id , u_int len ) { int i ; const char * cp ; const struct id_off * io ; char c ; int nid ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-id:"" ) ) ; if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ; len -= sizeof ( * id ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ; nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ; len -= sizeof ( * io ) * nid ; io = ( struct id_off * ) ( id + 1 ) ; cp = ( char * ) ( io + nid ) ; if ( ! ND_TTEST2 ( cp , len ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; } c = '<' ; for ( i = 0 ; i < nid && ND_TTEST ( * io ) ; ++ io , ++ i ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } if ( i >= nid ) { ND_PRINT ( ( ndo , "">"" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp
",the-tcpdump-group@tcpdump/3ed82f4ed0095768529afc22b923c8f7171fff70,CVE-2015-3138,https://github.com/the-tcpdump-group/tcpdump/commit/3ed82f4ed0095768529afc22b923c8f7171fff70,2017-09-28T01:29Z,"<S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug>"
2931,CWE-000,"static int ims_pcu_parse_cdc_data ( struct usb_interface * intf , struct ims_pcu * pcu ) { const struct usb_cdc_union_desc * union_desc ; struct usb_host_interface * alt ; union_desc = ims_pcu_get_cdc_union_desc ( intf ) ; if ( ! union_desc ) return - EINVAL ; pcu -> ctrl_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bMasterInterface0 ) ; alt = pcu -> ctrl_intf -> cur_altsetting ; pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ; pcu -> max_ctrl_size = usb_endpoint_maxp ( pcu -> ep_ctrl ) ; pcu -> data_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bSlaveInterface0 ) ; alt = pcu -> data_intf -> cur_altsetting ; if ( alt -> desc . bNumEndpoints != 2 ) { dev_err ( pcu -> dev , ""Incorrect<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>(%d)\\n"" , alt -> desc . bNumEndpoints ) ; return - EINVAL ; } pcu -> ep_out = & alt -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_bulk_out ( pcu -> ep_out ) ) { dev_err ( pcu -> dev , ""First<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>OUT\\n"" ) ; return - EINVAL ; } pcu -> max_out_size = usb_endpoint_maxp ( pcu -> ep_out ) ; if ( pcu -> max_out_size < 8 ) { dev_err ( pcu -> dev , ""Max<S2SV_blank>OUT<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\n"" , pcu -> max_out_size ) ; return - EINVAL ; } pcu -> ep_in = & alt -> endpoint [ 1 ] . desc ; if ( ! usb_endpoint_is_bulk_in ( pcu -> ep_in ) ) { dev_err ( pcu -> dev , ""Second<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>IN\\n"" ) ; return - EINVAL ; } pcu -> max_in_size = usb_endpoint_maxp ( pcu -> ep_in ) ; if ( pcu -> max_in_size < 8 ) { dev_err ( pcu -> dev , ""Max<S2SV_blank>IN<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\n"" , pcu -> max_in_size ) ; return - EINVAL ; } return 0 ; }
","<S2SV_ModStart> bMasterInterface0 ) ; if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> bSlaveInterface0 ) ; if ( ! pcu -> data_intf ) return - EINVAL ;
",torvalds@linux/a0ad220c96692eda76b2e3fd7279f3dcd1d8a8ff,CVE-2016-3689,https://github.com/torvalds/linux/commit/a0ad220c96692eda76b2e3fd7279f3dcd1d8a8ff,2016-05-02T10:59Z,<S2SV_StartBug> alt = pcu -> ctrl_intf -> cur_altsetting ; <S2SV_EndBug> <S2SV_StartBug> alt = pcu -> data_intf -> cur_altsetting ; <S2SV_EndBug>
945,CWE-264,"static void rd_release_device_space ( struct rd_dev * rd_dev ) { u32 i , j , page_count = 0 , sg_per_table ; struct rd_dev_sg_table * sg_table ; struct page * pg ; struct scatterlist * sg ; if ( ! rd_dev -> sg_table_array || ! rd_dev -> sg_table_count ) return ; sg_table = rd_dev -> sg_table_array ; for ( i = 0 ; i < rd_dev -> sg_table_count ; i ++ ) { sg = sg_table [ i ] . sg_table ; sg_per_table = sg_table [ i ] . rd_sg_count ; for ( j = 0 ; j < sg_per_table ; j ++ ) { pg = sg_page ( & sg [ j ] ) ; if ( pg ) { __free_page ( pg ) ; page_count ++ ; } } kfree ( sg ) ; } pr_debug ( ""CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Released<S2SV_blank>device<S2SV_blank>space<S2SV_blank>for<S2SV_blank>Ramdisk"" ""<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u,<S2SV_blank>pages<S2SV_blank>%u<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>tables<S2SV_blank>total<S2SV_blank>bytes<S2SV_blank>%lu\\n"" , rd_dev -> rd_host -> rd_host_id , rd_dev -> rd_dev_id , page_count , rd_dev -> sg_table_count , ( unsigned long ) page_count * PAGE_SIZE ) ; kfree ( sg_table ) ; rd_dev -> sg_table_array = NULL ; rd_dev -> sg_table_count = 0 ; }
","<S2SV_ModStart> ) { u32 page_count <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; page_count = rd_release_sgl_table ( rd_dev , <S2SV_ModEnd> rd_dev -> sg_table_array <S2SV_ModStart> rd_dev -> sg_table_array , <S2SV_ModEnd> rd_dev -> sg_table_count <S2SV_ModStart> rd_dev -> sg_table_count ) ; <S2SV_ModEnd> pr_debug ( ""CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Released<S2SV_blank>device<S2SV_blank>space<S2SV_blank>for<S2SV_blank>Ramdisk"" <S2SV_ModStart> PAGE_SIZE ) ; <S2SV_ModEnd> rd_dev -> sg_table_array
",torvalds@linux/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,CVE-2014-4027,https://github.com/torvalds/linux/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,2014-06-23T11:21Z,"<S2SV_StartBug> u32 i , j , page_count = 0 , sg_per_table ; <S2SV_EndBug> <S2SV_StartBug> sg_table = rd_dev -> sg_table_array ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < rd_dev -> sg_table_count ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( sg_table ) ; <S2SV_EndBug>"
6578,CWE-20,"int DoOneObject ( char * cinput ) { int num , i , num1 , num2 ; char * s , * t , * StartClean ; double * argbuf = 0 ; SetDefaults ( ) ; s = cinput ; while ( * s != '[' ) s ++ ; s ++ ; t = s ; while ( * t != ']' ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; outpos = outputbuffer ; outpos += sprintf ( outpos , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; if ( * s == '0' && s [ 1 ] == ']' ) { if ( strcmp ( nameobject , ""AxodrawWantsPDF"" ) == 0 ) { identification = 1 ; outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ; fprintf ( outfile , ""%s"" , outputbuffer ) ; return ( 0 ) ; } else { fprintf ( stderr , ""%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n"" , axohelp , nameobject ) ; if ( argbuf ) free ( argbuf ) ; return ( - 1 ) ; } } StartClean = outpos ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; if ( ( strcmp ( nameobject , ""Curve"" ) == 0 ) || ( strcmp ( nameobject , ""Polygon"" ) == 0 ) || ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) ) { if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; if ( num2 - 1 != 0 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>no<S2SV_blank>extra<S2SV_blank>numbers<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; free ( argbuf ) ; return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; if ( strcmp ( nameobject , ""Curve"" ) == 0 ) { Curve ( argbuf , num1 ) ; } else if ( strcmp ( nameobject , ""Polygon"" ) == 0 ) { Polygon ( argbuf , num1 , 0 ) ; } else if ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) { Polygon ( argbuf , num1 , 1 ) ; } free ( argbuf ) ; } } else if ( strcmp ( nameobject , ""DashCurve"" ) == 0 ) { if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; if ( num2 != 2 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>two<S2SV_blank>numbers<S2SV_blank>after<S2SV_blank>the<S2SV_blank>coordinates\\n<S2SV_blank><S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; free ( argbuf ) ; return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; DashCurve ( argbuf , num1 ) ; free ( argbuf ) ; } } else { if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ; for ( i = 0 ; i < sizeof ( commands ) / sizeof ( KEYWORD ) ; i ++ ) { if ( strcmp ( nameobject , commands [ i ] . name ) == 0 ) { if ( num == commands [ i ] . numargs + 1 ) { axolinewidth = argbuf [ num - 1 ] ; SetLineWidth ( axolinewidth ) ; ( * ( commands [ i ] . func ) ) ( argbuf ) ; free ( argbuf ) ; break ; } else { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>%d(+1)<S2SV_blank>arguments<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , commands [ i ] . numargs , inname ) ; free ( argbuf ) ; return ( - 1 ) ; } } } if ( i >= sizeof ( commands ) / sizeof ( KEYWORD ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>recognized<S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; free ( argbuf ) ; return ( - 1 ) ; } } outpos += sprintf ( outpos , ""}\\n"" ) ; CleanupOutput ( StartClean ) ; fprintf ( outfile , ""%s"" , outputbuffer ) ; return ( 0 ) ; }
","<S2SV_ModStart> num1 , num2 , retcode <S2SV_ModStart> , * t <S2SV_ModEnd> ; double * <S2SV_ModStart> argbuf = 0 ; retcode = - 1 <S2SV_ModStart> t ++ ; fprintf ( outfile , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_ModStart> = outputbuffer ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> 1 ] == 0 <S2SV_ModEnd> ) { if <S2SV_ModStart> = 1 ; fprintf ( outfile , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output."" <S2SV_ModEnd> , VERSION , <S2SV_ModStart> SUBVERSION ) ; goto SUCCESS ; } else { fprintf ( <S2SV_ModEnd> stderr , ""%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n"" <S2SV_ModStart> nameobject ) ; goto EXIT ; } } <S2SV_ModEnd> if ( ( <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; for ( <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } } <S2SV_ModStart> inname ) ; goto EXIT ; } } SUCCESS : retcode = 0 ; EXIT : if ( argbuf ) { <S2SV_ModStart> argbuf ) ; } fprintf ( outfile , ""}\\n"" ) ; return ( retcode <S2SV_ModEnd> ) ; }
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,"<S2SV_StartBug> int num , i , num1 , num2 ; <S2SV_EndBug> <S2SV_StartBug> char * s , * t , * StartClean ; <S2SV_EndBug> <S2SV_StartBug> double * argbuf = 0 ; <S2SV_EndBug> <S2SV_StartBug> outpos = outputbuffer ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * s == '0' && s [ 1 ] == ']' ) { <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( outfile , ""%s"" , outputbuffer ) ; <S2SV_EndBug> <S2SV_StartBug> if ( argbuf ) free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug>"
7126,CWE-200,"static void slc_bump ( struct slcan * sl ) { struct sk_buff * skb ; struct can_frame cf ; int i , tmp ; u32 tmpid ; char * cmd = sl -> rbuff ; cf . can_id = 0 ; switch ( * cmd ) { case 'r' : cf . can_id = CAN_RTR_FLAG ; case 't' : cf . can_dlc = sl -> rbuff [ SLC_CMD_LEN + SLC_SFF_ID_LEN ] ; sl -> rbuff [ SLC_CMD_LEN + SLC_SFF_ID_LEN ] = 0 ; cmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1 ; break ; case 'R' : cf . can_id = CAN_RTR_FLAG ; case 'T' : cf . can_id |= CAN_EFF_FLAG ; cf . can_dlc = sl -> rbuff [ SLC_CMD_LEN + SLC_EFF_ID_LEN ] ; sl -> rbuff [ SLC_CMD_LEN + SLC_EFF_ID_LEN ] = 0 ; cmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1 ; break ; default : return ; } if ( kstrtou32 ( sl -> rbuff + SLC_CMD_LEN , 16 , & tmpid ) ) return ; cf . can_id |= tmpid ; if ( cf . can_dlc >= '0' && cf . can_dlc < '9' ) cf . can_dlc -= '0' ; else return ; * ( u64 * ) ( & cf . data ) = 0 ; if ( ! ( cf . can_id & CAN_RTR_FLAG ) ) { for ( i = 0 ; i < cf . can_dlc ; i ++ ) { tmp = hex_to_bin ( * cmd ++ ) ; if ( tmp < 0 ) return ; cf . data [ i ] = ( tmp << 4 ) ; tmp = hex_to_bin ( * cmd ++ ) ; if ( tmp < 0 ) return ; cf . data [ i ] |= tmp ; } } skb = dev_alloc_skb ( sizeof ( struct can_frame ) + sizeof ( struct can_skb_priv ) ) ; if ( ! skb ) return ; skb -> dev = sl -> dev ; skb -> protocol = htons ( ETH_P_CAN ) ; skb -> pkt_type = PACKET_BROADCAST ; skb -> ip_summed = CHECKSUM_UNNECESSARY ; can_skb_reserve ( skb ) ; can_skb_prv ( skb ) -> ifindex = sl -> dev -> ifindex ; can_skb_prv ( skb ) -> skbcnt = 0 ; skb_put_data ( skb , & cf , sizeof ( struct can_frame ) ) ; sl -> dev -> stats . rx_packets ++ ; sl -> dev -> stats . rx_bytes += cf . can_dlc ; netif_rx_ni ( skb ) ; }
","<S2SV_ModStart> -> rbuff ; memset ( & cf , 0 , sizeof ( cf ) ) <S2SV_ModEnd> ; switch ( <S2SV_ModStart> else return ; <S2SV_ModEnd> if ( !
",torvalds@linux/b9258a2cece4ec1f020715fe3554bc2e360f6264,CVE-2020-11494,https://github.com/torvalds/linux/commit/b9258a2cece4ec1f020715fe3554bc2e360f6264,2020-04-02T21:15Z,<S2SV_StartBug> cf . can_id = 0 ; <S2SV_EndBug> <S2SV_StartBug> * ( u64 * ) ( & cf . data ) = 0 ; <S2SV_EndBug>
76,CWE-000,"void sas_init_disc ( struct sas_discovery * disc , struct asd_sas_port * port ) { int i ; static const work_func_t sas_event_fns [ DISC_NUM_EVENTS ] = { [ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , [ DISCE_PROBE ] = sas_probe_devices , [ DISCE_SUSPEND ] = sas_suspend_devices , [ DISCE_RESUME ] = sas_resume_devices , [ DISCE_DESTRUCT ] = sas_destruct_devices , } ; disc -> pending = 0 ; for ( i = 0 ; i < DISC_NUM_EVENTS ; i ++ ) { INIT_SAS_WORK ( & disc -> disc_work [ i ] . work , sas_event_fns [ i ] ) ; disc -> disc_work [ i ] . port = port ; } }
","<S2SV_ModStart> sas_revalidate_domain , [ <S2SV_ModEnd> DISCE_SUSPEND ] = <S2SV_ModStart> ] = sas_resume_devices <S2SV_ModEnd> , } ;
",torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z,"<S2SV_StartBug> [ DISCE_PROBE ] = sas_probe_devices , <S2SV_EndBug> <S2SV_StartBug> [ DISCE_RESUME ] = sas_resume_devices , <S2SV_EndBug>"
1603,CWE-119,"static MB_PREDICTION_MODE read_inter_mode ( VP9_COMMON * cm , vp9_reader * r , int ctx ) { const int mode = vp9_read_tree ( r , vp9_inter_mode_tree , cm -> fc . inter_mode_probs [ ctx ] ) ; if ( ! cm -> frame_parallel_decoding_mode ) ++ cm -> counts . inter_mode [ ctx ] [ mode ] ; return NEARESTMV + mode ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_inter_mode ( VP9_COMMON <S2SV_ModStart> * cm , MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> int mode = vpx_read_tree <S2SV_ModEnd> ( r , <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> inter_mode_probs [ ctx <S2SV_ModStart> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> inter_mode [ ctx
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static MB_PREDICTION_MODE read_inter_mode ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> const int mode = vp9_read_tree ( r , vp9_inter_mode_tree , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . inter_mode_probs [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug>"
8205,CWE-190,"static size_t optsize ( lua_State * L , char opt , const char * * fmt ) { switch ( opt ) { case 'B' : case 'b' : return sizeof ( char ) ; case 'H' : case 'h' : return sizeof ( short ) ; case 'L' : case 'l' : return sizeof ( long ) ; case 'T' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ; case 'c' : return getnum ( fmt , 1 ) ; case 'i' : case 'I' : { int sz = getnum ( fmt , sizeof ( int ) ) ; if ( sz > MAXINTSIZE ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d"" , sz , MAXINTSIZE ) ; return sz ; } default : return 0 ; } }
","<S2SV_ModStart> return getnum ( L , <S2SV_ModStart> = getnum ( L ,
",antirez@redis/ef764dde1cca2f25d00686673d1bc89448819571,CVE-2020-14147,https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571,2020-06-15T18:15Z,"<S2SV_StartBug> case 'c' : return getnum ( fmt , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int sz = getnum ( fmt , sizeof ( int ) ) ; <S2SV_EndBug>"
1539,CWE-119,"static void extend_to_full_distribution ( vp9_prob * probs , vp9_prob p ) { vpx_memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] , MODEL_NODES * sizeof ( vp9_prob ) ) ; }
","<S2SV_ModStart> void extend_to_full_distribution ( vpx_prob <S2SV_ModEnd> * probs , <S2SV_ModStart> * probs , vpx_prob <S2SV_ModEnd> p ) { <S2SV_ModStart> p ) { memcpy <S2SV_ModEnd> ( probs , <S2SV_ModStart> * sizeof ( vpx_prob <S2SV_ModEnd> ) ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void extend_to_full_distribution ( vp9_prob * probs , vp9_prob p ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] , <S2SV_EndBug> <S2SV_StartBug> MODEL_NODES * sizeof ( vp9_prob ) ) ; <S2SV_EndBug>"
2108,CWE-200,"static int recv_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; int sz_to_copy , target , needed ; int sz_copied = 0 ; u32 err ; int res = 0 ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( ( sock -> state == SS_UNCONNECTED ) || ( sock -> state == SS_CONNECTING ) ) ) { res = - ENOTCONN ; goto exit ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ; timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } if ( sz_copied == 0 ) { set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; } if ( ! err ) { u32 offset = ( u32 ) ( unsigned long ) ( TIPC_SKB_CB ( buf ) -> handle ) ; sz -= offset ; needed = ( buf_len - sz_copied ) ; sz_to_copy = ( sz <= needed ) ? sz : needed ; res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) + offset , m -> msg_iov , sz_to_copy ) ; if ( res ) goto exit ; sz_copied += sz_to_copy ; if ( sz_to_copy < sz ) { if ( ! ( flags & MSG_PEEK ) ) TIPC_SKB_CB ( buf ) -> handle = ( void * ) ( unsigned long ) ( offset + sz_to_copy ) ; goto exit ; } } else { if ( sz_copied != 0 ) goto exit ; if ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( unlikely ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } if ( ( sz_copied < buf_len ) && ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || ( sz_copied < target ) ) && ( ! ( flags & MSG_PEEK ) ) && ( ! err ) ) goto restart ; exit : release_sock ( sk ) ; return sz_copied ? sz_copied : res ; }
","<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
",torvalds@linux/60085c3d009b0df252547adb336d1ccca5ce52ec,CVE-2013-3235,https://github.com/torvalds/linux/commit/60085c3d009b0df252547adb336d1ccca5ce52ec,2013-04-22T11:41Z,<S2SV_StartBug> } <S2SV_EndBug>
6801,CWE-000,"static StkId rethook ( lua_State * L , CallInfo * ci , StkId firstres , int nres ) { ptrdiff_t oldtop = savestack ( L , L -> top ) ; int delta = 0 ; if ( isLuacode ( ci ) ) { Proto * p = clLvalue ( s2v ( ci -> func ) ) -> p ; if ( p -> is_vararg ) delta = ci -> u . l . nextraargs + p -> numparams + 1 ; if ( L -> top < ci -> top ) L -> top = ci -> top ; } if ( L -> hookmask & LUA_MASKRET ) { int ftransfer ; ci -> func += delta ; ftransfer = cast ( unsigned short , firstres - ci -> func ) ; luaD_hook ( L , LUA_HOOKRET , - 1 , ftransfer , nres ) ; ci -> func -= delta ; } if ( isLua ( ci -> previous ) ) L -> oldpc = ci -> previous -> u . l . savedpc ; return restorestack ( L , oldtop ) ; }
","<S2SV_ModStart> * p = ci_func ( ci <S2SV_ModEnd> ) -> p <S2SV_ModStart> isLua ( ci = ci <S2SV_ModStart> -> oldpc = pcRel ( ci <S2SV_ModEnd> -> u . <S2SV_ModStart> l . savedpc , ci_func ( ci ) -> p )
",lua@lua/a2195644d89812e5b157ce7bac35543e06db05e3,CVE-2020-15945,https://github.com/lua/lua/commit/a2195644d89812e5b157ce7bac35543e06db05e3,2020-07-24T21:15Z,<S2SV_StartBug> Proto * p = clLvalue ( s2v ( ci -> func ) ) -> p ; <S2SV_EndBug> <S2SV_StartBug> if ( isLua ( ci -> previous ) ) <S2SV_EndBug> <S2SV_StartBug> L -> oldpc = ci -> previous -> u . l . savedpc ; <S2SV_EndBug>
6355,CWE-476,"static int multiSelect ( Parse * pParse , Select * p , SelectDest * pDest ) { int rc = SQLITE_OK ; Select * pPrior ; Vdbe * v ; SelectDest dest ; Select * pDelete = 0 ; sqlite3 * db ; assert ( p && p -> pPrior ) ; assert ( ( p -> selFlags & SF_Recursive ) == 0 || p -> op == TK_ALL || p -> op == TK_UNION ) ; assert ( p -> selFlags & SF_Compound ) ; db = pParse -> db ; pPrior = p -> pPrior ; dest = * pDest ; if ( pPrior -> pOrderBy || pPrior -> pLimit ) { sqlite3ErrorMsg ( pParse , ""%s<S2SV_blank>clause<S2SV_blank>should<S2SV_blank>come<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>before"" , pPrior -> pOrderBy != 0 ? ""ORDER<S2SV_blank>BY"" : ""LIMIT"" , selectOpName ( p -> op ) ) ; rc = 1 ; goto multi_select_end ; } v = sqlite3GetVdbe ( pParse ) ; assert ( v != 0 ) ; if ( dest . eDest == SRT_EphemTab ) { assert ( p -> pEList ) ; sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , dest . iSDParm , p -> pEList -> nExpr ) ; dest . eDest = SRT_Table ; } if ( p -> selFlags & SF_MultiValue ) { rc = multiSelectValues ( pParse , p , & dest ) ; if ( rc >= 0 ) goto multi_select_end ; rc = SQLITE_OK ; } assert ( p -> pEList && pPrior -> pEList ) ; assert ( p -> pEList -> nExpr == pPrior -> pEList -> nExpr ) ; # ifndef SQLITE_OMIT_CTE if ( p -> selFlags & SF_Recursive ) { generateWithRecursiveQuery ( pParse , p , & dest ) ; } else # endif if ( p -> pOrderBy ) { return multiSelectOrderBy ( pParse , p , pDest ) ; } else { # ifndef SQLITE_OMIT_EXPLAIN if ( pPrior -> pPrior == 0 ) { ExplainQueryPlan ( ( pParse , 1 , ""COMPOUND<S2SV_blank>QUERY"" ) ) ; ExplainQueryPlan ( ( pParse , 1 , ""LEFT-MOST<S2SV_blank>SUBQUERY"" ) ) ; } # endif switch ( p -> op ) { case TK_ALL : { int addr = 0 ; int nLimit ; assert ( ! pPrior -> pLimit ) ; pPrior -> iLimit = p -> iLimit ; pPrior -> iOffset = p -> iOffset ; pPrior -> pLimit = p -> pLimit ; rc = sqlite3Select ( pParse , pPrior , & dest ) ; p -> pLimit = 0 ; if ( rc ) { goto multi_select_end ; } p -> pPrior = 0 ; p -> iLimit = pPrior -> iLimit ; p -> iOffset = pPrior -> iOffset ; if ( p -> iLimit ) { addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , ""Jump<S2SV_blank>ahead<S2SV_blank>if<S2SV_blank>LIMIT<S2SV_blank>reached"" ) ) ; if ( p -> iOffset ) { sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , p -> iLimit , p -> iOffset + 1 , p -> iOffset ) ; } } ExplainQueryPlan ( ( pParse , 1 , ""UNION<S2SV_blank>ALL"" ) ) ; rc = sqlite3Select ( pParse , p , & dest ) ; testcase ( rc != SQLITE_OK ) ; pDelete = p -> pPrior ; p -> pPrior = pPrior ; p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ) ; if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) ) { p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ) ; } if ( addr ) { sqlite3VdbeJumpHere ( v , addr ) ; } break ; } case TK_EXCEPT : case TK_UNION : { int unionTab ; u8 op = 0 ; int priorOp ; Expr * pLimit ; int addr ; SelectDest uniondest ; testcase ( p -> op == TK_EXCEPT ) ; testcase ( p -> op == TK_UNION ) ; priorOp = SRT_Union ; if ( dest . eDest == priorOp ) { assert ( p -> pLimit == 0 ) ; unionTab = dest . iSDParm ; } else { unionTab = pParse -> nTab ++ ; assert ( p -> pOrderBy == 0 ) ; addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ) ; assert ( p -> addrOpenEphm [ 0 ] == - 1 ) ; p -> addrOpenEphm [ 0 ] = addr ; findRightmost ( p ) -> selFlags |= SF_UsesEphemeral ; assert ( p -> pEList ) ; } assert ( ! pPrior -> pOrderBy ) ; sqlite3SelectDestInit ( & uniondest , priorOp , unionTab ) ; rc = sqlite3Select ( pParse , pPrior , & uniondest ) ; if ( rc ) { goto multi_select_end ; } if ( p -> op == TK_EXCEPT ) { op = SRT_Except ; } else { assert ( p -> op == TK_UNION ) ; op = SRT_Union ; } p -> pPrior = 0 ; pLimit = p -> pLimit ; p -> pLimit = 0 ; uniondest . eDest = op ; ExplainQueryPlan ( ( pParse , 1 , ""%s<S2SV_blank>USING<S2SV_blank>TEMP<S2SV_blank>B-TREE"" , selectOpName ( p -> op ) ) ) ; rc = sqlite3Select ( pParse , p , & uniondest ) ; testcase ( rc != SQLITE_OK ) ; sqlite3ExprListDelete ( db , p -> pOrderBy ) ; pDelete = p -> pPrior ; p -> pPrior = pPrior ; p -> pOrderBy = 0 ; if ( p -> op == TK_UNION ) { p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ) ; } sqlite3ExprDelete ( db , p -> pLimit ) ; p -> pLimit = pLimit ; p -> iLimit = 0 ; p -> iOffset = 0 ; assert ( unionTab == dest . iSDParm || dest . eDest != priorOp ) ; if ( dest . eDest != priorOp ) { int iCont , iBreak , iStart ; assert ( p -> pEList ) ; iBreak = sqlite3VdbeMakeLabel ( pParse ) ; iCont = sqlite3VdbeMakeLabel ( pParse ) ; computeLimitRegisters ( pParse , p , iBreak ) ; sqlite3VdbeAddOp2 ( v , OP_Rewind , unionTab , iBreak ) ; VdbeCoverage ( v ) ; iStart = sqlite3VdbeCurrentAddr ( v ) ; selectInnerLoop ( pParse , p , unionTab , 0 , 0 , & dest , iCont , iBreak ) ; sqlite3VdbeResolveLabel ( v , iCont ) ; sqlite3VdbeAddOp2 ( v , OP_Next , unionTab , iStart ) ; VdbeCoverage ( v ) ; sqlite3VdbeResolveLabel ( v , iBreak ) ; sqlite3VdbeAddOp2 ( v , OP_Close , unionTab , 0 ) ; } break ; } default : assert ( p -> op == TK_INTERSECT ) ; { int tab1 , tab2 ; int iCont , iBreak , iStart ; Expr * pLimit ; int addr ; SelectDest intersectdest ; int r1 ; tab1 = pParse -> nTab ++ ; tab2 = pParse -> nTab ++ ; assert ( p -> pOrderBy == 0 ) ; addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , tab1 , 0 ) ; assert ( p -> addrOpenEphm [ 0 ] == - 1 ) ; p -> addrOpenEphm [ 0 ] = addr ; findRightmost ( p ) -> selFlags |= SF_UsesEphemeral ; assert ( p -> pEList ) ; sqlite3SelectDestInit ( & intersectdest , SRT_Union , tab1 ) ; rc = sqlite3Select ( pParse , pPrior , & intersectdest ) ; if ( rc ) { goto multi_select_end ; } addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , tab2 , 0 ) ; assert ( p -> addrOpenEphm [ 1 ] == - 1 ) ; p -> addrOpenEphm [ 1 ] = addr ; p -> pPrior = 0 ; pLimit = p -> pLimit ; p -> pLimit = 0 ; intersectdest . iSDParm = tab2 ; ExplainQueryPlan ( ( pParse , 1 , ""%s<S2SV_blank>USING<S2SV_blank>TEMP<S2SV_blank>B-TREE"" , selectOpName ( p -> op ) ) ) ; rc = sqlite3Select ( pParse , p , & intersectdest ) ; testcase ( rc != SQLITE_OK ) ; pDelete = p -> pPrior ; p -> pPrior = pPrior ; if ( p -> nSelectRow > pPrior -> nSelectRow ) { p -> nSelectRow = pPrior -> nSelectRow ; } sqlite3ExprDelete ( db , p -> pLimit ) ; p -> pLimit = pLimit ; assert ( p -> pEList ) ; iBreak = sqlite3VdbeMakeLabel ( pParse ) ; iCont = sqlite3VdbeMakeLabel ( pParse ) ; computeLimitRegisters ( pParse , p , iBreak ) ; sqlite3VdbeAddOp2 ( v , OP_Rewind , tab1 , iBreak ) ; VdbeCoverage ( v ) ; r1 = sqlite3GetTempReg ( pParse ) ; iStart = sqlite3VdbeAddOp2 ( v , OP_RowData , tab1 , r1 ) ; sqlite3VdbeAddOp4Int ( v , OP_NotFound , tab2 , iCont , r1 , 0 ) ; VdbeCoverage ( v ) ; sqlite3ReleaseTempReg ( pParse , r1 ) ; selectInnerLoop ( pParse , p , tab1 , 0 , 0 , & dest , iCont , iBreak ) ; sqlite3VdbeResolveLabel ( v , iCont ) ; sqlite3VdbeAddOp2 ( v , OP_Next , tab1 , iStart ) ; VdbeCoverage ( v ) ; sqlite3VdbeResolveLabel ( v , iBreak ) ; sqlite3VdbeAddOp2 ( v , OP_Close , tab2 , 0 ) ; sqlite3VdbeAddOp2 ( v , OP_Close , tab1 , 0 ) ; break ; } } # ifndef SQLITE_OMIT_EXPLAIN if ( p -> pNext == 0 ) { ExplainQueryPlanPop ( pParse ) ; } # endif } if ( p -> selFlags & SF_UsesEphemeral ) { int i ; KeyInfo * pKeyInfo ; Select * pLoop ; CollSeq * * apColl ; int nCol ; assert ( p -> pNext == 0 ) ; nCol = p -> pEList -> nExpr ; pKeyInfo = sqlite3KeyInfoAlloc ( db , nCol , 1 ) ; if ( ! pKeyInfo ) { rc = SQLITE_NOMEM_BKPT ; goto multi_select_end ; } for ( i = 0 , apColl = pKeyInfo -> aColl ; i < nCol ; i ++ , apColl ++ ) { * apColl = multiSelectCollSeq ( pParse , p , i ) ; if ( 0 == * apColl ) { * apColl = db -> pDfltColl ; } } for ( pLoop = p ; pLoop ; pLoop = pLoop -> pPrior ) { for ( i = 0 ; i < 2 ; i ++ ) { int addr = pLoop -> addrOpenEphm [ i ] ; if ( addr < 0 ) { assert ( pLoop -> addrOpenEphm [ 1 ] < 0 ) ; break ; } sqlite3VdbeChangeP2 ( v , addr , nCol ) ; sqlite3VdbeChangeP4 ( v , addr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ) ; pLoop -> addrOpenEphm [ i ] = - 1 ; } } sqlite3KeyInfoUnref ( pKeyInfo ) ; } multi_select_end : pDest -> iSdst = dest . iSdst ; pDest -> nSdst = dest . nSdst ; sqlite3SelectDelete ( db , pDelete ) ; return rc ; }
","<S2SV_ModStart> } if ( pParse -> nErr ) goto multi_select_end ; if (
",sqlite@sqlite/8428b3b437569338a9d1e10c4cd8154acbe33089,CVE-2019-19926,https://github.com/sqlite/sqlite/commit/8428b3b437569338a9d1e10c4cd8154acbe33089,2019-12-23T01:15Z,<S2SV_StartBug> if ( p -> selFlags & SF_UsesEphemeral ) { <S2SV_EndBug>
3670,CWE-310,"static void prefetch_dec ( void ) { prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ; }
","<S2SV_ModStart> void ) { dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ;
",gpg@libgcrypt/daedbbb5541cd8ecda1459d3b843ea4d92788762,CVE-2019-12904,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,2019-06-20T00:15Z,<S2SV_StartBug> { <S2SV_EndBug>
1474,CWE-119,"void vp8cx_pick_filter_level ( YV12_BUFFER_CONFIG * sd , VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int best_err = 0 ; int filt_err = 0 ; int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filter_step ; int filt_high = 0 ; int filt_mid = cm -> filter_level ; int filt_low = 0 ; int filt_best ; int filt_direction = 0 ; int Bias = 0 ; int ss_err [ MAX_LOOP_FILTER + 1 ] ; YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ; if ( cm -> frame_type == KEY_FRAME ) cm -> sharpness_level = 0 ; else cm -> sharpness_level = cpi -> oxcf . Sharpness ; filt_mid = cm -> filter_level ; if ( filt_mid < min_filter_level ) filt_mid = min_filter_level ; else if ( filt_mid > max_filter_level ) filt_mid = max_filter_level ; filter_step = ( filt_mid < 16 ) ? 4 : filt_mid / 4 ; vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_mid ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_mid ) ; best_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_mid ] = best_err ; filt_best = filt_mid ; while ( filter_step > 0 ) { Bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ; if ( cpi -> twopass . section_intra_rating < 20 ) Bias = Bias * cpi -> twopass . section_intra_rating / 20 ; filt_high = ( ( filt_mid + filter_step ) > max_filter_level ) ? max_filter_level : ( filt_mid + filter_step ) ; filt_low = ( ( filt_mid - filter_step ) < min_filter_level ) ? min_filter_level : ( filt_mid - filter_step ) ; if ( ( filt_direction <= 0 ) && ( filt_low != filt_mid ) ) { if ( ss_err [ filt_low ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_low ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_low ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_low ] = filt_err ; } else filt_err = ss_err [ filt_low ] ; if ( ( filt_err - Bias ) < best_err ) { if ( filt_err < best_err ) best_err = filt_err ; filt_best = filt_low ; } } if ( ( filt_direction >= 0 ) && ( filt_high != filt_mid ) ) { if ( ss_err [ filt_high ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_high ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_high ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_high ] = filt_err ; } else filt_err = ss_err [ filt_high ] ; if ( filt_err < ( best_err - Bias ) ) { best_err = filt_err ; filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step = filter_step / 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } } cm -> filter_level = filt_best ; cm -> frame_to_show = saved_frame ; }
","<S2SV_ModStart> ; int filt_mid <S2SV_ModEnd> ; int filt_low <S2SV_ModStart> -> frame_to_show ; memset <S2SV_ModEnd> ( ss_err ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int filt_mid = cm -> filter_level ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <S2SV_EndBug>"
3306,CWE-119,"static ssize_t wdm_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { int rv , cntr ; int i = 0 ; struct wdm_device * desc = file -> private_data ; rv = mutex_lock_interruptible ( & desc -> rlock ) ; if ( rv < 0 ) return - ERESTARTSYS ; cntr = ACCESS_ONCE ( desc -> length ) ; if ( cntr == 0 ) { desc -> read = 0 ; retry : if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } i ++ ; if ( file -> f_flags & O_NONBLOCK ) { if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { rv = cntr ? cntr : - EAGAIN ; goto err ; } rv = 0 ; } else { rv = wait_event_interruptible ( desc -> wait , test_bit ( WDM_READ , & desc -> flags ) ) ; } if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } if ( test_bit ( WDM_RESETTING , & desc -> flags ) ) { rv = - EIO ; goto err ; } usb_mark_last_busy ( interface_to_usbdev ( desc -> intf ) ) ; if ( rv < 0 ) { rv = - ERESTARTSYS ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; if ( desc -> rerr ) { desc -> rerr = 0 ; spin_unlock_irq ( & desc -> iuspin ) ; rv = - EIO ; goto err ; } if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } if ( ! desc -> reslength ) { dev_dbg ( & desc -> intf -> dev , ""%s:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>-<S2SV_blank>clearing<S2SV_blank>WDM_READ\\n"" , __func__ ) ; clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } cntr = desc -> length ; spin_unlock_irq ( & desc -> iuspin ) ; } if ( cntr > count ) cntr = count ; rv = copy_to_user ( buffer , desc -> ubuf , cntr ) ; if ( rv > 0 ) { rv = - EFAULT ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; for ( i = 0 ; i < desc -> length - cntr ; i ++ ) desc -> ubuf [ i ] = desc -> ubuf [ i + cntr ] ; desc -> length -= cntr ; if ( ! desc -> length ) clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; rv = cntr ; err : mutex_unlock ( & desc -> rlock ) ; return rv ; }
","<S2SV_ModStart> err ; } if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; }
",torvalds@linux/c0f5ecee4e741667b2493c742b60b6218d40b3aa,CVE-2013-1860,https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa,2013-03-22T11:59Z,<S2SV_StartBug> i ++ ; <S2SV_EndBug>
3546,CWE-416,"static void sig_server_setup_fill_chatnet ( IRC_SERVER_CONNECT_REC * conn , IRC_CHATNET_REC * ircnet ) { if ( ! IS_IRC_SERVER_CONNECT ( conn ) ) return ; g_return_if_fail ( IS_IRCNET ( ircnet ) ) ; if ( ircnet -> alternate_nick != NULL ) { g_free_and_null ( conn -> alternate_nick ) ; conn -> alternate_nick = g_strdup ( ircnet -> alternate_nick ) ; } if ( ircnet -> usermode != NULL ) { g_free_and_null ( conn -> usermode ) ; conn -> usermode = g_strdup ( ircnet -> usermode ) ; } if ( ircnet -> max_kicks > 0 ) conn -> max_kicks = ircnet -> max_kicks ; if ( ircnet -> max_msgs > 0 ) conn -> max_msgs = ircnet -> max_msgs ; if ( ircnet -> max_modes > 0 ) conn -> max_modes = ircnet -> max_modes ; if ( ircnet -> max_whois > 0 ) conn -> max_whois = ircnet -> max_whois ; if ( ircnet -> max_cmds_at_once > 0 ) conn -> max_cmds_at_once = ircnet -> max_cmds_at_once ; if ( ircnet -> cmd_queue_speed > 0 ) conn -> cmd_queue_speed = ircnet -> cmd_queue_speed ; if ( ircnet -> max_query_chans > 0 ) conn -> max_query_chans = ircnet -> max_query_chans ; conn -> sasl_mechanism = SASL_MECHANISM_NONE ; conn -> sasl_username = NULL ; conn -> sasl_password = NULL ; if ( ircnet -> sasl_mechanism != NULL ) { if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , ""plain"" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_PLAIN ; if ( ircnet -> sasl_username != NULL && * ircnet -> sasl_username && ircnet -> sasl_password != NULL && * ircnet -> sasl_password ) { conn -> sasl_username = ircnet -> sasl_username ; conn -> sasl_password = ircnet -> sasl_password ; } else g_warning ( ""The<S2SV_blank>fields<S2SV_blank>sasl_username<S2SV_blank>and<S2SV_blank>sasl_password<S2SV_blank>are<S2SV_blank>either<S2SV_blank>missing<S2SV_blank>or<S2SV_blank>empty"" ) ; } else if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , ""external"" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_EXTERNAL ; } else g_warning ( ""Unsupported<S2SV_blank>SASL<S2SV_blank>mechanism<S2SV_blank>\\""%s\\""<S2SV_blank>selected"" , ircnet -> sasl_mechanism ) ; } }
","<S2SV_ModStart> -> sasl_username = g_strdup ( ircnet -> sasl_username ) ; conn -> sasl_password = g_strdup ( ircnet -> sasl_password ) <S2SV_ModEnd> ; } else
",irssi@irssi/d23b0d22cc611e43c88d99192a59f413f951a955,CVE-2019-13045,https://github.com/irssi/irssi/commit/d23b0d22cc611e43c88d99192a59f413f951a955,2019-06-29T14:15Z,<S2SV_StartBug> conn -> sasl_username = ircnet -> sasl_username ; <S2SV_EndBug>
5996,CWE-119,"static int psf_close ( SF_PRIVATE * psf ) { uint32_t k ; int error = 0 ; if ( psf -> codec_close ) { error = psf -> codec_close ( psf ) ; psf -> codec_close = NULL ; } ; if ( psf -> container_close ) error = psf -> container_close ( psf ) ; error = psf_fclose ( psf ) ; psf_close_rsrc ( psf ) ; free ( psf -> container_data ) ; free ( psf -> codec_data ) ; free ( psf -> interleave ) ; free ( psf -> dither ) ; free ( psf -> peak_info ) ; free ( psf -> broadcast_16k ) ; free ( psf -> loop_info ) ; free ( psf -> instrument ) ; free ( psf -> cues ) ; free ( psf -> channel_map ) ; free ( psf -> format_desc ) ; free ( psf -> strings . storage ) ; if ( psf -> wchunks . chunks ) for ( k = 0 ; k < psf -> wchunks . used ; k ++ ) free ( psf -> wchunks . chunks [ k ] . data ) ; free ( psf -> rchunks . chunks ) ; free ( psf -> wchunks . chunks ) ; free ( psf -> iterator ) ; free ( psf -> cart_16k ) ; memset ( psf , 0 , sizeof ( SF_PRIVATE ) ) ; free ( psf ) ; return error ; }
","<S2SV_ModStart> psf_close_rsrc ( psf ) ; free ( psf -> header . ptr
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,<S2SV_StartBug> psf_close_rsrc ( psf ) ; <S2SV_EndBug>
673,CWE-404,"static int omninet_open ( struct tty_struct * tty , struct usb_serial_port * port ) { struct usb_serial * serial = port -> serial ; struct usb_serial_port * wport ; wport = serial -> port [ 1 ] ; tty_port_tty_set ( & wport -> port , tty ) ; return usb_serial_generic_open ( tty , port ) ; }
","<S2SV_ModStart> port ) { <S2SV_ModEnd> return usb_serial_generic_open (
",torvalds@linux/30572418b445d85fcfe6c8fe84c947d2606767d8,CVE-2017-8925,https://github.com/torvalds/linux/commit/30572418b445d85fcfe6c8fe84c947d2606767d8,2017-05-12T21:29Z,<S2SV_StartBug> struct usb_serial * serial = port -> serial ; <S2SV_EndBug>
7359,CWE-352,"static void doPost ( HttpRequest req , HttpResponse res ) { set_content_type ( res , ""text/html"" ) ; if ( ACTION ( RUN ) ) handle_run ( req , res ) ; else if ( ACTION ( STATUS ) ) print_status ( req , res , 1 ) ; else if ( ACTION ( STATUS2 ) ) print_status ( req , res , 2 ) ; else if ( ACTION ( SUMMARY ) ) print_summary ( req , res ) ; else if ( ACTION ( REPORT ) ) _printReport ( req , res ) ; else if ( ACTION ( DOACTION ) ) handle_do_action ( req , res ) ; else handle_action ( req , res ) ; }
","<S2SV_ModStart> ( ACTION ( RUNTIME ) ) handle_runtime_action ( req , res ) ; else if ( ACTION ( VIEWLOG ) ) do_viewlog <S2SV_ModEnd> ( req , <S2SV_ModStart> DOACTION ) ) handle_doaction <S2SV_ModEnd> ( req , <S2SV_ModStart> ) ; else handle_service_action <S2SV_ModEnd> ( req ,
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,"<S2SV_StartBug> if ( ACTION ( RUN ) ) <S2SV_EndBug> <S2SV_StartBug> handle_do_action ( req , res ) ; <S2SV_EndBug> <S2SV_StartBug> handle_action ( req , res ) ; <S2SV_EndBug>"
1326,CWE-119,"void usage_exit ( ) { fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
","<S2SV_ModStart> void usage_exit ( void
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug>
2161,CWE-20,"void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) { __issue_discard_cmd ( sbi , false ) ; __drop_discard_cmd ( sbi ) ; __wait_discard_cmd ( sbi , false ) ; }
","<S2SV_ModStart> f2fs_sb_info * sbi , bool umount <S2SV_ModStart> ( sbi , ! umount <S2SV_ModEnd> ) ; }
",torvalds@linux/638164a2718f337ea224b747cf5977ef143166a4,CVE-2017-18200,https://github.com/torvalds/linux/commit/638164a2718f337ea224b747cf5977ef143166a4,2018-02-26T03:29Z,"<S2SV_StartBug> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) <S2SV_EndBug> <S2SV_StartBug> __wait_discard_cmd ( sbi , false ) ; <S2SV_EndBug>"
879,CWE-119,"int mainloop ( CLIENT * client ) { struct nbd_request request ; struct nbd_reply reply ; gboolean go_on = TRUE ; # ifdef DODBG int i = 0 ; # endif negotiate ( client -> net , client , NULL ) ; DEBUG ( ""Entering<S2SV_blank>request<S2SV_blank>loop!\\n"" ) ; reply . magic = htonl ( NBD_REPLY_MAGIC ) ; reply . error = 0 ; while ( go_on ) { char buf [ BUFSIZE ] ; size_t len ; # ifdef DODBG i ++ ; printf ( ""%d:<S2SV_blank>"" , i ) ; # endif readit ( client -> net , & request , sizeof ( request ) ) ; request . from = ntohll ( request . from ) ; request . type = ntohl ( request . type ) ; if ( request . type == NBD_CMD_DISC ) { msg2 ( LOG_INFO , ""Disconnect<S2SV_blank>request<S2SV_blank>received."" ) ; if ( client -> server -> flags & F_COPYONWRITE ) { if ( client -> difmap ) g_free ( client -> difmap ) ; close ( client -> difffile ) ; unlink ( client -> difffilename ) ; free ( client -> difffilename ) ; } go_on = FALSE ; continue ; } len = ntohl ( request . len ) ; if ( request . magic != htonl ( NBD_REQUEST_MAGIC ) ) err ( ""Not<S2SV_blank>enough<S2SV_blank>magic."" ) ; if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) err ( ""Request<S2SV_blank>too<S2SV_blank>big!"" ) ; # ifdef DODBG printf ( ""%s<S2SV_blank>from<S2SV_blank>%llu<S2SV_blank>(%llu)<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>"" , request . type ? ""WRITE"" : ""READ"" , ( unsigned long long ) request . from , ( unsigned long long ) request . from / 512 , len ) ; # endif memcpy ( reply . handle , request . handle , sizeof ( reply . handle ) ) ; if ( ( request . from + len ) > ( OFFT_MAX ) ) { DEBUG ( ""[Number<S2SV_blank>too<S2SV_blank>large!]"" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( ( ( ssize_t ) ( ( off_t ) request . from + len ) > client -> exportsize ) ) { DEBUG ( ""[RANGE!]"" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( request . type == NBD_CMD_WRITE ) { DEBUG ( ""wr:<S2SV_blank>net->buf,<S2SV_blank>"" ) ; readit ( client -> net , buf , len ) ; DEBUG ( ""buf->exp,<S2SV_blank>"" ) ; if ( ( client -> server -> flags & F_READONLY ) || ( client -> server -> flags & F_AUTOREADONLY ) ) { DEBUG ( ""[WRITE<S2SV_blank>to<S2SV_blank>READONLY!]"" ) ; ERROR ( client , reply , EPERM ) ; continue ; } if ( expwrite ( request . from , buf , len , client ) ) { DEBUG ( ""Write<S2SV_blank>failed:<S2SV_blank>%m"" ) ; ERROR ( client , reply , errno ) ; continue ; } SEND ( client -> net , reply ) ; DEBUG ( ""OK!\\n"" ) ; continue ; } DEBUG ( ""exp->buf,<S2SV_blank>"" ) ; if ( expread ( request . from , buf + sizeof ( struct nbd_reply ) , len , client ) ) { DEBUG ( ""Read<S2SV_blank>failed:<S2SV_blank>%m"" ) ; ERROR ( client , reply , errno ) ; continue ; } DEBUG ( ""buf->net,<S2SV_blank>"" ) ; memcpy ( buf , & reply , sizeof ( struct nbd_reply ) ) ; writeit ( client -> net , buf , len + sizeof ( struct nbd_reply ) ) ; DEBUG ( ""OK!\\n"" ) ; } return 0 ; }
","<S2SV_ModStart> len > BUFSIZE - <S2SV_ModEnd> sizeof ( struct
",yoe@nbd/3ef52043861ab16352d49af89e048ba6339d6df8,CVE-2011-0530,https://github.com/yoe/nbd/commit/3ef52043861ab16352d49af89e048ba6339d6df8,2011-02-22T19:00Z,<S2SV_StartBug> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <S2SV_EndBug>
220,CWE-310,"int asn1_ber_decoder ( const struct asn1_decoder * decoder , void * context , const unsigned char * data , size_t datalen ) { const unsigned char * machine = decoder -> machine ; const asn1_action_t * actions = decoder -> actions ; size_t machlen = decoder -> machlen ; enum asn1_opcode op ; unsigned char tag = 0 , csp = 0 , jsp = 0 , optag = 0 , hdr = 0 ; const char * errmsg ; size_t pc = 0 , dp = 0 , tdp = 0 , len = 0 ; int ret ; unsigned char flags = 0 ; # define FLAG_INDEFINITE_LENGTH 0x01 # define FLAG_MATCHED 0x02 # define FLAG_LAST_MATCHED 0x04 # define FLAG_CONS 0x20 # define NR_CONS_STACK 10 unsigned short cons_dp_stack [ NR_CONS_STACK ] ; unsigned short cons_datalen_stack [ NR_CONS_STACK ] ; unsigned char cons_hdrlen_stack [ NR_CONS_STACK ] ; # define NR_JUMP_STACK 10 unsigned char jump_stack [ NR_JUMP_STACK ] ; if ( datalen > 65535 ) return - EMSGSIZE ; next_op : pr_debug ( ""next_op:<S2SV_blank>pc=\\e[32m%zu\\e[m/%zu<S2SV_blank>dp=\\e[33m%zu\\e[m/%zu<S2SV_blank>C=%d<S2SV_blank>J=%d\\n"" , pc , machlen , dp , datalen , csp , jsp ) ; if ( unlikely ( pc >= machlen ) ) goto machine_overrun_error ; op = machine [ pc ] ; if ( unlikely ( pc + asn1_op_lengths [ op ] > machlen ) ) goto machine_overrun_error ; if ( op <= ASN1_OP__MATCHES_TAG ) { unsigned char tmp ; if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || dp == datalen ) { flags &= ~ FLAG_LAST_MATCHED ; pc += asn1_op_lengths [ op ] ; goto next_op ; } flags = 0 ; hdr = 2 ; if ( unlikely ( dp >= datalen - 1 ) ) goto data_overrun_error ; tag = data [ dp ++ ] ; if ( unlikely ( ( tag & 0x1f ) == ASN1_LONG_TAG ) ) goto long_tag_not_supported ; if ( op & ASN1_OP_MATCH__ANY ) { pr_debug ( ""-<S2SV_blank>any<S2SV_blank>%02x\\n"" , tag ) ; } else { optag = machine [ pc + 1 ] ; flags |= optag & FLAG_CONS ; tmp = optag ^ tag ; tmp &= ~ ( optag & ASN1_CONS_BIT ) ; pr_debug ( ""-<S2SV_blank>match?<S2SV_blank>%02x<S2SV_blank>%02x<S2SV_blank>%02x\\n"" , tag , optag , tmp ) ; if ( tmp != 0 ) { if ( op & ASN1_OP_MATCH__SKIP ) { pc += asn1_op_lengths [ op ] ; dp -- ; goto next_op ; } goto tag_mismatch ; } } flags |= FLAG_MATCHED ; len = data [ dp ++ ] ; if ( len > 0x7f ) { if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) { if ( unlikely ( ! ( tag & ASN1_CONS_BIT ) ) ) goto indefinite_len_primitive ; flags |= FLAG_INDEFINITE_LENGTH ; if ( unlikely ( 2 > datalen - dp ) ) goto data_overrun_error ; } else { int n = len - 0x80 ; if ( unlikely ( n > 2 ) ) goto length_too_long ; if ( unlikely ( dp >= datalen - n ) ) goto data_overrun_error ; hdr += n ; for ( len = 0 ; n > 0 ; n -- ) { len <<= 8 ; len |= data [ dp ++ ] ; } if ( unlikely ( len > datalen - dp ) ) goto data_overrun_error ; } } if ( flags & FLAG_CONS ) { if ( unlikely ( csp >= NR_CONS_STACK ) ) goto cons_stack_overflow ; cons_dp_stack [ csp ] = dp ; cons_hdrlen_stack [ csp ] = hdr ; if ( ! ( flags & FLAG_INDEFINITE_LENGTH ) ) { cons_datalen_stack [ csp ] = datalen ; datalen = dp + len ; } else { cons_datalen_stack [ csp ] = 0 ; } csp ++ ; } pr_debug ( ""-<S2SV_blank>TAG:<S2SV_blank>%02x<S2SV_blank>%zu%s\\n"" , tag , len , flags & FLAG_CONS ? ""<S2SV_blank>CONS"" : """" ) ; tdp = dp ; } switch ( op ) { case ASN1_OP_MATCH_ANY_ACT : case ASN1_OP_COND_MATCH_ANY_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH_ACT : case ASN1_OP_MATCH_ACT_OR_SKIP : case ASN1_OP_COND_MATCH_ACT_OR_SKIP : ret = actions [ machine [ pc + 2 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH : case ASN1_OP_MATCH_OR_SKIP : case ASN1_OP_MATCH_ANY : case ASN1_OP_COND_MATCH_OR_SKIP : case ASN1_OP_COND_MATCH_ANY : skip_data : if ( ! ( flags & FLAG_CONS ) ) { if ( flags & FLAG_INDEFINITE_LENGTH ) { ret = asn1_find_indefinite_length ( data , datalen , & dp , & len , & errmsg ) ; if ( ret < 0 ) goto error ; } else { dp += len ; } pr_debug ( ""-<S2SV_blank>LEAF:<S2SV_blank>%zu\\n"" , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MATCH_JUMP : case ASN1_OP_MATCH_JUMP_OR_SKIP : case ASN1_OP_COND_MATCH_JUMP_OR_SKIP : pr_debug ( ""-<S2SV_blank>MATCH_JUMP\\n"" ) ; if ( unlikely ( jsp == NR_JUMP_STACK ) ) goto jump_stack_overflow ; jump_stack [ jsp ++ ] = pc + asn1_op_lengths [ op ] ; pc = machine [ pc + 2 ] ; goto next_op ; case ASN1_OP_COND_FAIL : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_COMPLETE : if ( unlikely ( jsp != 0 || csp != 0 ) ) { pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Stacks<S2SV_blank>not<S2SV_blank>empty<S2SV_blank>at<S2SV_blank>completion<S2SV_blank>(%u,<S2SV_blank>%u)\\n"" , jsp , csp ) ; return - EBADMSG ; } return 0 ; case ASN1_OP_END_SET : case ASN1_OP_END_SET_ACT : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; case ASN1_OP_END_SEQ : case ASN1_OP_END_SET_OF : case ASN1_OP_END_SEQ_OF : case ASN1_OP_END_SEQ_ACT : case ASN1_OP_END_SET_OF_ACT : case ASN1_OP_END_SEQ_OF_ACT : if ( unlikely ( csp <= 0 ) ) goto cons_stack_underflow ; csp -- ; tdp = cons_dp_stack [ csp ] ; hdr = cons_hdrlen_stack [ csp ] ; len = datalen ; datalen = cons_datalen_stack [ csp ] ; pr_debug ( ""-<S2SV_blank>end<S2SV_blank>cons<S2SV_blank>t=%zu<S2SV_blank>dp=%zu<S2SV_blank>l=%zu/%zu\\n"" , tdp , dp , len , datalen ) ; if ( datalen == 0 ) { datalen = len ; if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; if ( data [ dp ++ ] != 0 ) { if ( op & ASN1_OP_END__OF ) { dp -- ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } goto missing_eoc ; } if ( data [ dp ++ ] != 0 ) goto invalid_eoc ; len = dp - tdp - 2 ; } else { if ( dp < len && ( op & ASN1_OP_END__OF ) ) { datalen = len ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } if ( dp != len ) goto cons_length_error ; len -= tdp ; pr_debug ( ""-<S2SV_blank>cons<S2SV_blank>len<S2SV_blank>l=%zu<S2SV_blank>d=%zu\\n"" , len , dp - tdp ) ; } if ( op & ASN1_OP_END__ACT ) { unsigned char act ; if ( op & ASN1_OP_END__OF ) act = machine [ pc + 2 ] ; else act = machine [ pc + 1 ] ; ret = actions [ act ] ( context , hdr , 0 , data + tdp , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MAYBE_ACT : if ( ! ( flags & FLAG_LAST_MATCHED ) ) { pc += asn1_op_lengths [ op ] ; goto next_op ; } case ASN1_OP_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + tdp , len ) ; if ( ret < 0 ) return ret ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_RETURN : if ( unlikely ( jsp <= 0 ) ) goto jump_stack_underflow ; pc = jump_stack [ -- jsp ] ; flags |= FLAG_MATCHED | FLAG_LAST_MATCHED ; goto next_op ; default : break ; } pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Found<S2SV_blank>reserved<S2SV_blank>opcode<S2SV_blank>(%u)<S2SV_blank>pc=%zu\\n"" , op , pc ) ; return - EBADMSG ; data_overrun_error : errmsg = ""Data<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; machine_overrun_error : errmsg = ""Machine<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; jump_stack_underflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; jump_stack_overflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_stack_underflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; cons_stack_overflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_length_error : errmsg = ""Cons<S2SV_blank>length<S2SV_blank>error"" ; goto error ; missing_eoc : errmsg = ""Missing<S2SV_blank>EOC<S2SV_blank>in<S2SV_blank>indefinite<S2SV_blank>len<S2SV_blank>cons"" ; goto error ; invalid_eoc : errmsg = ""Invalid<S2SV_blank>length<S2SV_blank>EOC"" ; goto error ; length_too_long : errmsg = ""Unsupported<S2SV_blank>length"" ; goto error ; indefinite_len_primitive : errmsg = ""Indefinite<S2SV_blank>len<S2SV_blank>primitive<S2SV_blank>not<S2SV_blank>permitted"" ; goto error ; tag_mismatch : errmsg = ""Unexpected<S2SV_blank>tag"" ; goto error ; long_tag_not_supported : errmsg = ""Long<S2SV_blank>tag<S2SV_blank>not<S2SV_blank>supported"" ; error : pr_debug ( ""\\nASN1:<S2SV_blank>%s<S2SV_blank>[m=%zu<S2SV_blank>d=%zu<S2SV_blank>ot=%02x<S2SV_blank>t=%02x<S2SV_blank>l=%zu]\\n"" , errmsg , pc , dp , optag , tag , len ) ; return - EBADMSG ; }
","<S2SV_ModStart> FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> dp == datalen )
",torvalds@linux/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,CVE-2016-2053,https://github.com/torvalds/linux/commit/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,2016-05-02T10:59Z,<S2SV_StartBug> dp == datalen ) { <S2SV_EndBug>
6719,CWE-444,"static ngx_int_t ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r ) { ngx_table_elt_t * header ; ngx_list_part_t * part ; ngx_uint_t i ; if ( ngx_list_init ( & sr -> headers_in . headers , sr -> pool , 20 , sizeof ( ngx_table_elt_t ) ) != NGX_OK ) { return NGX_ERROR ; } dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) r -> headers_in . headers . part . nelts ) ; part = & r -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { if ( part -> next == NULL ) { break ; } part = part -> next ; header = part -> elts ; i = 0 ; } dd ( ""setting<S2SV_blank>request<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; } } dd ( ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) r -> headers_in . headers . part . nelts ) ; return NGX_OK ; }
","<S2SV_ModStart> , ngx_http_request_t * pr , int pr_not_chunked <S2SV_ModEnd> ) { ngx_table_elt_t <S2SV_ModStart> { ngx_table_elt_t * clh , * <S2SV_ModStart> ; ngx_uint_t i ; u_char * p ; off_t len ; dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) pr -> headers_in . headers . part . nelts ) <S2SV_ModStart> NGX_ERROR ; } if ( sr -> request_body && ! pr_not_chunked ) { len = sr -> request_body -> buf ? ngx_buf_size ( sr -> request_body -> buf ) : 0 ; clh = ngx_list_push ( & sr <S2SV_ModEnd> -> headers_in . <S2SV_ModStart> headers_in . headers ) ; if ( clh <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) <S2SV_ModEnd> { return NGX_ERROR <S2SV_ModStart> NGX_ERROR ; } clh -> hash = ngx_http_lua_content_length_hash ; clh -> key = ngx_http_lua_content_length_header_key ; clh -> lowcase_key = ngx_pnalloc ( sr -> pool , clh -> key . len ) ; if ( clh -> lowcase_key == NULL ) { return NGX_ERROR ; } ngx_strlow ( clh -> lowcase_key , clh -> key . data , clh -> key . len ) ; p = ngx_palloc ( sr -> pool , NGX_OFF_T_LEN ) ; if ( p == NULL ) { return NGX_ERROR ; } clh -> value . data = p ; clh -> value . len = ngx_sprintf ( clh -> value . data , ""%O"" , len ) - clh -> value . data ; sr -> headers_in . content_length = clh ; sr -> headers_in . content_length_n = len ; dd ( ""sr<S2SV_blank>crafted<S2SV_blank>content-length:<S2SV_blank>%.*s"" , ( int ) sr -> headers_in . content_length -> value . len , sr -> headers_in . content_length -> value . data ) ; } part = & pr -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { if ( part -> next == NULL ) { break ; } part = part -> next ; header = part -> elts ; i = 0 ; } if ( ! pr_not_chunked && header [ i ] . key . len == sizeof ( ""Content-Length"" ) - 1 && ngx_strncasecmp ( header [ i ] . key . data , ( u_char * ) ""Content-Length"" , sizeof ( ""Content-Length"" ) - 1 ) == 0 ) { continue ; } dd ( ""sr<S2SV_blank>copied<S2SV_blank>req<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; } } dd ( <S2SV_ModEnd> ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( <S2SV_ModStart> ( int ) pr <S2SV_ModEnd> -> headers_in .
",openresty@lua-nginx-module/9ab38e8ee35fc08a57636b1b6190dca70b0076fa,CVE-2020-11724,https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa,2020-04-12T21:15Z,"<S2SV_StartBug> ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r ) <S2SV_EndBug> <S2SV_StartBug> ngx_table_elt_t * header ; <S2SV_EndBug> <S2SV_StartBug> ngx_uint_t i ; <S2SV_EndBug> <S2SV_StartBug> dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug> <S2SV_StartBug> if ( part -> next == NULL ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug>"
2555,CWE-19,"int xfs_attr3_leaf_clearflag ( struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_buf * bp ; int error ; # ifdef DEBUG struct xfs_attr3_icleaf_hdr ichdr ; xfs_attr_leaf_name_local_t * name_loc ; int namelen ; char * name ; # endif trace_xfs_attr_leaf_clearflag ( args ) ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return ( error ) ; leaf = bp -> b_addr ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; ASSERT ( entry -> flags & XFS_ATTR_INCOMPLETE ) ; # ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( args -> index < ichdr . count ) ; ASSERT ( args -> index >= 0 ) ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; namelen = name_loc -> namelen ; name = ( char * ) name_loc -> nameval ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; namelen = name_rmt -> namelen ; name = ( char * ) name_rmt -> name ; } ASSERT ( be32_to_cpu ( entry -> hashval ) == args -> hashval ) ; ASSERT ( namelen == args -> namelen ) ; ASSERT ( memcmp ( name , args -> name , namelen ) == 0 ) ; # endif entry -> flags &= ~ XFS_ATTR_INCOMPLETE ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ; if ( args -> rmtblkno ) { ASSERT ( ( entry -> flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ; name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ; } return xfs_trans_roll ( & args -> trans , args -> dp ) ; }
","<S2SV_ModStart> ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf
",torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z,<S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug>
1669,CWE-119,"static void write_modes_b ( VP9_COMP * cpi , const TileInfo * const tile , vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , int mi_row , int mi_col ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; MODE_INFO * m ; xd -> mi = cm -> mi_grid_visible + ( mi_row * cm -> mi_stride + mi_col ) ; m = xd -> mi [ 0 ] ; set_mi_row_col ( xd , tile , mi_row , num_8x8_blocks_high_lookup [ m -> mbmi . sb_type ] , mi_col , num_8x8_blocks_wide_lookup [ m -> mbmi . sb_type ] , cm -> mi_rows , cm -> mi_cols ) ; if ( frame_is_intra_only ( cm ) ) { write_mb_modes_kf ( cpi , xd -> mi , w ) ; } else { pack_inter_mode_mvs ( cpi , m , w ) ; } assert ( * tok < tok_end ) ; pack_mb_tokens ( w , tok , tok_end ) ; }
","<S2SV_ModStart> const tile , vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> * tok , const TOKENEXTRA * const <S2SV_ModEnd> tok_end , int <S2SV_ModStart> mi_col ) { const <S2SV_ModStart> & cpi -> td . <S2SV_ModStart> 0 ] ; cpi -> td . mb . mbmi_ext = cpi -> td . mb . mbmi_ext_base + ( mi_row * cm -> mi_cols + mi_col ) ; <S2SV_ModStart> { write_mb_modes_kf ( cm , xd <S2SV_ModEnd> , xd -> <S2SV_ModStart> tok , tok_end , cm -> bit_depth
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> set_mi_row_col ( xd , tile , <S2SV_EndBug> <S2SV_StartBug> write_mb_modes_kf ( cpi , xd -> mi , w ) ; <S2SV_EndBug> <S2SV_StartBug> pack_mb_tokens ( w , tok , tok_end ) ; <S2SV_EndBug>"
3351,CWE-190,"void * checked_xmalloc ( size_t size ) { alloc_limit_assert ( ""checked_xmalloc"" , size ) ; return xmalloc ( size ) ; }
","<S2SV_ModStart> checked_xmalloc ( size_t num , size_t <S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> ( ""checked_xmalloc"" , res <S2SV_ModEnd> ) ; return <S2SV_ModStart> return xmalloc ( num ,
",verdammelt@tnef/c5044689e50039635e7700fe2472fd632ac77176,CVE-2017-6308,https://github.com/verdammelt/tnef/commit/c5044689e50039635e7700fe2472fd632ac77176,2017-02-24T04:59Z,"<S2SV_StartBug> checked_xmalloc ( size_t size ) <S2SV_EndBug> <S2SV_StartBug> alloc_limit_assert ( ""checked_xmalloc"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> return xmalloc ( size ) ; <S2SV_EndBug>"
1437,CWE-119,"int vp8_diamond_search_sadx4 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , int * num00 , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { int i , j , step ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * best_address ; int tot_steps ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int best_site = 0 ; int last_site = 0 ; int ref_row ; int ref_col ; int this_row_offset ; int this_col_offset ; search_site * ss ; unsigned char * check_here ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; ref_row = ref_mv -> as_mv . row ; ref_col = ref_mv -> as_mv . col ; * num00 = 0 ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; in_what = ( unsigned char * ) ( base_pre + d -> offset + ( ref_row * pre_stride ) + ref_col ) ; best_address = in_what ; bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX ) + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; ss = & x -> ss [ search_param * x -> searches_per_step ] ; tot_steps = ( x -> ss_count / x -> searches_per_step ) - search_param ; i = 1 ; for ( step = 0 ; step < tot_steps ; step ++ ) { int all_in = 1 , t ; all_in &= ( ( best_mv -> as_mv . row + ss [ i ] . mv . row ) > x -> mv_row_min ) ; all_in &= ( ( best_mv -> as_mv . row + ss [ i + 1 ] . mv . row ) < x -> mv_row_max ) ; all_in &= ( ( best_mv -> as_mv . col + ss [ i + 2 ] . mv . col ) > x -> mv_col_min ) ; all_in &= ( ( best_mv -> as_mv . col + ss [ i + 3 ] . mv . col ) < x -> mv_col_max ) ; if ( all_in ) { unsigned int sad_array [ 4 ] ; for ( j = 0 ; j < x -> searches_per_step ; j += 4 ) { const unsigned char * block_offset [ 4 ] ; for ( t = 0 ; t < 4 ; t ++ ) block_offset [ t ] = ss [ i + t ] . offset + best_address ; fn_ptr -> sdx4df ( what , what_stride , block_offset , in_what_stride , sad_array ) ; for ( t = 0 ; t < 4 ; t ++ , i ++ ) { if ( sad_array [ t ] < bestsad ) { this_mv . as_mv . row = best_mv -> as_mv . row + ss [ i ] . mv . row ; this_mv . as_mv . col = best_mv -> as_mv . col + ss [ i ] . mv . col ; sad_array [ t ] += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( sad_array [ t ] < bestsad ) { bestsad = sad_array [ t ] ; best_site = i ; } } } } } else { for ( j = 0 ; j < x -> searches_per_step ; j ++ ) { this_row_offset = best_mv -> as_mv . row + ss [ i ] . mv . row ; this_col_offset = best_mv -> as_mv . col + ss [ i ] . mv . col ; if ( ( this_col_offset > x -> mv_col_min ) && ( this_col_offset < x -> mv_col_max ) && ( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ss [ i ] . offset + best_address ; thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; if ( thissad < bestsad ) { this_mv . as_mv . row = this_row_offset ; this_mv . as_mv . col = this_col_offset ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_site = i ; } } } i ++ ; } } if ( best_site != last_site ) { best_mv -> as_mv . row += ss [ best_site ] . mv . row ; best_mv -> as_mv . col += ss [ best_site ] . mv . col ; best_address += ss [ best_site ] . offset ; last_site = best_site ; } else if ( best_address == in_what ) ( * num00 ) ++ ; } this_mv . as_mv . row = best_mv -> as_mv . row * 8 ; this_mv . as_mv . col = best_mv -> as_mv . col * 8 ; return fn_ptr -> vf ( what , what_stride , best_address , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
","<S2SV_ModStart> in_what , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> check_here , in_what_stride <S2SV_ModEnd> ) ; if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug>"
6804,CWE-401,"static ssize_t qrtr_tun_write_iter ( struct kiocb * iocb , struct iov_iter * from ) { struct file * filp = iocb -> ki_filp ; struct qrtr_tun * tun = filp -> private_data ; size_t len = iov_iter_count ( from ) ; ssize_t ret ; void * kbuf ; kbuf = kzalloc ( len , GFP_KERNEL ) ; if ( ! kbuf ) return - ENOMEM ; if ( ! copy_from_iter_full ( kbuf , len , from ) ) return - EFAULT ; ret = qrtr_endpoint_post ( & tun -> ep , kbuf , len ) ; return ret < 0 ? ret : len ; }
","<S2SV_ModStart> from ) ) { kfree ( kbuf ) ; <S2SV_ModStart> - EFAULT ; } <S2SV_ModStart> len ) ; kfree ( kbuf ) ;
",torvalds@linux/a21b7f0cff1906a93a0130b74713b15a0b36481d,CVE-2019-19079,https://github.com/torvalds/linux/commit/a21b7f0cff1906a93a0130b74713b15a0b36481d,2019-11-18T06:15Z,"<S2SV_StartBug> if ( ! copy_from_iter_full ( kbuf , len , from ) ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> return ret < 0 ? ret : len ; <S2SV_EndBug>"
3439,CWE-000,"static int treo_attach ( struct usb_serial * serial ) { struct usb_serial_port * swap_port ; if ( ! ( ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == HANDSPRING_VENDOR_ID ) || ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == KYOCERA_VENDOR_ID ) ) || ( serial -> num_interrupt_in == 0 ) ) return 0 ; # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ; if ( ! swap_port ) return - ENOMEM ; COPY_PORT ( swap_port , serial -> port [ 0 ] ) ; COPY_PORT ( serial -> port [ 0 ] , serial -> port [ 1 ] ) ; COPY_PORT ( serial -> port [ 1 ] , swap_port ) ; kfree ( swap_port ) ; return 0 ; }
","<S2SV_ModStart> return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; }
",torvalds@linux/cac9b50b0d75a1d50d6c056ff65c005f3224c8e0,CVE-2016-2782,https://github.com/torvalds/linux/commit/cac9b50b0d75a1d50d6c056ff65c005f3224c8e0,2016-04-27T17:59Z,"<S2SV_StartBug> # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; <S2SV_EndBug>"
3469,CWE-119,"static int smacker_decode_tree ( BitstreamContext * bc , HuffContext * hc , uint32_t prefix , int length ) { if ( ! bitstream_read_bit ( bc ) ) { if ( hc -> current >= 256 ) { av_log ( NULL , AV_LOG_ERROR , ""Tree<S2SV_blank>size<S2SV_blank>exceeded!\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( length ) { hc -> bits [ hc -> current ] = prefix ; hc -> lengths [ hc -> current ] = length ; } else { hc -> bits [ hc -> current ] = 0 ; hc -> lengths [ hc -> current ] = 0 ; } hc -> values [ hc -> current ] = bitstream_read ( bc , 8 ) ; hc -> current ++ ; if ( hc -> maxlength < length ) hc -> maxlength = length ; return 0 ; } else { int r ; length ++ ; r = smacker_decode_tree ( bc , hc , prefix , length ) ; if ( r ) return r ; return smacker_decode_tree ( bc , hc , prefix | ( 1 << ( length - 1 ) ) , length ) ; } }
","<S2SV_ModStart> { if ( length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , ""Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n"" ) ; return AVERROR_INVALIDDATA ; } if (
",libav@libav/cd4663dc80323ba64989d0c103d51ad3ee0e9c2f,CVE-2017-16803,https://github.com/libav/libav/commit/cd4663dc80323ba64989d0c103d51ad3ee0e9c2f,2017-11-13T17:29Z,<S2SV_StartBug> if ( ! bitstream_read_bit ( bc ) ) { <S2SV_EndBug>
1328,CWE-119,"void usage_exit ( ) { fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><N-M|N/M>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
","<S2SV_ModStart> void usage_exit ( void
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug>
1284,CWE-617,"static int connection_edge_process_relay_cell ( cell_t * cell , circuit_t * circ , edge_connection_t * conn , crypt_path_t * layer_hint ) { static int num_seen = 0 ; relay_header_t rh ; unsigned domain = layer_hint ? LD_APP : LD_EXIT ; int reason ; int optimistic_data = 0 ; tor_assert ( cell ) ; tor_assert ( circ ) ; relay_header_unpack ( & rh , cell -> payload ) ; num_seen ++ ; log_debug ( domain , ""Now<S2SV_blank>seen<S2SV_blank>%d<S2SV_blank>relay<S2SV_blank>cells<S2SV_blank>here<S2SV_blank>(command<S2SV_blank>%d,<S2SV_blank>stream<S2SV_blank>%d)."" , num_seen , rh . command , rh . stream_id ) ; if ( rh . length > RELAY_PAYLOAD_SIZE ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Relay<S2SV_blank>cell<S2SV_blank>length<S2SV_blank>field<S2SV_blank>too<S2SV_blank>long.<S2SV_blank>Closing<S2SV_blank>circuit."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } if ( rh . stream_id == 0 ) { switch ( rh . command ) { case RELAY_COMMAND_BEGIN : case RELAY_COMMAND_CONNECTED : case RELAY_COMMAND_DATA : case RELAY_COMMAND_END : case RELAY_COMMAND_RESOLVE : case RELAY_COMMAND_RESOLVED : case RELAY_COMMAND_BEGIN_DIR : log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Relay<S2SV_blank>command<S2SV_blank>%d<S2SV_blank>with<S2SV_blank>zero<S2SV_blank>"" ""stream_id.<S2SV_blank>Dropping."" , ( int ) rh . command ) ; return 0 ; default : ; } } if ( conn && ! connection_state_is_open ( TO_CONN ( conn ) ) ) { if ( conn -> base_ . type == CONN_TYPE_EXIT && ( conn -> base_ . state == EXIT_CONN_STATE_CONNECTING || conn -> base_ . state == EXIT_CONN_STATE_RESOLVING ) && rh . command == RELAY_COMMAND_DATA ) { optimistic_data = 1 ; } else { return connection_edge_process_relay_cell_not_open ( & rh , cell , circ , conn , layer_hint ) ; } } switch ( rh . command ) { case RELAY_COMMAND_DROP : return 0 ; case RELAY_COMMAND_BEGIN : case RELAY_COMMAND_BEGIN_DIR : if ( layer_hint && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""Relay<S2SV_blank>begin<S2SV_blank>request<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>AP.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED && layer_hint != TO_ORIGIN_CIRCUIT ( circ ) -> cpath -> prev ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""Relay<S2SV_blank>begin<S2SV_blank>request<S2SV_blank>to<S2SV_blank>Hidden<S2SV_blank>Service<S2SV_blank>"" ""from<S2SV_blank>intermediary<S2SV_blank>node.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""Begin<S2SV_blank>cell<S2SV_blank>for<S2SV_blank>known<S2SV_blank>stream.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { static uint64_t next_id = 0 ; circ -> dirreq_id = ++ next_id ; TO_OR_CIRCUIT ( circ ) -> p_chan -> dirreq_id = circ -> dirreq_id ; } return connection_exit_begin_conn ( cell , circ ) ; case RELAY_COMMAND_DATA : ++ stats_n_data_cells_received ; if ( ( layer_hint && -- layer_hint -> deliver_window < 0 ) || ( ! layer_hint && -- circ -> deliver_window < 0 ) ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""(relay<S2SV_blank>data)<S2SV_blank>circ<S2SV_blank>deliver_window<S2SV_blank>below<S2SV_blank>0.<S2SV_blank>Killing."" ) ; if ( conn ) { connection_edge_end ( conn , END_STREAM_REASON_TORPROTOCOL ) ; connection_mark_for_close ( TO_CONN ( conn ) ) ; } return - END_CIRC_REASON_TORPROTOCOL ; } log_debug ( domain , ""circ<S2SV_blank>deliver_window<S2SV_blank>now<S2SV_blank>%d."" , layer_hint ? layer_hint -> deliver_window : circ -> deliver_window ) ; circuit_consider_sending_sendme ( circ , layer_hint ) ; if ( ! conn ) { log_info ( domain , ""data<S2SV_blank>cell<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream<S2SV_blank>(streamid<S2SV_blank>%d)."" , rh . stream_id ) ; return 0 ; } if ( -- conn -> deliver_window < 0 ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""(relay<S2SV_blank>data)<S2SV_blank>conn<S2SV_blank>deliver_window<S2SV_blank>below<S2SV_blank>0.<S2SV_blank>Killing."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } stats_n_data_bytes_received += rh . length ; connection_write_to_buf ( ( char * ) ( cell -> payload + RELAY_HEADER_SIZE ) , rh . length , TO_CONN ( conn ) ) ; if ( ! optimistic_data ) { connection_edge_consider_sending_sendme ( conn ) ; } return 0 ; case RELAY_COMMAND_END : reason = rh . length > 0 ? get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) : END_STREAM_REASON_MISC ; if ( ! conn ) { log_info ( domain , ""end<S2SV_blank>cell<S2SV_blank>(%s)<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream."" , stream_end_reason_to_string ( reason ) ) ; return 0 ; } log_info ( domain , TOR_SOCKET_T_FORMAT "":<S2SV_blank>end<S2SV_blank>cell<S2SV_blank>(%s)<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>%d.<S2SV_blank>"" ""Removing<S2SV_blank>stream."" , conn -> base_ . s , stream_end_reason_to_string ( reason ) , conn -> stream_id ) ; if ( conn -> base_ . type == CONN_TYPE_AP ) { entry_connection_t * entry_conn = EDGE_TO_ENTRY_CONN ( conn ) ; if ( entry_conn -> socks_request && ! entry_conn -> socks_request -> has_finished ) log_warn ( LD_BUG , ""open<S2SV_blank>stream<S2SV_blank>hasn\'t<S2SV_blank>sent<S2SV_blank>socks<S2SV_blank>answer<S2SV_blank>yet?<S2SV_blank>Closing."" ) ; } conn -> edge_has_sent_end = 1 ; if ( ! conn -> end_reason ) conn -> end_reason = reason | END_STREAM_REASON_FLAG_REMOTE ; if ( ! conn -> base_ . marked_for_close ) { connection_mark_and_flush ( TO_CONN ( conn ) ) ; } return 0 ; case RELAY_COMMAND_EXTEND : case RELAY_COMMAND_EXTEND2 : { static uint64_t total_n_extend = 0 , total_nonearly = 0 ; total_n_extend ++ ; if ( rh . stream_id ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""\'extend\'<S2SV_blank>cell<S2SV_blank>received<S2SV_blank>for<S2SV_blank>non-zero<S2SV_blank>stream.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( cell -> command != CELL_RELAY_EARLY && ! networkstatus_get_param ( NULL , ""AllowNonearlyExtend"" , 0 , 0 , 1 ) ) { # define EARLY_WARNING_INTERVAL 3600 static ratelim_t early_warning_limit = RATELIM_INIT ( EARLY_WARNING_INTERVAL ) ; char * m ; if ( cell -> command == CELL_RELAY ) { ++ total_nonearly ; if ( ( m = rate_limit_log ( & early_warning_limit , approx_time ( ) ) ) ) { double percentage = ( ( double ) total_nonearly ) / total_n_extend ; percentage *= 100 ; log_fn ( LOG_PROTOCOL_WARN , domain , ""EXTEND<S2SV_blank>cell<S2SV_blank>received,<S2SV_blank>"" ""but<S2SV_blank>not<S2SV_blank>via<S2SV_blank>RELAY_EARLY.<S2SV_blank>Dropping.%s"" , m ) ; log_fn ( LOG_PROTOCOL_WARN , domain , ""<S2SV_blank><S2SV_blank>(We<S2SV_blank>have<S2SV_blank>dropped<S2SV_blank>%.02f%%<S2SV_blank>of<S2SV_blank>"" ""all<S2SV_blank>EXTEND<S2SV_blank>cells<S2SV_blank>for<S2SV_blank>this<S2SV_blank>reason)"" , percentage ) ; tor_free ( m ) ; } } else { log_fn ( LOG_WARN , domain , ""EXTEND<S2SV_blank>cell<S2SV_blank>received,<S2SV_blank>in<S2SV_blank>a<S2SV_blank>cell<S2SV_blank>with<S2SV_blank>type<S2SV_blank>%d!<S2SV_blank>Dropping."" , cell -> command ) ; } return 0 ; } return circuit_extend ( cell , circ ) ; } case RELAY_COMMAND_EXTENDED : case RELAY_COMMAND_EXTENDED2 : if ( ! layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""\'extended\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>non-origin.<S2SV_blank>Dropping."" ) ; return 0 ; } log_debug ( domain , ""Got<S2SV_blank>an<S2SV_blank>extended<S2SV_blank>cell!<S2SV_blank>Yay."" ) ; { extended_cell_t extended_cell ; if ( extended_cell_parse ( & extended_cell , rh . command , ( const uint8_t * ) cell -> payload + RELAY_HEADER_SIZE , rh . length ) < 0 ) { log_warn ( LD_PROTOCOL , ""Can\'t<S2SV_blank>parse<S2SV_blank>EXTENDED<S2SV_blank>cell;<S2SV_blank>killing<S2SV_blank>circuit."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } if ( ( reason = circuit_finish_handshake ( TO_ORIGIN_CIRCUIT ( circ ) , & extended_cell . created_cell ) ) < 0 ) { log_warn ( domain , ""circuit_finish_handshake<S2SV_blank>failed."" ) ; return reason ; } } if ( ( reason = circuit_send_next_onion_skin ( TO_ORIGIN_CIRCUIT ( circ ) ) ) < 0 ) { log_info ( domain , ""circuit_send_next_onion_skin()<S2SV_blank>failed."" ) ; return reason ; } return 0 ; case RELAY_COMMAND_TRUNCATE : if ( layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""\'truncate\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>origin.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( circ -> n_hop ) { if ( circ -> n_chan ) log_warn ( LD_BUG , ""n_chan<S2SV_blank>and<S2SV_blank>n_hop<S2SV_blank>set<S2SV_blank>on<S2SV_blank>the<S2SV_blank>same<S2SV_blank>circuit!"" ) ; extend_info_free ( circ -> n_hop ) ; circ -> n_hop = NULL ; tor_free ( circ -> n_chan_create_cell ) ; circuit_set_state ( circ , CIRCUIT_STATE_OPEN ) ; } if ( circ -> n_chan ) { uint8_t trunc_reason = get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) ; circuit_clear_cell_queue ( circ , circ -> n_chan ) ; channel_send_destroy ( circ -> n_circ_id , circ -> n_chan , trunc_reason ) ; circuit_set_n_circid_chan ( circ , 0 , NULL ) ; } log_debug ( LD_EXIT , ""Processed<S2SV_blank>\'truncate\',<S2SV_blank>replying."" ) ; { char payload [ 1 ] ; payload [ 0 ] = ( char ) END_CIRC_REASON_REQUESTED ; relay_send_command_from_edge ( 0 , circ , RELAY_COMMAND_TRUNCATED , payload , sizeof ( payload ) , NULL ) ; } return 0 ; case RELAY_COMMAND_TRUNCATED : if ( ! layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_EXIT , ""\'truncated\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>non-origin.<S2SV_blank>Dropping."" ) ; return 0 ; } circuit_truncated ( TO_ORIGIN_CIRCUIT ( circ ) , layer_hint , get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) ) ; return 0 ; case RELAY_COMMAND_CONNECTED : if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""\'connected\'<S2SV_blank>unsupported<S2SV_blank>while<S2SV_blank>open.<S2SV_blank>Closing<S2SV_blank>circ."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } log_info ( domain , ""\'connected\'<S2SV_blank>received,<S2SV_blank>no<S2SV_blank>conn<S2SV_blank>attached<S2SV_blank>anymore.<S2SV_blank>Ignoring."" ) ; return 0 ; case RELAY_COMMAND_SENDME : if ( ! rh . stream_id ) { if ( layer_hint ) { if ( layer_hint -> package_window + CIRCWINDOW_INCREMENT > CIRCWINDOW_START_MAX ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Unexpected<S2SV_blank>sendme<S2SV_blank>cell<S2SV_blank>from<S2SV_blank>exit<S2SV_blank>relay.<S2SV_blank>"" ""Closing<S2SV_blank>circ."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } layer_hint -> package_window += CIRCWINDOW_INCREMENT ; log_debug ( LD_APP , ""circ-level<S2SV_blank>sendme<S2SV_blank>at<S2SV_blank>origin,<S2SV_blank>packagewindow<S2SV_blank>%d."" , layer_hint -> package_window ) ; circuit_resume_edge_reading ( circ , layer_hint ) ; } else { if ( circ -> package_window + CIRCWINDOW_INCREMENT > CIRCWINDOW_START_MAX ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Unexpected<S2SV_blank>sendme<S2SV_blank>cell<S2SV_blank>from<S2SV_blank>client.<S2SV_blank>"" ""Closing<S2SV_blank>circ<S2SV_blank>(window<S2SV_blank>%d)."" , circ -> package_window ) ; return - END_CIRC_REASON_TORPROTOCOL ; } circ -> package_window += CIRCWINDOW_INCREMENT ; log_debug ( LD_APP , ""circ-level<S2SV_blank>sendme<S2SV_blank>at<S2SV_blank>non-origin,<S2SV_blank>packagewindow<S2SV_blank>%d."" , circ -> package_window ) ; circuit_resume_edge_reading ( circ , layer_hint ) ; } return 0 ; } if ( ! conn ) { log_info ( domain , ""sendme<S2SV_blank>cell<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream<S2SV_blank>(streamid<S2SV_blank>%d)."" , rh . stream_id ) ; return 0 ; } conn -> package_window += STREAMWINDOW_INCREMENT ; log_debug ( domain , ""stream-level<S2SV_blank>sendme,<S2SV_blank>packagewindow<S2SV_blank>now<S2SV_blank>%d."" , conn -> package_window ) ; if ( circuit_queue_streams_are_blocked ( circ ) ) { return 0 ; } connection_start_reading ( TO_CONN ( conn ) ) ; if ( connection_edge_package_raw_inbuf ( conn , 1 , NULL ) < 0 ) { connection_mark_for_close ( TO_CONN ( conn ) ) ; return 0 ; } return 0 ; case RELAY_COMMAND_RESOLVE : if ( layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""resolve<S2SV_blank>request<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>AP;<S2SV_blank>dropping."" ) ; return 0 ; } else if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""resolve<S2SV_blank>request<S2SV_blank>for<S2SV_blank>known<S2SV_blank>stream;<S2SV_blank>dropping."" ) ; return 0 ; } else if ( circ -> purpose != CIRCUIT_PURPOSE_OR ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""resolve<S2SV_blank>request<S2SV_blank>on<S2SV_blank>circ<S2SV_blank>with<S2SV_blank>purpose<S2SV_blank>%d;<S2SV_blank>dropping"" , circ -> purpose ) ; return 0 ; } connection_exit_begin_resolve ( cell , TO_OR_CIRCUIT ( circ ) ) ; return 0 ; case RELAY_COMMAND_RESOLVED : if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""\'resolved\'<S2SV_blank>unsupported<S2SV_blank>while<S2SV_blank>open.<S2SV_blank>Closing<S2SV_blank>circ."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } log_info ( domain , ""\'resolved\'<S2SV_blank>received,<S2SV_blank>no<S2SV_blank>conn<S2SV_blank>attached<S2SV_blank>anymore.<S2SV_blank>Ignoring."" ) ; return 0 ; case RELAY_COMMAND_ESTABLISH_INTRO : case RELAY_COMMAND_ESTABLISH_RENDEZVOUS : case RELAY_COMMAND_INTRODUCE1 : case RELAY_COMMAND_INTRODUCE2 : case RELAY_COMMAND_INTRODUCE_ACK : case RELAY_COMMAND_RENDEZVOUS1 : case RELAY_COMMAND_RENDEZVOUS2 : case RELAY_COMMAND_INTRO_ESTABLISHED : case RELAY_COMMAND_RENDEZVOUS_ESTABLISHED : rend_process_relay_cell ( circ , layer_hint , rh . command , rh . length , cell -> payload + RELAY_HEADER_SIZE ) ; return 0 ; } log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Received<S2SV_blank>unknown<S2SV_blank>relay<S2SV_blank>command<S2SV_blank>%d.<S2SV_blank>Perhaps<S2SV_blank>the<S2SV_blank>other<S2SV_blank>side<S2SV_blank>is<S2SV_blank>using<S2SV_blank>"" ""a<S2SV_blank>newer<S2SV_blank>version<S2SV_blank>of<S2SV_blank>Tor?<S2SV_blank>Dropping."" , rh . command ) ; return 0 ; }
","<S2SV_ModStart> command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED
",torproject@tor/56a7c5bc15e0447203a491c1ee37de9939ad1dcd,CVE-2017-0376,https://github.com/torproject/tor/commit/56a7c5bc15e0447203a491c1ee37de9939ad1dcd,2017-06-09T17:29Z,<S2SV_StartBug> if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { <S2SV_EndBug>
235,CWE-264,"void * arm_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) ) return memory ; return __dma_alloc ( dev , size , handle , gfp , prot , false , __builtin_return_address ( 0 ) ) ; }
","<S2SV_ModStart> ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void
",torvalds@linux/0ea1ec713f04bdfac343c9702b21cd3a7c711826,CVE-2014-9888,https://github.com/torvalds/linux/commit/0ea1ec713f04bdfac343c9702b21cd3a7c711826,2016-08-06T10:59Z,"<S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug>"
299,CWE-125,"void arp_print ( netdissect_options * ndo , const u_char * bp , u_int length , u_int caplen ) { const struct arp_pkthdr * ap ; u_short pro , hrd , op , linkaddr ; ap = ( const struct arp_pkthdr * ) bp ; ND_TCHECK ( * ap ) ; hrd = HRD ( ap ) ; pro = PRO ( ap ) ; op = OP ( ap ) ; switch ( hrd ) { case ARPHRD_ATM2225 : atmarp_print ( ndo , bp , length , caplen ) ; return ; case ARPHRD_FRELAY : linkaddr = LINKADDR_FRELAY ; break ; default : linkaddr = LINKADDR_ETHER ; break ; } if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; return ; } if ( ! ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ; } if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || PROTO_LEN ( ap ) != 4 || HRD_LEN ( ap ) == 0 || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>(len<S2SV_blank>%u),<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , HRD_LEN ( ap ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , PROTO_LEN ( ap ) ) ) ; if ( ! ndo -> ndo_vflag ) { goto out ; } } ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>"" , ndo -> ndo_vflag ? "",<S2SV_blank>"" : """" , tok2str ( arpop_values , ""Unknown<S2SV_blank>(%u)"" , op ) ) ) ; switch ( op ) { case ARPOP_REQUEST : ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; break ; case ARPOP_REPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_REVREPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; break ; case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_INVREPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; break ; default : ND_DEFAULTPRINT ( ( const u_char * ) ap , caplen ) ; return ; } out : ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> ND_TTEST2 ( * TPA <S2SV_ModEnd> ( ap ) <S2SV_ModStart> ( ndo , ""who-has<S2SV_blank>"" ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> case ARPOP_REPLY : spaddr_print_ip ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>%s"" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ( ndo , ""%s<S2SV_blank>at<S2SV_blank>"" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ap ) ) ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( ndo , ""%s<S2SV_blank>at<S2SV_blank>"" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ap ) ) ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break
",the-tcpdump-group@tcpdump/13ab8d18617d616c7d343530f8a842e7143fb5cc,CVE-2017-13013,https://github.com/the-tcpdump-group/tcpdump/commit/13ab8d18617d616c7d343530f8a842e7143fb5cc,2017-09-14T06:29Z,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug>"
5917,CWE-269,"int main ( int argc , char * * argv ) { const char * safepath = SAFE_PATH ; const char * confpath = NULL ; char * shargv [ ] = { NULL , NULL } ; char * sh ; const char * cmd ; char cmdline [ LINE_MAX ] ; char myname [ _PW_NAME_LEN + 1 ] ; struct passwd * original_pw , * target_pw ; struct rule * rule ; uid_t uid ; uid_t target = 0 ; gid_t groups [ NGROUPS_MAX + 1 ] ; int ngroups ; int i , ch ; int sflag = 0 ; int nflag = 0 ; char cwdpath [ PATH_MAX ] ; const char * cwd ; char * login_style = NULL ; char * * envp ; # ifndef linux setprogname ( ""doas"" ) ; # endif # ifndef linux closefrom ( STDERR_FILENO + 1 ) ; # endif uid = getuid ( ) ; while ( ( ch = getopt ( argc , argv , ""a:C:nsu:"" ) ) != - 1 ) { switch ( ch ) { case 'a' : login_style = optarg ; break ; case 'C' : confpath = optarg ; break ; case 'u' : if ( parseuid ( optarg , & target ) != 0 ) errx ( 1 , ""unknown<S2SV_blank>user"" ) ; break ; case 'n' : nflag = 1 ; break ; case 's' : sflag = 1 ; break ; default : usage ( ) ; break ; } } argv += optind ; argc -= optind ; if ( confpath ) { if ( sflag ) usage ( ) ; } else if ( ( ! sflag && ! argc ) || ( sflag && argc ) ) usage ( ) ; original_pw = getpwuid ( uid ) ; if ( ! original_pw ) err ( 1 , ""getpwuid<S2SV_blank>failed"" ) ; if ( strlcpy ( myname , original_pw -> pw_name , sizeof ( myname ) ) >= sizeof ( myname ) ) errx ( 1 , ""pw_name<S2SV_blank>too<S2SV_blank>long"" ) ; ngroups = getgroups ( NGROUPS_MAX , groups ) ; if ( ngroups == - 1 ) err ( 1 , ""can\'t<S2SV_blank>get<S2SV_blank>groups"" ) ; groups [ ngroups ++ ] = getgid ( ) ; if ( sflag ) { sh = getenv ( ""SHELL"" ) ; if ( sh == NULL || * sh == '\\0' ) { shargv [ 0 ] = strdup ( original_pw -> pw_shell ) ; if ( shargv [ 0 ] == NULL ) err ( 1 , NULL ) ; } else shargv [ 0 ] = sh ; argv = shargv ; argc = 1 ; } if ( confpath ) { checkconfig ( confpath , argc , argv , uid , groups , ngroups , target ) ; exit ( 1 ) ; } if ( geteuid ( ) ) errx ( 1 , ""not<S2SV_blank>installed<S2SV_blank>setuid"" ) ; parseconfig ( DOAS_CONF , 1 ) ; ( void ) strlcpy ( cmdline , argv [ 0 ] , sizeof ( cmdline ) ) ; for ( i = 1 ; i < argc ; i ++ ) { if ( strlcat ( cmdline , ""<S2SV_blank>"" , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; if ( strlcat ( cmdline , argv [ i ] , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; } cmd = argv [ 0 ] ; if ( ! permit ( uid , groups , ngroups , & rule , target , cmd , ( const char * * ) argv + 1 ) ) { syslog ( LOG_AUTHPRIV | LOG_NOTICE , ""failed<S2SV_blank>command<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , myname , cmdline ) ; errc ( 1 , EPERM , NULL ) ; } if ( ! ( rule -> options & NOPASS ) ) { if ( nflag ) errx ( 1 , ""Authorization<S2SV_blank>required"" ) ; # if defined ( USE_BSD_AUTH ) authuser ( myname , login_style , rule -> options & PERSIST ) ; # elif defined ( USE_PAM ) # define PAM_END ( msg ) do { syslog ( LOG_ERR , ""%s:<S2SV_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; warnx ( ""%s:<S2SV_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; pam_end ( pamh , pam_err ) ; exit ( EXIT_FAILURE ) ; } while ( 0 ) pam_handle_t * pamh = NULL ; int pam_err ; int temp_stdin ; temp_stdin = dup ( STDIN_FILENO ) ; if ( temp_stdin == - 1 ) err ( 1 , ""dup"" ) ; close ( STDIN_FILENO ) ; int temp_stdout = dup ( 1 ) ; if ( temp_stdout == - 1 ) err ( 1 , ""dup"" ) ; close ( 1 ) ; if ( dup2 ( 2 , 1 ) == - 1 ) err ( 1 , ""dup2"" ) ; pam_err = pam_start ( ""doas"" , myname , & pamc , & pamh ) ; if ( pam_err != PAM_SUCCESS ) { if ( pamh != NULL ) PAM_END ( ""pam_start"" ) ; syslog ( LOG_ERR , ""pam_start<S2SV_blank>failed:<S2SV_blank>%s"" , pam_strerror ( pamh , pam_err ) ) ; errx ( EXIT_FAILURE , ""pam_start<S2SV_blank>failed"" ) ; } switch ( pam_err = pam_authenticate ( pamh , PAM_SILENT ) ) { case PAM_SUCCESS : switch ( pam_err = pam_acct_mgmt ( pamh , PAM_SILENT ) ) { case PAM_SUCCESS : break ; case PAM_NEW_AUTHTOK_REQD : pam_err = pam_chauthtok ( pamh , PAM_SILENT | PAM_CHANGE_EXPIRED_AUTHTOK ) ; if ( pam_err != PAM_SUCCESS ) PAM_END ( ""pam_chauthtok"" ) ; break ; case PAM_AUTH_ERR : case PAM_USER_UNKNOWN : case PAM_MAXTRIES : syslog ( LOG_AUTHPRIV | LOG_NOTICE , ""failed<S2SV_blank>auth<S2SV_blank>for<S2SV_blank>%s"" , myname ) ; errx ( EXIT_FAILURE , ""second<S2SV_blank>authentication<S2SV_blank>failed"" ) ; break ; default : PAM_END ( ""pam_acct_mgmt"" ) ; break ; } break ; case PAM_AUTH_ERR : case PAM_USER_UNKNOWN : case PAM_MAXTRIES : syslog ( LOG_AUTHPRIV | LOG_NOTICE , ""failed<S2SV_blank>auth<S2SV_blank>for<S2SV_blank>%s"" , myname ) ; errx ( EXIT_FAILURE , ""authentication<S2SV_blank>failed"" ) ; break ; default : PAM_END ( ""pam_authenticate"" ) ; break ; } pam_end ( pamh , pam_err ) ; # ifndef linux if ( dup2 ( temp_stdin , STDIN_FILENO ) == - 1 ) err ( 1 , ""dup2"" ) ; close ( temp_stdin ) ; # else close ( 1 ) ; if ( dup2 ( temp_stdout , 1 ) == - 1 ) err ( 1 , ""dup2"" ) ; # endif # else # error No auth module ! # endif } target_pw = getpwuid ( target ) ; if ( ! target_pw ) errx ( 1 , ""no<S2SV_blank>passwd<S2SV_blank>entry<S2SV_blank>for<S2SV_blank>target"" ) ; # if defined ( HAVE_LOGIN_CAP_H ) if ( setusercontext ( NULL , target_pw , target , LOGIN_SETGROUP | LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK | LOGIN_SETUSER ) != 0 ) errx ( 1 , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>user<S2SV_blank>context<S2SV_blank>for<S2SV_blank>target"" ) ; # endif if ( getcwd ( cwdpath , sizeof ( cwdpath ) ) == NULL ) cwd = ""(failed)"" ; else cwd = cwdpath ; # ifndef HAVE_LOGIN_CAP_H if ( target != 0 ) setuid ( target ) ; if ( geteuid ( ) == ROOT_UID ) setuid ( ROOT_UID ) ; # endif syslog ( LOG_AUTHPRIV | LOG_INFO , ""%s<S2SV_blank>ran<S2SV_blank>command<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s"" , myname , cmdline , target_pw -> pw_name , cwd ) ; envp = prepenv ( rule , original_pw , target_pw ) ; if ( rule -> cmd ) { if ( setenv ( ""PATH"" , safepath , 1 ) == - 1 ) err ( 1 , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>PATH<S2SV_blank>\'%s\'"" , safepath ) ; } execvpe ( cmd , argv , envp ) ; if ( errno == ENOENT ) errx ( 1 , ""%s:<S2SV_blank>command<S2SV_blank>not<S2SV_blank>found"" , cmd ) ; err ( 1 , ""%s"" , cmd ) ; }
","<S2SV_ModStart> EXIT_FAILURE ) ; \\\n} <S2SV_ModEnd> while ( 0 <S2SV_ModStart> ) ; # else # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresgid ( target_pw -> pw_gid , target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setresgid"" ) ; # else if ( setregid ( target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setregid"" ) ; # endif if ( initgroups ( target_pw -> pw_name , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""initgroups"" ) ; # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresuid ( target , target , target ) == - 1 ) err ( 1 , ""setresuid"" ) ; # else if ( setreuid ( target , target ) == - 1 ) err ( 1 , ""setreuid"" ) ; # endif # <S2SV_ModStart> = cwdpath ; <S2SV_ModEnd> syslog ( LOG_AUTHPRIV
",slicer69@doas/6cf0236184ff6304bf5e267ccf7ef02874069697,CVE-2019-15901,https://github.com/slicer69/doas/commit/6cf0236184ff6304bf5e267ccf7ef02874069697,2019-10-18T16:15Z,"<S2SV_StartBug> # define PAM_END ( msg ) do { syslog ( LOG_ERR , ""%s:<S2SV_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; warnx ( ""%s:<S2SV_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; pam_end ( pamh , pam_err ) ; exit ( EXIT_FAILURE ) ; } while ( 0 ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # ifndef HAVE_LOGIN_CAP_H <S2SV_EndBug>"
1027,CWE-284,"static inline int accept_server_socket ( int s ) { struct sockaddr_un client_address ; socklen_t clen ; int fd = accept ( s , ( struct sockaddr * ) & client_address , & clen ) ; APPL_TRACE_DEBUG ( ""accepted<S2SV_blank>fd:%d<S2SV_blank>for<S2SV_blank>server<S2SV_blank>fd:%d"" , fd , s ) ; return fd ; }
","<S2SV_ModStart> int fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & clen )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> int fd = accept ( s , ( struct sockaddr * ) & client_address , & clen ) ; <S2SV_EndBug>"
384,CWE-119,"ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { size_t ss = CDF_SEC_SIZE ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ; if ( pos > ss * sst -> sst_len ) { DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , pos , ss * sst -> sst_len ) ) ; return - 1 ; } ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ; return len ; }
","<S2SV_ModStart> size_t ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h ) <S2SV_ModStart> ( pos > CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst -> <S2SV_ModStart> , pos , CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst ->
",glensc@file/1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b,CVE-2012-1571,https://github.com/glensc/file/commit/1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b,2012-07-17T21:55Z,"<S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pos > ss * sst -> sst_len ) { <S2SV_EndBug> <S2SV_StartBug> pos , ss * sst -> sst_len ) ) ; <S2SV_EndBug>"
3458,CWE-125,"static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ; if ( len < sizeof ( * prep ) ) { return ( - 1 ) ; } n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }
","<S2SV_ModStart> * prep ) || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> return ( - <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS
",the-tcpdump-group@tcpdump/cc356512f512e7fa423b3674db4bb31dbe40ffec,CVE-2017-13014,https://github.com/the-tcpdump-group/tcpdump/commit/cc356512f512e7fa423b3674db4bb31dbe40ffec,2017-09-14T06:29Z,<S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
3207,CWE-200,"static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , ""application<S2SV_blank>%i"" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; kfree ( tu -> queue ) ; tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; tu -> timeri -> disconnect = snd_timer_user_disconnect ; } __err : return err ; }
","<S2SV_ModStart> goto __err ; tu -> qhead = tu -> qtail = tu -> qused = 0 ;
",torvalds@linux/ba3021b2c79b2fa9114f92790a99deb27a65b728,CVE-2017-1000380,https://github.com/torvalds/linux/commit/ba3021b2c79b2fa9114f92790a99deb27a65b728,2017-06-17T18:29Z,<S2SV_StartBug> kfree ( tu -> queue ) ; <S2SV_EndBug>
8246,CWE-787,"static inline int l2cap_config_req ( struct l2cap_conn * conn , struct l2cap_cmd_hdr * cmd , u16 cmd_len , u8 * data ) { struct l2cap_conf_req * req = ( struct l2cap_conf_req * ) data ; u16 dcid , flags ; u8 rsp [ 64 ] ; struct sock * sk ; int len ; dcid = __le16_to_cpu ( req -> dcid ) ; flags = __le16_to_cpu ( req -> flags ) ; BT_DBG ( ""dcid<S2SV_blank>0x%4.4x<S2SV_blank>flags<S2SV_blank>0x%2.2x"" , dcid , flags ) ; sk = l2cap_get_chan_by_scid ( & conn -> chan_list , dcid ) ; if ( ! sk ) return - ENOENT ; if ( sk -> sk_state == BT_DISCONN ) goto unlock ; len = cmd_len - sizeof ( * req ) ; if ( l2cap_pi ( sk ) -> conf_len + len > sizeof ( l2cap_pi ( sk ) -> conf_req ) ) { l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , l2cap_build_conf_rsp ( sk , rsp , L2CAP_CONF_REJECT , flags ) , rsp ) ; goto unlock ; } memcpy ( l2cap_pi ( sk ) -> conf_req + l2cap_pi ( sk ) -> conf_len , req -> data , len ) ; l2cap_pi ( sk ) -> conf_len += len ; if ( flags & 0x0001 ) { l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , l2cap_build_conf_rsp ( sk , rsp , L2CAP_CONF_SUCCESS , 0x0001 ) , rsp ) ; goto unlock ; } len = l2cap_parse_conf_req ( sk , rsp ) ; if ( len < 0 ) goto unlock ; l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , len , rsp ) ; l2cap_pi ( sk ) -> conf_len = 0 ; if ( ! ( l2cap_pi ( sk ) -> conf_state & L2CAP_CONF_OUTPUT_DONE ) ) goto unlock ; if ( l2cap_pi ( sk ) -> conf_state & L2CAP_CONF_INPUT_DONE ) { sk -> sk_state = BT_CONNECTED ; l2cap_chan_ready ( sk ) ; goto unlock ; } if ( ! ( l2cap_pi ( sk ) -> conf_state & L2CAP_CONF_REQ_SENT ) ) { u8 buf [ 64 ] ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , l2cap_build_conf_req ( sk , buf ) , buf ) ; } unlock : bh_unlock_sock ( sk ) ; return 0 ; }
","<S2SV_ModStart> < 0 ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; <S2SV_ModStart> goto unlock ; } <S2SV_ModStart> , rsp ) ; l2cap_pi ( sk ) -> num_conf_rsp ++ <S2SV_ModStart> buf ) ; l2cap_pi ( sk ) -> num_conf_req ++ ;
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z,"<S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , len , rsp ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
2516,CWE-119,"void PNGAPI png_info_init_3 ( png_infopp ptr_ptr , png_size_t png_info_struct_size ) { png_infop info_ptr = * ptr_ptr ; png_debug ( 1 , ""in<S2SV_blank>png_info_init_3"" ) ; if ( info_ptr == NULL ) return ; if ( png_sizeof ( png_info ) > png_info_struct_size ) { png_destroy_struct ( info_ptr ) ; info_ptr = ( png_infop ) png_create_struct ( PNG_STRUCT_INFO ) ; * ptr_ptr = info_ptr ; } png_memset ( info_ptr , 0 , png_sizeof ( png_info ) ) ; }
","<S2SV_ModStart> = info_ptr ; if ( info_ptr == NULL ) return ;
",chromium@chromium/7f3d85b096f66870a15b37c2f40b219b2e292693,CVE-2015-8126,https://github.com/chromium/chromium/commit/7f3d85b096f66870a15b37c2f40b219b2e292693,2015-11-13T03:59Z,<S2SV_StartBug> } <S2SV_EndBug>
1640,CWE-119,"int vp9_block_energy ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bs ) { double energy ; unsigned int var = block_variance ( cpi , x , bs ) ; vp9_clear_system_state ( ) ; energy = 0.9 * ( log ( var + 1.0 ) - 10.0 ) ; return clamp ( ( int ) round ( energy ) , ENERGY_MIN , ENERGY_MAX ) ; }
","<S2SV_ModStart> double energy ; double energy_midpoint ; vpx_clear_system_state ( ) ; energy_midpoint = ( cpi -> oxcf . pass == 2 ) ? cpi -> twopass . mb_av_energy : DEFAULT_E_MIDPOINT ; energy = vp9_log_block_var <S2SV_ModEnd> ( cpi , <S2SV_ModStart> , bs ) - energy_midpoint <S2SV_ModEnd> ; return clamp
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> unsigned int var = block_variance ( cpi , x , bs ) ; <S2SV_EndBug>"
3092,CWE-835,"void gsm_xsmp_client_connect ( GsmXSMPClient * client , SmsConn conn , unsigned long * mask_ret , SmsCallbacks * callbacks_ret ) { client -> priv -> conn = conn ; if ( client -> priv -> protocol_timeout ) { g_source_remove ( client -> priv -> protocol_timeout ) ; client -> priv -> protocol_timeout = 0 ; } g_debug ( ""GsmXSMPClient:<S2SV_blank>Initializing<S2SV_blank>client<S2SV_blank>%s"" , client -> priv -> description ) ; * mask_ret = 0 ; * mask_ret |= SmsRegisterClientProcMask ; callbacks_ret -> register_client . callback = register_client_callback ; callbacks_ret -> register_client . manager_data = client ; * mask_ret |= SmsInteractRequestProcMask ; callbacks_ret -> interact_request . callback = interact_request_callback ; callbacks_ret -> interact_request . manager_data = client ; * mask_ret |= SmsInteractDoneProcMask ; callbacks_ret -> interact_done . callback = interact_done_callback ; callbacks_ret -> interact_done . manager_data = client ; * mask_ret |= SmsSaveYourselfRequestProcMask ; callbacks_ret -> save_yourself_request . callback = save_yourself_request_callback ; callbacks_ret -> save_yourself_request . manager_data = client ; * mask_ret |= SmsSaveYourselfP2RequestProcMask ; callbacks_ret -> save_yourself_phase2_request . callback = save_yourself_phase2_request_callback ; callbacks_ret -> save_yourself_phase2_request . manager_data = client ; * mask_ret |= SmsSaveYourselfDoneProcMask ; callbacks_ret -> save_yourself_done . callback = save_yourself_done_callback ; callbacks_ret -> save_yourself_done . manager_data = client ; * mask_ret |= SmsCloseConnectionProcMask ; callbacks_ret -> close_connection . callback = close_connection_callback ; callbacks_ret -> close_connection . manager_data = client ; * mask_ret |= SmsSetPropertiesProcMask ; callbacks_ret -> set_properties . callback = set_properties_callback ; callbacks_ret -> set_properties . manager_data = client ; * mask_ret |= SmsDeletePropertiesProcMask ; callbacks_ret -> delete_properties . callback = delete_properties_callback ; callbacks_ret -> delete_properties . manager_data = client ; * mask_ret |= SmsGetPropertiesProcMask ; callbacks_ret -> get_properties . callback = get_properties_callback ; callbacks_ret -> get_properties . manager_data = client ; }
","<S2SV_ModStart> = conn ; <S2SV_ModEnd> g_debug ( ""GsmXSMPClient:<S2SV_blank>Initializing<S2SV_blank>client<S2SV_blank>%s""
",GNOME@gnome-session/b0dc999e0b45355314616321dbb6cb71e729fc9d,CVE-2017-11171,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,2017-07-11T20:29Z,<S2SV_StartBug> if ( client -> priv -> protocol_timeout ) { <S2SV_EndBug>
5988,CWE-119,"static inline void header_put_le_3byte ( SF_PRIVATE * psf , int x ) { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) { psf -> header [ psf -> headindex ++ ] = x ; psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; } ; }
","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug>
3524,CWE-264,"static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg , u8 cpl , bool in_task_switch ) { struct desc_struct seg_desc , old_desc ; u8 dpl , rpl ; unsigned err_vec = GP_VECTOR ; u32 err_code = 0 ; bool null_selector = ! ( selector & ~ 0x3 ) ; ulong desc_addr ; int ret ; u16 dummy ; u32 base3 = 0 ; memset ( & seg_desc , 0 , sizeof seg_desc ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) { ctxt -> ops -> get_segment ( ctxt , & dummy , & seg_desc , NULL , seg ) ; set_desc_base ( & seg_desc , selector << 4 ) ; goto load ; } else if ( seg <= VCPU_SREG_GS && ctxt -> mode == X86EMUL_MODE_VM86 ) { set_desc_base ( & seg_desc , selector << 4 ) ; set_desc_limit ( & seg_desc , 0xffff ) ; seg_desc . type = 3 ; seg_desc . p = 1 ; seg_desc . s = 1 ; seg_desc . dpl = 3 ; goto load ; } rpl = selector & 3 ; if ( ( seg == VCPU_SREG_CS || ( seg == VCPU_SREG_SS && ( ctxt -> mode != X86EMUL_MODE_PROT64 || rpl != cpl ) ) || seg == VCPU_SREG_TR ) && null_selector ) goto exception ; if ( seg == VCPU_SREG_TR && ( selector & ( 1 << 2 ) ) ) goto exception ; if ( null_selector ) goto load ; ret = read_segment_descriptor ( ctxt , selector , & seg_desc , & desc_addr ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; err_code = selector & 0xfffc ; err_vec = in_task_switch ? TS_VECTOR : GP_VECTOR ; if ( seg <= VCPU_SREG_GS && ! seg_desc . s ) goto exception ; if ( ! seg_desc . p ) { err_vec = ( seg == VCPU_SREG_SS ) ? SS_VECTOR : NP_VECTOR ; goto exception ; } dpl = seg_desc . dpl ; switch ( seg ) { case VCPU_SREG_SS : if ( rpl != cpl || ( seg_desc . type & 0xa ) != 0x2 || dpl != cpl ) goto exception ; break ; case VCPU_SREG_CS : if ( ! ( seg_desc . type & 8 ) ) goto exception ; if ( seg_desc . type & 4 ) { if ( dpl > cpl ) goto exception ; } else { if ( rpl > cpl || dpl != cpl ) goto exception ; } if ( seg_desc . d && seg_desc . l ) { u64 efer = 0 ; ctxt -> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( efer & EFER_LMA ) goto exception ; } selector = ( selector & 0xfffc ) | cpl ; break ; case VCPU_SREG_TR : if ( seg_desc . s || ( seg_desc . type != 1 && seg_desc . type != 9 ) ) goto exception ; old_desc = seg_desc ; seg_desc . type |= 2 ; ret = ctxt -> ops -> cmpxchg_emulated ( ctxt , desc_addr , & old_desc , & seg_desc , sizeof ( seg_desc ) , & ctxt -> exception ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; break ; case VCPU_SREG_LDTR : if ( seg_desc . s || seg_desc . type != 2 ) goto exception ; break ; default : if ( ( seg_desc . type & 0xa ) == 0x8 || ( ( ( seg_desc . type & 0xc ) != 0xc ) && ( rpl > dpl && cpl > dpl ) ) ) goto exception ; break ; } if ( seg_desc . s ) { seg_desc . type |= 1 ; ret = write_segment_descriptor ( ctxt , selector , & seg_desc ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; } else if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) { ret = ctxt -> ops -> read_std ( ctxt , desc_addr + 8 , & base3 , sizeof ( base3 ) , & ctxt -> exception ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; } load : ctxt -> ops -> set_segment ( ctxt , selector , & seg_desc , base3 , seg ) ; return X86EMUL_CONTINUE ; exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ; }
","<S2SV_ModStart> , bool in_task_switch , struct desc_struct * desc <S2SV_ModStart> seg ) ; if ( desc ) * desc = seg_desc ;
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z,"<S2SV_StartBug> u16 selector , int seg , u8 cpl , bool in_task_switch ) <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug>"
2915,CWE-000,"struct sk_buff * nf_ct_frag6_gather ( struct sk_buff * skb , u32 user ) { struct sk_buff * clone ; struct net_device * dev = skb -> dev ; struct frag_hdr * fhdr ; struct nf_ct_frag6_queue * fq ; struct ipv6hdr * hdr ; int fhoff , nhoff ; u8 prevhdr ; struct sk_buff * ret_skb = NULL ; if ( ipv6_hdr ( skb ) -> payload_len == 0 ) { pr_debug ( ""payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\n"" ) ; return skb ; } if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ; clone = skb_clone ( skb , GFP_ATOMIC ) ; if ( clone == NULL ) { pr_debug ( ""Can\'t<S2SV_blank>clone<S2SV_blank>skb\\n"" ) ; return skb ; } NFCT_FRAG6_CB ( clone ) -> orig = skb ; if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) { pr_debug ( ""message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\n"" ) ; goto ret_orig ; } skb_set_transport_header ( clone , fhoff ) ; hdr = ipv6_hdr ( clone ) ; fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ; if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { pr_debug ( ""Invalid<S2SV_blank>fragment<S2SV_blank>offset\\n"" ) ; goto ret_orig ; } if ( atomic_read ( & nf_init_frags . mem ) > nf_init_frags . high_thresh ) nf_ct_frag6_evictor ( ) ; fq = fq_find ( fhdr -> identification , user , & hdr -> saddr , & hdr -> daddr ) ; if ( fq == NULL ) { pr_debug ( ""Can\'t<S2SV_blank>find<S2SV_blank>and<S2SV_blank>can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>queue\\n"" ) ; goto ret_orig ; } spin_lock_bh ( & fq -> q . lock ) ; if ( nf_ct_frag6_queue ( fq , clone , fhdr , nhoff ) < 0 ) { spin_unlock_bh ( & fq -> q . lock ) ; pr_debug ( ""Can\'t<S2SV_blank>insert<S2SV_blank>skb<S2SV_blank>to<S2SV_blank>queue\\n"" ) ; fq_put ( fq ) ; goto ret_orig ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) { ret_skb = nf_ct_frag6_reasm ( fq , dev ) ; if ( ret_skb == NULL ) pr_debug ( ""Can\'t<S2SV_blank>reassemble<S2SV_blank>fragmented<S2SV_blank>packets\\n"" ) ; } spin_unlock_bh ( & fq -> q . lock ) ; fq_put ( fq ) ; return ret_skb ; ret_orig : kfree_skb ( clone ) ; return skb ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> atomic_read ( &
",torvalds@linux/9e2dcf72023d1447f09c47d77c99b0c49659e5ce,CVE-2012-2744,https://github.com/torvalds/linux/commit/9e2dcf72023d1447f09c47d77c99b0c49659e5ce,2012-08-09T10:29Z,<S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug>
688,CWE-189,"Datum hstore_recv ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; int32 i ; int32 pcount ; StringInfo buf = ( StringInfo ) PG_GETARG_POINTER ( 0 ) ; pcount = pq_getmsgint ( buf , 4 ) ; if ( pcount == 0 ) { out = hstorePairs ( NULL , 0 , 0 ) ; PG_RETURN_POINTER ( out ) ; } pairs = palloc ( pcount * sizeof ( Pairs ) ) ; for ( i = 0 ; i < pcount ; ++ i ) { int rawlen = pq_getmsgint ( buf , 4 ) ; int len ; if ( rawlen < 0 ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( ""null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key"" ) ) ) ; pairs [ i ] . key = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( len ) ; pairs [ i ] . needfree = true ; rawlen = pq_getmsgint ( buf , 4 ) ; if ( rawlen < 0 ) { pairs [ i ] . val = NULL ; pairs [ i ] . vallen = 0 ; pairs [ i ] . isnull = true ; } else { pairs [ i ] . val = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . vallen = hstoreCheckValLen ( len ) ; pairs [ i ] . isnull = false ; } } pcount = hstoreUniquePairs ( pairs , pcount , & buflen ) ; out = hstorePairs ( pairs , pcount , buflen ) ; PG_RETURN_POINTER ( out ) ; }
","<S2SV_ModStart> ) ; } if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,<S2SV_StartBug> pairs = palloc ( pcount * sizeof ( Pairs ) ) ; <S2SV_EndBug>
3319,CWE-125,"static int rx_cache_find ( const struct rx_header * rxh , const struct ip * ip , int sport , int32_t * opcode ) { int i ; struct rx_cache_entry * rxent ; uint32_t clip ; uint32_t sip ; UNALIGNED_MEMCPY ( & clip , & ip -> ip_dst , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & sip , & ip -> ip_src , sizeof ( uint32_t ) ) ; i = rx_cache_hint ; do { rxent = & rx_cache [ i ] ; if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip && rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && rxent -> dport == sport ) { rx_cache_hint = i ; * opcode = rxent -> opcode ; return ( 1 ) ; } if ( ++ i >= RX_CACHE_SIZE ) i = 0 ; } while ( i != rx_cache_hint ) ; return ( 0 ) ; }
","<S2SV_ModStart> -> serviceId == EXTRACT_16BITS <S2SV_ModEnd> ( & rxh
",the-tcpdump-group@tcpdump/c24922e692a52121e853a84ead6b9337f4c08a94,CVE-2018-14466,https://github.com/the-tcpdump-group/tcpdump/commit/c24922e692a52121e853a84ead6b9337f4c08a94,2019-10-03T16:15Z,<S2SV_StartBug> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <S2SV_EndBug>
818,CWE-119,"void WT_InterpolateNoLoop ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = ( EAS_I32 ) pWTVoice -> phaseFrac ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }
","<S2SV_ModStart> -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; }
",external@sonivox/3ac044334c3ff6a61cb4238ff3ddaf17c7efcf49,CVE-2016-0838,https://android.googlesource.com/platform/external/sonivox/+/3ac044334c3ff6a61cb4238ff3ddaf17c7efcf49,2016-04-18T00:59Z,<S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug>
4875,CWE-362,"static int mptctl_hp_hostinfo ( unsigned long arg , unsigned int data_size ) { hp_host_info_t __user * uarg = ( void __user * ) arg ; MPT_ADAPTER * ioc ; struct pci_dev * pdev ; char * pbuf = NULL ; dma_addr_t buf_dma ; hp_host_info_t karg ; CONFIGPARMS cfg ; ConfigPageHeader_t hdr ; int iocnum ; int rc , cim_rev ; ToolboxIstwiReadWriteRequest_t * IstwiRWRequest ; MPT_FRAME_HDR * mf = NULL ; unsigned long timeleft ; int retval ; u32 msgcontext ; if ( data_size == sizeof ( hp_host_info_t ) ) cim_rev = 1 ; else if ( data_size == sizeof ( hp_host_info_rev0_t ) ) cim_rev = 0 ; else return - EFAULT ; if ( copy_from_user ( & karg , uarg , sizeof ( hp_host_info_t ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_hp_host_info<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>hp_host_info<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_hp_hostinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT "":<S2SV_blank>mptctl_hp_hostinfo<S2SV_blank>called.\\n"" , ioc -> name ) ) ; pdev = ( struct pci_dev * ) ioc -> pcidev ; karg . vendor = pdev -> vendor ; karg . device = pdev -> device ; karg . subsystem_id = pdev -> subsystem_device ; karg . subsystem_vendor = pdev -> subsystem_vendor ; karg . devfn = pdev -> devfn ; karg . bus = pdev -> bus -> number ; if ( ioc -> sh != NULL ) karg . host_no = ioc -> sh -> host_no ; else karg . host_no = - 1 ; snprintf ( karg . fw_version , sizeof ( karg . fw_version ) , ""%.2hhu.%.2hhu.%.2hhu.%.2hhu"" , ioc -> facts . FWVersion . Struct . Major , ioc -> facts . FWVersion . Struct . Minor , ioc -> facts . FWVersion . Struct . Unit , ioc -> facts . FWVersion . Struct . Dev ) ; hdr . PageVersion = 0 ; hdr . PageLength = 0 ; hdr . PageNumber = 0 ; hdr . PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING ; cfg . cfghdr . hdr = & hdr ; cfg . physAddr = - 1 ; cfg . pageAddr = 0 ; cfg . action = MPI_CONFIG_ACTION_PAGE_HEADER ; cfg . dir = 0 ; cfg . timeout = 10 ; strncpy ( karg . serial_number , ""<S2SV_blank>"" , 24 ) ; if ( mpt_config ( ioc , & cfg ) == 0 ) { if ( cfg . cfghdr . hdr -> PageLength > 0 ) { cfg . action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT ; pbuf = pci_alloc_consistent ( ioc -> pcidev , hdr . PageLength * 4 , & buf_dma ) ; if ( pbuf ) { cfg . physAddr = buf_dma ; if ( mpt_config ( ioc , & cfg ) == 0 ) { ManufacturingPage0_t * pdata = ( ManufacturingPage0_t * ) pbuf ; if ( strlen ( pdata -> BoardTracerNumber ) > 1 ) { strlcpy ( karg . serial_number , pdata -> BoardTracerNumber , 24 ) ; } } pci_free_consistent ( ioc -> pcidev , hdr . PageLength * 4 , pbuf , buf_dma ) ; pbuf = NULL ; } } } rc = mpt_GetIocState ( ioc , 1 ) ; switch ( rc ) { case MPI_IOC_STATE_OPERATIONAL : karg . ioc_status = HP_STATUS_OK ; break ; case MPI_IOC_STATE_FAULT : karg . ioc_status = HP_STATUS_FAILED ; break ; case MPI_IOC_STATE_RESET : case MPI_IOC_STATE_READY : default : karg . ioc_status = HP_STATUS_OTHER ; break ; } karg . base_io_addr = pci_resource_start ( pdev , 0 ) ; if ( ( ioc -> bus_type == SAS ) || ( ioc -> bus_type == FC ) ) karg . bus_phys_width = HP_BUS_WIDTH_UNK ; else karg . bus_phys_width = HP_BUS_WIDTH_16 ; karg . hard_resets = 0 ; karg . soft_resets = 0 ; karg . timeouts = 0 ; if ( ioc -> sh != NULL ) { MPT_SCSI_HOST * hd = shost_priv ( ioc -> sh ) ; if ( hd && ( cim_rev == 1 ) ) { karg . hard_resets = ioc -> hard_resets ; karg . soft_resets = ioc -> soft_resets ; karg . timeouts = ioc -> timeouts ; } } if ( ( mf = mpt_get_msg_frame ( mptctl_id , ioc ) ) == NULL ) { dfailprintk ( ioc , printk ( MYIOC_s_WARN_FMT ""%s,<S2SV_blank>no<S2SV_blank>msg<S2SV_blank>frames!!\\n"" , ioc -> name , __func__ ) ) ; goto out ; } IstwiRWRequest = ( ToolboxIstwiReadWriteRequest_t * ) mf ; msgcontext = IstwiRWRequest -> MsgContext ; memset ( IstwiRWRequest , 0 , sizeof ( ToolboxIstwiReadWriteRequest_t ) ) ; IstwiRWRequest -> MsgContext = msgcontext ; IstwiRWRequest -> Function = MPI_FUNCTION_TOOLBOX ; IstwiRWRequest -> Tool = MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL ; IstwiRWRequest -> Flags = MPI_TB_ISTWI_FLAGS_READ ; IstwiRWRequest -> NumAddressBytes = 0x01 ; IstwiRWRequest -> DataLength = cpu_to_le16 ( 0x04 ) ; if ( pdev -> devfn & 1 ) IstwiRWRequest -> DeviceAddr = 0xB2 ; else IstwiRWRequest -> DeviceAddr = 0xB0 ; pbuf = pci_alloc_consistent ( ioc -> pcidev , 4 , & buf_dma ) ; if ( ! pbuf ) goto out ; ioc -> add_sge ( ( char * ) & IstwiRWRequest -> SGL , ( MPT_SGE_FLAGS_SSIMPLE_READ | 4 ) , buf_dma ) ; retval = 0 ; SET_MGMT_MSG_CONTEXT ( ioc -> ioctl_cmds . msg_context , IstwiRWRequest -> MsgContext ) ; INITIALIZE_MGMT_STATUS ( ioc -> ioctl_cmds . status ) mpt_put_msg_frame ( mptctl_id , ioc , mf ) ; retry_wait : timeleft = wait_for_completion_timeout ( & ioc -> ioctl_cmds . done , HZ * MPT_IOCTL_DEFAULT_TIMEOUT ) ; if ( ! ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_COMMAND_GOOD ) ) { retval = - ETIME ; printk ( MYIOC_s_WARN_FMT ""%s:<S2SV_blank>failed\\n"" , ioc -> name , __func__ ) ; if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_DID_IOCRESET ) { mpt_free_msg_frame ( ioc , mf ) ; goto out ; } if ( ! timeleft ) { printk ( MYIOC_s_WARN_FMT ""HOST<S2SV_blank>INFO<S2SV_blank>command<S2SV_blank>timeout,<S2SV_blank>doorbell=0x%08x\\n"" , ioc -> name , mpt_GetIocState ( ioc , 0 ) ) ; mptctl_timeout_expired ( ioc , mf ) ; } else goto retry_wait ; goto out ; } if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_RF_VALID ) karg . rsvd = * ( u32 * ) pbuf ; out : CLEAR_MGMT_STATUS ( ioc -> ioctl_cmds . status ) SET_MGMT_MSG_CONTEXT ( ioc -> ioctl_cmds . msg_context , 0 ) ; if ( pbuf ) pci_free_consistent ( ioc -> pcidev , 4 , pbuf , buf_dma ) ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( hp_host_info_t ) ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_hpgethostinfo<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>hp_host_info<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } return 0 ; }
","<S2SV_ModStart> int mptctl_hp_hostinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> ) arg ; <S2SV_ModEnd> struct pci_dev * <S2SV_ModStart> ; ConfigPageHeader_t hdr <S2SV_ModEnd> ; int rc <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> dctlprintk ( ioc
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,"<S2SV_StartBug> mptctl_hp_hostinfo ( unsigned long arg , unsigned int data_size ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> ConfigPageHeader_t hdr ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug>"
2937,CWE-252,"IHEVCD_ERROR_T ihevcd_parse_slice_header ( codec_t * ps_codec , nal_header_t * ps_nal ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 i ; WORD32 sps_id ; pps_t * ps_pps ; sps_t * ps_sps ; slice_header_t * ps_slice_hdr ; WORD32 disable_deblocking_filter_flag ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; WORD32 idr_pic_flag ; WORD32 pps_id ; WORD32 first_slice_in_pic_flag ; WORD32 no_output_of_prior_pics_flag = 0 ; WORD8 i1_nal_unit_type = ps_nal -> i1_nal_unit_type ; WORD32 num_poc_total_curr = 0 ; WORD32 slice_address ; if ( ps_codec -> i4_slice_error == 1 ) return ret ; idr_pic_flag = ( NAL_IDR_W_LP == i1_nal_unit_type ) || ( NAL_IDR_N_LP == i1_nal_unit_type ) ; BITS_PARSE ( ""first_slice_in_pic_flag"" , first_slice_in_pic_flag , ps_bitstrm , 1 ) ; if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) { BITS_PARSE ( ""no_output_of_prior_pics_flag"" , no_output_of_prior_pics_flag , ps_bitstrm , 1 ) ; } UEV_PARSE ( ""pic_parameter_set_id"" , pps_id , ps_bitstrm ) ; pps_id = CLIP3 ( pps_id , 0 , MAX_PPS_CNT - 2 ) ; ps_pps = ps_codec -> s_parse . ps_pps_base + pps_id ; if ( 0 == ps_pps -> i1_pps_valid ) { pps_t * ps_pps_ref = ps_codec -> ps_pps_base ; while ( 0 == ps_pps_ref -> i1_pps_valid ) ps_pps_ref ++ ; if ( ( ps_pps_ref - ps_codec -> ps_pps_base >= MAX_PPS_CNT - 1 ) ) return IHEVCD_INVALID_HEADER ; ihevcd_copy_pps ( ps_codec , pps_id , ps_pps_ref -> i1_pps_id ) ; } sps_id = ps_pps -> i1_sps_id ; ps_sps = ps_codec -> s_parse . ps_sps_base + sps_id ; if ( ( 0 != ps_codec -> u4_pic_cnt || ps_codec -> i4_pic_present ) && first_slice_in_pic_flag ) { if ( ps_codec -> i4_pic_present ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; return ret ; } else { ps_codec -> i4_slice_error = 0 ; } } if ( first_slice_in_pic_flag ) { ps_codec -> s_parse . i4_cur_slice_idx = 0 ; } else { if ( 0 == ps_codec -> i4_pic_present ) ps_codec -> s_parse . i4_cur_slice_idx = 1 ; } ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr_base + ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; if ( ( ps_pps -> i1_dependent_slice_enabled_flag ) && ( ! first_slice_in_pic_flag ) ) { BITS_PARSE ( ""dependent_slice_flag"" , value , ps_bitstrm , 1 ) ; if ( value && ( ps_codec -> s_parse . i4_cur_slice_idx > 0 ) ) { ihevcd_copy_slice_hdr ( ps_codec , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) , ( ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; } ps_slice_hdr -> i1_dependent_slice_flag = value ; } else { ps_slice_hdr -> i1_dependent_slice_flag = 0 ; } ps_slice_hdr -> i1_nal_unit_type = i1_nal_unit_type ; ps_slice_hdr -> i1_pps_id = pps_id ; ps_slice_hdr -> i1_first_slice_in_pic_flag = first_slice_in_pic_flag ; ps_slice_hdr -> i1_no_output_of_prior_pics_flag = 1 ; if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) { ps_slice_hdr -> i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag ; } ps_slice_hdr -> i1_pps_id = pps_id ; if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) { WORD32 num_bits ; num_bits = 32 - CLZ ( ps_sps -> i4_pic_size_in_ctb - 1 ) ; BITS_PARSE ( ""slice_address"" , value , ps_bitstrm , num_bits ) ; slice_address = value ; if ( value >= ps_sps -> i4_pic_size_in_ctb ) return IHEVCD_IGNORE_SLICE ; } else { slice_address = 0 ; } if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_slice_hdr -> i1_pic_output_flag = 1 ; ps_slice_hdr -> i4_pic_order_cnt_lsb = 0 ; ps_slice_hdr -> i1_num_long_term_sps = 0 ; ps_slice_hdr -> i1_num_long_term_pics = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_extra_slice_header_bits ; i ++ ) { BITS_PARSE ( ""slice_reserved_undetermined_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; } UEV_PARSE ( ""slice_type"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_type = value ; if ( ( ps_slice_hdr -> i1_nal_unit_type >= NAL_BLA_W_LP ) && ( ps_slice_hdr -> i1_nal_unit_type <= NAL_RSV_RAP_VCL23 ) ) ps_slice_hdr -> i1_slice_type = ISLICE ; if ( ( ps_slice_hdr -> i1_slice_type < 0 ) || ( ps_slice_hdr -> i1_slice_type > 2 ) ) return IHEVCD_IGNORE_SLICE ; if ( ps_pps -> i1_output_flag_present_flag ) { BITS_PARSE ( ""pic_output_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_pic_output_flag = value ; } ps_slice_hdr -> i1_colour_plane_id = 0 ; if ( 1 == ps_sps -> i1_separate_colour_plane_flag ) { BITS_PARSE ( ""colour_plane_id"" , value , ps_bitstrm , 2 ) ; ps_slice_hdr -> i1_colour_plane_id = value ; } ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = 0 ; if ( ! idr_pic_flag ) { WORD32 st_rps_idx ; WORD32 num_neg_pics ; WORD32 num_pos_pics ; WORD8 * pi1_used ; BITS_PARSE ( ""pic_order_cnt_lsb"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_slice_hdr -> i4_pic_order_cnt_lsb = value ; BITS_PARSE ( ""short_term_ref_pic_set_sps_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag = value ; if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) { WORD32 numbits ; ps_slice_hdr -> i1_short_term_ref_pic_set_idx = 0 ; if ( ps_sps -> i1_num_short_term_ref_pic_sets > 1 ) { numbits = 32 - CLZ ( ps_sps -> i1_num_short_term_ref_pic_sets - 1 ) ; BITS_PARSE ( ""short_term_ref_pic_set_idx"" , value , ps_bitstrm , numbits ) ; ps_slice_hdr -> i1_short_term_ref_pic_set_idx = value ; } st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ; num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ; num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ; pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ; } else { ihevcd_short_term_ref_pic_set ( ps_bitstrm , & ps_sps -> as_stref_picset [ 0 ] , ps_sps -> i1_num_short_term_ref_pic_sets , ps_sps -> i1_num_short_term_ref_pic_sets , & ps_slice_hdr -> s_stref_picset ) ; st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ; num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ; num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ; pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ; } if ( ps_sps -> i1_long_term_ref_pics_present_flag ) { if ( ps_sps -> i1_num_long_term_ref_pics_sps > 0 ) { UEV_PARSE ( ""num_long_term_sps"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_long_term_sps = value ; ps_slice_hdr -> i1_num_long_term_sps = CLIP3 ( ps_slice_hdr -> i1_num_long_term_sps , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics ) ; } UEV_PARSE ( ""num_long_term_pics"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_long_term_pics = value ; ps_slice_hdr -> i1_num_long_term_pics = CLIP3 ( ps_slice_hdr -> i1_num_long_term_pics , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics - ps_slice_hdr -> i1_num_long_term_sps ) ; for ( i = 0 ; i < ( ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ) ; i ++ ) { if ( i < ps_slice_hdr -> i1_num_long_term_sps ) { WORD32 num_bits = 32 - CLZ ( ps_sps -> i1_num_long_term_ref_pics_sps ) ; BITS_PARSE ( ""lt_idx_sps[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , num_bits ) ; ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = ps_sps -> ai1_lt_ref_pic_poc_lsb_sps [ value ] ; ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = ps_sps -> ai1_used_by_curr_pic_lt_sps_flag [ value ] ; } else { BITS_PARSE ( ""poc_lsb_lt[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = value ; BITS_PARSE ( ""used_by_curr_pic_lt_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = value ; } BITS_PARSE ( ""delta_poc_msb_present_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] = value ; ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = 0 ; if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) { UEV_PARSE ( ""delata_poc_msb_cycle_lt[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = value ; } if ( ( i != 0 ) && ( i != ps_slice_hdr -> i1_num_long_term_sps ) ) { ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] += ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i - 1 ] ; } } } for ( i = 0 ; i < num_neg_pics + num_pos_pics ; i ++ ) { if ( pi1_used [ i ] ) { num_poc_total_curr ++ ; } } for ( i = 0 ; i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ; i ++ ) { if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) { num_poc_total_curr ++ ; } } if ( ps_sps -> i1_sps_temporal_mvp_enable_flag ) { BITS_PARSE ( ""enable_temporal_mvp_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = value ; } } ps_slice_hdr -> i1_slice_sao_luma_flag = 0 ; ps_slice_hdr -> i1_slice_sao_chroma_flag = 0 ; if ( ps_sps -> i1_sample_adaptive_offset_enabled_flag ) { BITS_PARSE ( ""slice_sao_luma_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_sao_luma_flag = value ; BITS_PARSE ( ""slice_sao_chroma_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_sao_chroma_flag = value ; } ps_slice_hdr -> i1_max_num_merge_cand = 1 ; ps_slice_hdr -> i1_cabac_init_flag = 0 ; ps_slice_hdr -> i1_num_ref_idx_l0_active = 0 ; ps_slice_hdr -> i1_num_ref_idx_l1_active = 0 ; ps_slice_hdr -> i1_slice_cb_qp_offset = 0 ; ps_slice_hdr -> i1_slice_cr_qp_offset = 0 ; if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) { BITS_PARSE ( ""num_ref_idx_active_override_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_num_ref_idx_active_override_flag = value ; if ( ps_slice_hdr -> i1_num_ref_idx_active_override_flag ) { UEV_PARSE ( ""num_ref_idx_l0_active_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_ref_idx_l0_active = value + 1 ; if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { UEV_PARSE ( ""num_ref_idx_l1_active_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_ref_idx_l1_active = value + 1 ; } } else { ps_slice_hdr -> i1_num_ref_idx_l0_active = ps_pps -> i1_num_ref_idx_l0_default_active ; if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { ps_slice_hdr -> i1_num_ref_idx_l1_active = ps_pps -> i1_num_ref_idx_l1_default_active ; } } ps_slice_hdr -> i1_num_ref_idx_l0_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l0_active , 0 , MAX_DPB_SIZE - 1 ) ; ps_slice_hdr -> i1_num_ref_idx_l1_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l1_active , 0 , MAX_DPB_SIZE - 1 ) ; if ( 0 == num_poc_total_curr ) return IHEVCD_IGNORE_SLICE ; if ( ( ps_pps -> i1_lists_modification_present_flag ) && ( num_poc_total_curr > 1 ) ) { ihevcd_ref_pic_list_modification ( ps_bitstrm , ps_slice_hdr , num_poc_total_curr ) ; } else { ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 = 0 ; ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 = 0 ; } if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { BITS_PARSE ( ""mvd_l1_zero_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_mvd_l1_zero_flag = value ; } ps_slice_hdr -> i1_cabac_init_flag = 0 ; if ( ps_pps -> i1_cabac_init_present_flag ) { BITS_PARSE ( ""cabac_init_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_cabac_init_flag = value ; } ps_slice_hdr -> i1_collocated_from_l0_flag = 1 ; ps_slice_hdr -> i1_collocated_ref_idx = 0 ; if ( ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag ) { if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { BITS_PARSE ( ""collocated_from_l0_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_collocated_from_l0_flag = value ; } if ( ( ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l0_active > 1 ) ) || ( ! ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l1_active > 1 ) ) ) { UEV_PARSE ( ""collocated_ref_idx"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_collocated_ref_idx = value ; } } ps_slice_hdr -> i1_collocated_ref_idx = CLIP3 ( ps_slice_hdr -> i1_collocated_ref_idx , 0 , MAX_DPB_SIZE - 1 ) ; if ( ( ps_pps -> i1_weighted_pred_flag && ( PSLICE == ps_slice_hdr -> i1_slice_type ) ) || ( ps_pps -> i1_weighted_bipred_flag && ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) ) { ihevcd_parse_pred_wt_ofst ( ps_bitstrm , ps_sps , ps_pps , ps_slice_hdr ) ; } UEV_PARSE ( ""five_minus_max_num_merge_cand"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_max_num_merge_cand = 5 - value ; } ps_slice_hdr -> i1_max_num_merge_cand = CLIP3 ( ps_slice_hdr -> i1_max_num_merge_cand , 1 , 5 ) ; SEV_PARSE ( ""slice_qp_delta"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_qp_delta = value ; if ( ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag ) { SEV_PARSE ( ""slice_cb_qp_offset"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_cb_qp_offset = value ; SEV_PARSE ( ""slice_cr_qp_offset"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_cr_qp_offset = value ; } ps_slice_hdr -> i1_deblocking_filter_override_flag = 0 ; ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; ps_slice_hdr -> i1_beta_offset_div2 = ps_pps -> i1_beta_offset_div2 ; ps_slice_hdr -> i1_tc_offset_div2 = ps_pps -> i1_tc_offset_div2 ; disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { if ( ps_pps -> i1_deblocking_filter_override_enabled_flag ) { BITS_PARSE ( ""deblocking_filter_override_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_deblocking_filter_override_flag = value ; } if ( ps_slice_hdr -> i1_deblocking_filter_override_flag ) { BITS_PARSE ( ""slice_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = value ; disable_deblocking_filter_flag = ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ; if ( ! ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) { SEV_PARSE ( ""beta_offset_div2"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_beta_offset_div2 = value ; SEV_PARSE ( ""tc_offset_div2"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_tc_offset_div2 = value ; } } } ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = ps_pps -> i1_loop_filter_across_slices_enabled_flag ; if ( ps_pps -> i1_loop_filter_across_slices_enabled_flag && ( ps_slice_hdr -> i1_slice_sao_luma_flag || ps_slice_hdr -> i1_slice_sao_chroma_flag || ! disable_deblocking_filter_flag ) ) { BITS_PARSE ( ""slice_loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = value ; } } if ( ( ! first_slice_in_pic_flag ) && ( ps_codec -> i4_pic_present ) ) { slice_header_t * ps_slice_hdr_base = ps_codec -> ps_slice_hdr_base ; if ( ( ps_slice_hdr_base -> i1_pps_id != ps_slice_hdr -> i1_pps_id ) || ( ps_slice_hdr_base -> i4_pic_order_cnt_lsb != ps_slice_hdr -> i4_pic_order_cnt_lsb ) ) { return IHEVCD_IGNORE_SLICE ; } } if ( 0 == ps_codec -> i4_pic_present ) { ps_slice_hdr -> i4_abs_pic_order_cnt = ihevcd_calc_poc ( ps_codec , ps_nal , ps_sps -> i1_log2_max_pic_order_cnt_lsb , ps_slice_hdr -> i4_pic_order_cnt_lsb ) ; } else { ps_slice_hdr -> i4_abs_pic_order_cnt = ps_codec -> s_parse . i4_abs_pic_order_cnt ; } if ( ! first_slice_in_pic_flag ) { if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) { if ( slice_address > ps_codec -> s_parse . i4_next_ctb_indx ) { if ( ps_codec -> i4_pic_present ) { ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; return ret ; } else { return IHEVCD_IGNORE_SLICE ; } } else if ( slice_address < ps_codec -> s_parse . i4_next_ctb_indx ) { return IHEVCD_IGNORE_SLICE ; } else { ps_codec -> i4_slice_error = 0 ; } } else { if ( ps_codec -> i4_pic_present ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; return ret ; } else { if ( ps_slice_hdr -> i1_dependent_slice_flag ) return IHEVCD_IGNORE_SLICE ; ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; } } } else { if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) return IHEVCD_IGNORE_SLICE ; ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; } ps_slice_hdr -> i4_num_entry_point_offsets = 0 ; if ( ( ps_pps -> i1_tiles_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) { UEV_PARSE ( ""num_entry_point_offsets"" , value , ps_bitstrm ) ; ps_slice_hdr -> i4_num_entry_point_offsets = value ; { WORD32 max_num_entry_point_offsets ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) { max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; } else if ( ps_pps -> i1_tiles_enabled_flag ) { max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ps_pps -> i1_num_tile_rows ; } else { max_num_entry_point_offsets = ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; } ps_slice_hdr -> i4_num_entry_point_offsets = CLIP3 ( ps_slice_hdr -> i4_num_entry_point_offsets , 0 , max_num_entry_point_offsets ) ; } if ( ps_slice_hdr -> i4_num_entry_point_offsets > 0 ) { UEV_PARSE ( ""offset_len_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_offset_len = value + 1 ; for ( i = 0 ; i < ps_slice_hdr -> i4_num_entry_point_offsets ; i ++ ) { BITS_PARSE ( ""entry_point_offset"" , value , ps_bitstrm , ps_slice_hdr -> i1_offset_len ) ; } } } if ( ps_pps -> i1_slice_header_extension_present_flag ) { UEV_PARSE ( ""slice_header_extension_length"" , value , ps_bitstrm ) ; ps_slice_hdr -> i2_slice_header_extension_length = value ; for ( i = 0 ; i < ps_slice_hdr -> i2_slice_header_extension_length ; i ++ ) { BITS_PARSE ( ""slice_header_extension_data_byte"" , value , ps_bitstrm , 8 ) ; } } ihevcd_bits_flush_to_byte_boundary ( ps_bitstrm ) ; { dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; WORD32 r_idx ; if ( ( NAL_IDR_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_IDR_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_DLP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( 0 == ps_codec -> u4_pic_cnt ) ) { for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) { pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ; mv_buf_t * ps_mv_buf ; ihevc_dpb_mgr_del_ref ( ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ; for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ ) { if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) { ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ; break ; } ps_mv_buf ++ ; } } } for ( r_idx = 0 ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = NULL ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = NULL ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = NULL ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = NULL ; } } else { ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ; } } if ( ps_codec -> i4_pic_present ) { pic_buf_t * ps_pic_buf_ref ; mv_buf_t * ps_mv_buf_ref ; WORD32 r_idx ; dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ps_slice_hdr -> i4_abs_pic_order_cnt ) ; if ( NULL == ps_pic_buf_ref ) { ps_pic_buf_ref = ps_codec -> as_process [ 0 ] . ps_cur_pic ; ps_mv_buf_ref = ps_codec -> s_parse . ps_cur_mv_buf ; } else { ps_mv_buf_ref = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf_ref -> i4_abs_poc ) ; } for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx ++ ) { if ( NULL == ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx ++ ) { if ( NULL == ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ) { ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) { ps_slice_hdr -> i2_ctb_x = slice_address % ps_sps -> i2_pic_wd_in_ctb ; ps_slice_hdr -> i2_ctb_y = slice_address / ps_sps -> i2_pic_wd_in_ctb ; if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_slice_hdr -> i2_independent_ctb_x = ps_slice_hdr -> i2_ctb_x ; ps_slice_hdr -> i2_independent_ctb_y = ps_slice_hdr -> i2_ctb_y ; } } else { ps_slice_hdr -> i2_ctb_x = 0 ; ps_slice_hdr -> i2_ctb_y = 0 ; ps_slice_hdr -> i2_independent_ctb_x = 0 ; ps_slice_hdr -> i2_independent_ctb_y = 0 ; } if ( ( ! first_slice_in_pic_flag ) && ( 0 == ps_codec -> i4_pic_present ) ) { slice_header_t * ps_slice_hdr_prev = ps_codec -> s_parse . ps_slice_hdr_base ; ihevcd_copy_slice_hdr ( ps_codec , 0 , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; ps_codec -> i4_slice_error = 1 ; ps_slice_hdr_prev -> i2_ctb_x = 0 ; ps_slice_hdr_prev -> i2_ctb_y = 0 ; ps_codec -> s_parse . i4_ctb_x = 0 ; ps_codec -> s_parse . i4_ctb_y = 0 ; ps_codec -> s_parse . i4_cur_slice_idx = 0 ; if ( ( ps_slice_hdr -> i2_ctb_x == 0 ) && ( ps_slice_hdr -> i2_ctb_y == 0 ) ) { ps_slice_hdr -> i2_ctb_x ++ ; } } { if ( ( i1_nal_unit_type < NAL_BLA_W_LP ) && ( i1_nal_unit_type % 2 == 0 ) ) { if ( IVD_SKIP_B == ps_codec -> e_pic_skip_mode ) return IHEVCD_IGNORE_SLICE ; } if ( ( IVD_SKIP_PB == ps_codec -> e_pic_skip_mode ) && ( ISLICE != ps_slice_hdr -> i1_slice_type ) ) { return IHEVCD_IGNORE_SLICE ; } } return ret ; }
","<S2SV_ModStart> } else { ret = <S2SV_ModStart> ps_slice_hdr ) ; if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) { return ret ; }
",external@libhevc/a1424724a00d62ac5efa0e27953eed66850d662f,CVE-2017-0599,https://android.googlesource.com/platform/external/libhevc/+/a1424724a00d62ac5efa0e27953eed66850d662f,2017-05-12T15:29Z,"<S2SV_StartBug> ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ; <S2SV_EndBug>"
2674,CWE-20,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;
",ImageMagick@ImageMagick/8a370f9ab120faf182aa160900ba692ba8e2bcf0,CVE-2016-10069,https://github.com/ImageMagick/ImageMagick/commit/8a370f9ab120faf182aa160900ba692ba8e2bcf0,2017-03-02T21:59Z,<S2SV_StartBug> break ; <S2SV_EndBug>
1925,CWE-119,"static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 , __m128i * in1 , int stride ) { write_buffer_8x8 ( output , in0 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in0 + 8 , stride ) ; output += 8 ; write_buffer_8x8 ( output , in1 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in1 + 8 , stride ) ; }
","<S2SV_ModStart> void write_buffer_16x16 ( tran_low_t <S2SV_ModEnd> * output ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 , <S2SV_EndBug>"
243,CWE-189,"static Image * ReadICONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { IconFile icon_file ; IconInfo icon_info ; Image * image ; MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bit , byte , bytes_per_line , one , scanline_pad ; ssize_t count , offset , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } icon_file . reserved = ( short ) ReadBlobLSBShort ( image ) ; icon_file . resource_type = ( short ) ReadBlobLSBShort ( image ) ; icon_file . count = ( short ) ReadBlobLSBShort ( image ) ; if ( ( icon_file . reserved != 0 ) || ( ( icon_file . resource_type != 1 ) && ( icon_file . resource_type != 2 ) ) || ( icon_file . count > MaxIcons ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; for ( i = 0 ; i < icon_file . count ; i ++ ) { icon_file . directory [ i ] . width = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . height = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . colors = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . reserved = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . planes = ( unsigned short ) ReadBlobLSBShort ( image ) ; icon_file . directory [ i ] . bits_per_pixel = ( unsigned short ) ReadBlobLSBShort ( image ) ; icon_file . directory [ i ] . size = ReadBlobLSBLong ( image ) ; icon_file . directory [ i ] . offset = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } one = 1 ; for ( i = 0 ; i < icon_file . count ; i ++ ) { offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) icon_file . directory [ i ] . offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; icon_info . size = ReadBlobLSBLong ( image ) ; icon_info . width = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) ) ; icon_info . height = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) / 2 ) ; icon_info . planes = ReadBlobLSBShort ( image ) ; icon_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( ( icon_info . planes == 18505 ) && ( icon_info . bits_per_pixel == 21060 ) ) || ( icon_info . size == 0x474e5089 ) ) { Image * icon_image ; ImageInfo * read_info ; size_t length ; unsigned char * png ; length = icon_file . directory [ i ] . size ; png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ; if ( png == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) CopyMagickMemory ( png , ""\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015"" , 12 ) ; png [ 12 ] = ( unsigned char ) icon_info . planes ; png [ 13 ] = ( unsigned char ) ( icon_info . planes >> 8 ) ; png [ 14 ] = ( unsigned char ) icon_info . bits_per_pixel ; png [ 15 ] = ( unsigned char ) ( icon_info . bits_per_pixel >> 8 ) ; count = ReadBlob ( image , length - 16 , png + 16 ) ; icon_image = ( Image * ) NULL ; if ( count > 0 ) { read_info = CloneImageInfo ( image_info ) ; ( void ) CopyMagickString ( read_info -> magick , ""PNG"" , MagickPathExtent ) ; icon_image = BlobToImage ( read_info , png , length + 16 , exception ) ; read_info = DestroyImageInfo ( read_info ) ; } png = ( unsigned char * ) RelinquishMagickMemory ( png ) ; if ( icon_image == ( Image * ) NULL ) { if ( count != ( ssize_t ) ( length - 16 ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } DestroyBlob ( icon_image ) ; icon_image -> blob = ReferenceBlob ( image -> blob ) ; ReplaceImageInList ( & image , icon_image ) ; } else { if ( icon_info . bits_per_pixel > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; icon_info . compression = ReadBlobLSBLong ( image ) ; icon_info . image_size = ReadBlobLSBLong ( image ) ; icon_info . x_pixels = ReadBlobLSBLong ( image ) ; icon_info . y_pixels = ReadBlobLSBLong ( image ) ; icon_info . number_colors = ReadBlobLSBLong ( image ) ; icon_info . colors_important = ReadBlobLSBLong ( image ) ; image -> alpha_trait = BlendPixelTrait ; image -> columns = ( size_t ) icon_file . directory [ i ] . width ; if ( ( ssize_t ) image -> columns > icon_info . width ) image -> columns = ( size_t ) icon_info . width ; if ( image -> columns == 0 ) image -> columns = 256 ; image -> rows = ( size_t ) icon_file . directory [ i ] . height ; if ( ( ssize_t ) image -> rows > icon_info . height ) image -> rows = ( size_t ) icon_info . height ; if ( image -> rows == 0 ) image -> rows = 256 ; image -> depth = icon_info . bits_per_pixel ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank>scene<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) i ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>size<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . size ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>width<S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_file . directory [ i ] . width ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>height<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_file . directory [ i ] . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>colors<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . number_colors ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>planes<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . planes ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>bpp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . bits_per_pixel ) ; } if ( ( icon_info . number_colors != 0 ) || ( icon_info . bits_per_pixel <= 16U ) ) { image -> storage_class = PseudoClass ; image -> colors = icon_info . number_colors ; if ( image -> colors == 0 ) image -> colors = one << icon_info . bits_per_pixel ; } if ( image -> storage_class == PseudoClass ) { register ssize_t i ; unsigned char * icon_colormap ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; icon_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4UL * sizeof ( * icon_colormap ) ) ; if ( icon_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) ( 4 * image -> colors ) , icon_colormap ) ; if ( count != ( ssize_t ) ( 4 * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = icon_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; p ++ ; } icon_colormap = ( unsigned char * ) RelinquishMagickMemory ( icon_colormap ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_line = ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & ~ 31 ) >> 3 ; ( void ) bytes_per_line ; scanline_pad = ( ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & ~ 31 ) - ( image -> columns * icon_info . bits_per_pixel ) ) >> 3 ; switch ( icon_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 8 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) , q ) ; q += GetPixelChannels ( image ) ; } } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelIndex ( image , ( ( byte ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 8 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , byte , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 16 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte = ( size_t ) ReadBlobByte ( image ) ; byte |= ( size_t ) ( ReadBlobByte ( image ) << 8 ) ; SetPixelIndex ( image , byte , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : case 32 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; if ( icon_info . bits_per_pixel == 32 ) SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( icon_info . bits_per_pixel == 24 ) for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( image_info -> ping == MagickFalse ) ( void ) SyncImage ( image , exception ) ; if ( icon_info . bits_per_pixel != 32 ) { image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? TransparentAlpha : OpaqueAlpha ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 8 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? TransparentAlpha : OpaqueAlpha ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 32 ) != 0 ) for ( x = 0 ; x < ( ssize_t ) ( ( 32 - ( image -> columns % 32 ) ) / 8 ) ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( i < ( ssize_t ) ( icon_file . count - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ] . size ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" )
",ImageMagick@ImageMagick/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,CVE-2015-8896,https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,2017-03-15T19:59Z,<S2SV_StartBug> length = icon_file . directory [ i ] . size ; <S2SV_EndBug>
5065,CWE-79,"static void do_viewlog ( HttpRequest req , HttpResponse res ) { if ( is_readonly ( req ) ) { send_error ( req , res , SC_FORBIDDEN , ""You<S2SV_blank>do<S2SV_blank>not<S2SV_blank>have<S2SV_blank>sufficient<S2SV_blank>privileges<S2SV_blank>to<S2SV_blank>access<S2SV_blank>this<S2SV_blank>page"" ) ; return ; } do_head ( res , ""_viewlog"" , ""View<S2SV_blank>log"" , 100 ) ; if ( ( Run . flags & Run_Log ) && ! ( Run . flags & Run_UseSyslog ) ) { FILE * f = fopen ( Run . files . log , ""r"" ) ; if ( f ) { size_t n ; char buf [ 512 ] ; StringBuffer_append ( res -> outputbuffer , ""<br><p><form><textarea<S2SV_blank>cols=120<S2SV_blank>rows=30<S2SV_blank>readonly>"" ) ; while ( ( n = fread ( buf , sizeof ( char ) , sizeof ( buf ) - 1 , f ) ) > 0 ) { buf [ n ] = 0 ; StringBuffer_append ( res -> outputbuffer , ""%s"" , buf ) ; } fclose ( f ) ; StringBuffer_append ( res -> outputbuffer , ""</textarea></form>"" ) ; } else { StringBuffer_append ( res -> outputbuffer , ""Error<S2SV_blank>opening<S2SV_blank>logfile:<S2SV_blank>%s"" , STRERROR ) ; } } else { StringBuffer_append ( res -> outputbuffer , ""<b>Cannot<S2SV_blank>view<S2SV_blank>logfile:</b><br>"" ) ; if ( ! ( Run . flags & Run_Log ) ) StringBuffer_append ( res -> outputbuffer , ""Monit<S2SV_blank>was<S2SV_blank>started<S2SV_blank>without<S2SV_blank>logging"" ) ; else StringBuffer_append ( res -> outputbuffer , ""Monit<S2SV_blank>uses<S2SV_blank>syslog"" ) ; } do_foot ( res ) ; }
","<S2SV_ModStart> = 0 ; escapeHTML ( res -> outputbuffer <S2SV_ModEnd> , buf )
",tildeslash@monit/328f60773057641c4b2075fab9820145e95b728c,CVE-2019-11454,https://bitbucket.org/tildeslash/monit/commit/328f60773057641c4b2075fab9820145e95b728c,2019-04-22T16:29Z,"<S2SV_StartBug> StringBuffer_append ( res -> outputbuffer , ""%s"" , buf ) ; <S2SV_EndBug>"
8362,CWE-362,"int ip_options_echo ( struct ip_options * dopt , struct sk_buff * skb ) { struct ip_options * sopt ; unsigned char * sptr , * dptr ; int soffset , doffset ; int optlen ; __be32 daddr ; memset ( dopt , 0 , sizeof ( struct ip_options ) ) ; sopt = & ( IPCB ( skb ) -> opt ) ; if ( sopt -> optlen == 0 ) { dopt -> optlen = 0 ; return 0 ; } sptr = skb_network_header ( skb ) ; dptr = dopt -> __data ; daddr = skb_rtable ( skb ) -> rt_spec_dst ; if ( sopt -> rr ) { optlen = sptr [ sopt -> rr + 1 ] ; soffset = sptr [ sopt -> rr + 2 ] ; dopt -> rr = dopt -> optlen + sizeof ( struct iphdr ) ; memcpy ( dptr , sptr + sopt -> rr , optlen ) ; if ( sopt -> rr_needaddr && soffset <= optlen ) { if ( soffset + 3 > optlen ) return - EINVAL ; dptr [ 2 ] = soffset + 4 ; dopt -> rr_needaddr = 1 ; } dptr += optlen ; dopt -> optlen += optlen ; } if ( sopt -> ts ) { optlen = sptr [ sopt -> ts + 1 ] ; soffset = sptr [ sopt -> ts + 2 ] ; dopt -> ts = dopt -> optlen + sizeof ( struct iphdr ) ; memcpy ( dptr , sptr + sopt -> ts , optlen ) ; if ( soffset <= optlen ) { if ( sopt -> ts_needaddr ) { if ( soffset + 3 > optlen ) return - EINVAL ; dopt -> ts_needaddr = 1 ; soffset += 4 ; } if ( sopt -> ts_needtime ) { if ( soffset + 3 > optlen ) return - EINVAL ; if ( ( dptr [ 3 ] & 0xF ) != IPOPT_TS_PRESPEC ) { dopt -> ts_needtime = 1 ; soffset += 4 ; } else { dopt -> ts_needtime = 0 ; if ( soffset + 7 <= optlen ) { __be32 addr ; memcpy ( & addr , dptr + soffset - 1 , 4 ) ; if ( inet_addr_type ( dev_net ( skb_dst ( skb ) -> dev ) , addr ) != RTN_UNICAST ) { dopt -> ts_needtime = 1 ; soffset += 8 ; } } } } dptr [ 2 ] = soffset ; } dptr += optlen ; dopt -> optlen += optlen ; } if ( sopt -> srr ) { unsigned char * start = sptr + sopt -> srr ; __be32 faddr ; optlen = start [ 1 ] ; soffset = start [ 2 ] ; doffset = 0 ; if ( soffset > optlen ) soffset = optlen + 1 ; soffset -= 4 ; if ( soffset > 3 ) { memcpy ( & faddr , & start [ soffset - 1 ] , 4 ) ; for ( soffset -= 4 , doffset = 4 ; soffset > 3 ; soffset -= 4 , doffset += 4 ) memcpy ( & dptr [ doffset - 1 ] , & start [ soffset - 1 ] , 4 ) ; if ( memcmp ( & ip_hdr ( skb ) -> saddr , & start [ soffset + 3 ] , 4 ) == 0 ) doffset -= 4 ; } if ( doffset > 3 ) { memcpy ( & start [ doffset - 1 ] , & daddr , 4 ) ; dopt -> faddr = faddr ; dptr [ 0 ] = start [ 0 ] ; dptr [ 1 ] = doffset + 3 ; dptr [ 2 ] = 4 ; dptr += doffset + 3 ; dopt -> srr = dopt -> optlen + sizeof ( struct iphdr ) ; dopt -> optlen += doffset + 3 ; dopt -> is_strictroute = sopt -> is_strictroute ; } } if ( sopt -> cipso ) { optlen = sptr [ sopt -> cipso + 1 ] ; dopt -> cipso = dopt -> optlen + sizeof ( struct iphdr ) ; memcpy ( dptr , sptr + sopt -> cipso , optlen ) ; dptr += optlen ; dopt -> optlen += optlen ; } while ( dopt -> optlen & 3 ) { * dptr ++ = IPOPT_END ; dopt -> optlen ++ ; } return 0 ; }
","<S2SV_ModStart> skb ) { const <S2SV_ModStart> == 0 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> sptr = skb_network_header
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> struct ip_options * sopt ; <S2SV_EndBug> <S2SV_StartBug> if ( sopt -> optlen == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
7889,CWE-20,"error_t httpClientAddQueryParam ( HttpClientContext * context , const char_t * name , const char_t * value ) { size_t nameLen ; size_t valueLen ; char_t separator ; char_t * p ; if ( context == NULL || name == NULL ) return ERROR_INVALID_PARAMETER ; if ( name [ 0 ] == '\\0' ) return ERROR_INVALID_PARAMETER ; if ( context -> requestState != HTTP_REQ_STATE_FORMAT_HEADER ) return ERROR_WRONG_STATE ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ; p = strchr ( context -> buffer , '<S2SV_blank>' ) ; if ( p == NULL ) return ERROR_INVALID_SYNTAX ; p = strpbrk ( p + 1 , ""<S2SV_blank>?"" ) ; if ( p == NULL ) return ERROR_INVALID_SYNTAX ; if ( * p == '?' ) { p = strchr ( p + 1 , '<S2SV_blank>' ) ; if ( p == NULL ) return ERROR_INVALID_SYNTAX ; separator = '&' ; } else { separator = '?' ; } nameLen = osStrlen ( name ) ; if ( value == NULL ) { if ( ( context -> bufferLen + nameLen + 1 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + nameLen + 1 , p , context -> buffer + context -> bufferLen + 1 - p ) ; p [ 0 ] = separator ; osStrncpy ( p + 1 , name , nameLen ) ; context -> bufferLen += nameLen + 1 ; } else { valueLen = osStrlen ( value ) ; if ( ( context -> bufferLen + nameLen + valueLen + 2 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + nameLen + valueLen + 2 , p , context -> buffer + context -> bufferLen + 1 - p ) ; p [ 0 ] = separator ; osStrncpy ( p + 1 , name , nameLen ) ; p [ nameLen + 1 ] = '=' ; osStrncpy ( p + nameLen + 2 , value , valueLen ) ; context -> bufferLen += nameLen + valueLen + 2 ; } return NO_ERROR ; }
","<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> { p = osStrchr <S2SV_ModEnd> ( p +
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> <S2SV_StartBug> p = strchr ( p + 1 , '<S2SV_blank>' ) ; <S2SV_EndBug>"
5983,CWE-119,"static int header_gets ( SF_PRIVATE * psf , char * ptr , int bufsize ) { int k ; for ( k = 0 ; k < bufsize - 1 ; k ++ ) { if ( psf -> headindex < psf -> headend ) { ptr [ k ] = psf -> header [ psf -> headindex ] ; psf -> headindex ++ ; } else { psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , 1 , psf ) ; ptr [ k ] = psf -> header [ psf -> headindex ] ; psf -> headindex = psf -> headend ; } ; if ( ptr [ k ] == '\\n' ) break ; } ; ptr [ k ] = 0 ; return k ; }
","<S2SV_ModStart> int k ; if ( psf -> header . indx + bufsize >= psf -> header . len && psf_bump_header_allocation ( psf , bufsize ) ) return 0 ; <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> < psf -> <S2SV_ModStart> < psf -> header . end ) { ptr [ k ] = psf -> header . ptr [ psf -> header . indx ] ; psf -> header . indx <S2SV_ModEnd> ++ ; } <S2SV_ModStart> { psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> psf -> header . ptr [ psf -> header . indx ] ; psf -> header . indx = psf -> header . end <S2SV_ModEnd> ; } ;
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,"<S2SV_StartBug> for ( k = 0 ; k < bufsize - 1 ; k ++ ) <S2SV_EndBug> <S2SV_StartBug> { if ( psf -> headindex < psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> { psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , 1 , psf ) ; <S2SV_EndBug> <S2SV_StartBug> ptr [ k ] = psf -> header [ psf -> headindex ] ; <S2SV_EndBug>"
1402,CWE-119,"int vp8dx_receive_compressed_data ( VP8D_COMP * pbi , size_t size , const uint8_t * source , int64_t time_stamp ) { # if HAVE_NEON int64_t dx_store_reg [ 8 ] ; # endif VP8_COMMON * cm = & pbi -> common ; int retcode = - 1 ; pbi -> common . error . error_code = VPX_CODEC_OK ; retcode = check_fragments_for_errors ( pbi ) ; if ( retcode <= 0 ) return retcode ; # if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( dx_store_reg ) ; } # endif cm -> new_fb_idx = get_free_fb ( cm ) ; pbi -> dec_fb_ref [ INTRA_FRAME ] = & cm -> yv12_fb [ cm -> new_fb_idx ] ; pbi -> dec_fb_ref [ LAST_FRAME ] = & cm -> yv12_fb [ cm -> lst_fb_idx ] ; pbi -> dec_fb_ref [ GOLDEN_FRAME ] = & cm -> yv12_fb [ cm -> gld_fb_idx ] ; pbi -> dec_fb_ref [ ALTREF_FRAME ] = & cm -> yv12_fb [ cm -> alt_fb_idx ] ; if ( setjmp ( pbi -> common . error . jmp ) ) { cm -> yv12_fb [ cm -> lst_fb_idx ] . corrupted = 1 ; if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; goto decode_exit ; } pbi -> common . error . setjmp = 1 ; retcode = vp8_decode_frame ( pbi ) ; if ( retcode < 0 ) { if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; pbi -> common . error . error_code = VPX_CODEC_ERROR ; goto decode_exit ; } if ( swap_frame_buffers ( cm ) ) { pbi -> common . error . error_code = VPX_CODEC_ERROR ; goto decode_exit ; } vp8_clear_system_state ( ) ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; cm -> show_frame_mi = cm -> mi ; } # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_enabled && pbi -> common . prev_mi ) { MODE_INFO * tmp = pbi -> common . prev_mi ; int row , col ; pbi -> common . prev_mi = pbi -> common . mi ; pbi -> common . mi = tmp ; for ( row = 0 ; row < pbi -> common . mb_rows ; ++ row ) { for ( col = 0 ; col < pbi -> common . mb_cols ; ++ col ) { const int i = row * pbi -> common . mode_info_stride + col ; pbi -> common . mi [ i ] . mbmi . segment_id = pbi -> common . prev_mi [ i ] . mbmi . segment_id ; } } } # endif pbi -> ready_for_new_data = 0 ; pbi -> last_time_stamp = time_stamp ; decode_exit : # if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( dx_store_reg ) ; } # endif pbi -> common . error . setjmp = 0 ; return retcode ; }
","<S2SV_ModStart> time_stamp ) { <S2SV_ModEnd> VP8_COMMON * cm <S2SV_ModStart> - 1 ; ( void ) size ; ( void ) source ; <S2SV_ModStart> return retcode ; <S2SV_ModEnd> cm -> new_fb_idx <S2SV_ModStart> ; decode_exit : <S2SV_ModEnd> pbi -> common <S2SV_ModStart> = 0 ; vp8_clear_system_state ( ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> pbi -> common . error . error_code = VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> return retcode ; <S2SV_EndBug>
3250,CWE-617,"static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || s -> cur_pic . field_picture || s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ; return 1 ; }
","<S2SV_ModStart> cur_pic . field_picture <S2SV_ModEnd> ) return 0
",FFmpeg@FFmpeg/bd27a9364ca274ca97f1df6d984e88a0700fb235,CVE-2018-13304,https://github.com/FFmpeg/FFmpeg/commit/bd27a9364ca274ca97f1df6d984e88a0700fb235,2018-07-05T17:29Z,<S2SV_StartBug> s -> cur_pic . field_picture || <S2SV_EndBug>
2363,CWE-119,"static uint32_t scsi_init_iovec ( SCSIDiskReq * r ) { r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ; qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; return r -> qiov . size / 512 ; }
","<S2SV_ModStart> r ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; if ( ! r -> iov . iov_base ) { r -> buflen = SCSI_DMA_BUF_SIZE ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } <S2SV_ModStart> * 512 , r -> buflen <S2SV_ModEnd> ) ; qemu_iovec_init_external
",bonzini@qemu/7285477ab11831b1cf56e45878a89170dd06d9b9,CVE-2011-3346,https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9,2014-04-01T06:35Z,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ; <S2SV_EndBug>"
2127,CWE-20,"int oidc_handle_redirect_uri_request ( request_rec * r , oidc_cfg * c , oidc_session_t * session ) { if ( oidc_proto_is_redirect_authorization_response ( r , c ) ) { return oidc_handle_redirect_authorization_response ( r , c , session ) ; } else if ( oidc_proto_is_post_authorization_response ( r , c ) ) { return oidc_handle_post_authorization_response ( r , c , session ) ; } else if ( oidc_is_discovery_response ( r , c ) ) { return oidc_handle_discovery_response ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , ""logout"" ) ) { return oidc_handle_logout ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , ""jwks"" ) ) { return oidc_handle_jwks ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , ""session"" ) ) { return oidc_handle_session_management ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , ""refresh"" ) ) { return oidc_handle_refresh_token_request ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , ""request_uri"" ) ) { return oidc_handle_request_uri ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , ""remove_at_cache"" ) ) { return oidc_handle_remove_at_cache ( r , c ) ; } else if ( ( r -> args == NULL ) || ( apr_strnatcmp ( r -> args , """" ) == 0 ) ) { return oidc_proto_javascript_implicit ( r , c ) ; } if ( oidc_util_request_has_parameter ( r , ""error"" ) ) { oidc_handle_redirect_authorization_response ( r , c , session ) ; } return oidc_util_html_send_error ( r , c -> error_template , ""Invalid<S2SV_blank>Request"" , apr_psprintf ( r -> pool , ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request:<S2SV_blank>%s"" , r -> args ) , HTTP_INTERNAL_SERVER_ERROR ) ; }
","<S2SV_ModStart> -> pool , ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request"" ) , <S2SV_ModEnd> HTTP_INTERNAL_SERVER_ERROR ) ;
",pingidentity@mod_auth_openidc/612e309bfffd6f9b8ad7cdccda3019fc0865f3b4,CVE-2017-6059,https://github.com/pingidentity/mod_auth_openidc/commit/612e309bfffd6f9b8ad7cdccda3019fc0865f3b4,2017-04-12T20:59Z,"<S2SV_StartBug> ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request:<S2SV_blank>%s"" , <S2SV_EndBug>"
980,CWE-416,"static struct ipv6_txoptions * ipv6_update_options ( struct sock * sk , struct ipv6_txoptions * opt ) { if ( inet_sk ( sk ) -> is_icsk ) { if ( opt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_LISTEN | TCPF_CLOSE ) ) && inet_sk ( sk ) -> inet_daddr != LOOPBACK4_IPV6 ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen ; icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } } opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; sk_dst_reset ( sk ) ; return opt ; }
","<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * )
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,"<S2SV_StartBug> opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; <S2SV_EndBug>"
47,CWE-200,"static int l2tp_ip6_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) { struct sockaddr_l2tpip6 * lsa = ( struct sockaddr_l2tpip6 * ) uaddr ; struct sock * sk = sock -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct l2tp_ip6_sock * lsk = l2tp_ip6_sk ( sk ) ; lsa -> l2tp_family = AF_INET6 ; lsa -> l2tp_flowinfo = 0 ; lsa -> l2tp_scope_id = 0 ; if ( peer ) { if ( ! lsk -> peer_conn_id ) return - ENOTCONN ; lsa -> l2tp_conn_id = lsk -> peer_conn_id ; lsa -> l2tp_addr = np -> daddr ; if ( np -> sndflow ) lsa -> l2tp_flowinfo = np -> flow_label ; } else { if ( ipv6_addr_any ( & np -> rcv_saddr ) ) lsa -> l2tp_addr = np -> saddr ; else lsa -> l2tp_addr = np -> rcv_saddr ; lsa -> l2tp_conn_id = lsk -> conn_id ; } if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) lsa -> l2tp_scope_id = sk -> sk_bound_dev_if ; * uaddr_len = sizeof ( * lsa ) ; return 0 ; }
","<S2SV_ModStart> = 0 ; lsa -> l2tp_unused = 0 ;
",torvalds@linux/04d4fbca1017c11381e7d82acea21dd741e748bc,CVE-2012-6543,https://github.com/torvalds/linux/commit/04d4fbca1017c11381e7d82acea21dd741e748bc,2013-03-15T20:55Z,<S2SV_StartBug> if ( peer ) { <S2SV_EndBug>
2906,CWE-834,"static int read_tfra ( MOVContext * mov , AVIOContext * f ) { MOVFragmentIndex * index = NULL ; int version , fieldlength , i , j ; int64_t pos = avio_tell ( f ) ; uint32_t size = avio_rb32 ( f ) ; void * tmp ; if ( avio_rb32 ( f ) != MKBETAG ( 't' , 'f' , 'r' , 'a' ) ) { return 1 ; } av_log ( mov -> fc , AV_LOG_VERBOSE , ""found<S2SV_blank>tfra\\n"" ) ; index = av_mallocz ( sizeof ( MOVFragmentIndex ) ) ; if ( ! index ) { return AVERROR ( ENOMEM ) ; } tmp = av_realloc_array ( mov -> fragment_index_data , mov -> fragment_index_count + 1 , sizeof ( MOVFragmentIndex * ) ) ; if ( ! tmp ) { av_freep ( & index ) ; return AVERROR ( ENOMEM ) ; } mov -> fragment_index_data = tmp ; mov -> fragment_index_data [ mov -> fragment_index_count ++ ] = index ; version = avio_r8 ( f ) ; avio_rb24 ( f ) ; index -> track_id = avio_rb32 ( f ) ; fieldlength = avio_rb32 ( f ) ; index -> item_count = avio_rb32 ( f ) ; index -> items = av_mallocz_array ( index -> item_count , sizeof ( MOVFragmentIndexItem ) ) ; if ( ! index -> items ) { index -> item_count = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < index -> item_count ; i ++ ) { int64_t time , offset ; if ( version == 1 ) { time = avio_rb64 ( f ) ; offset = avio_rb64 ( f ) ; } else { time = avio_rb32 ( f ) ; offset = avio_rb32 ( f ) ; } index -> items [ i ] . time = time ; index -> items [ i ] . moof_offset = offset ; for ( j = 0 ; j < ( ( fieldlength >> 4 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength >> 2 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength >> 0 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; } avio_seek ( f , pos + size , SEEK_SET ) ; return 0 ; }
","<S2SV_ModStart> , offset ; if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; }
",FFmpeg@FFmpeg/9cb4eb772839c5e1de2855d126bf74ff16d13382,CVE-2017-14222,https://github.com/FFmpeg/FFmpeg/commit/9cb4eb772839c5e1de2855d126bf74ff16d13382,2017-09-09T01:29Z,"<S2SV_StartBug> int64_t time , offset ; <S2SV_EndBug>"
125,CWE-285,"int xfs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error = 0 ; if ( ! acl ) goto set_acl ; error = - E2BIG ; if ( acl -> a_count > XFS_ACL_MAX_ENTRIES ( XFS_M ( inode -> i_sb ) ) ) return error ; if ( type == ACL_TYPE_ACCESS ) { umode_t mode = inode -> i_mode ; error = posix_acl_equiv_mode ( acl , & mode ) ; if ( error <= 0 ) { acl = NULL ; if ( error < 0 ) return error ; } error = xfs_set_mode ( inode , mode ) ; if ( error ) return error ; } set_acl : return __xfs_set_acl ( inode , type , acl ) ; }
","<S2SV_ModStart> { umode_t mode <S2SV_ModEnd> ; error = <S2SV_ModStart> ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl <S2SV_ModStart> if ( error <S2SV_ModEnd> ) return error <S2SV_ModStart> return error ; <S2SV_ModEnd> error = xfs_set_mode
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
1008,CWE-284,"static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( ""btif_hl_select_close_connected"" ) ; return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; }
","<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug>"
798,CWE-476,"static int nfc_genl_deactivate_target ( struct sk_buff * skb , struct genl_info * info ) { struct nfc_dev * dev ; u32 device_idx , target_idx ; int rc ; if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) return - EINVAL ; device_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) ; dev = nfc_get_device ( device_idx ) ; if ( ! dev ) return - ENODEV ; target_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_TARGET_INDEX ] ) ; rc = nfc_deactivate_target ( dev , target_idx , NFC_TARGET_MODE_SLEEP ) ; nfc_put_device ( dev ) ; return rc ; }
","<S2SV_ModStart> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX
",torvalds@linux/385097a3675749cbc9e97c085c0e5dfe4269ca51,CVE-2019-12984,https://github.com/torvalds/linux/commit/385097a3675749cbc9e97c085c0e5dfe4269ca51,2019-06-26T18:15Z,<S2SV_StartBug> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <S2SV_EndBug>
2951,CWE-399,"SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) { struct fsnotify_group * group ; struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; user = get_current_user ( ) ; if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; } group = inotify_new_group ( user , inotify_max_queued_events ) ; if ( IS_ERR ( group ) ) { ret = PTR_ERR ( group ) ; goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( ""inotify"" , & inotify_fops , group , O_RDONLY | flags ) ; if ( ret >= 0 ) return ret ; atomic_dec ( & user -> inotify_devs ) ; out_free_uid : free_uid ( user ) ; return ret ; }
","<S2SV_ModStart> return ret ; fsnotify_put_group ( group ) ;
",torvalds@linux/a2ae4cc9a16e211c8a128ba10d22a85431f093ab,CVE-2010-4250,https://github.com/torvalds/linux/commit/a2ae4cc9a16e211c8a128ba10d22a85431f093ab,2012-06-21T23:55Z,<S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug>
1849,CWE-119,"static void rate_block ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , struct rdcost_block_args * args ) { int x_idx , y_idx ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x_idx , & y_idx ) ; args -> rate = cost_coeffs ( args -> x , plane , block , args -> t_above + x_idx , args -> t_left + y_idx , tx_size , args -> so -> scan , args -> so -> neighbors , args -> use_fast_coef_costing ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> rate_block ( int <S2SV_ModStart> y_idx ) ; return <S2SV_ModEnd> cost_coeffs ( args
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void rate_block ( int plane , int block , BLOCK_SIZE plane_bsize , <S2SV_EndBug> <S2SV_StartBug> args -> rate = cost_coeffs ( args -> x , plane , block , args -> t_above + x_idx , <S2SV_EndBug>"
2878,CWE-119,"static void oz_usb_handle_ep_data ( struct oz_usb_ctx * usb_ctx , struct oz_usb_hdr * usb_hdr , int len ) { struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ; switch ( data_hdr -> format ) { case OZ_DATA_F_MULTIPLE_FIXED : { struct oz_multiple_fixed * body = ( struct oz_multiple_fixed * ) data_hdr ; u8 * data = body -> data ; int n ; if ( ! body -> unit_size ) break ; n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) / body -> unit_size ; while ( n -- ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , body -> unit_size ) ; data += body -> unit_size ; } } break ; case OZ_DATA_F_ISOC_FIXED : { struct oz_isoc_fixed * body = ( struct oz_isoc_fixed * ) data_hdr ; int data_len = len - sizeof ( struct oz_isoc_fixed ) + 1 ; int unit_size = body -> unit_size ; u8 * data = body -> data ; int count ; int i ; if ( ! unit_size ) break ; count = data_len / unit_size ; for ( i = 0 ; i < count ; i ++ ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , unit_size ) ; data += unit_size ; } } break ; } }
","<S2SV_ModStart> -> data ; unsigned <S2SV_ModStart> body -> unit_size || len < sizeof ( struct oz_multiple_fixed ) - 1 <S2SV_ModStart> ( len - ( <S2SV_ModStart> struct oz_multiple_fixed ) - 1 ) <S2SV_ModEnd> ) / body
",torvalds@linux/9a59029bc218b48eff8b5d4dde5662fd79d3e1a8,CVE-2015-4002,https://github.com/torvalds/linux/commit/9a59029bc218b48eff8b5d4dde5662fd79d3e1a8,2015-06-07T23:59Z,<S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! body -> unit_size ) <S2SV_EndBug> <S2SV_StartBug> n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug>
2510,CWE-000,"static int ghash_final ( struct shash_desc * desc , u8 * dst ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * buf = dctx -> buffer ; ghash_flush ( ctx , dctx ) ; memcpy ( dst , buf , GHASH_BLOCK_SIZE ) ; return 0 ; }
","<S2SV_ModStart> -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ;
",torvalds@linux/7ed47b7d142ec99ad6880bbbec51e9f12b3af74c,CVE-2011-4081,https://github.com/torvalds/linux/commit/7ed47b7d142ec99ad6880bbbec51e9f12b3af74c,2012-05-24T23:55Z,"<S2SV_StartBug> ghash_flush ( ctx , dctx ) ; <S2SV_EndBug>"
1277,CWE-200,"void __ip_select_ident ( struct iphdr * iph , int segs ) { static u32 ip_idents_hashrnd __read_mostly ; u32 hash , id ; net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , iph -> protocol , ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }
","<S2SV_ModStart> ip_idents_hashrnd __read_mostly ; static u32 ip_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> sizeof ( ip_idents_hashrnd ) ) ; net_get_random_once ( & ip_idents_hashrnd_extra , sizeof ( ip_idents_hashrnd_extra <S2SV_ModStart> iph -> protocol ^ ip_idents_hashrnd_extra
",torvalds@linux/55f0fc7a02de8f12757f4937143d8d5091b2e40b,CVE-2019-10638,https://github.com/torvalds/linux/commit/55f0fc7a02de8f12757f4937143d8d5091b2e40b,2019-07-05T23:15Z,"<S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> iph -> protocol , <S2SV_EndBug>"
4583,CWE-787,"char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) { char * buffer = NULL ; int n = 0 ; FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( """" , cl , NULL ) ; if ( length > 0 ) { buffer = malloc ( ( uint64_t ) length + 1 ) ; if ( buffer != NULL ) { if ( ( n = rfbReadExact ( cl , ( char * ) buffer , length ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( ""rfbProcessFileTransferReadBuffer:<S2SV_blank>read"" ) ; rfbCloseClient ( cl ) ; if ( buffer != NULL ) free ( buffer ) ; return NULL ; } buffer [ length ] = 0 ; } } return buffer ; }
","<S2SV_ModStart> if ( length == SIZE_MAX ) { rfbErr ( ""rfbProcessFileTransferReadBuffer:<S2SV_blank>too<S2SV_blank>big<S2SV_blank>file<S2SV_blank>transfer<S2SV_blank>length<S2SV_blank>requested:<S2SV_blank>%u"" , ( unsigned int ) length ) ; rfbCloseClient ( cl ) ; return NULL ; } if ( length <S2SV_ModStart> malloc ( ( size_t <S2SV_ModEnd> ) length +
",LibVNC@libvncserver/15bb719c03cc70f14c36a843dcb16ed69b405707,CVE-2018-20749,https://github.com/LibVNC/libvncserver/commit/15bb719c03cc70f14c36a843dcb16ed69b405707,2019-01-30T18:29Z,<S2SV_StartBug> if ( length > 0 ) { <S2SV_EndBug> <S2SV_StartBug> buffer = malloc ( ( uint64_t ) length + 1 ) ; <S2SV_EndBug>
7726,CWE-000,"static int _nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state * * res ) { struct nfs4_state_owner * sp ; struct nfs4_state * state = NULL ; struct nfs_server * server = NFS_SERVER ( dir ) ; struct nfs4_opendata * opendata ; int status ; status = - ENOMEM ; if ( ! ( sp = nfs4_get_state_owner ( server , cred ) ) ) { dprintk ( ""nfs4_do_open:<S2SV_blank>nfs4_get_state_owner<S2SV_blank>failed!\\n"" ) ; goto out_err ; } status = nfs4_recover_expired_lease ( server ) ; if ( status != 0 ) goto err_put_state_owner ; if ( path -> dentry -> d_inode != NULL ) nfs4_return_incompatible_delegation ( path -> dentry -> d_inode , flags & ( FMODE_READ | FMODE_WRITE ) ) ; status = - ENOMEM ; opendata = nfs4_opendata_alloc ( path , sp , flags , sattr ) ; if ( opendata == NULL ) goto err_put_state_owner ; if ( path -> dentry -> d_inode != NULL ) opendata -> state = nfs4_get_open_state ( path -> dentry -> d_inode , sp ) ; status = _nfs4_proc_open ( opendata ) ; if ( status != 0 ) goto err_opendata_put ; if ( opendata -> o_arg . open_flags & O_EXCL ) nfs4_exclusive_attrset ( opendata , sattr ) ; state = nfs4_opendata_to_nfs4_state ( opendata ) ; status = PTR_ERR ( state ) ; if ( IS_ERR ( state ) ) goto err_opendata_put ; nfs4_opendata_put ( opendata ) ; nfs4_put_state_owner ( sp ) ; * res = state ; return 0 ; err_opendata_put : nfs4_opendata_put ( opendata ) ; err_put_state_owner : nfs4_put_state_owner ( sp ) ; out_err : * res = NULL ; return status ; }
","<S2SV_ModStart> * path , fmode_t fmode , <S2SV_ModStart> -> d_inode , fmode <S2SV_ModEnd> ) ; status <S2SV_ModStart> path , sp , fmode
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static int _nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state * * res ) <S2SV_EndBug> <S2SV_StartBug> nfs4_return_incompatible_delegation ( path -> dentry -> d_inode , flags & ( FMODE_READ | FMODE_WRITE ) ) ; <S2SV_EndBug> <S2SV_StartBug> opendata = nfs4_opendata_alloc ( path , sp , flags , sattr ) ; <S2SV_EndBug>"
1386,CWE-119,"void vp8_dequant_idct_add_y_block_mmx ( short * q , short * dq , unsigned char * dst , int stride , char * eobs ) { int i ; for ( i = 0 ; i < 4 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dst , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ; vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dst + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dst + 4 , stride , dst + 4 , stride ) ; vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; } if ( eobs [ 2 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 32 , dq , dst + 8 , stride ) ; else if ( eobs [ 2 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 32 ] * dq [ 0 ] , dst + 8 , stride , dst + 8 , stride ) ; vpx_memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; } if ( eobs [ 3 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 48 , dq , dst + 12 , stride ) ; else if ( eobs [ 3 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 48 ] * dq [ 0 ] , dst + 12 , stride , dst + 12 , stride ) ; vpx_memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; } q += 64 ; dst += 4 * stride ; eobs += 4 ; } }
","<S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q , <S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q + <S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q + <S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q +
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug>"
6533,CWE-119,"void cJSON_Delete ( cJSON * c ) { cJSON * next ; while ( c ) { next = c -> next ; if ( ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ; if ( ! ( c -> type & cJSON_IsReference ) && c -> valuestring ) cJSON_free ( c -> valuestring ) ; if ( c -> string ) cJSON_free ( c -> string ) ; cJSON_free ( c ) ; c = next ; } }
","<S2SV_ModStart> ; if ( ! ( c -> type & cJSON_StringIsConst ) &&
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,<S2SV_StartBug> if ( c -> string ) <S2SV_EndBug>
3624,CWE-125,"static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]"" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[max<S2SV_blank>resp<S2SV_blank>delay=%d]"" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[gaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>sflag"" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>robustness=%d"" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 ) { qqi = bp [ 25 ] ; } else { qqi = ( ( bp [ 25 ] & 0x0f ) | 0x10 ) << ( ( ( bp [ 25 ] & 0x70 ) >> 4 ) + 3 ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>qqi=%d"" , qqi ) ) ; } ND_TCHECK2 ( bp [ 26 ] , 2 ) ; nsrcs = EXTRACT_16BITS ( & bp [ 26 ] ) ; if ( nsrcs > 0 ) { if ( len < 28 + nsrcs * sizeof ( struct in6_addr ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources]"" ) ) ; else if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>{"" ) ) ; for ( i = 0 ; i < nsrcs ; i ++ ) { ND_TCHECK2 ( bp [ 28 + i * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 28 + i * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>}"" ) ) ; } else ND_PRINT ( ( ndo , "",<S2SV_blank>%d<S2SV_blank>source(s)"" , nsrcs ) ) ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , mldv2_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug>"
7162,CWE-401,"static ssize_t rpmsg_eptdev_write_iter ( struct kiocb * iocb , struct iov_iter * from ) { struct file * filp = iocb -> ki_filp ; struct rpmsg_eptdev * eptdev = filp -> private_data ; size_t len = iov_iter_count ( from ) ; void * kbuf ; int ret ; kbuf = kzalloc ( len , GFP_KERNEL ) ; if ( ! kbuf ) return - ENOMEM ; if ( ! copy_from_iter_full ( kbuf , len , from ) ) return - EFAULT ; if ( mutex_lock_interruptible ( & eptdev -> ept_lock ) ) { ret = - ERESTARTSYS ; goto free_kbuf ; } if ( ! eptdev -> ept ) { ret = - EPIPE ; goto unlock_eptdev ; } if ( filp -> f_flags & O_NONBLOCK ) ret = rpmsg_trysend ( eptdev -> ept , kbuf , len ) ; else ret = rpmsg_send ( eptdev -> ept , kbuf , len ) ; unlock_eptdev : mutex_unlock ( & eptdev -> ept_lock ) ; free_kbuf : kfree ( kbuf ) ; return ret < 0 ? ret : len ; }
","<S2SV_ModStart> from ) ) { ret = <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; goto free_kbuf ; }
",torvalds@linux/bbe692e349e2a1edf3fe0a29a0e05899c9c94d51,CVE-2019-19053,https://github.com/torvalds/linux/commit/bbe692e349e2a1edf3fe0a29a0e05899c9c94d51,2019-11-18T06:15Z,<S2SV_StartBug> return - EFAULT ; <S2SV_EndBug>
524,CWE-190,"bool layer_resize ( int layer , int x_size , int y_size ) { int old_height ; int old_width ; struct map_tile * tile ; int tile_width ; int tile_height ; struct map_tile * tilemap ; struct map_trigger * trigger ; struct map_zone * zone ; int x , y , i ; old_width = s_map -> layers [ layer ] . width ; old_height = s_map -> layers [ layer ] . height ; if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) ) return false ; for ( x = 0 ; x < x_size ; ++ x ) { for ( y = 0 ; y < y_size ; ++ y ) { if ( x < old_width && y < old_height ) { tilemap [ x + y * x_size ] = s_map -> layers [ layer ] . tilemap [ x + y * old_width ] ; } else { tile = & tilemap [ x + y * x_size ] ; tile -> frames_left = tileset_get_delay ( s_map -> tileset , 0 ) ; tile -> tile_index = 0 ; } } } free ( s_map -> layers [ layer ] . tilemap ) ; s_map -> layers [ layer ] . tilemap = tilemap ; s_map -> layers [ layer ] . width = x_size ; s_map -> layers [ layer ] . height = y_size ; tileset_get_size ( s_map -> tileset , & tile_width , & tile_height ) ; s_map -> width = 0 ; s_map -> height = 0 ; for ( i = 0 ; i < s_map -> num_layers ; ++ i ) { if ( ! s_map -> layers [ i ] . is_parallax ) { s_map -> width = fmax ( s_map -> width , s_map -> layers [ i ] . width * tile_width ) ; s_map -> height = fmax ( s_map -> height , s_map -> layers [ i ] . height * tile_height ) ; } } for ( i = ( int ) vector_len ( s_map -> zones ) - 1 ; i >= 0 ; -- i ) { zone = vector_get ( s_map -> zones , i ) ; if ( zone -> bounds . x1 >= s_map -> width || zone -> bounds . y1 >= s_map -> height ) vector_remove ( s_map -> zones , i ) ; else { if ( zone -> bounds . x2 > s_map -> width ) zone -> bounds . x2 = s_map -> width ; if ( zone -> bounds . y2 > s_map -> height ) zone -> bounds . y2 = s_map -> height ; } } for ( i = ( int ) vector_len ( s_map -> triggers ) - 1 ; i >= 0 ; -- i ) { trigger = vector_get ( s_map -> triggers , i ) ; if ( trigger -> x >= s_map -> width || trigger -> y >= s_map -> height ) vector_remove ( s_map -> triggers , i ) ; } return true ; }
","<S2SV_ModStart> * zone ; size_t tilemap_size ; <S2SV_ModStart> . height ; tilemap_size = <S2SV_ModEnd> x_size * y_size <S2SV_ModStart> struct map_tile ) ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size
",fatcerberus@minisphere/252c1ca184cb38e1acb917aa0e451c5f08519996,CVE-2018-1000524,https://github.com/fatcerberus/minisphere/commit/252c1ca184cb38e1acb917aa0e451c5f08519996,2018-06-26T16:29Z,"<S2SV_StartBug> int x , y , i ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) ) <S2SV_EndBug>"
1384,CWE-119,"void vp8_setup_intra_recon_top_line ( YV12_BUFFER_CONFIG * ybf ) { vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ; vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; }
","<S2SV_ModStart> ybf ) { memset <S2SV_ModEnd> ( ybf -> <S2SV_ModStart> 5 ) ; memset <S2SV_ModEnd> ( ybf -> <S2SV_ModStart> 5 ) ; memset <S2SV_ModEnd> ( ybf ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug>"
683,CWE-476,"int read_escaped_char ( yyscan_t yyscanner , uint8_t * escaped_char ) { char text [ 4 ] = { 0 , 0 , 0 , 0 } ; text [ 0 ] = '\\\\' ; text [ 1 ] = RE_YY_INPUT ( yyscanner ) ; if ( text [ 1 ] == EOF ) return 0 ; if ( text [ 1 ] == 'x' ) { text [ 2 ] = RE_YY_INPUT ( yyscanner ) ; if ( text [ 2 ] == EOF ) return 0 ; text [ 3 ] = RE_YY_INPUT ( yyscanner ) ; if ( text [ 3 ] == EOF ) return 0 ; } * escaped_char = escaped_char_value ( text ) ; return 1 ; }
","<S2SV_ModStart> ] == EOF || text [ 1 ] == 0 <S2SV_ModStart> ; if ( ! isxdigit ( <S2SV_ModStart> [ 2 ] ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( ! isxdigit ( <S2SV_ModStart> [ 3 ] ) <S2SV_ModEnd> ) return 0
",VirusTotal@yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,CVE-2016-10210,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,2017-04-03T05:59Z,<S2SV_StartBug> if ( text [ 1 ] == EOF ) <S2SV_EndBug> <S2SV_StartBug> if ( text [ 2 ] == EOF ) <S2SV_EndBug> <S2SV_StartBug> if ( text [ 3 ] == EOF ) <S2SV_EndBug>
1316,CWE-59,"static int setup_dev_console ( const struct lxc_rootfs * rootfs , const struct lxc_console * console ) { char path [ MAXPATHLEN ] ; struct stat s ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/dev/console"" , rootfs -> mount ) ; if ( ret >= sizeof ( path ) ) { ERROR ( ""console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } if ( access ( path , F_OK ) ) { WARN ( ""rootfs<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>no<S2SV_blank>console<S2SV_blank>found<S2SV_blank>at<S2SV_blank>\'%s\'"" , path ) ; return 0 ; } if ( console -> master < 0 ) { INFO ( ""no<S2SV_blank>console"" ) ; return 0 ; } if ( stat ( path , & s ) ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>stat<S2SV_blank>\'%s\'"" , path ) ; return - 1 ; } if ( chmod ( console -> name , s . st_mode ) ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>mode<S2SV_blank>\'0%o\'<S2SV_blank>to<S2SV_blank>\'%s\'"" , s . st_mode , console -> name ) ; return - 1 ; } if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , console -> name , path ) ; return - 1 ; } INFO ( ""console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup"" ) ; return 0 ; }
","<S2SV_ModStart> } if ( safe_mount ( console -> name , path , ""none"" , MS_BIND , 0 , rootfs -> mount <S2SV_ModEnd> ) ) {
",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z,"<S2SV_StartBug> if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) { <S2SV_EndBug>"
3674,CWE-732,"static M_bool M_fs_check_overwrite_allowed ( const char * p1 , const char * p2 , M_uint32 mode ) { M_fs_info_t * info = NULL ; char * pold = NULL ; char * pnew = NULL ; M_fs_type_t type ; M_bool ret = M_TRUE ; if ( mode & M_FS_FILE_MODE_OVERWRITE ) return M_TRUE ; if ( M_fs_info ( & info , p1 , M_FS_PATH_INFO_FLAGS_BASIC ) != M_FS_ERROR_SUCCESS ) return M_FALSE ; type = M_fs_info_get_type ( info ) ; M_fs_info_destroy ( info ) ; if ( type != M_FS_TYPE_DIR ) { if ( M_fs_perms_can_access ( p2 , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { ret = M_FALSE ; goto done ; } } pold = M_fs_path_basename ( p1 , M_FS_SYSTEM_AUTO ) ; pnew = M_fs_path_join ( p2 , pnew , M_FS_SYSTEM_AUTO ) ; if ( M_fs_perms_can_access ( pnew , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { ret = M_FALSE ; goto done ; } done : M_free ( pnew ) ; M_free ( pold ) ; return ret ; }
","
",Monetra@mstdlib/db124b8f607dd0a40a9aef2d4d468fad433522a7,CVE-2018-14043,https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7,2018-07-13T14:29Z,
2286,CWE-119,"protected int file_trycdf ( struct magic_set * ms , int fd , const unsigned char * buf , size_t nbytes ) { cdf_info_t info ; cdf_header_t h ; cdf_sat_t sat , ssat ; cdf_stream_t sst , scn ; cdf_dir_t dir ; int i ; const char * expn = """" ; const char * corrupt = ""corrupt:<S2SV_blank>"" ; info . i_fd = fd ; info . i_buf = buf ; info . i_len = nbytes ; if ( ms -> flags & MAGIC_APPLE ) return 0 ; if ( cdf_read_header ( & info , & h ) == - 1 ) return 0 ; # ifdef CDF_DEBUG cdf_dump_header ( & h ) ; # endif if ( ( i = cdf_read_sat ( & info , & h , & sat ) ) == - 1 ) { expn = ""Can\'t<S2SV_blank>read<S2SV_blank>SAT"" ; goto out0 ; } # ifdef CDF_DEBUG cdf_dump_sat ( ""SAT"" , & sat , CDF_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_ssat ( & info , & h , & sat , & ssat ) ) == - 1 ) { expn = ""Can\'t<S2SV_blank>read<S2SV_blank>SSAT"" ; goto out1 ; } # ifdef CDF_DEBUG cdf_dump_sat ( ""SSAT"" , & ssat , CDF_SHORT_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_dir ( & info , & h , & sat , & dir ) ) == - 1 ) { expn = ""Can\'t<S2SV_blank>read<S2SV_blank>directory"" ; goto out2 ; } const cdf_directory_t * root_storage ; if ( ( i = cdf_read_short_stream ( & info , & h , & sat , & dir , & sst , & root_storage ) ) == - 1 ) { expn = ""Cannot<S2SV_blank>read<S2SV_blank>short<S2SV_blank>stream"" ; goto out3 ; } # ifdef CDF_DEBUG cdf_dump_dir ( & info , & h , & sat , & ssat , & sst , & dir ) ; # endif # ifdef notdef if ( root_storage ) { if ( NOTMIME ( ms ) ) { char clsbuf [ 128 ] ; if ( file_printf ( ms , ""CLSID<S2SV_blank>%s,<S2SV_blank>"" , format_clsid ( clsbuf , sizeof ( clsbuf ) , root_storage -> d_storage_uuid ) ) == - 1 ) return - 1 ; } } # endif if ( ( i = cdf_read_summary_info ( & info , & h , & sat , & ssat , & sst , & dir , & scn ) ) == - 1 ) { if ( errno == ESRCH ) { corrupt = expn ; expn = ""No<S2SV_blank>summary<S2SV_blank>info"" ; } else { expn = ""Cannot<S2SV_blank>read<S2SV_blank>summary<S2SV_blank>info"" ; } goto out4 ; } # ifdef CDF_DEBUG cdf_dump_summary_info ( & h , & scn ) ; # endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn , root_storage -> d_storage_uuid ) ) < 0 ) expn = ""Can\'t<S2SV_blank>expand<S2SV_blank>summary_info"" ; if ( i == 0 ) { const char * str = NULL ; cdf_directory_t * d ; char name [ __arraycount ( d -> d_name ) ] ; size_t j , k ; for ( j = 0 ; str == NULL && j < dir . dir_len ; j ++ ) { d = & dir . dir_tab [ j ] ; for ( k = 0 ; k < sizeof ( name ) ; k ++ ) name [ k ] = ( char ) cdf_tole2 ( d -> d_name [ k ] ) ; str = cdf_app_to_mime ( name , NOTMIME ( ms ) ? name2desc : name2mime ) ; } if ( NOTMIME ( ms ) ) { if ( str != NULL ) { if ( file_printf ( ms , ""%s"" , str ) == - 1 ) return - 1 ; i = 1 ; } } else { if ( str == NULL ) str = ""vnd.ms-office"" ; if ( file_printf ( ms , ""application/%s"" , str ) == - 1 ) return - 1 ; i = 1 ; } } free ( scn . sst_tab ) ; out4 : free ( sst . sst_tab ) ; out3 : free ( dir . dir_tab ) ; out2 : free ( ssat . sat_tab ) ; out1 : free ( sat . sat_tab ) ; out0 : if ( i == - 1 ) { if ( NOTMIME ( ms ) ) { if ( file_printf ( ms , ""Composite<S2SV_blank>Document<S2SV_blank>File<S2SV_blank>V2<S2SV_blank>Document"" ) == - 1 ) return - 1 ; if ( * expn ) if ( file_printf ( ms , "",<S2SV_blank>%s%s"" , corrupt , expn ) == - 1 ) return - 1 ; } else { if ( file_printf ( ms , ""application/CDFV2-corrupt"" ) == - 1 ) return - 1 ; } i = 1 ; } return i ; }
","<S2SV_ModStart> scn , root_storage <S2SV_ModEnd> ) ) <
",file@file/6d209c1c489457397a5763bca4b28e43aac90391,CVE-2014-0207,https://github.com/file/file/commit/6d209c1c489457397a5763bca4b28e43aac90391,2014-07-09T11:07Z,<S2SV_StartBug> root_storage -> d_storage_uuid ) ) < 0 ) <S2SV_EndBug>
7838,CWE-20,"error_t rawSocketSendIpPacket ( Socket * socket , const SocketMsg * message , uint_t flags ) { error_t error ; size_t offset ; NetBuffer * buffer ; NetInterface * interface ; IpPseudoHeader pseudoHeader ; NetTxAncillary ancillary ; interface = socket -> interface ; buffer = ipAllocBuffer ( 0 , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; do { error = netBufferAppend ( buffer , message -> data , message -> length ) ; if ( error ) break ; # if ( IPV4_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv4Addr ) ) { Ipv4Addr srcIpAddr ; error = ipv4SelectSourceAddr ( & interface , message -> destIpAddr . ipv4Addr , & srcIpAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv4PseudoHeader ) ; pseudoHeader . ipv4Data . srcAddr = srcIpAddr ; pseudoHeader . ipv4Data . destAddr = message -> destIpAddr . ipv4Addr ; pseudoHeader . ipv4Data . reserved = 0 ; pseudoHeader . ipv4Data . protocol = socket -> protocol ; pseudoHeader . ipv4Data . length = htons ( message -> length ) ; } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv6Addr ) ) { error = ipv6SelectSourceAddr ( & interface , & message -> destIpAddr . ipv6Addr , & pseudoHeader . ipv6Data . srcAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv6PseudoHeader ) ; pseudoHeader . ipv6Data . destAddr = message -> destIpAddr . ipv6Addr ; pseudoHeader . ipv6Data . length = htonl ( message -> length ) ; pseudoHeader . ipv6Data . reserved [ 0 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 1 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 2 ] = 0 ; pseudoHeader . ipv6Data . nextHeader = socket -> protocol ; } else # endif { error = ERROR_FAILURE ; break ; } ancillary = NET_DEFAULT_TX_ANCILLARY ; if ( message -> ttl != 0 ) { ancillary . ttl = message -> ttl ; } else if ( ipIsMulticastAddr ( & message -> destIpAddr ) ) { ancillary . ttl = socket -> multicastTtl ; } else { ancillary . ttl = socket -> ttl ; } if ( flags & SOCKET_FLAG_DONT_ROUTE ) { ancillary . dontRoute = TRUE ; } # if ( IP_DIFF_SERV_SUPPORT == ENABLED ) ancillary . dscp = socket -> dscp ; # endif # if ( ETH_SUPPORT == ENABLED ) ancillary . srcMacAddr = message -> srcMacAddr ; ancillary . destMacAddr = message -> destMacAddr ; # endif # if ( ETH_VLAN_SUPPORT == ENABLED ) ancillary . vlanPcp = socket -> vlanPcp ; ancillary . vlanDei = socket -> vlanDei ; # endif # if ( ETH_VMAN_SUPPORT == ENABLED ) ancillary . vmanPcp = socket -> vmanPcp ; ancillary . vmanDei = socket -> vmanDei ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) ancillary . port = message -> switchPort ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) ancillary . timestampId = message -> timestampId ; # endif error = ipSendDatagram ( interface , & pseudoHeader , buffer , offset , & ancillary ) ; if ( error ) break ; } while ( 0 ) ; netBufferFree ( buffer ) ; return error ; }
","<S2SV_ModStart> NetTxAncillary ancillary ; if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModEnd> buffer = ipAllocBuffer
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> interface = socket -> interface ; <S2SV_EndBug>
2940,CWE-000,"bool_t xdr_krb5_principal ( XDR * xdrs , krb5_principal * objp ) { int ret ; char * p = NULL ; krb5_principal pr = NULL ; static krb5_context context = NULL ; if ( ! context && kadm5_init_krb5_context ( & context ) ) return ( FALSE ) ; switch ( xdrs -> x_op ) { case XDR_ENCODE : if ( * objp ) { if ( ( ret = krb5_unparse_name ( context , * objp , & p ) ) != 0 ) return FALSE ; } if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) free ( p ) ; break ; case XDR_DECODE : if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) { ret = krb5_parse_name ( context , p , & pr ) ; if ( ret != 0 ) return FALSE ; * objp = pr ; free ( p ) ; } else * objp = NULL ; break ; case XDR_FREE : if ( * objp != NULL ) krb5_free_principal ( context , * objp ) ; break ; } return TRUE ; }
","<S2SV_ModStart> objp ) ; * objp = NULL ;
",krb5@krb5/a197e92349a4aa2141b5dff12e9dd44c2a2166e3,CVE-2014-9421,https://github.com/krb5/krb5/commit/a197e92349a4aa2141b5dff12e9dd44c2a2166e3,2015-02-19T11:59Z,<S2SV_StartBug> break ; <S2SV_EndBug>
1255,CWE-119,"static inline bool unconditional ( const struct ip6t_ip6 * ipv6 ) { static const struct ip6t_ip6 uncond ; return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ; }
","<S2SV_ModStart> ( const struct ip6t_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e -> <S2SV_ModEnd> ipv6 , &
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z,"<S2SV_StartBug> static inline bool unconditional ( const struct ip6t_ip6 * ipv6 ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug>"
4532,CWE-125,"PyObject * ast2obj_stmt ( void * _o ) { stmt_ty o = ( stmt_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_INCREF ( Py_None ) ; return Py_None ; } switch ( o -> kind ) { case FunctionDef_kind : result = PyType_GenericNew ( FunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . FunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . FunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . AsyncFunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . AsyncFunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ClassDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . bases , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_bases , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . keywords , ast2obj_keyword ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_keywords , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Return_kind : result = PyType_GenericNew ( Return_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Return . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Delete_kind : result = PyType_GenericNew ( Delete_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Delete . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assign_kind : result = PyType_GenericNew ( Assign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Assign . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . Assign . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AugAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . AugAssign . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AugAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AnnAssign_kind : result = PyType_GenericNew ( AnnAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AnnAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . AnnAssign . simple ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_simple , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case For_kind : result = PyType_GenericNew ( For_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . For . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . For . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . For . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AsyncFor . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFor . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . While . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case If_kind : result = PyType_GenericNew ( If_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . If . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case With_kind : result = PyType_GenericNew ( With_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . With . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . With . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . With . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . AsyncWith . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncWith . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Raise . exc ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_exc , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Raise . cause ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_cause , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Try_kind : result = PyType_GenericNew ( Try_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Try . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . handlers , ast2obj_excepthandler ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_handlers , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . finalbody , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_finalbody , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assert_kind : result = PyType_GenericNew ( Assert_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Assert . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assert . msg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_msg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Import_kind : result = PyType_GenericNew ( Import_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Import . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ImportFrom_kind : result = PyType_GenericNew ( ImportFrom_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ImportFrom . module ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_module , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ImportFrom . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . ImportFrom . level ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_level , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Global_kind : result = PyType_GenericNew ( Global_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Global . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Nonlocal_kind : result = PyType_GenericNew ( Nonlocal_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Nonlocal . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expr_kind : result = PyType_GenericNew ( Expr_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expr . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Pass_kind : result = PyType_GenericNew ( Pass_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Break_kind : result = PyType_GenericNew ( Break_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Continue_kind : result = PyType_GenericNew ( Continue_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug>
1641,CWE-119,"void vp9_vaq_frame_setup ( VP9_COMP * cpi ) { VP9_COMMON * cm = & cpi -> common ; struct segmentation * seg = & cm -> seg ; const double base_q = vp9_convert_qindex_to_q ( cm -> base_qindex ) ; const int base_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + cm -> y_dc_delta_q ) ; int i ; if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_clear_system_state ( ) ; for ( i = ENERGY_MIN ; i <= ENERGY_MAX ; i ++ ) { int qindex_delta , segment_rdmult ; if ( Q_RATIO ( i ) == 1 ) { RDMULT_RATIO ( i ) = 1 ; continue ; } qindex_delta = vp9_compute_qdelta ( & cpi -> rc , base_q , base_q * Q_RATIO ( i ) ) ; vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ; vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ; segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta + cm -> y_dc_delta_q ) ; RDMULT_RATIO ( i ) = ( double ) segment_rdmult / base_rdmult ; } } }
","<S2SV_ModStart> cm -> seg <S2SV_ModEnd> ; int i <S2SV_ModStart> = SEGMENT_DELTADATA ; vpx_clear_system_state <S2SV_ModEnd> ( ) ; <S2SV_ModStart> ( i = 0 ; i < MAX_SEGMENTS ; ++ i <S2SV_ModEnd> ) { int <S2SV_ModStart> { int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , rate_ratio [ i ] , cm -> bit_depth ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( rate_ratio [ i ] == 1.0 ) { <S2SV_ModEnd> continue ; } <S2SV_ModStart> continue ; } <S2SV_ModEnd> vp9_set_segdata ( seg <S2SV_ModStart> ( seg , i <S2SV_ModEnd> , SEG_LVL_ALT_Q , <S2SV_ModStart> ( seg , i <S2SV_ModEnd> , SEG_LVL_ALT_Q ) <S2SV_ModStart> SEG_LVL_ALT_Q ) ; <S2SV_ModEnd> } } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> struct segmentation * seg = & cm -> seg ; <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = ENERGY_MIN ; i <= ENERGY_MAX ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int qindex_delta , segment_rdmult ; <S2SV_EndBug> <S2SV_StartBug> if ( Q_RATIO ( i ) == 1 ) { <S2SV_EndBug> <S2SV_StartBug> qindex_delta = vp9_compute_qdelta ( & cpi -> rc , base_q , base_q * Q_RATIO ( i ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ; <S2SV_EndBug> <S2SV_StartBug> segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta + <S2SV_EndBug>"
3443,CWE-119,"static uint32_t color_string_to_rgba ( const char * p , int len ) { uint32_t ret = 0xFF000000 ; const ColorEntry * entry ; char color_name [ 100 ] ; if ( * p == '#' ) { p ++ ; len -- ; if ( len == 3 ) { ret |= ( hex_char_to_number ( p [ 2 ] ) << 4 ) | ( hex_char_to_number ( p [ 1 ] ) << 12 ) | ( hex_char_to_number ( p [ 0 ] ) << 20 ) ; } else if ( len == 4 ) { ret = ( hex_char_to_number ( p [ 3 ] ) << 4 ) | ( hex_char_to_number ( p [ 2 ] ) << 12 ) | ( hex_char_to_number ( p [ 1 ] ) << 20 ) | ( hex_char_to_number ( p [ 0 ] ) << 28 ) ; } else if ( len == 6 ) { ret |= hex_char_to_number ( p [ 5 ] ) | ( hex_char_to_number ( p [ 4 ] ) << 4 ) | ( hex_char_to_number ( p [ 3 ] ) << 8 ) | ( hex_char_to_number ( p [ 2 ] ) << 12 ) | ( hex_char_to_number ( p [ 1 ] ) << 16 ) | ( hex_char_to_number ( p [ 0 ] ) << 20 ) ; } else if ( len == 8 ) { ret = hex_char_to_number ( p [ 7 ] ) | ( hex_char_to_number ( p [ 6 ] ) << 4 ) | ( hex_char_to_number ( p [ 5 ] ) << 8 ) | ( hex_char_to_number ( p [ 4 ] ) << 12 ) | ( hex_char_to_number ( p [ 3 ] ) << 16 ) | ( hex_char_to_number ( p [ 2 ] ) << 20 ) | ( hex_char_to_number ( p [ 1 ] ) << 24 ) | ( hex_char_to_number ( p [ 0 ] ) << 28 ) ; } } else { strncpy ( color_name , p , len ) ; color_name [ len ] = '\\0' ; entry = bsearch ( color_name , color_table , FF_ARRAY_ELEMS ( color_table ) , sizeof ( ColorEntry ) , color_table_compare ) ; if ( ! entry ) return ret ; ret = entry -> rgb_color ; } return ret ; }
","<S2SV_ModStart> 100 ] ; len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;
",FFmpeg@FFmpeg/cb243972b121b1ae6b60a78ff55a0506c69f3879,CVE-2017-9990,https://github.com/FFmpeg/FFmpeg/commit/cb243972b121b1ae6b60a78ff55a0506c69f3879,2017-06-28T06:29Z,<S2SV_StartBug> if ( * p == '#' ) { <S2SV_EndBug>
748,CWE-119,"static int sc_pkcs15emu_esteid_init ( sc_pkcs15_card_t * p15card ) { sc_card_t * card = p15card -> card ; unsigned char buff [ 128 ] ; int r , i ; size_t field_length = 0 , modulus_length = 0 ; sc_path_t tmppath ; set_string ( & p15card -> tokeninfo -> label , ""ID-kaart"" ) ; set_string ( & p15card -> tokeninfo -> manufacturer_id , ""AS<S2SV_blank>Sertifitseerimiskeskus"" ) ; sc_format_path ( ""3f00eeee5044"" , & tmppath ) ; r = sc_select_file ( card , & tmppath , NULL ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , ""select<S2SV_blank>esteid<S2SV_blank>PD<S2SV_blank>failed"" ) ; r = sc_read_record ( card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , ""read<S2SV_blank>document<S2SV_blank>number<S2SV_blank>failed"" ) ; buff [ r ] = '\\0' ; set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ; p15card -> tokeninfo -> flags = SC_PKCS15_TOKEN_PRN_GENERATION | SC_PKCS15_TOKEN_EID_COMPLIANT | SC_PKCS15_TOKEN_READONLY ; for ( i = 0 ; i < 2 ; i ++ ) { static const char * esteid_cert_names [ 2 ] = { ""Isikutuvastus"" , ""Allkirjastamine"" } ; static char const * esteid_cert_paths [ 2 ] = { ""3f00eeeeaace"" , ""3f00eeeeddce"" } ; static int esteid_cert_ids [ 2 ] = { 1 , 2 } ; struct sc_pkcs15_cert_info cert_info ; struct sc_pkcs15_object cert_obj ; memset ( & cert_info , 0 , sizeof ( cert_info ) ) ; memset ( & cert_obj , 0 , sizeof ( cert_obj ) ) ; cert_info . id . value [ 0 ] = esteid_cert_ids [ i ] ; cert_info . id . len = 1 ; sc_format_path ( esteid_cert_paths [ i ] , & cert_info . path ) ; strlcpy ( cert_obj . label , esteid_cert_names [ i ] , sizeof ( cert_obj . label ) ) ; r = sc_pkcs15emu_add_x509_cert ( p15card , & cert_obj , & cert_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; if ( i == 0 ) { sc_pkcs15_cert_t * cert = NULL ; r = sc_pkcs15_read_certificate ( p15card , & cert_info , & cert ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; if ( cert -> key -> algorithm == SC_ALGORITHM_EC ) field_length = cert -> key -> u . ec . params . field_length ; else modulus_length = cert -> key -> u . rsa . modulus . len * 8 ; if ( r == SC_SUCCESS ) { static const struct sc_object_id cn_oid = { { 2 , 5 , 4 , 3 , - 1 } } ; u8 * cn_name = NULL ; size_t cn_len = 0 ; sc_pkcs15_get_name_from_dn ( card -> ctx , cert -> subject , cert -> subject_len , & cn_oid , & cn_name , & cn_len ) ; if ( cn_len > 0 ) { char * token_name = malloc ( cn_len + 1 ) ; if ( token_name ) { memcpy ( token_name , cn_name , cn_len ) ; token_name [ cn_len ] = '\\0' ; set_string ( & p15card -> tokeninfo -> label , ( const char * ) token_name ) ; free ( token_name ) ; } } free ( cn_name ) ; sc_pkcs15_free_certificate ( cert ) ; } } } sc_format_path ( ""3f000016"" , & tmppath ) ; r = sc_select_file ( card , & tmppath , NULL ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; for ( i = 0 ; i < 3 ; i ++ ) { unsigned char tries_left ; static const char * esteid_pin_names [ 3 ] = { ""PIN1"" , ""PIN2"" , ""PUK"" } ; static const int esteid_pin_min [ 3 ] = { 4 , 5 , 8 } ; static const int esteid_pin_ref [ 3 ] = { 1 , 2 , 0 } ; static const int esteid_pin_authid [ 3 ] = { 1 , 2 , 3 } ; static const int esteid_pin_flags [ 3 ] = { 0 , 0 , SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN } ; struct sc_pkcs15_auth_info pin_info ; struct sc_pkcs15_object pin_obj ; memset ( & pin_info , 0 , sizeof ( pin_info ) ) ; memset ( & pin_obj , 0 , sizeof ( pin_obj ) ) ; r = sc_read_record ( card , i + 1 , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; tries_left = buff [ 5 ] ; pin_info . auth_id . len = 1 ; pin_info . auth_id . value [ 0 ] = esteid_pin_authid [ i ] ; pin_info . auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN ; pin_info . attrs . pin . reference = esteid_pin_ref [ i ] ; pin_info . attrs . pin . flags = esteid_pin_flags [ i ] ; pin_info . attrs . pin . type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC ; pin_info . attrs . pin . min_length = esteid_pin_min [ i ] ; pin_info . attrs . pin . stored_length = 12 ; pin_info . attrs . pin . max_length = 12 ; pin_info . attrs . pin . pad_char = '\\0' ; pin_info . tries_left = ( int ) tries_left ; pin_info . max_tries = 3 ; strlcpy ( pin_obj . label , esteid_pin_names [ i ] , sizeof ( pin_obj . label ) ) ; pin_obj . flags = esteid_pin_flags [ i ] ; if ( i < 2 ) { pin_obj . auth_id . len = 1 ; pin_obj . auth_id . value [ 0 ] = 3 ; } r = sc_pkcs15emu_add_pin_obj ( p15card , & pin_obj , & pin_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; } for ( i = 0 ; i < 2 ; i ++ ) { static int prkey_pin [ 2 ] = { 1 , 2 } ; static const char * prkey_name [ 2 ] = { ""Isikutuvastus"" , ""Allkirjastamine"" } ; struct sc_pkcs15_prkey_info prkey_info ; struct sc_pkcs15_object prkey_obj ; memset ( & prkey_info , 0 , sizeof ( prkey_info ) ) ; memset ( & prkey_obj , 0 , sizeof ( prkey_obj ) ) ; prkey_info . id . len = 1 ; prkey_info . id . value [ 0 ] = prkey_pin [ i ] ; prkey_info . native = 1 ; prkey_info . key_reference = i + 1 ; prkey_info . field_length = field_length ; prkey_info . modulus_length = modulus_length ; if ( i == 1 ) prkey_info . usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION ; else if ( field_length > 0 ) prkey_info . usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE ; else prkey_info . usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT ; strlcpy ( prkey_obj . label , prkey_name [ i ] , sizeof ( prkey_obj . label ) ) ; prkey_obj . auth_id . len = 1 ; prkey_obj . auth_id . value [ 0 ] = prkey_pin [ i ] ; prkey_obj . user_consent = 0 ; prkey_obj . flags = SC_PKCS15_CO_FLAG_PRIVATE ; if ( field_length > 0 ) r = sc_pkcs15emu_add_ec_prkey ( p15card , & prkey_obj , & prkey_info ) ; else r = sc_pkcs15emu_add_rsa_prkey ( p15card , & prkey_obj , & prkey_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; } return SC_SUCCESS ; }
","<S2SV_ModStart> ; buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <S2SV_ModEnd> ] = '\\0'
",OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16391,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536,2018-09-03T14:29Z,<S2SV_StartBug> buff [ r ] = '\\0' ; <S2SV_EndBug>
511,CWE-20,"static int net_ctl_permissions ( struct ctl_table_header * head , struct ctl_table * table ) { struct net * net = container_of ( head -> set , struct net , sysctls ) ; kuid_t root_uid = make_kuid ( net -> user_ns , 0 ) ; kgid_t root_gid = make_kgid ( net -> user_ns , 0 ) ; if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) || uid_eq ( root_uid , current_uid ( ) ) ) { int mode = ( table -> mode >> 6 ) & 7 ; return ( mode << 6 ) | ( mode << 3 ) | mode ; } if ( gid_eq ( root_gid , current_gid ( ) ) ) { int mode = ( table -> mode >> 3 ) & 7 ; return ( mode << 3 ) | mode ; } return table -> mode ; }
","<S2SV_ModStart> ( root_uid , current_euid <S2SV_ModEnd> ( ) ) <S2SV_ModStart> } if ( in_egroup_p ( root_gid <S2SV_ModEnd> ) ) {
",torvalds@linux/2433c8f094a008895e66f25bd1773cdb01c91d01,CVE-2013-4270,https://github.com/torvalds/linux/commit/2433c8f094a008895e66f25bd1773cdb01c91d01,2013-12-09T18:55Z,"<S2SV_StartBug> uid_eq ( root_uid , current_uid ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( gid_eq ( root_gid , current_gid ( ) ) ) { <S2SV_EndBug>"
7988,CWE-120,"SecureElementStatus_t SecureElementProcessJoinAccept ( JoinReqIdentifier_t joinReqType , uint8_t * joinEui , uint16_t devNonce , uint8_t * encJoinAccept , uint8_t encJoinAcceptSize , uint8_t * decJoinAccept , uint8_t * versionMinor ) { if ( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) ) { return SECURE_ELEMENT_ERROR_NPE ; } KeyIdentifier_t encKeyID = NWK_KEY ; if ( joinReqType != JOIN_REQ ) { encKeyID = J_S_ENC_KEY ; } memcpy1 ( decJoinAccept , encJoinAccept , encJoinAcceptSize ) ; if ( SecureElementAesEncrypt ( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE , encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE , encKeyID , decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS ) { return SECURE_ELEMENT_FAIL_ENCRYPT ; } * versionMinor = ( ( decJoinAccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; uint32_t mic = 0 ; mic = ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ] << 0 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1 ] << 8 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2 ] << 16 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3 ] << 24 ) ; if ( * versionMinor == 0 ) { if ( SecureElementVerifyAesCmac ( decJoinAccept , ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ) , mic , NWK_KEY ) != SECURE_ELEMENT_SUCCESS ) { return SECURE_ELEMENT_FAIL_CMAC ; } } # if ( USE_LRWAN_1_1_X_CRYPTO == 1 ) else if ( * versionMinor == 1 ) { uint8_t micHeader11 [ JOIN_ACCEPT_MIC_COMPUTATION_OFFSET ] = { 0 } ; uint16_t bufItr = 0 ; micHeader11 [ bufItr ++ ] = ( uint8_t ) joinReqType ; memcpyr ( micHeader11 + bufItr , joinEui , LORAMAC_JOIN_EUI_FIELD_SIZE ) ; bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE ; micHeader11 [ bufItr ++ ] = devNonce & 0xFF ; micHeader11 [ bufItr ++ ] = ( devNonce >> 8 ) & 0xFF ; uint8_t localBuffer [ LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET ] = { 0 } ; memcpy1 ( localBuffer , micHeader11 , JOIN_ACCEPT_MIC_COMPUTATION_OFFSET ) ; memcpy1 ( localBuffer + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET - 1 , decJoinAccept , encJoinAcceptSize ) ; if ( SecureElementVerifyAesCmac ( localBuffer , encJoinAcceptSize + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET - LORAMAC_MHDR_FIELD_SIZE - LORAMAC_MIC_FIELD_SIZE , mic , J_S_INT_KEY ) != SECURE_ELEMENT_SUCCESS ) { return SECURE_ELEMENT_FAIL_CMAC ; } } # endif else { return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION ; } return SECURE_ELEMENT_SUCCESS ; }
","<S2SV_ModStart> { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE
",Lora-net@LoRaMac-node/e3063a91daa7ad8a687223efa63079f0c24568e4,CVE-2020-11068,https://github.com/Lora-net/LoRaMac-node/commit/e3063a91daa7ad8a687223efa63079f0c24568e4,2020-06-23T17:15Z,<S2SV_StartBug> return SECURE_ELEMENT_ERROR_NPE ; <S2SV_EndBug>
7759,CWE-125,"static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/dc317ac9cff859aa84eeabe03fb5004982545b3b,CVE-2019-19275,https://github.com/python/typed_ast/commit/dc317ac9cff859aa84eeabe03fb5004982545b3b,2019-11-26T15:15Z,"<S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug>"
333,CWE-20,"static gboolean is_link_trusted ( NautilusFile * file , gboolean is_launcher ) { GFile * location ; gboolean res ; if ( ! is_launcher ) { return TRUE ; } if ( nautilus_file_can_execute ( file ) ) { return TRUE ; } res = FALSE ; if ( nautilus_file_is_local ( file ) ) { location = nautilus_file_get_location ( file ) ; res = nautilus_is_in_system_dir ( location ) ; g_object_unref ( location ) ; } return res ; }
","<S2SV_ModStart> gboolean res ; g_autofree gchar * trusted = NULL ; <S2SV_ModStart> TRUE ; } trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ; <S2SV_ModStart> ( file ) && trusted != NULL
",GNOME@nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0,CVE-2017-14604,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,2017-09-20T08:29Z,<S2SV_StartBug> if ( ! is_launcher ) <S2SV_EndBug> <S2SV_StartBug> if ( nautilus_file_can_execute ( file ) ) <S2SV_EndBug>
2225,CWE-189,"static int efx_probe_all ( struct efx_nic * efx ) { int rc ; rc = efx_probe_nic ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>NIC\\n"" ) ; goto fail1 ; } rc = efx_probe_port ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>port\\n"" ) ; goto fail2 ; } efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ; rc = efx_probe_channels ( efx ) ; if ( rc ) goto fail3 ; rc = efx_probe_filters ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>filter<S2SV_blank>tables\\n"" ) ; goto fail4 ; } return 0 ; fail4 : efx_remove_channels ( efx ) ; fail3 : efx_remove_port ( efx ) ; fail2 : efx_remove_nic ( efx ) ; fail1 : return rc ; }
","<S2SV_ModStart> fail2 ; } BUILD_BUG_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT ) ; if ( WARN_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT ( efx ) ) ) { rc = - EINVAL ; goto fail3 ; }
",torvalds@linux/68cb695ccecf949d48949e72f8ce591fdaaa325c,CVE-2012-3412,https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c,2012-10-03T11:02Z,<S2SV_StartBug> efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ; <S2SV_EndBug>
2087,CWE-119,"static ssize_t cifs_iovec_write ( struct file * file , const struct iovec * iov , unsigned long nr_segs , loff_t * poffset ) { unsigned long nr_pages , i ; size_t copied , len , cur_len ; ssize_t total_written = 0 ; loff_t offset ; struct iov_iter it ; struct cifsFileInfo * open_file ; struct cifs_tcon * tcon ; struct cifs_sb_info * cifs_sb ; struct cifs_writedata * wdata , * tmp ; struct list_head wdata_list ; int rc ; pid_t pid ; len = iov_length ( iov , nr_segs ) ; if ( ! len ) return 0 ; rc = generic_write_checks ( file , poffset , & len , 0 ) ; if ( rc ) return rc ; INIT_LIST_HEAD ( & wdata_list ) ; cifs_sb = CIFS_SB ( file -> f_path . dentry -> d_sb ) ; open_file = file -> private_data ; tcon = tlink_tcon ( open_file -> tlink ) ; if ( ! tcon -> ses -> server -> ops -> async_writev ) return - ENOSYS ; offset = * poffset ; if ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD ) pid = open_file -> pid ; else pid = current -> tgid ; iov_iter_init ( & it , iov , nr_segs , len , 0 ) ; do { size_t save_len ; nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len ) ; wdata = cifs_writedata_alloc ( nr_pages , cifs_uncached_writev_complete ) ; if ( ! wdata ) { rc = - ENOMEM ; break ; } rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages ) ; if ( rc ) { kfree ( wdata ) ; break ; } save_len = cur_len ; for ( i = 0 ; i < nr_pages ; i ++ ) { copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , 0 , copied ) ; cur_len -= copied ; iov_iter_advance ( & it , copied ) ; } cur_len = save_len - cur_len ; wdata -> sync_mode = WB_SYNC_ALL ; wdata -> nr_pages = nr_pages ; wdata -> offset = ( __u64 ) offset ; wdata -> cfile = cifsFileInfo_get ( open_file ) ; wdata -> pid = pid ; wdata -> bytes = cur_len ; wdata -> pagesz = PAGE_SIZE ; wdata -> tailsz = cur_len - ( ( nr_pages - 1 ) * PAGE_SIZE ) ; rc = cifs_uncached_retry_writev ( wdata ) ; if ( rc ) { kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; break ; } list_add_tail ( & wdata -> list , & wdata_list ) ; offset += cur_len ; len -= cur_len ; } while ( len > 0 ) ; if ( ! list_empty ( & wdata_list ) ) rc = 0 ; restart_loop : list_for_each_entry_safe ( wdata , tmp , & wdata_list , list ) { if ( ! rc ) { rc = wait_for_completion_killable ( & wdata -> done ) ; if ( rc ) rc = - EINTR ; else if ( wdata -> result ) rc = wdata -> result ; else total_written += wdata -> bytes ; if ( rc == - EAGAIN ) { rc = cifs_uncached_retry_writev ( wdata ) ; goto restart_loop ; } } list_del_init ( & wdata -> list ) ; kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; } if ( total_written > 0 ) * poffset += total_written ; cifs_stats_bytes_written ( tcon , total_written ) ; return total_written ? total_written : ( ssize_t ) rc ; }
","<S2SV_ModStart> i ; size_t bytes , <S2SV_ModStart> ++ ) { bytes <S2SV_ModEnd> = min_t ( <S2SV_ModStart> , 0 , bytes <S2SV_ModEnd> ) ; cur_len <S2SV_ModStart> copied ) ; if ( copied < bytes ) break ; <S2SV_ModStart> save_len - cur_len ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] )
",torvalds@linux/5d81de8e8667da7135d3a32a964087c0faf5483f,CVE-2014-0069,https://github.com/torvalds/linux/commit/5d81de8e8667da7135d3a32a964087c0faf5483f,2014-02-28T06:18Z,"<S2SV_StartBug> size_t copied , len , cur_len ; <S2SV_EndBug> <S2SV_StartBug> copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> 0 , copied ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cur_len = save_len - cur_len ; <S2SV_EndBug>"
981,CWE-416,"static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct raw6_sock * rp = raw6_sk ( sk ) ; struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct raw6_frag_vec rfv ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; u16 proto ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( sin6 ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( sin6 -> sin6_family && sin6 -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; proto = ntohs ( sin6 -> sin6_port ) ; if ( ! proto ) proto = inet -> inet_num ; else if ( proto != inet -> inet_num ) return - EINVAL ; if ( proto > 255 ) return - EINVAL ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; proto = inet -> inet_num ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; } if ( ! opt ) opt = np -> opt ; if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = proto ; rfv . msg = msg ; rfv . hlen = 0 ; err = rawv6_probe_proto_opt ( & rfv , & fl6 ) ; if ( err ) goto out ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; if ( inet -> hdrincl ) fl6 . flowi6_flags |= FLOWI_FLAG_KNOWN_NH ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = rawv6_send_hdrinc ( sk , msg , len , & fl6 , & dst , msg -> msg_flags ) ; else { lock_sock ( sk ) ; err = ip6_append_data ( sk , raw6_getfrag , & rfv , len , 0 , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; if ( err ) ip6_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = rawv6_push_pending_frames ( sk , & fl6 , rp ) ; release_sock ( sk ) ; } done : dst_release ( dst ) ; out : fl6_sock_release ( flowlabel ) ; return err < 0 ? err : len ; do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }
","<S2SV_ModStart> len ) { struct ipv6_txoptions * opt_to_free = NULL ; <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> flowlabel ) ; txopt_put ( opt_to_free ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> opt = np -> opt ; <S2SV_EndBug> <S2SV_StartBug> return err < 0 ? err : len ; <S2SV_EndBug>
195,CWE-119,"static Sdb * store_versioninfo_gnu_verneed ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { ut8 * end , * need = NULL ; const char * section_name = """" ; Elf_ ( Shdr ) * link_shdr = NULL ; const char * link_section_name = """" ; Sdb * sdb_vernaux = NULL ; Sdb * sdb_version = NULL ; Sdb * sdb = NULL ; int i , cnt ; if ( ! bin || ! bin -> dynstr ) { return NULL ; } if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return NULL ; } if ( shdr -> sh_size < 1 ) { return NULL ; } sdb = sdb_new0 ( ) ; if ( ! sdb ) { return NULL ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! ( need = ( ut8 * ) calloc ( R_MAX ( 1 , shdr -> sh_size ) , sizeof ( ut8 ) ) ) ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Elf_(Verneed)\\n"" ) ; goto beach ; } end = need + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""num_entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) { goto beach ; } if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) { goto beach ; } i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ; if ( i < 0 ) goto beach ; for ( i = 0 , cnt = 0 ; cnt < shdr -> sh_info ; ++ cnt ) { int j , isum ; ut8 * vstart = need + i ; Elf_ ( Verneed ) vvn = { 0 } ; if ( vstart + sizeof ( Elf_ ( Verneed ) ) > end ) { goto beach ; } Elf_ ( Verneed ) * entry = & vvn ; char key [ 32 ] = { 0 } ; sdb_version = sdb_new0 ( ) ; if ( ! sdb_version ) { goto beach ; } j = 0 ; vvn . vn_version = READ16 ( vstart , j ) vvn . vn_cnt = READ16 ( vstart , j ) vvn . vn_file = READ32 ( vstart , j ) vvn . vn_aux = READ32 ( vstart , j ) vvn . vn_next = READ32 ( vstart , j ) sdb_num_set ( sdb_version , ""vn_version"" , entry -> vn_version , 0 ) ; sdb_num_set ( sdb_version , ""idx"" , i , 0 ) ; if ( entry -> vn_file > bin -> dynstr_size ) { goto beach ; } { char * s = r_str_ndup ( & bin -> dynstr [ entry -> vn_file ] , 16 ) ; sdb_set ( sdb_version , ""file_name"" , s , 0 ) ; free ( s ) ; } sdb_num_set ( sdb_version , ""cnt"" , entry -> vn_cnt , 0 ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux ; for ( j = 0 , isum = i + entry -> vn_aux ; j < entry -> vn_cnt && vstart + sizeof ( Elf_ ( Vernaux ) ) <= end ; ++ j ) { int k ; Elf_ ( Vernaux ) * aux = NULL ; Elf_ ( Vernaux ) vaux = { 0 } ; sdb_vernaux = sdb_new0 ( ) ; if ( ! sdb_vernaux ) { goto beach ; } aux = ( Elf_ ( Vernaux ) * ) & vaux ; k = 0 ; vaux . vna_hash = READ32 ( vstart , k ) vaux . vna_flags = READ16 ( vstart , k ) vaux . vna_other = READ16 ( vstart , k ) vaux . vna_name = READ32 ( vstart , k ) vaux . vna_next = READ32 ( vstart , k ) if ( aux -> vna_name > bin -> dynstr_size ) { goto beach ; } sdb_num_set ( sdb_vernaux , ""idx"" , isum , 0 ) ; if ( aux -> vna_name > 0 && aux -> vna_name + 8 < bin -> dynstr_size ) { char name [ 16 ] ; strncpy ( name , & bin -> dynstr [ aux -> vna_name ] , sizeof ( name ) - 1 ) ; name [ sizeof ( name ) - 1 ] = 0 ; sdb_set ( sdb_vernaux , ""name"" , name , 0 ) ; } sdb_set ( sdb_vernaux , ""flags"" , get_ver_flags ( aux -> vna_flags ) , 0 ) ; sdb_num_set ( sdb_vernaux , ""version"" , aux -> vna_other , 0 ) ; isum += aux -> vna_next ; vstart += aux -> vna_next ; snprintf ( key , sizeof ( key ) , ""vernaux%d"" , j ) ; sdb_ns_set ( sdb_version , key , sdb_vernaux ) ; } if ( ( int ) entry -> vn_next < 0 ) { bprintf ( ""Invalid<S2SV_blank>vn_next\\n"" ) ; break ; } i += entry -> vn_next ; snprintf ( key , sizeof ( key ) , ""version%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_version ) ; if ( ! entry -> vn_next ) { break ; } } free ( need ) ; return sdb ; beach : free ( need ) ; sdb_free ( sdb_vernaux ) ; sdb_free ( sdb_version ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
",radare@radare2/0b973e28166636e0ff1fad80baa0385c9c09c53a,CVE-2017-16357,https://github.com/radare/radare2/commit/0b973e28166636e0ff1fad80baa0385c9c09c53a,2017-11-01T17:29Z,<S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug>
496,CWE-264,"void setattr_copy ( struct inode * inode , const struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; if ( ia_valid & ATTR_ATIME ) inode -> i_atime = timespec_trunc ( attr -> ia_atime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MTIME ) inode -> i_mtime = timespec_trunc ( attr -> ia_mtime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_CTIME ) inode -> i_ctime = timespec_trunc ( attr -> ia_ctime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MODE ) { umode_t mode = attr -> ia_mode ; if ( ! in_group_p ( inode -> i_gid ) && ! inode_capable ( inode , CAP_FSETID ) ) mode &= ~ S_ISGID ; inode -> i_mode = mode ; } }
","<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
",torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03,CVE-2014-4014,https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03,2014-06-23T11:21Z,"<S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug>"
5170,CWE-476,"rfbClientPtr rfbClientIteratorNext ( rfbClientIteratorPtr i ) { if ( i -> next == 0 ) { LOCK ( rfbClientListMutex ) ; i -> next = i -> screen -> clientHead ; UNLOCK ( rfbClientListMutex ) ; } else { rfbClientPtr cl = i -> next ; i -> next = i -> next -> next ; rfbDecrClientRef ( cl ) ; } # if defined ( LIBVNCSERVER_HAVE_LIBPTHREAD ) || defined ( LIBVNCSERVER_HAVE_WIN32THREADS ) if ( ! i -> closedToo ) while ( i -> next && i -> next -> sock < 0 ) i -> next = i -> next -> next ; if ( i -> next ) rfbIncrClientRef ( i -> next ) ; # endif return i -> next ; }
","<S2SV_ModStart> i ) { if ( ! i ) return NULL ;
",LibVNC@libvncserver/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0,CVE-2020-14397,https://github.com/LibVNC/libvncserver/commit/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0,2020-06-17T16:15Z,<S2SV_StartBug> { <S2SV_EndBug>
3212,CWE-125,"static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\n"" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""no<S2SV_blank>material<S2SV_blank>package<S2SV_blank>found\\n"" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , ""material_package_umid"" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , ""material_package_name"" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_package -> tracks_refs [ i ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } if ( ( component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , TimecodeComponent ) ) ) { mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; } } if ( ! ( material_track -> sequence = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence -> structural_components_refs [ j ] , TimecodeComponent ) ; if ( ! component ) continue ; mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; break ; } } if ( material_track -> sequence -> structural_components_count > 1 ) av_log ( mxf -> fc , AV_LOG_WARNING , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>components\\n"" , material_track -> track_id , material_track -> sequence -> structural_components_count ) ; for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_sourceclip ( mxf , & material_track -> sequence -> structural_components_refs [ j ] ) ; if ( ! component ) continue ; source_package = mxf_resolve_source_package ( mxf , component -> source_package_ul , component -> source_package_uid ) ; if ( ! source_package ) { av_log ( mxf -> fc , AV_LOG_TRACE , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>package<S2SV_blank>found\\n"" , material_track -> track_id ) ; continue ; } for ( k = 0 ; k < source_package -> tracks_count ; k ++ ) { if ( ! ( temp_track = mxf_resolve_strong_ref ( mxf , & source_package -> tracks_refs [ k ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( temp_track -> track_id == component -> source_track_id ) { source_track = temp_track ; break ; } } if ( ! source_track ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>track<S2SV_blank>found\\n"" , material_track -> track_id ) ; break ; } for ( k = 0 ; k < mxf -> essence_container_data_count ; k ++ ) { MXFEssenceContainerData * essence_data ; if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) { av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } if ( ! memcmp ( component -> source_package_ul , essence_data -> package_ul , sizeof ( UID ) ) && ! memcmp ( component -> source_package_uid , essence_data -> package_uid , sizeof ( UID ) ) ) { source_track -> body_sid = essence_data -> body_sid ; source_track -> index_sid = essence_data -> index_sid ; break ; } } if ( source_track && component ) break ; } if ( ! source_track || ! component || ! source_package ) { if ( ( ret = mxf_add_metadata_stream ( mxf , material_track ) ) ) goto fail_and_free ; continue ; } if ( ! ( source_track -> sequence = mxf_resolve_strong_ref ( mxf , & source_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( memcmp ( material_track -> sequence -> data_definition_ul , source_track -> sequence -> data_definition_ul , 16 ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>DataDefinition<S2SV_blank>mismatch\\n"" , material_track -> track_id ) ; continue ; } st = avformat_new_stream ( mxf -> fc , NULL ) ; if ( ! st ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>stream\\n"" ) ; ret = AVERROR ( ENOMEM ) ; goto fail_and_free ; } st -> id = material_track -> track_id ; st -> priv_data = source_track ; source_package -> descriptor = mxf_resolve_strong_ref ( mxf , & source_package -> descriptor_ref , AnyType ) ; descriptor = mxf_resolve_multidescriptor ( mxf , source_package -> descriptor , source_track -> track_id ) ; if ( descriptor && descriptor -> duration != AV_NOPTS_VALUE ) source_track -> original_duration = st -> duration = FFMIN ( descriptor -> duration , component -> duration ) ; else source_track -> original_duration = st -> duration = component -> duration ; if ( st -> duration == - 1 ) st -> duration = AV_NOPTS_VALUE ; st -> start_time = component -> start_position ; if ( material_track -> edit_rate . num <= 0 || material_track -> edit_rate . den <= 0 ) { av_log ( mxf -> fc , AV_LOG_WARNING , ""Invalid<S2SV_blank>edit<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>found<S2SV_blank>on<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>"" ""defaulting<S2SV_blank>to<S2SV_blank>25/1\\n"" , material_track -> edit_rate . num , material_track -> edit_rate . den , st -> index ) ; material_track -> edit_rate = ( AVRational ) { 25 , 1 } ; } avpriv_set_pts_info ( st , 64 , material_track -> edit_rate . den , material_track -> edit_rate . num ) ; source_track -> edit_rate = material_track -> edit_rate ; PRINT_KEY ( mxf -> fc , ""data<S2SV_blank>definition<S2SV_blank><S2SV_blank><S2SV_blank>ul"" , source_track -> sequence -> data_definition_ul ) ; codec_ul = mxf_get_codec_ul ( ff_mxf_data_definition_uls , & source_track -> sequence -> data_definition_ul ) ; st -> codecpar -> codec_type = codec_ul -> id ; if ( ! descriptor ) { av_log ( mxf -> fc , AV_LOG_INFO , ""source<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>stream<S2SV_blank>%d,<S2SV_blank>no<S2SV_blank>descriptor<S2SV_blank>found\\n"" , source_track -> track_id , st -> index ) ; continue ; } PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>codec<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ul"" , descriptor -> essence_codec_ul ) ; PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>container<S2SV_blank>ul"" , descriptor -> essence_container_ul ) ; essence_container_ul = & descriptor -> essence_container_ul ; source_track -> wrapping = ( mxf -> op == OPAtom ) ? ClipWrapped : mxf_get_wrapping_kind ( essence_container_ul ) ; if ( source_track -> wrapping == UnknownWrapped ) av_log ( mxf -> fc , AV_LOG_INFO , ""wrapping<S2SV_blank>of<S2SV_blank>stream<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unknown\\n"" , st -> index ) ; if ( IS_KLV_KEY ( essence_container_ul , mxf_encrypted_essence_container ) ) { av_log ( mxf -> fc , AV_LOG_INFO , ""broken<S2SV_blank>encrypted<S2SV_blank>mxf<S2SV_blank>file\\n"" ) ; for ( k = 0 ; k < mxf -> metadata_sets_count ; k ++ ) { MXFMetadataSet * metadata = mxf -> metadata_sets [ k ] ; if ( metadata -> type == CryptoContext ) { essence_container_ul = & ( ( MXFCryptoContext * ) metadata ) -> source_container_ul ; break ; } } } codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) { codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%s:<S2SV_blank>Universal<S2SV_blank>Label:<S2SV_blank>"" , avcodec_get_name ( st -> codecpar -> codec_id ) ) ; for ( k = 0 ; k < 16 ; k ++ ) { av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%.2x"" , descriptor -> essence_codec_ul [ k ] ) ; if ( ! ( k + 1 & 19 ) || k == 5 ) av_log ( mxf -> fc , AV_LOG_VERBOSE , ""."" ) ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""\\n"" ) ; mxf_add_umid_metadata ( & st -> metadata , ""file_package_umid"" , source_package ) ; if ( source_package -> name && source_package -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""file_package_name"" , source_package -> name , 0 ) ; if ( material_track -> name && material_track -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""track_name"" , material_track -> name , 0 ) ; mxf_parse_physical_source_package ( mxf , source_track , st ) ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { source_track -> intra_only = mxf_is_intra_only ( descriptor ) ; container_ul = mxf_get_codec_ul ( mxf_picture_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; st -> codecpar -> width = descriptor -> width ; st -> codecpar -> height = descriptor -> height ; switch ( descriptor -> frame_layout ) { case FullFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; break ; case OneField : av_log ( mxf -> fc , AV_LOG_INFO , ""OneField<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>isn\'t<S2SV_blank>currently<S2SV_blank>supported\\n"" ) ; break ; case MixedFields : break ; case SegmentedFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; case SeparateFields : av_log ( mxf -> fc , AV_LOG_DEBUG , ""video_line_map:<S2SV_blank>(%d,<S2SV_blank>%d),<S2SV_blank>field_dominance:<S2SV_blank>%d\\n"" , descriptor -> video_line_map [ 0 ] , descriptor -> video_line_map [ 1 ] , descriptor -> field_dominance ) ; if ( ( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 ) ) { if ( ( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2 ) { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_TT ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_TB ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } else { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_BB ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_BT ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } } st -> codecpar -> height *= 2 ; break ; default : av_log ( mxf -> fc , AV_LOG_INFO , ""Unknown<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>type:<S2SV_blank>%d\\n"" , descriptor -> frame_layout ) ; } if ( st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO ) { st -> codecpar -> format = descriptor -> pix_fmt ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { pix_fmt_ul = mxf_get_codec_ul ( ff_mxf_pixel_format_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> format = ( enum AVPixelFormat ) pix_fmt_ul -> id ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { st -> codecpar -> codec_tag = mxf_get_codec_ul ( ff_mxf_codec_tag_uls , & descriptor -> essence_codec_ul ) -> id ; if ( ! st -> codecpar -> codec_tag ) { if ( descriptor -> horiz_subsampling == 2 && descriptor -> vert_subsampling == 1 && descriptor -> component_depth == 8 ) { st -> codecpar -> format = AV_PIX_FMT_UYVY422 ; } } } } } st -> need_parsing = AVSTREAM_PARSE_HEADERS ; if ( material_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""material_track_origin"" , material_track -> sequence -> origin , 0 ) ; } if ( source_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""source_track_origin"" , source_track -> sequence -> origin , 0 ) ; } if ( descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den ) st -> display_aspect_ratio = descriptor -> aspect_ratio ; } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { container_ul = mxf_get_codec_ul ( mxf_sound_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE ) ) st -> codecpar -> codec_id = ( enum AVCodecID ) container_ul -> id ; st -> codecpar -> channels = descriptor -> channels ; st -> codecpar -> bits_per_coded_sample = descriptor -> bits_per_sample ; if ( descriptor -> sample_rate . den > 0 ) { st -> codecpar -> sample_rate = descriptor -> sample_rate . num / descriptor -> sample_rate . den ; avpriv_set_pts_info ( st , 64 , descriptor -> sample_rate . den , descriptor -> sample_rate . num ) ; } else { av_log ( mxf -> fc , AV_LOG_WARNING , ""invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>"" ""found<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>time<S2SV_blank>base<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1/48000\\n"" , descriptor -> sample_rate . num , descriptor -> sample_rate . den , st -> index ) ; avpriv_set_pts_info ( st , 64 , 1 , 48000 ) ; } if ( st -> duration != AV_NOPTS_VALUE ) st -> duration = av_rescale_q ( st -> duration , av_inv_q ( material_track -> edit_rate ) , st -> time_base ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24LE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32LE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24BE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32BE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_MP2 ) { st -> need_parsing = AVSTREAM_PARSE_FULL ; } } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) { enum AVMediaType type ; container_ul = mxf_get_codec_ul ( mxf_data_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; type = avcodec_get_type ( st -> codecpar -> codec_id ) ; if ( type == AVMEDIA_TYPE_SUBTITLE ) st -> codecpar -> codec_type = type ; if ( container_ul -> desc ) av_dict_set ( & st -> metadata , ""data_type"" , container_ul -> desc , 0 ) ; } if ( descriptor -> extradata ) { if ( ! ff_alloc_extradata ( st -> codecpar , descriptor -> extradata_size ) ) { memcpy ( st -> codecpar -> extradata , descriptor -> extradata , descriptor -> extradata_size ) ; } } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_H264 ) { int coded_width = mxf_get_codec_ul ( mxf_intra_only_picture_coded_width , & descriptor -> essence_codec_ul ) -> id ; if ( coded_width ) st -> codecpar -> width = coded_width ; ret = ff_generate_avci_extradata ( st ) ; if ( ret < 0 ) return ret ; } if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && source_track -> wrapping != FrameWrapped ) { st -> need_parsing = AVSTREAM_PARSE_TIMESTAMPS ; } } ret = 0 ; fail_and_free : return ret ; }
","<S2SV_ModStart> av_log ( mxf -> fc
",FFmpeg@FFmpeg/bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,CVE-2018-1999014,https://github.com/FFmpeg/FFmpeg/commit/bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,2018-07-23T15:29Z,"<S2SV_StartBug> av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; <S2SV_EndBug>"
1755,CWE-119,"void vp9_copy_and_extend_frame ( const YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst ) { const int et_y = 16 ; const int el_y = 16 ; const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_width , 16 ) ; const int er_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_height , 6 ) - src -> y_height , 16 ) ; const int uv_width_subsampling = ( src -> uv_width != src -> y_width ) ; const int uv_height_subsampling = ( src -> uv_height != src -> y_height ) ; const int et_uv = et_y >> uv_height_subsampling ; const int el_uv = el_y >> uv_width_subsampling ; const int eb_uv = eb_y >> uv_height_subsampling ; const int er_uv = er_y >> uv_width_subsampling ; # if CONFIG_ALPHA const int et_a = dst -> border >> ( dst -> alpha_height != dst -> y_height ) ; const int el_a = dst -> border >> ( dst -> alpha_width != dst -> y_width ) ; const int eb_a = et_a + dst -> alpha_height - src -> alpha_height ; const int er_a = el_a + dst -> alpha_width - src -> alpha_width ; copy_and_extend_plane ( src -> alpha_buffer , src -> alpha_stride , dst -> alpha_buffer , dst -> alpha_stride , src -> alpha_width , src -> alpha_height , et_a , el_a , eb_a , er_a ) ; # endif copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , src -> y_width , src -> y_height , et_y , el_y , eb_y , er_y ) ; copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , src -> uv_width , src -> uv_height , et_uv , el_uv , eb_uv , er_uv ) ; copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , src -> uv_width , src -> uv_height , et_uv , el_uv , eb_uv , er_uv ) ; }
","<S2SV_ModStart> ; const int er_y = MAX ( src -> y_width + 16 , ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) ) - src -> y_crop_width ; const int <S2SV_ModStart> = MAX ( src -> y_height + 16 , <S2SV_ModStart> ( src -> y_height <S2SV_ModEnd> , 6 ) <S2SV_ModStart> , 6 ) ) <S2SV_ModStart> - src -> y_crop_height <S2SV_ModEnd> ; const int <S2SV_ModStart> ; # if CONFIG_VP9_HIGHBITDEPTH if ( src -> flags & YV12_FLAG_HIGHBITDEPTH ) { highbd_copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , src -> y_crop_width , src -> y_crop_height , et_y , el_y , eb_y , er_y ) ; highbd_copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; highbd_copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; return ; } <S2SV_ModEnd> # endif copy_and_extend_plane <S2SV_ModStart> , src -> y_crop_width , src -> y_crop_height <S2SV_ModEnd> , et_y , <S2SV_ModStart> , src -> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> , et_uv , <S2SV_ModStart> , src -> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> , et_uv ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_width , <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> <S2SV_StartBug> src -> y_width , src -> y_height , <S2SV_EndBug> <S2SV_StartBug> src -> uv_width , src -> uv_height , <S2SV_EndBug> <S2SV_StartBug> src -> uv_width , src -> uv_height , <S2SV_EndBug>"
159,CWE-190,"static BOOL gdi_Bitmap_Decompress ( rdpContext * context , rdpBitmap * bitmap , const BYTE * pSrcData , UINT32 DstWidth , UINT32 DstHeight , UINT32 bpp , UINT32 length , BOOL compressed , UINT32 codecId ) { UINT32 SrcSize = length ; rdpGdi * gdi = context -> gdi ; bitmap -> compressed = FALSE ; bitmap -> format = gdi -> dstFormat ; bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ; if ( ! bitmap -> data ) return FALSE ; if ( compressed ) { if ( bpp < 32 ) { if ( ! interleaved_decompress ( context -> codecs -> interleaved , pSrcData , SrcSize , DstWidth , DstHeight , bpp , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , & gdi -> palette ) ) return FALSE ; } else { if ( ! planar_decompress ( context -> codecs -> planar , pSrcData , SrcSize , DstWidth , DstHeight , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , TRUE ) ) return FALSE ; } } else { const UINT32 SrcFormat = gdi_get_pixel_format ( bpp ) ; const size_t sbpp = GetBytesPerPixel ( SrcFormat ) ; const size_t dbpp = GetBytesPerPixel ( bitmap -> format ) ; if ( ( sbpp == 0 ) || ( dbpp == 0 ) ) return FALSE ; else { const size_t dstSize = SrcSize * dbpp / sbpp ; if ( dstSize < bitmap -> length ) return FALSE ; } if ( ! freerdp_image_copy ( bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , pSrcData , SrcFormat , 0 , 0 , 0 , & gdi -> palette , FREERDP_FLIP_VERTICAL ) ) return FALSE ; } return TRUE ; }
","<S2SV_ModStart> -> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> -> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> -> length = size <S2SV_ModEnd> ; bitmap ->
",FreeRDP@FreeRDP/09b9d4f1994a674c4ec85b4947aa656eda1aed8a,CVE-2018-8787,https://github.com/FreeRDP/FreeRDP/commit/09b9d4f1994a674c4ec85b4947aa656eda1aed8a,2018-11-29T18:29Z,<S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug>
8114,CWE-295,"int context_init ( SERVICE_OPTIONS * section ) { # if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> option . client ) section -> ctx = SSL_CTX_new ( TLS_client_method ( ) ) ; else section -> ctx = SSL_CTX_new ( TLS_server_method ( ) ) ; if ( ! SSL_CTX_set_min_proto_version ( section -> ctx , section -> min_proto_version ) ) { s_log ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>the<S2SV_blank>minimum<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>0x%X"" , section -> min_proto_version ) ; return 1 ; } if ( ! SSL_CTX_set_max_proto_version ( section -> ctx , section -> max_proto_version ) ) { s_log ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>0x%X"" , section -> max_proto_version ) ; return 1 ; } # else if ( section -> option . client ) section -> ctx = SSL_CTX_new ( section -> client_method ) ; else section -> ctx = SSL_CTX_new ( section -> server_method ) ; # endif if ( ! section -> ctx ) { sslerror ( ""SSL_CTX_new"" ) ; return 1 ; } if ( ! SSL_CTX_set_ex_data ( section -> ctx , index_ssl_ctx_opt , section ) ) { sslerror ( ""SSL_CTX_set_ex_data"" ) ; return 1 ; } current_section = section ; if ( section -> cipher_list ) { s_log ( LOG_DEBUG , ""Ciphers:<S2SV_blank>%s"" , section -> cipher_list ) ; if ( ! SSL_CTX_set_cipher_list ( section -> ctx , section -> cipher_list ) ) { sslerror ( ""SSL_CTX_set_cipher_list"" ) ; return 1 ; } } # ifndef OPENSSL_NO_TLS1_3 if ( section -> ciphersuites ) { s_log ( LOG_DEBUG , ""TLSv1.3<S2SV_blank>ciphersuites:<S2SV_blank>%s"" , section -> ciphersuites ) ; if ( ! SSL_CTX_set_ciphersuites ( section -> ctx , section -> ciphersuites ) ) { sslerror ( ""SSL_CTX_set_ciphersuites"" ) ; return 1 ; } } # endif SSL_CTX_set_options ( section -> ctx , SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 ) ; # ifdef SSL_OP_NO_COMPRESSION SSL_CTX_clear_options ( section -> ctx , SSL_OP_NO_COMPRESSION ) ; # endif SSL_CTX_set_options ( section -> ctx , ( SSL_OPTIONS_TYPE ) ( section -> ssl_options_set ) ) ; # if OPENSSL_VERSION_NUMBER >= 0x009080dfL SSL_CTX_clear_options ( section -> ctx , ( SSL_OPTIONS_TYPE ) ( section -> ssl_options_clear ) ) ; # endif # if OPENSSL_VERSION_NUMBER >= 0x009080dfL s_log ( LOG_DEBUG , ""TLS<S2SV_blank>options:<S2SV_blank>0x%08lX<S2SV_blank>(+0x%08lX,<S2SV_blank>-0x%08lX)"" , SSL_CTX_get_options ( section -> ctx ) , section -> ssl_options_set , section -> ssl_options_clear ) ; # else s_log ( LOG_DEBUG , ""TLS<S2SV_blank>options:<S2SV_blank>0x%08lX<S2SV_blank>(+0x%08lX)"" , SSL_CTX_get_options ( section -> ctx ) , section -> ssl_options_set ) ; # endif if ( conf_init ( section ) ) return 1 ; # ifdef SSL_MODE_RELEASE_BUFFERS SSL_CTX_set_mode ( section -> ctx , SSL_MODE_ENABLE_PARTIAL_WRITE | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER | SSL_MODE_RELEASE_BUFFERS ) ; # else SSL_CTX_set_mode ( section -> ctx , SSL_MODE_ENABLE_PARTIAL_WRITE | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER ) ; # endif # if OPENSSL_VERSION_NUMBER >= 0x10101000L SSL_CTX_set_session_ticket_cb ( section -> ctx , generate_session_ticket_cb , decrypt_session_ticket_cb , NULL ) ; # endif # if OPENSSL_VERSION_NUMBER >= 0x10000000L if ( ( section -> ticket_key ) && ( section -> ticket_mac ) ) SSL_CTX_set_tlsext_ticket_key_cb ( section -> ctx , ssl_tlsext_ticket_key_cb ) ; # endif if ( ! section -> option . client ) { unsigned servname_len = ( unsigned ) strlen ( section -> servname ) ; if ( servname_len > SSL_MAX_SSL_SESSION_ID_LENGTH ) servname_len = SSL_MAX_SSL_SESSION_ID_LENGTH ; if ( ! SSL_CTX_set_session_id_context ( section -> ctx , ( unsigned char * ) section -> servname , servname_len ) ) { sslerror ( ""SSL_CTX_set_session_id_context"" ) ; return 1 ; } } SSL_CTX_set_session_cache_mode ( section -> ctx , SSL_SESS_CACHE_BOTH | SSL_SESS_CACHE_NO_INTERNAL_STORE ) ; SSL_CTX_sess_set_cache_size ( section -> ctx , section -> session_size ) ; SSL_CTX_set_timeout ( section -> ctx , section -> session_timeout ) ; SSL_CTX_sess_set_new_cb ( section -> ctx , sess_new_cb ) ; SSL_CTX_sess_set_get_cb ( section -> ctx , sess_get_cb ) ; SSL_CTX_sess_set_remove_cb ( section -> ctx , sess_remove_cb ) ; SSL_CTX_set_info_callback ( section -> ctx , info_callback ) ; if ( auth_init ( section ) ) return 1 ; if ( verify_init ( section ) ) return 1 ; if ( ! section -> option . client ) { # ifndef OPENSSL_NO_TLSEXT SSL_CTX_set_tlsext_servername_callback ( section -> ctx , servername_cb ) ; # endif # ifndef OPENSSL_NO_DH dh_init ( section ) ; # endif # ifndef OPENSSL_NO_ECDH ecdh_init ( section ) ; # endif } return 0 ; }
","<S2SV_ModStart> = section ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> security_level >= 0 ) { SSL_CTX_set_security_level ( section -> ctx , section -> security_level ) ; s_log ( LOG_INFO , ""User-specified<S2SV_blank>security<S2SV_blank>level<S2SV_blank>set:<S2SV_blank>%d"" , section -> security_level ) ; } else if ( SSL_CTX_get_security_level ( section -> ctx ) < DEFAULT_SECURITY_LEVEL ) { SSL_CTX_set_security_level ( section -> ctx , DEFAULT_SECURITY_LEVEL ) ; s_log ( LOG_INFO , ""stunnel<S2SV_blank>default<S2SV_blank>security<S2SV_blank>level<S2SV_blank>set:<S2SV_blank>%d"" , DEFAULT_SECURITY_LEVEL ) ; } else { s_log ( LOG_INFO , ""OpenSSL<S2SV_blank>security<S2SV_blank>level<S2SV_blank>is<S2SV_blank>used:<S2SV_blank>%d"" , SSL_CTX_get_security_level ( section -> ctx ) ) ; } # endif <S2SV_ModStart> return 1 ; # ifndef OPENSSL_NO_TLSEXT <S2SV_ModStart> . client ) <S2SV_ModEnd> SSL_CTX_set_tlsext_servername_callback ( section <S2SV_ModStart> ; # endif <S2SV_ModEnd> return 0 ;
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,<S2SV_StartBug> if ( section -> cipher_list ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! section -> option . client ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
3056,CWE-476,"int kvm_vm_ioctl_check_extension ( struct kvm * kvm , long ext ) { int r ; int hv_enabled = kvmppc_hv_ops ? 1 : 0 ; if ( kvm ) { hv_enabled = is_kvmppc_hv_enabled ( kvm ) ; } switch ( ext ) { # ifdef CONFIG_BOOKE case KVM_CAP_PPC_BOOKE_SREGS : case KVM_CAP_PPC_BOOKE_WATCHDOG : case KVM_CAP_PPC_EPR : # else case KVM_CAP_PPC_SEGSTATE : case KVM_CAP_PPC_HIOR : case KVM_CAP_PPC_PAPR : # endif case KVM_CAP_PPC_UNSET_IRQ : case KVM_CAP_PPC_IRQ_LEVEL : case KVM_CAP_ENABLE_CAP : case KVM_CAP_ENABLE_CAP_VM : case KVM_CAP_ONE_REG : case KVM_CAP_IOEVENTFD : case KVM_CAP_DEVICE_CTRL : case KVM_CAP_IMMEDIATE_EXIT : r = 1 ; break ; case KVM_CAP_PPC_PAIRED_SINGLES : case KVM_CAP_PPC_OSI : case KVM_CAP_PPC_GET_PVINFO : # if defined ( CONFIG_KVM_E500V2 ) || defined ( CONFIG_KVM_E500MC ) case KVM_CAP_SW_TLB : # endif r = ! hv_enabled ; break ; # ifdef CONFIG_KVM_MPIC case KVM_CAP_IRQ_MPIC : r = 1 ; break ; # endif # ifdef CONFIG_PPC_BOOK3S_64 case KVM_CAP_SPAPR_TCE : case KVM_CAP_SPAPR_TCE_64 : case KVM_CAP_SPAPR_TCE_VFIO : case KVM_CAP_PPC_RTAS : case KVM_CAP_PPC_FIXUP_HCALL : case KVM_CAP_PPC_ENABLE_HCALL : # ifdef CONFIG_KVM_XICS case KVM_CAP_IRQ_XICS : # endif r = 1 ; break ; case KVM_CAP_PPC_ALLOC_HTAB : r = hv_enabled ; break ; # endif # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_SMT : r = 0 ; if ( kvm ) { if ( kvm -> arch . emul_smt_mode > 1 ) r = kvm -> arch . emul_smt_mode ; else r = kvm -> arch . smt_mode ; } else if ( hv_enabled ) { if ( cpu_has_feature ( CPU_FTR_ARCH_300 ) ) r = 1 ; else r = threads_per_subcore ; } break ; case KVM_CAP_PPC_SMT_POSSIBLE : r = 1 ; if ( hv_enabled ) { if ( ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ) r = ( ( threads_per_subcore << 1 ) - 1 ) ; else r = 8 | 4 | 2 | 1 ; } break ; case KVM_CAP_PPC_RMA : r = 0 ; break ; case KVM_CAP_PPC_HWRNG : r = kvmppc_hwrng_present ( ) ; break ; case KVM_CAP_PPC_MMU_RADIX : r = ! ! ( hv_enabled && radix_enabled ( ) ) ; break ; case KVM_CAP_PPC_MMU_HASH_V3 : r = ! ! ( hv_enabled && ! radix_enabled ( ) && cpu_has_feature ( CPU_FTR_ARCH_300 ) ) ; break ; # endif case KVM_CAP_SYNC_MMU : # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE r = hv_enabled ; # elif defined ( KVM_ARCH_WANT_MMU_NOTIFIER ) r = 1 ; # else r = 0 ; # endif break ; # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_HTAB_FD : r = hv_enabled ; break ; # endif case KVM_CAP_NR_VCPUS : if ( hv_enabled ) r = num_present_cpus ( ) ; else r = num_online_cpus ( ) ; break ; case KVM_CAP_NR_MEMSLOTS : r = KVM_USER_MEM_SLOTS ; break ; case KVM_CAP_MAX_VCPUS : r = KVM_MAX_VCPUS ; break ; # ifdef CONFIG_PPC_BOOK3S_64 case KVM_CAP_PPC_GET_SMMU_INFO : r = 1 ; break ; case KVM_CAP_SPAPR_MULTITCE : r = 1 ; break ; case KVM_CAP_SPAPR_RESIZE_HPT : r = ! ! hv_enabled && ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ; break ; # endif # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_FWNMI : r = hv_enabled ; break ; # endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) && is_kvmppc_hv_enabled ( kvm ) ; break ; default : r = 0 ; break ; } return r ; }
","<S2SV_ModStart> CPU_FTR_TM_COMP ) && hv_enabled <S2SV_ModEnd> ; break ;
",torvalds@linux/ac64115a66c18c01745bbd3c47a36b124e5fd8c0,CVE-2017-15306,https://github.com/torvalds/linux/commit/ac64115a66c18c01745bbd3c47a36b124e5fd8c0,2017-11-06T18:29Z,<S2SV_StartBug> is_kvmppc_hv_enabled ( kvm ) ; <S2SV_EndBug>
7469,CWE-476,"static VTermState * vterm_state_new ( VTerm * vt ) { VTermState * state = vterm_allocator_malloc ( vt , sizeof ( VTermState ) ) ; state -> vt = vt ; state -> rows = vt -> rows ; state -> cols = vt -> cols ; state -> mouse_col = 0 ; state -> mouse_row = 0 ; state -> mouse_buttons = 0 ; state -> mouse_protocol = MOUSE_X10 ; state -> callbacks = NULL ; state -> cbdata = NULL ; vterm_state_newpen ( state ) ; state -> bold_is_highbright = 0 ; return state ; }
","<S2SV_ModStart> VTermState ) ) ; if ( state == NULL ) return NULL
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,"<S2SV_StartBug> VTermState * state = vterm_allocator_malloc ( vt , sizeof ( VTermState ) ) ; <S2SV_EndBug>"
2138,CWE-125,"int main ( int argc , char * argv [ ] ) { libettercap_init ( ) ; ef_globals_alloc ( ) ; select_text_interface ( ) ; libettercap_ui_init ( ) ; fprintf ( stdout , ""\\n"" EC_COLOR_BOLD ""%s<S2SV_blank>%s"" EC_COLOR_END ""<S2SV_blank>copyright<S2SV_blank>%s<S2SV_blank>%s\\n\\n"" , PROGRAM , EC_VERSION , EC_COPYRIGHT , EC_AUTHORS ) ; EF_GBL -> lineno = 1 ; parse_options ( argc , argv ) ; if ( EF_GBL_OPTIONS -> source_file ) { yyin = fopen ( EF_GBL_OPTIONS -> source_file , ""r"" ) ; if ( yyin == NULL ) FATAL_ERROR ( ""Input<S2SV_blank>file<S2SV_blank>not<S2SV_blank>found<S2SV_blank>!"" ) ; } else { FATAL_ERROR ( ""No<S2SV_blank>source<S2SV_blank>file."" ) ; } setbuf ( yyin , NULL ) ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; load_tables ( ) ; load_constants ( ) ; fprintf ( stdout , ""\\n<S2SV_blank>Parsing<S2SV_blank>source<S2SV_blank>file<S2SV_blank>\\\'%s\\\'<S2SV_blank>"" , EF_GBL_OPTIONS -> source_file ) ; fflush ( stdout ) ; ef_debug ( 1 , ""\\n"" ) ; if ( yyparse ( ) == 0 ) fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; else fprintf ( stdout , ""\\n\\nThe<S2SV_blank>script<S2SV_blank>contains<S2SV_blank>errors...\\n\\n"" ) ; if ( write_output ( ) != E_SUCCESS ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ; ef_globals_free ( ) ; return 0 ; }
","<S2SV_ModStart> ] ) { int ret_value = 0 ; <S2SV_ModStart> ""\\n\\nThe<S2SV_blank>script<S2SV_blank>contains<S2SV_blank>errors...\\n\\n"" ) ; ret_value = <S2SV_ModEnd> write_output ( ) <S2SV_ModStart> write_output ( ) ; if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correctly<S2SV_blank>handled."" , EF_GBL_OPTIONS -> output_file ) ; else if ( ret_value == - E_INVALID ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct.<S2SV_blank>"" <S2SV_ModEnd> , EF_GBL_OPTIONS ->
",LocutusOfBorg@ettercap/626dc56686f15f2dda13c48f78c2a666cb6d8506,CVE-2017-6430,https://github.com/LocutusOfBorg/ettercap/commit/626dc56686f15f2dda13c48f78c2a666cb6d8506,2017-03-15T15:59Z,<S2SV_StartBug> libettercap_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( write_output ( ) != E_SUCCESS ) <S2SV_EndBug>
2916,CWE-000,"static struct sk_buff * nf_ct_frag6_reasm ( struct nf_ct_frag6_queue * fq , struct net_device * dev ) { struct sk_buff * fp , * op , * head = fq -> q . fragments ; int payload_len ; fq_kill ( fq ) ; WARN_ON ( head == NULL ) ; WARN_ON ( NFCT_FRAG6_CB ( head ) -> offset != 0 ) ; payload_len = ( ( head -> data - skb_network_header ( head ) ) - sizeof ( struct ipv6hdr ) + fq -> q . len - sizeof ( struct frag_hdr ) ) ; if ( payload_len > IPV6_MAXPLEN ) { pr_debug ( ""payload<S2SV_blank>len<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\n"" ) ; goto out_oversize ; } if ( skb_cloned ( head ) && pskb_expand_head ( head , 0 , 0 , GFP_ATOMIC ) ) { pr_debug ( ""skb<S2SV_blank>is<S2SV_blank>cloned<S2SV_blank>but<S2SV_blank>can\'t<S2SV_blank>expand<S2SV_blank>head"" ) ; goto out_oom ; } if ( skb_has_frags ( head ) ) { struct sk_buff * clone ; int i , plen = 0 ; if ( ( clone = alloc_skb ( 0 , GFP_ATOMIC ) ) == NULL ) { pr_debug ( ""Can\'t<S2SV_blank>alloc<S2SV_blank>skb\\n"" ) ; goto out_oom ; } clone -> next = head -> next ; head -> next = clone ; skb_shinfo ( clone ) -> frag_list = skb_shinfo ( head ) -> frag_list ; skb_frag_list_init ( head ) ; for ( i = 0 ; i < skb_shinfo ( head ) -> nr_frags ; i ++ ) plen += skb_shinfo ( head ) -> frags [ i ] . size ; clone -> len = clone -> data_len = head -> data_len - plen ; head -> data_len -= clone -> len ; head -> len -= clone -> len ; clone -> csum = 0 ; clone -> ip_summed = head -> ip_summed ; NFCT_FRAG6_CB ( clone ) -> orig = NULL ; atomic_add ( clone -> truesize , & nf_init_frags . mem ) ; } skb_network_header ( head ) [ fq -> nhoffset ] = skb_transport_header ( head ) [ 0 ] ; memmove ( head -> head + sizeof ( struct frag_hdr ) , head -> head , ( head -> data - head -> head ) - sizeof ( struct frag_hdr ) ) ; head -> mac_header += sizeof ( struct frag_hdr ) ; head -> network_header += sizeof ( struct frag_hdr ) ; skb_shinfo ( head ) -> frag_list = head -> next ; skb_reset_transport_header ( head ) ; skb_push ( head , head -> data - skb_network_header ( head ) ) ; atomic_sub ( head -> truesize , & nf_init_frags . mem ) ; for ( fp = head -> next ; fp ; fp = fp -> next ) { head -> data_len += fp -> len ; head -> len += fp -> len ; if ( head -> ip_summed != fp -> ip_summed ) head -> ip_summed = CHECKSUM_NONE ; else if ( head -> ip_summed == CHECKSUM_COMPLETE ) head -> csum = csum_add ( head -> csum , fp -> csum ) ; head -> truesize += fp -> truesize ; atomic_sub ( fp -> truesize , & nf_init_frags . mem ) ; } head -> next = NULL ; head -> dev = dev ; head -> tstamp = fq -> q . stamp ; ipv6_hdr ( head ) -> payload_len = htons ( payload_len ) ; if ( head -> ip_summed == CHECKSUM_COMPLETE ) head -> csum = csum_partial ( skb_network_header ( head ) , skb_network_header_len ( head ) , head -> csum ) ; fq -> q . fragments = NULL ; fp = skb_shinfo ( head ) -> frag_list ; if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) fp = fp -> next ; op = NFCT_FRAG6_CB ( head ) -> orig ; for ( ; fp ; fp = fp -> next ) { struct sk_buff * orig = NFCT_FRAG6_CB ( fp ) -> orig ; op -> next = orig ; op = orig ; NFCT_FRAG6_CB ( fp ) -> orig = NULL ; } return head ; out_oversize : if ( net_ratelimit ( ) ) printk ( KERN_DEBUG ""nf_ct_frag6_reasm:<S2SV_blank>payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%d\\n"" , payload_len ) ; goto out_fail ; out_oom : if ( net_ratelimit ( ) ) printk ( KERN_DEBUG ""nf_ct_frag6_reasm:<S2SV_blank>no<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>reassembly\\n"" ) ; out_fail : return NULL ; }
","<S2SV_ModStart> ; if ( fp &&
",torvalds@linux/9e2dcf72023d1447f09c47d77c99b0c49659e5ce,CVE-2012-2744,https://github.com/torvalds/linux/commit/9e2dcf72023d1447f09c47d77c99b0c49659e5ce,2012-08-09T10:29Z,<S2SV_StartBug> if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) <S2SV_EndBug>
1975,CWE-119,"static void svc_log_reset ( SvcContext * svc_ctx ) { SvcInternal * const si = ( SvcInternal * ) svc_ctx -> internal ; si -> message_buffer [ 0 ] = '\\0' ; }
","<S2SV_ModStart> svc_ctx ) { SvcInternal_t <S2SV_ModEnd> * const si <S2SV_ModStart> si = ( SvcInternal_t <S2SV_ModEnd> * ) svc_ctx
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> SvcInternal * const si = ( SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug>
2371,CWE-20,"static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num > chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
","<S2SV_ModStart> if ( chunk_num >= <S2SV_ModEnd> chm -> num_chunks
",kyz@libmspack/72e70a921f0f07fee748aec2274b30784e1d312a,CVE-2018-14680,https://github.com/kyz/libmspack/commit/72e70a921f0f07fee748aec2274b30784e1d312a,2018-07-28T23:29Z,<S2SV_StartBug> if ( chunk_num > chm -> num_chunks ) return NULL ; <S2SV_EndBug>
2278,CWE-119,"static enum led_brightness k90_backlight_get ( struct led_classdev * led_cdev ) { int ret ; struct k90_led * led = container_of ( led_cdev , struct k90_led , cdev ) ; struct device * dev = led -> cdev . dev -> parent ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int brightness ; char data [ 8 ] ; ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n"" , ret ) ; return - EIO ; } brightness = data [ 4 ] ; if ( brightness < 0 || brightness > 3 ) { dev_warn ( dev , ""Read<S2SV_blank>invalid<S2SV_blank>backlight<S2SV_blank>brightness:<S2SV_blank>%02hhx.\\n"" , data [ 4 ] ) ; return - EIO ; } return brightness ; }
","<S2SV_ModStart> brightness ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } brightness <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/6d104af38b570d37aa32a5803b04c354f8ed513d,CVE-2017-5547,https://github.com/torvalds/linux/commit/6d104af38b570d37aa32a5803b04c354f8ed513d,2017-02-06T06:59Z,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
2380,CWE-125,"int main ( int argc , char * argv [ ] ) { FILE * iplist = NULL ; plist_t root_node = NULL ; char * plist_out = NULL ; uint32_t size = 0 ; int read_size = 0 ; char * plist_entire = NULL ; struct stat filestats ; options_t * options = parse_arguments ( argc , argv ) ; if ( ! options ) { print_usage ( argc , argv ) ; return 0 ; } iplist = fopen ( options -> in_file , ""rb"" ) ; if ( ! iplist ) { free ( options ) ; return 1 ; } stat ( options -> in_file , & filestats ) ; plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ; read_size = fread ( plist_entire , sizeof ( char ) , filestats . st_size , iplist ) ; fclose ( iplist ) ; if ( memcmp ( plist_entire , ""bplist00"" , 8 ) == 0 ) { plist_from_bin ( plist_entire , read_size , & root_node ) ; plist_to_xml ( root_node , & plist_out , & size ) ; } else { plist_from_xml ( plist_entire , read_size , & root_node ) ; plist_to_bin ( root_node , & plist_out , & size ) ; } plist_free ( root_node ) ; free ( plist_entire ) ; if ( plist_out ) { if ( options -> out_file != NULL ) { FILE * oplist = fopen ( options -> out_file , ""wb"" ) ; if ( ! oplist ) { free ( options ) ; return 1 ; } fwrite ( plist_out , size , sizeof ( char ) , oplist ) ; fclose ( oplist ) ; } else fwrite ( plist_out , size , sizeof ( char ) , stdout ) ; free ( plist_out ) ; } else printf ( ""ERROR:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>input<S2SV_blank>file.\\n"" ) ; free ( options ) ; return 0 ; }
","<S2SV_ModStart> filestats ) ; if ( filestats . st_size < 8 ) { printf ( ""ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\n"" ) ; return - 1 ; }
",libimobiledevice@libplist/7391a506352c009fe044dead7baad9e22dd279ee,CVE-2017-5545,https://github.com/libimobiledevice/libplist/commit/7391a506352c009fe044dead7baad9e22dd279ee,2017-01-21T01:59Z,"<S2SV_StartBug> stat ( options -> in_file , & filestats ) ; <S2SV_EndBug>"
2758,CWE-000,"struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; bpf_map_inc ( map , true ) ; fdput ( f ) ; return map ; }
","<S2SV_ModStart> return map ; map =
",torvalds@linux/92117d8443bc5afacc8d5ba82e541946310f106e,CVE-2016-4558,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,2016-05-23T10:59Z,"<S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug>"
2241,CWE-119,"static int fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; if ( cc % ( bps * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpAcc"" , ""%s"" , ""cc%(bps*stride))!=0"" ) ; return 0 ; } if ( ! tmp ) return 0 ; while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; # else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; # endif } } _TIFFfree ( tmp ) ; return 1 ; }
","<S2SV_ModStart> uint8 * tmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
",vadz@libtiff/6a984bf7905c6621281588431f384e79d11a2e33,CVE-2016-9535,https://github.com/vadz/libtiff/commit/6a984bf7905c6621281588431f384e79d11a2e33,2016-11-22T19:59Z,<S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug>
4210,CWE-78,"R_API char * r_socket_http_post ( const char * url , const char * data , int * code , int * rlen ) { RSocket * s ; bool ssl = r_str_startswith ( url , ""https://"" ) ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } char * host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; printf ( ""Invalid<S2SV_blank>URI"" ) ; return NULL ; } host += 3 ; char * port = strchr ( host , ':' ) ; if ( ! port ) { port = ( ssl ) ? ""443"" : ""80"" ; } else { * port ++ = 0 ; } char * path = strchr ( host , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { printf ( ""Cannot<S2SV_blank>create<S2SV_blank>socket\\n"" ) ; free ( uri ) ; return NULL ; } if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) { eprintf ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\n"" , host , port ) ; free ( uri ) ; return NULL ; } r_socket_printf ( s , ""POST<S2SV_blank>/%s<S2SV_blank>HTTP/1.0\\r\\n"" ""User-Agent:<S2SV_blank>radare2<S2SV_blank>"" R2_VERSION ""\\r\\n"" ""Accept:<S2SV_blank>*/*\\r\\n"" ""Host:<S2SV_blank>%s\\r\\n"" ""Content-Length:<S2SV_blank>%i\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ""\\r\\n"" , path , host , ( int ) strlen ( data ) ) ; free ( uri ) ; r_socket_write ( s , ( void * ) data , strlen ( data ) ) ; return r_socket_http_answer ( s , code , rlen ) ; }
","<S2SV_ModStart> ) ; return socket_http_answer <S2SV_ModEnd> ( s , <S2SV_ModStart> code , rlen , 0
",radareorg@radare2/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,CVE-2020-15121,https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,2020-07-20T18:15Z,"<S2SV_StartBug> return r_socket_http_answer ( s , code , rlen ) ; <S2SV_EndBug>"
19,CWE-125,"static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) { EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ; switch ( type ) { case EVP_CTRL_INIT : gctx -> key_set = 0 ; gctx -> iv_set = 0 ; gctx -> ivlen = EVP_CIPHER_CTX_iv_length ( c ) ; gctx -> iv = EVP_CIPHER_CTX_iv_noconst ( c ) ; gctx -> taglen = - 1 ; gctx -> iv_gen = 0 ; gctx -> tls_aad_len = - 1 ; return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 ) return 0 ; if ( ( arg > EVP_MAX_IV_LENGTH ) && ( arg > gctx -> ivlen ) ) { if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ; gctx -> iv = OPENSSL_malloc ( arg ) ; if ( gctx -> iv == NULL ) return 0 ; } gctx -> ivlen = arg ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; gctx -> taglen = arg ; return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ; memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ; return 1 ; case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) { memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ; gctx -> iv_gen = 1 ; return 1 ; } if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ; if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ; if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ; gctx -> iv_gen = 1 ; return 1 ; case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ; CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ; if ( arg <= 0 || arg > gctx -> ivlen ) arg = gctx -> ivlen ; memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ; ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ) ; gctx -> iv_set = 1 ; return 1 ; case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ; memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ; CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ; gctx -> iv_set = 1 ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; gctx -> tls_aad_len = arg ; { unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ; len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ; if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) len -= EVP_GCM_TLS_TAG_LEN ; EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ; EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ; } return EVP_GCM_TLS_TAG_LEN ; case EVP_CTRL_COPY : { EVP_CIPHER_CTX * out = ptr ; EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ; if ( gctx -> gcm . key ) { if ( gctx -> gcm . key != & gctx -> ks ) return 0 ; gctx_out -> gcm . key = & gctx_out -> ks ; } if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ; else { gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ; if ( gctx_out -> iv == NULL ) return 0 ; memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ; } return 1 ; } default : return - 1 ; } }
","<S2SV_ModStart> 1 ] ; if ( len < EVP_GCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> c ) ) { if ( len < EVP_GCM_TLS_TAG_LEN ) return 0 ; <S2SV_ModStart> -= EVP_GCM_TLS_TAG_LEN ; }
",openssl@openssl/00d965474b22b54e4275232bc71ee0c699c5cd21,CVE-2017-3731,https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21,2017-05-04T19:29Z,<S2SV_StartBug> len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= EVP_GCM_TLS_TAG_LEN ; <S2SV_EndBug>
5660,CWE-601,"static int oidc_handle_logout ( request_rec * r , oidc_cfg * c , oidc_session_t * session ) { oidc_provider_t * provider = NULL ; char * url = NULL ; oidc_util_get_request_parameter ( r , OIDC_REDIRECT_URI_REQUEST_LOGOUT , & url ) ; oidc_debug ( r , ""enter<S2SV_blank>(url=%s)"" , url ) ; if ( oidc_is_front_channel_logout ( url ) ) { return oidc_handle_logout_request ( r , c , session , url ) ; } else if ( oidc_is_back_channel_logout ( url ) ) { return oidc_handle_logout_backchannel ( r , c ) ; } if ( ( url == NULL ) || ( apr_strnatcmp ( url , """" ) == 0 ) ) { url = c -> default_slo_url ; } else { const char * error_description = NULL ; apr_uri_t uri ; if ( apr_uri_parse ( r -> pool , url , & uri ) != APR_SUCCESS ) { const char * error_description = apr_psprintf ( r -> pool , ""Logout<S2SV_blank>URL<S2SV_blank>malformed:<S2SV_blank>%s"" , url ) ; oidc_error ( r , ""%s"" , error_description ) ; return oidc_util_html_send_error ( r , c -> error_template , ""Malformed<S2SV_blank>URL"" , error_description , HTTP_INTERNAL_SERVER_ERROR ) ; } const char * c_host = oidc_get_current_url_host ( r ) ; if ( ( uri . hostname != NULL ) && ( ( strstr ( c_host , uri . hostname ) == NULL ) || ( strstr ( uri . hostname , c_host ) == NULL ) ) ) { error_description = apr_psprintf ( r -> pool , ""logout<S2SV_blank>value<S2SV_blank>\\""%s\\""<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>the<S2SV_blank>hostname<S2SV_blank>of<S2SV_blank>the<S2SV_blank>current<S2SV_blank>request<S2SV_blank>\\""%s\\"""" , apr_uri_unparse ( r -> pool , & uri , 0 ) , c_host ) ; oidc_error ( r , ""%s"" , error_description ) ; return oidc_util_html_send_error ( r , c -> error_template , ""Invalid<S2SV_blank>Request"" , error_description , HTTP_INTERNAL_SERVER_ERROR ) ; } if ( ( ( strstr ( url , ""\\n"" ) != NULL ) || strstr ( url , ""\\r"" ) != NULL ) ) { error_description = apr_psprintf ( r -> pool , ""logout<S2SV_blank>value<S2SV_blank>\\""%s\\""<S2SV_blank>contains<S2SV_blank>illegal<S2SV_blank>\\""\\n\\""<S2SV_blank>or<S2SV_blank>\\""\\r\\""<S2SV_blank>character(s)"" , url ) ; oidc_error ( r , ""%s"" , error_description ) ; return oidc_util_html_send_error ( r , c -> error_template , ""Invalid<S2SV_blank>Request"" , error_description , HTTP_INTERNAL_SERVER_ERROR ) ; } } oidc_get_provider_from_session ( r , c , session , & provider ) ; if ( ( provider != NULL ) && ( provider -> end_session_endpoint != NULL ) ) { const char * id_token_hint = oidc_session_get_idtoken ( r , session ) ; char * logout_request = apr_pstrdup ( r -> pool , provider -> end_session_endpoint ) ; if ( id_token_hint != NULL ) { logout_request = apr_psprintf ( r -> pool , ""%s%sid_token_hint=%s"" , logout_request , strchr ( logout_request ? logout_request : """" , OIDC_CHAR_QUERY ) != NULL ? OIDC_STR_AMP : OIDC_STR_QUERY , oidc_util_escape_string ( r , id_token_hint ) ) ; } if ( url != NULL ) { logout_request = apr_psprintf ( r -> pool , ""%s%spost_logout_redirect_uri=%s"" , logout_request , strchr ( logout_request ? logout_request : """" , OIDC_CHAR_QUERY ) != NULL ? OIDC_STR_AMP : OIDC_STR_QUERY , oidc_util_escape_string ( r , url ) ) ; } url = logout_request ; } return oidc_handle_logout_request ( r , c , session , url ) ; }
","<S2SV_ModStart> = NULL ; char * error_str = NULL ; char * error_description = NULL ; <S2SV_ModStart> } else { if ( oidc_validate_post_logout_url ( r , url , & error_str , & error_description ) == FALSE ) { <S2SV_ModEnd> return oidc_util_html_send_error ( <S2SV_ModStart> -> error_template , error_str , error_description , HTTP_BAD_REQUEST <S2SV_ModEnd> ) ; }
",zmartzone@mod_auth_openidc/5c15dfb08106c2451c2c44ce7ace6813c216ba75,CVE-2019-14857,https://github.com/zmartzone/mod_auth_openidc/commit/5c15dfb08106c2451c2c44ce7ace6813c216ba75,2019-11-26T12:15Z,"<S2SV_StartBug> oidc_util_get_request_parameter ( r , OIDC_REDIRECT_URI_REQUEST_LOGOUT , & url ) ; <S2SV_EndBug> <S2SV_StartBug> const char * error_description = NULL ; <S2SV_EndBug> <S2SV_StartBug> ""Malformed<S2SV_blank>URL"" , error_description , <S2SV_EndBug>"
7837,CWE-20,"error_t rawSocketSendEthPacket ( Socket * socket , const SocketMsg * message , uint_t flags ) { error_t error ; # if ( ETH_SUPPORT == ENABLED ) size_t length ; NetBuffer * buffer ; NetInterface * interface ; if ( socket -> interface != NULL ) { interface = socket -> interface ; } else { interface = netGetDefaultInterface ( ) ; } interface = nicGetPhysicalInterface ( interface ) ; if ( interface -> nicDriver != NULL && interface -> nicDriver -> type == NIC_TYPE_ETHERNET ) { buffer = netBufferAlloc ( 0 ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; length = message -> length ; error = netBufferAppend ( buffer , message -> data , length ) ; if ( ! error ) { if ( ! interface -> nicDriver -> autoPadding ) { if ( length < ( ETH_MIN_FRAME_SIZE - ETH_CRC_SIZE ) ) { size_t n ; n = ( ETH_MIN_FRAME_SIZE - ETH_CRC_SIZE ) - length ; error = netBufferAppend ( buffer , ethPadding , n ) ; length += n ; } } } if ( ! error ) { if ( ! interface -> nicDriver -> autoCrcCalc ) { uint32_t crc ; crc = ethCalcCrcEx ( buffer , 0 , length ) ; crc = htole32 ( crc ) ; error = netBufferAppend ( buffer , & crc , sizeof ( crc ) ) ; length += sizeof ( crc ) ; } } if ( ! error ) { NetTxAncillary ancillary ; ancillary = NET_DEFAULT_TX_ANCILLARY ; # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) ancillary . port = message -> switchPort ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) ancillary . timestampId = message -> timestampId ; # endif TRACE_DEBUG ( ""Sending<S2SV_blank>raw<S2SV_blank>Ethernet<S2SV_blank>frame<S2SV_blank>(%"" PRIuSIZE ""<S2SV_blank>bytes)...\\r\\n"" , length ) ; error = nicSendPacket ( interface , buffer , 0 , & ancillary ) ; } netBufferFree ( buffer ) ; } else # endif { error = ERROR_INVALID_INTERFACE ; } return error ; }
","<S2SV_ModStart> * interface ; if ( message -> interface != NULL ) { interface = message -> interface ; } else
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> if ( socket -> interface != NULL ) <S2SV_EndBug>
1730,CWE-119,"static void sum_intra_stats ( FRAME_COUNTS * counts , const MODE_INFO * mi ) { const MB_PREDICTION_MODE y_mode = mi -> mbmi . mode ; const MB_PREDICTION_MODE uv_mode = mi -> mbmi . uv_mode ; const BLOCK_SIZE bsize = mi -> mbmi . sb_type ; if ( bsize < BLOCK_8X8 ) { int idx , idy ; const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) ++ counts -> y_mode [ 0 ] [ mi -> bmi [ idy * 2 + idx ] . as_mode ] ; } else { ++ counts -> y_mode [ size_group_lookup [ bsize ] ] [ y_mode ] ; } ++ counts -> uv_mode [ y_mode ] [ uv_mode ] ; }
","<S2SV_ModStart> ) { const PREDICTION_MODE <S2SV_ModEnd> y_mode = mi <S2SV_ModStart> mode ; const PREDICTION_MODE <S2SV_ModEnd> uv_mode = mi
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> const MB_PREDICTION_MODE y_mode = mi -> mbmi . mode ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE uv_mode = mi -> mbmi . uv_mode ; <S2SV_EndBug>
7607,CWE-190,"jas_image_t * jas_image_create0 ( ) { jas_image_t * image ; if ( ! ( image = jas_malloc ( sizeof ( jas_image_t ) ) ) ) { return 0 ; } image -> tlx_ = 0 ; image -> tly_ = 0 ; image -> brx_ = 0 ; image -> bry_ = 0 ; image -> clrspc_ = JAS_CLRSPC_UNKNOWN ; image -> numcmpts_ = 0 ; image -> maxcmpts_ = 0 ; image -> cmpts_ = 0 ; image -> inmem_ = true ; image -> cmprof_ = 0 ; return image ; }
","<S2SV_ModStart> ; image -> <S2SV_ModEnd> cmprof_ = 0
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> image -> inmem_ = true ; <S2SV_EndBug>
3185,CWE-119,"static guint32 parse_wbxml_attribute_list ( proto_tree * tree , tvbuff_t * tvb , guint32 offset , guint32 str_tbl , guint8 level , guint8 * codepage_attr ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; guint32 off = offset ; guint32 len ; guint str_len ; guint32 ent ; guint32 idx ; guint8 peek ; DebugLog ( ( ""parse_wbxml_attr<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , level , offset ) ) ; while ( off < tvb_len ) { peek = tvb_get_guint8 ( tvb , off ) ; DebugLog ( ( ""ATTR:<S2SV_blank>(top<S2SV_blank>of<S2SV_blank>while)<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%3u,<S2SV_blank>peek<S2SV_blank>=<S2SV_blank>0x%02X,<S2SV_blank>"" ""off<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>tvb_len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , peek , off , tvb_len ) ) ; if ( ( peek & 0x3F ) < 5 ) switch ( peek ) { case 0x00 : * codepage_attr = tvb_get_guint8 ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 2 , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>-->%3d<S2SV_blank>"" ""|<S2SV_blank>SWITCH_PAGE<S2SV_blank>(Attr<S2SV_blank>code<S2SV_blank>page)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|"" , * codepage_attr ) ; off += 2 ; break ; case 0x01 : off ++ ; DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; case 0x02 : ent = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>ENTITY<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\'&#%u;\'"" , level , * codepage_attr , Indent ( level ) , ent ) ; off += 1 + len ; break ; case 0x03 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_I<S2SV_blank>(Inline<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x04 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>LITERAL<S2SV_blank>(Literal<S2SV_blank>Attribute)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>%s<%s<S2SV_blank>/>"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0x40 : case 0x41 : case 0x42 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_I_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Inline<S2SV_blank>string<S2SV_blank>extension:<S2SV_blank>\\\'%s\\\')"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x80 : case 0x81 : case 0x82 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_T_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Extension<S2SV_blank>Token,<S2SV_blank>integer<S2SV_blank>value:<S2SV_blank>%u)"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , idx ) ; off += 1 + len ; break ; case 0x83 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_T<S2SV_blank>(Tableref<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0xC0 : case 0xC1 : case 0xC2 : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Single-byte<S2SV_blank>extension)"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) ) ; off ++ ; break ; case 0xC3 : if ( tvb_get_guint8 ( tvb , 0 ) ) { idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len + idx , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>OPAQUE<S2SV_blank>(Opaque<S2SV_blank>data)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>opaque<S2SV_blank>data)"" , level , * codepage_attr , Indent ( level ) , idx ) ; off += 1 + len + idx ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>RESERVED_2<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>"" ""|<S2SV_blank>WBXML<S2SV_blank>1.0<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here."" , level , * codepage_attr ) ; off = tvb_len ; DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; } break ; default : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%-10s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>"" ""|<S2SV_blank>WBXML<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here."" , level , * codepage_attr , val_to_str_ext ( peek , & vals_wbxml1x_global_tokens_ext , ""(unknown<S2SV_blank>0x%x)"" ) ) ; off = tvb_len ; break ; } else { if ( peek & 0x80 ) { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrValue<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%sattrValue_0x%02X"" , level , * codepage_attr , peek & 0x7f , Indent ( level ) , peek ) ; off ++ ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrStart<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>%sattrStart_0x%02X"" , level , * codepage_attr , peek & 0x7f , Indent ( level ) , peek ) ; off ++ ; } } } DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\n"" , level , off - offset ) ) ; return ( off - offset ) ; }
","<S2SV_ModStart> off = offset , last_off <S2SV_ModStart> offset ) ) ; last_off = off <S2SV_ModStart> ; } } if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ;
",wireshark@wireshark/b8e0d416898bb975a02c1b55883342edc5b4c9c0,CVE-2016-5359,https://github.com/wireshark/wireshark/commit/b8e0d416898bb975a02c1b55883342edc5b4c9c0,2016-08-07T16:59Z,"<S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> <S2SV_StartBug> DebugLog ( ( ""parse_wbxml_attr<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , level , offset ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
1984,CWE-119,"vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , vpx_codec_dec_cfg_t * cfg , vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_DECODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_POSTPROC ) && ! ( iface -> caps & VPX_CODEC_CAP_POSTPROC ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) && ! ( iface -> caps & VPX_CODEC_CAP_ERROR_CONCEALMENT ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_INPUT_FRAGMENTS ) && ! ( iface -> caps & VPX_CODEC_CAP_INPUT_FRAGMENTS ) ) res = VPX_CODEC_INCAPABLE ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_DECODER ) ) res = VPX_CODEC_INCAPABLE ; else { memset ( ctx , 0 , sizeof ( * ctx ) ) ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . dec = cfg ; res = VPX_CODEC_OK ; if ( ! ( flags & VPX_CODEC_USE_XMA ) ) { res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; } if ( ctx -> priv ) ctx -> priv -> iface = ctx -> iface ; } } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> * iface , const <S2SV_ModStart> ( flags & <S2SV_ModEnd> VPX_CODEC_USE_POSTPROC ) && <S2SV_ModStart> ; res = <S2SV_ModEnd> ctx -> iface <S2SV_ModStart> ) ; } <S2SV_ModEnd> } return SAVE_STATUS
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_codec_dec_cfg_t * cfg , <S2SV_EndBug> <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> <S2SV_StartBug> res = VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug>"
2324,CWE-190,"static int decode_level3_header ( LHAFileHeader * * header , LHAInputStream * stream ) { unsigned int header_len ; if ( lha_decode_uint16 ( & RAW_DATA ( header , 0 ) ) != 4 ) { return 0 ; } if ( ! extend_raw_data ( header , stream , LEVEL_3_HEADER_LEN - RAW_DATA_LEN ( header ) ) ) { return 0 ; } header_len = lha_decode_uint32 ( & RAW_DATA ( header , 24 ) ) ; if ( header_len > LEVEL_3_MAX_HEADER_LEN ) { return 0 ; } if ( ! extend_raw_data ( header , stream , header_len - RAW_DATA_LEN ( header ) ) ) { return 0 ; } memcpy ( ( * header ) -> compress_method , & RAW_DATA ( header , 2 ) , 5 ) ; ( * header ) -> compress_method [ 5 ] = '\\0' ; ( * header ) -> compressed_length = lha_decode_uint32 ( & RAW_DATA ( header , 7 ) ) ; ( * header ) -> length = lha_decode_uint32 ( & RAW_DATA ( header , 11 ) ) ; ( * header ) -> timestamp = lha_decode_uint32 ( & RAW_DATA ( header , 15 ) ) ; ( * header ) -> crc = lha_decode_uint16 ( & RAW_DATA ( header , 21 ) ) ; ( * header ) -> os_type = RAW_DATA ( header , 23 ) ; if ( ! decode_extended_headers ( header , 28 ) ) { return 0 ; } return 1 ; }
","<S2SV_ModStart> header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header )
",fragglet@lhasa/6fcdb8f1f538b9d63e63a5fa199c5514a15d4564,CVE-2016-2347,https://github.com/fragglet/lhasa/commit/6fcdb8f1f538b9d63e63a5fa199c5514a15d4564,2017-04-21T20:59Z,<S2SV_StartBug> if ( header_len > LEVEL_3_MAX_HEADER_LEN ) { <S2SV_EndBug>
7764,CWE-125,"int PyParser_AddToken ( parser_state * ps , int type , char * str , int lineno , int col_offset , int end_lineno , int end_col_offset , int * expected_ret ) { int ilabel ; int err ; D ( printf ( ""Token<S2SV_blank>%s/\'%s\'<S2SV_blank>...<S2SV_blank>"" , _PyParser_TokenNames [ type ] , str ) ) ; ilabel = classify ( ps , type , str ) ; if ( ilabel < 0 ) return E_SYNTAX ; for ( ; ; ) { dfa * d = ps -> p_stack . s_top -> s_dfa ; state * s = & d -> d_state [ ps -> p_stack . s_top -> s_state ] ; D ( printf ( ""<S2SV_blank>DFA<S2SV_blank>\'%s\',<S2SV_blank>state<S2SV_blank>%d:"" , d -> d_name , ps -> p_stack . s_top -> s_state ) ) ; if ( s -> s_lower <= ilabel && ilabel < s -> s_upper ) { int x = s -> s_accel [ ilabel - s -> s_lower ] ; if ( x != - 1 ) { if ( x & ( 1 << 7 ) ) { int nt = ( x >> 8 ) + NT_OFFSET ; int arrow = x & ( ( 1 << 7 ) - 1 ) ; dfa * d1 = PyGrammar_FindDFA ( ps -> p_grammar , nt ) ; if ( ( err = push ( & ps -> p_stack , nt , d1 , arrow , lineno , col_offset , end_lineno , end_col_offset ) ) > 0 ) { D ( printf ( ""<S2SV_blank>MemError:<S2SV_blank>push\\n"" ) ) ; return err ; } D ( printf ( ""<S2SV_blank>Push<S2SV_blank>...\\n"" ) ) ; continue ; } if ( ( err = shift ( & ps -> p_stack , type , str , x , lineno , col_offset , end_lineno , end_col_offset ) ) > 0 ) { D ( printf ( ""<S2SV_blank>MemError:<S2SV_blank>shift.\\n"" ) ) ; return err ; } D ( printf ( ""<S2SV_blank>Shift.\\n"" ) ) ; while ( s = & d -> d_state [ ps -> p_stack . s_top -> s_state ] , s -> s_accept && s -> s_narcs == 1 ) { D ( printf ( ""<S2SV_blank><S2SV_blank>DFA<S2SV_blank>\'%s\',<S2SV_blank>state<S2SV_blank>%d:<S2SV_blank>"" ""Direct<S2SV_blank>pop.\\n"" , d -> d_name , ps -> p_stack . s_top -> s_state ) ) ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD # if 0 if ( d -> d_name [ 0 ] == 'i' && strcmp ( d -> d_name , ""import_stmt"" ) == 0 ) future_hack ( ps ) ; # endif # endif s_pop ( & ps -> p_stack ) ; if ( s_empty ( & ps -> p_stack ) ) { D ( printf ( ""<S2SV_blank><S2SV_blank>ACCEPT.\\n"" ) ) ; return E_DONE ; } d = ps -> p_stack . s_top -> s_dfa ; } return E_OK ; } } if ( s -> s_accept ) { # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD # if 0 if ( d -> d_name [ 0 ] == 'i' && strcmp ( d -> d_name , ""import_stmt"" ) == 0 ) future_hack ( ps ) ; # endif # endif s_pop ( & ps -> p_stack ) ; D ( printf ( ""<S2SV_blank>Pop<S2SV_blank>...\\n"" ) ) ; if ( s_empty ( & ps -> p_stack ) ) { D ( printf ( ""<S2SV_blank>Error:<S2SV_blank>bottom<S2SV_blank>of<S2SV_blank>stack.\\n"" ) ) ; return E_SYNTAX ; } continue ; } D ( printf ( ""<S2SV_blank>Error.\\n"" ) ) ; if ( expected_ret ) { if ( s -> s_lower == s -> s_upper - 1 ) { * expected_ret = ps -> p_grammar -> g_ll . ll_label [ s -> s_lower ] . lb_type ; } else * expected_ret = - 1 ; } return E_SYNTAX ; } }
","<S2SV_ModStart> dfa * d1 ; if ( nt == func_body_suite && ! ( ps -> p_flags & PyCF_TYPE_COMMENTS ) ) { D ( printf ( ""<S2SV_blank>[switch<S2SV_blank>func_body_suite<S2SV_blank>to<S2SV_blank>suite]"" ) ) ; nt = suite ; } d1 <S2SV_ModStart> ( printf ( ""<S2SV_blank>Push<S2SV_blank>\'%s\'\\n"" , d1 -> d_name <S2SV_ModEnd> ) ) ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> dfa * d1 = PyGrammar_FindDFA ( <S2SV_EndBug> <S2SV_StartBug> D ( printf ( ""<S2SV_blank>Push<S2SV_blank>...\\n"" ) ) ; <S2SV_EndBug>"
7511,CWE-665,"void rfbSendServerCutText ( rfbScreenInfoPtr rfbScreen , char * str , int len ) { rfbClientPtr cl ; rfbServerCutTextMsg sct ; rfbClientIteratorPtr iterator ; iterator = rfbGetClientIterator ( rfbScreen ) ; while ( ( cl = rfbClientIteratorNext ( iterator ) ) != NULL ) { sct . type = rfbServerCutText ; sct . length = Swap32IfLE ( len ) ; LOCK ( cl -> sendMutex ) ; if ( rfbWriteExact ( cl , ( char * ) & sct , sz_rfbServerCutTextMsg ) < 0 ) { rfbLogPerror ( ""rfbSendServerCutText:<S2SV_blank>write"" ) ; rfbCloseClient ( cl ) ; UNLOCK ( cl -> sendMutex ) ; continue ; } if ( rfbWriteExact ( cl , str , len ) < 0 ) { rfbLogPerror ( ""rfbSendServerCutText:<S2SV_blank>write"" ) ; rfbCloseClient ( cl ) ; } UNLOCK ( cl -> sendMutex ) ; rfbStatRecordMessageSent ( cl , rfbServerCutText , sz_rfbServerCutTextMsg + len , sz_rfbServerCutTextMsg + len ) ; } rfbReleaseClientIterator ( iterator ) ; }
","<S2SV_ModStart> rfbClientIteratorPtr iterator ; memset ( ( char * ) & sct , 0 , sizeof ( sct ) ) ;
",LibVNC@libvncserver/d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a,CVE-2019-15681,https://github.com/LibVNC/libvncserver/commit/d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a,2019-10-29T19:15Z,<S2SV_StartBug> iterator = rfbGetClientIterator ( rfbScreen ) ; <S2SV_EndBug>
7453,CWE-125,"static void l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) { const uint16_t * ptr = ( const uint16_t * ) dat ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,"<S2SV_StartBug> l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug>"
23,CWE-200,"static int udf_encode_fh ( struct inode * inode , __u32 * fh , int * lenp , struct inode * parent ) { int len = * lenp ; struct kernel_lb_addr location = UDF_I ( inode ) -> i_location ; struct fid * fid = ( struct fid * ) fh ; int type = FILEID_UDF_WITHOUT_PARENT ; if ( parent && ( len < 5 ) ) { * lenp = 5 ; return 255 ; } else if ( len < 3 ) { * lenp = 3 ; return 255 ; } * lenp = 3 ; fid -> udf . block = location . logicalBlockNum ; fid -> udf . partref = location . partitionReferenceNum ; fid -> udf . generation = inode -> i_generation ; if ( parent ) { location = UDF_I ( parent ) -> i_location ; fid -> udf . parent_block = location . logicalBlockNum ; fid -> udf . parent_partref = location . partitionReferenceNum ; fid -> udf . parent_generation = inode -> i_generation ; * lenp = 5 ; type = FILEID_UDF_WITH_PARENT ; } return type ; }
","<S2SV_ModStart> -> udf . parent_partref = 0 ; fid -> udf .
",torvalds@linux/0143fc5e9f6f5aad4764801015bc8d4b4a278200,CVE-2012-6548,https://github.com/torvalds/linux/commit/0143fc5e9f6f5aad4764801015bc8d4b4a278200,2013-03-15T20:55Z,<S2SV_StartBug> fid -> udf . generation = inode -> i_generation ; <S2SV_EndBug>
3273,CWE-399,"int udp_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , sin , msg -> msg_name ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; } if ( inet -> cmsg_flags ) ip_cmsg_recv_offset ( msg , skb , sizeof ( struct udphdr ) ) ; err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; if ( noblock ) return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
","<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
",torvalds@linux/beb39db59d14990e401e235faf66a6b9b31240b0,CVE-2015-5366,https://github.com/torvalds/linux/commit/beb39db59d14990e401e235faf66a6b9b31240b0,2015-08-31T10:59Z,<S2SV_StartBug> if ( noblock ) <S2SV_EndBug>
7186,CWE-552,"static ssize_t _hostsock_sendto ( oe_fd_t * sock_ , const void * buf , size_t count , int flags , const struct oe_sockaddr * dest_addr , oe_socklen_t addrlen ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_errno = 0 ; if ( ! sock || ( count && ! buf ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_syscall_sendto_ocall ( & ret , sock -> host_fd , buf , count , flags , ( struct oe_sockaddr * ) dest_addr , addrlen ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } done : return ret ; }
","<S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,<S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug>
2557,CWE-19,"int xfs_attr3_leaf_getvalue ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; int valuelen ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; ASSERT ( args -> index < ichdr . count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; ASSERT ( name_loc -> namelen == args -> namelen ) ; ASSERT ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) == 0 ) ; valuelen = be16_to_cpu ( name_loc -> valuelen ) ; if ( args -> flags & ATTR_KERNOVAL ) { args -> valuelen = valuelen ; return 0 ; } if ( args -> valuelen < valuelen ) { args -> valuelen = valuelen ; return XFS_ERROR ( ERANGE ) ; } args -> valuelen = valuelen ; memcpy ( args -> value , & name_loc -> nameval [ args -> namelen ] , valuelen ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; ASSERT ( name_rmt -> namelen == args -> namelen ) ; ASSERT ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) == 0 ) ; valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , valuelen ) ; if ( args -> flags & ATTR_KERNOVAL ) { args -> valuelen = valuelen ; return 0 ; } if ( args -> valuelen < valuelen ) { args -> valuelen = valuelen ; return XFS_ERROR ( ERANGE ) ; } args -> valuelen = valuelen ; } return 0 ; }
","<S2SV_ModStart> 0 ) ; args -> rmtvaluelen <S2SV_ModEnd> = be32_to_cpu ( <S2SV_ModStart> -> i_mount , args -> rmtvaluelen <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return 0 <S2SV_ModStart> -> valuelen < args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return XFS_ERROR <S2SV_ModStart> -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; } return
",torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z,<S2SV_StartBug> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> <S2SV_StartBug> if ( args -> valuelen < valuelen ) { <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug>
2378,CWE-416,"static long do_get_mempolicy ( int * policy , nodemask_t * nmask , unsigned long addr , unsigned long flags ) { int err ; struct mm_struct * mm = current -> mm ; struct vm_area_struct * vma = NULL ; struct mempolicy * pol = current -> mempolicy ; if ( flags & ~ ( unsigned long ) ( MPOL_F_NODE | MPOL_F_ADDR | MPOL_F_MEMS_ALLOWED ) ) return - EINVAL ; if ( flags & MPOL_F_MEMS_ALLOWED ) { if ( flags & ( MPOL_F_NODE | MPOL_F_ADDR ) ) return - EINVAL ; * policy = 0 ; task_lock ( current ) ; * nmask = cpuset_current_mems_allowed ; task_unlock ( current ) ; return 0 ; } if ( flags & MPOL_F_ADDR ) { down_read ( & mm -> mmap_sem ) ; vma = find_vma_intersection ( mm , addr , addr + 1 ) ; if ( ! vma ) { up_read ( & mm -> mmap_sem ) ; return - EFAULT ; } if ( vma -> vm_ops && vma -> vm_ops -> get_policy ) pol = vma -> vm_ops -> get_policy ( vma , addr ) ; else pol = vma -> vm_policy ; } else if ( addr ) return - EINVAL ; if ( ! pol ) pol = & default_policy ; if ( flags & MPOL_F_NODE ) { if ( flags & MPOL_F_ADDR ) { err = lookup_node ( addr ) ; if ( err < 0 ) goto out ; * policy = err ; } else if ( pol == current -> mempolicy && pol -> mode == MPOL_INTERLEAVE ) { * policy = next_node_in ( current -> il_prev , pol -> v . nodes ) ; } else { err = - EINVAL ; goto out ; } } else { * policy = pol == & default_policy ? MPOL_DEFAULT : pol -> mode ; * policy |= ( pol -> flags & MPOL_MODE_FLAGS ) ; } if ( vma ) { up_read ( & current -> mm -> mmap_sem ) ; vma = NULL ; } err = 0 ; if ( nmask ) { if ( mpol_store_user_nodemask ( pol ) ) { * nmask = pol -> w . user_nodemask ; } else { task_lock ( current ) ; get_policy_nodemask ( pol , nmask ) ; task_unlock ( current ) ; } } out : mpol_cond_put ( pol ) ; if ( vma ) up_read ( & current -> mm -> mmap_sem ) ; return err ; }
","<S2SV_ModStart> ) ; } <S2SV_ModEnd> err = 0
",torvalds@linux/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,CVE-2018-10675,https://github.com/torvalds/linux/commit/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,2018-05-02T18:29Z,<S2SV_StartBug> if ( vma ) { <S2SV_EndBug>
6411,CWE-119,"int ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) { UINT8 * ptr ; int framesize ; int c , chunks ; int l , lines ; int i , j , x = 0 , y , ymax ; if ( bytes < 4 ) return 0 ; ptr = buf ; framesize = I32 ( ptr ) ; if ( framesize < I32 ( ptr ) ) return 0 ; if ( I16 ( ptr + 4 ) != 0xF1FA ) { state -> errcode = IMAGING_CODEC_UNKNOWN ; return - 1 ; } chunks = I16 ( ptr + 6 ) ; ptr += 16 ; for ( c = 0 ; c < chunks ; c ++ ) { UINT8 * data = ptr + 6 ; switch ( I16 ( ptr + 4 ) ) { case 4 : case 11 : break ; case 7 : lines = I16 ( data ) ; data += 2 ; for ( l = y = 0 ; l < lines && y < state -> ysize ; l ++ , y ++ ) { UINT8 * buf = ( UINT8 * ) im -> image [ y ] ; int p , packets ; packets = I16 ( data ) ; data += 2 ; while ( packets & 0x8000 ) { if ( packets & 0x4000 ) { y += 65536 - packets ; if ( y >= state -> ysize ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } buf = ( UINT8 * ) im -> image [ y ] ; } else { buf [ state -> xsize - 1 ] = ( UINT8 ) packets ; } packets = I16 ( data ) ; data += 2 ; } for ( p = x = 0 ; p < packets ; p ++ ) { x += data [ 0 ] ; if ( data [ 1 ] >= 128 ) { i = 256 - data [ 1 ] ; if ( x + i + i > state -> xsize ) break ; for ( j = 0 ; j < i ; j ++ ) { buf [ x ++ ] = data [ 2 ] ; buf [ x ++ ] = data [ 3 ] ; } data += 2 + 2 ; } else { i = 2 * ( int ) data [ 1 ] ; if ( x + i > state -> xsize ) break ; memcpy ( buf + x , data + 2 , i ) ; data += 2 + i ; x += i ; } } if ( p < packets ) break ; } if ( l < lines ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } break ; case 12 : y = I16 ( data ) ; ymax = y + I16 ( data + 2 ) ; data += 4 ; for ( ; y < ymax && y < state -> ysize ; y ++ ) { UINT8 * out = ( UINT8 * ) im -> image [ y ] ; int p , packets = * data ++ ; for ( p = x = 0 ; p < packets ; p ++ , x += i ) { x += data [ 0 ] ; if ( data [ 1 ] & 0x80 ) { i = 256 - data [ 1 ] ; if ( x + i > state -> xsize ) break ; memset ( out + x , data [ 2 ] , i ) ; data += 3 ; } else { i = data [ 1 ] ; if ( x + i > state -> xsize ) break ; memcpy ( out + x , data + 2 , i ) ; data += i + 2 ; } } if ( p < packets ) break ; } if ( y < ymax ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } break ; case 13 : for ( y = 0 ; y < state -> ysize ; y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ; break ; case 15 : for ( y = 0 ; y < state -> ysize ; y ++ ) { UINT8 * out = ( UINT8 * ) im -> image [ y ] ; data += 1 ; for ( x = 0 ; x < state -> xsize ; x += i ) { if ( data [ 0 ] & 0x80 ) { i = 256 - data [ 0 ] ; if ( x + i > state -> xsize ) break ; memcpy ( out + x , data + 1 , i ) ; data += i + 1 ; } else { i = data [ 0 ] ; if ( x + i > state -> xsize ) break ; memset ( out + x , data [ 1 ] , i ) ; data += 2 ; } } if ( x != state -> xsize ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } } break ; case 16 : for ( y = 0 ; y < state -> ysize ; y ++ ) { UINT8 * buf = ( UINT8 * ) im -> image [ y ] ; memcpy ( buf + x , data , state -> xsize ) ; data += state -> xsize ; } break ; case 18 : break ; default : state -> errcode = IMAGING_CODEC_UNKNOWN ; return - 1 ; } ptr += I32 ( ptr ) ; } return - 1 ; }
","<S2SV_ModStart> memcpy ( buf <S2SV_ModEnd> , data ,
",python-pillow@Pillow/893a40850c2d5da41537958e40569c029a6e127b,CVE-2016-0775,https://github.com/python-pillow/Pillow/commit/893a40850c2d5da41537958e40569c029a6e127b,2016-04-13T16:59Z,"<S2SV_StartBug> memcpy ( buf + x , data , state -> xsize ) ; <S2SV_EndBug>"
1540,CWE-119,"void vp9_default_coef_probs ( VP9_COMMON * cm ) { vp9_copy ( cm -> fc . coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ; vp9_copy ( cm -> fc . coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ; vp9_copy ( cm -> fc . coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ; vp9_copy ( cm -> fc . coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ; }
","<S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_4X4 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_8X8 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_16X16 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_32X32
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ; <S2SV_EndBug>"
6813,CWE-401,"static int rtl8xxxu_submit_int_urb ( struct ieee80211_hw * hw ) { struct rtl8xxxu_priv * priv = hw -> priv ; struct urb * urb ; u32 val32 ; int ret ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) return - ENOMEM ; usb_fill_int_urb ( urb , priv -> udev , priv -> pipe_interrupt , priv -> int_buf , USB_INTR_CONTENT_LENGTH , rtl8xxxu_int_complete , priv , 1 ) ; usb_anchor_urb ( urb , & priv -> int_anchor ) ; ret = usb_submit_urb ( urb , GFP_KERNEL ) ; if ( ret ) { usb_unanchor_urb ( urb ) ; goto error ; } val32 = rtl8xxxu_read32 ( priv , REG_USB_HIMR ) ; val32 |= USB_HIMR_CPWM ; rtl8xxxu_write32 ( priv , REG_USB_HIMR , val32 ) ; error : return ret ; }
","<S2SV_ModStart> urb ) ; usb_free_urb ( urb ) ;
",torvalds@linux/a2cdd07488e666aa93a49a3fc9c9b1299e27ef3c,CVE-2019-19068,https://github.com/torvalds/linux/commit/a2cdd07488e666aa93a49a3fc9c9b1299e27ef3c,2019-11-18T06:15Z,<S2SV_StartBug> goto error ; <S2SV_EndBug>
3201,CWE-200,"void iov_iter_pipe ( struct iov_iter * i , int direction , struct pipe_inode_info * pipe , size_t count ) { BUG_ON ( direction != ITER_PIPE ) ; i -> type = direction ; i -> pipe = pipe ; i -> idx = ( pipe -> curbuf + pipe -> nrbufs ) & ( pipe -> buffers - 1 ) ; i -> iov_offset = 0 ; i -> count = count ; }
","<S2SV_ModStart> direction != ITER_PIPE ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers
",torvalds@linux/b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb,CVE-2017-5550,https://github.com/torvalds/linux/commit/b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb,2017-02-06T06:59Z,<S2SV_StartBug> BUG_ON ( direction != ITER_PIPE ) ; <S2SV_EndBug>
151,CWE-119,"int mlx4_register_mac ( struct mlx4_dev * dev , u8 port , u64 mac , int * index ) { struct mlx4_mac_table * table = & mlx4_priv ( dev ) -> port [ port ] . mac_table ; int i , err = 0 ; int free = - 1 ; mlx4_dbg ( dev , ""Registering<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n"" , ( unsigned long long ) mac ) ; mutex_lock ( & table -> mutex ) ; for ( i = 0 ; i < MLX4_MAX_MAC_NUM - 1 ; i ++ ) { if ( free < 0 && ! table -> refs [ i ] ) { free = i ; continue ; } if ( mac == ( MLX4_MAC_MASK & be64_to_cpu ( table -> entries [ i ] ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; } } mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n"" , free ) ; if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be64 ( mac | MLX4_MAC_VALID ) ; err = mlx4_set_port_mac_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_err ( dev , ""Failed<S2SV_blank>adding<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n"" , ( unsigned long long ) mac ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
","<S2SV_ModStart> ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ; }
",torvalds@linux/0926f91083f34d047abc74f1ca4fa6a9c161f7db,CVE-2010-5332,https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db,2019-07-27T22:15Z,"<S2SV_StartBug> mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n"" , free ) ; <S2SV_EndBug>"
409,CWE-125,"u_int fr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { int ret ; uint16_t extracted_ethertype ; u_int dlci ; u_int addr_len ; uint16_t nlpid ; u_int hdr_len ; uint8_t flags [ 4 ] ; ret = parse_q922_addr ( ndo , p , & dlci , & addr_len , flags , length ) ; if ( ret == - 1 ) goto trunc ; if ( ret == 0 ) { ND_PRINT ( ( ndo , ""Q.922,<S2SV_blank>invalid<S2SV_blank>address"" ) ) ; return 0 ; } ND_TCHECK ( p [ addr_len ] ) ; if ( length < addr_len + 1 ) goto trunc ; if ( p [ addr_len ] != LLC_UI && dlci != 0 ) { if ( ! ND_TTEST2 ( p [ addr_len ] , 2 ) || length < addr_len + 2 ) { ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ; } else { extracted_ethertype = EXTRACT_16BITS ( p + addr_len ) ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , extracted_ethertype ) ; if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p - addr_len - ETHERTYPE_LEN , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ; else return addr_len + 2 ; } } ND_TCHECK ( p [ addr_len + 1 ] ) ; if ( length < addr_len + 2 ) goto trunc ; if ( p [ addr_len + 1 ] == 0 ) { if ( addr_len != 3 ) ND_PRINT ( ( ndo , ""Pad!<S2SV_blank>"" ) ) ; hdr_len = addr_len + 1 + 1 + 1 ; } else { if ( addr_len == 3 ) ND_PRINT ( ( ndo , ""No<S2SV_blank>pad!<S2SV_blank>"" ) ) ; hdr_len = addr_len + 1 + 1 ; } ND_TCHECK ( p [ hdr_len - 1 ] ) ; if ( length < hdr_len ) goto trunc ; nlpid = p [ hdr_len - 1 ] ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , nlpid ) ; p += hdr_len ; length -= hdr_len ; switch ( nlpid ) { case NLPID_IP : ip_print ( ndo , p , length ) ; break ; case NLPID_IP6 : ip6_print ( ndo , p , length ) ; break ; case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS : isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length , ndo -> ndo_snapend - p , NULL , NULL , 0 ) == 0 ) { if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , hdr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p - hdr_len , length + hdr_len ) ; } break ; case NLPID_Q933 : q933_print ( ndo , p , length ) ; break ; case NLPID_MFR : frf15_print ( ndo , p , length ) ; break ; case NLPID_PPP : ppp_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , addr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_xflag ) ND_DEFAULTPRINT ( p , length ) ; } return hdr_len ; trunc : ND_PRINT ( ( ndo , ""[|fr]"" ) ) ; return 0 ; }
","<S2SV_ModStart> length + 1 ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length <S2SV_ModStart> ndo_snapend - p <S2SV_ModEnd> , NULL ,
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,"<S2SV_StartBug> isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ; <S2SV_EndBug>"
3673,CWE-835,"static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , ""BA"" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ; case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ; default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; * magick = '\\0' ; if ( bmp_info . ba_offset != 0 ) { offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ; if ( ( MagickSizeType ) <S2SV_ModStart> ) break ; offset = ( MagickOffsetType ) <S2SV_ModEnd> bmp_info . ba_offset <S2SV_ModStart> bmp_info . ba_offset ; if ( offset <S2SV_ModStart> != 0 ) if ( <S2SV_ModEnd> ( offset < <S2SV_ModStart> ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> ""ImproperImageHeader"" ) ; * magick = '\\0' ; <S2SV_ModEnd> count = ReadBlob
",ImageMagick@ImageMagick/db0add932fb850d762b02604ca3053b7d7ab6deb,CVE-2018-20467,https://github.com/ImageMagick/ImageMagick/commit/db0add932fb850d762b02604ca3053b7d7ab6deb,2018-12-26T03:29Z,<S2SV_StartBug> if ( bmp_info . number_colors > GetBlobSize ( image ) ) <S2SV_EndBug> <S2SV_StartBug> * magick = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( bmp_info . ba_offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( offset < 0 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
1790,CWE-119,"static void update_mbgraph_mb_stats ( VP9_COMP * cpi , MBGRAPH_MB_STATS * stats , YV12_BUFFER_CONFIG * buf , int mb_y_offset , YV12_BUFFER_CONFIG * golden_ref , int_mv * prev_golden_ref_mv , YV12_BUFFER_CONFIG * alt_ref , int mb_row , int mb_col ) { MACROBLOCK * const x = & cpi -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; int intra_error ; VP9_COMMON * cm = & cpi -> common ; x -> plane [ 0 ] . src . buf = buf -> y_buffer + mb_y_offset ; x -> plane [ 0 ] . src . stride = buf -> y_stride ; xd -> plane [ 0 ] . dst . buf = get_frame_new_buffer ( cm ) -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . dst . stride = get_frame_new_buffer ( cm ) -> y_stride ; intra_error = find_best_16x16_intra ( cpi , & stats -> ref [ INTRA_FRAME ] . m . mode ) ; if ( intra_error <= 0 ) intra_error = 1 ; stats -> ref [ INTRA_FRAME ] . err = intra_error ; if ( golden_ref ) { int g_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = golden_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = golden_ref -> y_stride ; g_motion_error = do_16x16_motion_search ( cpi , prev_golden_ref_mv , & stats -> ref [ GOLDEN_FRAME ] . m . mv , mb_row , mb_col ) ; stats -> ref [ GOLDEN_FRAME ] . err = g_motion_error ; } else { stats -> ref [ GOLDEN_FRAME ] . err = INT_MAX ; stats -> ref [ GOLDEN_FRAME ] . m . mv . as_int = 0 ; } if ( alt_ref ) { int a_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = alt_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = alt_ref -> y_stride ; a_motion_error = do_16x16_zerozero_search ( cpi , & stats -> ref [ ALTREF_FRAME ] . m . mv ) ; stats -> ref [ ALTREF_FRAME ] . err = a_motion_error ; } else { stats -> ref [ ALTREF_FRAME ] . err = INT_MAX ; stats -> ref [ ALTREF_FRAME ] . m . mv . as_int = 0 ; } }
","<S2SV_ModStart> * golden_ref , const MV <S2SV_ModEnd> * prev_golden_ref_mv , <S2SV_ModStart> & cpi -> td .
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int_mv * prev_golden_ref_mv , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug>"
1122,CWE-119,"int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , ""PACK"" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; line += PKT_LEN_SIZE ; if ( len == PKT_LEN_SIZE ) { * head = NULL ; * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ACK"" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""NAK"" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , ""ERR<S2SV_blank>"" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ok"" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ng"" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""unpack"" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line + len ; return ret ; }
","<S2SV_ModStart> return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
",libgit2@libgit2/4ac39c76c0153d1ee6889a0984c39e97731684b2,CVE-2016-10128,https://github.com/libgit2/libgit2/commit/4ac39c76c0153d1ee6889a0984c39e97731684b2,2017-03-24T15:59Z,<S2SV_StartBug> line += PKT_LEN_SIZE ; <S2SV_EndBug>
1020,CWE-284,"int uinput_create ( char * name ) { struct uinput_dev dev ; int fd , x = 0 ; for ( x = 0 ; x < MAX_UINPUT_PATHS ; x ++ ) { fd = open ( uinput_dev_path [ x ] , O_RDWR ) ; if ( fd < 0 ) continue ; break ; } if ( x == MAX_UINPUT_PATHS ) { BTIF_TRACE_ERROR ( ""%s<S2SV_blank>ERROR:<S2SV_blank>uinput<S2SV_blank>device<S2SV_blank>open<S2SV_blank>failed"" , __FUNCTION__ ) ; return - 1 ; } memset ( & dev , 0 , sizeof ( dev ) ) ; if ( name ) strncpy ( dev . name , name , UINPUT_MAX_NAME_SIZE - 1 ) ; dev . id . bustype = BUS_BLUETOOTH ; dev . id . vendor = 0x0000 ; dev . id . product = 0x0000 ; dev . id . version = 0x0000 ; if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) { BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>device<S2SV_blank>information"" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ; ioctl ( fd , UI_SET_EVBIT , EV_REL ) ; ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ; for ( x = 0 ; key_map [ x ] . name != NULL ; x ++ ) ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ; if ( ioctl ( fd , UI_DEV_CREATE , NULL ) < 0 ) { BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>uinput<S2SV_blank>device"" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } return fd ; }
","<S2SV_ModStart> { fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ] , O_RDWR ) <S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> sizeof ( dev ) <S2SV_ModStart> 1 ; } TEMP_FAILURE_RETRY ( <S2SV_ModStart> , EV_KEY ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> ioctl ( fd <S2SV_ModStart> , EV_REL ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> ioctl ( fd <S2SV_ModStart> UI_SET_EVBIT , EV_SYN ) <S2SV_ModStart> x ++ ) TEMP_FAILURE_RETRY ( <S2SV_ModStart> . mapped_id ) ) ; if ( TEMP_FAILURE_RETRY <S2SV_ModEnd> ( ioctl ( <S2SV_ModStart> UI_DEV_CREATE , NULL )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> fd = open ( uinput_dev_path [ x ] , O_RDWR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_REL ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ioctl ( fd , UI_DEV_CREATE , NULL ) < 0 ) { <S2SV_EndBug>"
8159,CWE-119,"static void update_read_synchronize ( rdpUpdate * update , wStream * s ) { WINPR_UNUSED ( update ) ; Stream_Seek_UINT16 ( s ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> update_read_synchronize ( rdpUpdate <S2SV_ModStart> update ) ; return Stream_SafeSeek ( s , 2 <S2SV_ModEnd> ) ; }
",FreeRDP@FreeRDP/ed53cd148f43cbab905eaa0f5308c2bf3c48cc37,CVE-2020-11046,https://github.com/FreeRDP/FreeRDP/commit/ed53cd148f43cbab905eaa0f5308c2bf3c48cc37,2020-05-07T19:15Z,"<S2SV_StartBug> static void update_read_synchronize ( rdpUpdate * update , wStream * s ) <S2SV_EndBug> <S2SV_StartBug> Stream_Seek_UINT16 ( s ) ; <S2SV_EndBug>"
465,CWE-119,"static int decode_unit ( SCPRContext * s , PixelModel * pixel , unsigned step , unsigned * rval ) { GetByteContext * gb = & s -> gb ; RangeCoder * rc = & s -> rc ; unsigned totfr = pixel -> total_freq ; unsigned value , x = 0 , cumfr = 0 , cnt_x = 0 ; int i , j , ret , c , cnt_c ; if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) return ret ; while ( x < 16 ) { cnt_x = pixel -> lookup [ x ] ; if ( value >= cumfr + cnt_x ) cumfr += cnt_x ; else break ; x ++ ; } c = x * 16 ; cnt_c = 0 ; while ( c < 256 ) { cnt_c = pixel -> freq [ c ] ; if ( value >= cumfr + cnt_c ) cumfr += cnt_c ; else break ; c ++ ; } if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) return ret ; pixel -> freq [ c ] = cnt_c + step ; pixel -> lookup [ x ] = cnt_x + step ; totfr += step ; if ( totfr > BOT ) { totfr = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { unsigned nc = ( pixel -> freq [ i ] >> 1 ) + 1 ; pixel -> freq [ i ] = nc ; totfr += nc ; } for ( i = 0 ; i < 16 ; i ++ ) { unsigned sum = 0 ; unsigned i16_17 = i << 4 ; for ( j = 0 ; j < 16 ; j ++ ) sum += pixel -> freq [ i16_17 + j ] ; pixel -> lookup [ i ] = sum ; } } pixel -> total_freq = totfr ; * rval = c & s -> cbits ; return 0 ; }
","<S2SV_ModStart> } if ( x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if (
",FFmpeg@FFmpeg/2171dfae8c065878a2e130390eb78cf2947a5b69,CVE-2017-9995,https://github.com/FFmpeg/FFmpeg/commit/2171dfae8c065878a2e130390eb78cf2947a5b69,2017-06-28T06:29Z,"<S2SV_StartBug> if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) <S2SV_EndBug>"
1891,CWE-119,"void vp9_init_second_pass_spatial_svc ( VP9_COMP * cpi ) { SVC * const svc = & cpi -> svc ; int i ; for ( i = 0 ; i < svc -> number_spatial_layers ; ++ i ) { struct twopass_rc * const twopass = & svc -> layer_context [ i ] . twopass ; svc -> spatial_layer_id = i ; vp9_init_second_pass ( cpi ) ; twopass -> total_stats . spatial_layer_id = i ; twopass -> total_left_stats . spatial_layer_id = i ; } svc -> spatial_layer_id = 0 ; }
","<S2SV_ModStart> i ) { TWO_PASS <S2SV_ModEnd> * const twopass
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> struct twopass_rc * const twopass = & svc -> layer_context [ i ] . twopass ; <S2SV_EndBug>
1528,CWE-119,"static void yuvconfig2image ( vpx_image_t * img , const YV12_BUFFER_CONFIG * yv12 , void * user_priv ) { img -> fmt = VPX_IMG_FMT_I420 ; img -> w = yv12 -> y_stride ; img -> h = ( yv12 -> y_height + 2 * VP8BORDERINPIXELS + 15 ) & ~ 15 ; img -> d_w = yv12 -> y_width ; img -> d_h = yv12 -> y_height ; img -> x_chroma_shift = 1 ; img -> y_chroma_shift = 1 ; img -> planes [ VPX_PLANE_Y ] = yv12 -> y_buffer ; img -> planes [ VPX_PLANE_U ] = yv12 -> u_buffer ; img -> planes [ VPX_PLANE_V ] = yv12 -> v_buffer ; img -> planes [ VPX_PLANE_ALPHA ] = NULL ; img -> stride [ VPX_PLANE_Y ] = yv12 -> y_stride ; img -> stride [ VPX_PLANE_U ] = yv12 -> uv_stride ; img -> stride [ VPX_PLANE_V ] = yv12 -> uv_stride ; img -> stride [ VPX_PLANE_ALPHA ] = yv12 -> y_stride ; img -> bps = 12 ; img -> user_priv = user_priv ; img -> img_data = yv12 -> buffer_alloc ; img -> img_data_owner = 0 ; img -> self_allocd = 0 ; }
","<S2SV_ModStart> ; img -> bit_depth = 8 ; img ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> img -> bps = 12 ; <S2SV_EndBug>
7888,CWE-20,"void ftpServerProcessList ( FtpClientConnection * connection , char_t * param ) { error_t error ; uint_t perm ; if ( ! connection -> userLoggedIn ) { osStrcpy ( connection -> response , ""530<S2SV_blank>Not<S2SV_blank>logged<S2SV_blank>in\\r\\n"" ) ; return ; } while ( * param == '-' ) { while ( * param != '<S2SV_blank>' && * param != '\\0' ) param ++ ; while ( * param == '<S2SV_blank>' ) param ++ ; } if ( * param == '\\0' ) { osStrcpy ( connection -> path , connection -> currentDir ) ; } else { error = ftpServerGetPath ( connection , param , connection -> path , FTP_SERVER_MAX_PATH_LEN ) ; if ( error ) { osStrcpy ( connection -> response , ""501<S2SV_blank>Invalid<S2SV_blank>parameter\\r\\n"" ) ; return ; } } perm = ftpServerGetFilePermissions ( connection , connection -> path ) ; if ( ( perm & FTP_FILE_PERM_READ ) == 0 ) { osStrcpy ( connection -> response , ""550<S2SV_blank>Access<S2SV_blank>denied\\r\\n"" ) ; return ; } connection -> dir = fsOpenDir ( connection -> path ) ; if ( ! connection -> dir ) { osStrcpy ( connection -> response , ""550<S2SV_blank>Directory<S2SV_blank>not<S2SV_blank>found\\r\\n"" ) ; return ; } if ( connection -> passiveMode ) { if ( connection -> dataChannel . state == FTP_CHANNEL_STATE_IDLE ) connection -> dataChannel . state = FTP_CHANNEL_STATE_SEND ; } else { error = ftpServerOpenDataChannel ( connection ) ; if ( error ) { fsCloseDir ( connection -> dir ) ; osStrcpy ( connection -> response , ""450<S2SV_blank>Can\'t<S2SV_blank>open<S2SV_blank>data<S2SV_blank>connection\\r\\n"" ) ; return ; } connection -> dataChannel . state = FTP_CHANNEL_STATE_SEND ; } connection -> bufferLength = 0 ; connection -> bufferPos = 0 ; connection -> controlChannel . state = FTP_CHANNEL_STATE_LIST ; osStrcpy ( connection -> response , ""150<S2SV_blank>Opening<S2SV_blank>data<S2SV_blank>connection\\r\\n"" ) ; }
","<S2SV_ModStart> != '\\0' ) { <S2SV_ModStart> param ++ ; } <S2SV_ModStart> == '<S2SV_blank>' ) { <S2SV_ModStart> param ++ ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> param ++ ; <S2SV_EndBug> <S2SV_StartBug> while ( * param == '<S2SV_blank>' ) <S2SV_EndBug> <S2SV_StartBug> param ++ ; <S2SV_EndBug>
5306,CWE-125,"static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ; if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ; if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || ( datao + 2 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ; if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || ( dataofs + s >= buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }
","<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 12 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> , s )
",libexif@libexif/435e21f05001fb03f9f186fa7cbc69454afd00d1,CVE-2020-13112,https://github.com/libexif/libexif/commit/435e21f05001fb03f9f186fa7cbc69454afd00d1,2020-05-21T16:15Z,"<S2SV_StartBug> if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug>"
948,CWE-772,"static Image * ReadMPCImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char cache_filename [ MaxTextExtent ] , id [ MaxTextExtent ] , keyword [ MaxTextExtent ] , * options ; const unsigned char * p ; GeometryInfo geometry_info ; Image * image ; int c ; LinkedListInfo * profiles ; MagickBooleanType status ; MagickOffsetType offset ; MagickStatusType flags ; register ssize_t i ; size_t depth , length ; ssize_t count ; StringInfo * profile ; unsigned int signature ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( cache_filename , image -> filename , MaxTextExtent ) ; AppendImageFormat ( ""cache"" , cache_filename ) ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } * id = '\\0' ; ( void ) ResetMagickMemory ( keyword , 0 , sizeof ( keyword ) ) ; offset = 0 ; do { profiles = ( LinkedListInfo * ) NULL ; length = MaxTextExtent ; options = AcquireString ( ( char * ) NULL ) ; signature = GetMagickSignature ( ( const StringInfo * ) NULL ) ; image -> depth = 8 ; image -> compression = NoCompression ; while ( ( isgraph ( c ) != MagickFalse ) && ( c != ( int ) ':' ) ) { register char * p ; if ( c == ( int ) '{' ) { char * comment ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '\\\\' ) c = ReadBlobByte ( image ) ; else if ( ( c == EOF ) || ( c == ( int ) '}' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) != MagickFalse ) { length = MaxTextExtent ; p = keyword ; do { if ( c == ( int ) '=' ) break ; if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } while ( c != EOF ) ; * p = '\\0' ; p = options ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; if ( c == ( int ) '=' ) { c = ReadBlobByte ( image ) ; while ( ( c != ( int ) '}' ) && ( c != EOF ) ) { if ( ( size_t ) ( p - options + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; options = ( char * ) ResizeQuantumMemory ( options , length + MaxTextExtent , sizeof ( * options ) ) ; if ( options == ( char * ) NULL ) break ; p = options + strlen ( options ) ; } * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; if ( c == '\\\\' ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '}' ) { * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } } if ( * options != '{' ) if ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) break ; } if ( options == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } * p = '\\0' ; if ( * options == '{' ) ( void ) CopyMagickString ( options , options + 1 , strlen ( options ) ) ; switch ( * keyword ) { case 'b' : case 'B' : { if ( LocaleCompare ( keyword , ""background-color"" ) == 0 ) { ( void ) QueryColorDatabase ( options , & image -> background_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""blue-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . blue_primary . x = geometry_info . rho ; image -> chromaticity . blue_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . blue_primary . y = image -> chromaticity . blue_primary . x ; break ; } if ( LocaleCompare ( keyword , ""border-color"" ) == 0 ) { ( void ) QueryColorDatabase ( options , & image -> border_color , exception ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'c' : case 'C' : { if ( LocaleCompare ( keyword , ""class"" ) == 0 ) { ssize_t storage_class ; storage_class = ParseCommandOption ( MagickClassOptions , MagickFalse , options ) ; if ( storage_class < 0 ) break ; image -> storage_class = ( ClassType ) storage_class ; break ; } if ( LocaleCompare ( keyword , ""colors"" ) == 0 ) { image -> colors = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""colorspace"" ) == 0 ) { ssize_t colorspace ; colorspace = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , options ) ; if ( colorspace < 0 ) break ; image -> colorspace = ( ColorspaceType ) colorspace ; break ; } if ( LocaleCompare ( keyword , ""compression"" ) == 0 ) { ssize_t compression ; compression = ParseCommandOption ( MagickCompressOptions , MagickFalse , options ) ; if ( compression < 0 ) break ; image -> compression = ( CompressionType ) compression ; break ; } if ( LocaleCompare ( keyword , ""columns"" ) == 0 ) { image -> columns = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'd' : case 'D' : { if ( LocaleCompare ( keyword , ""delay"" ) == 0 ) { image -> delay = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""depth"" ) == 0 ) { image -> depth = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""dispose"" ) == 0 ) { ssize_t dispose ; dispose = ParseCommandOption ( MagickDisposeOptions , MagickFalse , options ) ; if ( dispose < 0 ) break ; image -> dispose = ( DisposeType ) dispose ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'e' : case 'E' : { if ( LocaleCompare ( keyword , ""endian"" ) == 0 ) { ssize_t endian ; endian = ParseCommandOption ( MagickEndianOptions , MagickFalse , options ) ; if ( endian < 0 ) break ; image -> endian = ( EndianType ) endian ; break ; } if ( LocaleCompare ( keyword , ""error"" ) == 0 ) { image -> error . mean_error_per_pixel = StringToDouble ( options , ( char * * ) NULL ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'g' : case 'G' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""green-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . green_primary . x = geometry_info . rho ; image -> chromaticity . green_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . green_primary . y = image -> chromaticity . green_primary . x ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'i' : case 'I' : { if ( LocaleCompare ( keyword , ""id"" ) == 0 ) { ( void ) CopyMagickString ( id , options , MaxTextExtent ) ; break ; } if ( LocaleCompare ( keyword , ""iterations"" ) == 0 ) { image -> iterations = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'm' : case 'M' : { if ( LocaleCompare ( keyword , ""magick-signature"" ) == 0 ) { signature = ( unsigned int ) StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""matte"" ) == 0 ) { ssize_t matte ; matte = ParseCommandOption ( MagickBooleanOptions , MagickFalse , options ) ; if ( matte < 0 ) break ; image -> matte = ( MagickBooleanType ) matte ; break ; } if ( LocaleCompare ( keyword , ""matte-color"" ) == 0 ) { ( void ) QueryColorDatabase ( options , & image -> matte_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""maximum-error"" ) == 0 ) { image -> error . normalized_maximum_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""mean-error"" ) == 0 ) { image -> error . normalized_mean_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""montage"" ) == 0 ) { ( void ) CloneString ( & image -> montage , options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'o' : case 'O' : { if ( LocaleCompare ( keyword , ""opaque"" ) == 0 ) { ssize_t matte ; matte = ParseCommandOption ( MagickBooleanOptions , MagickFalse , options ) ; if ( matte < 0 ) break ; image -> matte = ( MagickBooleanType ) matte ; break ; } if ( LocaleCompare ( keyword , ""orientation"" ) == 0 ) { ssize_t orientation ; orientation = ParseCommandOption ( MagickOrientationOptions , MagickFalse , options ) ; if ( orientation < 0 ) break ; image -> orientation = ( OrientationType ) orientation ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'p' : case 'P' : { if ( LocaleCompare ( keyword , ""page"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> page ) ; geometry = DestroyString ( geometry ) ; break ; } if ( LocaleCompare ( keyword , ""pixel-intensity"" ) == 0 ) { ssize_t intensity ; intensity = ParseCommandOption ( MagickPixelIntensityOptions , MagickFalse , options ) ; if ( intensity < 0 ) break ; image -> intensity = ( PixelIntensityMethod ) intensity ; break ; } if ( ( LocaleNCompare ( keyword , ""profile:"" , 8 ) == 0 ) || ( LocaleNCompare ( keyword , ""profile-"" , 8 ) == 0 ) ) { if ( profiles == ( LinkedListInfo * ) NULL ) profiles = NewLinkedList ( 0 ) ; ( void ) AppendValueToLinkedList ( profiles , AcquireString ( keyword + 8 ) ) ; profile = BlobToStringInfo ( ( const void * ) NULL , ( size_t ) StringToLong ( options ) ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProfile ( image , keyword + 8 , profile ) ; profile = DestroyStringInfo ( profile ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'q' : case 'Q' : { if ( LocaleCompare ( keyword , ""quality"" ) == 0 ) { image -> quality = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'r' : case 'R' : { if ( LocaleCompare ( keyword , ""red-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . red_primary . x = geometry_info . rho ; if ( ( flags & SigmaValue ) != 0 ) image -> chromaticity . red_primary . y = geometry_info . sigma ; break ; } if ( LocaleCompare ( keyword , ""rendering-intent"" ) == 0 ) { ssize_t rendering_intent ; rendering_intent = ParseCommandOption ( MagickIntentOptions , MagickFalse , options ) ; if ( rendering_intent < 0 ) break ; image -> rendering_intent = ( RenderingIntent ) rendering_intent ; break ; } if ( LocaleCompare ( keyword , ""resolution"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; break ; } if ( LocaleCompare ( keyword , ""rows"" ) == 0 ) { image -> rows = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 's' : case 'S' : { if ( LocaleCompare ( keyword , ""scene"" ) == 0 ) { image -> scene = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 't' : case 'T' : { if ( LocaleCompare ( keyword , ""ticks-per-second"" ) == 0 ) { image -> ticks_per_second = ( ssize_t ) StringToLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""tile-offset"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> tile_offset ) ; geometry = DestroyString ( geometry ) ; } if ( LocaleCompare ( keyword , ""type"" ) == 0 ) { ssize_t type ; type = ParseCommandOption ( MagickTypeOptions , MagickFalse , options ) ; if ( type < 0 ) break ; image -> type = ( ImageType ) type ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'u' : case 'U' : { if ( LocaleCompare ( keyword , ""units"" ) == 0 ) { ssize_t units ; units = ParseCommandOption ( MagickResolutionOptions , MagickFalse , options ) ; if ( units < 0 ) break ; image -> units = ( ResolutionType ) units ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'w' : case 'W' : { if ( LocaleCompare ( keyword , ""white-point"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . white_point . x = geometry_info . rho ; image -> chromaticity . white_point . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . white_point . y = image -> chromaticity . white_point . x ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } default : { ( void ) SetImageProperty ( image , keyword , options ) ; break ; } } } else c = ReadBlobByte ( image ) ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } options = DestroyString ( options ) ; ( void ) ReadBlobByte ( image ) ; if ( ( LocaleCompare ( id , ""MagickCache"" ) != 0 ) || ( image -> storage_class == UndefinedClass ) || ( image -> compression == UndefinedCompression ) || ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( signature != GetMagickSignature ( ( const StringInfo * ) NULL ) ) ThrowReaderException ( CacheError , ""IncompatibleAPI"" ) ; if ( image -> montage != ( char * ) NULL ) { register char * p ; length = MaxTextExtent ; image -> directory = AcquireString ( ( char * ) NULL ) ; p = image -> directory ; do { * p = '\\0' ; if ( ( strlen ( image -> directory ) + MaxTextExtent ) >= length ) { length <<= 1 ; image -> directory = ( char * ) ResizeQuantumMemory ( image -> directory , length + MaxTextExtent , sizeof ( * image -> directory ) ) ; if ( image -> directory == ( char * ) NULL ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = image -> directory + strlen ( image -> directory ) ; } c = ReadBlobByte ( image ) ; * p ++ = ( char ) c ; } while ( c != ( int ) '\\0' ) ; } if ( profiles != ( LinkedListInfo * ) NULL ) { const char * name ; const StringInfo * profile ; register unsigned char * p ; ResetLinkedListIterator ( profiles ) ; name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; while ( name != ( const char * ) NULL ) { profile = GetImageProfile ( image , name ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; ( void ) ReadBlob ( image , GetStringInfoLength ( profile ) , p ) ; } name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; } profiles = DestroyLinkedList ( profiles , RelinquishMagickMemory ) ; } depth = GetImageQuantumDepth ( image , MagickFalse ) ; if ( image -> storage_class == PseudoClass ) { if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image -> colors != 0 ) { size_t packet_size ; unsigned char * colormap ; packet_size = ( size_t ) ( 3UL * depth / 8UL ) ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , packet_size * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , packet_size * image -> colors , colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = colormap ; switch ( depth ) { default : ThrowReaderException ( CorruptImageError , ""ImageDepthNotSupported"" ) ; case 8 : { unsigned char pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( pixel ) ; } break ; } case 16 : { unsigned short pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleShortToQuantum ( pixel ) ; } break ; } case 32 : { unsigned int pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleLongToQuantum ( pixel ) ; } break ; } } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( CacheError , ""UnableToPersistPixelCache"" ) ; do { c = ReadBlobByte ( image ) ; } while ( ( isgraph ( c ) == MagickFalse ) && ( c != EOF ) ) ; if ( c != EOF ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( c != EOF ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> PseudoClass ) { image -> colormap = ( PixelPacket * ) AcquireQuantumMemory ( <S2SV_ModEnd> image -> colors <S2SV_ModStart> image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelPacket * ) NULL <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> ) break ; if ( ( AcquireMagickResource ( WidthResource <S2SV_ModEnd> , image -> <S2SV_ModStart> image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource <S2SV_ModStart> -> rows ) <S2SV_ModEnd> == MagickFalse ) <S2SV_ModStart> == MagickFalse ) ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" ) ; <S2SV_ModEnd> status = PersistPixelCache
",ImageMagick@ImageMagick/4493d9ca1124564da17f9b628ef9d0f1a6be9738,CVE-2017-5507,https://github.com/ImageMagick/ImageMagick/commit/4493d9ca1124564da17f9b628ef9d0f1a6be9738,2017-03-24T15:59Z,"<S2SV_StartBug> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug>"
1131,CWE-20,"static int ssl_scan_clienthello_tlsext ( SSL * s , PACKET * pkt , int * al ) { unsigned int type ; int renegotiate_seen = 0 ; PACKET extensions ; * al = SSL_AD_DECODE_ERROR ; s -> servername_done = 0 ; s -> tlsext_status_type = - 1 ; # ifndef OPENSSL_NO_NEXTPROTONEG s -> s3 -> next_proto_neg_seen = 0 ; # endif OPENSSL_free ( s -> s3 -> alpn_selected ) ; s -> s3 -> alpn_selected = NULL ; s -> s3 -> alpn_selected_len = 0 ; OPENSSL_free ( s -> s3 -> alpn_proposed ) ; s -> s3 -> alpn_proposed = NULL ; s -> s3 -> alpn_proposed_len = 0 ; # ifndef OPENSSL_NO_HEARTBEATS s -> tlsext_heartbeat &= ~ ( SSL_DTLSEXT_HB_ENABLED | SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ) ; # endif # ifndef OPENSSL_NO_EC if ( s -> options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG ) ssl_check_for_safari ( s , pkt ) ; # endif OPENSSL_free ( s -> s3 -> tmp . peer_sigalgs ) ; s -> s3 -> tmp . peer_sigalgs = NULL ; s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; # ifndef OPENSSL_NO_SRP OPENSSL_free ( s -> srp_ctx . login ) ; s -> srp_ctx . login = NULL ; # endif s -> srtp_profile = NULL ; if ( PACKET_remaining ( pkt ) == 0 ) goto ri_check ; if ( ! PACKET_as_length_prefixed_2 ( pkt , & extensions ) ) return 0 ; if ( ! tls1_check_duplicate_extensions ( & extensions ) ) return 0 ; while ( PACKET_get_net_2 ( & extensions , & type ) ) { PACKET extension ; if ( ! PACKET_get_length_prefixed_2 ( & extensions , & extension ) ) return 0 ; if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 0 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tlsext_debug_arg ) ; if ( type == TLSEXT_TYPE_renegotiate ) { if ( ! ssl_parse_clienthello_renegotiate_ext ( s , & extension , al ) ) return 0 ; renegotiate_seen = 1 ; } else if ( s -> version == SSL3_VERSION ) { } else if ( type == TLSEXT_TYPE_server_name ) { unsigned int servname_type ; PACKET sni , hostname ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & sni ) || PACKET_remaining ( & sni ) == 0 ) { return 0 ; } if ( ! PACKET_get_1 ( & sni , & servname_type ) || servname_type != TLSEXT_NAMETYPE_host_name || ! PACKET_as_length_prefixed_2 ( & sni , & hostname ) ) { return 0 ; } if ( ! s -> hit ) { if ( PACKET_remaining ( & hostname ) > TLSEXT_MAXLEN_host_name ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if ( PACKET_contains_zero_byte ( & hostname ) ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if ( ! PACKET_strndup ( & hostname , & s -> session -> tlsext_hostname ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } s -> servername_done = 1 ; } else { s -> servername_done = s -> session -> tlsext_hostname && PACKET_equal ( & hostname , s -> session -> tlsext_hostname , strlen ( s -> session -> tlsext_hostname ) ) ; } } # ifndef OPENSSL_NO_SRP else if ( type == TLSEXT_TYPE_srp ) { PACKET srp_I ; if ( ! PACKET_as_length_prefixed_1 ( & extension , & srp_I ) ) return 0 ; if ( PACKET_contains_zero_byte ( & srp_I ) ) return 0 ; if ( ! PACKET_strndup ( & srp_I , & s -> srp_ctx . login ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } # endif # ifndef OPENSSL_NO_EC else if ( type == TLSEXT_TYPE_ec_point_formats ) { PACKET ec_point_format_list ; if ( ! PACKET_as_length_prefixed_1 ( & extension , & ec_point_format_list ) || PACKET_remaining ( & ec_point_format_list ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! PACKET_memdup ( & ec_point_format_list , & s -> session -> tlsext_ecpointformatlist , & s -> session -> tlsext_ecpointformatlist_length ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } } else if ( type == TLSEXT_TYPE_elliptic_curves ) { PACKET elliptic_curve_list ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & elliptic_curve_list ) || PACKET_remaining ( & elliptic_curve_list ) == 0 || ( PACKET_remaining ( & elliptic_curve_list ) % 2 ) != 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! PACKET_memdup ( & elliptic_curve_list , & s -> session -> tlsext_ellipticcurvelist , & s -> session -> tlsext_ellipticcurvelist_length ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } } # endif else if ( type == TLSEXT_TYPE_session_ticket ) { if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tls_session_ticket_ext_cb_arg ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } else if ( type == TLSEXT_TYPE_signature_algorithms ) { PACKET supported_sig_algs ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & supported_sig_algs ) || ( PACKET_remaining ( & supported_sig_algs ) % 2 ) != 0 || PACKET_remaining ( & supported_sig_algs ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! tls1_save_sigalgs ( s , PACKET_data ( & supported_sig_algs ) , PACKET_remaining ( & supported_sig_algs ) ) ) { return 0 ; } } } else if ( type == TLSEXT_TYPE_status_request ) { if ( ! PACKET_get_1 ( & extension , ( unsigned int * ) & s -> tlsext_status_type ) ) { return 0 ; } # ifndef OPENSSL_NO_OCSP if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp ) { const unsigned char * ext_data ; PACKET responder_id_list , exts ; if ( ! PACKET_get_length_prefixed_2 ( & extension , & responder_id_list ) ) return 0 ; sk_OCSP_RESPID_pop_free ( s -> tlsext_ocsp_ids , OCSP_RESPID_free ) ; if ( PACKET_remaining ( & responder_id_list ) > 0 ) { s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ; if ( s -> tlsext_ocsp_ids == NULL ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } else { s -> tlsext_ocsp_ids = NULL ; } while ( PACKET_remaining ( & responder_id_list ) > 0 ) { OCSP_RESPID * id ; PACKET responder_id ; const unsigned char * id_data ; if ( ! PACKET_get_length_prefixed_2 ( & responder_id_list , & responder_id ) || PACKET_remaining ( & responder_id ) == 0 ) { return 0 ; } id_data = PACKET_data ( & responder_id ) ; id = d2i_OCSP_RESPID ( NULL , & id_data , PACKET_remaining ( & responder_id ) ) ; if ( id == NULL ) return 0 ; if ( id_data != PACKET_end ( & responder_id ) ) { OCSP_RESPID_free ( id ) ; return 0 ; } if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) ) { OCSP_RESPID_free ( id ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } if ( ! PACKET_as_length_prefixed_2 ( & extension , & exts ) ) return 0 ; if ( PACKET_remaining ( & exts ) > 0 ) { ext_data = PACKET_data ( & exts ) ; sk_X509_EXTENSION_pop_free ( s -> tlsext_ocsp_exts , X509_EXTENSION_free ) ; s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & ext_data , PACKET_remaining ( & exts ) ) ; if ( s -> tlsext_ocsp_exts == NULL || ext_data != PACKET_end ( & exts ) ) { return 0 ; } } } else # endif { s -> tlsext_status_type = - 1 ; } } # ifndef OPENSSL_NO_HEARTBEATS else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_heartbeat ) { unsigned int hbtype ; if ( ! PACKET_get_1 ( & extension , & hbtype ) || PACKET_remaining ( & extension ) ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } switch ( hbtype ) { case 0x01 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; break ; case 0x02 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ; break ; default : * al = SSL_AD_ILLEGAL_PARAMETER ; return 0 ; } } # endif # ifndef OPENSSL_NO_NEXTPROTONEG else if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) { s -> s3 -> next_proto_neg_seen = 1 ; } # endif else if ( type == TLSEXT_TYPE_application_layer_protocol_negotiation && s -> s3 -> tmp . finish_md_len == 0 ) { if ( ! tls1_alpn_handle_client_hello ( s , & extension , al ) ) return 0 ; } # ifndef OPENSSL_NO_SRTP else if ( SSL_IS_DTLS ( s ) && SSL_get_srtp_profiles ( s ) && type == TLSEXT_TYPE_use_srtp ) { if ( ssl_parse_clienthello_use_srtp_ext ( s , & extension , al ) ) return 0 ; } # endif else if ( type == TLSEXT_TYPE_encrypt_then_mac ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; else if ( ! s -> hit ) { if ( custom_ext_parse ( s , 1 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , al ) <= 0 ) return 0 ; } } if ( PACKET_remaining ( pkt ) != 0 ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } ri_check : if ( ! renegotiate_seen && s -> renegotiate && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) { * al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT , SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED ) ; return 0 ; } return 1 ; }
","<S2SV_ModStart> ; s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; # ifndef <S2SV_ModStart> ) s -> tlsext_use_etm = 1 <S2SV_ModEnd> ; else if
",openssl@openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,CVE-2017-3733,https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,2017-05-04T19:29Z,<S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug>
950,CWE-000,"void xmlParseElement ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; const xmlChar * prefix = NULL ; const xmlChar * URI = NULL ; xmlParserNodeInfo node_info ; int line , tlen ; xmlNodePtr ret ; int nsNr = ctxt -> nsNr ; if ( ( ( unsigned int ) ctxt -> nameNr > xmlParserMaxDepth ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) { xmlFatalErrMsgInt ( ctxt , XML_ERR_INTERNAL_ERROR , ""Excessive<S2SV_blank>depth<S2SV_blank>in<S2SV_blank>document:<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>XML_PARSE_HUGE<S2SV_blank>option\\n"" , xmlParserMaxDepth ) ; ctxt -> instate = XML_PARSER_EOF ; return ; } if ( ctxt -> record_info ) { node_info . begin_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . begin_line = ctxt -> input -> line ; } if ( ctxt -> spaceNr == 0 ) spacePush ( ctxt , - 1 ) ; else if ( * ctxt -> space == - 2 ) spacePush ( ctxt , - 1 ) ; else spacePush ( ctxt , * ctxt -> space ) ; line = ctxt -> input -> line ; # ifdef LIBXML_SAX1_ENABLED if ( ctxt -> sax2 ) # endif name = xmlParseStartTag2 ( ctxt , & prefix , & URI , & tlen ) ; # ifdef LIBXML_SAX1_ENABLED else name = xmlParseStartTag ( ctxt ) ; # endif if ( name == NULL ) { spacePop ( ctxt ) ; return ; } namePush ( ctxt , name ) ; ret = ctxt -> node ; # ifdef LIBXML_VALID_ENABLED if ( ctxt -> validate && ctxt -> wellFormed && ctxt -> myDoc && ctxt -> node && ( ctxt -> node == ctxt -> myDoc -> children ) ) ctxt -> valid &= xmlValidateRoot ( & ctxt -> vctxt , ctxt -> myDoc ) ; # endif if ( ( RAW == '/' ) && ( NXT ( 1 ) == '>' ) ) { SKIP ( 2 ) ; if ( ctxt -> sax2 ) { if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> endElementNs != NULL ) && ( ! ctxt -> disableSAX ) ) ctxt -> sax -> endElementNs ( ctxt -> userData , name , prefix , URI ) ; # ifdef LIBXML_SAX1_ENABLED } else { if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> endElement != NULL ) && ( ! ctxt -> disableSAX ) ) ctxt -> sax -> endElement ( ctxt -> userData , name ) ; # endif } namePop ( ctxt ) ; spacePop ( ctxt ) ; if ( nsNr != ctxt -> nsNr ) nsPop ( ctxt , ctxt -> nsNr - nsNr ) ; if ( ret != NULL && ctxt -> record_info ) { node_info . end_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . end_line = ctxt -> input -> line ; node_info . node = ret ; xmlParserAddNodeInfo ( ctxt , & node_info ) ; } return ; } if ( RAW == '>' ) { NEXT1 ; } else { xmlFatalErrMsgStrIntStr ( ctxt , XML_ERR_GT_REQUIRED , ""Couldn\'t<S2SV_blank>find<S2SV_blank>end<S2SV_blank>of<S2SV_blank>Start<S2SV_blank>Tag<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d\\n"" , name , line , NULL ) ; nodePop ( ctxt ) ; namePop ( ctxt ) ; spacePop ( ctxt ) ; if ( nsNr != ctxt -> nsNr ) nsPop ( ctxt , ctxt -> nsNr - nsNr ) ; if ( ret != NULL && ctxt -> record_info ) { node_info . end_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . end_line = ctxt -> input -> line ; node_info . node = ret ; xmlParserAddNodeInfo ( ctxt , & node_info ) ; } return ; } xmlParseContent ( ctxt ) ; if ( ! IS_BYTE_CHAR ( RAW ) ) { xmlFatalErrMsgStrIntStr ( ctxt , XML_ERR_TAG_NOT_FINISHED , ""Premature<S2SV_blank>end<S2SV_blank>of<S2SV_blank>data<S2SV_blank>in<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d\\n"" , name , line , NULL ) ; nodePop ( ctxt ) ; namePop ( ctxt ) ; spacePop ( ctxt ) ; if ( nsNr != ctxt -> nsNr ) nsPop ( ctxt , ctxt -> nsNr - nsNr ) ; return ; } if ( ctxt -> sax2 ) { xmlParseEndTag2 ( ctxt , prefix , URI , line , ctxt -> nsNr - nsNr , tlen ) ; namePop ( ctxt ) ; } # ifdef LIBXML_SAX1_ENABLED else xmlParseEndTag1 ( ctxt , line ) ; # endif if ( ret != NULL && ctxt -> record_info ) { node_info . end_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . end_line = ctxt -> input -> line ; node_info . node = ret ; xmlParserAddNodeInfo ( ctxt , & node_info ) ; } }
","<S2SV_ModStart> endif if ( ctxt -> instate == XML_PARSER_EOF ) return ; if (
",chromium@chromium/44a637b47793512bfb1d2589d43b8dc492a97629,,https://github.com/chromium/chromium/commit/44a637b47793512bfb1d2589d43b8dc492a97629, ,<S2SV_StartBug> if ( name == NULL ) { <S2SV_EndBug>
2539,CWE-285,"static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) { struct Client * agent_p = NULL ; struct Client * saslserv_p = NULL ; if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ; if ( strlen ( client_p -> id ) == 3 ) { exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ; return 0 ; } saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ; if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) { sendto_one ( source_p , form_str ( ERR_SASLABORTED ) , me . name , EmptyString ( source_p -> name ) ? ""*"" : source_p -> name ) ; return 0 ; } if ( source_p -> localClient -> sasl_complete ) { * source_p -> localClient -> sasl_agent = '\\0' ; source_p -> localClient -> sasl_complete = 0 ; } if ( strlen ( parv [ 1 ] ) > 400 ) { sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? ""*"" : source_p -> name ) ; return 0 ; } if ( ! * source_p -> id ) { strcpy ( source_p -> id , generate_uid ( ) ) ; add_to_id_hash ( source_p -> id , source_p ) ; } if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ; if ( agent_p == NULL ) { sendto_one ( saslserv_p , "":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>H<S2SV_blank>%s<S2SV_blank>%s"" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , source_p -> host , source_p -> sockhost ) ; if ( ! strcmp ( parv [ 1 ] , ""EXTERNAL"" ) && source_p -> certfp != NULL ) sendto_one ( saslserv_p , "":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>%s"" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] , source_p -> certfp ) ; else sendto_one ( saslserv_p , "":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>S<S2SV_blank>%s"" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] ) ; rb_strlcpy ( source_p -> localClient -> sasl_agent , saslserv_p -> id , IDLEN ) ; } else sendto_one ( agent_p , "":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>C<S2SV_blank>%s"" , me . id , agent_p -> servptr -> name , source_p -> id , agent_p -> id , parv [ 1 ] ) ; source_p -> localClient -> sasl_out ++ ; return 0 ; }
","<S2SV_ModStart> client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { exit_client ( client_p , client_p , client_p , ""Malformed<S2SV_blank>AUTHENTICATE""
",charybdis-ircd@charybdis/818a3fda944b26d4814132cee14cfda4ea4aa824,CVE-2016-7143,https://github.com/charybdis-ircd/charybdis/commit/818a3fda944b26d4814132cee14cfda4ea4aa824,2016-09-21T14:25Z,"<S2SV_StartBug> exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ; <S2SV_EndBug>"
6555,CWE-119,"static char * print_number ( cJSON * item ) { char * str ; double f , f2 ; int64_t i ; str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) { f = item -> valuefloat ; i = f ; f2 = i ; if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint <= LLONG_MAX ) sprintf ( str , ""%lld"" , ( long long ) item -> valueint ) ; else sprintf ( str , ""%g"" , item -> valuefloat ) ; } return str ; }
","<S2SV_ModStart> cJSON * item , printbuffer * p ) { char * str = 0 ; double d <S2SV_ModEnd> = item -> <S2SV_ModStart> = item -> valuedouble ; if ( d == 0 ) { if ( p ) str = ensure ( p , 2 ) ; else str = ( char * ) cJSON_malloc ( 2 ) ; if ( str ) strcpy ( str , ""0"" ) ; } else if ( fabs ( ( ( double ) <S2SV_ModEnd> item -> valueint <S2SV_ModStart> item -> valueint ) - d ) <= DBL_EPSILON && d <= LLONG_MAX && d >= LLONG_MIN ) { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) sprintf ( str , ""%lld"" , ( long long ) <S2SV_ModEnd> item -> valueint <S2SV_ModStart> item -> valueint ) ; } else { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) { if ( fpclassify ( d ) != FP_ZERO && ! isnormal ( d ) ) sprintf ( str , ""null"" ) ; else if ( fabs ( floor ( d ) - d ) <= DBL_EPSILON && fabs ( d ) < 1.0e60 ) sprintf ( str , ""%.0f"" , d ) ; else if ( fabs ( d ) < 1.0e-6 || fabs ( d ) > 1.0e9 ) sprintf ( str , ""%e"" , d ) ; else sprintf ( str , ""%f"" , d ) ; } <S2SV_ModEnd> } return str
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,<S2SV_StartBug> static char * print_number ( cJSON * item ) <S2SV_EndBug> <S2SV_StartBug> f = item -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint <= LLONG_MAX ) <S2SV_EndBug>
2290,CWE-362,"void sock_release ( struct socket * sock ) { if ( sock -> ops ) { struct module * owner = sock -> ops -> owner ; sock -> ops -> release ( sock ) ; sock -> ops = NULL ; module_put ( owner ) ; } if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) pr_err ( ""%s:<S2SV_blank>fasync<S2SV_blank>list<S2SV_blank>not<S2SV_blank>empty!\\n"" , __func__ ) ; if ( ! sock -> file ) { iput ( SOCK_INODE ( sock ) ) ; return ; } sock -> file = NULL ; }
","<S2SV_ModStart> sock ) { __sock_release ( sock , NULL <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/6d8c50dcb029872b298eea68cc6209c866fd3e14,CVE-2018-12232,https://github.com/torvalds/linux/commit/6d8c50dcb029872b298eea68cc6209c866fd3e14,2018-06-12T12:29Z,"<S2SV_StartBug> if ( sock -> ops ) { <S2SV_EndBug> <S2SV_StartBug> if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) <S2SV_EndBug>"
3260,CWE-264,"static int save_new_data ( struct chfn_control * ctl ) { char * gecos ; int len ; len = xasprintf ( & gecos , ""%s,%s,%s,%s,%s"" , ctl -> newf . full_name , ctl -> newf . office , ctl -> newf . office_phone , ctl -> newf . home_phone , ctl -> newf . other ) ; if ( ! ctl -> newf . other ) { while ( len > 0 && gecos [ len - 1 ] == ',' ) len -- ; gecos [ len ] = 0 ; } # ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chfn"" , ctl -> username , ctl -> pw -> pw_uid , LU_GECOS , gecos ) < 0 ) { # else ctl -> pw -> pw_gecos = gecos ; if ( setpwnam ( ctl -> pw ) < 0 ) { warn ( ""setpwnam<S2SV_blank>failed"" ) ; # endif printf ( _ ( ""Finger<S2SV_blank>information<S2SV_blank>*NOT*<S2SV_blank>changed.<S2SV_blank><S2SV_blank>Try<S2SV_blank>again<S2SV_blank>later.\\n"" ) ) ; return - 1 ; } free ( gecos ) ; printf ( _ ( ""Finger<S2SV_blank>information<S2SV_blank>changed.\\n"" ) ) ; return 0 ; }
","<S2SV_ModStart> ctl -> pw , "".chfn""
",karelzak@util-linux/bde91c85bdc77975155058276f99d2e0f5eab5a9,CVE-2015-5224,https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9,2017-08-23T15:29Z,<S2SV_StartBug> if ( setpwnam ( ctl -> pw ) < 0 ) { <S2SV_EndBug>
3189,CWE-125,"static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , ""(pad1)"" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(padn:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(padn)"" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , ""(altcoa:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , ""(auth:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(auth)"" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)"" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(type-0x%02x:<S2SV_blank>len=%u)"" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }
","<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;
",the-tcpdump-group@tcpdump/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,CVE-2017-13023,https://github.com/the-tcpdump-group/tcpdump/commit/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,2017-09-14T06:29Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , <S2SV_EndBug>"
1577,CWE-119,"static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , MB_PREDICTION_MODE mode , TX_SIZE tx_size , int up_available , int left_available , int right_available , int x , int y , int plane ) { int i ; DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ; DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ; uint8_t * above_row = above_data + 16 ; const uint8_t * const_above_row = above_row ; const int bs = 4 << tx_size ; int frame_width , frame_height ; int x0 , y0 ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; once ( init_intra_pred_fn_ptrs ) ; if ( plane == 0 ) { frame_width = xd -> cur_buf -> y_width ; frame_height = xd -> cur_buf -> y_height ; } else { frame_width = xd -> cur_buf -> uv_width ; frame_height = xd -> cur_buf -> uv_height ; } x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ; y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ; vpx_memset ( left_col , 129 , 64 ) ; if ( left_available ) { if ( xd -> mb_to_bottom_edge < 0 ) { if ( y0 + bs <= frame_height ) { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } else { const int extend_bottom = frame_height - y0 ; for ( i = 0 ; i < extend_bottom ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; for ( ; i < bs ; ++ i ) left_col [ i ] = ref [ ( extend_bottom - 1 ) * ref_stride - 1 ] ; } } else { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } } if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { if ( x0 + 2 * bs <= frame_width ) { if ( right_available && bs == 4 ) { vpx_memcpy ( above_row , above_ref , 2 * bs ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { if ( bs == 4 && right_available && left_available ) { const_above_row = above_ref ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; if ( bs == 4 && right_available ) vpx_memcpy ( above_row + bs , above_ref + bs , bs ) ; else vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } } } else { vpx_memset ( above_row , 127 , bs * 2 ) ; above_row [ - 1 ] = 127 ; } if ( mode == DC_PRED ) { dc_pred [ left_available ] [ up_available ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } else { pred [ mode ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } }
","<S2SV_ModStart> int dst_stride , PREDICTION_MODE <S2SV_ModEnd> mode , TX_SIZE <S2SV_ModStart> int i ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> uint8_t , left_col [ 32 ] ) ; DECLARE_ALIGNED ( 16 , uint8_t , above_data [ 64 + 16 ] <S2SV_ModEnd> ) ; uint8_t <S2SV_ModStart> plane ] ; <S2SV_ModEnd> if ( plane <S2SV_ModStart> + y ; if ( extend_modes [ mode ] & NEED_LEFT ) { <S2SV_ModEnd> if ( left_available <S2SV_ModStart> ; } } else { memset ( left_col , 129 , bs ) ; } } if ( extend_modes [ mode ] & NEED_ABOVE ) { <S2SV_ModStart> ( x0 + <S2SV_ModEnd> bs <= frame_width <S2SV_ModStart> frame_width ) { memcpy ( above_row , above_ref , bs ) ; } else if ( x0 <S2SV_ModEnd> <= frame_width ) <S2SV_ModStart> - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + bs - frame_width ) ; } <S2SV_ModEnd> } else { <S2SV_ModStart> } else { memcpy ( above_row , above_ref , bs ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { memset ( above_row , 127 , bs ) ; above_row [ - 1 ] = 127 ; } } if ( extend_modes [ mode ] & NEED_ABOVERIGHT ) { if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { if ( x0 + 2 * bs <= frame_width ) { if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , 2 * bs ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } else { <S2SV_ModEnd> if ( bs <S2SV_ModStart> 4 && right_available && left_available ) { const_above_row = above_ref ; } else { memcpy ( above_row , above_ref , bs ) ; if ( bs == 4 && right_available ) memcpy ( above_row + bs , above_ref + bs , bs ) ; else memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } <S2SV_ModEnd> above_row [ - <S2SV_ModStart> 129 ; } else { memset <S2SV_ModEnd> ( above_row , <S2SV_ModStart> = 127 ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> MB_PREDICTION_MODE mode , TX_SIZE tx_size , <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ; <S2SV_EndBug> <S2SV_StartBug> once ( init_intra_pred_fn_ptrs ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( left_col , 129 , 64 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( x0 + 2 * bs <= frame_width ) { <S2SV_EndBug> <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( above_row , above_ref , bs ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bs == 4 && right_available ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> above_row [ - 1 ] = 127 ; <S2SV_EndBug>"
3517,CWE-787,"void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) { nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ; if ( context -> ChromaSubsamplingLevel ) { nsc_encode_subsampling ( context ) ; } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nsc_encode ( NSC_CONTEXT <S2SV_ModStart> rowstride ) { if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! <S2SV_ModStart> , rowstride ) ) return FALSE <S2SV_ModStart> ChromaSubsamplingLevel ) { if ( ! <S2SV_ModStart> ( context ) ) return FALSE ; } return TRUE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,"<S2SV_StartBug> void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) <S2SV_EndBug> <S2SV_StartBug> nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ; <S2SV_EndBug> <S2SV_StartBug> nsc_encode_subsampling ( context ) ; <S2SV_EndBug>"
547,CWE-20,"static void ikev2_parent_inI1outR1_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct ke_continuation * ke = ( struct ke_continuation * ) pcrc ; struct msg_digest * md = ke -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2<S2SV_blank>parent<S2SV_blank>inI1outR1:<S2SV_blank>calculated<S2SV_blank>ke+nonce,<S2SV_blank>sending<S2SV_blank>R1"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state"" , __FUNCTION__ ) ; if ( ke -> md ) release_md ( ke -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == ke -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI1outR1_tail ( pcrc , r ) ; if ( ke -> md != NULL ) { complete_v2_state_transition ( & ke -> md , e ) ; if ( ke -> md ) release_md ( ke -> md ) ; } reset_globals ( ) ; passert ( GLOBALS_ARE_RESET ( ) ) ; }
","<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",libreswan@libreswan/2899351224fe2940aec37d7656e1e392c0fe07f0,CVE-2013-7294,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,2014-01-16T05:05Z,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug>
7365,CWE-352,"static boolean_t is_authenticated ( HttpRequest req , HttpResponse res ) { if ( Run . httpd . credentials ) { if ( ! basic_authenticate ( req ) ) { send_error ( req , res , SC_UNAUTHORIZED , ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>access<S2SV_blank>monit.<S2SV_blank>Either<S2SV_blank>you<S2SV_blank>supplied<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>credentials<S2SV_blank>(e.g.<S2SV_blank>bad<S2SV_blank>password),<S2SV_blank>or<S2SV_blank>your<S2SV_blank>browser<S2SV_blank>doesn\'t<S2SV_blank>understand<S2SV_blank>how<S2SV_blank>to<S2SV_blank>supply<S2SV_blank>the<S2SV_blank>credentials<S2SV_blank>required"" ) ; set_header ( res , ""WWW-Authenticate"" , ""Basic<S2SV_blank>realm=\\""monit\\"""" ) ; return false ; } } return true ; }
","<S2SV_ModStart> ; } } if ( IS ( req -> method , METHOD_POST ) ) { const char * cookie = get_header ( req , ""Cookie"" ) ; const char * token = get_parameter ( req , ""securitytoken"" ) ; if ( ! cookie ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>cookie\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( ! token ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>parameter\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( ! Str_startsWith ( cookie , ""securitytoken="" ) ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>no<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>cookie\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( Str_compareConstantTime ( cookie + 14 , token ) ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>mismatch\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } }
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,<S2SV_StartBug> return true ; <S2SV_EndBug>
909,CWE-399,"struct scm_fp_list * scm_fp_dup ( struct scm_fp_list * fpl ) { struct scm_fp_list * new_fpl ; int i ; if ( ! fpl ) return NULL ; new_fpl = kmemdup ( fpl , offsetof ( struct scm_fp_list , fp [ fpl -> count ] ) , GFP_KERNEL ) ; if ( new_fpl ) { for ( i = 0 ; i < fpl -> count ; i ++ ) get_file ( fpl -> fp [ i ] ) ; new_fpl -> max = new_fpl -> count ; } return new_fpl ; }
","<S2SV_ModStart> -> count ; new_fpl -> user = get_uid ( fpl -> user ) ;
",torvalds@linux/415e3d3e90ce9e18727e8843ae343eda5a58fad6,CVE-2016-2550,https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6,2016-04-27T17:59Z,<S2SV_StartBug> } <S2SV_EndBug>
1004,CWE-284,"static void btif_dm_upstreams_evt ( UINT16 event , char * p_param ) { tBTA_DM_SEC * p_data = ( tBTA_DM_SEC * ) p_param ; tBTA_SERVICE_MASK service_mask ; uint32_t i ; bt_bdaddr_t bd_addr ; BTIF_TRACE_EVENT ( ""btif_dm_upstreams_cback<S2SV_blank><S2SV_blank>ev:<S2SV_blank>%s"" , dump_dm_event ( event ) ) ; switch ( event ) { case BTA_DM_ENABLE_EVT : { BD_NAME bdname ; bt_status_t status ; bt_property_t prop ; prop . type = BT_PROPERTY_BDNAME ; prop . len = BD_NAME_LEN ; prop . val = ( void * ) bdname ; status = btif_storage_get_adapter_property ( & prop ) ; if ( status == BT_STATUS_SUCCESS ) { BTA_DmSetDeviceName ( ( char * ) prop . val ) ; } else { BTA_DmSetDeviceName ( btif_get_default_local_name ( ) ) ; } # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) BTA_DmBleConfigLocalPrivacy ( BLE_LOCAL_PRIVACY_ENABLED ) ; # endif service_mask = btif_get_enabled_services_mask ( ) ; for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) { if ( service_mask & ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) { btif_in_execute_service_request ( i , TRUE ) ; } } memset ( & pairing_cb , 0 , sizeof ( btif_dm_pairing_cb_t ) ) ; pairing_cb . bond_type = BOND_TYPE_PERSISTENT ; btif_storage_load_bonded_devices ( ) ; btif_storage_load_autopair_device_list ( ) ; btif_enable_bluetooth_evt ( p_data -> enable . status ) ; } break ; case BTA_DM_DISABLE_EVT : service_mask = btif_get_enabled_services_mask ( ) ; for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) { if ( service_mask & ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) { btif_in_execute_service_request ( i , FALSE ) ; } } btif_disable_bluetooth_evt ( ) ; break ; case BTA_DM_PIN_REQ_EVT : btif_dm_pin_req_evt ( & p_data -> pin_req ) ; break ; case BTA_DM_AUTH_CMPL_EVT : btif_dm_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; break ; case BTA_DM_BOND_CANCEL_CMPL_EVT : if ( pairing_cb . state == BT_BOND_STATE_BONDING ) { bdcpy ( bd_addr . address , pairing_cb . bd_addr ) ; btm_set_bond_type_dev ( pairing_cb . bd_addr , BOND_TYPE_UNKNOWN ) ; bond_state_changed ( p_data -> bond_cancel_cmpl . result , & bd_addr , BT_BOND_STATE_NONE ) ; } break ; case BTA_DM_SP_CFM_REQ_EVT : btif_dm_ssp_cfm_req_evt ( & p_data -> cfm_req ) ; break ; case BTA_DM_SP_KEY_NOTIF_EVT : btif_dm_ssp_key_notif_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_DEV_UNPAIRED_EVT : bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; # if ( defined ( BTA_HH_INCLUDED ) && ( BTA_HH_INCLUDED == TRUE ) ) btif_hh_remove_device ( bd_addr ) ; # endif btif_storage_remove_bonded_device ( & bd_addr ) ; bond_state_changed ( BT_STATUS_SUCCESS , & bd_addr , BT_BOND_STATE_NONE ) ; break ; case BTA_DM_BUSY_LEVEL_EVT : { if ( p_data -> busy_level . level_flags & BTM_BL_INQUIRY_PAGING_MASK ) { if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_STARTED ) { HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , BT_DISCOVERY_STARTED ) ; btif_dm_inquiry_in_progress = TRUE ; } else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_CANCELLED ) { HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , BT_DISCOVERY_STOPPED ) ; btif_dm_inquiry_in_progress = FALSE ; } else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_COMPLETE ) { btif_dm_inquiry_in_progress = FALSE ; } } } break ; case BTA_DM_LINK_UP_EVT : bdcpy ( bd_addr . address , p_data -> link_up . bd_addr ) ; BTIF_TRACE_DEBUG ( ""BTA_DM_LINK_UP_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_CONNECTED"" ) ; btif_update_remote_version_property ( & bd_addr ) ; HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , & bd_addr , BT_ACL_STATE_CONNECTED ) ; break ; case BTA_DM_LINK_DOWN_EVT : bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; BTIF_TRACE_DEBUG ( ""BTA_DM_LINK_DOWN_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_DISCONNECTED"" ) ; HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , & bd_addr , BT_ACL_STATE_DISCONNECTED ) ; break ; case BTA_DM_HW_ERROR_EVT : BTIF_TRACE_ERROR ( ""Received<S2SV_blank>H/W<S2SV_blank>Error.<S2SV_blank>"" ) ; btif_config_flush ( ) ; usleep ( 100000 ) ; kill ( getpid ( ) , SIGKILL ) ; break ; # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) case BTA_DM_BLE_KEY_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_KEY_EVT<S2SV_blank>key_type=0x%02x<S2SV_blank>"" , p_data -> ble_key . key_type ) ; if ( pairing_cb . state != BT_BOND_STATE_BONDING ) { BTIF_TRACE_DEBUG ( ""Bond<S2SV_blank>state<S2SV_blank>not<S2SV_blank>sent<S2SV_blank>to<S2SV_blank>App<S2SV_blank>so<S2SV_blank>far.Notify<S2SV_blank>the<S2SV_blank>app<S2SV_blank>now"" ) ; bond_state_changed ( BT_STATUS_SUCCESS , ( bt_bdaddr_t * ) p_data -> ble_key . bd_addr , BT_BOND_STATE_BONDING ) ; } else if ( memcmp ( pairing_cb . bd_addr , p_data -> ble_key . bd_addr , BD_ADDR_LEN ) != 0 ) { BTIF_TRACE_ERROR ( ""BD<S2SV_blank>mismatch<S2SV_blank>discard<S2SV_blank>BLE<S2SV_blank>key_type=%d<S2SV_blank>"" , p_data -> ble_key . key_type ) ; break ; } switch ( p_data -> ble_key . key_type ) { case BTA_LE_KEY_PENC : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PENC"" ) ; pairing_cb . ble . is_penc_key_rcvd = TRUE ; pairing_cb . ble . penc_key = p_data -> ble_key . p_key_value -> penc_key ; break ; case BTA_LE_KEY_PID : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PID"" ) ; pairing_cb . ble . is_pid_key_rcvd = TRUE ; pairing_cb . ble . pid_key = p_data -> ble_key . p_key_value -> pid_key ; break ; case BTA_LE_KEY_PCSRK : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PCSRK"" ) ; pairing_cb . ble . is_pcsrk_key_rcvd = TRUE ; pairing_cb . ble . pcsrk_key = p_data -> ble_key . p_key_value -> pcsrk_key ; break ; case BTA_LE_KEY_LENC : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LENC"" ) ; pairing_cb . ble . is_lenc_key_rcvd = TRUE ; pairing_cb . ble . lenc_key = p_data -> ble_key . p_key_value -> lenc_key ; break ; case BTA_LE_KEY_LCSRK : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LCSRK"" ) ; pairing_cb . ble . is_lcsrk_key_rcvd = TRUE ; pairing_cb . ble . lcsrk_key = p_data -> ble_key . p_key_value -> lcsrk_key ; break ; case BTA_LE_KEY_LID : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LID"" ) ; pairing_cb . ble . is_lidk_key_rcvd = TRUE ; break ; default : BTIF_TRACE_ERROR ( ""unknown<S2SV_blank>BLE<S2SV_blank>key<S2SV_blank>type<S2SV_blank>(0x%02x)"" , p_data -> ble_key . key_type ) ; break ; } break ; case BTA_DM_BLE_SEC_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_SEC_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_sec_req_evt ( & p_data -> ble_req ) ; break ; case BTA_DM_BLE_PASSKEY_NOTIF_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_NOTIF_EVT.<S2SV_blank>"" ) ; btif_dm_ble_key_notif_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_BLE_PASSKEY_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_passkey_req_evt ( & p_data -> pin_req ) ; break ; case BTA_DM_BLE_NC_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_key_nc_req_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_BLE_OOB_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_OOB_REQ_EVT.<S2SV_blank>"" ) ; break ; case BTA_DM_BLE_LOCAL_IR_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_LOCAL_IR_EVT.<S2SV_blank>"" ) ; ble_local_key_cb . is_id_keys_rcvd = TRUE ; memcpy ( & ble_local_key_cb . id_keys . irk [ 0 ] , & p_data -> ble_id_keys . irk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; memcpy ( & ble_local_key_cb . id_keys . ir [ 0 ] , & p_data -> ble_id_keys . ir [ 0 ] , sizeof ( BT_OCTET16 ) ) ; memcpy ( & ble_local_key_cb . id_keys . dhk [ 0 ] , & p_data -> ble_id_keys . dhk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . irk [ 0 ] , BTIF_DM_LE_LOCAL_KEY_IRK , BT_OCTET16_LEN ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . ir [ 0 ] , BTIF_DM_LE_LOCAL_KEY_IR , BT_OCTET16_LEN ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . dhk [ 0 ] , BTIF_DM_LE_LOCAL_KEY_DHK , BT_OCTET16_LEN ) ; break ; case BTA_DM_BLE_LOCAL_ER_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_LOCAL_ER_EVT.<S2SV_blank>"" ) ; ble_local_key_cb . is_er_rcvd = TRUE ; memcpy ( & ble_local_key_cb . er [ 0 ] , & p_data -> ble_er [ 0 ] , sizeof ( BT_OCTET16 ) ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . er [ 0 ] , BTIF_DM_LE_LOCAL_KEY_ER , BT_OCTET16_LEN ) ; break ; case BTA_DM_BLE_AUTH_CMPL_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_AUTH_CMPL_EVT.<S2SV_blank>"" ) ; btif_dm_ble_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; break ; case BTA_DM_LE_FEATURES_READ : { tBTM_BLE_VSC_CB cmn_vsc_cb ; bt_local_le_features_t local_le_features ; char buf [ 512 ] ; bt_property_t prop ; prop . type = BT_PROPERTY_LOCAL_LE_FEATURES ; prop . val = ( void * ) buf ; prop . len = sizeof ( buf ) ; BTM_BleGetVendorCapabilities ( & cmn_vsc_cb ) ; local_le_features . local_privacy_enabled = BTM_BleLocalPrivacyEnabled ( ) ; prop . len = sizeof ( bt_local_le_features_t ) ; if ( cmn_vsc_cb . filter_support == 1 ) local_le_features . max_adv_filter_supported = cmn_vsc_cb . max_filter ; else local_le_features . max_adv_filter_supported = 0 ; local_le_features . max_adv_instance = cmn_vsc_cb . adv_inst_max ; local_le_features . max_irk_list_size = cmn_vsc_cb . max_irk_list_sz ; local_le_features . rpa_offload_supported = cmn_vsc_cb . rpa_offloading ; local_le_features . activity_energy_info_supported = cmn_vsc_cb . energy_support ; local_le_features . scan_result_storage_size = cmn_vsc_cb . tot_scan_results_strg ; local_le_features . version_supported = cmn_vsc_cb . version_supported ; local_le_features . total_trackable_advertisers = cmn_vsc_cb . total_trackable_advertisers ; local_le_features . extended_scan_support = cmn_vsc_cb . extended_scan_support > 0 ; local_le_features . debug_logging_supported = cmn_vsc_cb . debug_logging_supported > 0 ; memcpy ( prop . val , & local_le_features , prop . len ) ; HAL_CBACK ( bt_hal_cbacks , adapter_properties_cb , BT_STATUS_SUCCESS , 1 , & prop ) ; break ; } case BTA_DM_ENER_INFO_READ : { btif_activity_energy_info_cb_t * p_ener_data = ( btif_activity_energy_info_cb_t * ) p_param ; bt_activity_energy_info energy_info ; energy_info . status = p_ener_data -> status ; energy_info . ctrl_state = p_ener_data -> ctrl_state ; energy_info . rx_time = p_ener_data -> rx_time ; energy_info . tx_time = p_ener_data -> tx_time ; energy_info . idle_time = p_ener_data -> idle_time ; energy_info . energy_used = p_ener_data -> energy_used ; HAL_CBACK ( bt_hal_cbacks , energy_info_cb , & energy_info ) ; break ; } # endif case BTA_DM_AUTHORIZE_EVT : case BTA_DM_SIG_STRENGTH_EVT : case BTA_DM_SP_RMT_OOB_EVT : case BTA_DM_SP_KEYPRESS_EVT : case BTA_DM_ROLE_CHG_EVT : default : BTIF_TRACE_WARNING ( ""btif_dm_cback<S2SV_blank>:<S2SV_blank>unhandled<S2SV_blank>event<S2SV_blank>(%d)"" , event ) ; break ; } btif_dm_data_free ( event , p_data ) ; }
","<S2SV_ModStart> ( ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 100000 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,<S2SV_StartBug> usleep ( 100000 ) ; <S2SV_EndBug>
339,CWE-787,"__inline # if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__ __attribute__ ( ( __gnu_inline__ ) ) # endif # endif const struct ByUnfoldKey * unicode_unfold_key ( OnigCodePoint code ) { static const struct ByUnfoldKey wordlist [ ] = { { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x1040a , 3267 , 1 } , { 0x1e0a , 1727 , 1 } , { 0x040a , 1016 , 1 } , { 0x010a , 186 , 1 } , { 0x1f0a , 2088 , 1 } , { 0x2c0a , 2451 , 1 } , { 0x0189 , 619 , 1 } , { 0x1f89 , 134 , 2 } , { 0x1f85 , 154 , 2 } , { 0x0389 , 733 , 1 } , { 0x03ff , 724 , 1 } , { 0xab89 , 1523 , 1 } , { 0xab85 , 1511 , 1 } , { 0x10c89 , 3384 , 1 } , { 0x10c85 , 3372 , 1 } , { 0x1e84 , 1911 , 1 } , { 0x03f5 , 752 , 1 } , { 0x0184 , 360 , 1 } , { 0x1f84 , 149 , 2 } , { 0x2c84 , 2592 , 1 } , { 0x017d , 351 , 1 } , { 0x1ff3 , 96 , 2 } , { 0xab84 , 1508 , 1 } , { 0xa784 , 3105 , 1 } , { 0x10c84 , 3369 , 1 } , { 0xab7d , 1487 , 1 } , { 0xa77d , 1706 , 1 } , { 0x1e98 , 38 , 2 } , { 0x0498 , 1106 , 1 } , { 0x0198 , 375 , 1 } , { 0x1f98 , 169 , 2 } , { 0x2c98 , 2622 , 1 } , { 0x0398 , 762 , 1 } , { 0xa684 , 2940 , 1 } , { 0xab98 , 1568 , 1 } , { 0xa798 , 3123 , 1 } , { 0x10c98 , 3429 , 1 } , { 0x050a , 1277 , 1 } , { 0x1ffb , 2265 , 1 } , { 0x1e96 , 16 , 2 } , { 0x0496 , 1103 , 1 } , { 0x0196 , 652 , 1 } , { 0x1f96 , 199 , 2 } , { 0x2c96 , 2619 , 1 } , { 0x0396 , 756 , 1 } , { 0xa698 , 2970 , 1 } , { 0xab96 , 1562 , 1 } , { 0xa796 , 3120 , 1 } , { 0x10c96 , 3423 , 1 } , { 0x1feb , 2259 , 1 } , { 0x2ceb , 2736 , 1 } , { 0x1e90 , 1929 , 1 } , { 0x0490 , 1094 , 1 } , { 0x0190 , 628 , 1 } , { 0x1f90 , 169 , 2 } , { 0x2c90 , 2610 , 1 } , { 0x0390 , 25 , 3 } , { 0xa696 , 2967 , 1 } , { 0xab90 , 1544 , 1 } , { 0xa790 , 3114 , 1 } , { 0x10c90 , 3405 , 1 } , { 0x01d7 , 444 , 1 } , { 0x1fd7 , 31 , 3 } , { 0x1ea6 , 1947 , 1 } , { 0x04a6 , 1127 , 1 } , { 0x01a6 , 676 , 1 } , { 0x1fa6 , 239 , 2 } , { 0x2ca6 , 2643 , 1 } , { 0x03a6 , 810 , 1 } , { 0xa690 , 2958 , 1 } , { 0xaba6 , 1610 , 1 } , { 0xa7a6 , 3144 , 1 } , { 0x10ca6 , 3471 , 1 } , { 0x1ea4 , 1944 , 1 } , { 0x04a4 , 1124 , 1 } , { 0x01a4 , 390 , 1 } , { 0x1fa4 , 229 , 2 } , { 0x2ca4 , 2640 , 1 } , { 0x03a4 , 804 , 1 } , { 0x10a6 , 2763 , 1 } , { 0xaba4 , 1604 , 1 } , { 0xa7a4 , 3141 , 1 } , { 0x10ca4 , 3465 , 1 } , { 0x1ea0 , 1938 , 1 } , { 0x04a0 , 1118 , 1 } , { 0x01a0 , 384 , 1 } , { 0x1fa0 , 209 , 2 } , { 0x2ca0 , 2634 , 1 } , { 0x03a0 , 792 , 1 } , { 0x10a4 , 2757 , 1 } , { 0xaba0 , 1592 , 1 } , { 0xa7a0 , 3135 , 1 } , { 0x10ca0 , 3453 , 1 } , { 0x1eb2 , 1965 , 1 } , { 0x04b2 , 1145 , 1 } , { 0x01b2 , 694 , 1 } , { 0x1fb2 , 249 , 2 } , { 0x2cb2 , 2661 , 1 } , { 0x03fd , 718 , 1 } , { 0x10a0 , 2745 , 1 } , { 0xabb2 , 1646 , 1 } , { 0xa7b2 , 703 , 1 } , { 0x10cb2 , 3507 , 1 } , { 0x1eac , 1956 , 1 } , { 0x04ac , 1136 , 1 } , { 0x01ac , 396 , 1 } , { 0x1fac , 229 , 2 } , { 0x2cac , 2652 , 1 } , { 0x0537 , 1352 , 1 } , { 0x10b2 , 2799 , 1 } , { 0xabac , 1628 , 1 } , { 0xa7ac , 637 , 1 } , { 0x10cac , 3489 , 1 } , { 0x1eaa , 1953 , 1 } , { 0x04aa , 1133 , 1 } , { 0x00dd , 162 , 1 } , { 0x1faa , 219 , 2 } , { 0x2caa , 2649 , 1 } , { 0x03aa , 824 , 1 } , { 0x10ac , 2781 , 1 } , { 0xabaa , 1622 , 1 } , { 0xa7aa , 646 , 1 } , { 0x10caa , 3483 , 1 } , { 0x1ea8 , 1950 , 1 } , { 0x04a8 , 1130 , 1 } , { 0x020a , 517 , 1 } , { 0x1fa8 , 209 , 2 } , { 0x2ca8 , 2646 , 1 } , { 0x03a8 , 817 , 1 } , { 0x10aa , 2775 , 1 } , { 0xaba8 , 1616 , 1 } , { 0xa7a8 , 3147 , 1 } , { 0x10ca8 , 3477 , 1 } , { 0x1ea2 , 1941 , 1 } , { 0x04a2 , 1121 , 1 } , { 0x01a2 , 387 , 1 } , { 0x1fa2 , 219 , 2 } , { 0x2ca2 , 2637 , 1 } , { 0x118a6 , 3528 , 1 } , { 0x10a8 , 2769 , 1 } , { 0xaba2 , 1598 , 1 } , { 0xa7a2 , 3138 , 1 } , { 0x10ca2 , 3459 , 1 } , { 0x2ced , 2739 , 1 } , { 0x1fe9 , 2283 , 1 } , { 0x1fe7 , 47 , 3 } , { 0x1eb0 , 1962 , 1 } , { 0x04b0 , 1142 , 1 } , { 0x118a4 , 3522 , 1 } , { 0x10a2 , 2751 , 1 } , { 0x2cb0 , 2658 , 1 } , { 0x03b0 , 41 , 3 } , { 0x1fe3 , 41 , 3 } , { 0xabb0 , 1640 , 1 } , { 0xa7b0 , 706 , 1 } , { 0x10cb0 , 3501 , 1 } , { 0x01d9 , 447 , 1 } , { 0x1fd9 , 2277 , 1 } , { 0x118a0 , 3510 , 1 } , { 0x00df , 24 , 2 } , { 0x00d9 , 150 , 1 } , { 0xab77 , 1469 , 1 } , { 0x10b0 , 2793 , 1 } , { 0x1eae , 1959 , 1 } , { 0x04ae , 1139 , 1 } , { 0x01ae , 685 , 1 } , { 0x1fae , 239 , 2 } , { 0x2cae , 2655 , 1 } , { 0x118b2 , 3564 , 1 } , { 0xab73 , 1457 , 1 } , { 0xabae , 1634 , 1 } , { 0xab71 , 1451 , 1 } , { 0x10cae , 3495 , 1 } , { 0x1e2a , 1775 , 1 } , { 0x042a , 968 , 1 } , { 0x012a , 234 , 1 } , { 0x1f2a , 2130 , 1 } , { 0x2c2a , 2547 , 1 } , { 0x118ac , 3546 , 1 } , { 0x10ae , 2787 , 1 } , { 0x0535 , 1346 , 1 } , { 0xa72a , 2988 , 1 } , { 0x1e9a , 0 , 2 } , { 0x049a , 1109 , 1 } , { 0xff37 , 3225 , 1 } , { 0x1f9a , 179 , 2 } , { 0x2c9a , 2625 , 1 } , { 0x039a , 772 , 1 } , { 0x118aa , 3540 , 1 } , { 0xab9a , 1574 , 1 } , { 0xa79a , 3126 , 1 } , { 0x10c9a , 3435 , 1 } , { 0x1e94 , 1935 , 1 } , { 0x0494 , 1100 , 1 } , { 0x0194 , 640 , 1 } , { 0x1f94 , 189 , 2 } , { 0x2c94 , 2616 , 1 } , { 0x0394 , 749 , 1 } , { 0x118a8 , 3534 , 1 } , { 0xab94 , 1556 , 1 } , { 0xa69a , 2973 , 1 } , { 0x10c94 , 3417 , 1 } , { 0x10402 , 3243 , 1 } , { 0x1e02 , 1715 , 1 } , { 0x0402 , 992 , 1 } , { 0x0102 , 174 , 1 } , { 0x0533 , 1340 , 1 } , { 0x2c02 , 2427 , 1 } , { 0x118a2 , 3516 , 1 } , { 0x052a , 1325 , 1 } , { 0xa694 , 2964 , 1 } , { 0x1e92 , 1932 , 1 } , { 0x0492 , 1097 , 1 } , { 0x2165 , 2307 , 1 } , { 0x1f92 , 179 , 2 } , { 0x2c92 , 2613 , 1 } , { 0x0392 , 742 , 1 } , { 0x2161 , 2295 , 1 } , { 0xab92 , 1550 , 1 } , { 0xa792 , 3117 , 1 } , { 0x10c92 , 3411 , 1 } , { 0x118b0 , 3558 , 1 } , { 0x1f5f , 2199 , 1 } , { 0x1e8e , 1926 , 1 } , { 0x048e , 1091 , 1 } , { 0x018e , 453 , 1 } , { 0x1f8e , 159 , 2 } , { 0x2c8e , 2607 , 1 } , { 0x038e , 833 , 1 } , { 0xa692 , 2961 , 1 } , { 0xab8e , 1538 , 1 } , { 0x0055 , 59 , 1 } , { 0x10c8e , 3399 , 1 } , { 0x1f5d , 2196 , 1 } , { 0x212a , 27 , 1 } , { 0x04cb , 1181 , 1 } , { 0x01cb , 425 , 1 } , { 0x1fcb , 2241 , 1 } , { 0x118ae , 3552 , 1 } , { 0x0502 , 1265 , 1 } , { 0x00cb , 111 , 1 } , { 0xa68e , 2955 , 1 } , { 0x1e8a , 1920 , 1 } , { 0x048a , 1085 , 1 } , { 0x018a , 622 , 1 } , { 0x1f8a , 139 , 2 } , { 0x2c8a , 2601 , 1 } , { 0x038a , 736 , 1 } , { 0x2c67 , 2571 , 1 } , { 0xab8a , 1526 , 1 } , { 0x1e86 , 1914 , 1 } , { 0x10c8a , 3387 , 1 } , { 0x0186 , 616 , 1 } , { 0x1f86 , 159 , 2 } , { 0x2c86 , 2595 , 1 } , { 0x0386 , 727 , 1 } , { 0xff35 , 3219 , 1 } , { 0xab86 , 1514 , 1 } , { 0xa786 , 3108 , 1 } , { 0x10c86 , 3375 , 1 } , { 0xa68a , 2949 , 1 } , { 0x0555 , 1442 , 1 } , { 0x1ebc , 1980 , 1 } , { 0x04bc , 1160 , 1 } , { 0x01bc , 411 , 1 } , { 0x1fbc , 62 , 2 } , { 0x2cbc , 2676 , 1 } , { 0x1f5b , 2193 , 1 } , { 0xa686 , 2943 , 1 } , { 0xabbc , 1676 , 1 } , { 0x1eb8 , 1974 , 1 } , { 0x04b8 , 1154 , 1 } , { 0x01b8 , 408 , 1 } , { 0x1fb8 , 2268 , 1 } , { 0x2cb8 , 2670 , 1 } , { 0x01db , 450 , 1 } , { 0x1fdb , 2247 , 1 } , { 0xabb8 , 1664 , 1 } , { 0x10bc , 2829 , 1 } , { 0x00db , 156 , 1 } , { 0x1eb6 , 1971 , 1 } , { 0x04b6 , 1151 , 1 } , { 0xff33 , 3213 , 1 } , { 0x1fb6 , 58 , 2 } , { 0x2cb6 , 2667 , 1 } , { 0xff2a , 3186 , 1 } , { 0x10b8 , 2817 , 1 } , { 0xabb6 , 1658 , 1 } , { 0xa7b6 , 3153 , 1 } , { 0x10426 , 3351 , 1 } , { 0x1e26 , 1769 , 1 } , { 0x0426 , 956 , 1 } , { 0x0126 , 228 , 1 } , { 0x0053 , 52 , 1 } , { 0x2c26 , 2535 , 1 } , { 0x0057 , 65 , 1 } , { 0x10b6 , 2811 , 1 } , { 0x022a , 562 , 1 } , { 0xa726 , 2982 , 1 } , { 0x1e2e , 1781 , 1 } , { 0x042e , 980 , 1 } , { 0x012e , 240 , 1 } , { 0x1f2e , 2142 , 1 } , { 0x2c2e , 2559 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2167 , 2313 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa72e , 2994 , 1 } , { 0x1e2c , 1778 , 1 } , { 0x042c , 974 , 1 } , { 0x012c , 237 , 1 } , { 0x1f2c , 2136 , 1 } , { 0x2c2c , 2553 , 1 } , { 0x1f6f , 2223 , 1 } , { 0x2c6f , 604 , 1 } , { 0xabbf , 1685 , 1 } , { 0xa72c , 2991 , 1 } , { 0x1e28 , 1772 , 1 } , { 0x0428 , 962 , 1 } , { 0x0128 , 231 , 1 } , { 0x1f28 , 2124 , 1 } , { 0x2c28 , 2541 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0553 , 1436 , 1 } , { 0x10bf , 2838 , 1 } , { 0xa728 , 2985 , 1 } , { 0x0526 , 1319 , 1 } , { 0x0202 , 505 , 1 } , { 0x1e40 , 1808 , 1 } , { 0x10424 , 3345 , 1 } , { 0x1e24 , 1766 , 1 } , { 0x0424 , 950 , 1 } , { 0x0124 , 225 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c24 , 2529 , 1 } , { 0x052e , 1331 , 1 } , { 0xa740 , 3018 , 1 } , { 0x118bc , 3594 , 1 } , { 0xa724 , 2979 , 1 } , { 0x1ef2 , 2061 , 1 } , { 0x04f2 , 1241 , 1 } , { 0x01f2 , 483 , 1 } , { 0x1ff2 , 257 , 2 } , { 0x2cf2 , 2742 , 1 } , { 0x052c , 1328 , 1 } , { 0x118b8 , 3582 , 1 } , { 0xa640 , 2865 , 1 } , { 0x10422 , 3339 , 1 } , { 0x1e22 , 1763 , 1 } , { 0x0422 , 944 , 1 } , { 0x0122 , 222 , 1 } , { 0x2126 , 820 , 1 } , { 0x2c22 , 2523 , 1 } , { 0x0528 , 1322 , 1 } , { 0x01f1 , 483 , 1 } , { 0x118b6 , 3576 , 1 } , { 0xa722 , 2976 , 1 } , { 0x03f1 , 796 , 1 } , { 0x1ebe , 1983 , 1 } , { 0x04be , 1163 , 1 } , { 0xfb02 , 12 , 2 } , { 0x1fbe , 767 , 1 } , { 0x2cbe , 2679 , 1 } , { 0x01b5 , 405 , 1 } , { 0x0540 , 1379 , 1 } , { 0xabbe , 1682 , 1 } , { 0x0524 , 1316 , 1 } , { 0x00b5 , 779 , 1 } , { 0xabb5 , 1655 , 1 } , { 0x1eba , 1977 , 1 } , { 0x04ba , 1157 , 1 } , { 0x216f , 2337 , 1 } , { 0x1fba , 2226 , 1 } , { 0x2cba , 2673 , 1 } , { 0x10be , 2835 , 1 } , { 0x0051 , 46 , 1 } , { 0xabba , 1670 , 1 } , { 0x10b5 , 2808 , 1 } , { 0x1e6e , 1878 , 1 } , { 0x046e , 1055 , 1 } , { 0x016e , 330 , 1 } , { 0x1f6e , 2220 , 1 } , { 0x2c6e , 664 , 1 } , { 0x118bf , 3603 , 1 } , { 0x0522 , 1313 , 1 } , { 0x10ba , 2823 , 1 } , { 0xa76e , 3087 , 1 } , { 0x1eb4 , 1968 , 1 } , { 0x04b4 , 1148 , 1 } , { 0x2c75 , 2583 , 1 } , { 0x1fb4 , 50 , 2 } , { 0x2cb4 , 2664 , 1 } , { 0xab75 , 1463 , 1 } , { 0x1ec2 , 1989 , 1 } , { 0xabb4 , 1652 , 1 } , { 0xa7b4 , 3150 , 1 } , { 0x1fc2 , 253 , 2 } , { 0x2cc2 , 2685 , 1 } , { 0x03c2 , 800 , 1 } , { 0x00c2 , 83 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff26 , 3174 , 1 } , { 0x10b4 , 2805 , 1 } , { 0x1eca , 2001 , 1 } , { 0x0551 , 1430 , 1 } , { 0x01ca , 425 , 1 } , { 0x1fca , 2238 , 1 } , { 0x2cca , 2697 , 1 } , { 0x10c2 , 2847 , 1 } , { 0x00ca , 108 , 1 } , { 0xff2e , 3198 , 1 } , { 0x1e8c , 1923 , 1 } , { 0x048c , 1088 , 1 } , { 0x0226 , 556 , 1 } , { 0x1f8c , 149 , 2 } , { 0x2c8c , 2604 , 1 } , { 0x038c , 830 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab8c , 1532 , 1 } , { 0xff2c , 3192 , 1 } , { 0x10c8c , 3393 , 1 } , { 0x1ec4 , 1992 , 1 } , { 0x022e , 568 , 1 } , { 0x01c4 , 417 , 1 } , { 0x1fc4 , 54 , 2 } , { 0x2cc4 , 2688 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x00c4 , 89 , 1 } , { 0xff28 , 3180 , 1 } , { 0xa68c , 2952 , 1 } , { 0x01cf , 432 , 1 } , { 0x022c , 565 , 1 } , { 0x118be , 3600 , 1 } , { 0x03cf , 839 , 1 } , { 0x00cf , 123 , 1 } , { 0x118b5 , 3573 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c4 , 2853 , 1 } , { 0x216e , 2334 , 1 } , { 0x24cb , 2406 , 1 } , { 0x0228 , 559 , 1 } , { 0xff24 , 3168 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x118ba , 3588 , 1 } , { 0x1efe , 2079 , 1 } , { 0x04fe , 1259 , 1 } , { 0x01fe , 499 , 1 } , { 0x1e9e , 24 , 2 } , { 0x049e , 1115 , 1 } , { 0x03fe , 721 , 1 } , { 0x1f9e , 199 , 2 } , { 0x2c9e , 2631 , 1 } , { 0x039e , 786 , 1 } , { 0x0224 , 553 , 1 } , { 0xab9e , 1586 , 1 } , { 0xa79e , 3132 , 1 } , { 0x10c9e , 3447 , 1 } , { 0x01f7 , 414 , 1 } , { 0x1ff7 , 67 , 3 } , { 0xff22 , 3162 , 1 } , { 0x03f7 , 884 , 1 } , { 0x118b4 , 3570 , 1 } , { 0x049c , 1112 , 1 } , { 0x019c , 661 , 1 } , { 0x1f9c , 189 , 2 } , { 0x2c9c , 2628 , 1 } , { 0x039c , 779 , 1 } , { 0x24bc , 2361 , 1 } , { 0xab9c , 1580 , 1 } , { 0xa79c , 3129 , 1 } , { 0x10c9c , 3441 , 1 } , { 0x0222 , 550 , 1 } , { 0x1e7c , 1899 , 1 } , { 0x047c , 1076 , 1 } , { 0x1e82 , 1908 , 1 } , { 0x24b8 , 2349 , 1 } , { 0x0182 , 357 , 1 } , { 0x1f82 , 139 , 2 } , { 0x2c82 , 2589 , 1 } , { 0xab7c , 1484 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab82 , 1502 , 1 } , { 0xa782 , 3102 , 1 } , { 0x10c82 , 3363 , 1 } , { 0x2c63 , 1709 , 1 } , { 0x24b6 , 2343 , 1 } , { 0x1e80 , 1905 , 1 } , { 0x0480 , 1082 , 1 } , { 0x1f59 , 2190 , 1 } , { 0x1f80 , 129 , 2 } , { 0x2c80 , 2586 , 1 } , { 0x0059 , 71 , 1 } , { 0xa682 , 2937 , 1 } , { 0xab80 , 1496 , 1 } , { 0xa780 , 3099 , 1 } , { 0x10c80 , 3357 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1e4c , 1826 , 1 } , { 0x0145 , 270 , 1 } , { 0x014c , 279 , 1 } , { 0x1f4c , 2184 , 1 } , { 0x0345 , 767 , 1 } , { 0x0045 , 12 , 1 } , { 0x004c , 31 , 1 } , { 0xa680 , 2934 , 1 } , { 0xa74c , 3036 , 1 } , { 0x1e4a , 1823 , 1 } , { 0x01d5 , 441 , 1 } , { 0x014a , 276 , 1 } , { 0x1f4a , 2178 , 1 } , { 0x03d5 , 810 , 1 } , { 0x00d5 , 141 , 1 } , { 0x004a , 24 , 1 } , { 0x24bf , 2370 , 1 } , { 0xa74a , 3033 , 1 } , { 0xa64c , 2883 , 1 } , { 0x1041c , 3321 , 1 } , { 0x1e1c , 1754 , 1 } , { 0x041c , 926 , 1 } , { 0x011c , 213 , 1 } , { 0x1f1c , 2118 , 1 } , { 0x2c1c , 2505 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xa64a , 2880 , 1 } , { 0x1041a , 3315 , 1 } , { 0x1e1a , 1751 , 1 } , { 0x041a , 920 , 1 } , { 0x011a , 210 , 1 } , { 0x1f1a , 2112 , 1 } , { 0x2c1a , 2499 , 1 } , { 0xabbd , 1679 , 1 } , { 0x0545 , 1394 , 1 } , { 0x054c , 1415 , 1 } , { 0x10418 , 3309 , 1 } , { 0x1e18 , 1748 , 1 } , { 0x0418 , 914 , 1 } , { 0x0118 , 207 , 1 } , { 0x1f18 , 2106 , 1 } , { 0x2c18 , 2493 , 1 } , { 0x10bd , 2832 , 1 } , { 0x2163 , 2301 , 1 } , { 0x054a , 1409 , 1 } , { 0x1040e , 3279 , 1 } , { 0x1e0e , 1733 , 1 } , { 0x040e , 1028 , 1 } , { 0x010e , 192 , 1 } , { 0x1f0e , 2100 , 1 } , { 0x2c0e , 2463 , 1 } , { 0x1efc , 2076 , 1 } , { 0x04fc , 1256 , 1 } , { 0x01fc , 496 , 1 } , { 0x1ffc , 96 , 2 } , { 0x051c , 1304 , 1 } , { 0x1040c , 3273 , 1 } , { 0x1e0c , 1730 , 1 } , { 0x040c , 1022 , 1 } , { 0x010c , 189 , 1 } , { 0x1f0c , 2094 , 1 } , { 0x2c0c , 2457 , 1 } , { 0x1f6d , 2217 , 1 } , { 0x2c6d , 607 , 1 } , { 0x051a , 1301 , 1 } , { 0x24be , 2367 , 1 } , { 0x10408 , 3261 , 1 } , { 0x1e08 , 1724 , 1 } , { 0x0408 , 1010 , 1 } , { 0x0108 , 183 , 1 } , { 0x1f08 , 2082 , 1 } , { 0x2c08 , 2445 , 1 } , { 0x04c9 , 1178 , 1 } , { 0x0518 , 1298 , 1 } , { 0x1fc9 , 2235 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x24ba , 2355 , 1 } , { 0x00c9 , 105 , 1 } , { 0x10416 , 3303 , 1 } , { 0x1e16 , 1745 , 1 } , { 0x0416 , 908 , 1 } , { 0x0116 , 204 , 1 } , { 0x050e , 1283 , 1 } , { 0x2c16 , 2487 , 1 } , { 0x10414 , 3297 , 1 } , { 0x1e14 , 1742 , 1 } , { 0x0414 , 902 , 1 } , { 0x0114 , 201 , 1 } , { 0x042b , 971 , 1 } , { 0x2c14 , 2481 , 1 } , { 0x1f2b , 2133 , 1 } , { 0x2c2b , 2550 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x050c , 1280 , 1 } , { 0x10406 , 3255 , 1 } , { 0x1e06 , 1721 , 1 } , { 0x0406 , 1004 , 1 } , { 0x0106 , 180 , 1 } , { 0x13fb , 1697 , 1 } , { 0x2c06 , 2439 , 1 } , { 0x24c2 , 2379 , 1 } , { 0x118bd , 3597 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0508 , 1274 , 1 } , { 0x10404 , 3249 , 1 } , { 0x1e04 , 1718 , 1 } , { 0x0404 , 998 , 1 } , { 0x0104 , 177 , 1 } , { 0x1f95 , 194 , 2 } , { 0x2c04 , 2433 , 1 } , { 0x0395 , 752 , 1 } , { 0x24ca , 2403 , 1 } , { 0xab95 , 1559 , 1 } , { 0x0531 , 1334 , 1 } , { 0x10c95 , 3420 , 1 } , { 0x0516 , 1295 , 1 } , { 0x1e6c , 1875 , 1 } , { 0x046c , 1052 , 1 } , { 0x016c , 327 , 1 } , { 0x1f6c , 2214 , 1 } , { 0x216d , 2331 , 1 } , { 0x0514 , 1292 , 1 } , { 0x0245 , 697 , 1 } , { 0x024c , 598 , 1 } , { 0xa76c , 3084 , 1 } , { 0x10400 , 3237 , 1 } , { 0x1e00 , 1712 , 1 } , { 0x0400 , 986 , 1 } , { 0x0100 , 171 , 1 } , { 0x24c4 , 2385 , 1 } , { 0x2c00 , 2421 , 1 } , { 0x0506 , 1271 , 1 } , { 0x024a , 595 , 1 } , { 0x1fab , 224 , 2 } , { 0xa66c , 2931 , 1 } , { 0x03ab , 827 , 1 } , { 0x24cf , 2418 , 1 } , { 0xabab , 1625 , 1 } , { 0xa7ab , 631 , 1 } , { 0x10cab , 3486 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0504 , 1268 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x021c , 544 , 1 } , { 0x01a9 , 679 , 1 } , { 0x1fa9 , 214 , 2 } , { 0x10ab , 2778 , 1 } , { 0x03a9 , 820 , 1 } , { 0x212b , 92 , 1 } , { 0xaba9 , 1619 , 1 } , { 0x1e88 , 1917 , 1 } , { 0x10ca9 , 3480 , 1 } , { 0x021a , 541 , 1 } , { 0x1f88 , 129 , 2 } , { 0x2c88 , 2598 , 1 } , { 0x0388 , 730 , 1 } , { 0x13fd , 1703 , 1 } , { 0xab88 , 1520 , 1 } , { 0x10a9 , 2772 , 1 } , { 0x10c88 , 3381 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0218 , 538 , 1 } , { 0x0500 , 1262 , 1 } , { 0x1f4d , 2187 , 1 } , { 0x01a7 , 393 , 1 } , { 0x1fa7 , 244 , 2 } , { 0x004d , 34 , 1 } , { 0x03a7 , 814 , 1 } , { 0xa688 , 2946 , 1 } , { 0xaba7 , 1613 , 1 } , { 0x020e , 523 , 1 } , { 0x10ca7 , 3474 , 1 } , { 0x1e6a , 1872 , 1 } , { 0x046a , 1049 , 1 } , { 0x016a , 324 , 1 } , { 0x1f6a , 2208 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x216c , 2328 , 1 } , { 0x10a7 , 2766 , 1 } , { 0x01d1 , 435 , 1 } , { 0xa76a , 3081 , 1 } , { 0x020c , 520 , 1 } , { 0x03d1 , 762 , 1 } , { 0x00d1 , 129 , 1 } , { 0x1e68 , 1869 , 1 } , { 0x0468 , 1046 , 1 } , { 0x0168 , 321 , 1 } , { 0x1f68 , 2202 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xff31 , 3207 , 1 } , { 0xa66a , 2928 , 1 } , { 0x0208 , 514 , 1 } , { 0xa768 , 3078 , 1 } , { 0x1e64 , 1863 , 1 } , { 0x0464 , 1040 , 1 } , { 0x0164 , 315 , 1 } , { 0x054d , 1418 , 1 } , { 0x2c64 , 673 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xff2b , 3189 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa764 , 3072 , 1 } , { 0xa668 , 2925 , 1 } , { 0x0216 , 535 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x118ab , 3543 , 1 } , { 0x1e62 , 1860 , 1 } , { 0x0462 , 1037 , 1 } , { 0x0162 , 312 , 1 } , { 0x0214 , 532 , 1 } , { 0x2c62 , 655 , 1 } , { 0xa664 , 2919 , 1 } , { 0x1ed2 , 2013 , 1 } , { 0x04d2 , 1193 , 1 } , { 0xa762 , 3069 , 1 } , { 0x1fd2 , 20 , 3 } , { 0x2cd2 , 2709 , 1 } , { 0x118a9 , 3537 , 1 } , { 0x00d2 , 132 , 1 } , { 0x0206 , 511 , 1 } , { 0x10420 , 3333 , 1 } , { 0x1e20 , 1760 , 1 } , { 0x0420 , 938 , 1 } , { 0x0120 , 219 , 1 } , { 0xa662 , 2916 , 1 } , { 0x2c20 , 2517 , 1 } , { 0x1e60 , 1856 , 1 } , { 0x0460 , 1034 , 1 } , { 0x0160 , 309 , 1 } , { 0x0204 , 508 , 1 } , { 0x2c60 , 2562 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x24bd , 2364 , 1 } , { 0x216a , 2322 , 1 } , { 0xa760 , 3066 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xfb16 , 125 , 2 } , { 0x118a7 , 3531 , 1 } , { 0x1efa , 2073 , 1 } , { 0x04fa , 1253 , 1 } , { 0x01fa , 493 , 1 } , { 0x1ffa , 2262 , 1 } , { 0xfb14 , 109 , 2 } , { 0x03fa , 887 , 1 } , { 0xa660 , 2913 , 1 } , { 0x2168 , 2316 , 1 } , { 0x01b7 , 700 , 1 } , { 0x1fb7 , 10 , 3 } , { 0x1f6b , 2211 , 1 } , { 0x2c6b , 2577 , 1 } , { 0x0200 , 502 , 1 } , { 0xabb7 , 1661 , 1 } , { 0xfb06 , 29 , 2 } , { 0x1e56 , 1841 , 1 } , { 0x2164 , 2304 , 1 } , { 0x0156 , 294 , 1 } , { 0x1f56 , 62 , 3 } , { 0x0520 , 1310 , 1 } , { 0x004f , 40 , 1 } , { 0x0056 , 62 , 1 } , { 0x10b7 , 2814 , 1 } , { 0xa756 , 3051 , 1 } , { 0xfb04 , 5 , 3 } , { 0x1e78 , 1893 , 1 } , { 0x0478 , 1070 , 1 } , { 0x0178 , 168 , 1 } , { 0x1e54 , 1838 , 1 } , { 0x2162 , 2298 , 1 } , { 0x0154 , 291 , 1 } , { 0x1f54 , 57 , 3 } , { 0xab78 , 1472 , 1 } , { 0xa656 , 2898 , 1 } , { 0x0054 , 56 , 1 } , { 0x1e52 , 1835 , 1 } , { 0xa754 , 3048 , 1 } , { 0x0152 , 288 , 1 } , { 0x1f52 , 52 , 3 } , { 0x24c9 , 2400 , 1 } , { 0x1e32 , 1787 , 1 } , { 0x0052 , 49 , 1 } , { 0x0132 , 243 , 1 } , { 0xa752 , 3045 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xfb00 , 4 , 2 } , { 0xa654 , 2895 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa732 , 2997 , 1 } , { 0x2160 , 2292 , 1 } , { 0x054f , 1424 , 1 } , { 0x0556 , 1445 , 1 } , { 0x1e50 , 1832 , 1 } , { 0xa652 , 2892 , 1 } , { 0x0150 , 285 , 1 } , { 0x1f50 , 84 , 2 } , { 0x017b , 348 , 1 } , { 0x1e4e , 1829 , 1 } , { 0x0050 , 43 , 1 } , { 0x014e , 282 , 1 } , { 0xa750 , 3042 , 1 } , { 0xab7b , 1481 , 1 } , { 0xa77b , 3093 , 1 } , { 0x004e , 37 , 1 } , { 0x0554 , 1439 , 1 } , { 0xa74e , 3039 , 1 } , { 0x1e48 , 1820 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x216b , 2325 , 1 } , { 0x1f48 , 2172 , 1 } , { 0xa650 , 2889 , 1 } , { 0x0552 , 1433 , 1 } , { 0x0048 , 21 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa748 , 3030 , 1 } , { 0xa64e , 2886 , 1 } , { 0x0532 , 1337 , 1 } , { 0x1041e , 3327 , 1 } , { 0x1e1e , 1757 , 1 } , { 0x041e , 932 , 1 } , { 0x011e , 216 , 1 } , { 0x118b7 , 3579 , 1 } , { 0x2c1e , 2511 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa648 , 2877 , 1 } , { 0x1ff9 , 2253 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x03f9 , 878 , 1 } , { 0x0550 , 1427 , 1 } , { 0x10412 , 3291 , 1 } , { 0x1e12 , 1739 , 1 } , { 0x0412 , 896 , 1 } , { 0x0112 , 198 , 1 } , { 0x054e , 1421 , 1 } , { 0x2c12 , 2475 , 1 } , { 0x10410 , 3285 , 1 } , { 0x1e10 , 1736 , 1 } , { 0x0410 , 890 , 1 } , { 0x0110 , 195 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c10 , 2469 , 1 } , { 0x2132 , 2289 , 1 } , { 0x0548 , 1403 , 1 } , { 0x1ef8 , 2070 , 1 } , { 0x04f8 , 1250 , 1 } , { 0x01f8 , 490 , 1 } , { 0x1ff8 , 2250 , 1 } , { 0x0220 , 381 , 1 } , { 0x1ee2 , 2037 , 1 } , { 0x04e2 , 1217 , 1 } , { 0x01e2 , 462 , 1 } , { 0x1fe2 , 36 , 3 } , { 0x2ce2 , 2733 , 1 } , { 0x03e2 , 857 , 1 } , { 0x051e , 1307 , 1 } , { 0x1ede , 2031 , 1 } , { 0x04de , 1211 , 1 } , { 0x01de , 456 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2cde , 2727 , 1 } , { 0x03de , 851 , 1 } , { 0x00de , 165 , 1 } , { 0x1f69 , 2205 , 1 } , { 0x2c69 , 2574 , 1 } , { 0x1eda , 2025 , 1 } , { 0x04da , 1205 , 1 } , { 0x0512 , 1289 , 1 } , { 0x1fda , 2244 , 1 } , { 0x2cda , 2721 , 1 } , { 0x03da , 845 , 1 } , { 0x00da , 153 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0510 , 1286 , 1 } , { 0x1ed8 , 2022 , 1 } , { 0x04d8 , 1202 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fd8 , 2274 , 1 } , { 0x2cd8 , 2718 , 1 } , { 0x03d8 , 842 , 1 } , { 0x00d8 , 147 , 1 } , { 0x1ed6 , 2019 , 1 } , { 0x04d6 , 1199 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fd6 , 76 , 2 } , { 0x2cd6 , 2715 , 1 } , { 0x03d6 , 792 , 1 } , { 0x00d6 , 144 , 1 } , { 0x1ec8 , 1998 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x01c8 , 421 , 1 } , { 0x1fc8 , 2232 , 1 } , { 0x2cc8 , 2694 , 1 } , { 0xff32 , 3210 , 1 } , { 0x00c8 , 102 , 1 } , { 0x04c7 , 1175 , 1 } , { 0x01c7 , 421 , 1 } , { 0x1fc7 , 15 , 3 } , { 0x1ec0 , 1986 , 1 } , { 0x04c0 , 1187 , 1 } , { 0x00c7 , 99 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2cc0 , 2682 , 1 } , { 0x0179 , 345 , 1 } , { 0x00c0 , 77 , 1 } , { 0x0232 , 574 , 1 } , { 0x01b3 , 402 , 1 } , { 0x1fb3 , 62 , 2 } , { 0xab79 , 1475 , 1 } , { 0xa779 , 3090 , 1 } , { 0x10c7 , 2859 , 1 } , { 0xabb3 , 1649 , 1 } , { 0xa7b3 , 3156 , 1 } , { 0x1fa5 , 234 , 2 } , { 0x10c0 , 2841 , 1 } , { 0x03a5 , 807 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xaba5 , 1607 , 1 } , { 0x01b1 , 691 , 1 } , { 0x10ca5 , 3468 , 1 } , { 0x10b3 , 2802 , 1 } , { 0x2169 , 2319 , 1 } , { 0x024e , 601 , 1 } , { 0xabb1 , 1643 , 1 } , { 0xa7b1 , 682 , 1 } , { 0x10cb1 , 3504 , 1 } , { 0x10a5 , 2760 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x01af , 399 , 1 } , { 0x1faf , 244 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x0248 , 592 , 1 } , { 0x10b1 , 2796 , 1 } , { 0xabaf , 1637 , 1 } , { 0x1fad , 234 , 2 } , { 0x10caf , 3498 , 1 } , { 0x04cd , 1184 , 1 } , { 0x01cd , 429 , 1 } , { 0xabad , 1631 , 1 } , { 0xa7ad , 658 , 1 } , { 0x10cad , 3492 , 1 } , { 0x00cd , 117 , 1 } , { 0x10af , 2790 , 1 } , { 0x021e , 547 , 1 } , { 0x1fa3 , 224 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x03a3 , 800 , 1 } , { 0x10ad , 2784 , 1 } , { 0xaba3 , 1601 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10ca3 , 3462 , 1 } , { 0x10cd , 2862 , 1 } , { 0x1fa1 , 214 , 2 } , { 0x24b7 , 2346 , 1 } , { 0x03a1 , 796 , 1 } , { 0x0212 , 529 , 1 } , { 0xaba1 , 1595 , 1 } , { 0x10a3 , 2754 , 1 } , { 0x10ca1 , 3456 , 1 } , { 0x01d3 , 438 , 1 } , { 0x1fd3 , 25 , 3 } , { 0x0210 , 526 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x00d3 , 135 , 1 } , { 0x1e97 , 34 , 2 } , { 0x10a1 , 2748 , 1 } , { 0x0197 , 649 , 1 } , { 0x1f97 , 204 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x0397 , 759 , 1 } , { 0x1041d , 3324 , 1 } , { 0xab97 , 1565 , 1 } , { 0x041d , 929 , 1 } , { 0x10c97 , 3426 , 1 } , { 0x1f1d , 2121 , 1 } , { 0x2c1d , 2508 , 1 } , { 0x1e72 , 1884 , 1 } , { 0x0472 , 1061 , 1 } , { 0x0172 , 336 , 1 } , { 0x118b3 , 3567 , 1 } , { 0x2c72 , 2580 , 1 } , { 0x0372 , 712 , 1 } , { 0x1041b , 3318 , 1 } , { 0xab72 , 1454 , 1 } , { 0x041b , 923 , 1 } , { 0x118a5 , 3525 , 1 } , { 0x1f1b , 2115 , 1 } , { 0x2c1b , 2502 , 1 } , { 0x1e70 , 1881 , 1 } , { 0x0470 , 1058 , 1 } , { 0x0170 , 333 , 1 } , { 0x118b1 , 3561 , 1 } , { 0x2c70 , 610 , 1 } , { 0x0370 , 709 , 1 } , { 0x1e46 , 1817 , 1 } , { 0xab70 , 1448 , 1 } , { 0x1e66 , 1866 , 1 } , { 0x0466 , 1043 , 1 } , { 0x0166 , 318 , 1 } , { 0x1e44 , 1814 , 1 } , { 0x0046 , 15 , 1 } , { 0x118af , 3555 , 1 } , { 0xa746 , 3027 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa766 , 3075 , 1 } , { 0x0044 , 9 , 1 } , { 0x118ad , 3549 , 1 } , { 0xa744 , 3024 , 1 } , { 0x1e7a , 1896 , 1 } , { 0x047a , 1073 , 1 } , { 0x1e3a , 1799 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa646 , 2874 , 1 } , { 0x1f3a , 2154 , 1 } , { 0xa666 , 2922 , 1 } , { 0xab7a , 1478 , 1 } , { 0x118a3 , 3519 , 1 } , { 0xa644 , 2871 , 1 } , { 0xa73a , 3009 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1ef4 , 2064 , 1 } , { 0x04f4 , 1244 , 1 } , { 0x01f4 , 487 , 1 } , { 0x1ff4 , 101 , 2 } , { 0x118a1 , 3513 , 1 } , { 0x03f4 , 762 , 1 } , { 0x1eec , 2052 , 1 } , { 0x04ec , 1232 , 1 } , { 0x01ec , 477 , 1 } , { 0x1fec , 2286 , 1 } , { 0x0546 , 1397 , 1 } , { 0x03ec , 872 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x013f , 261 , 1 } , { 0x1f3f , 2169 , 1 } , { 0x0544 , 1391 , 1 } , { 0x1eea , 2049 , 1 } , { 0x04ea , 1229 , 1 } , { 0x01ea , 474 , 1 } , { 0x1fea , 2256 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x03ea , 869 , 1 } , { 0x1ee8 , 2046 , 1 } , { 0x04e8 , 1226 , 1 } , { 0x01e8 , 471 , 1 } , { 0x1fe8 , 2280 , 1 } , { 0x053a , 1361 , 1 } , { 0x03e8 , 866 , 1 } , { 0x1ee6 , 2043 , 1 } , { 0x04e6 , 1223 , 1 } , { 0x01e6 , 468 , 1 } , { 0x1fe6 , 88 , 2 } , { 0x1f4b , 2181 , 1 } , { 0x03e6 , 863 , 1 } , { 0x1e5e , 1853 , 1 } , { 0x004b , 27 , 1 } , { 0x015e , 306 , 1 } , { 0x2166 , 2310 , 1 } , { 0x1ee4 , 2040 , 1 } , { 0x04e4 , 1220 , 1 } , { 0x01e4 , 465 , 1 } , { 0x1fe4 , 80 , 2 } , { 0xa75e , 3063 , 1 } , { 0x03e4 , 860 , 1 } , { 0x1ee0 , 2034 , 1 } , { 0x04e0 , 1214 , 1 } , { 0x01e0 , 459 , 1 } , { 0x053f , 1376 , 1 } , { 0x2ce0 , 2730 , 1 } , { 0x03e0 , 854 , 1 } , { 0x1edc , 2028 , 1 } , { 0x04dc , 1208 , 1 } , { 0xa65e , 2910 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2cdc , 2724 , 1 } , { 0x03dc , 848 , 1 } , { 0x00dc , 159 , 1 } , { 0x1ed0 , 2010 , 1 } , { 0x04d0 , 1190 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x2cd0 , 2706 , 1 } , { 0x03d0 , 742 , 1 } , { 0x00d0 , 126 , 1 } , { 0x1ecc , 2004 , 1 } , { 0x054b , 1412 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fcc , 71 , 2 } , { 0x2ccc , 2700 , 1 } , { 0x1ec6 , 1995 , 1 } , { 0x00cc , 114 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fc6 , 67 , 2 } , { 0x2cc6 , 2691 , 1 } , { 0x24c8 , 2397 , 1 } , { 0x00c6 , 96 , 1 } , { 0x04c5 , 1172 , 1 } , { 0x01c5 , 417 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fbb , 2229 , 1 } , { 0x24c7 , 2394 , 1 } , { 0x00c5 , 92 , 1 } , { 0x1fb9 , 2271 , 1 } , { 0xabbb , 1673 , 1 } , { 0x24c0 , 2373 , 1 } , { 0x04c3 , 1169 , 1 } , { 0xabb9 , 1667 , 1 } , { 0x1fc3 , 71 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x00c3 , 86 , 1 } , { 0x10c5 , 2856 , 1 } , { 0x10bb , 2826 , 1 } , { 0x1ed4 , 2016 , 1 } , { 0x04d4 , 1196 , 1 } , { 0x10b9 , 2820 , 1 } , { 0x13fc , 1700 , 1 } , { 0x2cd4 , 2712 , 1 } , { 0x0246 , 589 , 1 } , { 0x00d4 , 138 , 1 } , { 0x10c3 , 2850 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xff3a , 3234 , 1 } , { 0x0244 , 688 , 1 } , { 0x019f , 670 , 1 } , { 0x1f9f , 204 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x039f , 789 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab9f , 1589 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c9f , 3450 , 1 } , { 0x019d , 667 , 1 } , { 0x1f9d , 194 , 2 } , { 0x023a , 2565 , 1 } , { 0x039d , 783 , 1 } , { 0x1e5a , 1847 , 1 } , { 0xab9d , 1583 , 1 } , { 0x015a , 300 , 1 } , { 0x10c9d , 3444 , 1 } , { 0x1e9b , 1856 , 1 } , { 0x24cd , 2412 , 1 } , { 0x005a , 74 , 1 } , { 0x1f9b , 184 , 2 } , { 0xa75a , 3057 , 1 } , { 0x039b , 776 , 1 } , { 0x1ece , 2007 , 1 } , { 0xab9b , 1577 , 1 } , { 0x1e99 , 42 , 2 } , { 0x10c9b , 3438 , 1 } , { 0x2cce , 2703 , 1 } , { 0x1f99 , 174 , 2 } , { 0x00ce , 120 , 1 } , { 0x0399 , 767 , 1 } , { 0xa65a , 2904 , 1 } , { 0xab99 , 1571 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c99 , 3432 , 1 } , { 0x0193 , 634 , 1 } , { 0x1f93 , 184 , 2 } , { 0x1e58 , 1844 , 1 } , { 0x0393 , 746 , 1 } , { 0x0158 , 297 , 1 } , { 0xab93 , 1553 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c93 , 3414 , 1 } , { 0x0058 , 68 , 1 } , { 0x042d , 977 , 1 } , { 0xa758 , 3054 , 1 } , { 0x1f2d , 2139 , 1 } , { 0x2c2d , 2556 , 1 } , { 0x118bb , 3591 , 1 } , { 0x0191 , 369 , 1 } , { 0x1f91 , 174 , 2 } , { 0x118b9 , 3585 , 1 } , { 0x0391 , 739 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab91 , 1547 , 1 } , { 0xa658 , 2901 , 1 } , { 0x10c91 , 3408 , 1 } , { 0x018f , 625 , 1 } , { 0x1f8f , 164 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x038f , 836 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab8f , 1541 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c8f , 3402 , 1 } , { 0x018b , 366 , 1 } , { 0x1f8b , 144 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x0187 , 363 , 1 } , { 0x1f87 , 164 , 2 } , { 0xab8b , 1529 , 1 } , { 0xa78b , 3111 , 1 } , { 0x10c8b , 3390 , 1 } , { 0xab87 , 1517 , 1 } , { 0x04c1 , 1166 , 1 } , { 0x10c87 , 3378 , 1 } , { 0x1e7e , 1902 , 1 } , { 0x047e , 1079 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x00c1 , 80 , 1 } , { 0x2c7e , 580 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xab7e , 1490 , 1 } , { 0xa77e , 3096 , 1 } , { 0x1e76 , 1890 , 1 } , { 0x0476 , 1067 , 1 } , { 0x0176 , 342 , 1 } , { 0x1e42 , 1811 , 1 } , { 0x10c1 , 2844 , 1 } , { 0x0376 , 715 , 1 } , { 0x1e36 , 1793 , 1 } , { 0xab76 , 1466 , 1 } , { 0x0136 , 249 , 1 } , { 0x0042 , 3 , 1 } , { 0x1e3e , 1805 , 1 } , { 0xa742 , 3021 , 1 } , { 0x1e38 , 1796 , 1 } , { 0x1f3e , 2166 , 1 } , { 0xa736 , 3003 , 1 } , { 0x1f38 , 2148 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0587 , 105 , 2 } , { 0xa73e , 3015 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa738 , 3006 , 1 } , { 0xa642 , 2868 , 1 } , { 0x1e5c , 1850 , 1 } , { 0x1e34 , 1790 , 1 } , { 0x015c , 303 , 1 } , { 0x0134 , 246 , 1 } , { 0x1ef6 , 2067 , 1 } , { 0x04f6 , 1247 , 1 } , { 0x01f6 , 372 , 1 } , { 0x1ff6 , 92 , 2 } , { 0xa75c , 3060 , 1 } , { 0xa734 , 3000 , 1 } , { 0x1ef0 , 2058 , 1 } , { 0x04f0 , 1238 , 1 } , { 0x01f0 , 20 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x1e30 , 1784 , 1 } , { 0x03f0 , 772 , 1 } , { 0x0130 , 261 , 2 } , { 0x0542 , 1385 , 1 } , { 0xa65c , 2907 , 1 } , { 0x1f83 , 144 , 2 } , { 0x0536 , 1349 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xab83 , 1505 , 1 } , { 0x053e , 1373 , 1 } , { 0x10c83 , 3366 , 1 } , { 0x0538 , 1355 , 1 } , { 0x1eee , 2055 , 1 } , { 0x04ee , 1235 , 1 } , { 0x01ee , 480 , 1 } , { 0x1f8d , 154 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x03ee , 875 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab8d , 1535 , 1 } , { 0xa78d , 643 , 1 } , { 0x10c8d , 3396 , 1 } , { 0x0534 , 1343 , 1 } , { 0x0181 , 613 , 1 } , { 0x1f81 , 134 , 2 } , { 0x013d , 258 , 1 } , { 0x1f3d , 2163 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab81 , 1499 , 1 } , { 0x017f , 52 , 1 } , { 0x10c81 , 3360 , 1 } , { 0x2c7f , 583 , 1 } , { 0x037f , 881 , 1 } , { 0xff2d , 3195 , 1 } , { 0xab7f , 1493 , 1 } , { 0x1e74 , 1887 , 1 } , { 0x0474 , 1064 , 1 } , { 0x0174 , 339 , 1 } , { 0x1e3c , 1802 , 1 } , { 0x0149 , 46 , 2 } , { 0x1f49 , 2175 , 1 } , { 0x1f3c , 2160 , 1 } , { 0xab74 , 1460 , 1 } , { 0x0049 , 3606 , 1 } , { 0x0143 , 267 , 1 } , { 0x24cc , 2409 , 1 } , { 0xa73c , 3012 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0043 , 6 , 1 } , { 0x0141 , 264 , 1 } , { 0x24c6 , 2391 , 1 } , { 0x013b , 255 , 1 } , { 0x1f3b , 2157 , 1 } , { 0x0041 , 0 , 1 } , { 0x0139 , 252 , 1 } , { 0x1f39 , 2151 , 1 } , { 0x24c5 , 2388 , 1 } , { 0x24bb , 2358 , 1 } , { 0x13fa , 1694 , 1 } , { 0x053d , 1370 , 1 } , { 0x24b9 , 2352 , 1 } , { 0x0429 , 965 , 1 } , { 0x2183 , 2340 , 1 } , { 0x1f29 , 2127 , 1 } , { 0x2c29 , 2544 , 1 } , { 0x24c3 , 2382 , 1 } , { 0x10427 , 3354 , 1 } , { 0x10425 , 3348 , 1 } , { 0x0427 , 959 , 1 } , { 0x0425 , 953 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c27 , 2538 , 1 } , { 0x2c25 , 2532 , 1 } , { 0x0549 , 1406 , 1 } , { 0x053c , 1367 , 1 } , { 0x10423 , 3342 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0423 , 947 , 1 } , { 0x0543 , 1388 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c23 , 2526 , 1 } , { 0xff36 , 3222 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0541 , 1382 , 1 } , { 0x10421 , 3336 , 1 } , { 0x053b , 1364 , 1 } , { 0x0421 , 941 , 1 } , { 0xff38 , 3228 , 1 } , { 0x0539 , 1358 , 1 } , { 0x2c21 , 2520 , 1 } , { 0x10419 , 3312 , 1 } , { 0x10417 , 3306 , 1 } , { 0x0419 , 917 , 1 } , { 0x0417 , 911 , 1 } , { 0x1f19 , 2109 , 1 } , { 0x2c19 , 2496 , 1 } , { 0x2c17 , 2490 , 1 } , { 0x023e , 2568 , 1 } , { 0xff34 , 3216 , 1 } , { 0x10415 , 3300 , 1 } , { 0x10413 , 3294 , 1 } , { 0x0415 , 905 , 1 } , { 0x0413 , 899 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c15 , 2484 , 1 } , { 0x2c13 , 2478 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x24ce , 2415 , 1 } , { 0x1040f , 3282 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x040f , 1031 , 1 } , { 0xff30 , 3204 , 1 } , { 0x1f0f , 2103 , 1 } , { 0x2c0f , 2466 , 1 } , { 0x1040d , 3276 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x040d , 1025 , 1 } , { 0x0147 , 273 , 1 } , { 0x1f0d , 2097 , 1 } , { 0x2c0d , 2460 , 1 } , { 0x1040b , 3270 , 1 } , { 0x0047 , 18 , 1 } , { 0x040b , 1019 , 1 } , { 0x0230 , 571 , 1 } , { 0x1f0b , 2091 , 1 } , { 0x2c0b , 2454 , 1 } , { 0x10409 , 3264 , 1 } , { 0x10405 , 3252 , 1 } , { 0x0409 , 1013 , 1 } , { 0x0405 , 1001 , 1 } , { 0x1f09 , 2085 , 1 } , { 0x2c09 , 2448 , 1 } , { 0x2c05 , 2436 , 1 } , { 0x10403 , 3246 , 1 } , { 0x10401 , 3240 , 1 } , { 0x0403 , 995 , 1 } , { 0x0401 , 989 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c03 , 2430 , 1 } , { 0x2c01 , 2424 , 1 } , { 0x13f9 , 1691 , 1 } , { 0x042f , 983 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1f2f , 2145 , 1 } , { 0x1041f , 3330 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x041f , 935 , 1 } , { 0x023d , 378 , 1 } , { 0x10411 , 3288 , 1 } , { 0x2c1f , 2514 , 1 } , { 0x0411 , 893 , 1 } , { 0x0547 , 1400 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c11 , 2472 , 1 } , { 0x10407 , 3258 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0407 , 1007 , 1 } , { 0x24c1 , 2376 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c07 , 2442 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x13f8 , 1688 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff39 , 3231 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0243 , 354 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x0241 , 586 , 1 } , { 0xff29 , 3183 , 1 } , { 0x023b , 577 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff27 , 3177 , 1 } , { 0xff25 , 3171 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff23 , 3165 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff21 , 3159 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb17 , 117 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff2f , 3201 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb15 , 113 , 2 } , { 0xfb13 , 121 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb05 , 29 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb03 , 0 , 3 } , { 0xfb01 , 8 , 2 } } ; if ( 0 == 0 ) { int key = hash ( & code ) ; if ( key <= MAX_HASH_VALUE && key >= 0 ) { OnigCodePoint gcode = wordlist [ key ] . code ; if ( code == gcode ) return & wordlist [ key ] ; } } return 0 ; }
","<S2SV_ModStart> code == gcode && wordlist [ key ] . index >= 0
",kkos@oniguruma/166a6c3999bf06b4de0ab4ce6b088a468cc4029f,CVE-2017-9225,https://github.com/kkos/oniguruma/commit/166a6c3999bf06b4de0ab4ce6b088a468cc4029f,2017-05-24T15:29Z,<S2SV_StartBug> if ( code == gcode ) <S2SV_EndBug>
4064,CWE-119,"static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ; int number_extensionss = 0 ; MagickBooleanType status ; RectangleInfo page ; register ssize_t i ; register unsigned char * p ; size_t delay , dispose , duration , global_colors , image_count , iterations , one ; ssize_t count , opacity ; unsigned char background , c , flag , * global_colormap , header [ MaxTextExtent ] , magick [ 12 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 6 , magick ) ; if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) magick , ""GIF87"" , 5 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""GIF89"" , 5 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; page . width = ReadBlobLSBShort ( image ) ; page . height = ReadBlobLSBShort ( image ) ; flag = ( unsigned char ) ReadBlobByte ( image ) ; background = ( unsigned char ) ReadBlobByte ( image ) ; c = ( unsigned char ) ReadBlobByte ( image ) ; one = 1 ; global_colors = one << ( ( ( size_t ) flag & 0x07 ) + 1 ) ; global_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( global_colors , 256 ) , 3UL * sizeof ( * global_colormap ) ) ; if ( global_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) count = ReadBlob ( image , ( size_t ) ( 3 * global_colors ) , global_colormap ) ; delay = 0 ; dispose = 0 ; duration = 0 ; iterations = 1 ; opacity = ( - 1 ) ; image_count = 0 ; meta_image = AcquireImage ( image_info ) ; for ( ; ; ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) break ; if ( c == ( unsigned char ) ';' ) break ; if ( c == ( unsigned char ) '!' ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadExtensionBlock"" ) ; } switch ( c ) { case 0xf9 : { while ( ReadBlobBlock ( image , header ) != 0 ) ; dispose = ( size_t ) ( header [ 0 ] >> 2 ) ; delay = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ; if ( ( ssize_t ) ( header [ 0 ] & 0x01 ) == 0x01 ) opacity = ( ssize_t ) header [ 3 ] ; break ; } case 0xfe : { char * comments ; size_t length ; comments = AcquireString ( ( char * ) NULL ) ; for ( length = 0 ; ; length += count ) { count = ( ssize_t ) ReadBlobBlock ( image , header ) ; if ( count == 0 ) break ; header [ count ] = '\\0' ; ( void ) ConcatenateString ( & comments , ( const char * ) header ) ; } ( void ) SetImageProperty ( meta_image , ""comment"" , comments ) ; comments = DestroyString ( comments ) ; break ; } case 0xff : { MagickBooleanType loop ; loop = MagickFalse ; if ( ReadBlobBlock ( image , header ) != 0 ) loop = LocaleNCompare ( ( char * ) header , ""NETSCAPE2.0"" , 11 ) == 0 ? MagickTrue : MagickFalse ; if ( loop != MagickFalse ) { while ( ReadBlobBlock ( image , header ) != 0 ) iterations = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ; break ; } else { char name [ MaxTextExtent ] ; int block_length , info_length , reserved_length ; MagickBooleanType i8bim , icc , iptc , magick ; StringInfo * profile ; unsigned char * info ; icc = LocaleNCompare ( ( char * ) header , ""ICCRGBG1012"" , 11 ) == 0 ? MagickTrue : MagickFalse ; magick = LocaleNCompare ( ( char * ) header , ""ImageMagick"" , 11 ) == 0 ? MagickTrue : MagickFalse ; i8bim = LocaleNCompare ( ( char * ) header , ""MGK8BIM0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; iptc = LocaleNCompare ( ( char * ) header , ""MGKIPTC0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; number_extensionss ++ ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Reading<S2SV_blank>GIF<S2SV_blank>application<S2SV_blank>extension"" ) ; info = ( unsigned char * ) AcquireQuantumMemory ( 255UL , sizeof ( * info ) ) ; reserved_length = 255 ; for ( info_length = 0 ; ; ) { block_length = ( int ) ReadBlobBlock ( image , & info [ info_length ] ) ; if ( block_length == 0 ) break ; info_length += block_length ; if ( info_length > ( reserved_length - 255 ) ) { reserved_length += 4096 ; info = ( unsigned char * ) ResizeQuantumMemory ( info , ( size_t ) reserved_length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } } profile = BlobToStringInfo ( info , ( size_t ) info_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( i8bim != MagickFalse ) ( void ) CopyMagickString ( name , ""8bim"" , sizeof ( name ) ) ; else if ( icc != MagickFalse ) ( void ) CopyMagickString ( name , ""icc"" , sizeof ( name ) ) ; else if ( iptc != MagickFalse ) ( void ) CopyMagickString ( name , ""iptc"" , sizeof ( name ) ) ; else if ( magick != MagickFalse ) { ( void ) CopyMagickString ( name , ""magick"" , sizeof ( name ) ) ; image -> gamma = StringToDouble ( ( char * ) info + 6 , ( char * * ) NULL ) ; } else ( void ) FormatLocaleString ( name , sizeof ( name ) , ""gif:%.11s"" , header ) ; info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; if ( magick == MagickFalse ) ( void ) SetImageProfile ( meta_image , name , profile ) ; profile = DestroyStringInfo ( profile ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>profile<S2SV_blank>name=%s"" , name ) ; } break ; } default : { while ( ReadBlobBlock ( image , header ) != 0 ) ; break ; } } } if ( c != ( unsigned char ) ',' ) continue ; if ( image_count != 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; } image_count ++ ; meta_image -> scene = image -> scene ; CloneImageProperties ( image , meta_image ) ; DestroyImageProperties ( meta_image ) ; CloneImageProfiles ( image , meta_image ) ; DestroyImageProfiles ( meta_image ) ; image -> storage_class = PseudoClass ; image -> compression = LZWCompression ; page . x = ( ssize_t ) ReadBlobLSBShort ( image ) ; page . y = ( ssize_t ) ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; image -> depth = 8 ; flag = ( unsigned char ) ReadBlobByte ( image ) ; image -> interlace = BitSet ( ( int ) flag , 0x40 ) != 0 ? GIFInterlace : NoInterlace ; image -> colors = BitSet ( ( int ) flag , 0x80 ) == 0 ? global_colors : one << ( ( size_t ) ( flag & 0x07 ) + 1 ) ; if ( opacity >= ( ssize_t ) image -> colors ) opacity = ( - 1 ) ; image -> page . width = page . width ; image -> page . height = page . height ; image -> page . y = page . y ; image -> page . x = page . x ; image -> delay = delay ; image -> iterations = iterations ; image -> ticks_per_second = 100 ; image -> dispose = ( DisposeType ) dispose ; image -> matte = opacity >= 0 ? MagickTrue : MagickFalse ; delay = 0 ; dispose = 0 ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; } if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } if ( BitSet ( ( int ) flag , 0x80 ) == 0 ) { p = global_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) { image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ; image -> transparent_color = image -> colormap [ opacity ] ; } } image -> background_color = image -> colormap [ MagickMin ( background , image -> colors - 1 ) ] ; } else { unsigned char * colormap ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , 3 * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } count = ReadBlob ( image , ( 3 * image -> colors ) * sizeof ( * colormap ) , colormap ) ; if ( count != ( ssize_t ) ( 3 * image -> colors ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ; } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } if ( image -> gamma == 1.0 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) if ( IsGrayPixel ( image -> colormap + i ) == MagickFalse ) break ; ( void ) SetImageColorspace ( image , i == ( ssize_t ) image -> colors ? GRAYColorspace : RGBColorspace ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( image_info -> ping != MagickFalse ) status = PingGIFImage ( image ) ; else status = DecodeImage ( image , opacity ) ; if ( ( image_info -> ping == MagickFalse ) && ( status == MagickFalse ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } duration += image -> delay * image -> iterations ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; opacity = ( - 1 ) ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) image -> scene - 1 , image -> scene ) ; if ( status == MagickFalse ) break ; } image -> duration = duration ; meta_image = DestroyImage ( meta_image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,<S2SV_StartBug> if ( image_info -> ping != MagickFalse ) <S2SV_EndBug>
1334,CWE-119,"int main ( int argc , char * * argv ) { FILE * infile = NULL ; vpx_codec_ctx_t codec = { 0 } ; vpx_codec_enc_cfg_t cfg = { 0 } ; int frame_count = 0 ; vpx_image_t raw = { 0 } ; vpx_codec_err_t res ; VpxVideoInfo info = { 0 } ; VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; const int fps = 2 ; const double bits_per_pixel_per_frame = 0.067 ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ; encoder = get_vpx_encoder_by_name ( argv [ 1 ] ) ; if ( ! encoder ) die ( ""Unsupported<S2SV_blank>codec."" ) ; info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( argv [ 2 ] , NULL , 0 ) ; info . frame_height = strtol ( argv [ 3 ] , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image."" ) ; } printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = ( unsigned int ) ( bits_per_pixel_per_frame * cfg . g_w * cfg . g_h * fps / 1000 ) ; cfg . g_lag_in_frames = 0 ; writer = vpx_video_writer_open ( argv [ 5 ] , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 5 ] ) ; if ( ! ( infile = fopen ( argv [ 4 ] , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 4 ] ) ; if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; while ( vpx_img_read ( & raw , infile ) ) { ++ frame_count ; if ( frame_count == 22 && encoder -> fourcc == VP8_FOURCC ) { set_roi_map ( & cfg , & codec ) ; } else if ( frame_count == 33 ) { set_active_map ( & cfg , & codec ) ; } else if ( frame_count == 44 ) { unset_active_map ( & cfg , & codec ) ; } encode_frame ( & codec , & raw , frame_count , writer ) ; } encode_frame ( & codec , NULL , - 1 , writer ) ; printf ( ""\\n"" ) ; fclose ( infile ) ; printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_count ) ; vpx_img_free ( & raw ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }
","<S2SV_ModStart> ; vpx_codec_ctx_t codec <S2SV_ModEnd> ; vpx_codec_enc_cfg_t cfg <S2SV_ModStart> ; vpx_codec_enc_cfg_t cfg <S2SV_ModEnd> ; int frame_count <S2SV_ModStart> ; vpx_image_t raw <S2SV_ModEnd> ; vpx_codec_err_t res <S2SV_ModStart> ; VpxVideoInfo info <S2SV_ModEnd> ; VpxVideoWriter * <S2SV_ModStart> ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ; memset ( & info , 0 , sizeof ( info ) ) ; <S2SV_ModStart> ; if ( encoder == NULL ) { <S2SV_ModEnd> die ( ""Unsupported<S2SV_blank>codec."" <S2SV_ModStart> die ( ""Unsupported<S2SV_blank>codec."" ) ; } assert ( encoder != NULL <S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> , encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> ) ; } while ( <S2SV_ModStart> , writer ) ) { } <S2SV_ModEnd> printf ( ""\\n""
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_codec_ctx_t codec = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_enc_cfg_t cfg = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> vpx_image_t raw = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> VpxVideoInfo info = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> encoder = get_vpx_encoder_by_name ( argv [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! encoder ) <S2SV_EndBug> <S2SV_StartBug> die ( ""Unsupported<S2SV_blank>codec."" ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , writer ) ; <S2SV_EndBug>"
3818,CWE-77,"void imap_quote_string ( char * dest , size_t dlen , const char * src ) { static const char quote [ ] = ""\\""\\\\"" ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { dlen -= 2 ; if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }
","<S2SV_ModStart> char * src , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> ; char *
",neomutt@neomutt/e52393740334443ae0206cab2d7caef381646725,CVE-2018-14357,https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725,2018-07-17T17:29Z,"<S2SV_StartBug> void imap_quote_string ( char * dest , size_t dlen , const char * src ) <S2SV_EndBug>"
1162,CWE-862,"static struct key * construct_key_and_link ( struct keyring_search_context * ctx , const char * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct key_user * user ; struct key * key ; int ret ; kenter ( """" ) ; if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ; user = key_user_lookup ( current_fsuid ( ) ) ; if ( ! user ) return ERR_PTR ( - ENOMEM ) ; construct_get_dest_keyring ( & dest_keyring ) ; ret = construct_alloc_key ( ctx , dest_keyring , flags , user , & key ) ; key_user_put ( user ) ; if ( ret == 0 ) { ret = construct_key ( key , callout_info , callout_len , aux , dest_keyring ) ; if ( ret < 0 ) { kdebug ( ""cons<S2SV_blank>failed"" ) ; goto construction_failed ; } } else if ( ret == - EINPROGRESS ) { ret = 0 ; } else { goto couldnt_alloc_key ; } key_put ( dest_keyring ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>key<S2SV_blank>%d"" , key_serial ( key ) ) ; return key ; construction_failed : key_negate_and_link ( key , key_negative_timeout , NULL , NULL ) ; key_put ( key ) ; couldnt_alloc_key : key_put ( dest_keyring ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ERR_PTR ( ret ) ; }
","<S2SV_ModStart> EPERM ) ; ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> ! user ) { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> ret = construct_alloc_key <S2SV_ModStart> else { goto error_put_dest_keyring <S2SV_ModEnd> ; } key_put <S2SV_ModStart> key ) ; error_put_dest_keyring <S2SV_ModEnd> : key_put ( <S2SV_ModStart> dest_keyring ) ; error :
",torvalds@linux/4dca6ea1d9432052afb06baf2e3ae78188a4410b,CVE-2017-17807,https://github.com/torvalds/linux/commit/4dca6ea1d9432052afb06baf2e3ae78188a4410b,2017-12-20T23:29Z,<S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ERR_PTR ( - ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> goto couldnt_alloc_key ; <S2SV_EndBug> <S2SV_StartBug> couldnt_alloc_key : <S2SV_EndBug> <S2SV_StartBug> key_put ( dest_keyring ) ; <S2SV_EndBug>
4855,CWE-22,"static int target_xcopy_locate_se_dev_e4_iter ( struct se_device * se_dev , void * data ) { struct xcopy_dev_search_info * info = data ; unsigned char tmp_dev_wwn [ XCOPY_NAA_IEEE_REGEX_LEN ] ; int rc ; if ( ! se_dev -> dev_attrib . emulate_3pc ) return 0 ; memset ( & tmp_dev_wwn [ 0 ] , 0 , XCOPY_NAA_IEEE_REGEX_LEN ) ; target_xcopy_gen_naa_ieee ( se_dev , & tmp_dev_wwn [ 0 ] ) ; rc = memcmp ( & tmp_dev_wwn [ 0 ] , info -> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN ) ; if ( rc != 0 ) return 0 ; info -> found_dev = se_dev ; pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" , se_dev ) ; rc = target_depend_item ( & se_dev -> dev_group . cg_item ) ; if ( rc != 0 ) { pr_err ( ""configfs_depend_item<S2SV_blank>attempt<S2SV_blank>failed:<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" , rc , se_dev ) ; return rc ; } pr_debug ( ""Called<S2SV_blank>configfs_depend_item<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\n"" , se_dev , & se_dev -> dev_group ) ; return 1 ; }
","<S2SV_ModStart> * se_dev , const unsigned char * dev_wwn ) { <S2SV_ModEnd> unsigned char tmp_dev_wwn <S2SV_ModStart> . emulate_3pc ) { pr_debug ( ""XCOPY:<S2SV_blank>emulate_3pc<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>se_dev<S2SV_blank>%p\\n"" , se_dev ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> 0 ] , <S2SV_ModEnd> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN <S2SV_ModStart> != 0 ) { pr_debug ( ""XCOPY:<S2SV_blank>skip<S2SV_blank>non-matching:<S2SV_blank>%*ph\\n"" , XCOPY_NAA_IEEE_REGEX_LEN , tmp_dev_wwn ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModEnd> pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" <S2SV_ModStart> se_dev ) ; <S2SV_ModEnd> return 1 ;
",torvalds@linux/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,CVE-2020-28374,https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,2021-01-13T04:15Z,"<S2SV_StartBug> void * data ) <S2SV_EndBug> <S2SV_StartBug> if ( ! se_dev -> dev_attrib . emulate_3pc ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> rc = memcmp ( & tmp_dev_wwn [ 0 ] , info -> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc != 0 ) <S2SV_EndBug> <S2SV_StartBug> info -> found_dev = se_dev ; <S2SV_EndBug> <S2SV_StartBug> rc = target_depend_item ( & se_dev -> dev_group . cg_item ) ; <S2SV_EndBug>"
528,CWE-125,"INST_HANDLER ( sbrx ) { int b = buf [ 0 ] & 0x7 ; int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ; RAnalOp next_op ; avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""%d,1,<<,r%d,&,"" , b , r ) ; ESIL_A ( ( buf [ 1 ] & 0xe ) == 0xc ? ""!,"" : ""!,!,"" ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }
","<S2SV_ModStart> ; RAnalOp next_op = { 0 }
",radare@radare2/25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4,CVE-2018-11377,https://github.com/radare/radare2/commit/25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4,2018-05-22T19:29Z,<S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug>
1916,CWE-119,"void fadst8_sse2 ( __m128i * in ) { const __m128i k__cospi_p02_p30 = pair_set_epi16 ( cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_p30_m02 = pair_set_epi16 ( cospi_30_64 , - cospi_2_64 ) ; const __m128i k__cospi_p10_p22 = pair_set_epi16 ( cospi_10_64 , cospi_22_64 ) ; const __m128i k__cospi_p22_m10 = pair_set_epi16 ( cospi_22_64 , - cospi_10_64 ) ; const __m128i k__cospi_p18_p14 = pair_set_epi16 ( cospi_18_64 , cospi_14_64 ) ; const __m128i k__cospi_p14_m18 = pair_set_epi16 ( cospi_14_64 , - cospi_18_64 ) ; const __m128i k__cospi_p26_p06 = pair_set_epi16 ( cospi_26_64 , cospi_6_64 ) ; const __m128i k__cospi_p06_m26 = pair_set_epi16 ( cospi_6_64 , - cospi_26_64 ) ; const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ; const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; const __m128i k__const_0 = _mm_set1_epi16 ( 0 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; __m128i u0 , u1 , u2 , u3 , u4 , u5 , u6 , u7 , u8 , u9 , u10 , u11 , u12 , u13 , u14 , u15 ; __m128i v0 , v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 ; __m128i w0 , w1 , w2 , w3 , w4 , w5 , w6 , w7 , w8 , w9 , w10 , w11 , w12 , w13 , w14 , w15 ; __m128i s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; __m128i in0 , in1 , in2 , in3 , in4 , in5 , in6 , in7 ; in0 = in [ 7 ] ; in1 = in [ 0 ] ; in2 = in [ 5 ] ; in3 = in [ 2 ] ; in4 = in [ 3 ] ; in5 = in [ 4 ] ; in6 = in [ 1 ] ; in7 = in [ 6 ] ; s0 = _mm_unpacklo_epi16 ( in0 , in1 ) ; s1 = _mm_unpackhi_epi16 ( in0 , in1 ) ; s2 = _mm_unpacklo_epi16 ( in2 , in3 ) ; s3 = _mm_unpackhi_epi16 ( in2 , in3 ) ; s4 = _mm_unpacklo_epi16 ( in4 , in5 ) ; s5 = _mm_unpackhi_epi16 ( in4 , in5 ) ; s6 = _mm_unpacklo_epi16 ( in6 , in7 ) ; s7 = _mm_unpackhi_epi16 ( in6 , in7 ) ; u0 = _mm_madd_epi16 ( s0 , k__cospi_p02_p30 ) ; u1 = _mm_madd_epi16 ( s1 , k__cospi_p02_p30 ) ; u2 = _mm_madd_epi16 ( s0 , k__cospi_p30_m02 ) ; u3 = _mm_madd_epi16 ( s1 , k__cospi_p30_m02 ) ; u4 = _mm_madd_epi16 ( s2 , k__cospi_p10_p22 ) ; u5 = _mm_madd_epi16 ( s3 , k__cospi_p10_p22 ) ; u6 = _mm_madd_epi16 ( s2 , k__cospi_p22_m10 ) ; u7 = _mm_madd_epi16 ( s3 , k__cospi_p22_m10 ) ; u8 = _mm_madd_epi16 ( s4 , k__cospi_p18_p14 ) ; u9 = _mm_madd_epi16 ( s5 , k__cospi_p18_p14 ) ; u10 = _mm_madd_epi16 ( s4 , k__cospi_p14_m18 ) ; u11 = _mm_madd_epi16 ( s5 , k__cospi_p14_m18 ) ; u12 = _mm_madd_epi16 ( s6 , k__cospi_p26_p06 ) ; u13 = _mm_madd_epi16 ( s7 , k__cospi_p26_p06 ) ; u14 = _mm_madd_epi16 ( s6 , k__cospi_p06_m26 ) ; u15 = _mm_madd_epi16 ( s7 , k__cospi_p06_m26 ) ; w0 = _mm_add_epi32 ( u0 , u8 ) ; w1 = _mm_add_epi32 ( u1 , u9 ) ; w2 = _mm_add_epi32 ( u2 , u10 ) ; w3 = _mm_add_epi32 ( u3 , u11 ) ; w4 = _mm_add_epi32 ( u4 , u12 ) ; w5 = _mm_add_epi32 ( u5 , u13 ) ; w6 = _mm_add_epi32 ( u6 , u14 ) ; w7 = _mm_add_epi32 ( u7 , u15 ) ; w8 = _mm_sub_epi32 ( u0 , u8 ) ; w9 = _mm_sub_epi32 ( u1 , u9 ) ; w10 = _mm_sub_epi32 ( u2 , u10 ) ; w11 = _mm_sub_epi32 ( u3 , u11 ) ; w12 = _mm_sub_epi32 ( u4 , u12 ) ; w13 = _mm_sub_epi32 ( u5 , u13 ) ; w14 = _mm_sub_epi32 ( u6 , u14 ) ; w15 = _mm_sub_epi32 ( u7 , u15 ) ; v0 = _mm_add_epi32 ( w0 , k__DCT_CONST_ROUNDING ) ; v1 = _mm_add_epi32 ( w1 , k__DCT_CONST_ROUNDING ) ; v2 = _mm_add_epi32 ( w2 , k__DCT_CONST_ROUNDING ) ; v3 = _mm_add_epi32 ( w3 , k__DCT_CONST_ROUNDING ) ; v4 = _mm_add_epi32 ( w4 , k__DCT_CONST_ROUNDING ) ; v5 = _mm_add_epi32 ( w5 , k__DCT_CONST_ROUNDING ) ; v6 = _mm_add_epi32 ( w6 , k__DCT_CONST_ROUNDING ) ; v7 = _mm_add_epi32 ( w7 , k__DCT_CONST_ROUNDING ) ; v8 = _mm_add_epi32 ( w8 , k__DCT_CONST_ROUNDING ) ; v9 = _mm_add_epi32 ( w9 , k__DCT_CONST_ROUNDING ) ; v10 = _mm_add_epi32 ( w10 , k__DCT_CONST_ROUNDING ) ; v11 = _mm_add_epi32 ( w11 , k__DCT_CONST_ROUNDING ) ; v12 = _mm_add_epi32 ( w12 , k__DCT_CONST_ROUNDING ) ; v13 = _mm_add_epi32 ( w13 , k__DCT_CONST_ROUNDING ) ; v14 = _mm_add_epi32 ( w14 , k__DCT_CONST_ROUNDING ) ; v15 = _mm_add_epi32 ( w15 , k__DCT_CONST_ROUNDING ) ; u0 = _mm_srai_epi32 ( v0 , DCT_CONST_BITS ) ; u1 = _mm_srai_epi32 ( v1 , DCT_CONST_BITS ) ; u2 = _mm_srai_epi32 ( v2 , DCT_CONST_BITS ) ; u3 = _mm_srai_epi32 ( v3 , DCT_CONST_BITS ) ; u4 = _mm_srai_epi32 ( v4 , DCT_CONST_BITS ) ; u5 = _mm_srai_epi32 ( v5 , DCT_CONST_BITS ) ; u6 = _mm_srai_epi32 ( v6 , DCT_CONST_BITS ) ; u7 = _mm_srai_epi32 ( v7 , DCT_CONST_BITS ) ; u8 = _mm_srai_epi32 ( v8 , DCT_CONST_BITS ) ; u9 = _mm_srai_epi32 ( v9 , DCT_CONST_BITS ) ; u10 = _mm_srai_epi32 ( v10 , DCT_CONST_BITS ) ; u11 = _mm_srai_epi32 ( v11 , DCT_CONST_BITS ) ; u12 = _mm_srai_epi32 ( v12 , DCT_CONST_BITS ) ; u13 = _mm_srai_epi32 ( v13 , DCT_CONST_BITS ) ; u14 = _mm_srai_epi32 ( v14 , DCT_CONST_BITS ) ; u15 = _mm_srai_epi32 ( v15 , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u0 , u1 ) ; in [ 1 ] = _mm_packs_epi32 ( u2 , u3 ) ; in [ 2 ] = _mm_packs_epi32 ( u4 , u5 ) ; in [ 3 ] = _mm_packs_epi32 ( u6 , u7 ) ; in [ 4 ] = _mm_packs_epi32 ( u8 , u9 ) ; in [ 5 ] = _mm_packs_epi32 ( u10 , u11 ) ; in [ 6 ] = _mm_packs_epi32 ( u12 , u13 ) ; in [ 7 ] = _mm_packs_epi32 ( u14 , u15 ) ; s0 = _mm_add_epi16 ( in [ 0 ] , in [ 2 ] ) ; s1 = _mm_add_epi16 ( in [ 1 ] , in [ 3 ] ) ; s2 = _mm_sub_epi16 ( in [ 0 ] , in [ 2 ] ) ; s3 = _mm_sub_epi16 ( in [ 1 ] , in [ 3 ] ) ; u0 = _mm_unpacklo_epi16 ( in [ 4 ] , in [ 5 ] ) ; u1 = _mm_unpackhi_epi16 ( in [ 4 ] , in [ 5 ] ) ; u2 = _mm_unpacklo_epi16 ( in [ 6 ] , in [ 7 ] ) ; u3 = _mm_unpackhi_epi16 ( in [ 6 ] , in [ 7 ] ) ; v0 = _mm_madd_epi16 ( u0 , k__cospi_p08_p24 ) ; v1 = _mm_madd_epi16 ( u1 , k__cospi_p08_p24 ) ; v2 = _mm_madd_epi16 ( u0 , k__cospi_p24_m08 ) ; v3 = _mm_madd_epi16 ( u1 , k__cospi_p24_m08 ) ; v4 = _mm_madd_epi16 ( u2 , k__cospi_m24_p08 ) ; v5 = _mm_madd_epi16 ( u3 , k__cospi_m24_p08 ) ; v6 = _mm_madd_epi16 ( u2 , k__cospi_p08_p24 ) ; v7 = _mm_madd_epi16 ( u3 , k__cospi_p08_p24 ) ; w0 = _mm_add_epi32 ( v0 , v4 ) ; w1 = _mm_add_epi32 ( v1 , v5 ) ; w2 = _mm_add_epi32 ( v2 , v6 ) ; w3 = _mm_add_epi32 ( v3 , v7 ) ; w4 = _mm_sub_epi32 ( v0 , v4 ) ; w5 = _mm_sub_epi32 ( v1 , v5 ) ; w6 = _mm_sub_epi32 ( v2 , v6 ) ; w7 = _mm_sub_epi32 ( v3 , v7 ) ; v0 = _mm_add_epi32 ( w0 , k__DCT_CONST_ROUNDING ) ; v1 = _mm_add_epi32 ( w1 , k__DCT_CONST_ROUNDING ) ; v2 = _mm_add_epi32 ( w2 , k__DCT_CONST_ROUNDING ) ; v3 = _mm_add_epi32 ( w3 , k__DCT_CONST_ROUNDING ) ; v4 = _mm_add_epi32 ( w4 , k__DCT_CONST_ROUNDING ) ; v5 = _mm_add_epi32 ( w5 , k__DCT_CONST_ROUNDING ) ; v6 = _mm_add_epi32 ( w6 , k__DCT_CONST_ROUNDING ) ; v7 = _mm_add_epi32 ( w7 , k__DCT_CONST_ROUNDING ) ; u0 = _mm_srai_epi32 ( v0 , DCT_CONST_BITS ) ; u1 = _mm_srai_epi32 ( v1 , DCT_CONST_BITS ) ; u2 = _mm_srai_epi32 ( v2 , DCT_CONST_BITS ) ; u3 = _mm_srai_epi32 ( v3 , DCT_CONST_BITS ) ; u4 = _mm_srai_epi32 ( v4 , DCT_CONST_BITS ) ; u5 = _mm_srai_epi32 ( v5 , DCT_CONST_BITS ) ; u6 = _mm_srai_epi32 ( v6 , DCT_CONST_BITS ) ; u7 = _mm_srai_epi32 ( v7 , DCT_CONST_BITS ) ; s4 = _mm_packs_epi32 ( u0 , u1 ) ; s5 = _mm_packs_epi32 ( u2 , u3 ) ; s6 = _mm_packs_epi32 ( u4 , u5 ) ; s7 = _mm_packs_epi32 ( u6 , u7 ) ; u0 = _mm_unpacklo_epi16 ( s2 , s3 ) ; u1 = _mm_unpackhi_epi16 ( s2 , s3 ) ; u2 = _mm_unpacklo_epi16 ( s6 , s7 ) ; u3 = _mm_unpackhi_epi16 ( s6 , s7 ) ; v0 = _mm_madd_epi16 ( u0 , k__cospi_p16_p16 ) ; v1 = _mm_madd_epi16 ( u1 , k__cospi_p16_p16 ) ; v2 = _mm_madd_epi16 ( u0 , k__cospi_p16_m16 ) ; v3 = _mm_madd_epi16 ( u1 , k__cospi_p16_m16 ) ; v4 = _mm_madd_epi16 ( u2 , k__cospi_p16_p16 ) ; v5 = _mm_madd_epi16 ( u3 , k__cospi_p16_p16 ) ; v6 = _mm_madd_epi16 ( u2 , k__cospi_p16_m16 ) ; v7 = _mm_madd_epi16 ( u3 , k__cospi_p16_m16 ) ; u0 = _mm_add_epi32 ( v0 , k__DCT_CONST_ROUNDING ) ; u1 = _mm_add_epi32 ( v1 , k__DCT_CONST_ROUNDING ) ; u2 = _mm_add_epi32 ( v2 , k__DCT_CONST_ROUNDING ) ; u3 = _mm_add_epi32 ( v3 , k__DCT_CONST_ROUNDING ) ; u4 = _mm_add_epi32 ( v4 , k__DCT_CONST_ROUNDING ) ; u5 = _mm_add_epi32 ( v5 , k__DCT_CONST_ROUNDING ) ; u6 = _mm_add_epi32 ( v6 , k__DCT_CONST_ROUNDING ) ; u7 = _mm_add_epi32 ( v7 , k__DCT_CONST_ROUNDING ) ; v0 = _mm_srai_epi32 ( u0 , DCT_CONST_BITS ) ; v1 = _mm_srai_epi32 ( u1 , DCT_CONST_BITS ) ; v2 = _mm_srai_epi32 ( u2 , DCT_CONST_BITS ) ; v3 = _mm_srai_epi32 ( u3 , DCT_CONST_BITS ) ; v4 = _mm_srai_epi32 ( u4 , DCT_CONST_BITS ) ; v5 = _mm_srai_epi32 ( u5 , DCT_CONST_BITS ) ; v6 = _mm_srai_epi32 ( u6 , DCT_CONST_BITS ) ; v7 = _mm_srai_epi32 ( u7 , DCT_CONST_BITS ) ; s2 = _mm_packs_epi32 ( v0 , v1 ) ; s3 = _mm_packs_epi32 ( v2 , v3 ) ; s6 = _mm_packs_epi32 ( v4 , v5 ) ; s7 = _mm_packs_epi32 ( v6 , v7 ) ; in [ 0 ] = s0 ; in [ 1 ] = _mm_sub_epi16 ( k__const_0 , s4 ) ; in [ 2 ] = s6 ; in [ 3 ] = _mm_sub_epi16 ( k__const_0 , s2 ) ; in [ 4 ] = s3 ; in [ 5 ] = _mm_sub_epi16 ( k__const_0 , s7 ) ; in [ 6 ] = s5 ; in [ 7 ] = _mm_sub_epi16 ( k__const_0 , s1 ) ; array_transpose_8x8 ( in , in ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> void fadst8_sse2 ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug>
855,CWE-119,"static void swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; TIFFSwabArrayOfLong ( wp , wc ) ; horAcc32 ( tif , cp0 , cc ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc32 ( TIFF <S2SV_ModStart> wc ) ; return
",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horAcc32 ( tif , cp0 , cc ) ; <S2SV_EndBug>"
1414,CWE-119,"static void encode_mb_row ( VP8_COMP * cpi , VP8_COMMON * cm , int mb_row , MACROBLOCK * x , MACROBLOCKD * xd , TOKENEXTRA * * tp , int * segment_counts , int * totalrate ) { int recon_yoffset , recon_uvoffset ; int mb_col ; int ref_fb_idx = cm -> lst_fb_idx ; int dst_fb_idx = cm -> new_fb_idx ; int recon_y_stride = cm -> yv12_fb [ ref_fb_idx ] . y_stride ; int recon_uv_stride = cm -> yv12_fb [ ref_fb_idx ] . uv_stride ; int map_index = ( mb_row * cpi -> common . mb_cols ) ; # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) const int num_part = ( 1 << cm -> multi_token_partition ) ; TOKENEXTRA * tp_start = cpi -> tok ; vp8_writer * w ; # endif # if CONFIG_MULTITHREAD const int nsync = cpi -> mt_sync_range ; const int rightmost_col = cm -> mb_cols + nsync ; volatile const int * last_row_current_mb_col ; volatile int * current_mb_col = & cpi -> mt_current_mb_col [ mb_row ] ; if ( ( cpi -> b_multi_threaded != 0 ) && ( mb_row != 0 ) ) last_row_current_mb_col = & cpi -> mt_current_mb_col [ mb_row - 1 ] ; else last_row_current_mb_col = & rightmost_col ; # endif # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( num_part > 1 ) w = & cpi -> bc [ 1 + ( mb_row % num_part ) ] ; else w = & cpi -> bc [ 1 ] ; # endif xd -> above_context = cm -> above_context ; xd -> up_available = ( mb_row != 0 ) ; recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; recon_uvoffset = ( mb_row * recon_uv_stride * 8 ) ; cpi -> tplist [ mb_row ] . start = * tp ; xd -> mb_to_top_edge = - ( ( mb_row * 16 ) << 3 ) ; xd -> mb_to_bottom_edge = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) << 3 ; x -> mv_row_min = - ( ( mb_row * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; x -> mb_activity_ptr = & cpi -> mb_activity_map [ map_index ] ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) * tp = cpi -> tok ; # endif xd -> mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; xd -> mb_to_right_edge = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) << 3 ; x -> mv_col_min = - ( ( mb_col * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; xd -> dst . y_buffer = cm -> yv12_fb [ dst_fb_idx ] . y_buffer + recon_yoffset ; xd -> dst . u_buffer = cm -> yv12_fb [ dst_fb_idx ] . u_buffer + recon_uvoffset ; xd -> dst . v_buffer = cm -> yv12_fb [ dst_fb_idx ] . v_buffer + recon_uvoffset ; xd -> left_available = ( mb_col != 0 ) ; x -> rddiv = cpi -> RDDIV ; x -> rdmult = cpi -> RDMULT ; vp8_copy_mem16x16 ( x -> src . y_buffer , x -> src . y_stride , x -> thismb , 16 ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded != 0 ) { * current_mb_col = mb_col - 1 ; if ( ( mb_col & ( nsync - 1 ) ) == 0 ) { while ( mb_col > ( * last_row_current_mb_col - nsync ) ) { x86_pause_hint ( ) ; thread_sleep ( 0 ) ; } } } # endif if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) vp8_activity_masking ( cpi , x ) ; if ( xd -> segmentation_enabled ) { if ( cpi -> segmentation_map [ map_index + mb_col ] <= 3 ) xd -> mode_info_context -> mbmi . segment_id = cpi -> segmentation_map [ map_index + mb_col ] ; else xd -> mode_info_context -> mbmi . segment_id = 0 ; vp8cx_mb_init_quantizer ( cpi , x , 1 ) ; } else xd -> mode_info_context -> mbmi . segment_id = 0 ; x -> active_ptr = cpi -> active_map + map_index + mb_col ; if ( cm -> frame_type == KEY_FRAME ) { * totalrate += vp8cx_encode_intra_macroblock ( cpi , x , tp ) ; # ifdef MODE_STATS y_modes [ xd -> mbmi . mode ] ++ ; # endif } else { * totalrate += vp8cx_encode_inter_macroblock ( cpi , x , tp , recon_yoffset , recon_uvoffset , mb_row , mb_col ) ; # ifdef MODE_STATS inter_y_modes [ xd -> mbmi . mode ] ++ ; if ( xd -> mbmi . mode == SPLITMV ) { int b ; for ( b = 0 ; b < xd -> mbmi . partition_count ; b ++ ) { inter_b_modes [ x -> partition -> bmi [ b ] . mode ] ++ ; } } # endif if ( ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ; else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) ) { if ( cpi -> cyclic_refresh_map [ map_index + mb_col ] == 1 ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = 0 ; } else cpi -> cyclic_refresh_map [ map_index + mb_col ] = 1 ; } } cpi -> tplist [ mb_row ] . stop = * tp ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int tok_count = * tp - tp_start ; pack_tokens ( w , tp_start , tok_count ) ; } # endif x -> gf_active_ptr ++ ; x -> mb_activity_ptr ++ ; x -> src . y_buffer += 16 ; x -> src . u_buffer += 8 ; x -> src . v_buffer += 8 ; recon_yoffset += 16 ; recon_uvoffset += 8 ; segment_counts [ xd -> mode_info_context -> mbmi . segment_id ] ++ ; xd -> mode_info_context ++ ; x -> partition_info ++ ; xd -> above_context ++ ; } vp8_extend_mb_row ( & cm -> yv12_fb [ dst_fb_idx ] , xd -> dst . y_buffer + 16 , xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded != 0 ) * current_mb_col = rightmost_col ; # endif xd -> mode_info_context ++ ; x -> partition_info ++ ; }
","<S2SV_ModStart> endif if ( <S2SV_ModEnd> cpi -> current_layer <S2SV_ModStart> == 0 ) { if <S2SV_ModEnd> ( xd -> <S2SV_ModStart> mode == ZEROMV && <S2SV_ModEnd> xd -> mode_info_context <S2SV_ModStart> == LAST_FRAME ) { if ( cpi -> consec_zero_last [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last [ map_index + mb_col ] += 1 ; if ( cpi -> consec_zero_last_mvbias [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] += 1 ; } else { cpi -> consec_zero_last [ map_index + mb_col ] = 0 ; cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( x -> zero_last_dot_suppress ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ; else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) <S2SV_ModStart> - tp_start ; vp8_pack_tokens <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> if ( ( cpi -> current_layer == 0 ) && <S2SV_EndBug> <S2SV_StartBug> else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) ) <S2SV_EndBug> <S2SV_StartBug> pack_tokens ( w , tp_start , tok_count ) ; <S2SV_EndBug>"
2376,CWE-119,"int au1100fb_fb_mmap ( struct fb_info * fbi , struct vm_area_struct * vma ) { struct au1100fb_device * fbdev ; unsigned int len ; unsigned long start = 0 , off ; fbdev = to_au1100fb_device ( fbi ) ; if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= ( 6 << 9 ) ; if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) { return - EAGAIN ; } return 0 ; }
","<S2SV_ModStart> * fbdev ; <S2SV_ModEnd> fbdev = to_au1100fb_device <S2SV_ModStart> ( fbi ) <S2SV_ModEnd> ; vma -> <S2SV_ModStart> 9 ) ; return vm_iomap_memory <S2SV_ModEnd> ( vma , <S2SV_ModStart> ( vma , fbdev -> fb_phys , fbdev -> fb_len ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/7314e613d5ff9f0934f7a0f74ed7973b903315d1,CVE-2013-6763,https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1,2013-11-12T14:35Z,"<S2SV_StartBug> unsigned int len ; <S2SV_EndBug> <S2SV_StartBug> fbdev = to_au1100fb_device ( fbi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug>"
1647,CWE-119,"static void encode_txfm_probs ( VP9_COMMON * cm , vp9_writer * w ) { vp9_write_literal ( w , MIN ( cm -> tx_mode , ALLOW_32X32 ) , 2 ) ; if ( cm -> tx_mode >= ALLOW_32X32 ) vp9_write_bit ( w , cm -> tx_mode == TX_MODE_SELECT ) ; if ( cm -> tx_mode == TX_MODE_SELECT ) { int i , j ; unsigned int ct_8x8p [ TX_SIZES - 3 ] [ 2 ] ; unsigned int ct_16x16p [ TX_SIZES - 2 ] [ 2 ] ; unsigned int ct_32x32p [ TX_SIZES - 1 ] [ 2 ] ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { tx_counts_to_branch_counts_8x8 ( cm -> counts . tx . p8x8 [ i ] , ct_8x8p ) ; for ( j = 0 ; j < TX_SIZES - 3 ; j ++ ) vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p8x8 [ i ] [ j ] , ct_8x8p [ j ] ) ; } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { tx_counts_to_branch_counts_16x16 ( cm -> counts . tx . p16x16 [ i ] , ct_16x16p ) ; for ( j = 0 ; j < TX_SIZES - 2 ; j ++ ) vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p16x16 [ i ] [ j ] , ct_16x16p [ j ] ) ; } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { tx_counts_to_branch_counts_32x32 ( cm -> counts . tx . p32x32 [ i ] , ct_32x32p ) ; for ( j = 0 ; j < TX_SIZES - 1 ; j ++ ) vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p32x32 [ i ] [ j ] , ct_32x32p [ j ] ) ; } } }
","<S2SV_ModStart> * cm , vpx_writer * w , FRAME_COUNTS * counts ) { vpx_write_literal <S2SV_ModEnd> ( w , <S2SV_ModStart> >= ALLOW_32X32 ) vpx_write_bit <S2SV_ModEnd> ( w , <S2SV_ModStart> { tx_counts_to_branch_counts_8x8 ( counts -> <S2SV_ModEnd> tx . p8x8 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> tx_probs . p8x8 <S2SV_ModStart> { tx_counts_to_branch_counts_16x16 ( counts -> <S2SV_ModEnd> tx . p16x16 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> tx_probs . p16x16 <S2SV_ModStart> { tx_counts_to_branch_counts_32x32 ( counts -> <S2SV_ModEnd> tx . p32x32 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> tx_probs . p32x32
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void encode_txfm_probs ( VP9_COMMON * cm , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( w , cm -> tx_mode == TX_MODE_SELECT ) ; <S2SV_EndBug> <S2SV_StartBug> tx_counts_to_branch_counts_8x8 ( cm -> counts . tx . p8x8 [ i ] , ct_8x8p ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p8x8 [ i ] [ j ] , ct_8x8p [ j ] ) ; <S2SV_EndBug> <S2SV_StartBug> tx_counts_to_branch_counts_16x16 ( cm -> counts . tx . p16x16 [ i ] , ct_16x16p ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p16x16 [ i ] [ j ] , <S2SV_EndBug> <S2SV_StartBug> tx_counts_to_branch_counts_32x32 ( cm -> counts . tx . p32x32 [ i ] , ct_32x32p ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p32x32 [ i ] [ j ] , <S2SV_EndBug>"
206,CWE-787,"static char * decode_text_string ( const char * str , size_t str_len ) { int idx , is_hex , is_utf16be , ascii_idx ; char * ascii , hex_buf [ 5 ] = { 0 } ; is_hex = is_utf16be = idx = ascii_idx = 0 ; if ( str [ 0 ] == '(' ) { ascii = malloc ( strlen ( str ) + 1 ) ; strncpy ( ascii , str , strlen ( str ) + 1 ) ; return ascii ; } else if ( str [ 0 ] == '<' ) { is_hex = 1 ; ++ idx ; } if ( is_hex && ( str_len > 5 ) && ( str [ idx ] == 'F' ) && ( str [ idx + 1 ] == 'E' ) && ( str [ idx + 2 ] == 'F' ) && ( str [ idx + 3 ] == 'F' ) ) { is_utf16be = 1 ; idx += 4 ; } else return NULL ; ascii = malloc ( str_len ) ; for ( ; idx < str_len ; ++ idx ) { hex_buf [ 0 ] = str [ idx ++ ] ; hex_buf [ 1 ] = str [ idx ++ ] ; hex_buf [ 2 ] = str [ idx ++ ] ; hex_buf [ 3 ] = str [ idx ] ; ascii [ ascii_idx ++ ] = strtol ( hex_buf , NULL , 16 ) ; } return ascii ; }
","<S2SV_ModStart> { ascii = safe_calloc <S2SV_ModEnd> ( strlen ( <S2SV_ModStart> ; ascii = safe_calloc <S2SV_ModEnd> ( str_len )
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,<S2SV_StartBug> ascii = malloc ( strlen ( str ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ascii = malloc ( str_len ) ; <S2SV_EndBug>
2381,CWE-119,"char * suhosin_decrypt_single_cookie ( char * name , int name_len , char * value , int value_len , char * key , char * * where TSRMLS_DC ) { char buffer [ 4096 ] ; char buffer2 [ 4096 ] ; int o_name_len = name_len ; char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; int l ; if ( name_len > sizeof ( buffer ) - 2 ) { buf = estrndup ( name , name_len ) ; } else { memcpy ( buf , name , name_len ) ; buf [ name_len ] = 0 ; } name_len = php_url_decode ( buf , name_len ) ; normalize_varname ( buf ) ; name_len = strlen ( buf ) ; if ( SUHOSIN_G ( cookie_plainlist ) ) { if ( zend_hash_exists ( SUHOSIN_G ( cookie_plainlist ) , buf , name_len + 1 ) ) { decrypt_return_plain : if ( buf != buffer ) { efree ( buf ) ; } memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , value , value_len ) ; * where += value_len ; return * where ; } } else if ( SUHOSIN_G ( cookie_cryptlist ) ) { if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) { goto decrypt_return_plain ; } } if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { memcpy ( buf2 , value , value_len ) ; buf2 [ value_len ] = 0 ; } else { buf2 = estrndup ( value , value_len ) ; } value_len = php_url_decode ( buf2 , value_len ) ; d = suhosin_decrypt_string ( buf2 , value_len , buf , name_len , key , & l , SUHOSIN_G ( cookie_checkraddr ) TSRMLS_CC ) ; if ( d == NULL ) { goto skip_cookie ; } d_url = php_url_encode ( d , l , & l ) ; efree ( d ) ; memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , d_url , l ) ; * where += l ; efree ( d_url ) ; skip_cookie : if ( buf != buffer ) { efree ( buf ) ; } if ( buf2 != buffer2 ) { efree ( buf2 ) ; } return * where ; }
","<S2SV_ModStart> TSRMLS_DC ) { <S2SV_ModEnd> int o_name_len = <S2SV_ModStart> char * buf , * buf2 <S2SV_ModEnd> , * d <S2SV_ModStart> int l ; <S2SV_ModEnd> buf = estrndup <S2SV_ModStart> name_len ) ; <S2SV_ModEnd> name_len = php_url_decode <S2SV_ModStart> { decrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> memcpy ( * <S2SV_ModStart> ; } } buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> value_len = php_url_decode <S2SV_ModStart> ; skip_cookie : efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return * where
",stefanesser@suhosin/73b1968ee30f6d9d2dae497544b910e68e114bfa,CVE-2012-0807,https://github.com/stefanesser/suhosin/commit/73b1968ee30f6d9d2dae497544b910e68e114bfa,2012-01-27T00:55Z,"<S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> <S2SV_StartBug> char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; <S2SV_EndBug> <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug>"
3293,CWE-476,"struct key * key_get_instantiation_authkey ( key_serial_t target_id ) { char description [ 16 ] ; struct keyring_search_context ctx = { . index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = user_match , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ; struct key * authkey ; key_ref_t authkey_ref ; sprintf ( description , ""%x"" , target_id ) ; authkey_ref = search_process_keyrings ( & ctx ) ; if ( IS_ERR ( authkey_ref ) ) { authkey = ERR_CAST ( authkey_ref ) ; if ( authkey == ERR_PTR ( - EAGAIN ) ) authkey = ERR_PTR ( - ENOKEY ) ; goto error ; } authkey = key_ref_to_ptr ( authkey_ref ) ; if ( test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { key_put ( authkey ) ; authkey = ERR_PTR ( - EKEYREVOKED ) ; } error : return authkey ; }
","<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
",torvalds@linux/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,CVE-2017-2647,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,2017-03-31T04:59Z,"<S2SV_StartBug> . match_data . cmp = user_match , <S2SV_EndBug>"
2721,CWE-362,"static int raw_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct net * net = sock_net ( sk ) ; struct ipcm_cookie ipc ; struct rtable * rt = NULL ; struct flowi4 fl4 ; int free = 0 ; __be32 daddr ; __be32 saddr ; u8 tos ; int err ; struct ip_options_data opt_copy ; struct raw_frag_vec rfv ; err = - EMSGSIZE ; if ( len > 0xFFFF ) goto out ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; err = - EINVAL ; if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ; if ( usin -> sin_family != AF_INET ) { pr_info_once ( ""%s:<S2SV_blank>%s<S2SV_blank>forgot<S2SV_blank>to<S2SV_blank>set<S2SV_blank>AF_INET.<S2SV_blank>Fix<S2SV_blank>it!\\n"" , __func__ , current -> comm ) ; err = - EAFNOSUPPORT ; if ( usin -> sin_family ) goto out ; } daddr = usin -> sin_addr . s_addr ; } else { err = - EDESTADDRREQ ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; daddr = inet -> inet_daddr ; } ipc . sockc . tsflags = sk -> sk_tsflags ; ipc . addr = inet -> inet_saddr ; ipc . opt = NULL ; ipc . tx_flags = 0 ; ipc . ttl = 0 ; ipc . tos = - 1 ; ipc . oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sk , msg , & ipc , false ) ; if ( unlikely ( err ) ) { kfree ( ipc . opt ) ; goto out ; } if ( ipc . opt ) free = 1 ; } saddr = ipc . addr ; ipc . addr = daddr ; if ( ! ipc . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } if ( ipc . opt ) { err = - EINVAL ; if ( inet -> hdrincl ) goto done ; if ( ipc . opt -> opt . srr ) { if ( ! daddr ) goto done ; daddr = ipc . opt -> opt . faddr ; } } tos = get_rtconn_flags ( & ipc , sk ) ; if ( msg -> msg_flags & MSG_DONTROUTE ) tos |= RTO_ONLINK ; if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; } else if ( ! ipc . oif ) ipc . oif = inet -> uc_index ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , inet_sk_flowi_flags ( sk ) | ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , daddr , saddr , 0 , 0 , sk -> sk_uid ) ; if ( ! inet -> hdrincl ) { rfv . msg = msg ; rfv . hlen = 0 ; err = raw_probe_proto_opt ( & rfv , & fl4 ) ; if ( err ) goto done ; } security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; goto done ; } err = - EACCES ; if ( rt -> rt_flags & RTCF_BROADCAST && ! sock_flag ( sk , SOCK_BROADCAST ) ) goto done ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ; else { sock_tx_timestamp ( sk , ipc . sockc . tsflags , & ipc . tx_flags ) ; if ( ! ipc . addr ) ipc . addr = fl4 . daddr ; lock_sock ( sk ) ; err = ip_append_data ( sk , & fl4 , raw_getfrag , & rfv , len , 0 , & ipc , & rt , msg -> msg_flags ) ; if ( err ) ip_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) { err = ip_push_pending_frames ( sk , & fl4 ) ; if ( err == - ENOBUFS && ! inet -> recverr ) err = 0 ; } release_sock ( sk ) ; } done : if ( free ) kfree ( ipc . opt ) ; ip_rt_put ( rt ) ; out : if ( err < 0 ) return err ; return len ; do_confirm : if ( msg -> msg_flags & MSG_PROBE ) dst_confirm_neigh ( & rt -> dst , & fl4 . daddr ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }
","<S2SV_ModStart> raw_frag_vec rfv ; int hdrincl ; <S2SV_ModStart> ) goto out ; hdrincl = inet -> hdrincl <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdrincl ) goto <S2SV_ModStart> , RT_SCOPE_UNIVERSE , <S2SV_ModEnd> hdrincl ? IPPROTO_RAW <S2SV_ModStart> ) | ( <S2SV_ModEnd> hdrincl ? FLOWI_FLAG_KNOWN_NH <S2SV_ModStart> if ( ! <S2SV_ModEnd> hdrincl ) { <S2SV_ModStart> : if ( <S2SV_ModEnd> hdrincl ) err
",torvalds@linux/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483,CVE-2017-17712,https://github.com/torvalds/linux/commit/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483,2017-12-16T01:29Z,"<S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> <S2SV_StartBug> inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , <S2SV_EndBug> <S2SV_StartBug> ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , <S2SV_EndBug> <S2SV_StartBug> if ( ! inet -> hdrincl ) { <S2SV_EndBug> <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug>"
4613,CWE-787,"static int cbs_jpeg_split_fragment ( CodedBitstreamContext * ctx , CodedBitstreamFragment * frag , int header ) { AVBufferRef * data_ref ; uint8_t * data ; size_t data_size ; int unit , start , end , marker , next_start , next_marker ; int err , i , j , length ; if ( frag -> data_size < 4 ) { return AVERROR_INVALIDDATA ; } for ( i = 0 ; i + 1 < frag -> data_size && frag -> data [ i ] != 0xff ; i ++ ) ; if ( i > 0 ) { av_log ( ctx -> log_ctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>"" ""beginning<S2SV_blank>of<S2SV_blank>image.\\n"" , i ) ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size && frag -> data [ i ] ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""no<S2SV_blank>SOI<S2SV_blank>marker<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; if ( marker != JPEG_MARKER_SOI ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>first<S2SV_blank>"" ""marker<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>SOI.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""no<S2SV_blank>image<S2SV_blank>content<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; start = i + 1 ; for ( unit = 0 ; ; unit ++ ) { if ( marker == JPEG_MARKER_EOI ) { break ; } else if ( marker == JPEG_MARKER_SOS ) { for ( i = start ; i + 1 < frag -> data_size ; i ++ ) { if ( frag -> data [ i ] != 0xff ) continue ; end = i ; for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { if ( frag -> data [ i ] == 0x00 ) continue ; next_marker = frag -> data [ i ] ; next_start = i + 1 ; } break ; } } else { i = start ; if ( i + 2 > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } length = AV_RB16 ( frag -> data + i ) ; if ( i + length > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker<S2SV_blank>segment.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } end = start + length ; i = end ; if ( frag -> data [ i ] != 0xff ) { next_marker = - 1 ; } else { for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { next_marker = frag -> data [ i ] ; next_start = i + 1 ; } } } if ( marker == JPEG_MARKER_SOS ) { length = AV_RB16 ( frag -> data + start ) ; data_ref = NULL ; data = av_malloc ( end - start + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! data ) return AVERROR ( ENOMEM ) ; memcpy ( data , frag -> data + start , length ) ; for ( i = start + length , j = length ; i < end ; i ++ , j ++ ) { if ( frag -> data [ i ] == 0xff ) { while ( frag -> data [ i ] == 0xff ) ++ i ; data [ j ] = 0xff ; } else { data [ j ] = frag -> data [ i ] ; } } data_size = j ; memset ( data + data_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; } else { data = frag -> data + start ; data_size = end - start ; data_ref = frag -> data_ref ; } err = ff_cbs_insert_unit_data ( ctx , frag , unit , marker , data , data_size , data_ref ) ; if ( err < 0 ) return err ; if ( next_marker == - 1 ) break ; marker = next_marker ; start = next_start ; } return 0 ; }
","<S2SV_ModStart> start ) ; if ( length > end - start ) return AVERROR_INVALIDDATA ;
",FFmpeg@FFmpeg/1812352d767ccf5431aa440123e2e260a4db2726,CVE-2020-12284,https://github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726,2020-04-28T06:15Z,<S2SV_StartBug> data_ref = NULL ; <S2SV_EndBug>
1656,CWE-119,"static void update_skip_probs ( VP9_COMMON * cm , vp9_writer * w ) { int k ; for ( k = 0 ; k < SKIP_CONTEXTS ; ++ k ) vp9_cond_prob_diff_update ( w , & cm -> fc . skip_probs [ k ] , cm -> counts . skip [ k ] ) ; }
","<S2SV_ModStart> * cm , vpx_writer * w , FRAME_COUNTS * counts <S2SV_ModEnd> ) { int <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> skip_probs [ k <S2SV_ModStart> k ] , counts -> <S2SV_ModEnd> skip [ k
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void update_skip_probs ( VP9_COMMON * cm , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . skip_probs [ k ] , cm -> counts . skip [ k ] ) ; <S2SV_EndBug>"
3958,CWE-000,"static struct file * path_openat ( int dfd , struct filename * pathname , struct nameidata * nd , const struct open_flags * op , int flags ) { struct file * file ; struct path path ; int opened = 0 ; int error ; file = get_empty_filp ( ) ; if ( IS_ERR ( file ) ) return file ; file -> f_flags = op -> open_flag ; if ( unlikely ( file -> f_flags & __O_TMPFILE ) ) { error = do_tmpfile ( dfd , pathname , nd , flags , op , file , & opened ) ; goto out ; } error = path_init ( dfd , pathname , flags , nd ) ; if ( unlikely ( error ) ) goto out ; error = do_last ( nd , & path , file , op , & opened , pathname ) ; while ( unlikely ( error > 0 ) ) { struct path link = path ; void * cookie ; if ( ! ( nd -> flags & LOOKUP_FOLLOW ) ) { path_put_conditional ( & path , nd ) ; path_put ( & nd -> path ) ; error = - ELOOP ; break ; } error = may_follow_link ( & link , nd ) ; if ( unlikely ( error ) ) break ; nd -> flags |= LOOKUP_PARENT ; nd -> flags &= ~ ( LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_EXCL ) ; error = follow_link ( & link , nd , & cookie ) ; if ( unlikely ( error ) ) break ; error = do_last ( nd , & path , file , op , & opened , pathname ) ; put_link ( nd , & link , cookie ) ; } out : path_cleanup ( nd ) ; if ( ! ( opened & FILE_OPENED ) ) { BUG_ON ( ! error ) ; put_filp ( file ) ; } if ( unlikely ( error ) ) { if ( error == - EOPENSTALE ) { if ( flags & LOOKUP_RCU ) error = - ECHILD ; else error = - ESTALE ; } file = ERR_PTR ( error ) ; } return file ; }
","<S2SV_ModStart> ) ; goto out2 <S2SV_ModEnd> ; } error <S2SV_ModStart> nd ) ; out2 :
",torvalds@linux/f15133df088ecadd141ea1907f2c96df67c729f0,CVE-2015-5706,https://github.com/torvalds/linux/commit/f15133df088ecadd141ea1907f2c96df67c729f0,2015-08-31T10:59Z,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( opened & FILE_OPENED ) ) { <S2SV_EndBug>
5499,CWE-59,"int add_mibfile ( const char * tmpstr , const char * d_name , FILE * ip ) { FILE * fp ; char token [ MAXTOKEN ] , token2 [ MAXTOKEN ] ; if ( ( fp = fopen ( tmpstr , ""r"" ) ) == NULL ) { snmp_log_perror ( tmpstr ) ; return 1 ; } DEBUGMSGTL ( ( ""parse-mibs"" , ""Checking<S2SV_blank>file:<S2SV_blank>%s...\\n"" , tmpstr ) ) ; mibLine = 1 ; File = tmpstr ; if ( get_token ( fp , token , MAXTOKEN ) != LABEL ) { fclose ( fp ) ; return 1 ; } if ( get_token ( fp , token2 , MAXTOKEN ) == DEFINITIONS ) { new_module ( token , tmpstr ) ; if ( ip ) fprintf ( ip , ""%s<S2SV_blank>%s\\n"" , token , d_name ) ; fclose ( fp ) ; return 0 ; } else { fclose ( fp ) ; return 1 ; } }
","<S2SV_ModStart> char * d_name <S2SV_ModEnd> ) { FILE <S2SV_ModStart> tmpstr ) ; <S2SV_ModEnd> fclose ( fp
",net-snmp@net-snmp/4fd9a450444a434a993bc72f7c3486ccce41f602,CVE-2020-15861,https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602,2020-08-20T01:17Z,"<S2SV_StartBug> add_mibfile ( const char * tmpstr , const char * d_name , FILE * ip ) <S2SV_EndBug> <S2SV_StartBug> if ( ip ) <S2SV_EndBug>"
1644,CWE-119,"static void encode_quantization ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ; write_delta_q ( wb , cm -> y_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_ac_delta_q ) ; }
","<S2SV_ModStart> void encode_quantization ( const VP9_COMMON * const <S2SV_ModEnd> cm , struct <S2SV_ModStart> cm , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> wb ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void encode_quantization ( VP9_COMMON * cm , <S2SV_EndBug> <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ; <S2SV_EndBug>"
335,CWE-20,"static void activate_desktop_file ( ActivateParameters * parameters , NautilusFile * file ) { ActivateParametersDesktop * parameters_desktop ; char * primary , * secondary , * display_name ; GtkWidget * dialog ; GdkScreen * screen ; char * uri ; screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; if ( ! nautilus_file_is_trusted_link ( file ) ) { parameters_desktop = g_new0 ( ActivateParametersDesktop , 1 ) ; if ( parameters -> parent_window ) { parameters_desktop -> parent_window = parameters -> parent_window ; g_object_add_weak_pointer ( G_OBJECT ( parameters_desktop -> parent_window ) , ( gpointer * ) & parameters_desktop -> parent_window ) ; } parameters_desktop -> file = nautilus_file_ref ( file ) ; primary = _ ( ""Untrusted<S2SV_blank>application<S2SV_blank>launcher"" ) ; display_name = nautilus_file_get_display_name ( file ) ; secondary = g_strdup_printf ( _ ( ""The<S2SV_blank>application<S2SV_blank>launcher<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>not<S2SV_blank>been<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>trusted.<S2SV_blank>"" ""If<S2SV_blank>you<S2SV_blank>do<S2SV_blank>not<S2SV_blank>know<S2SV_blank>the<S2SV_blank>source<S2SV_blank>of<S2SV_blank>this<S2SV_blank>file,<S2SV_blank>launching<S2SV_blank>it<S2SV_blank>may<S2SV_blank>be<S2SV_blank>unsafe."" ) , display_name ) ; dialog = gtk_message_dialog_new ( parameters -> parent_window , 0 , GTK_MESSAGE_WARNING , GTK_BUTTONS_NONE , NULL ) ; g_object_set ( dialog , ""text"" , primary , ""secondary-text"" , secondary , NULL ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ; if ( nautilus_file_can_set_permissions ( file ) ) { gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ; } gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ; g_signal_connect ( dialog , ""response"" , G_CALLBACK ( untrusted_launcher_response_callback ) , parameters_desktop ) ; gtk_widget_show ( dialog ) ; g_free ( display_name ) ; g_free ( secondary ) ; return ; } uri = nautilus_file_get_uri ( file ) ; DEBUG ( ""Launching<S2SV_blank>trusted<S2SV_blank>launcher<S2SV_blank>%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; }
","<S2SV_ModStart> , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , _ ( ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> g_signal_connect ( dialog
",GNOME@nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0,CVE-2017-14604,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,2017-09-20T08:29Z,"<S2SV_StartBug> _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ; <S2SV_EndBug> <S2SV_StartBug> _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ; <S2SV_EndBug> <S2SV_StartBug> gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_EndBug>"
452,CWE-119,"static int nl80211_start_sched_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_sched_scan_request * request ; struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; u32 interval ; enum ieee80211_band band ; size_t ie_len ; if ( ! ( rdev -> wiphy . flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN ) || ! rdev -> ops -> sched_scan_start ) return - EOPNOTSUPP ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; if ( rdev -> sched_scan_req ) return - EINPROGRESS ; if ( ! info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) return - EINVAL ; interval = nla_get_u32 ( info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) ; if ( interval == 0 ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; request -> interval = interval ; err = rdev -> ops -> sched_scan_start ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { rdev -> sched_scan_req = request ; nl80211_send_sched_scan ( rdev , dev , NL80211_CMD_START_SCHED_SCAN ) ; goto out ; } out_free : kfree ( request ) ; out : return err ; }
","<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
",torvalds@linux/208c72f4fe44fe09577e7975ba0e7fa0278f3d03,CVE-2011-2517,https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03,2012-05-24T23:55Z,<S2SV_StartBug> if ( request -> ssids [ i ] . ssid_len > <S2SV_EndBug> <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug>
1029,CWE-284,"int btsock_thread_exit ( int h ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( ""invalid<S2SV_blank>bt<S2SV_blank>thread<S2SV_blank>handle:%d"" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( ""cmd<S2SV_blank>socket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>created"" ) ; return FALSE ; } sock_cmd_t cmd = { CMD_EXIT , 0 , 0 , 0 , 0 } ; if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ) { pthread_join ( ts [ h ] . thread_id , 0 ) ; pthread_mutex_lock ( & thread_slot_lock ) ; free_thread_slot ( h ) ; pthread_mutex_unlock ( & thread_slot_lock ) ; return TRUE ; } return FALSE ; }
","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) , 0 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ) <S2SV_EndBug>"
1602,CWE-119,"static REFERENCE_MODE read_block_reference_mode ( VP9_COMMON * cm , const MACROBLOCKD * xd , vp9_reader * r ) { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { const int ctx = vp9_get_reference_mode_context ( cm , xd ) ; const REFERENCE_MODE mode = ( REFERENCE_MODE ) vp9_read ( r , cm -> fc . comp_inter_prob [ ctx ] ) ; if ( ! cm -> frame_parallel_decoding_mode ) ++ cm -> counts . comp_inter [ ctx ] [ mode ] ; return mode ; } else { return cm -> reference_mode ; } }
","<S2SV_ModStart> * xd , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> ( REFERENCE_MODE ) vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> comp_inter_prob [ ctx <S2SV_ModStart> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> comp_inter [ ctx
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> ( REFERENCE_MODE ) vp9_read ( r , cm -> fc . comp_inter_prob [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug>"
5448,CWE-787,"static void process_demand_active ( STREAM s ) { uint8 type ; uint16 len_src_descriptor , len_combined_caps ; rd_create_ui ( ) ; in_uint32_le ( s , g_rdp_shareid ) ; in_uint16_le ( s , len_src_descriptor ) ; in_uint16_le ( s , len_combined_caps ) ; in_uint8s ( s , len_src_descriptor ) ; logger ( Protocol , Debug , ""process_demand_active(),<S2SV_blank>shareid=0x%x"" , g_rdp_shareid ) ; rdp_process_server_caps ( s , len_combined_caps ) ; rdp_send_confirm_active ( ) ; rdp_send_synchronise ( ) ; rdp_send_control ( RDP_CTL_COOPERATE ) ; rdp_send_control ( RDP_CTL_REQUEST_CONTROL ) ; rdp_recv ( & type ) ; rdp_recv ( & type ) ; rdp_recv ( & type ) ; rdp_send_input ( 0 , RDP_INPUT_SYNCHRONIZE , 0 , g_numlock_sync ? ui_get_numlock_state ( read_keyboard_state ( ) ) : 0 , 0 ) ; if ( g_rdp_version >= RDP_V5 ) { rdp_enum_bmpcache2 ( ) ; rdp_send_fonts ( 3 ) ; } else { rdp_send_fonts ( 1 ) ; rdp_send_fonts ( 2 ) ; } rdp_recv ( & type ) ; reset_order_state ( ) ; }
","<S2SV_ModStart> , len_combined_caps ; struct stream packet = * s ; <S2SV_ModStart> len_combined_caps ) ; if ( ! s_check_rem ( s , len_src_descriptor ) ) { rdp_protocol_error ( ""rdp_demand_active(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>source<S2SV_blank>descriptor<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,"<S2SV_StartBug> rd_create_ui ( ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint16_le ( s , len_combined_caps ) ; <S2SV_EndBug>"
5157,CWE-674,"static void renameTableFunc ( sqlite3_context * context , int NotUsed , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; const char * zDb = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zInput = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * zOld = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; const char * zNew = ( const char * ) sqlite3_value_text ( argv [ 5 ] ) ; int bTemp = sqlite3_value_int ( argv [ 6 ] ) ; UNUSED_PARAMETER ( NotUsed ) ; if ( zInput && zOld && zNew ) { Parse sParse ; int rc ; int bQuote = 1 ; RenameCtx sCtx ; Walker sWalker ; # ifndef SQLITE_OMIT_AUTHORIZATION sqlite3_xauth xAuth = db -> xAuth ; db -> xAuth = 0 ; # endif sqlite3BtreeEnterAll ( db ) ; memset ( & sCtx , 0 , sizeof ( RenameCtx ) ) ; sCtx . pTab = sqlite3FindTable ( db , zOld , zDb ) ; memset ( & sWalker , 0 , sizeof ( Walker ) ) ; sWalker . pParse = & sParse ; sWalker . xExprCallback = renameTableExprCb ; sWalker . xSelectCallback = renameTableSelectCb ; sWalker . u . pRename = & sCtx ; rc = renameParseSql ( & sParse , zDb , 1 , db , zInput , bTemp ) ; if ( rc == SQLITE_OK ) { int isLegacy = ( db -> flags & SQLITE_LegacyAlter ) ; if ( sParse . pNewTable ) { Table * pTab = sParse . pNewTable ; if ( pTab -> pSelect ) { if ( isLegacy == 0 ) { NameContext sNC ; memset ( & sNC , 0 , sizeof ( sNC ) ) ; sNC . pParse = & sParse ; sqlite3SelectPrep ( & sParse , pTab -> pSelect , & sNC ) ; if ( sParse . nErr ) rc = sParse . rc ; sqlite3WalkSelect ( & sWalker , pTab -> pSelect ) ; } } else { # ifndef SQLITE_OMIT_FOREIGN_KEY if ( isLegacy == 0 || ( db -> flags & SQLITE_ForeignKeys ) ) { FKey * pFKey ; for ( pFKey = pTab -> pFKey ; pFKey ; pFKey = pFKey -> pNextFrom ) { if ( sqlite3_stricmp ( pFKey -> zTo , zOld ) == 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) pFKey -> zTo ) ; } } } # endif if ( sqlite3_stricmp ( zOld , pTab -> zName ) == 0 ) { sCtx . pTab = pTab ; if ( isLegacy == 0 ) { sqlite3WalkExprList ( & sWalker , pTab -> pCheck ) ; } renameTokenFind ( & sParse , & sCtx , pTab -> zName ) ; } } } else if ( sParse . pNewIndex ) { renameTokenFind ( & sParse , & sCtx , sParse . pNewIndex -> zName ) ; if ( isLegacy == 0 ) { sqlite3WalkExpr ( & sWalker , sParse . pNewIndex -> pPartIdxWhere ) ; } } # ifndef SQLITE_OMIT_TRIGGER else { Trigger * pTrigger = sParse . pNewTrigger ; TriggerStep * pStep ; if ( 0 == sqlite3_stricmp ( sParse . pNewTrigger -> table , zOld ) && sCtx . pTab -> pSchema == pTrigger -> pTabSchema ) { renameTokenFind ( & sParse , & sCtx , sParse . pNewTrigger -> table ) ; } if ( isLegacy == 0 ) { rc = renameResolveTrigger ( & sParse , bTemp ? 0 : zDb ) ; if ( rc == SQLITE_OK ) { renameWalkTrigger ( & sWalker , pTrigger ) ; for ( pStep = pTrigger -> step_list ; pStep ; pStep = pStep -> pNext ) { if ( pStep -> zTarget && 0 == sqlite3_stricmp ( pStep -> zTarget , zOld ) ) { renameTokenFind ( & sParse , & sCtx , pStep -> zTarget ) ; } } } } } # endif } if ( rc == SQLITE_OK ) { rc = renameEditSql ( context , & sCtx , zInput , zNew , bQuote ) ; } if ( rc != SQLITE_OK ) { if ( sParse . zErrMsg ) { renameColumnParseError ( context , 0 , argv [ 1 ] , argv [ 2 ] , & sParse ) ; } else { sqlite3_result_error_code ( context , rc ) ; } } renameParseCleanup ( & sParse ) ; renameTokenFree ( db , sCtx . pList ) ; sqlite3BtreeLeaveAll ( db ) ; # ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = xAuth ; # endif } return ; }
","<S2SV_ModStart> 0 ) { Select * pSelect = pTab -> pSelect ; <S2SV_ModStart> = & sParse ; assert ( pSelect -> selFlags & SF_View ) ; pSelect -> selFlags &= ~ SF_View
",sqlite@sqlite/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,CVE-2019-19645,https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,2019-12-09T16:15Z,<S2SV_StartBug> NameContext sNC ; <S2SV_EndBug> <S2SV_StartBug> sNC . pParse = & sParse ; <S2SV_EndBug>
536,CWE-119,"int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( ""can\'t<S2SV_blank>handle<S2SV_blank>.WAV<S2SV_blank>files<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>4<S2SV_blank>GB<S2SV_blank>(non-standard)!"" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , ""WAVE"" , 4 ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , ""ds64"" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || bcount != sizeof ( DS64Chunk ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( ""DS64:<S2SV_blank>riffSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>dataSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>sampleCount<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>table_length<S2SV_blank>=<S2SV_blank>%d"" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , ""fmt<S2SV_blank>"" , 4 ) ) { int supported = TRUE , format ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.WAV<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>WAV<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else if ( config -> float_norm_exp ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point<S2SV_blank>(Audition<S2SV_blank>%d:%d<S2SV_blank>float<S2SV_blank>type<S2SV_blank>1)"" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , ""data"" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> ) , got_ds64 = 0 , format_chunk <S2SV_ModStart> , format ; if ( format_chunk ++ ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
",dbry@WavPack/26cb47f99d481ad9b93eeff80d26e6b63bbd7e15,CVE-2018-10537,https://github.com/dbry/WavPack/commit/26cb47f99d481ad9b93eeff80d26e6b63bbd7e15,2018-04-29T15:29Z,"<S2SV_StartBug> int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; <S2SV_EndBug> <S2SV_StartBug> int supported = TRUE , format ; <S2SV_EndBug>"
7671,CWE-119,"int CLASS parse_jpeg ( int offset ) { int len , save , hlen , mark ; fseek ( ifp , offset , SEEK_SET ) ; if ( fgetc ( ifp ) != 0xff || fgetc ( ifp ) != 0xd8 ) return 0 ; while ( fgetc ( ifp ) == 0xff && ( mark = fgetc ( ifp ) ) != 0xda ) { order = 0x4d4d ; len = get2 ( ) - 2 ; save = ftell ( ifp ) ; if ( mark == 0xc0 || mark == 0xc3 || mark == 0xc9 ) { fgetc ( ifp ) ; raw_height = get2 ( ) ; raw_width = get2 ( ) ; } order = get2 ( ) ; hlen = get4 ( ) ; if ( get4 ( ) == 0x48454150 ) { # ifdef LIBRAW_LIBRARY_BUILD imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ; # endif parse_ciff ( save + hlen , len - hlen , 0 ) ; } if ( parse_tiff ( save + 6 ) ) apply_tiff ( ) ; fseek ( ifp , save + len , SEEK_SET ) ; } return 1 ; }
","<S2SV_ModStart> ) == 0x48454150 <S2SV_ModEnd> # ifdef LIBRAW_LIBRARY_BUILD <S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD && ( save + hlen ) >= 0 && ( save + hlen ) <= ifp -> size ( ) # endif ) { # ifdef LIBRAW_LIBRARY_BUILD
",LibRaw@LibRaw/d7c3d2cb460be10a3ea7b32e9443a83c243b2251,CVE-2017-6887,https://github.com/LibRaw/LibRaw/commit/d7c3d2cb460be10a3ea7b32e9443a83c243b2251,2017-05-16T16:29Z,<S2SV_StartBug> if ( get4 ( ) == 0x48454150 ) <S2SV_EndBug> <S2SV_StartBug> imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; <S2SV_EndBug>
938,CWE-284,"int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( ""socket()"" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # ifdef SO_NOSIGPIPE if ( setsockopt ( sfd , SOL_SOCKET , SO_NOSIGPIPE , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # endif memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( ""bind()"" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( ""listen()"" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }
","<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
",libimobiledevice@libusbmuxd/4397b3376dc4e4cb1c991d0aed61ce6482614196,CVE-2016-5104,https://github.com/libimobiledevice/libusbmuxd/commit/4397b3376dc4e4cb1c991d0aed61ce6482614196,2016-06-13T14:59Z,<S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug>
328,CWE-416,"static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; pipe_buf_get ( ipipe , ibuf ) ; obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
","<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe
",torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug>"
1470,CWE-119,"void vp8_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , int recon_uvoffset , int * returnrate , int * returndistortion , int * returnintra , int mb_row , int mb_col ) { BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; MB_MODE_INFO best_mbmode ; int_mv best_ref_mv_sb [ 2 ] ; int_mv mode_mv_sb [ 2 ] [ MB_MODE_COUNT ] ; int_mv best_ref_mv ; int_mv * mode_mv ; MB_PREDICTION_MODE this_mode ; int num00 ; int mdcounts [ 4 ] ; int best_rd = INT_MAX ; int rd_adjustment = 100 ; int best_intra_rd = INT_MAX ; int mode_index ; int rate ; int rate2 ; int distortion2 ; int bestsme = INT_MAX ; int best_mode_index = 0 ; unsigned int sse = INT_MAX , best_rd_sse = INT_MAX ; # if CONFIG_TEMPORAL_DENOISING unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX ; # endif int sf_improved_mv_pred = cpi -> sf . improved_mv_pred ; int_mv mvp ; int near_sadidx [ 8 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int saddone = 0 ; int sr = 0 ; unsigned char * plane [ 4 ] [ 3 ] ; int ref_frame_map [ 4 ] ; int sign_bias = 0 ; # if CONFIG_MULTI_RES_ENCODING int dissim = INT_MAX ; int parent_ref_frame = 0 ; int parent_ref_valid = cpi -> oxcf . mr_encoder_id && cpi -> mr_low_res_mv_avail ; int_mv parent_ref_mv ; MB_PREDICTION_MODE parent_mode = 0 ; if ( parent_ref_valid ) { int parent_ref_flag ; get_lower_res_motion_info ( cpi , xd , & dissim , & parent_ref_frame , & parent_mode , & parent_ref_mv , mb_row , mb_col ) ; parent_ref_flag = 0 ; if ( parent_ref_frame == LAST_FRAME ) parent_ref_flag = ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ; else if ( parent_ref_frame == GOLDEN_FRAME ) parent_ref_flag = ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ; else if ( parent_ref_frame == ALTREF_FRAME ) parent_ref_flag = ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) ; if ( parent_ref_frame && ! parent_ref_flag ) parent_ref_valid = 0 ; } # endif mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int = 0 ; vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; vpx_memset ( & best_mbmode , 0 , sizeof ( best_mbmode ) ) ; # if CONFIG_MULTI_RES_ENCODING if ( parent_ref_valid && parent_ref_frame && dissim < 8 ) { ref_frame_map [ 0 ] = - 1 ; ref_frame_map [ 1 ] = parent_ref_frame ; ref_frame_map [ 2 ] = - 1 ; ref_frame_map [ 3 ] = - 1 ; } else # endif get_reference_search_order ( cpi , ref_frame_map ) ; if ( ref_frame_map [ 1 ] > 0 ) { sign_bias = vp8_find_near_mvs_bias ( & x -> e_mbd , x -> e_mbd . mode_info_context , mode_mv_sb , best_ref_mv_sb , mdcounts , ref_frame_map [ 1 ] , cpi -> common . ref_frame_sign_bias ) ; mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; } get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; x -> mbs_tested_so_far ++ ; * returnintra = INT_MAX ; x -> skip = 0 ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; calculate_zeromv_rd_adjustment ( cpi , x , & rd_adjustment ) ; for ( mode_index = 0 ; mode_index < MAX_MODES ; mode_index ++ ) { int frame_cost ; int this_rd = INT_MAX ; int this_ref_frame = ref_frame_map [ vp8_ref_frame_order [ mode_index ] ] ; if ( best_rd <= x -> rd_threshes [ mode_index ] ) continue ; if ( this_ref_frame < 0 ) continue ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; if ( x -> e_mbd . mode_info_context -> mbmi . ref_frame ) { x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; if ( sign_bias != cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ) { sign_bias = cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ; mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; } # if CONFIG_MULTI_RES_ENCODING if ( parent_ref_valid ) { if ( vp8_mode_order [ mode_index ] == NEARESTMV && mode_mv [ NEARESTMV ] . as_int == 0 ) continue ; if ( vp8_mode_order [ mode_index ] == NEARMV && mode_mv [ NEARMV ] . as_int == 0 ) continue ; if ( vp8_mode_order [ mode_index ] == NEWMV && parent_mode == ZEROMV && best_ref_mv . as_int == 0 ) continue ; else if ( vp8_mode_order [ mode_index ] == NEWMV && dissim == 0 && best_ref_mv . as_int == parent_ref_mv . as_int ) continue ; } # endif } if ( x -> mode_test_hit_counts [ mode_index ] && ( cpi -> mode_check_freq [ mode_index ] > 1 ) ) { if ( x -> mbs_tested_so_far <= ( cpi -> mode_check_freq [ mode_index ] * x -> mode_test_hit_counts [ mode_index ] ) ) { x -> rd_thresh_mult [ mode_index ] += 4 ; if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ; continue ; } } x -> mode_test_hit_counts [ mode_index ] ++ ; rate2 = 0 ; distortion2 = 0 ; this_mode = vp8_mode_order [ mode_index ] ; x -> e_mbd . mode_info_context -> mbmi . mode = this_mode ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; frame_cost = x -> ref_frame_cost [ x -> e_mbd . mode_info_context -> mbmi . ref_frame ] ; rate2 += frame_cost ; if ( cpi -> is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) { if ( this_mode != ZEROMV || x -> e_mbd . mode_info_context -> mbmi . ref_frame != ALTREF_FRAME ) continue ; } switch ( this_mode ) { case B_PRED : distortion2 = best_rd_sse ; pick_intra4x4mby_modes ( x , & rate , & distortion2 ) ; if ( distortion2 == INT_MAX ) { this_rd = INT_MAX ; } else { rate2 += rate ; distortion2 = vp8_variance16x16 ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; if ( this_rd < best_intra_rd ) { best_intra_rd = this_rd ; * returnintra = distortion2 ; } } break ; case SPLITMV : break ; case DC_PRED : case V_PRED : case H_PRED : case TM_PRED : vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ; distortion2 = vp8_variance16x16 ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ; rate2 += x -> mbmode_cost [ x -> e_mbd . frame_type ] [ x -> e_mbd . mode_info_context -> mbmi . mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; if ( this_rd < best_intra_rd ) { best_intra_rd = this_rd ; * returnintra = distortion2 ; } break ; case NEWMV : { int thissme ; int step_param ; int further_steps ; int n = 0 ; int sadpb = x -> sadperbit16 ; int_mv mvp_full ; int col_min = ( ( best_ref_mv . as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int row_min = ( ( best_ref_mv . as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int col_max = ( best_ref_mv . as_mv . col >> 3 ) + MAX_FULL_PEL_VAL ; int row_max = ( best_ref_mv . as_mv . row >> 3 ) + MAX_FULL_PEL_VAL ; int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; int tmp_row_max = x -> mv_row_max ; int speed_adjust = ( cpi -> Speed > 5 ) ? ( ( cpi -> Speed >= 8 ) ? 3 : 2 ) : 1 ; step_param = cpi -> sf . first_step + speed_adjust ; # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id && ! parent_ref_valid ) sf_improved_mv_pred = 0 ; if ( parent_ref_valid && parent_ref_frame ) { mvp . as_int = parent_ref_mv . as_int ; mvp_full . as_mv . col = parent_ref_mv . as_mv . col >> 3 ; mvp_full . as_mv . row = parent_ref_mv . as_mv . row >> 3 ; if ( dissim <= 32 ) step_param += 3 ; else if ( dissim <= 128 ) step_param += 2 ; else step_param += 1 ; } else # endif { if ( sf_improved_mv_pred ) { if ( ! saddone ) { vp8_cal_sad ( cpi , xd , x , recon_yoffset , & near_sadidx [ 0 ] ) ; saddone = 1 ; } vp8_mv_pred ( cpi , & x -> e_mbd , x -> e_mbd . mode_info_context , & mvp , x -> e_mbd . mode_info_context -> mbmi . ref_frame , cpi -> common . ref_frame_sign_bias , & sr , & near_sadidx [ 0 ] ) ; sr += speed_adjust ; if ( sr > step_param ) step_param = sr ; mvp_full . as_mv . col = mvp . as_mv . col >> 3 ; mvp_full . as_mv . row = mvp . as_mv . row >> 3 ; } else { mvp . as_int = best_ref_mv . as_int ; mvp_full . as_mv . col = best_ref_mv . as_mv . col >> 3 ; mvp_full . as_mv . row = best_ref_mv . as_mv . row >> 3 ; } } # if CONFIG_MULTI_RES_ENCODING if ( parent_ref_valid && parent_ref_frame && dissim <= 2 && MAX ( abs ( best_ref_mv . as_mv . row - parent_ref_mv . as_mv . row ) , abs ( best_ref_mv . as_mv . col - parent_ref_mv . as_mv . col ) ) <= 4 ) { d -> bmi . mv . as_int = mvp_full . as_int ; mode_mv [ NEWMV ] . as_int = mvp_full . as_int ; cpi -> find_fractional_mv_step ( x , b , d , & d -> bmi . mv , & best_ref_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , cpi -> mb . mvcost , & distortion2 , & sse ) ; } else # endif { if ( x -> mv_col_min < col_min ) x -> mv_col_min = col_min ; if ( x -> mv_col_max > col_max ) x -> mv_col_max = col_max ; if ( x -> mv_row_min < row_min ) x -> mv_row_min = row_min ; if ( x -> mv_row_max > row_max ) x -> mv_row_max = row_max ; further_steps = ( cpi -> Speed >= 8 ) ? 0 : ( cpi -> sf . max_step_search_steps - 1 - step_param ) ; if ( cpi -> sf . search_method == HEX ) { # if CONFIG_MULTI_RES_ENCODING if ( ! parent_ref_valid ) step_param = 0 ; # endif bestsme = vp8_hex_search ( x , b , d , & mvp_full , & d -> bmi . mv , step_param , sadpb , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvsadcost , x -> mvcost , & best_ref_mv ) ; mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; } else { bestsme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ; mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; n = num00 ; num00 = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { thissme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param + n , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ; if ( thissme < bestsme ) { bestsme = thissme ; mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; } else { d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ; } } } } x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) cpi -> find_fractional_mv_step ( x , b , d , & d -> bmi . mv , & best_ref_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , cpi -> mb . mvcost , & distortion2 , & sse ) ; } mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , cpi -> mb . mvcost , 128 ) ; } case NEARESTMV : case NEARMV : if ( mode_mv [ this_mode ] . as_int == 0 ) continue ; case ZEROMV : if ( ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) < x -> mv_row_min ) || ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) > x -> mv_row_max ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) < x -> mv_col_min ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) > x -> mv_col_max ) ) continue ; rate2 += vp8_cost_mv_ref ( this_mode , mdcounts ) ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = mode_mv [ this_mode ] . as_int ; this_rd = evaluate_inter_mode ( & sse , rate2 , & distortion2 , cpi , x , rd_adjustment ) ; break ; default : break ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { if ( this_mode == ZEROMV && sse < zero_mv_sse ) { zero_mv_sse = sse ; x -> best_zeromv_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ; } if ( x -> e_mbd . mode_info_context -> mbmi . mode == NEWMV && sse < best_sse ) { best_sse = sse ; x -> best_sse_inter_mode = NEWMV ; x -> best_sse_mv = x -> e_mbd . mode_info_context -> mbmi . mv ; x -> need_to_clamp_best_mvs = x -> e_mbd . mode_info_context -> mbmi . need_to_clamp_mvs ; x -> best_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ; } } # endif if ( this_rd < best_rd || x -> skip ) { best_mode_index = mode_index ; * returnrate = rate2 ; * returndistortion = distortion2 ; best_rd_sse = sse ; best_rd = this_rd ; vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , sizeof ( MB_MODE_INFO ) ) ; x -> rd_thresh_mult [ mode_index ] = ( x -> rd_thresh_mult [ mode_index ] >= ( MIN_THRESHMULT + 2 ) ) ? x -> rd_thresh_mult [ mode_index ] - 2 : MIN_THRESHMULT ; x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ; } else { x -> rd_thresh_mult [ mode_index ] += 4 ; if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ; } if ( x -> skip ) break ; } if ( ( cpi -> rd_baseline_thresh [ best_mode_index ] > 0 ) && ( cpi -> rd_baseline_thresh [ best_mode_index ] < ( INT_MAX >> 2 ) ) ) { int best_adjustment = ( x -> rd_thresh_mult [ best_mode_index ] >> 3 ) ; x -> rd_thresh_mult [ best_mode_index ] = ( x -> rd_thresh_mult [ best_mode_index ] >= ( MIN_THRESHMULT + best_adjustment ) ) ? x -> rd_thresh_mult [ best_mode_index ] - best_adjustment : MIN_THRESHMULT ; x -> rd_threshes [ best_mode_index ] = ( cpi -> rd_baseline_thresh [ best_mode_index ] >> 7 ) * x -> rd_thresh_mult [ best_mode_index ] ; } { int this_rdbin = ( * returndistortion >> 7 ) ; if ( this_rdbin >= 1024 ) { this_rdbin = 1023 ; } x -> error_bins [ this_rdbin ] ++ ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { if ( x -> best_sse_inter_mode == DC_PRED ) { x -> best_sse_inter_mode = best_mbmode . mode ; x -> best_sse_mv = best_mbmode . mv ; x -> need_to_clamp_best_mvs = best_mbmode . need_to_clamp_mvs ; x -> best_reference_frame = best_mbmode . ref_frame ; best_sse = best_rd_sse ; } vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , recon_yoffset , recon_uvoffset ) ; if ( best_mbmode . ref_frame == INTRA_FRAME && x -> best_zeromv_reference_frame != INTRA_FRAME ) { int this_rd = 0 ; int this_ref_frame = x -> best_zeromv_reference_frame ; rate2 = x -> ref_frame_cost [ this_ref_frame ] + vp8_cost_mv_ref ( ZEROMV , mdcounts ) ; distortion2 = 0 ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; this_rd = evaluate_inter_mode ( & sse , rate2 , & distortion2 , cpi , x , rd_adjustment ) ; if ( this_rd < best_rd ) { vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , sizeof ( MB_MODE_INFO ) ) ; } } } # endif if ( cpi -> is_src_frame_alt_ref && ( best_mbmode . mode != ZEROMV || best_mbmode . ref_frame != ALTREF_FRAME ) ) { x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = ALTREF_FRAME ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . mb_skip_coeff = ( cpi -> common . mb_no_coeff_skip ) ; x -> e_mbd . mode_info_context -> mbmi . partitioning = 0 ; return ; } if ( ! x -> skip ) vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mbmode , sizeof ( MB_MODE_INFO ) ) ; if ( best_mbmode . mode <= B_PRED ) { pick_intra_mbuv_mode ( x ) ; } if ( sign_bias != cpi -> common . ref_frame_sign_bias [ xd -> mode_info_context -> mbmi . ref_frame ] ) best_ref_mv . as_int = best_ref_mv_sb [ ! sign_bias ] . as_int ; update_mvcount ( x , & best_ref_mv ) ; }
","<S2SV_ModStart> int sse = UINT_MAX <S2SV_ModEnd> , best_rd_sse = <S2SV_ModStart> , best_rd_sse = UINT_MAX <S2SV_ModEnd> ; # if <S2SV_ModStart> int zero_mv_sse = UINT_MAX <S2SV_ModEnd> , best_sse = <S2SV_ModStart> , best_sse = UINT_MAX <S2SV_ModEnd> ; # endif <S2SV_ModStart> . improved_mv_pred ; # if CONFIG_MULTI_RES_ENCODING int dissim = INT_MAX ; int parent_ref_frame = 0 ; int_mv parent_ref_mv ; MB_PREDICTION_MODE parent_mode = 0 ; int parent_ref_valid = 0 ; # endif <S2SV_ModStart> = 0 ; int dot_artifact_candidate = 0 ; get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) { unsigned char * target_y = x -> src . y_buffer ; unsigned char * target_u = x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src ; unsigned char * target_v = x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src ; int stride = x -> src . y_stride ; int stride_uv = x -> block [ 16 ] . src_stride ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { const int uv_denoise = ( cpi -> oxcf . noise_sensitivity >= 2 ) ? 1 : 0 ; target_y = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_buffer + recon_yoffset ; stride = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_stride ; if ( uv_denoise ) { target_u = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . u_buffer + recon_uvoffset ; target_v = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . v_buffer + recon_uvoffset ; stride_uv = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . uv_stride ; } } # endif dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_y , stride , plane [ LAST_FRAME ] [ 0 ] , mb_row , mb_col , 0 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_u , stride_uv , plane [ LAST_FRAME ] [ 1 ] , mb_row , mb_col , 1 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_v , stride_uv , plane [ LAST_FRAME ] [ 2 ] , mb_row , mb_col , 2 ) ; } } } # if CONFIG_MULTI_RES_ENCODING <S2SV_ModEnd> parent_ref_valid = cpi <S2SV_ModStart> cpi -> mr_low_res_mv_avail <S2SV_ModEnd> ; if ( <S2SV_ModStart> ref_frame_flags & VP8_GOLD_FRAME <S2SV_ModEnd> ) ; if <S2SV_ModStart> = 0 ; if ( dot_artifact_candidate ) parent_ref_valid = 0 ; <S2SV_ModStart> } # endif { const int y = x -> src . y_buffer [ 7 * x -> src . y_stride + 7 ] ; const int cb = x -> src . u_buffer [ 3 * x -> src . uv_stride + 3 ] ; const int cr = x -> src . v_buffer [ 3 * x -> src . uv_stride + 3 ] ; x -> is_skin = 0 ; if ( ! cpi -> oxcf . screen_content_mode ) x -> is_skin = is_skin_color ( y , cb , cr ) ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { } # endif <S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( mode_mv_sb , <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( & best_mbmode <S2SV_ModStart> as_int ; } <S2SV_ModEnd> x -> mbs_tested_so_far <S2SV_ModStart> = INTRA_FRAME ; if ( cpi -> Speed < 12 ) { <S2SV_ModStart> rd_adjustment ) ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { rd_adjustment = ( int ) ( rd_adjustment * cpi -> denoiser . denoise_pars . pickmode_mv_bias / 100 ) ; } # endif if ( dot_artifact_candidate ) { rd_adjustment = 150 ; } <S2SV_ModStart> ; distortion2 = vpx_variance16x16 <S2SV_ModEnd> ( * ( <S2SV_ModStart> ; distortion2 = vpx_variance16x16 <S2SV_ModEnd> ( * ( <S2SV_ModStart> oxcf . mr_encoder_id <S2SV_ModEnd> ) sf_improved_mv_pred = <S2SV_ModStart> ( parent_ref_valid && ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> ) { mvp <S2SV_ModStart> ( parent_ref_valid && ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> && dissim <= <S2SV_ModStart> ( ! parent_ref_valid || ( parent_ref_frame != this_ref_frame ) <S2SV_ModStart> . as_int ; vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ; <S2SV_ModStart> noise_sensitivity ) { int skip_old_reference = ( ( this_ref_frame != LAST_FRAME ) && ( cpi -> common . current_video_frame - cpi -> current_ref_frames [ this_ref_frame ] > MAX_GF_ARF_DENOISE_RANGE ) ) ? 1 : 0 ; <S2SV_ModStart> sse < zero_mv_sse && ! skip_old_reference <S2SV_ModStart> sse < best_sse && ! skip_old_reference <S2SV_ModStart> = this_rd ; memcpy <S2SV_ModEnd> ( & best_mbmode <S2SV_ModStart> noise_sensitivity ) { int block_index = mb_row * cpi -> common . mb_cols + mb_col ; int reevaluate = 0 ; int is_noisy = 0 ; <S2SV_ModStart> best_rd_sse ; } if ( cpi -> oxcf . noise_sensitivity == 4 ) { if ( cpi -> denoiser . nmse_source_diff > 70 * cpi -> denoiser . threshold_aggressive_mode / 100 ) is_noisy = 1 ; } else { if ( cpi -> mse_source_denoised > 1000 ) is_noisy = 1 ; } x -> increase_denoising = 0 ; if ( ! x -> is_skin && x -> best_sse_inter_mode == ZEROMV && ( x -> best_reference_frame == LAST_FRAME || x -> best_reference_frame == cpi -> closest_reference_frame ) && cpi -> consec_zero_last [ block_index ] >= 20 && is_noisy ) { x -> increase_denoising = 1 ; } x -> denoise_zeromv = 0 ; <S2SV_ModStart> recon_yoffset , recon_uvoffset , & cpi -> common . lf_info , mb_row , mb_col , block_index ) ; reevaluate = <S2SV_ModEnd> ( best_mbmode . <S2SV_ModStart> ref_frame == INTRA_FRAME ) || ( best_mbmode . mode != ZEROMV && x -> denoise_zeromv && cpi -> mse_source_denoised > 2000 ) ; if ( ! dot_artifact_candidate && reevaluate <S2SV_ModStart> -> best_zeromv_reference_frame ; rd_adjustment = 100 ; <S2SV_ModStart> best_rd ) { memcpy <S2SV_ModEnd> ( & best_mbmode <S2SV_ModStart> -> skip ) memcpy <S2SV_ModEnd> ( & x
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> unsigned int sse = INT_MAX , best_rd_sse = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> int sf_improved_mv_pred = cpi -> sf . improved_mv_pred ; <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> <S2SV_StartBug> int parent_ref_valid = cpi -> oxcf . mr_encoder_id && cpi -> mr_low_res_mv_avail ; <S2SV_EndBug> <S2SV_StartBug> parent_ref_flag = ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> mode_mv = mode_mv_sb [ sign_bias ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mbmode , 0 , sizeof ( best_mbmode ) ) ; <S2SV_EndBug> <S2SV_StartBug> get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> <S2SV_StartBug> calculate_zeromv_rd_adjustment ( cpi , x , & rd_adjustment ) ; <S2SV_EndBug> <S2SV_StartBug> distortion2 = vp8_variance16x16 ( <S2SV_EndBug> <S2SV_StartBug> distortion2 = vp8_variance16x16 <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . mr_encoder_id && ! parent_ref_valid ) <S2SV_EndBug> <S2SV_StartBug> if ( parent_ref_valid && parent_ref_frame ) <S2SV_EndBug> <S2SV_StartBug> if ( parent_ref_valid && parent_ref_frame && dissim <= 2 && <S2SV_EndBug> <S2SV_StartBug> if ( ! parent_ref_valid ) <S2SV_EndBug> <S2SV_StartBug> rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( this_mode == ZEROMV && sse < zero_mv_sse ) <S2SV_EndBug> <S2SV_StartBug> sse < best_sse ) <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , <S2SV_EndBug> <S2SV_StartBug> if ( x -> best_sse_inter_mode == DC_PRED ) <S2SV_EndBug> <S2SV_StartBug> vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , <S2SV_EndBug> <S2SV_StartBug> recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_mbmode . ref_frame == INTRA_FRAME && <S2SV_EndBug> <S2SV_StartBug> rate2 = x -> ref_frame_cost [ this_ref_frame ] + <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mbmode , <S2SV_EndBug>"
1830,CWE-119,"int vp9_rc_pick_q_and_bounds ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { int q ; if ( cpi -> pass == 0 ) { if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) q = rc_pick_q_and_bounds_one_pass_cbr ( cpi , bottom_index , top_index ) ; else q = rc_pick_q_and_bounds_one_pass_vbr ( cpi , bottom_index , top_index ) ; } else { q = rc_pick_q_and_bounds_two_pass ( cpi , bottom_index , top_index ) ; } if ( cpi -> sf . use_nonrd_pick_mode ) { if ( q == 0 ) q ++ ; if ( cpi -> sf . force_frame_boost == 1 ) q -= cpi -> sf . max_delta_qindex ; if ( q < * bottom_index ) * bottom_index = q ; else if ( q > * top_index ) * top_index = q ; } return q ; }
","<S2SV_ModStart> ( cpi -> oxcf . <S2SV_ModStart> -> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> ) q = <S2SV_ModStart> { if ( <S2SV_ModEnd> cpi -> sf
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> if ( cpi -> pass == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) <S2SV_EndBug> <S2SV_StartBug> if ( q == 0 ) <S2SV_EndBug>
2840,CWE-125,"static char * get_icu_value_internal ( const char * loc_name , char * tag_name , int * result , int fromParseLocale ) { char * tag_value = NULL ; int32_t tag_value_len = 512 ; int singletonPos = 0 ; char * mod_loc_name = NULL ; int grOffset = 0 ; int32_t buflen = 512 ; UErrorCode status = U_ZERO_ERROR ; if ( strcmp ( tag_name , LOC_CANONICALIZE_TAG ) != 0 ) { grOffset = findOffset ( LOC_GRANDFATHERED , loc_name ) ; if ( grOffset >= 0 ) { if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { return estrdup ( loc_name ) ; } else { return NULL ; } } if ( fromParseLocale == 1 ) { if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { if ( strlen ( loc_name ) > 1 && ( isIDPrefix ( loc_name ) == 1 ) ) { return estrdup ( loc_name ) ; } } singletonPos = getSingletonPos ( loc_name ) ; if ( singletonPos == 0 ) { return NULL ; } else if ( singletonPos > 0 ) { mod_loc_name = estrndup ( loc_name , singletonPos - 1 ) ; } } } if ( mod_loc_name == NULL ) { mod_loc_name = estrdup ( loc_name ) ; } do { tag_value = erealloc ( tag_value , buflen ) ; tag_value_len = buflen ; if ( strcmp ( tag_name , LOC_SCRIPT_TAG ) == 0 ) { buflen = uloc_getScript ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { buflen = uloc_getLanguage ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_REGION_TAG ) == 0 ) { buflen = uloc_getCountry ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_VARIANT_TAG ) == 0 ) { buflen = uloc_getVariant ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_CANONICALIZE_TAG ) == 0 ) { buflen = uloc_canonicalize ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( U_FAILURE ( status ) ) { if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; continue ; } * result = 0 ; if ( tag_value ) { efree ( tag_value ) ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return NULL ; } } while ( buflen > tag_value_len ) ; if ( buflen == 0 ) { * result = - 1 ; if ( tag_value ) { efree ( tag_value ) ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return NULL ; } else { * result = 1 ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return tag_value ; }
","<S2SV_ModStart> = U_ZERO_ERROR ; buflen ++ ;
",php@php-src/97eff7eb57fc2320c267a949cffd622c38712484,CVE-2016-5093,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484?w=1,2016-08-07T10:59Z,<S2SV_StartBug> continue ; <S2SV_EndBug>
8418,CWE-94,"int StreamTcpPacket ( ThreadVars * tv , Packet * p , StreamTcpThread * stt , PacketQueue * pq ) { SCEnter ( ) ; DEBUG_ASSERT_FLOW_LOCKED ( p -> flow ) ; SCLogDebug ( ""p->pcap_cnt<S2SV_blank>%"" PRIu64 , p -> pcap_cnt ) ; HandleThreadId ( tv , p , stt ) ; TcpSession * ssn = ( TcpSession * ) p -> flow -> protoctx ; if ( ssn != NULL ) { ssn -> tcp_packet_flags |= p -> tcph -> th_flags ; if ( PKT_IS_TOSERVER ( p ) ) ssn -> client . tcp_flags |= p -> tcph -> th_flags ; else if ( PKT_IS_TOCLIENT ( p ) ) ssn -> server . tcp_flags |= p -> tcph -> th_flags ; if ( ssn -> flags & STREAMTCP_FLAG_ASYNC && ssn -> client . tcp_flags != 0 && ssn -> server . tcp_flags != 0 ) { SCLogDebug ( ""ssn<S2SV_blank>%p:<S2SV_blank>removing<S2SV_blank>ASYNC<S2SV_blank>flag<S2SV_blank>as<S2SV_blank>we<S2SV_blank>have<S2SV_blank>packets<S2SV_blank>on<S2SV_blank>both<S2SV_blank>sides"" , ssn ) ; ssn -> flags &= ~ STREAMTCP_FLAG_ASYNC ; } } if ( ( p -> tcph -> th_flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) { StatsIncr ( tv , stt -> counter_tcp_synack ) ; } else if ( p -> tcph -> th_flags & ( TH_SYN ) ) { StatsIncr ( tv , stt -> counter_tcp_syn ) ; } if ( p -> tcph -> th_flags & ( TH_RST ) ) { StatsIncr ( tv , stt -> counter_tcp_rst ) ; } if ( ! ( p -> tcph -> th_flags & TH_ACK ) && TCP_GET_ACK ( p ) != 0 ) { StreamTcpSetEvent ( p , STREAM_PKT_BROKEN_ACK ) ; } if ( StreamTcpCheckFlowDrops ( p ) == 1 ) { SCLogDebug ( ""This<S2SV_blank>flow/stream<S2SV_blank>triggered<S2SV_blank>a<S2SV_blank>drop<S2SV_blank>rule"" ) ; FlowSetNoPacketInspectionFlag ( p -> flow ) ; DecodeSetNoPacketInspectionFlag ( p ) ; StreamTcpDisableAppLayer ( p -> flow ) ; PACKET_DROP ( p ) ; StreamTcpSessionPktFree ( p ) ; SCReturnInt ( 0 ) ; } if ( ssn == NULL || ssn -> state == TCP_NONE ) { if ( StreamTcpPacketStateNone ( tv , p , stt , ssn , & stt -> pseudo_queue ) == - 1 ) { goto error ; } if ( ssn != NULL ) SCLogDebug ( ""ssn->alproto<S2SV_blank>%"" PRIu16 """" , p -> flow -> alproto ) ; } else { if ( p -> flags & PKT_PSEUDO_STREAM_END ) { if ( PKT_IS_TOCLIENT ( p ) ) { ssn -> client . last_ack = TCP_GET_ACK ( p ) ; StreamTcpReassembleHandleSegment ( tv , stt -> ra_ctx , ssn , & ssn -> server , p , pq ) ; } else { ssn -> server . last_ack = TCP_GET_ACK ( p ) ; StreamTcpReassembleHandleSegment ( tv , stt -> ra_ctx , ssn , & ssn -> client , p , pq ) ; } goto skip ; } if ( p -> flow -> flags & FLOW_WRONG_THREAD || ssn -> client . flags & STREAMTCP_STREAM_FLAG_GAP || ssn -> server . flags & STREAMTCP_STREAM_FLAG_GAP ) { p -> flags |= PKT_STREAM_NO_EVENTS ; } if ( StreamTcpPacketIsKeepAlive ( ssn , p ) == 1 ) { goto skip ; } if ( StreamTcpPacketIsKeepAliveACK ( ssn , p ) == 1 ) { StreamTcpClearKeepAliveFlag ( ssn , p ) ; goto skip ; } StreamTcpClearKeepAliveFlag ( ssn , p ) ; if ( StreamTcpPacketIsFinShutdownAck ( ssn , p ) == 0 ) if ( StreamTcpPacketIsWindowUpdate ( ssn , p ) == 0 ) if ( StreamTcpPacketIsBadWindowUpdate ( ssn , p ) ) goto skip ; if ( StreamTcpStateDispatch ( tv , p , stt , ssn , & stt -> pseudo_queue , ssn -> state ) < 0 ) goto error ; skip : StreamTcpPacketCheckPostRst ( ssn , p ) ; if ( ssn -> state >= TCP_ESTABLISHED ) { p -> flags |= PKT_STREAM_EST ; } } if ( ssn != NULL ) { while ( stt -> pseudo_queue . len > 0 ) { SCLogDebug ( ""processing<S2SV_blank>pseudo<S2SV_blank>packet<S2SV_blank>/<S2SV_blank>stream<S2SV_blank>end"" ) ; Packet * np = PacketDequeue ( & stt -> pseudo_queue ) ; if ( np != NULL ) { if ( PKT_IS_TOSERVER ( np ) ) { SCLogDebug ( ""pseudo<S2SV_blank>packet<S2SV_blank>is<S2SV_blank>to<S2SV_blank>server"" ) ; StreamTcpReassembleHandleSegment ( tv , stt -> ra_ctx , ssn , & ssn -> client , np , NULL ) ; } else { SCLogDebug ( ""pseudo<S2SV_blank>packet<S2SV_blank>is<S2SV_blank>to<S2SV_blank>client"" ) ; StreamTcpReassembleHandleSegment ( tv , stt -> ra_ctx , ssn , & ssn -> server , np , NULL ) ; } PacketEnqueue ( pq , np ) ; } SCLogDebug ( ""processing<S2SV_blank>pseudo<S2SV_blank>packet<S2SV_blank>/<S2SV_blank>stream<S2SV_blank>end<S2SV_blank>done"" ) ; } if ( p -> flags & PKT_STREAM_MODIFIED ) { ReCalculateChecksum ( p ) ; } if ( ( ssn -> client . flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED ) || ( ssn -> server . flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED ) ) { if ( StreamTcpBypassEnabled ( ) ) { PacketBypassCallback ( p ) ; } } if ( ( ssn -> client . flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED ) || ( ssn -> server . flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED ) ) { p -> flags |= PKT_STREAM_NOPCAPLOG ; } if ( ( PKT_IS_TOSERVER ( p ) && ( ssn -> client . flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY ) ) || ( PKT_IS_TOCLIENT ( p ) && ( ssn -> server . flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY ) ) ) { p -> flags |= PKT_STREAM_NOPCAPLOG ; } if ( ssn -> flags & STREAMTCP_FLAG_BYPASS ) { if ( StreamTcpBypassEnabled ( ) ) { PacketBypassCallback ( p ) ; } } else if ( g_detect_disabled && ( ssn -> client . flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY ) && ( ssn -> server . flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY ) && StreamTcpBypassEnabled ( ) ) { SCLogDebug ( ""bypass<S2SV_blank>as<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>dead<S2SV_blank>and<S2SV_blank>we<S2SV_blank>have<S2SV_blank>no<S2SV_blank>rules"" ) ; PacketBypassCallback ( p ) ; } } SCReturnInt ( 0 ) ; error : while ( stt -> pseudo_queue . len > 0 ) { Packet * np = PacketDequeue ( & stt -> pseudo_queue ) ; if ( np != NULL ) { PacketEnqueue ( pq , np ) ; } } if ( p -> flags & PKT_STREAM_MODIFIED ) { ReCalculateChecksum ( p ) ; } if ( StreamTcpInlineDropInvalid ( ) ) { DecodeSetNoPayloadInspectionFlag ( p ) ; PACKET_DROP ( p ) ; } SCReturnInt ( - 1 ) ; }
","<S2SV_ModStart> , STREAM_PKT_BROKEN_ACK ) ; goto error
",OISF@suricata/fa692df37a796c3330c81988d15ef1a219afc006,CVE-2019-18792,https://github.com/OISF/suricata/commit/fa692df37a796c3330c81988d15ef1a219afc006,2020-01-06T18:15Z,"<S2SV_StartBug> StreamTcpSetEvent ( p , STREAM_PKT_BROKEN_ACK ) ; <S2SV_EndBug>"
5585,CWE-399,"int cib_remote_perform_op ( cib_t * cib , const char * op , const char * host , const char * section , xmlNode * data , xmlNode * * output_data , int call_options , const char * name ) { int rc = pcmk_ok ; xmlNode * op_msg = NULL ; xmlNode * op_reply = NULL ; cib_remote_opaque_t * private = cib -> variant_opaque ; if ( sync_timer == NULL ) { sync_timer = calloc ( 1 , sizeof ( struct timer_rec_s ) ) ; } if ( cib -> state == cib_disconnected ) { return - ENOTCONN ; } if ( output_data != NULL ) { * output_data = NULL ; } if ( op == NULL ) { crm_err ( ""No<S2SV_blank>operation<S2SV_blank>specified"" ) ; return - EINVAL ; } cib -> call_id ++ ; if ( cib -> call_id < 1 ) { cib -> call_id = 1 ; } op_msg = cib_create_op ( cib -> call_id , private -> callback . token , op , host , section , data , call_options , NULL ) ; if ( op_msg == NULL ) { return - EPROTO ; } crm_trace ( ""Sending<S2SV_blank>%s<S2SV_blank>message<S2SV_blank>to<S2SV_blank>CIB<S2SV_blank>service"" , op ) ; crm_send_remote_msg ( private -> command . session , op_msg , private -> command . encrypted ) ; free_xml ( op_msg ) ; if ( ( call_options & cib_discard_reply ) ) { crm_trace ( ""Discarding<S2SV_blank>reply"" ) ; return pcmk_ok ; } else if ( ! ( call_options & cib_sync_call ) ) { return cib -> call_id ; } crm_trace ( ""Waiting<S2SV_blank>for<S2SV_blank>a<S2SV_blank>syncronous<S2SV_blank>reply"" ) ; if ( cib -> call_timeout > 0 ) { timer_expired = FALSE ; sync_timer -> call_id = cib -> call_id ; sync_timer -> timeout = cib -> call_timeout * 1000 ; sync_timer -> ref = g_timeout_add ( sync_timer -> timeout , cib_timeout_handler , sync_timer ) ; } while ( timer_expired == FALSE ) { int reply_id = - 1 ; int msg_id = cib -> call_id ; op_reply = crm_recv_remote_msg ( private -> command . session , private -> command . encrypted ) ; if ( op_reply == NULL ) { break ; } crm_element_value_int ( op_reply , F_CIB_CALLID , & reply_id ) ; CRM_CHECK ( reply_id > 0 , free_xml ( op_reply ) ; if ( sync_timer -> ref > 0 ) { g_source_remove ( sync_timer -> ref ) ; sync_timer -> ref = 0 ; } return - ENOMSG ) ; if ( reply_id == msg_id ) { break ; } else if ( reply_id < msg_id ) { crm_debug ( ""Received<S2SV_blank>old<S2SV_blank>reply:<S2SV_blank>%d<S2SV_blank>(wanted<S2SV_blank>%d)"" , reply_id , msg_id ) ; crm_log_xml_trace ( op_reply , ""Old<S2SV_blank>reply"" ) ; } else if ( ( reply_id - 10000 ) > msg_id ) { crm_debug ( ""Received<S2SV_blank>old<S2SV_blank>reply:<S2SV_blank>%d<S2SV_blank>(wanted<S2SV_blank>%d)"" , reply_id , msg_id ) ; crm_log_xml_trace ( op_reply , ""Old<S2SV_blank>reply"" ) ; } else { crm_err ( ""Received<S2SV_blank>a<S2SV_blank>__future__<S2SV_blank>reply:"" ""<S2SV_blank>%d<S2SV_blank>(wanted<S2SV_blank>%d)"" , reply_id , msg_id ) ; } free_xml ( op_reply ) ; op_reply = NULL ; } if ( sync_timer -> ref > 0 ) { g_source_remove ( sync_timer -> ref ) ; sync_timer -> ref = 0 ; } if ( timer_expired ) { return - ETIME ; } if ( op_reply == NULL ) { crm_err ( ""No<S2SV_blank>reply<S2SV_blank>message<S2SV_blank>-<S2SV_blank>empty"" ) ; return - ENOMSG ; } crm_trace ( ""Syncronous<S2SV_blank>reply<S2SV_blank>received"" ) ; if ( crm_element_value_int ( op_reply , F_CIB_RC , & rc ) != 0 ) { rc = - EPROTO ; } if ( rc == - pcmk_err_diff_resync ) { rc = pcmk_ok ; } if ( rc == pcmk_ok || rc == - EPERM ) { crm_log_xml_debug ( op_reply , ""passed"" ) ; } else { crm_err ( ""Call<S2SV_blank>failed:<S2SV_blank>%s"" , pcmk_strerror ( rc ) ) ; crm_log_xml_warn ( op_reply , ""failed"" ) ; } if ( output_data == NULL ) { } else if ( ! ( call_options & cib_discard_reply ) ) { xmlNode * tmp = get_message_xml ( op_reply , F_CIB_CALLDATA ) ; if ( tmp == NULL ) { crm_trace ( ""No<S2SV_blank>output<S2SV_blank>in<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>\\""%s\\""<S2SV_blank>command<S2SV_blank>%d"" , op , cib -> call_id - 1 ) ; } else { * output_data = copy_xml ( tmp ) ; } } free_xml ( op_reply ) ; return rc ; }
","<S2SV_ModStart> = pcmk_ok ; int disconnected = 0 ; int remaining_time = 0 ; time_t start_time ; <S2SV_ModStart> -> variant_opaque ; <S2SV_ModEnd> if ( cib <S2SV_ModStart> op ) ; if ( ! ( call_options & cib_sync_call ) ) { <S2SV_ModStart> ( private -> callback . session , op_msg , private -> command . encrypted ) ; } else { crm_send_remote_msg ( private -> command . <S2SV_ModEnd> session , op_msg <S2SV_ModStart> encrypted ) ; } <S2SV_ModStart> ""Waiting<S2SV_blank>for<S2SV_blank>a<S2SV_blank>syncronous<S2SV_blank>reply"" ) ; start_time = time ( NULL ) ; remaining_time = <S2SV_ModEnd> cib -> call_timeout <S2SV_ModStart> cib -> call_timeout ? cib -> call_timeout : 60 ; while ( remaining_time > 0 && ! disconnected <S2SV_ModEnd> ) { int <S2SV_ModStart> -> call_id ; <S2SV_ModEnd> crm_recv_remote_msg ( private <S2SV_ModStart> . session , & <S2SV_ModStart> -> command . recv_buf , private -> command . encrypted , remaining_time * 1000 , & disconnected ) ; op_reply = crm_parse_remote_buffer ( & private -> command . recv_buf ) ; if ( ! op_reply <S2SV_ModEnd> ) { break <S2SV_ModStart> , & reply_id <S2SV_ModEnd> ) ; if <S2SV_ModStart> = NULL ; remaining_time = time ( NULL ) - start_time ; } if ( disconnected ) { crm_err ( ""Disconnected<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>reply."" ) ; return - ENOTCONN ; } else <S2SV_ModEnd> if ( op_reply
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z,"<S2SV_StartBug> xmlNode * op_msg = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( sync_timer == NULL ) { <S2SV_EndBug> <S2SV_StartBug> crm_send_remote_msg ( private -> command . session , op_msg , private -> command . encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cib -> call_timeout > 0 ) { <S2SV_EndBug> <S2SV_StartBug> op_reply = crm_recv_remote_msg ( private -> command . session , private -> command . encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> crm_element_value_int ( op_reply , F_CIB_CALLID , & reply_id ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
4071,CWE-416,"static Image * ReadMATImageV4 ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { typedef struct { unsigned char Type [ 4 ] ; unsigned int nRows ; unsigned int nCols ; unsigned int imagf ; unsigned int nameLen ; } MAT4_HDR ; long ldblk ; EndianType endian ; Image * rotated_image ; MagickBooleanType status ; MAT4_HDR HDR ; QuantumInfo * quantum_info ; QuantumFormatType format_type ; register ssize_t i ; ssize_t count , y ; unsigned char * pixels ; unsigned int depth ; quantum_info = ( QuantumInfo * ) NULL ; ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; status = MagickTrue ; while ( EOFBlob ( image ) == MagickFalse ) { ldblk = ReadBlobLSBLong ( image ) ; if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) break ; HDR . Type [ 3 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 2 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 1 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 0 ] = ldblk ; if ( HDR . Type [ 3 ] != 0 ) break ; if ( HDR . Type [ 2 ] != 0 ) break ; if ( HDR . Type [ 0 ] == 0 ) { HDR . nRows = ReadBlobLSBLong ( image ) ; HDR . nCols = ReadBlobLSBLong ( image ) ; HDR . imagf = ReadBlobLSBLong ( image ) ; HDR . nameLen = ReadBlobLSBLong ( image ) ; endian = LSBEndian ; } else { HDR . nRows = ReadBlobMSBLong ( image ) ; HDR . nCols = ReadBlobMSBLong ( image ) ; HDR . imagf = ReadBlobMSBLong ( image ) ; HDR . nameLen = ReadBlobMSBLong ( image ) ; endian = MSBEndian ; } if ( ( HDR . imagf != 0 ) && ( HDR . imagf != 1 ) ) break ; if ( HDR . nameLen > 0xFFFF ) return ( DestroyImageList ( image ) ) ; for ( i = 0 ; i < ( ssize_t ) HDR . nameLen ; i ++ ) { int byte ; byte = ReadBlobByte ( image ) ; if ( byte == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } image -> columns = ( size_t ) HDR . nRows ; image -> rows = ( size_t ) HDR . nCols ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( DestroyImageList ( image ) ) ; if ( image_info -> ping != MagickFalse ) { Swap ( image -> columns , image -> rows ) ; if ( HDR . imagf == 1 ) ldblk *= 2 ; SeekBlob ( image , HDR . nCols * ldblk , SEEK_CUR ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( image -> previous == ( Image * ) NULL ? DestroyImageList ( image ) : image ) ; goto skip_reading_current ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) return ( DestroyImageList ( image ) ) ; switch ( HDR . Type [ 1 ] ) { case 0 : format_type = FloatingPointQuantumFormat ; depth = 64 ; break ; case 1 : format_type = FloatingPointQuantumFormat ; depth = 32 ; break ; case 2 : format_type = UnsignedQuantumFormat ; depth = 16 ; break ; case 3 : format_type = SignedQuantumFormat ; depth = 16 ; break ; case 4 : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; default : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; } image -> depth = depth ; if ( HDR . Type [ 0 ] != 0 ) SetQuantumEndian ( image , quantum_info , MSBEndian ) ; status = SetQuantumFormat ( image , quantum_info , format_type ) ; status = SetQuantumDepth ( image , quantum_info , depth ) ; status = SetQuantumEndian ( image , quantum_info , endian ) ; SetQuantumScale ( quantum_info , 1.0 ) ; pixels = ( unsigned char * ) GetQuantumPixels ( quantum_info ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; q = QueueAuthenticPixels ( image , 0 , image -> rows - y - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ; if ( ( HDR . Type [ 1 ] == 2 ) || ( HDR . Type [ 1 ] == 3 ) ) FixSignedValues ( image , q , ( int ) image -> columns ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( HDR . imagf == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; if ( HDR . Type [ 1 ] == 0 ) InsertComplexDoubleRow ( image , ( double * ) pixels , y , 0 , 0 , exception ) ; else InsertComplexFloatRow ( image , ( float * ) pixels , y , 0 , 0 , exception ) ; } if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; rotated_image -> colors = image -> colors ; DestroyBlob ( rotated_image ) ; rotated_image -> blob = ReferenceBlob ( image -> blob ) ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; skip_reading_current : AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ; if ( EOFBlob ( image ) ) break ; if (
",ImageMagick@ImageMagick/f7206618d27c2e69d977abf40e3035a33e5f6be0,CVE-2019-15140,https://github.com/ImageMagick/ImageMagick/commit/f7206618d27c2e69d977abf40e3035a33e5f6be0,2019-08-18T19:15Z,<S2SV_StartBug> if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) <S2SV_EndBug>
3990,CWE-20,"int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; int copied , error = - EINVAL ; msg -> msg_namelen = 0 ; if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( ""%d<S2SV_blank>-=<S2SV_blank>%d\\n"" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }
","<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; if (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,"<S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug>"
150,CWE-000,"static krb5_error_code process_db_args ( krb5_context context , char * * db_args , xargs_t * xargs , OPERATION optype ) { int i = 0 ; krb5_error_code st = 0 ; char * arg = NULL , * arg_val = NULL ; char * * dptr = NULL ; unsigned int arg_val_len = 0 ; if ( db_args ) { for ( i = 0 ; db_args [ i ] ; ++ i ) { arg = strtok_r ( db_args [ i ] , ""="" , & arg_val ) ; if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { dptr = & xargs -> tktpolicydn ; } else { if ( strcmp ( arg , USERDN_ARG ) == 0 ) { if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL || xargs -> linkdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> dn ; } else if ( strcmp ( arg , CONTAINERDN_ARG ) == 0 ) { if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> containerdn ; } else if ( strcmp ( arg , LINKDN_ARG ) == 0 ) { if ( xargs -> dn != NULL || xargs -> linkdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> linkdn ; } else { st = EINVAL ; k5_setmsg ( context , st , _ ( ""unknown<S2SV_blank>option:<S2SV_blank>%s"" ) , arg ) ; goto cleanup ; } xargs -> dn_from_kbd = TRUE ; if ( arg_val == NULL || strlen ( arg_val ) == 0 ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>value<S2SV_blank>missing"" ) , arg ) ; goto cleanup ; } } if ( arg_val == NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>value<S2SV_blank>missing"" ) , arg ) ; goto cleanup ; } arg_val_len = strlen ( arg_val ) + 1 ; if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { if ( ( st = krb5_ldap_name_to_policydn ( context , arg_val , dptr ) ) != 0 ) goto cleanup ; } else { * dptr = k5memdup ( arg_val , arg_val_len , & st ) ; if ( * dptr == NULL ) goto cleanup ; } } } cleanup : return st ; }
","<S2SV_ModStart> arg_val ) ; arg = ( arg != NULL ) ? arg : """" ;
",krb5@krb5/08c642c09c38a9c6454ab43a9b53b2a89b9eef99,CVE-2016-3119,https://github.com/krb5/krb5/commit/08c642c09c38a9c6454ab43a9b53b2a89b9eef99,2016-03-26T01:59Z,"<S2SV_StartBug> if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { <S2SV_EndBug>"
1220,CWE-436,"static void flatpak_proxy_client_finalize ( GObject * object ) { FlatpakProxyClient * client = FLATPAK_PROXY_CLIENT ( object ) ; client -> proxy -> clients = g_list_remove ( client -> proxy -> clients , client ) ; g_clear_object ( & client -> proxy ) ; g_hash_table_destroy ( client -> rewrite_reply ) ; g_hash_table_destroy ( client -> get_owner_reply ) ; g_hash_table_destroy ( client -> unique_id_policy ) ; free_side ( & client -> client_side ) ; free_side ( & client -> bus_side ) ; G_OBJECT_CLASS ( flatpak_proxy_client_parent_class ) -> finalize ( object ) ; }
","<S2SV_ModStart> client -> proxy ) ; g_byte_array_free ( client -> auth_buffer , TRUE
",flatpak@flatpak/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6,CVE-2018-6560,https://github.com/flatpak/flatpak/commit/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6,2018-02-02T14:29Z,<S2SV_StartBug> g_clear_object ( & client -> proxy ) ; <S2SV_EndBug>
2213,CWE-200,"static void * __alloc_from_pool ( size_t size , struct page * * ret_page , gfp_t flags ) { unsigned long val ; void * ptr = NULL ; if ( ! atomic_pool ) { WARN ( 1 , ""coherent<S2SV_blank>pool<S2SV_blank>not<S2SV_blank>initialised!\\n"" ) ; return NULL ; } val = gen_pool_alloc ( atomic_pool , size ) ; if ( val ) { phys_addr_t phys = gen_pool_virt_to_phys ( atomic_pool , val ) ; * ret_page = phys_to_page ( phys ) ; ptr = ( void * ) val ; if ( flags & __GFP_ZERO ) memset ( ptr , 0 , size ) ; } return ptr ; }
","<S2SV_ModStart> ) val ; <S2SV_ModEnd> memset ( ptr
",torvalds@linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5,CVE-2015-8950,https://github.com/torvalds/linux/commit/6829e274a623187c24f7cfc0e3d35f25d087fcc5,2016-10-10T10:59Z,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug>
8131,CWE-295,"int main_configure ( char * arg1 , char * arg2 ) { int cmdline_status ; cmdline_status = options_cmdline ( arg1 , arg2 ) ; if ( cmdline_status ) return cmdline_status ; options_apply ( ) ; str_canary_init ( ) ; log_open ( SINK_SYSLOG ) ; if ( bind_ports ( ) ) return 1 ; # ifdef HAVE_CHROOT if ( change_root ( ) ) return 1 ; # endif if ( drop_privileges ( 1 ) ) return 1 ; if ( log_open ( SINK_OUTFILE ) ) return 1 ; # ifndef USE_FORK num_clients = 0 ; # endif log_flush ( LOG_MODE_CONFIGURED ) ; return 0 ; }
","<S2SV_ModStart> int cmdline_status ; log_flush ( LOG_MODE_BUFFER ) ; <S2SV_ModStart> ( cmdline_status ) { log_flush ( LOG_MODE_ERROR ) ; return cmdline_status ; } options_free ( 1 ) <S2SV_ModEnd> ; options_apply ( <S2SV_ModStart> ( ) ) { unbind_ports ( ) ; options_free ( 1 ) ; options_defaults ( ) ; options_apply ( ) ; log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> # ifdef HAVE_CHROOT <S2SV_ModStart> ( ) ) { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> # endif if <S2SV_ModStart> 1 ) ) { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> if ( log_open <S2SV_ModStart> SINK_OUTFILE ) ) { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> # ifndef USE_FORK
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,"<S2SV_StartBug> cmdline_status = options_cmdline ( arg1 , arg2 ) ; <S2SV_EndBug> <S2SV_StartBug> return cmdline_status ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug>"
1069,CWE-20,"static int netbk_count_requests ( struct xenvif * vif , struct xen_netif_tx_request * first , struct xen_netif_tx_request * txp , int work_to_do ) { RING_IDX cons = vif -> tx . req_cons ; int frags = 0 ; if ( ! ( first -> flags & XEN_NETTXF_more_data ) ) return 0 ; do { if ( frags >= work_to_do ) { netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\n"" ) ; return - frags ; } if ( unlikely ( frags >= MAX_SKB_FRAGS ) ) { netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\n"" ) ; return - frags ; } memcpy ( txp , RING_GET_REQUEST ( & vif -> tx , cons + frags ) , sizeof ( * txp ) ) ; if ( txp -> size > first -> size ) { netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\n"" ) ; return - frags ; } first -> size -= txp -> size ; frags ++ ; if ( unlikely ( ( txp -> offset + txp -> size ) > PAGE_SIZE ) ) { netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n"" , txp -> offset , txp -> size ) ; return - frags ; } } while ( ( txp ++ ) -> flags & XEN_NETTXF_more_data ) ; return frags ; }
","<S2SV_ModStart> work_to_do ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> size ) { netdev_err ( vif -> dev , ""Frag<S2SV_blank>is<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>frame.\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> txp -> size ) ; netbk_fatal_tx_err ( vif
",torvalds@linux/48856286b64e4b66ec62b94e504d0b29c1ade664,CVE-2013-0216,https://github.com/torvalds/linux/commit/48856286b64e4b66ec62b94e504d0b29c1ade664,2013-02-18T04:41Z,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n"" , <S2SV_EndBug> <S2SV_StartBug> txp -> offset , txp -> size ) ; <S2SV_EndBug>"
1851,CWE-119,"static int64_t rd_pick_intra_sbuv_mode ( VP9_COMP * cpi , MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , TX_SIZE max_tx_size ) { MACROBLOCKD * xd = & x -> e_mbd ; MB_PREDICTION_MODE mode ; MB_PREDICTION_MODE mode_selected = DC_PRED ; int64_t best_rd = INT64_MAX , this_rd ; int this_rate_tokenonly , this_rate , s ; int64_t this_distortion , this_sse ; for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { if ( ! ( cpi -> sf . intra_uv_mode_mask [ max_tx_size ] & ( 1 << mode ) ) ) continue ; xd -> mi [ 0 ] -> mbmi . uv_mode = mode ; super_block_uvrd ( cpi , x , & this_rate_tokenonly , & this_distortion , & s , & this_sse , bsize , best_rd ) ; if ( this_rate_tokenonly == INT_MAX ) continue ; this_rate = this_rate_tokenonly + x -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ; if ( this_rd < best_rd ) { mode_selected = mode ; best_rd = this_rd ; * rate = this_rate ; * rate_tokenonly = this_rate_tokenonly ; * distortion = this_distortion ; * skippable = s ; if ( ! x -> select_txfm_size ) { int i ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd -> plane ; for ( i = 1 ; i < MAX_MB_PLANE ; ++ i ) { p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 2 ] ; p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 2 ] ; pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 2 ] ; p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 2 ] ; ctx -> coeff_pbuf [ i ] [ 2 ] = ctx -> coeff_pbuf [ i ] [ 0 ] ; ctx -> qcoeff_pbuf [ i ] [ 2 ] = ctx -> qcoeff_pbuf [ i ] [ 0 ] ; ctx -> dqcoeff_pbuf [ i ] [ 2 ] = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ; ctx -> eobs_pbuf [ i ] [ 2 ] = ctx -> eobs_pbuf [ i ] [ 0 ] ; ctx -> coeff_pbuf [ i ] [ 0 ] = p [ i ] . coeff ; ctx -> qcoeff_pbuf [ i ] [ 0 ] = p [ i ] . qcoeff ; ctx -> dqcoeff_pbuf [ i ] [ 0 ] = pd [ i ] . dqcoeff ; ctx -> eobs_pbuf [ i ] [ 0 ] = p [ i ] . eobs ; } } } } xd -> mi [ 0 ] -> mbmi . uv_mode = mode_selected ; return best_rd ; }
","<S2SV_ModStart> -> e_mbd ; PREDICTION_MODE mode ; PREDICTION_MODE <S2SV_ModEnd> mode_selected = DC_PRED <S2SV_ModStart> this_distortion , this_sse ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) <S2SV_ModStart> = mode ; if ( ! <S2SV_ModStart> , best_rd ) <S2SV_ModEnd> ) continue ; <S2SV_ModStart> = this_rate_tokenonly + cpi <S2SV_ModEnd> -> intra_uv_mode_cost [ <S2SV_ModStart> ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ; <S2SV_ModEnd> } } xd
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> MB_PREDICTION_MODE mode ; <S2SV_EndBug> <S2SV_StartBug> int64_t this_distortion , this_sse ; <S2SV_EndBug> <S2SV_StartBug> super_block_uvrd ( cpi , x , & this_rate_tokenonly , <S2SV_EndBug> <S2SV_StartBug> & this_distortion , & s , & this_sse , bsize , best_rd ) ; <S2SV_EndBug> <S2SV_StartBug> x -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> select_txfm_size ) { <S2SV_EndBug>"
1317,CWE-59,"static int setup_ttydir_console ( const struct lxc_rootfs * rootfs , const struct lxc_console * console , char * ttydir ) { char path [ MAXPATHLEN ] , lxcpath [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/dev/%s"" , rootfs -> mount , ttydir ) ; if ( ret >= sizeof ( path ) ) return - 1 ; ret = mkdir ( path , 0755 ) ; if ( ret && errno != EEXIST ) { SYSERROR ( ""failed<S2SV_blank>with<S2SV_blank>errno<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%s"" , errno , path ) ; return - 1 ; } INFO ( ""created<S2SV_blank>%s"" , path ) ; ret = snprintf ( lxcpath , sizeof ( lxcpath ) , ""%s/dev/%s/console"" , rootfs -> mount , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( ""console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } snprintf ( path , sizeof ( path ) , ""%s/dev/console"" , rootfs -> mount ) ; ret = unlink ( path ) ; if ( ret && errno != ENOENT ) { SYSERROR ( ""error<S2SV_blank>unlinking<S2SV_blank>%s"" , path ) ; return - 1 ; } ret = creat ( lxcpath , 0660 ) ; if ( ret == - 1 && errno != EEXIST ) { SYSERROR ( ""error<S2SV_blank>%d<S2SV_blank>creating<S2SV_blank>%s"" , errno , lxcpath ) ; return - 1 ; } if ( ret >= 0 ) close ( ret ) ; if ( console -> master < 0 ) { INFO ( ""no<S2SV_blank>console"" ) ; return 0 ; } if ( mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 ) ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , console -> name , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , ""%s/console"" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( ""lxc/console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>for<S2SV_blank>console"" ) ; return - 1 ; } INFO ( ""console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup<S2SV_blank>on<S2SV_blank>%s"" , lxcpath ) ; return 0 ; }
","<S2SV_ModStart> } if ( safe_mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 , rootfs -> mount ) ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , <S2SV_ModEnd> console -> name <S2SV_ModStart> name , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , ""%s/console"" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( ""lxc/console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>for<S2SV_blank>console"" ) ; return - 1 ; } INFO ( ""console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup<S2SV_blank>on<S2SV_blank>%s"" , lxcpath ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>
",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z,"<S2SV_StartBug> if ( mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 ) ) { <S2SV_EndBug>"
1275,CWE-119,"static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) { int ret ; ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , indx , data , size , 100 ) ; if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\n"" , __func__ , ret ) ; return ret ; }
","<S2SV_ModStart> __u16 size , const <S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
",torvalds@linux/5593523f968bc86d42a035c6df47d5e0979b5ace,CVE-2017-8068,https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace,2017-04-23T05:59Z,"<S2SV_StartBug> static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , data , size , 100 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug>"
216,CWE-20,"int ptrace_setxregs ( struct task_struct * child , void __user * uregs ) { struct thread_info * ti = task_thread_info ( child ) ; struct pt_regs * regs = task_pt_regs ( child ) ; elf_xtregs_t * xtregs = uregs ; int ret = 0 ; # if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ; coprocessor_release_all ( ti ) ; ret |= __copy_from_user ( & ti -> xtregs_cp , & xtregs -> cp0 , sizeof ( xtregs_coprocessor_t ) ) ; # endif ret |= __copy_from_user ( & regs -> xtregs_opt , & xtregs -> opt , sizeof ( xtregs -> opt ) ) ; ret |= __copy_from_user ( & ti -> xtregs_user , & xtregs -> user , sizeof ( xtregs -> user ) ) ; return ret ? - EFAULT : 0 ; }
","<S2SV_ModStart> ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
",torvalds@linux/0d0138ebe24b94065580bd2601f8bb7eb6152f56,CVE-2011-2707,https://github.com/torvalds/linux/commit/0d0138ebe24b94065580bd2601f8bb7eb6152f56,2012-05-24T23:55Z,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug>
3640,CWE-20,"static void handle_rx ( struct vhost_net * net ) { struct vhost_net_virtqueue * nvq = & net -> vqs [ VHOST_NET_VQ_RX ] ; struct vhost_virtqueue * vq = & nvq -> vq ; unsigned uninitialized_var ( in ) , log ; struct vhost_log * vq_log ; struct msghdr msg = { . msg_name = NULL , . msg_namelen = 0 , . msg_control = NULL , . msg_controllen = 0 , . msg_iov = vq -> iov , . msg_flags = MSG_DONTWAIT , } ; struct virtio_net_hdr_mrg_rxbuf hdr = { . hdr . flags = 0 , . hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE } ; size_t total_len = 0 ; int err , mergeable ; s16 headcount ; size_t vhost_hlen , sock_hlen ; size_t vhost_len , sock_len ; struct socket * sock ; mutex_lock ( & vq -> mutex ) ; sock = vq -> private_data ; if ( ! sock ) goto out ; vhost_disable_notify ( & net -> dev , vq ) ; vhost_hlen = nvq -> vhost_hlen ; sock_hlen = nvq -> sock_hlen ; vq_log = unlikely ( vhost_has_feature ( & net -> dev , VHOST_F_LOG_ALL ) ) ? vq -> log : NULL ; mergeable = vhost_has_feature ( & net -> dev , VIRTIO_NET_F_MRG_RXBUF ) ; while ( ( sock_len = peek_head_len ( sock -> sk ) ) ) { sock_len += sock_hlen ; vhost_len = sock_len + vhost_hlen ; headcount = get_rx_bufs ( vq , vq -> heads , vhost_len , & in , vq_log , & log , likely ( mergeable ) ? UIO_MAXIOV : 1 ) ; if ( unlikely ( headcount < 0 ) ) break ; if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; if ( unlikely ( err != sock_len ) ) { pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>"" ""<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\n"" , err , sock_len ) ; vhost_discard_vq_desc ( vq , headcount ) ; continue ; } if ( unlikely ( vhost_hlen ) && memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & hdr , 0 , vhost_hlen ) ) { vq_err ( vq , ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>vnet_hdr<S2SV_blank>at<S2SV_blank>addr<S2SV_blank>%p\\n"" , vq -> iov -> iov_base ) ; break ; } if ( likely ( mergeable ) && memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & headcount , offsetof ( typeof ( hdr ) , num_buffers ) , sizeof hdr . num_buffers ) ) { vq_err ( vq , ""Failed<S2SV_blank>num_buffers<S2SV_blank>write"" ) ; vhost_discard_vq_desc ( vq , headcount ) ; break ; } vhost_add_used_and_signal_n ( & net -> dev , vq , vq -> heads , headcount ) ; if ( unlikely ( vq_log ) ) vhost_log_write ( vq , vq_log , log , vhost_len ) ; total_len += vhost_len ; if ( unlikely ( total_len >= VHOST_NET_WEIGHT ) ) { vhost_poll_queue ( & vq -> poll ) ; break ; } } out : mutex_unlock ( & vq -> mutex ) ; }
","<S2SV_ModStart> ; if ( unlikely ( headcount > UIO_MAXIOV ) ) { <S2SV_ModEnd> msg . msg_iovlen <S2SV_ModStart> . msg_iovlen = 1 <S2SV_ModEnd> ; err = <S2SV_ModStart> & msg , 1 <S2SV_ModEnd> , MSG_DONTWAIT | <S2SV_ModStart> MSG_TRUNC ) ; pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\n"" , sock_len ) ; continue ; } if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;
",torvalds@linux/d8316f3991d207fe32881a9ac20241be8fa2bad0,CVE-2014-0077,https://github.com/torvalds/linux/commit/d8316f3991d207fe32881a9ac20241be8fa2bad0,2014-04-14T23:55Z,"<S2SV_StartBug> if ( ! headcount ) { <S2SV_EndBug> <S2SV_StartBug> msg . msg_iovlen = in ; <S2SV_EndBug> <S2SV_StartBug> sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err != sock_len ) ) { <S2SV_EndBug>"
441,CWE-200,"static int copy_to_user_tmpl ( struct xfrm_policy * xp , struct sk_buff * skb ) { struct xfrm_user_tmpl vec [ XFRM_MAX_DEPTH ] ; int i ; if ( xp -> xfrm_nr == 0 ) return 0 ; for ( i = 0 ; i < xp -> xfrm_nr ; i ++ ) { struct xfrm_user_tmpl * up = & vec [ i ] ; struct xfrm_tmpl * kp = & xp -> xfrm_vec [ i ] ; memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; up -> family = kp -> encap_family ; memcpy ( & up -> saddr , & kp -> saddr , sizeof ( up -> saddr ) ) ; up -> reqid = kp -> reqid ; up -> mode = kp -> mode ; up -> share = kp -> share ; up -> optional = kp -> optional ; up -> aalgos = kp -> aalgos ; up -> ealgos = kp -> ealgos ; up -> calgos = kp -> calgos ; } return nla_put ( skb , XFRMA_TMPL , sizeof ( struct xfrm_user_tmpl ) * xp -> xfrm_nr , vec ) ; }
","<S2SV_ModStart> i ] ; memset ( up , 0 , sizeof ( * up ) ) ;
",torvalds@linux/1f86840f897717f86d523a13e99a447e6a5d2fa5,CVE-2012-6537,https://github.com/torvalds/linux/commit/1f86840f897717f86d523a13e99a447e6a5d2fa5,2013-03-15T20:55Z,"<S2SV_StartBug> memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; <S2SV_EndBug>"
2079,CWE-264,"struct crypto_alg * crypto_larval_lookup ( const char * name , u32 type , u32 mask ) { struct crypto_alg * alg ; if ( ! name ) return ERR_PTR ( - ENOENT ) ; mask &= ~ ( CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD ) ; type &= mask ; alg = crypto_alg_lookup ( name , type , mask ) ; if ( ! alg ) { request_module ( ""%s"" , name ) ; if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) ) request_module ( ""%s-all"" , name ) ; alg = crypto_alg_lookup ( name , type , mask ) ; } if ( alg ) return crypto_is_larval ( alg ) ? crypto_larval_wait ( alg ) : alg ; return crypto_larval_add ( name , type , mask ) ; }
","<S2SV_ModStart> { request_module ( ""crypto-%s"" <S2SV_ModEnd> , name ) <S2SV_ModStart> ) request_module ( ""crypto-%s-all"" <S2SV_ModEnd> , name )
",torvalds@linux/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,CVE-2013-7421,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,2015-03-02T11:59Z,"<S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> <S2SV_StartBug> request_module ( ""%s-all"" , name ) ; <S2SV_EndBug>"
1612,CWE-119,"static void read_ref_frames ( VP9_COMMON * const cm , MACROBLOCKD * const xd , vp9_reader * r , int segment_id , MV_REFERENCE_FRAME ref_frame [ 2 ] ) { FRAME_CONTEXT * const fc = & cm -> fc ; FRAME_COUNTS * const counts = & cm -> counts ; if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { ref_frame [ 0 ] = ( MV_REFERENCE_FRAME ) vp9_get_segdata ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ; ref_frame [ 1 ] = NONE ; } else { const REFERENCE_MODE mode = read_block_reference_mode ( cm , xd , r ) ; if ( mode == COMPOUND_REFERENCE ) { const int idx = cm -> ref_frame_sign_bias [ cm -> comp_fixed_ref ] ; const int ctx = vp9_get_pred_context_comp_ref_p ( cm , xd ) ; const int bit = vp9_read ( r , fc -> comp_ref_prob [ ctx ] ) ; if ( ! cm -> frame_parallel_decoding_mode ) ++ counts -> comp_ref [ ctx ] [ bit ] ; ref_frame [ idx ] = cm -> comp_fixed_ref ; ref_frame [ ! idx ] = cm -> comp_var_ref [ bit ] ; } else if ( mode == SINGLE_REFERENCE ) { const int ctx0 = vp9_get_pred_context_single_ref_p1 ( xd ) ; const int bit0 = vp9_read ( r , fc -> single_ref_prob [ ctx0 ] [ 0 ] ) ; if ( ! cm -> frame_parallel_decoding_mode ) ++ counts -> single_ref [ ctx0 ] [ 0 ] [ bit0 ] ; if ( bit0 ) { const int ctx1 = vp9_get_pred_context_single_ref_p2 ( xd ) ; const int bit1 = vp9_read ( r , fc -> single_ref_prob [ ctx1 ] [ 1 ] ) ; if ( ! cm -> frame_parallel_decoding_mode ) ++ counts -> single_ref [ ctx1 ] [ 1 ] [ bit1 ] ; ref_frame [ 0 ] = bit1 ? ALTREF_FRAME : GOLDEN_FRAME ; } else { ref_frame [ 0 ] = LAST_FRAME ; } ref_frame [ 1 ] = NONE ; } else { assert ( 0 && ""Invalid<S2SV_blank>prediction<S2SV_blank>mode."" ) ; } } }
","<S2SV_ModStart> const xd , vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> const fc = cm -> fc ; FRAME_COUNTS * counts = xd -> counts ; if ( segfeature_active ( <S2SV_ModStart> & cm -> <S2SV_ModEnd> seg , segment_id <S2SV_ModStart> ( MV_REFERENCE_FRAME ) get_segdata <S2SV_ModEnd> ( & cm <S2SV_ModStart> int bit = vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ; if ( counts <S2SV_ModEnd> ) ++ counts <S2SV_ModStart> int bit0 = vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ; if ( counts <S2SV_ModEnd> ) ++ counts <S2SV_ModStart> int bit1 = vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ; if ( counts <S2SV_ModEnd> ) ++ counts
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> ref_frame [ 0 ] = ( MV_REFERENCE_FRAME ) vp9_get_segdata ( & cm -> seg , segment_id , <S2SV_EndBug> <S2SV_StartBug> const int bit = vp9_read ( r , fc -> comp_ref_prob [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> <S2SV_StartBug> const int bit0 = vp9_read ( r , fc -> single_ref_prob [ ctx0 ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> <S2SV_StartBug> const int bit1 = vp9_read ( r , fc -> single_ref_prob [ ctx1 ] [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug>"
2424,CWE-190,"static void cpStripToTile ( uint8 * out , uint8 * in , uint32 rows , uint32 cols , int outskew , int inskew ) { while ( rows -- > 0 ) { uint32 j = cols ; while ( j -- > 0 ) * out ++ = * in ++ ; out += outskew ; in += inskew ; } }
","<S2SV_ModStart> int outskew , int64 <S2SV_ModEnd> inskew ) {
",vadz@libtiff/787c0ee906430b772f33ca50b97b8b5ca070faec,CVE-2016-10093,https://github.com/vadz/libtiff/commit/787c0ee906430b772f33ca50b97b8b5ca070faec,2017-03-01T15:59Z,"<S2SV_StartBug> uint32 rows , uint32 cols , int outskew , int inskew ) <S2SV_EndBug>"
8428,CWE-74,"static int smtp_open ( struct Connection * conn , bool esmtp ) { int rc ; if ( mutt_socket_open ( conn ) ) return - 1 ; rc = smtp_get_resp ( conn ) ; if ( rc != 0 ) return rc ; rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; # ifdef USE_SSL enum QuadOption ans = MUTT_NO ; if ( conn -> ssf ) ans = MUTT_NO ; else if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( Capabilities & SMTP_CAP_STARTTLS ) && ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ) == MUTT_ABORT ) ) { return - 1 ; } if ( ans == MUTT_YES ) { if ( mutt_socket_send ( conn , ""STARTTLS\\r\\n"" ) < 0 ) return SMTP_ERR_WRITE ; rc = smtp_get_resp ( conn ) ; if ( rc != 0 ) return rc ; if ( mutt_ssl_starttls ( conn ) ) { mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; return - 1 ; } rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! ( Capabilities & SMTP_CAP_AUTH ) ) { mutt_error ( _ ( ""SMTP<S2SV_blank>server<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>authentication"" ) ) ; return - 1 ; } return smtp_auth ( conn ) ; } return 0 ; }
","<S2SV_ModStart> rc = smtp_get_resp ( conn ) ; mutt_socket_empty
",neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc,CVE-2020-14954,https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc,2020-06-21T17:15Z,<S2SV_StartBug> rc = smtp_get_resp ( conn ) ; <S2SV_EndBug>
2902,CWE-310,"static noinline int create_pending_snapshot ( struct btrfs_trans_handle * trans , struct btrfs_fs_info * fs_info , struct btrfs_pending_snapshot * pending ) { struct btrfs_key key ; struct btrfs_root_item * new_root_item ; struct btrfs_root * tree_root = fs_info -> tree_root ; struct btrfs_root * root = pending -> root ; struct btrfs_root * parent_root ; struct btrfs_block_rsv * rsv ; struct inode * parent_inode ; struct btrfs_path * path ; struct btrfs_dir_item * dir_item ; struct dentry * parent ; struct dentry * dentry ; struct extent_buffer * tmp ; struct extent_buffer * old ; struct timespec cur_time = CURRENT_TIME ; int ret ; u64 to_reserve = 0 ; u64 index = 0 ; u64 objectid ; u64 root_flags ; uuid_le new_uuid ; path = btrfs_alloc_path ( ) ; if ( ! path ) { ret = pending -> error = - ENOMEM ; goto path_alloc_fail ; } new_root_item = kmalloc ( sizeof ( * new_root_item ) , GFP_NOFS ) ; if ( ! new_root_item ) { ret = pending -> error = - ENOMEM ; goto root_item_alloc_fail ; } ret = btrfs_find_free_objectid ( tree_root , & objectid ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } btrfs_reloc_pre_snapshot ( trans , pending , & to_reserve ) ; if ( to_reserve > 0 ) { ret = btrfs_block_rsv_add ( root , & pending -> block_rsv , to_reserve , BTRFS_RESERVE_NO_FLUSH ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } } ret = btrfs_qgroup_inherit ( trans , fs_info , root -> root_key . objectid , objectid , pending -> inherit ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } key . objectid = objectid ; key . offset = ( u64 ) - 1 ; key . type = BTRFS_ROOT_ITEM_KEY ; rsv = trans -> block_rsv ; trans -> block_rsv = & pending -> block_rsv ; dentry = pending -> dentry ; parent = dget_parent ( dentry ) ; parent_inode = parent -> d_inode ; parent_root = BTRFS_I ( parent_inode ) -> root ; record_root_in_trans ( trans , parent_root ) ; ret = btrfs_set_inode_index ( parent_inode , & index ) ; BUG_ON ( ret ) ; dir_item = btrfs_lookup_dir_item ( NULL , parent_root , path , btrfs_ino ( parent_inode ) , dentry -> d_name . name , dentry -> d_name . len , 0 ) ; if ( dir_item != NULL && ! IS_ERR ( dir_item ) ) { pending -> error = - EEXIST ; goto fail ; } else if ( IS_ERR ( dir_item ) ) { ret = PTR_ERR ( dir_item ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_release_path ( path ) ; ret = btrfs_run_delayed_items ( trans , root ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } record_root_in_trans ( trans , root ) ; btrfs_set_root_last_snapshot ( & root -> root_item , trans -> transid ) ; memcpy ( new_root_item , & root -> root_item , sizeof ( * new_root_item ) ) ; btrfs_check_and_init_root_item ( new_root_item ) ; root_flags = btrfs_root_flags ( new_root_item ) ; if ( pending -> readonly ) root_flags |= BTRFS_ROOT_SUBVOL_RDONLY ; else root_flags &= ~ BTRFS_ROOT_SUBVOL_RDONLY ; btrfs_set_root_flags ( new_root_item , root_flags ) ; btrfs_set_root_generation_v2 ( new_root_item , trans -> transid ) ; uuid_le_gen ( & new_uuid ) ; memcpy ( new_root_item -> uuid , new_uuid . b , BTRFS_UUID_SIZE ) ; memcpy ( new_root_item -> parent_uuid , root -> root_item . uuid , BTRFS_UUID_SIZE ) ; new_root_item -> otime . sec = cpu_to_le64 ( cur_time . tv_sec ) ; new_root_item -> otime . nsec = cpu_to_le32 ( cur_time . tv_nsec ) ; btrfs_set_root_otransid ( new_root_item , trans -> transid ) ; memset ( & new_root_item -> stime , 0 , sizeof ( new_root_item -> stime ) ) ; memset ( & new_root_item -> rtime , 0 , sizeof ( new_root_item -> rtime ) ) ; btrfs_set_root_stransid ( new_root_item , 0 ) ; btrfs_set_root_rtransid ( new_root_item , 0 ) ; old = btrfs_lock_root_node ( root ) ; ret = btrfs_cow_block ( trans , root , old , NULL , 0 , & old ) ; if ( ret ) { btrfs_tree_unlock ( old ) ; free_extent_buffer ( old ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_set_lock_blocking ( old ) ; ret = btrfs_copy_root ( trans , root , old , & tmp , objectid ) ; btrfs_tree_unlock ( old ) ; free_extent_buffer ( old ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } root -> force_cow = 1 ; smp_wmb ( ) ; btrfs_set_root_node ( new_root_item , tmp ) ; key . offset = trans -> transid ; ret = btrfs_insert_root ( trans , tree_root , & key , new_root_item ) ; btrfs_tree_unlock ( tmp ) ; free_extent_buffer ( tmp ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_add_root_ref ( trans , tree_root , objectid , parent_root -> root_key . objectid , btrfs_ino ( parent_inode ) , index , dentry -> d_name . name , dentry -> d_name . len ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } key . offset = ( u64 ) - 1 ; pending -> snap = btrfs_read_fs_root_no_name ( root -> fs_info , & key ) ; if ( IS_ERR ( pending -> snap ) ) { ret = PTR_ERR ( pending -> snap ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_reloc_post_snapshot ( trans , pending ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_run_delayed_refs ( trans , root , ( unsigned long ) - 1 ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_insert_dir_item ( trans , parent_root , dentry -> d_name . name , dentry -> d_name . len , parent_inode , & key , BTRFS_FT_DIR , index ) ; BUG_ON ( ret == - EEXIST ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + dentry -> d_name . len * 2 ) ; parent_inode -> i_mtime = parent_inode -> i_ctime = CURRENT_TIME ; ret = btrfs_update_inode_fallback ( trans , parent_root , parent_inode ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; fail : dput ( parent ) ; trans -> block_rsv = rsv ; no_free_objectid : kfree ( new_root_item ) ; root_item_alloc_fail : btrfs_free_path ( path ) ; path_alloc_fail : btrfs_block_rsv_release ( root , & pending -> block_rsv , ( u64 ) - 1 ) ; return ret ; }
","<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
",torvalds@linux/9c52057c698fb96f8f07e7a4bcf4801a092bda89,CVE-2012-5375,https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89,2013-02-18T11:56Z,<S2SV_StartBug> BUG_ON ( ret == - EEXIST ) ; <S2SV_EndBug>
7253,CWE-401,"int crypto_reportstat ( struct sk_buff * in_skb , struct nlmsghdr * in_nlh , struct nlattr * * attrs ) { struct net * net = sock_net ( in_skb -> sk ) ; struct crypto_user_alg * p = nlmsg_data ( in_nlh ) ; struct crypto_alg * alg ; struct sk_buff * skb ; struct crypto_dump_info info ; int err ; if ( ! null_terminated ( p -> cru_name ) || ! null_terminated ( p -> cru_driver_name ) ) return - EINVAL ; alg = crypto_alg_match ( p , 0 ) ; if ( ! alg ) return - ENOENT ; err = - ENOMEM ; skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) goto drop_alg ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = in_nlh -> nlmsg_seq ; info . nlmsg_flags = 0 ; err = crypto_reportstat_alg ( alg , & info ) ; drop_alg : crypto_mod_put ( alg ) ; if ( err ) return err ; return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ; }
","<S2SV_ModStart> ( err ) { kfree_skb ( skb ) ; return err ; } <S2SV_ModEnd> return nlmsg_unicast (
",torvalds@linux/c03b04dcdba1da39903e23cc4d072abf8f68f2dd,CVE-2019-19050,https://github.com/torvalds/linux/commit/c03b04dcdba1da39903e23cc4d072abf8f68f2dd,2019-11-18T06:15Z,<S2SV_StartBug> return err ; <S2SV_EndBug>
2148,CWE-190,"int jas_stream_pad ( jas_stream_t * stream , int n , int c ) { int m ; m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_putc ( stream , c ) == EOF ) return n - m ; } return n ; }
","<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad"" ) ; }
",mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,CVE-2016-9262,https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,2017-03-23T18:59Z,<S2SV_StartBug> int m ; <S2SV_EndBug>
1213,CWE-190,"static int fts3tokFilterMethod ( sqlite3_vtab_cursor * pCursor , int idxNum , const char * idxStr , int nVal , sqlite3_value * * apVal ) { int rc = SQLITE_ERROR ; Fts3tokCursor * pCsr = ( Fts3tokCursor * ) pCursor ; Fts3tokTable * pTab = ( Fts3tokTable * ) ( pCursor -> pVtab ) ; UNUSED_PARAMETER ( idxStr ) ; UNUSED_PARAMETER ( nVal ) ; fts3tokResetCursor ( pCsr ) ; if ( idxNum == 1 ) { const char * zByte = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nByte = sqlite3_value_bytes ( apVal [ 0 ] ) ; pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ; if ( pCsr -> zInput == 0 ) { rc = SQLITE_NOMEM ; } else { memcpy ( pCsr -> zInput , zByte , nByte ) ; pCsr -> zInput [ nByte ] = 0 ; rc = pTab -> pMod -> xOpen ( pTab -> pTok , pCsr -> zInput , nByte , & pCsr -> pCsr ) ; if ( rc == SQLITE_OK ) { pCsr -> pCsr -> pTokenizer = pTab -> pTok ; } } } if ( rc != SQLITE_OK ) return rc ; return fts3tokNextMethod ( pCursor ) ; }
","<S2SV_ModStart> -> zInput = sqlite3_malloc64 <S2SV_ModEnd> ( nByte +
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z,<S2SV_StartBug> pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ; <S2SV_EndBug>
7111,CWE-125,"static void printFlow ( u_int16_t id , struct ndpi_flow_info * flow , u_int16_t thread_id ) { FILE * out = results_file ? results_file : stdout ; u_int8_t known_tls ; char buf [ 32 ] , buf1 [ 64 ] ; u_int i ; double dos_ge_score ; double dos_slow_score ; double dos_hulk_score ; double ddos_score ; double hearthbleed_score ; double ftp_patator_score ; double ssh_patator_score ; double inf_score ; if ( csv_fp != NULL ) { float data_ratio = ndpi_data_ratio ( flow -> src2dst_bytes , flow -> dst2src_bytes ) ; double f = ( double ) flow -> first_seen , l = ( double ) flow -> last_seen ; dos_ge_score = Dos_goldeneye_score ( flow ) ; dos_slow_score = Dos_slow_score ( flow ) ; dos_hulk_score = Dos_hulk_score ( flow ) ; ddos_score = Ddos_score ( flow ) ; hearthbleed_score = Hearthbleed_score ( flow ) ; ftp_patator_score = Ftp_patator_score ( flow ) ; ssh_patator_score = Ssh_patator_score ( flow ) ; inf_score = Infiltration_score ( flow ) ; double benign_score = dos_ge_score < 1 && dos_slow_score < 1 && dos_hulk_score < 1 && ddos_score < 1 && hearthbleed_score < 1 && ftp_patator_score < 1 && ssh_patator_score < 1 && inf_score < 1 ? 1.1 : 0 ; fprintf ( csv_fp , ""%u,%u,%.3f,%.3f,%.3f,%s,%u,%s,%u,"" , flow -> flow_id , flow -> protocol , f / 1000.0 , l / 1000.0 , ( l - f ) / 1000.0 , flow -> src_name , ntohs ( flow -> src_port ) , flow -> dst_name , ntohs ( flow -> dst_port ) ) ; fprintf ( csv_fp , ""%s,"" , ndpi_protocol2id ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) ) ; fprintf ( csv_fp , ""%s,%s,"" , ndpi_protocol2name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) , flow -> host_server_name ) ; fprintf ( csv_fp , ""%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,"" , benign_score , dos_slow_score , dos_ge_score , dos_hulk_score , ddos_score , hearthbleed_score , ftp_patator_score , ssh_patator_score , inf_score ) ; fprintf ( csv_fp , ""%u,%llu,%llu,"" , flow -> src2dst_packets , ( long long unsigned int ) flow -> src2dst_bytes , ( long long unsigned int ) flow -> src2dst_goodput_bytes ) ; fprintf ( csv_fp , ""%u,%llu,%llu,"" , flow -> dst2src_packets , ( long long unsigned int ) flow -> dst2src_bytes , ( long long unsigned int ) flow -> dst2src_goodput_bytes ) ; fprintf ( csv_fp , ""%.3f,%s,"" , data_ratio , ndpi_data_ratio2str ( data_ratio ) ) ; fprintf ( csv_fp , ""%.1f,%.1f,"" , 100.0 * ( ( float ) flow -> src2dst_goodput_bytes / ( float ) ( flow -> src2dst_bytes + 1 ) ) , 100.0 * ( ( float ) flow -> dst2src_goodput_bytes / ( float ) ( flow -> dst2src_bytes + 1 ) ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> iat_flow ) , ndpi_data_average ( flow -> iat_flow ) , ndpi_data_max ( flow -> iat_flow ) , ndpi_data_stddev ( flow -> iat_flow ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> iat_c_to_s ) , ndpi_data_average ( flow -> iat_c_to_s ) , ndpi_data_max ( flow -> iat_c_to_s ) , ndpi_data_stddev ( flow -> iat_c_to_s ) , ndpi_data_min ( flow -> iat_s_to_c ) , ndpi_data_average ( flow -> iat_s_to_c ) , ndpi_data_max ( flow -> iat_s_to_c ) , ndpi_data_stddev ( flow -> iat_s_to_c ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> pktlen_c_to_s ) , ndpi_data_average ( flow -> pktlen_c_to_s ) , ndpi_data_max ( flow -> pktlen_c_to_s ) , ndpi_data_stddev ( flow -> pktlen_c_to_s ) , ndpi_data_min ( flow -> pktlen_s_to_c ) , ndpi_data_average ( flow -> pktlen_s_to_c ) , ndpi_data_max ( flow -> pktlen_s_to_c ) , ndpi_data_stddev ( flow -> pktlen_s_to_c ) ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> cwr_count , flow -> ece_count , flow -> urg_count , flow -> ack_count , flow -> psh_count , flow -> rst_count , flow -> syn_count , flow -> fin_count ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> src2dst_cwr_count , flow -> src2dst_ece_count , flow -> src2dst_urg_count , flow -> src2dst_ack_count , flow -> src2dst_psh_count , flow -> src2dst_rst_count , flow -> src2dst_syn_count , flow -> src2dst_fin_count ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> dst2src_cwr_count , flow -> ece_count , flow -> urg_count , flow -> ack_count , flow -> psh_count , flow -> rst_count , flow -> syn_count , flow -> fin_count ) ; fprintf ( csv_fp , ""%u,%u,"" , flow -> c_to_s_init_win , flow -> s_to_c_init_win ) ; fprintf ( csv_fp , ""%s,%s,"" , ( flow -> ssh_tls . client_requested_server_name [ 0 ] != '\\0' ) ? flow -> ssh_tls . client_requested_server_name : """" , ( flow -> ssh_tls . server_info [ 0 ] != '\\0' ) ? flow -> ssh_tls . server_info : """" ) ; fprintf ( csv_fp , ""%s,%s,%s,%s,%s,"" , ( flow -> ssh_tls . ssl_version != 0 ) ? ndpi_ssl_version2str ( flow -> ssh_tls . ssl_version , & known_tls ) : ""0"" , ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) ? flow -> ssh_tls . ja3_client : """" , ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) ? is_unsafe_cipher ( flow -> ssh_tls . client_unsafe_cipher ) : ""0"" , ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) ? flow -> ssh_tls . ja3_server : """" , ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) ? is_unsafe_cipher ( flow -> ssh_tls . server_unsafe_cipher ) : ""0"" ) ; fprintf ( csv_fp , ""%s,%s,"" , flow -> ssh_tls . tls_alpn ? flow -> ssh_tls . tls_alpn : """" , flow -> ssh_tls . tls_supported_versions ? flow -> ssh_tls . tls_supported_versions : """" ) ; fprintf ( csv_fp , ""%s,%s,"" , flow -> ssh_tls . tls_issuerDN ? flow -> ssh_tls . tls_issuerDN : """" , flow -> ssh_tls . tls_subjectDN ? flow -> ssh_tls . tls_subjectDN : """" ) ; fprintf ( csv_fp , ""%s,%s"" , ( flow -> ssh_tls . client_hassh [ 0 ] != '\\0' ) ? flow -> ssh_tls . client_hassh : """" , ( flow -> ssh_tls . server_hassh [ 0 ] != '\\0' ) ? flow -> ssh_tls . server_hassh : """" ) ; fprintf ( csv_fp , "",%s"" , flow -> info ) ; } if ( ( verbose != 1 ) && ( verbose != 2 ) ) { if ( csv_fp && enable_joy_stats ) { flowGetBDMeanandVariance ( flow ) ; } if ( csv_fp ) fprintf ( csv_fp , ""\\n"" ) ; return ; } if ( csv_fp || ( verbose > 1 ) ) { # if 1 fprintf ( out , ""\\t%u"" , id ) ; # else fprintf ( out , ""\\t%u(%u)"" , id , flow -> flow_id ) ; # endif fprintf ( out , ""\\t%s<S2SV_blank>"" , ipProto2Name ( flow -> protocol ) ) ; fprintf ( out , ""%s%s%s:%u<S2SV_blank>%s<S2SV_blank>%s%s%s:%u<S2SV_blank>"" , ( flow -> ip_version == 6 ) ? ""["" : """" , flow -> src_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> src_port ) , flow -> bidirectional ? ""<->"" : ""->"" , ( flow -> ip_version == 6 ) ? ""["" : """" , flow -> dst_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> dst_port ) ) ; if ( flow -> vlan_id > 0 ) fprintf ( out , ""[VLAN:<S2SV_blank>%u]"" , flow -> vlan_id ) ; if ( enable_payload_analyzer ) fprintf ( out , ""[flowId:<S2SV_blank>%u]"" , flow -> flow_id ) ; } if ( enable_joy_stats ) { flowGetBDMeanandVariance ( flow ) ; fflush ( out ) ; fprintf ( out , ""[score:<S2SV_blank>%.4f]"" , flow -> entropy . score ) ; } if ( csv_fp ) fprintf ( csv_fp , ""\\n"" ) ; fprintf ( out , ""[proto:<S2SV_blank>"" ) ; if ( flow -> tunnel_type != ndpi_no_tunnel ) fprintf ( out , ""%s:"" , ndpi_tunnel2str ( flow -> tunnel_type ) ) ; fprintf ( out , ""%s/%s]"" , ndpi_protocol2id ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) , ndpi_protocol2name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf1 , sizeof ( buf1 ) ) ) ; if ( flow -> detected_protocol . category != 0 ) fprintf ( out , ""[cat:<S2SV_blank>%s/%u]"" , ndpi_category_get_name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol . category ) , ( unsigned int ) flow -> detected_protocol . category ) ; fprintf ( out , ""[%u<S2SV_blank>pkts/%llu<S2SV_blank>bytes<S2SV_blank>"" , flow -> src2dst_packets , ( long long unsigned int ) flow -> src2dst_bytes ) ; fprintf ( out , ""%s<S2SV_blank>%u<S2SV_blank>pkts/%llu<S2SV_blank>bytes]"" , ( flow -> dst2src_packets > 0 ) ? ""<->"" : ""->"" , flow -> dst2src_packets , ( long long unsigned int ) flow -> dst2src_bytes ) ; fprintf ( out , ""[Goodput<S2SV_blank>ratio:<S2SV_blank>%.0f/%.0f]"" , 100.0 * ( ( float ) flow -> src2dst_goodput_bytes / ( float ) ( flow -> src2dst_bytes + 1 ) ) , 100.0 * ( ( float ) flow -> dst2src_goodput_bytes / ( float ) ( flow -> dst2src_bytes + 1 ) ) ) ; if ( flow -> last_seen > flow -> first_seen ) fprintf ( out , ""[%.2f<S2SV_blank>sec]"" , ( ( float ) ( flow -> last_seen - flow -> first_seen ) ) / ( float ) 1000 ) ; else fprintf ( out , ""[<<S2SV_blank>1<S2SV_blank>sec]"" ) ; if ( flow -> telnet . username [ 0 ] != '\\0' ) fprintf ( out , ""[Username:<S2SV_blank>%s]"" , flow -> telnet . username ) ; if ( flow -> telnet . password [ 0 ] != '\\0' ) fprintf ( out , ""[Password:<S2SV_blank>%s]"" , flow -> telnet . password ) ; if ( flow -> host_server_name [ 0 ] != '\\0' ) fprintf ( out , ""[Host:<S2SV_blank>%s]"" , flow -> host_server_name ) ; if ( flow -> info [ 0 ] != '\\0' ) fprintf ( out , ""[%s]"" , flow -> info ) ; if ( flow -> flow_extra_info [ 0 ] != '\\0' ) fprintf ( out , ""[%s]"" , flow -> flow_extra_info ) ; if ( ( flow -> src2dst_packets + flow -> dst2src_packets ) > 5 ) { if ( flow -> iat_c_to_s && flow -> iat_s_to_c ) { float data_ratio = ndpi_data_ratio ( flow -> src2dst_bytes , flow -> dst2src_bytes ) ; fprintf ( out , ""[bytes<S2SV_blank>ratio:<S2SV_blank>%.3f<S2SV_blank>(%s)]"" , data_ratio , ndpi_data_ratio2str ( data_ratio ) ) ; fprintf ( out , ""[IAT<S2SV_blank>c2s/s2c<S2SV_blank>min/avg/max/stddev:<S2SV_blank>%u/%u<S2SV_blank>%.0f/%.0f<S2SV_blank>%u/%u<S2SV_blank>%.0f/%.0f]"" , ndpi_data_min ( flow -> iat_c_to_s ) , ndpi_data_min ( flow -> iat_s_to_c ) , ( float ) ndpi_data_average ( flow -> iat_c_to_s ) , ( float ) ndpi_data_average ( flow -> iat_s_to_c ) , ndpi_data_max ( flow -> iat_c_to_s ) , ndpi_data_max ( flow -> iat_s_to_c ) , ( float ) ndpi_data_stddev ( flow -> iat_c_to_s ) , ( float ) ndpi_data_stddev ( flow -> iat_s_to_c ) ) ; fprintf ( out , ""[Pkt<S2SV_blank>Len<S2SV_blank>c2s/s2c<S2SV_blank>min/avg/max/stddev:<S2SV_blank>%u/%u<S2SV_blank>%.0f/%.0f<S2SV_blank>%u/%u<S2SV_blank>%.0f/%.0f]"" , ndpi_data_min ( flow -> pktlen_c_to_s ) , ndpi_data_min ( flow -> pktlen_s_to_c ) , ndpi_data_average ( flow -> pktlen_c_to_s ) , ndpi_data_average ( flow -> pktlen_s_to_c ) , ndpi_data_max ( flow -> pktlen_c_to_s ) , ndpi_data_max ( flow -> pktlen_s_to_c ) , ndpi_data_stddev ( flow -> pktlen_c_to_s ) , ndpi_data_stddev ( flow -> pktlen_s_to_c ) ) ; } } if ( flow -> http . url [ 0 ] != '\\0' ) { ndpi_risk_enum risk = ndpi_validate_url ( flow -> http . url ) ; if ( risk != NDPI_NO_RISK ) NDPI_SET_BIT ( flow -> risk , risk ) ; fprintf ( out , ""[URL:<S2SV_blank>%s[StatusCode:<S2SV_blank>%u]"" , flow -> http . url , flow -> http . response_status_code ) ; if ( flow -> http . content_type [ 0 ] != '\\0' ) fprintf ( out , ""[ContentType:<S2SV_blank>%s]"" , flow -> http . content_type ) ; if ( flow -> http . user_agent [ 0 ] != '\\0' ) fprintf ( out , ""[UserAgent:<S2SV_blank>%s]"" , flow -> http . user_agent ) ; } if ( flow -> risk ) { u_int i ; fprintf ( out , ""[Risk:<S2SV_blank>"" ) ; for ( i = 0 ; i < NDPI_MAX_RISK ; i ++ ) if ( NDPI_ISSET_BIT ( flow -> risk , i ) ) fprintf ( out , ""**<S2SV_blank>%s<S2SV_blank>**"" , ndpi_risk2str ( i ) ) ; fprintf ( out , ""]"" ) ; } if ( flow -> ssh_tls . ssl_version != 0 ) fprintf ( out , ""[%s]"" , ndpi_ssl_version2str ( flow -> ssh_tls . ssl_version , & known_tls ) ) ; if ( flow -> ssh_tls . client_requested_server_name [ 0 ] != '\\0' ) fprintf ( out , ""[Client:<S2SV_blank>%s]"" , flow -> ssh_tls . client_requested_server_name ) ; if ( flow -> ssh_tls . client_hassh [ 0 ] != '\\0' ) fprintf ( out , ""[HASSH-C:<S2SV_blank>%s]"" , flow -> ssh_tls . client_hassh ) ; if ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) fprintf ( out , ""[JA3C:<S2SV_blank>%s%s]"" , flow -> ssh_tls . ja3_client , print_cipher ( flow -> ssh_tls . client_unsafe_cipher ) ) ; if ( flow -> ssh_tls . server_info [ 0 ] != '\\0' ) fprintf ( out , ""[Server:<S2SV_blank>%s]"" , flow -> ssh_tls . server_info ) ; if ( flow -> ssh_tls . server_names ) fprintf ( out , ""[ServerNames:<S2SV_blank>%s]"" , flow -> ssh_tls . server_names ) ; if ( flow -> ssh_tls . server_hassh [ 0 ] != '\\0' ) fprintf ( out , ""[HASSH-S:<S2SV_blank>%s]"" , flow -> ssh_tls . server_hassh ) ; if ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) fprintf ( out , ""[JA3S:<S2SV_blank>%s%s]"" , flow -> ssh_tls . ja3_server , print_cipher ( flow -> ssh_tls . server_unsafe_cipher ) ) ; if ( flow -> ssh_tls . tls_issuerDN ) fprintf ( out , ""[Issuer:<S2SV_blank>%s]"" , flow -> ssh_tls . tls_issuerDN ) ; if ( flow -> ssh_tls . tls_subjectDN ) fprintf ( out , ""[Subject:<S2SV_blank>%s]"" , flow -> ssh_tls . tls_subjectDN ) ; if ( ( flow -> detected_protocol . master_protocol == NDPI_PROTOCOL_TLS ) || ( flow -> detected_protocol . app_protocol == NDPI_PROTOCOL_TLS ) ) { if ( flow -> ssh_tls . sha1_cert_fingerprint_set ) { fprintf ( out , ""[Certificate<S2SV_blank>SHA-1:<S2SV_blank>"" ) ; for ( i = 0 ; i < 20 ; i ++ ) fprintf ( out , ""%s%02X"" , ( i > 0 ) ? "":"" : """" , flow -> ssh_tls . sha1_cert_fingerprint [ i ] & 0xFF ) ; fprintf ( out , ""]"" ) ; } } if ( flow -> ssh_tls . notBefore && flow -> ssh_tls . notAfter ) { char notBefore [ 32 ] , notAfter [ 32 ] ; struct tm a , b ; struct tm * before = gmtime_r ( & flow -> ssh_tls . notBefore , & a ) ; struct tm * after = gmtime_r ( & flow -> ssh_tls . notAfter , & b ) ; strftime ( notBefore , sizeof ( notBefore ) , ""%F<S2SV_blank>%T"" , before ) ; strftime ( notAfter , sizeof ( notAfter ) , ""%F<S2SV_blank>%T"" , after ) ; fprintf ( out , ""[Validity:<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%s]"" , notBefore , notAfter ) ; } if ( flow -> ssh_tls . server_cipher != '\\0' ) fprintf ( out , ""[Cipher:<S2SV_blank>%s]"" , ndpi_cipher2str ( flow -> ssh_tls . server_cipher ) ) ; if ( flow -> bittorent_hash [ 0 ] != '\\0' ) fprintf ( out , ""[BT<S2SV_blank>Hash:<S2SV_blank>%s]"" , flow -> bittorent_hash ) ; if ( flow -> dhcp_fingerprint [ 0 ] != '\\0' ) fprintf ( out , ""[DHCP<S2SV_blank>Fingerprint:<S2SV_blank>%s]"" , flow -> dhcp_fingerprint ) ; if ( flow -> has_human_readeable_strings ) fprintf ( out , ""[PLAIN<S2SV_blank>TEXT<S2SV_blank>(%s)]"" , flow -> human_readeable_string_buffer ) ; fprintf ( out , ""\\n"" ) ; }
","<S2SV_ModStart> ( out , ""[URL:<S2SV_blank>%s][StatusCode:<S2SV_blank>%u]"" <S2SV_ModEnd> , flow -> <S2SV_ModStart> ( out , ""[Content-Type:<S2SV_blank>%s]"" <S2SV_ModEnd> , flow -> <S2SV_ModStart> ( out , ""[User-Agent:<S2SV_blank>%s]"" <S2SV_ModEnd> , flow ->
",ntop@nDPI/b7e666e465f138ae48ab81976726e67deed12701,CVE-2020-15472,https://github.com/ntop/nDPI/commit/b7e666e465f138ae48ab81976726e67deed12701,2020-07-01T11:15Z,"<S2SV_StartBug> fprintf ( out , ""[URL:<S2SV_blank>%s[StatusCode:<S2SV_blank>%u]"" , <S2SV_EndBug> <S2SV_StartBug> fprintf ( out , ""[ContentType:<S2SV_blank>%s]"" , flow -> http . content_type ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( out , ""[UserAgent:<S2SV_blank>%s]"" , flow -> http . user_agent ) ; <S2SV_EndBug>"
2475,CWE-189,"int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { size_t ofs , tail = ( i << 1 ) + 1 ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; ofs = CDF_GETUINT32 ( p , tail ) ; q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements && i < sh . sh_properties ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
","<S2SV_ModStart> if ( q < p || q
",php@php-src/7ba1409a1aee5925180de546057ddd84ff267947,CVE-2014-3587,https://github.com/php/php-src/commit/7ba1409a1aee5925180de546057ddd84ff267947,2014-08-23T01:55Z,<S2SV_StartBug> if ( q > e ) { <S2SV_EndBug>
2468,CWE-119,"void ParseNameValue ( const char * buffer , int bufsize , struct NameValueParserData * data ) { struct xmlparser parser ; data -> l_head = NULL ; data -> portListing = NULL ; data -> portListingLength = 0 ; parser . xmlstart = buffer ; parser . xmlsize = bufsize ; parser . data = data ; parser . starteltfunc = NameValueParserStartElt ; parser . endeltfunc = NameValueParserEndElt ; parser . datafunc = NameValueParserGetData ; parser . attfunc = 0 ; parsexml ( & parser ) ; }
","<S2SV_ModStart> xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser .
",miniupnp@miniupnp/7aeb624b44f86d335841242ff427433190e7168a,CVE-2017-1000494,https://github.com/miniupnp/miniupnp/commit/7aeb624b44f86d335841242ff427433190e7168a,2018-01-03T14:29Z,<S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug>
912,CWE-399,"void unix_inflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; spin_lock ( & unix_gc_lock ) ; if ( s ) { struct unix_sock * u = unix_sk ( s ) ; if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { BUG_ON ( ! list_empty ( & u -> link ) ) ; list_add_tail ( & u -> link , & gc_inflight_list ) ; } else { BUG_ON ( list_empty ( & u -> link ) ) ; } unix_tot_inflight ++ ; } fp -> f_cred -> user -> unix_inflight ++ ; spin_unlock ( & unix_gc_lock ) ; }
","<S2SV_ModStart> void unix_inflight ( struct user_struct * user , <S2SV_ModStart> ++ ; } <S2SV_ModEnd> user -> unix_inflight
",torvalds@linux/415e3d3e90ce9e18727e8843ae343eda5a58fad6,CVE-2016-2550,https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6,2016-04-27T17:59Z,<S2SV_StartBug> void unix_inflight ( struct file * fp ) <S2SV_EndBug> <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_EndBug>
5291,CWE-476,"jas_image_t * jp2_decode ( jas_stream_t * in , const char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; JAS_DBGLOG ( 100 , ( ""jp2_decode(%p,<S2SV_blank>\\""%s\\"")\\n"" , in , optstr ) ) ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( ""error:<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>box\\n"" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( ""error:<S2SV_blank>expecting<S2SV_blank>signature<S2SV_blank>box\\n"" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( ""incorrect<S2SV_blank>magic<S2SV_blank>number\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( ""expecting<S2SV_blank>file<S2SV_blank>type<S2SV_blank>box\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( ""got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\n"" , box -> info -> name ) ; } switch ( box -> type ) { case JP2_BOX_JP2C : found = 1 ; break ; case JP2_BOX_IHDR : if ( ! dec -> ihdr ) { dec -> ihdr = box ; box = 0 ; } break ; case JP2_BOX_BPCC : if ( ! dec -> bpcc ) { dec -> bpcc = box ; box = 0 ; } break ; case JP2_BOX_CDEF : if ( ! dec -> cdef ) { dec -> cdef = box ; box = 0 ; } break ; case JP2_BOX_PCLR : if ( ! dec -> pclr ) { dec -> pclr = box ; box = 0 ; } break ; case JP2_BOX_CMAP : if ( ! dec -> cmap ) { dec -> cmap = box ; box = 0 ; } break ; case JP2_BOX_COLR : if ( ! dec -> colr ) { dec -> colr = box ; box = 0 ; } break ; } if ( box ) { jp2_box_destroy ( box ) ; box = 0 ; } if ( found ) { break ; } } if ( ! found ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>code<S2SV_blank>stream<S2SV_blank>found\\n"" ) ; goto error ; } if ( ! ( dec -> image = jpc_decode ( in , optstr ) ) ) { jas_eprintf ( ""error:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>code<S2SV_blank>stream\\n"" ) ; goto error ; } if ( ! dec -> ihdr ) { jas_eprintf ( ""error:<S2SV_blank>missing<S2SV_blank>IHDR<S2SV_blank>box\\n"" ) ; goto error ; } if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\n"" ) ; } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>components\\n"" ) ; goto error ; } samedtype = true ; dtype = jas_image_cmptdtype ( dec -> image , 0 ) ; for ( i = 1 ; i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) { samedtype = false ; break ; } } if ( ( samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_DTYPETOBPC ( dtype ) ) || ( ! samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_IHDR_BPCNULL ) ) { jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; } if ( dec -> ihdr -> data . ihdr . comptype != JP2_IHDR_COMPTYPE ) { jas_eprintf ( ""error:<S2SV_blank>unsupported<S2SV_blank>compression<S2SV_blank>type\\n"" ) ; goto error ; } if ( dec -> bpcc ) { if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\n"" ) ; } if ( ! samedtype ) { for ( i = 0 ; i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != JP2_BPCTODTYPE ( dec -> bpcc -> data . bpcc . bpcs [ i ] ) ) { jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; } } } else { jas_eprintf ( ""warning:<S2SV_blank>superfluous<S2SV_blank>BPCC<S2SV_blank>box\\n"" ) ; } } if ( ! dec -> colr ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>COLR<S2SV_blank>box\\n"" ) ; goto error ; } switch ( dec -> colr -> data . colr . method ) { case JP2_COLR_ENUM : jas_image_setclrspc ( dec -> image , jp2_getcs ( & dec -> colr -> data . colr ) ) ; break ; case JP2_COLR_ICC : iccprof = jas_iccprof_createfrombuf ( dec -> colr -> data . colr . iccp , dec -> colr -> data . colr . iccplen ) ; if ( ! iccprof ) { jas_eprintf ( ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>ICC<S2SV_blank>profile\\n"" ) ; goto error ; } jas_iccprof_gethdr ( iccprof , & icchdr ) ; jas_eprintf ( ""ICC<S2SV_blank>Profile<S2SV_blank>CS<S2SV_blank>%08x\\n"" , icchdr . colorspc ) ; jas_image_setclrspc ( dec -> image , fromiccpcs ( icchdr . colorspc ) ) ; dec -> image -> cmprof_ = jas_cmprof_createfromiccprof ( iccprof ) ; if ( ! dec -> image -> cmprof_ ) { jas_iccprof_destroy ( iccprof ) ; goto error ; } jas_iccprof_destroy ( iccprof ) ; break ; } if ( dec -> cmap && ! dec -> pclr ) { jas_eprintf ( ""warning:<S2SV_blank>missing<S2SV_blank>PCLR<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>CMAP<S2SV_blank>box\\n"" ) ; jp2_box_destroy ( dec -> cmap ) ; dec -> cmap = 0 ; } if ( ! dec -> cmap && dec -> pclr ) { jas_eprintf ( ""warning:<S2SV_blank>missing<S2SV_blank>CMAP<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>PCLR<S2SV_blank>box\\n"" ) ; jp2_box_destroy ( dec -> pclr ) ; dec -> pclr = 0 ; } dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans : JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; if ( dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>component<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CMAP<S2SV_blank>box\\n"" ) ; goto error ; } if ( dec -> cmap -> data . cmap . ents [ i ] . pcol >= dec -> pclr -> data . pclr . numchans ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>CMAP<S2SV_blank>LUT<S2SV_blank>index\\n"" ) ; goto error ; } } } if ( ! ( dec -> chantocmptlut = jas_alloc2 ( dec -> numchans , sizeof ( uint_fast16_t ) ) ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>memory\\n"" ) ; goto error ; } if ( ! dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { dec -> chantocmptlut [ i ] = i ; } } else { cmapd = & dec -> cmap -> data . cmap ; pclrd = & dec -> pclr -> data . pclr ; cdefd = & dec -> cdef -> data . cdef ; for ( channo = 0 ; channo < cmapd -> numchans ; ++ channo ) { cmapent = & cmapd -> ents [ channo ] ; if ( cmapent -> map == JP2_CMAP_DIRECT ) { dec -> chantocmptlut [ channo ] = channo ; } else if ( cmapent -> map == JP2_CMAP_PALETTE ) { if ( ! pclrd -> numlutents ) { goto error ; } lutents = jas_alloc2 ( pclrd -> numlutents , sizeof ( int_fast32_t ) ) ; if ( ! lutents ) { goto error ; } for ( i = 0 ; i < pclrd -> numlutents ; ++ i ) { lutents [ i ] = pclrd -> lutdata [ cmapent -> pcol + i * pclrd -> numchans ] ; } newcmptno = jas_image_numcmpts ( dec -> image ) ; jas_image_depalettize ( dec -> image , cmapent -> cmptno , pclrd -> numlutents , lutents , JP2_BPCTODTYPE ( pclrd -> bpc [ cmapent -> pcol ] ) , newcmptno ) ; dec -> chantocmptlut [ channo ] = newcmptno ; jas_free ( lutents ) ; # if 0 if ( dec -> cdef ) { cdefent = jp2_cdef_lookup ( cdefd , channo ) ; if ( ! cdefent ) { abort ( ) ; } jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , cdefent -> type , cdefent -> assoc ) ) ; } else { jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , channo + 1 ) ) ; } # else ( void ) cdefd ; # endif } else { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>MTYP<S2SV_blank>in<S2SV_blank>CMAP<S2SV_blank>box\\n"" ) ; goto error ; } } } if ( dec -> numchans != jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<S2SV_blank>mismatch<S2SV_blank>in<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>(%d<S2SV_blank>!=<S2SV_blank>%d)\\n"" , dec -> numchans , jas_image_numcmpts ( dec -> image ) ) ; goto error ; } for ( i = 0 ; i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ; } if ( dec -> cdef ) { for ( i = 0 ; i < dec -> cdef -> data . cdef . numchans ; ++ i ) { if ( dec -> cdef -> data . cdef . ents [ i ] . channo >= dec -> numchans ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>channel<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CDEF<S2SV_blank>box\\n"" ) ; goto error ; } jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ dec -> cdef -> data . cdef . ents [ i ] . channo ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , dec -> cdef -> data . cdef . ents [ i ] . type , dec -> cdef -> data . cdef . ents [ i ] . assoc ) ) ; } } else { for ( i = 0 ; i < dec -> numchans ; ++ i ) { jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ i ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , i + 1 ) ) ; } } for ( i = jas_image_numcmpts ( dec -> image ) ; i > 0 ; -- i ) { if ( jas_image_cmpttype ( dec -> image , i - 1 ) == JAS_IMAGE_CT_UNKNOWN ) { jas_image_delcmpt ( dec -> image , i - 1 ) ; } } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>components\\n"" ) ; goto error ; } # if 0 jas_eprintf ( ""no<S2SV_blank>of<S2SV_blank>components<S2SV_blank>is<S2SV_blank>%d\\n"" , jas_image_numcmpts ( dec -> image ) ) ; # endif image = dec -> image ; dec -> image = 0 ; jp2_dec_destroy ( dec ) ; return image ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( dec ) { jp2_dec_destroy ( dec ) ; } return 0 ; }
","<S2SV_ModStart> { jas_eprintf ( ""error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> { jas_eprintf ( ""error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> { jas_eprintf ( ""error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; goto error <S2SV_ModEnd> ; } }
",jasper-software@jasper/41f214b121b837fa30d9ca5f2430212110f5cd9b,CVE-2021-26927,https://github.com/jasper-software/jasper/commit/41f214b121b837fa30d9ca5f2430212110f5cd9b,2021-02-23T20:15Z,"<S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> dec -> image ) ) ) { <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; <S2SV_EndBug>"
94,CWE-119,"static int create_qp_common ( struct mlx5_ib_dev * dev , struct ib_pd * pd , struct ib_qp_init_attr * init_attr , struct ib_udata * udata , struct mlx5_ib_qp * qp ) { struct mlx5_ib_resources * devr = & dev -> devr ; int inlen = MLX5_ST_SZ_BYTES ( create_qp_in ) ; struct mlx5_core_dev * mdev = dev -> mdev ; struct mlx5_ib_create_qp_resp resp ; struct mlx5_ib_cq * send_cq ; struct mlx5_ib_cq * recv_cq ; unsigned long flags ; u32 uidx = MLX5_IB_DEFAULT_UIDX ; struct mlx5_ib_create_qp ucmd ; struct mlx5_ib_qp_base * base ; int mlx5_st ; void * qpc ; u32 * in ; int err ; mutex_init ( & qp -> mutex ) ; spin_lock_init ( & qp -> sq . lock ) ; spin_lock_init ( & qp -> rq . lock ) ; mlx5_st = to_mlx5_st ( init_attr -> qp_type ) ; if ( mlx5_st < 0 ) return - EINVAL ; if ( init_attr -> rwq_ind_tbl ) { if ( ! udata ) return - ENOSYS ; err = create_rss_raw_qp_tir ( dev , qp , pd , init_attr , udata ) ; return err ; } if ( init_attr -> create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK ) { if ( ! MLX5_CAP_GEN ( mdev , block_lb_mc ) ) { mlx5_ib_dbg ( dev , ""block<S2SV_blank>multicast<S2SV_blank>loopback<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EINVAL ; } else { qp -> flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ; } } if ( init_attr -> create_flags & ( IB_QP_CREATE_CROSS_CHANNEL | IB_QP_CREATE_MANAGED_SEND | IB_QP_CREATE_MANAGED_RECV ) ) { if ( ! MLX5_CAP_GEN ( mdev , cd ) ) { mlx5_ib_dbg ( dev , ""cross-channel<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EINVAL ; } if ( init_attr -> create_flags & IB_QP_CREATE_CROSS_CHANNEL ) qp -> flags |= MLX5_IB_QP_CROSS_CHANNEL ; if ( init_attr -> create_flags & IB_QP_CREATE_MANAGED_SEND ) qp -> flags |= MLX5_IB_QP_MANAGED_SEND ; if ( init_attr -> create_flags & IB_QP_CREATE_MANAGED_RECV ) qp -> flags |= MLX5_IB_QP_MANAGED_RECV ; } if ( init_attr -> qp_type == IB_QPT_UD && ( init_attr -> create_flags & IB_QP_CREATE_IPOIB_UD_LSO ) ) if ( ! MLX5_CAP_GEN ( mdev , ipoib_basic_offloads ) ) { mlx5_ib_dbg ( dev , ""ipoib<S2SV_blank>UD<S2SV_blank>lso<S2SV_blank>qp<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } if ( init_attr -> create_flags & IB_QP_CREATE_SCATTER_FCS ) { if ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) { mlx5_ib_dbg ( dev , ""Scatter<S2SV_blank>FCS<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>only<S2SV_blank>for<S2SV_blank>Raw<S2SV_blank>Packet<S2SV_blank>QPs"" ) ; return - EOPNOTSUPP ; } if ( ! MLX5_CAP_GEN ( dev -> mdev , eth_net_offloads ) || ! MLX5_CAP_ETH ( dev -> mdev , scatter_fcs ) ) { mlx5_ib_dbg ( dev , ""Scatter<S2SV_blank>FCS<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } qp -> flags |= MLX5_IB_QP_CAP_SCATTER_FCS ; } if ( init_attr -> sq_sig_type == IB_SIGNAL_ALL_WR ) qp -> sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE ; if ( init_attr -> create_flags & IB_QP_CREATE_CVLAN_STRIPPING ) { if ( ! ( MLX5_CAP_GEN ( dev -> mdev , eth_net_offloads ) && MLX5_CAP_ETH ( dev -> mdev , vlan_cap ) ) || ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) ) return - EOPNOTSUPP ; qp -> flags |= MLX5_IB_QP_CVLAN_STRIPPING ; } if ( pd && pd -> uobject ) { if ( ib_copy_from_udata ( & ucmd , udata , sizeof ( ucmd ) ) ) { mlx5_ib_dbg ( dev , ""copy<S2SV_blank>failed\\n"" ) ; return - EFAULT ; } err = get_qp_user_index ( to_mucontext ( pd -> uobject -> context ) , & ucmd , udata -> inlen , & uidx ) ; if ( err ) return err ; qp -> wq_sig = ! ! ( ucmd . flags & MLX5_QP_FLAG_SIGNATURE ) ; qp -> scat_cqe = ! ! ( ucmd . flags & MLX5_QP_FLAG_SCATTER_CQE ) ; if ( ucmd . flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS ) { if ( init_attr -> qp_type != IB_QPT_RAW_PACKET || ! tunnel_offload_supported ( mdev ) ) { mlx5_ib_dbg ( dev , ""Tunnel<S2SV_blank>offload<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } qp -> tunnel_offload_en = true ; } if ( init_attr -> create_flags & IB_QP_CREATE_SOURCE_QPN ) { if ( init_attr -> qp_type != IB_QPT_UD || ( MLX5_CAP_GEN ( dev -> mdev , port_type ) != MLX5_CAP_PORT_TYPE_IB ) || ! mlx5_get_flow_namespace ( dev -> mdev , MLX5_FLOW_NAMESPACE_BYPASS ) ) { mlx5_ib_dbg ( dev , ""Source<S2SV_blank>QP<S2SV_blank>option<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } qp -> flags |= MLX5_IB_QP_UNDERLAY ; qp -> underlay_qpn = init_attr -> source_qpn ; } } else { qp -> wq_sig = ! ! wq_signature ; } base = ( init_attr -> qp_type == IB_QPT_RAW_PACKET || qp -> flags & MLX5_IB_QP_UNDERLAY ) ? & qp -> raw_packet_qp . rq . base : & qp -> trans_qp . base ; qp -> has_rq = qp_has_rq ( init_attr ) ; err = set_rq_size ( dev , & init_attr -> cap , qp -> has_rq , qp , ( pd && pd -> uobject ) ? & ucmd : NULL ) ; if ( err ) { mlx5_ib_dbg ( dev , ""err<S2SV_blank>%d\\n"" , err ) ; return err ; } if ( pd ) { if ( pd -> uobject ) { __u32 max_wqes = 1 << MLX5_CAP_GEN ( mdev , log_max_qp_sz ) ; mlx5_ib_dbg ( dev , ""requested<S2SV_blank>sq_wqe_count<S2SV_blank>(%d)\\n"" , ucmd . sq_wqe_count ) ; if ( ucmd . rq_wqe_shift != qp -> rq . wqe_shift || ucmd . rq_wqe_count != qp -> rq . wqe_cnt ) { mlx5_ib_dbg ( dev , ""invalid<S2SV_blank>rq<S2SV_blank>params\\n"" ) ; return - EINVAL ; } if ( ucmd . sq_wqe_count > max_wqes ) { mlx5_ib_dbg ( dev , ""requested<S2SV_blank>sq_wqe_count<S2SV_blank>(%d)<S2SV_blank>><S2SV_blank>max<S2SV_blank>allowed<S2SV_blank>(%d)\\n"" , ucmd . sq_wqe_count , max_wqes ) ; return - EINVAL ; } if ( init_attr -> create_flags & mlx5_ib_create_qp_sqpn_qp1 ( ) ) { mlx5_ib_dbg ( dev , ""user-space<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>UD<S2SV_blank>QPs<S2SV_blank>spoofing<S2SV_blank>as<S2SV_blank>QP1\\n"" ) ; return - EINVAL ; } err = create_user_qp ( dev , pd , qp , udata , init_attr , & in , & resp , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , ""err<S2SV_blank>%d\\n"" , err ) ; } else { err = create_kernel_qp ( dev , init_attr , qp , & in , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , ""err<S2SV_blank>%d\\n"" , err ) ; } if ( err ) return err ; } else { in = kvzalloc ( inlen , GFP_KERNEL ) ; if ( ! in ) return - ENOMEM ; qp -> create_type = MLX5_QP_EMPTY ; } if ( is_sqp ( init_attr -> qp_type ) ) qp -> port = init_attr -> port_num ; qpc = MLX5_ADDR_OF ( create_qp_in , in , qpc ) ; MLX5_SET ( qpc , qpc , st , mlx5_st ) ; MLX5_SET ( qpc , qpc , pm_state , MLX5_QP_PM_MIGRATED ) ; if ( init_attr -> qp_type != MLX5_IB_QPT_REG_UMR ) MLX5_SET ( qpc , qpc , pd , to_mpd ( pd ? pd : devr -> p0 ) -> pdn ) ; else MLX5_SET ( qpc , qpc , latency_sensitive , 1 ) ; if ( qp -> wq_sig ) MLX5_SET ( qpc , qpc , wq_signature , 1 ) ; if ( qp -> flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ) MLX5_SET ( qpc , qpc , block_lb_mc , 1 ) ; if ( qp -> flags & MLX5_IB_QP_CROSS_CHANNEL ) MLX5_SET ( qpc , qpc , cd_master , 1 ) ; if ( qp -> flags & MLX5_IB_QP_MANAGED_SEND ) MLX5_SET ( qpc , qpc , cd_slave_send , 1 ) ; if ( qp -> flags & MLX5_IB_QP_MANAGED_RECV ) MLX5_SET ( qpc , qpc , cd_slave_receive , 1 ) ; if ( qp -> scat_cqe && is_connected ( init_attr -> qp_type ) ) { int rcqe_sz ; int scqe_sz ; rcqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> recv_cq ) ; scqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> send_cq ) ; if ( rcqe_sz == 128 ) MLX5_SET ( qpc , qpc , cs_res , MLX5_RES_SCAT_DATA64_CQE ) ; else MLX5_SET ( qpc , qpc , cs_res , MLX5_RES_SCAT_DATA32_CQE ) ; if ( init_attr -> sq_sig_type == IB_SIGNAL_ALL_WR ) { if ( scqe_sz == 128 ) MLX5_SET ( qpc , qpc , cs_req , MLX5_REQ_SCAT_DATA64_CQE ) ; else MLX5_SET ( qpc , qpc , cs_req , MLX5_REQ_SCAT_DATA32_CQE ) ; } } if ( qp -> rq . wqe_cnt ) { MLX5_SET ( qpc , qpc , log_rq_stride , qp -> rq . wqe_shift - 4 ) ; MLX5_SET ( qpc , qpc , log_rq_size , ilog2 ( qp -> rq . wqe_cnt ) ) ; } MLX5_SET ( qpc , qpc , rq_type , get_rx_type ( qp , init_attr ) ) ; if ( qp -> sq . wqe_cnt ) { MLX5_SET ( qpc , qpc , log_sq_size , ilog2 ( qp -> sq . wqe_cnt ) ) ; } else { MLX5_SET ( qpc , qpc , no_sq , 1 ) ; if ( init_attr -> srq && init_attr -> srq -> srq_type == IB_SRQT_TM ) MLX5_SET ( qpc , qpc , offload_type , MLX5_QPC_OFFLOAD_TYPE_RNDV ) ; } switch ( init_attr -> qp_type ) { case IB_QPT_XRC_TGT : MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , cqn_snd , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( init_attr -> xrcd ) -> xrcdn ) ; break ; case IB_QPT_XRC_INI : MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; break ; default : if ( init_attr -> srq ) { MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x0 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( init_attr -> srq ) -> msrq . srqn ) ; } else { MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s1 ) -> msrq . srqn ) ; } } if ( init_attr -> send_cq ) MLX5_SET ( qpc , qpc , cqn_snd , to_mcq ( init_attr -> send_cq ) -> mcq . cqn ) ; if ( init_attr -> recv_cq ) MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( init_attr -> recv_cq ) -> mcq . cqn ) ; MLX5_SET64 ( qpc , qpc , dbr_addr , qp -> db . dma ) ; if ( MLX5_CAP_GEN ( mdev , cqe_version ) == MLX5_CQE_VERSION_V1 ) MLX5_SET ( qpc , qpc , user_index , uidx ) ; if ( init_attr -> qp_type == IB_QPT_UD && ( init_attr -> create_flags & IB_QP_CREATE_IPOIB_UD_LSO ) ) { MLX5_SET ( qpc , qpc , ulp_stateless_offload_mode , 1 ) ; qp -> flags |= MLX5_IB_QP_LSO ; } if ( init_attr -> create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING ) { if ( ! MLX5_CAP_GEN ( dev -> mdev , end_pad ) ) { mlx5_ib_dbg ( dev , ""scatter<S2SV_blank>end<S2SV_blank>padding<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; err = - EOPNOTSUPP ; goto err ; } else if ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) { MLX5_SET ( qpc , qpc , end_padding_mode , MLX5_WQ_END_PAD_MODE_ALIGN ) ; } else { qp -> flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING ; } } if ( inlen < 0 ) { err = - EINVAL ; goto err ; } if ( init_attr -> qp_type == IB_QPT_RAW_PACKET || qp -> flags & MLX5_IB_QP_UNDERLAY ) { qp -> raw_packet_qp . sq . ubuffer . buf_addr = ucmd . sq_buf_addr ; raw_packet_qp_copy_info ( qp , & qp -> raw_packet_qp ) ; err = create_raw_packet_qp ( dev , qp , in , inlen , pd ) ; } else { err = mlx5_core_create_qp ( dev -> mdev , & base -> mqp , in , inlen ) ; } if ( err ) { mlx5_ib_dbg ( dev , ""create<S2SV_blank>qp<S2SV_blank>failed\\n"" ) ; goto err_create ; } kvfree ( in ) ; base -> container_mibqp = qp ; base -> mqp . event = mlx5_ib_qp_event ; get_cqs ( init_attr -> qp_type , init_attr -> send_cq , init_attr -> recv_cq , & send_cq , & recv_cq ) ; spin_lock_irqsave ( & dev -> reset_flow_resource_lock , flags ) ; mlx5_ib_lock_cqs ( send_cq , recv_cq ) ; list_add_tail ( & qp -> qps_list , & dev -> qp_list ) ; if ( send_cq ) list_add_tail ( & qp -> cq_send_list , & send_cq -> list_send_qp ) ; if ( recv_cq ) list_add_tail ( & qp -> cq_recv_list , & recv_cq -> list_recv_qp ) ; mlx5_ib_unlock_cqs ( send_cq , recv_cq ) ; spin_unlock_irqrestore ( & dev -> reset_flow_resource_lock , flags ) ; return 0 ; err_create : if ( qp -> create_type == MLX5_QP_USER ) destroy_qp_user ( dev , pd , qp , base ) ; else if ( qp -> create_type == MLX5_QP_KERNEL ) destroy_qp_kernel ( dev , qp ) ; err : kvfree ( in ) ; return err ; }
","<S2SV_ModStart> struct mlx5_ib_create_qp_resp resp = { }
",torvalds@linux/0625b4ba1a5d4703c7fb01c497bd6c156908af00,CVE-2018-20855,https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00,2019-07-26T05:15Z,<S2SV_StartBug> struct mlx5_ib_create_qp_resp resp ; <S2SV_EndBug>
1681,CWE-119,"void vp9_cost_tokens ( int * costs , const vp9_prob * probs , vp9_tree tree ) { cost ( costs , tree , probs , 0 , 0 ) ; }
","<S2SV_ModStart> costs , const vpx_prob <S2SV_ModEnd> * probs , <S2SV_ModStart> * probs , vpx_tree <S2SV_ModEnd> tree ) {
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> void vp9_cost_tokens ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <S2SV_EndBug>"
4843,CWE-787,"static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , ""number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ; int xd_size = 0 ; int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ; xd_size += len ; } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ; if ( delta > data_len [ j ] ) { return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; } offset += data_len [ j ] ; } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }
","<S2SV_ModStart> int xd_size = 1 <S2SV_ModEnd> ; int data_len <S2SV_ModStart> xd_size += len + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ] ) ; av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> offset += delta <S2SV_ModStart> break ; } av_assert0 ( data_len [ j ] <= xd_size - offset ) ;
",FFmpeg@FFmpeg/27a99e2c7d450fef15594671eef4465c8a166bd7,CVE-2020-35964,https://github.com/FFmpeg/FFmpeg/commit/27a99e2c7d450fef15594671eef4465c8a166bd7,2021-01-03T19:15Z,<S2SV_StartBug> int xd_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> xd_size += len ; <S2SV_EndBug> <S2SV_StartBug> if ( delta > data_len [ j ] ) { <S2SV_EndBug> <S2SV_StartBug> offset += data_len [ j ] ; <S2SV_EndBug>
2874,CWE-200,"static void snd_timer_user_ccallback ( struct snd_timer_instance * timeri , int event , struct timespec * tstamp , unsigned long resolution ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread r1 ; unsigned long flags ; if ( event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE ) tu -> tstamp = * tstamp ; if ( ( tu -> filter & ( 1 << event ) ) == 0 || ! tu -> tread ) return ; r1 . event = event ; r1 . tstamp = * tstamp ; r1 . val = resolution ; spin_lock_irqsave ( & tu -> qlock , flags ) ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; spin_unlock_irqrestore ( & tu -> qlock , flags ) ; kill_fasync ( & tu -> fasync , SIGIO , POLL_IN ) ; wake_up ( & tu -> qchange_sleep ) ; }
","<S2SV_ModStart> ) return ; memset ( & r1 , 0 , sizeof ( r1 ) ) ;
",torvalds@linux/9a47e9cff994f37f7f0dbd9ae23740d0f64f9fe6,CVE-2016-4578,https://github.com/torvalds/linux/commit/9a47e9cff994f37f7f0dbd9ae23740d0f64f9fe6,2016-05-23T10:59Z,<S2SV_StartBug> r1 . event = event ; <S2SV_EndBug>
3063,CWE-119,"static int logi_dj_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * data , int size ) { struct dj_receiver_dev * djrcv_dev = hid_get_drvdata ( hdev ) ; struct dj_report * dj_report = ( struct dj_report * ) data ; unsigned long flags ; bool report_processed = false ; dbg_hid ( ""%s,<S2SV_blank>size:%d\\n"" , __func__ , size ) ; spin_lock_irqsave ( & djrcv_dev -> lock , flags ) ; if ( dj_report -> report_id == REPORT_ID_DJ_SHORT ) { switch ( dj_report -> report_type ) { case REPORT_TYPE_NOTIF_DEVICE_PAIRED : case REPORT_TYPE_NOTIF_DEVICE_UNPAIRED : logi_dj_recv_queue_notification ( djrcv_dev , dj_report ) ; break ; case REPORT_TYPE_NOTIF_CONNECTION_STATUS : if ( dj_report -> report_params [ CONNECTION_STATUS_PARAM_STATUS ] == STATUS_LINKLOSS ) { logi_dj_recv_forward_null_report ( djrcv_dev , dj_report ) ; } break ; default : logi_dj_recv_forward_report ( djrcv_dev , dj_report ) ; } report_processed = true ; } spin_unlock_irqrestore ( & djrcv_dev -> lock , flags ) ; return report_processed ; }
","<S2SV_ModStart> size ) ; if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n"" , __func__ , dj_report -> device_index ) ; return false ; }
",torvalds@linux/ad3e14d7c5268c2e24477c6ef54bbdf88add5d36,CVE-2014-3182,https://github.com/torvalds/linux/commit/ad3e14d7c5268c2e24477c6ef54bbdf88add5d36,2014-09-28T10:55Z,"<S2SV_StartBug> dbg_hid ( ""%s,<S2SV_blank>size:%d\\n"" , __func__ , size ) ; <S2SV_EndBug>"
4442,CWE-401,"struct resource_pool * dce112_create_resource_pool ( uint8_t num_virtual_links , struct dc * dc ) { struct dce110_resource_pool * pool = kzalloc ( sizeof ( struct dce110_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( num_virtual_links , dc , pool ) ) return & pool -> base ; BREAK_TO_DEBUGGER ( ) ; return NULL ; }
","<S2SV_ModStart> -> base ; kfree ( pool ) ;
",torvalds@linux/104c307147ad379617472dd91a5bcb368d72bd6d,CVE-2019-19082,https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d,2019-11-18T06:15Z,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug>
8084,CWE-400,"static int evtchn_fifo_percpu_deinit ( unsigned int cpu ) { __evtchn_fifo_handle_events ( cpu , true ) ; return 0 ; }
","<S2SV_ModStart> ( cpu , NULL <S2SV_ModEnd> ) ; return
",torvalds@linux/e99502f76271d6bc4e374fe368c50c67a1fd3070,CVE-2020-27673,https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070,2020-10-22T21:15Z,"<S2SV_StartBug> __evtchn_fifo_handle_events ( cpu , true ) ; <S2SV_EndBug>"
3648,CWE-125,"static inline unsigned short ReadPropertyUnsignedShort ( const EndianType endian , const unsigned char * buffer ) { unsigned short value ; if ( endian == LSBEndian ) { value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; return ( ( unsigned short ) ( value & 0xffff ) ) ; } value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | ( ( unsigned char * ) buffer ) [ 1 ] ) ; return ( ( unsigned short ) ( value & 0xffff ) ) ; }
","<S2SV_ModStart> unsigned short ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; return ( <S2SV_ModStart> ; return ( <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ) ; } <S2SV_ModStart> unsigned short ) buffer <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ] << 8 ; value |= <S2SV_ModEnd> ( unsigned short <S2SV_ModStart> unsigned short ) buffer [ 1 ] ; return <S2SV_ModStart> & 0xffff ) <S2SV_ModEnd> ; } <S2SV_null>
",ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5842,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z,<S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug>
1335,CWE-119,"static void set_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { unsigned int i ; vpx_active_map_t map = { 0 } ; map . rows = ( cfg -> g_h + 15 ) / 16 ; map . cols = ( cfg -> g_w + 15 ) / 16 ; map . active_map = ( uint8_t * ) malloc ( map . rows * map . cols ) ; for ( i = 0 ; i < map . rows * map . cols ; ++ i ) map . active_map [ i ] = i % 2 ; if ( vpx_codec_control ( codec , VP8E_SET_ACTIVEMAP , & map ) ) die_codec ( codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>active<S2SV_blank>map"" ) ; free ( map . active_map ) ; }
","<S2SV_ModStart> map = { 0 , 0 ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug>
679,CWE-362,"static bool add_free_nid ( struct f2fs_sb_info * sbi , nid_t nid , bool build ) { struct f2fs_nm_info * nm_i = NM_I ( sbi ) ; struct free_nid * i ; struct nat_entry * ne ; int err ; if ( unlikely ( nid == 0 ) ) return false ; if ( build ) { ne = __lookup_nat_cache ( nm_i , nid ) ; if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) ) return false ; } i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } spin_lock ( & nm_i -> nid_list_lock ) ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; if ( err ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } return true ; }
","<S2SV_ModStart> free_nid * i , * e <S2SV_ModStart> ; int err = - EINVAL ; bool ret = false <S2SV_ModStart> return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/30a61ddf8117c26ac5b295e1233eaa9629a94ca3,CVE-2017-18249,https://github.com/torvalds/linux/commit/30a61ddf8117c26ac5b295e1233eaa9629a94ca3,2018-03-26T20:29Z,<S2SV_StartBug> struct free_nid * i ; <S2SV_EndBug> <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( build ) { <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug>
2152,CWE-190,"static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) { unsigned char * buf ; assert ( bufsize >= 0 ) ; JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\n"" , m , bufsize ) ) ; if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) { JAS_DBGLOG ( 100 , ( ""mem_resize<S2SV_blank>realloc<S2SV_blank>failed\\n"" ) ) ; return - 1 ; } JAS_DBGLOG ( 100 , ( ""mem_resize<S2SV_blank>realloc<S2SV_blank>succeeded\\n"" ) ) ; m -> buf_ = buf ; m -> bufsize_ = bufsize ; return 0 ; }
","<S2SV_ModStart> * m , size_t <S2SV_ModEnd> bufsize ) { <S2SV_ModStart> * buf ; <S2SV_ModEnd> JAS_DBGLOG ( 100 <S2SV_ModStart> 100 , ( ""mem_resize(%p,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> , m , <S2SV_ModStart> ) ) ; if ( ! bufsize ) { jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\n"" ""This<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work.\\n"" ) ; }
",mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,CVE-2016-9262,https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,2017-03-23T18:59Z,"<S2SV_StartBug> static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) <S2SV_EndBug> <S2SV_StartBug> assert ( bufsize >= 0 ) ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\n"" , m , bufsize ) ) ; <S2SV_EndBug>"
4102,CWE-119,"static krb5_error_code get_matching_data ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , X509 * cert , pkinit_cert_matching_data * * md_out ) { krb5_error_code ret = ENOMEM ; pkinit_cert_matching_data * md = NULL ; krb5_principal * pkinit_sans = NULL , * upn_sans = NULL ; size_t i , j ; char buf [ DN_BUF_LEN ] ; unsigned int bufsize = sizeof ( buf ) ; * md_out = NULL ; md = calloc ( 1 , sizeof ( * md ) ) ; if ( md == NULL ) goto cleanup ; X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize , XN_FLAG_SEP_COMMA_PLUS ) ; md -> subject_dn = strdup ( buf ) ; if ( md -> subject_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize , XN_FLAG_SEP_COMMA_PLUS ) ; md -> issuer_dn = strdup ( buf ) ; if ( md -> issuer_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } ret = crypto_retrieve_X509_sans ( context , plg_cryptoctx , req_cryptoctx , cert , & pkinit_sans , & upn_sans , NULL ) ; if ( ret ) goto cleanup ; j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( j != 0 ) { md -> sans = calloc ( ( size_t ) j + 1 , sizeof ( * md -> sans ) ) ; if ( md -> sans == NULL ) { ret = ENOMEM ; goto cleanup ; } j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = pkinit_sans [ i ] ; free ( pkinit_sans ) ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = upn_sans [ i ] ; free ( upn_sans ) ; } md -> sans [ j ] = NULL ; } else md -> sans = NULL ; ret = crypto_retrieve_X509_key_usage ( context , plg_cryptoctx , req_cryptoctx , cert , & md -> ku_bits , & md -> eku_bits ) ; if ( ret ) goto cleanup ; * md_out = md ; md = NULL ; cleanup : crypto_cert_free_matching_data ( context , md ) ; return ret ; }
","<S2SV_ModStart> , j ; * md_out = NULL ; md = calloc ( 1 , sizeof ( <S2SV_ModEnd> * md ) <S2SV_ModStart> goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_subject_name ( <S2SV_ModStart> cert ) , & <S2SV_ModEnd> md -> subject_dn <S2SV_ModStart> md -> subject_dn ) ; if ( ret ) goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_issuer_name ( <S2SV_ModStart> cert ) , & <S2SV_ModEnd> md -> issuer_dn <S2SV_ModStart> md -> issuer_dn ) ; if ( ret ) goto cleanup ; <S2SV_ModEnd> ret = crypto_retrieve_X509_sans
",krb5@krb5/fbb687db1088ddd894d975996e5f6a4252b9a2b4,CVE-2017-15088,https://github.com/krb5/krb5/commit/fbb687db1088ddd894d975996e5f6a4252b9a2b4,2017-11-23T17:29Z,"<S2SV_StartBug> char buf [ DN_BUF_LEN ] ; <S2SV_EndBug> <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize , <S2SV_EndBug> <S2SV_StartBug> md -> subject_dn = strdup ( buf ) ; <S2SV_EndBug> <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize , <S2SV_EndBug> <S2SV_StartBug> md -> issuer_dn = strdup ( buf ) ; <S2SV_EndBug>"
1427,CWE-119,"static void find_next_key_frame ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame ) { int i , j ; FIRSTPASS_STATS last_frame ; FIRSTPASS_STATS first_frame ; FIRSTPASS_STATS next_frame ; FIRSTPASS_STATS * start_position ; double decay_accumulator = 1.0 ; double boost_score = 0 ; double old_boost_score = 0.0 ; double loop_decay_rate ; double kf_mod_err = 0.0 ; double kf_group_err = 0.0 ; double kf_group_intra_err = 0.0 ; double kf_group_coded_err = 0.0 ; double recent_loop_decay [ 8 ] = { 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 } ; vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; vp8_clear_system_state ( ) ; start_position = cpi -> twopass . stats_in ; cpi -> common . frame_type = KEY_FRAME ; cpi -> this_key_frame_forced = cpi -> next_key_frame_forced ; cpi -> source_alt_ref_active = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> twopass . frames_to_key = 1 ; vpx_memcpy ( & first_frame , this_frame , sizeof ( * this_frame ) ) ; cpi -> twopass . kf_group_bits = 0 ; cpi -> twopass . kf_group_error_left = 0 ; kf_mod_err = calculate_modified_err ( cpi , this_frame ) ; i = 0 ; while ( cpi -> twopass . stats_in < cpi -> twopass . stats_in_end ) { kf_group_err += calculate_modified_err ( cpi , this_frame ) ; kf_group_intra_err += this_frame -> intra_error ; kf_group_coded_err += this_frame -> coded_error ; vpx_memcpy ( & last_frame , this_frame , sizeof ( * this_frame ) ) ; input_stats ( cpi , this_frame ) ; if ( cpi -> oxcf . auto_key && lookup_next_frame_stats ( cpi , & next_frame ) != EOF ) { if ( ( i >= MIN_GF_INTERVAL ) && test_candidate_kf ( cpi , & last_frame , this_frame , & next_frame ) ) { break ; } loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; recent_loop_decay [ i % 8 ] = loop_decay_rate ; decay_accumulator = 1.0 ; for ( j = 0 ; j < 8 ; j ++ ) { decay_accumulator = decay_accumulator * recent_loop_decay [ j ] ; } if ( detect_transition_to_still ( cpi , i , ( cpi -> key_frame_frequency - i ) , loop_decay_rate , decay_accumulator ) ) { break ; } cpi -> twopass . frames_to_key ++ ; if ( cpi -> twopass . frames_to_key >= 2 * ( int ) cpi -> key_frame_frequency ) break ; } else cpi -> twopass . frames_to_key ++ ; i ++ ; } if ( cpi -> oxcf . auto_key && cpi -> twopass . frames_to_key > ( int ) cpi -> key_frame_frequency ) { FIRSTPASS_STATS * current_pos = cpi -> twopass . stats_in ; FIRSTPASS_STATS tmp_frame ; cpi -> twopass . frames_to_key /= 2 ; vpx_memcpy ( & tmp_frame , & first_frame , sizeof ( first_frame ) ) ; reset_fpf_position ( cpi , start_position ) ; kf_group_err = 0 ; kf_group_intra_err = 0 ; kf_group_coded_err = 0 ; for ( i = 0 ; i < cpi -> twopass . frames_to_key ; i ++ ) { kf_group_err += calculate_modified_err ( cpi , & tmp_frame ) ; kf_group_intra_err += tmp_frame . intra_error ; kf_group_coded_err += tmp_frame . coded_error ; input_stats ( cpi , & tmp_frame ) ; } reset_fpf_position ( cpi , current_pos ) ; cpi -> next_key_frame_forced = 1 ; } else cpi -> next_key_frame_forced = 0 ; if ( cpi -> twopass . stats_in >= cpi -> twopass . stats_in_end ) { kf_group_err += calculate_modified_err ( cpi , this_frame ) ; kf_group_intra_err += this_frame -> intra_error ; kf_group_coded_err += this_frame -> coded_error ; } if ( ( cpi -> twopass . bits_left > 0 ) && ( cpi -> twopass . modified_error_left > 0.0 ) ) { int max_bits = frame_max_bits ( cpi ) ; int64_t max_grp_bits ; cpi -> twopass . kf_group_bits = ( int64_t ) ( cpi -> twopass . bits_left * ( kf_group_err / cpi -> twopass . modified_error_left ) ) ; max_grp_bits = ( int64_t ) max_bits * ( int64_t ) cpi -> twopass . frames_to_key ; if ( cpi -> twopass . kf_group_bits > max_grp_bits ) cpi -> twopass . kf_group_bits = max_grp_bits ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { int64_t opt_buffer_lvl = cpi -> oxcf . optimal_buffer_level ; int64_t buffer_lvl = cpi -> buffer_level ; if ( buffer_lvl >= opt_buffer_lvl ) { int64_t high_water_mark = ( opt_buffer_lvl + cpi -> oxcf . maximum_buffer_size ) >> 1 ; int64_t av_group_bits ; av_group_bits = ( int64_t ) cpi -> av_per_frame_bandwidth * ( int64_t ) cpi -> twopass . frames_to_key ; if ( cpi -> buffer_level >= high_water_mark ) { int64_t min_group_bits ; min_group_bits = av_group_bits + ( int64_t ) ( buffer_lvl - high_water_mark ) ; if ( cpi -> twopass . kf_group_bits < min_group_bits ) cpi -> twopass . kf_group_bits = min_group_bits ; } else if ( cpi -> twopass . kf_group_bits < av_group_bits ) { int64_t bits_below_av = av_group_bits - cpi -> twopass . kf_group_bits ; cpi -> twopass . kf_group_bits += ( int64_t ) ( ( double ) bits_below_av * ( double ) ( buffer_lvl - opt_buffer_lvl ) / ( double ) ( high_water_mark - opt_buffer_lvl ) ) ; } } } } else cpi -> twopass . kf_group_bits = 0 ; reset_fpf_position ( cpi , start_position ) ; decay_accumulator = 1.0 ; boost_score = 0.0 ; loop_decay_rate = 1.00 ; for ( i = 0 ; i < cpi -> twopass . frames_to_key ; i ++ ) { double r ; if ( EOF == input_stats ( cpi , & next_frame ) ) break ; if ( next_frame . intra_error > cpi -> twopass . kf_intra_err_min ) r = ( IIKFACTOR2 * next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; else r = ( IIKFACTOR2 * cpi -> twopass . kf_intra_err_min / DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; if ( r > RMAX ) r = RMAX ; loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; decay_accumulator = decay_accumulator * loop_decay_rate ; decay_accumulator = decay_accumulator < 0.1 ? 0.1 : decay_accumulator ; boost_score += ( decay_accumulator * r ) ; if ( ( i > MIN_GF_INTERVAL ) && ( ( boost_score - old_boost_score ) < 1.0 ) ) { break ; } old_boost_score = boost_score ; } if ( 1 ) { FIRSTPASS_STATS sectionstats ; double Ratio ; zero_stats ( & sectionstats ) ; reset_fpf_position ( cpi , start_position ) ; for ( i = 0 ; i < cpi -> twopass . frames_to_key ; i ++ ) { input_stats ( cpi , & next_frame ) ; accumulate_stats ( & sectionstats , & next_frame ) ; } avg_stats ( & sectionstats ) ; cpi -> twopass . section_intra_rating = ( unsigned int ) ( sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; Ratio = sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ; cpi -> twopass . section_max_qfactor = 1.0 - ( ( Ratio - 10.0 ) * 0.025 ) ; if ( cpi -> twopass . section_max_qfactor < 0.80 ) cpi -> twopass . section_max_qfactor = 0.80 ; } if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { double max_boost ; if ( cpi -> drop_frames_allowed ) { int df_buffer_level = ( int ) ( cpi -> oxcf . drop_frames_water_mark * ( cpi -> oxcf . optimal_buffer_level / 100 ) ) ; if ( cpi -> buffer_level > df_buffer_level ) max_boost = ( ( double ) ( ( cpi -> buffer_level - df_buffer_level ) * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; else max_boost = 0.0 ; } else if ( cpi -> buffer_level > 0 ) { max_boost = ( ( double ) ( cpi -> buffer_level * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; } else { max_boost = 0.0 ; } if ( boost_score > max_boost ) boost_score = max_boost ; } reset_fpf_position ( cpi , start_position ) ; if ( 1 ) { int kf_boost = ( int ) boost_score ; int allocation_chunks ; int Counter = cpi -> twopass . frames_to_key ; int alt_kf_bits ; YV12_BUFFER_CONFIG * lst_yv12 = & cpi -> common . yv12_fb [ cpi -> common . lst_fb_idx ] ; # if 0 while ( ( kf_boost < 48 ) && ( Counter > 0 ) ) { Counter -= 2 ; kf_boost ++ ; } # endif if ( kf_boost < 48 ) { kf_boost += ( ( Counter + 1 ) >> 1 ) ; if ( kf_boost > 48 ) kf_boost = 48 ; } if ( ( lst_yv12 -> y_width * lst_yv12 -> y_height ) > ( 320 * 240 ) ) kf_boost += 2 * ( lst_yv12 -> y_width * lst_yv12 -> y_height ) / ( 320 * 240 ) ; else if ( ( lst_yv12 -> y_width * lst_yv12 -> y_height ) < ( 320 * 240 ) ) kf_boost -= 4 * ( 320 * 240 ) / ( lst_yv12 -> y_width * lst_yv12 -> y_height ) ; kf_boost = ( int ) ( ( double ) kf_boost * 100.0 ) >> 4 ; if ( kf_boost < 250 ) kf_boost = 250 ; if ( decay_accumulator >= 0.99 ) { allocation_chunks = ( ( cpi -> twopass . frames_to_key - 1 ) * 10 ) + kf_boost ; } else { allocation_chunks = ( ( cpi -> twopass . frames_to_key - 1 ) * 100 ) + kf_boost ; } while ( kf_boost > 1000 ) { kf_boost /= 2 ; allocation_chunks /= 2 ; } cpi -> twopass . kf_group_bits = ( cpi -> twopass . kf_group_bits < 0 ) ? 0 : cpi -> twopass . kf_group_bits ; cpi -> twopass . kf_bits = ( int ) ( ( double ) kf_boost * ( ( double ) cpi -> twopass . kf_group_bits / ( double ) allocation_chunks ) ) ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { if ( cpi -> twopass . kf_bits > ( int ) ( ( 3 * cpi -> buffer_level ) >> 2 ) ) cpi -> twopass . kf_bits = ( int ) ( ( 3 * cpi -> buffer_level ) >> 2 ) ; } if ( kf_mod_err < kf_group_err / cpi -> twopass . frames_to_key ) { double alt_kf_grp_bits = ( ( double ) cpi -> twopass . bits_left * ( kf_mod_err * ( double ) cpi -> twopass . frames_to_key ) / DOUBLE_DIVIDE_CHECK ( cpi -> twopass . modified_error_left ) ) ; alt_kf_bits = ( int ) ( ( double ) kf_boost * ( alt_kf_grp_bits / ( double ) allocation_chunks ) ) ; if ( cpi -> twopass . kf_bits > alt_kf_bits ) { cpi -> twopass . kf_bits = alt_kf_bits ; } } else { alt_kf_bits = ( int ) ( ( double ) cpi -> twopass . bits_left * ( kf_mod_err / DOUBLE_DIVIDE_CHECK ( cpi -> twopass . modified_error_left ) ) ) ; if ( alt_kf_bits > cpi -> twopass . kf_bits ) { cpi -> twopass . kf_bits = alt_kf_bits ; } } cpi -> twopass . kf_group_bits -= cpi -> twopass . kf_bits ; cpi -> twopass . kf_bits += cpi -> min_frame_bandwidth ; cpi -> per_frame_bandwidth = cpi -> twopass . kf_bits ; cpi -> target_bandwidth = ( int ) ( cpi -> twopass . kf_bits * cpi -> output_framerate ) ; } cpi -> twopass . kf_group_error_left = ( int ) ( kf_group_err - kf_mod_err ) ; cpi -> twopass . modified_error_left -= kf_group_err ; if ( cpi -> oxcf . allow_spatial_resampling ) { int resample_trigger = 0 ; int last_kf_resampled = 0 ; int kf_q ; int scale_val = 0 ; int hr , hs , vr , vs ; int new_width = cpi -> oxcf . Width ; int new_height = cpi -> oxcf . Height ; int projected_buffer_level = ( int ) cpi -> buffer_level ; int tmp_q ; double projected_bits_perframe ; double group_iiratio = ( kf_group_intra_err - first_frame . intra_error ) / ( kf_group_coded_err - first_frame . coded_error ) ; double err_per_frame = kf_group_err / cpi -> twopass . frames_to_key ; double bits_per_frame ; double av_bits_per_frame ; double effective_size_ratio ; if ( ( cpi -> common . Width != cpi -> oxcf . Width ) || ( cpi -> common . Height != cpi -> oxcf . Height ) ) last_kf_resampled = 1 ; cpi -> common . horiz_scale = NORMAL ; cpi -> common . vert_scale = NORMAL ; av_bits_per_frame = cpi -> oxcf . target_bandwidth / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> framerate ) ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { bits_per_frame = av_bits_per_frame ; } else { bits_per_frame = ( double ) ( cpi -> twopass . kf_group_bits / cpi -> twopass . frames_to_key ) ; if ( bits_per_frame < av_bits_per_frame ) bits_per_frame = av_bits_per_frame ; } if ( bits_per_frame < ( cpi -> oxcf . target_bandwidth * cpi -> oxcf . two_pass_vbrmin_section / 100 ) ) bits_per_frame = ( cpi -> oxcf . target_bandwidth * cpi -> oxcf . two_pass_vbrmin_section / 100 ) ; kf_q = estimate_kf_group_q ( cpi , err_per_frame , ( int ) bits_per_frame , group_iiratio ) ; projected_bits_perframe = bits_per_frame ; tmp_q = kf_q ; while ( tmp_q > cpi -> worst_quality ) { projected_bits_perframe *= 1.04 ; tmp_q -- ; } projected_buffer_level = ( int ) ( cpi -> buffer_level - ( int ) ( ( projected_bits_perframe - av_bits_per_frame ) * cpi -> twopass . frames_to_key ) ) ; if ( 0 ) { FILE * f = fopen ( ""Subsamle.stt"" , ""a"" ) ; fprintf ( f , ""<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%12.0f<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d\\n"" , cpi -> common . current_video_frame , kf_q , cpi -> common . horiz_scale , cpi -> common . vert_scale , kf_group_err / cpi -> twopass . frames_to_key , ( int ) ( cpi -> twopass . kf_group_bits / cpi -> twopass . frames_to_key ) , new_height , new_width ) ; fclose ( f ) ; } if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { if ( ( projected_buffer_level < ( cpi -> oxcf . resample_down_water_mark * cpi -> oxcf . optimal_buffer_level / 100 ) ) || ( last_kf_resampled && ( projected_buffer_level < ( cpi -> oxcf . resample_up_water_mark * cpi -> oxcf . optimal_buffer_level / 100 ) ) ) ) resample_trigger = 1 ; else resample_trigger = 0 ; } else { int64_t clip_bits = ( int64_t ) ( cpi -> twopass . total_stats . count * cpi -> oxcf . target_bandwidth / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> framerate ) ) ; int64_t over_spend = cpi -> oxcf . starting_buffer_level - cpi -> buffer_level ; if ( ( last_kf_resampled && ( kf_q > cpi -> worst_quality ) ) || ( ( kf_q > cpi -> worst_quality ) && ( over_spend > clip_bits / 20 ) ) ) resample_trigger = 1 ; else resample_trigger = 0 ; } if ( resample_trigger ) { while ( ( kf_q >= cpi -> worst_quality ) && ( scale_val < 6 ) ) { scale_val ++ ; cpi -> common . vert_scale = vscale_lookup [ scale_val ] ; cpi -> common . horiz_scale = hscale_lookup [ scale_val ] ; Scale2Ratio ( cpi -> common . horiz_scale , & hr , & hs ) ; Scale2Ratio ( cpi -> common . vert_scale , & vr , & vs ) ; new_width = ( ( hs - 1 ) + ( cpi -> oxcf . Width * hr ) ) / hs ; new_height = ( ( vs - 1 ) + ( cpi -> oxcf . Height * vr ) ) / vs ; effective_size_ratio = ( double ) ( new_width * new_height ) / ( double ) ( cpi -> oxcf . Width * cpi -> oxcf . Height ) ; effective_size_ratio = ( 1.0 + ( 3.0 * effective_size_ratio ) ) / 4.0 ; kf_q = estimate_kf_group_q ( cpi , err_per_frame * effective_size_ratio , ( int ) bits_per_frame , group_iiratio ) ; if ( 0 ) { FILE * f = fopen ( ""Subsamle.stt"" , ""a"" ) ; fprintf ( f , ""********<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%12.0f<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d\\n"" , kf_q , cpi -> common . horiz_scale , cpi -> common . vert_scale , kf_group_err / cpi -> twopass . frames_to_key , ( int ) ( cpi -> twopass . kf_group_bits / cpi -> twopass . frames_to_key ) , new_height , new_width ) ; fclose ( f ) ; } } } if ( ( cpi -> common . Width != new_width ) || ( cpi -> common . Height != new_height ) ) { cpi -> common . Width = new_width ; cpi -> common . Height = new_height ; vp8_alloc_compressor_data ( cpi ) ; } } }
","<S2SV_ModStart> 1.0 } ; memset <S2SV_ModEnd> ( & next_frame <S2SV_ModStart> = 1 ; memcpy <S2SV_ModEnd> ( & first_frame <S2SV_ModStart> -> coded_error ; memcpy <S2SV_ModEnd> ( & last_frame <S2SV_ModStart> /= 2 ; memcpy <S2SV_ModEnd> ( & tmp_frame <S2SV_ModStart> boost_score = 0.0 <S2SV_ModEnd> ; for ( <S2SV_ModStart> ; int projected_buffer_level <S2SV_ModEnd> ; int tmp_q
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & first_frame , this_frame , sizeof ( * this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & last_frame , this_frame , sizeof ( * this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & tmp_frame , & first_frame , sizeof ( first_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> boost_score = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> int projected_buffer_level = ( int ) cpi -> buffer_level ; <S2SV_EndBug>"
3256,CWE-119,"static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; } switch ( sun_info . maptype ) { case RMT_NONE : { if ( sun_info . depth < 24 ) { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ; image -> <S2SV_ModEnd> colors = sun_info <S2SV_ModStart> / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_ModStart> maptype ) { <S2SV_ModEnd> case RMT_EQUAL_RGB : <S2SV_ModStart> char * sun_colormap <S2SV_ModEnd> ; sun_colormap =
",ImageMagick@ImageMagick/bd96074b254c6607a0f7731e59f923ad19d5a46d,CVE-2015-8957,https://github.com/ImageMagick/ImageMagick/commit/bd96074b254c6607a0f7731e59f923ad19d5a46d,2017-04-20T18:59Z,<S2SV_StartBug> image -> storage_class = PseudoClass ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> case RMT_NONE : <S2SV_EndBug> <S2SV_StartBug> * sun_colormap ; <S2SV_EndBug>
4444,CWE-401,"struct resource_pool * dcn10_create_resource_pool ( const struct dc_init_data * init_data , struct dc * dc ) { struct dcn10_resource_pool * pool = kzalloc ( sizeof ( struct dcn10_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( init_data -> num_virtual_links , dc , pool ) ) return & pool -> base ; BREAK_TO_DEBUGGER ( ) ; return NULL ; }
","<S2SV_ModStart> -> base ; kfree ( pool ) ;
",torvalds@linux/104c307147ad379617472dd91a5bcb368d72bd6d,CVE-2019-19082,https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d,2019-11-18T06:15Z,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug>
1555,CWE-119,"void vp9_iht4x4_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , int stride , int eob ) { if ( tx_type == DCT_DCT ) vp9_idct4x4_add ( input , dest , stride , eob ) ; else vp9_iht4x4_16_add ( input , dest , stride , tx_type ) ; }
","<S2SV_ModStart> tx_type , const tran_low_t <S2SV_ModEnd> * input ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> void vp9_iht4x4_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug>"
7772,CWE-125,"stmt_ty AsyncFunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq * decorator_list , expr_ty returns , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! name ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>name<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFunctionDef"" ) ; return NULL ; } if ( ! args ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>args<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFunctionDef"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFunctionDef_kind ; p -> v . AsyncFunctionDef . name = name ; p -> v . AsyncFunctionDef . args = args ; p -> v . AsyncFunctionDef . body = body ; p -> v . AsyncFunctionDef . decorator_list = decorator_list ; p -> v . AsyncFunctionDef . returns = returns ; p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
","<S2SV_ModStart> expr_ty returns , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> returns = returns ; p -> v . AsyncFunctionDef . type_comment = type_comment
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> * decorator_list , expr_ty returns , int lineno , int col_offset , <S2SV_EndBug> <S2SV_StartBug> p -> v . AsyncFunctionDef . returns = returns ; <S2SV_EndBug>"
3573,CWE-20,"static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent . first == ( u32 ) - 1 ) || ( extent . lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent . first + extent . count ) <= extent . first ) goto out ; if ( ( extent . lower_first + extent . count ) <= extent . lower_first ) goto out ; if ( mappings_overlap ( & new_map , & extent ) ) goto out ; if ( ( new_map . nr_extents + 1 ) == UID_GID_MAP_MAX_EXTENTS && ( next_line != NULL ) ) goto out ; ret = insert_extent ( & new_map , & extent ) ; if ( ret < 0 ) goto out ; ret = - EINVAL ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ; if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) goto out ; ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ret = - EPERM ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { struct uid_gid_extent * e ; u32 lower_first ; if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) e = & new_map . extent [ idx ] ; else e = & new_map . forward [ idx ] ; lower_first = map_id_range_down ( parent_map , e -> lower_first , e -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; e -> lower_first = lower_first ; } if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; } else { map -> forward = new_map . forward ; map -> reverse = new_map . reverse ; } smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : if ( ret < 0 && new_map . nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS ) { kfree ( new_map . forward ) ; kfree ( new_map . reverse ) ; map -> forward = NULL ; map -> reverse = NULL ; map -> nr_extents = 0 ; } mutex_unlock ( & userns_state_mutex ) ; kfree ( kbuf ) ; return ret ; }
","<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
",torvalds@linux/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,CVE-2018-18955,https://github.com/torvalds/linux/commit/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,2018-11-16T20:29Z,"<S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug>"
5470,CWE-362,"int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick ) { int got_error ; uint i , key , total_key_length , istep ; ulong rec_length ; ha_rows start_records ; my_off_t new_header_length , del ; File new_file ; MI_SORT_PARAM * sort_param = 0 ; MYISAM_SHARE * share = info -> s ; ulong * rec_per_key_part ; HA_KEYSEG * keyseg ; char llbuff [ 22 ] ; IO_CACHE new_data_cache ; IO_CACHE_SHARE io_share ; SORT_INFO sort_info ; ulonglong UNINIT_VAR ( key_map ) ; pthread_attr_t thr_attr ; ulong max_pack_reclength ; int error ; DBUG_ENTER ( ""mi_repair_parallel"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-<S2SV_blank>parallel<S2SV_blank>recovering<S2SV_blank>(with<S2SV_blank>sort)<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; DBUG_PRINT ( ""info"" , ( ""is<S2SV_blank>quick<S2SV_blank>repair:<S2SV_blank>%d"" , rep_quick ) ) ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; mysql_mutex_init ( mi_key_mutex_MI_SORT_INFO_mutex , & sort_info . mutex , MY_MUTEX_INIT_FAST ) ; mysql_cond_init ( mi_key_cond_MI_SORT_INFO_cond , & sort_info . cond , 0 ) ; mysql_mutex_init ( mi_key_mutex_MI_CHECK_print_msg , & param -> print_msg_mutex , MY_MUTEX_INIT_FAST ) ; param -> need_print_msg_lock = 1 ; if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && ( init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) || init_io_cache ( & new_data_cache , - 1 , ( uint ) param -> write_buffer_length , READ_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_DONT_CHECK_FILESIZE ) ) ) ) ) goto err ; sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ; info -> opt_flag |= WRITE_CACHE_USED ; info -> rec_cache . file = info -> dfile ; if ( ! rep_quick ) { if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; goto err ; } if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ; if ( param -> testflag & T_UNPACK ) { share -> options &= ~ HA_OPTION_COMPRESS_RECORD ; mi_int2store ( share -> state . header . options , share -> options ) ; } share -> state . dellink = HA_OFFSET_ERROR ; info -> rec_cache . file = new_file ; } info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; mi_drop_all_indexes ( param , info , FALSE ) ; key_map = share -> state . key_map ; if ( param -> testflag & T_CREATE_MISSING_KEYS ) { key_map = ~ key_map ; } sort_info . info = info ; sort_info . param = param ; set_data_file_type ( & sort_info , share ) ; sort_info . dupp = 0 ; sort_info . buff = 0 ; param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ; if ( share -> data_file_type == DYNAMIC_RECORD ) rec_length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ; else if ( share -> data_file_type == COMPRESSED_RECORD ) rec_length = share -> base . min_block_length ; else rec_length = share -> base . pack_reclength ; sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records + 1 : ( ha_rows ) ( sort_info . filelength / rec_length + 1 ) ) ; del = info -> state -> del ; param -> glob_crc = 0 ; max_pack_reclength = share -> base . pack_reclength ; if ( share -> options & HA_OPTION_COMPRESS_RECORD ) set_if_bigger ( max_pack_reclength , share -> max_pack_length ) ; if ( ! ( sort_param = ( MI_SORT_PARAM * ) my_malloc ( ( uint ) share -> base . keys * ( sizeof ( MI_SORT_PARAM ) + max_pack_reclength ) , MYF ( MY_ZEROFILL ) ) ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>key!"" ) ; goto err ; } total_key_length = 0 ; rec_per_key_part = param -> rec_per_key_part ; info -> state -> records = info -> state -> del = share -> state . split = 0 ; info -> state -> empty = 0 ; for ( i = key = 0 , istep = 1 ; key < share -> base . keys ; rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) { sort_param [ i ] . key = key ; sort_param [ i ] . keyinfo = share -> keyinfo + key ; sort_param [ i ] . seg = sort_param [ i ] . keyinfo -> seg ; if ( ! mi_is_key_active ( key_map , key ) ) { memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ; istep = 0 ; continue ; } istep = 1 ; if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\n"" , key + 1 ) ; if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) { sort_param [ i ] . key_read = sort_ft_key_read ; sort_param [ i ] . key_write = sort_ft_key_write ; } else { sort_param [ i ] . key_read = sort_key_read ; sort_param [ i ] . key_write = sort_key_write ; } sort_param [ i ] . key_cmp = sort_key_cmp ; sort_param [ i ] . lock_in_memory = lock_memory ; sort_param [ i ] . tmpdir = param -> tmpdir ; sort_param [ i ] . sort_info = & sort_info ; sort_param [ i ] . master = 0 ; sort_param [ i ] . fix_datafile = 0 ; sort_param [ i ] . calc_checksum = 0 ; sort_param [ i ] . filepos = new_header_length ; sort_param [ i ] . max_pos = sort_param [ i ] . pos = share -> pack . header_length ; sort_param [ i ] . record = ( ( ( uchar * ) ( sort_param + share -> base . keys ) ) + ( max_pack_reclength * i ) ) ; if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param [ i ] . rec_buff ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory!"" ) ; goto err ; } sort_param [ i ] . key_length = share -> rec_reflength ; for ( keyseg = sort_param [ i ] . seg ; keyseg -> type != HA_KEYTYPE_END ; keyseg ++ ) { sort_param [ i ] . key_length += keyseg -> length ; if ( keyseg -> flag & HA_SPACE_PACK ) sort_param [ i ] . key_length += get_pack_length ( keyseg -> length ) ; if ( keyseg -> flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param [ i ] . key_length += 2 + test ( keyseg -> length >= 127 ) ; if ( keyseg -> flag & HA_NULL_PART ) sort_param [ i ] . key_length ++ ; } total_key_length += sort_param [ i ] . key_length ; if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) { uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param [ i ] . keyinfo -> seg -> charset -> mbmaxlen ; sort_param [ i ] . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ; init_alloc_root ( & sort_param [ i ] . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ; } } sort_info . total_keys = i ; sort_param [ 0 ] . master = 1 ; sort_param [ 0 ] . fix_datafile = ( my_bool ) ( ! rep_quick ) ; sort_param [ 0 ] . calc_checksum = test ( param -> testflag & T_CALC_CHECKSUM ) ; if ( ! ftparser_alloc_param ( info ) ) goto err ; sort_info . got_error = 0 ; mysql_mutex_lock ( & sort_info . mutex ) ; if ( i > 1 ) { if ( rep_quick ) init_io_cache_share ( & param -> read_cache , & io_share , NULL , i ) ; else init_io_cache_share ( & new_data_cache , & io_share , & info -> rec_cache , i ) ; } else io_share . total_threads = 0 ; ( void ) pthread_attr_init ( & thr_attr ) ; ( void ) pthread_attr_setdetachstate ( & thr_attr , PTHREAD_CREATE_DETACHED ) ; for ( i = 0 ; i < sort_info . total_keys ; i ++ ) { sort_param [ i ] . read_cache = ( ( rep_quick || ! i ) ? param -> read_cache : new_data_cache ) ; DBUG_PRINT ( ""io_cache_share"" , ( ""thread:<S2SV_blank>%u<S2SV_blank><S2SV_blank>read_cache:<S2SV_blank>0x%lx"" , i , ( long ) & sort_param [ i ] . read_cache ) ) ; sort_param [ i ] . sortbuff_size = # ifndef USING_SECOND_APPROACH param -> sort_buffer_length / sort_info . total_keys ; # else param -> sort_buffer_length * sort_param [ i ] . key_length / total_key_length ; # endif if ( ( error = mysql_thread_create ( mi_key_thread_find_all_keys , & sort_param [ i ] . thr , & thr_attr , thr_find_all_keys , ( void * ) ( sort_param + i ) ) ) ) { mi_check_print_error ( param , ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread<S2SV_blank>(errno=<S2SV_blank>%d)"" , error ) ; if ( io_share . total_threads ) remove_io_thread ( & sort_param [ i ] . read_cache ) ; DBUG_PRINT ( ""error"" , ( ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread"" ) ) ; sort_info . got_error = 1 ; } else sort_info . threads_running ++ ; } ( void ) pthread_attr_destroy ( & thr_attr ) ; while ( sort_info . threads_running ) mysql_cond_wait ( & sort_info . cond , & sort_info . mutex ) ; mysql_mutex_unlock ( & sort_info . mutex ) ; if ( ( got_error = thr_write_keys ( sort_param ) ) ) { param -> retry_repair = 1 ; goto err ; } got_error = 1 ; if ( sort_param [ 0 ] . fix_datafile ) { if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ; if ( param -> testflag & T_SAFE_REPAIR ) { if ( info -> state -> records + 1 < start_records ) { info -> state -> records = start_records ; goto err ; } } share -> state . state . data_file_length = info -> state -> data_file_length = sort_param -> filepos ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; mysql_file_close ( info -> dfile , MYF ( 0 ) ) ; info -> dfile = new_file ; share -> data_file_type = sort_info . new_data_file_type ; share -> pack . header_length = ( ulong ) new_header_length ; } else info -> state -> data_file_length = sort_param -> max_pos ; if ( rep_quick && del + sort_info . dupp != info -> state -> del ) { mi_check_print_error ( param , ""Couldn\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ; mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ; param -> retry_repair = 1 ; param -> testflag |= T_RETRY_WITHOUT_QUICK ; goto err ; } if ( rep_quick & T_FORCE_UNIQUENESS ) { my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ; # ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ; # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; } if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ; if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; if ( ! ( param -> testflag & T_SILENT ) ) { if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ; } got_error = 0 ; if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ; err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & info -> rec_cache ) ; if ( ! rep_quick ) ( void ) end_io_cache ( & new_data_cache ) ; if ( ! got_error ) { if ( new_file >= 0 ) { mysql_file_close ( new_file , MYF ( 0 ) ) ; info -> dfile = new_file = - 1 ; if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ; } } if ( got_error ) { if ( ! param -> error_printed ) mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>fixing<S2SV_blank>table"" , my_errno ) ; if ( new_file >= 0 ) { ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ; ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ; } mi_mark_crashed_on_repair ( info ) ; } else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ STATE_NOT_OPTIMIZED_KEYS ; share -> state . changed |= STATE_NOT_SORTED_PAGES ; mysql_cond_destroy ( & sort_info . cond ) ; mysql_mutex_destroy ( & sort_info . mutex ) ; mysql_mutex_destroy ( & param -> print_msg_mutex ) ; param -> need_print_msg_lock = 0 ; my_free ( sort_info . ft_buf ) ; my_free ( sort_info . key_block ) ; my_free ( sort_param ) ; my_free ( sort_info . buff ) ; ( void ) end_io_cache ( & param -> read_cache ) ; info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ; if ( ! got_error && ( param -> testflag & T_UNPACK ) ) { share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ; share -> pack . header_length = 0 ; } DBUG_RETURN ( got_error ) ; }
","<S2SV_ModStart> , int rep_quick , my_bool no_copy_stat <S2SV_ModStart> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> , DATA_TMP_EXT , flags <S2SV_ModEnd> ) || mi_open_datafile
",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z,"<S2SV_StartBug> const char * name , int rep_quick ) <S2SV_EndBug> <S2SV_StartBug> mysql_file_close ( new_file , MYF ( 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( param -> testflag & T_BACKUP_DATA ? <S2SV_EndBug>"
2005,CWE-119,"void vp8_vertical_band_2_1_scale_c ( unsigned char * source , unsigned int src_pitch , unsigned char * dest , unsigned int dest_pitch , unsigned int dest_width ) { ( void ) dest_pitch ; ( void ) src_pitch ; vpx_memcpy ( dest , source , dest_width ) ; }
","<S2SV_ModStart> ) src_pitch ; memcpy <S2SV_ModEnd> ( dest ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( dest , source , dest_width ) ; <S2SV_EndBug>"
1526,CWE-119,"static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx , int ctr_id , va_list args ) { # if CONFIG_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; if ( data ) { ctx -> postproc_cfg_set = 1 ; ctx -> postproc_cfg = * ( ( vp8_postproc_cfg_t * ) data ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; # else return VPX_CODEC_INCAPABLE ; # endif }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args <S2SV_ModStart> ; # else ( void ) ctx ; ( void ) args ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug>"
3336,CWE-125,"static int dhcpv4_print ( netdissect_options * ndo , const u_char * cp , u_int length , int indent ) { u_int i , t ; const u_char * tlv , * value ; uint8_t type , optlen ; i = 0 ; while ( i < length ) { tlv = cp + i ; type = ( uint8_t ) tlv [ 0 ] ; optlen = ( uint8_t ) tlv [ 1 ] ; value = tlv + 2 ; ND_PRINT ( ( ndo , ""\\n"" ) ) ; for ( t = indent ; t > 0 ; t -- ) ND_PRINT ( ( ndo , ""\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( dh4opt_str , ""Unknown"" , type ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ; switch ( type ) { case DH4OPT_DNS_SERVERS : case DH4OPT_NTP_SERVERS : { if ( optlen < 4 || optlen % 4 != 0 ) { return - 1 ; } for ( t = 0 ; t < optlen ; t += 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , value + t ) ) ) ; } break ; case DH4OPT_DOMAIN_SEARCH : { const u_char * tp = value ; while ( tp < value + optlen ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , value + optlen ) ) == NULL ) return - 1 ; } } break ; } i += 2 + optlen ; } return 0 ; }
","<S2SV_ModStart> length ) { if ( i + 2 > length ) return - 1 ; <S2SV_ModStart> 2 ) ) ; if ( i + 2 + optlen > length ) return - 1
",the-tcpdump-group@tcpdump/c2f6833dddecf2d5fb89c9c898eee9981da342ed,CVE-2017-13044,https://github.com/the-tcpdump-group/tcpdump/commit/c2f6833dddecf2d5fb89c9c898eee9981da342ed,2017-09-14T06:29Z,"<S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ; <S2SV_EndBug>"
3278,CWE-125,"static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }
","<S2SV_ModStart> size_t ) ldblk + 1
",ImageMagick@ImageMagick/bef1e4f637d8f665bc133a9c6d30df08d983bc3a,CVE-2016-7533,https://github.com/ImageMagick/ImageMagick/commit/bef1e4f637d8f665bc133a9c6d30df08d983bc3a,2017-04-19T14:59Z,"<S2SV_StartBug> ldblk , sizeof ( * BImgBuff ) ) ; <S2SV_EndBug>"
2016,CWE-119,"int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) { int i ; struct ExternalFrameBufferList * const ext_fb_list = ( struct ExternalFrameBufferList * ) cb_priv ; if ( ext_fb_list == NULL ) return - 1 ; for ( i = 0 ; i < ext_fb_list -> num_external_frame_buffers ; ++ i ) { if ( ! ext_fb_list -> ext_fb [ i ] . in_use ) break ; } if ( i == ext_fb_list -> num_external_frame_buffers ) return - 1 ; if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) { free ( ext_fb_list -> ext_fb [ i ] . data ) ; ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ; if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ; ext_fb_list -> ext_fb [ i ] . size = min_size ; } fb -> data = ext_fb_list -> ext_fb [ i ] . data ; fb -> size = ext_fb_list -> ext_fb [ i ] . size ; ext_fb_list -> ext_fb [ i ] . in_use = 1 ; fb -> priv = & ext_fb_list -> ext_fb [ i ] ; return 0 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> uint8_t * ) calloc ( min_size , sizeof ( uint8_t ) <S2SV_ModEnd> ) ; if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , <S2SV_EndBug> <S2SV_StartBug> ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ; <S2SV_EndBug>"
4155,CWE-617,"static krb5_error_code kdc_process_for_user ( kdc_realm_t * kdc_active_realm , krb5_pa_data * pa_data , krb5_keyblock * tgs_session , krb5_pa_s4u_x509_user * * s4u_x509_user , const char * * status ) { krb5_error_code code ; krb5_pa_for_user * for_user ; krb5_data req_data ; req_data . length = pa_data -> length ; req_data . data = ( char * ) pa_data -> contents ; code = decode_krb5_pa_for_user ( & req_data , & for_user ) ; if ( code ) return code ; code = verify_for_user_checksum ( kdc_context , tgs_session , for_user ) ; if ( code ) { * status = ""INVALID_S4U2SELF_CHECKSUM"" ; krb5_free_pa_for_user ( kdc_context , for_user ) ; return code ; } * s4u_x509_user = calloc ( 1 , sizeof ( krb5_pa_s4u_x509_user ) ) ; if ( * s4u_x509_user == NULL ) { krb5_free_pa_for_user ( kdc_context , for_user ) ; return ENOMEM ; } ( * s4u_x509_user ) -> user_id . user = for_user -> user ; for_user -> user = NULL ; krb5_free_pa_for_user ( kdc_context , for_user ) ; return 0 ; }
","<S2SV_ModStart> ( code ) { * status = ""DECODE_PA_FOR_USER"" ; return code ; } <S2SV_ModEnd> code = verify_for_user_checksum
",krb5@krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970,CVE-2017-11368,https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970,2017-08-09T18:29Z,<S2SV_StartBug> return code ; <S2SV_EndBug>
233,CWE-399,"int ext4_orphan_del ( handle_t * handle , struct inode * inode ) { struct list_head * prev ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; struct ext4_sb_info * sbi ; __u32 ino_next ; struct ext4_iloc iloc ; int err = 0 ; if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) return 0 ; mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; if ( list_empty ( & ei -> i_orphan ) ) goto out ; ino_next = NEXT_ORPHAN ( inode ) ; prev = ei -> i_orphan . prev ; sbi = EXT4_SB ( inode -> i_sb ) ; jbd_debug ( 4 , ""remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\n"" , inode -> i_ino ) ; list_del_init ( & ei -> i_orphan ) ; if ( ! handle ) goto out ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_err ; if ( prev == & sbi -> s_orphan ) { jbd_debug ( 4 , ""superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , ino_next ) ; BUFFER_TRACE ( sbi -> s_sbh , ""get_write_access"" ) ; err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ; if ( err ) goto out_brelse ; sbi -> s_es -> s_last_orphan = cpu_to_le32 ( ino_next ) ; err = ext4_handle_dirty_super ( handle , inode -> i_sb ) ; } else { struct ext4_iloc iloc2 ; struct inode * i_prev = & list_entry ( prev , struct ext4_inode_info , i_orphan ) -> vfs_inode ; jbd_debug ( 4 , ""orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , i_prev -> i_ino , ino_next ) ; err = ext4_reserve_inode_write ( handle , i_prev , & iloc2 ) ; if ( err ) goto out_brelse ; NEXT_ORPHAN ( i_prev ) = ino_next ; err = ext4_mark_iloc_dirty ( handle , i_prev , & iloc2 ) ; } if ( err ) goto out_brelse ; NEXT_ORPHAN ( inode ) = 0 ; err = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; out_err : ext4_std_error ( inode -> i_sb , err ) ; out : mutex_unlock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; return err ; out_brelse : brelse ( iloc . bh ) ; goto out_err ; }
","<S2SV_ModStart> ; if ( ( <S2SV_ModStart> ) -> s_journal ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS )
",torvalds@linux/0e9a9a1ad619e7e987815d20262d36a2f95717ca,CVE-2013-2015,https://github.com/torvalds/linux/commit/0e9a9a1ad619e7e987815d20262d36a2f95717ca,2013-04-29T14:55Z,<S2SV_StartBug> if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) <S2SV_EndBug>
3433,CWE-125,"static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; ( void ) ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; viff_info . comment [ 511 ] = '\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ( int ) ReadBlobLong ( image ) ; viff_info . y_offset = ( int ) ReadBlobLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> matte = viff_info . number_data_bands == 4 ? MagickTrue : MagickFalse ; image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; else max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets , bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( MagickRealType ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( MagickRealType ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { if ( image -> storage_class != PseudoClass ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * ( p + number_pixels ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( q ) ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . red ) ; index = ( ssize_t ) GetPixelGreen ( q ) ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . green ) ; index = ( ssize_t ) GetPixelRed ( q ) ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . blue ) ; } SetPixelOpacity ( q , image -> matte != MagickFalse ? QuantumRange - ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueOpacity ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , <S2SV_ModEnd> bytes_per_pixel * sizeof
",ImageMagick@ImageMagick/ca0c886abd6d3ef335eb74150cd23b89ebd17135,CVE-2016-7528,https://github.com/ImageMagick/ImageMagick/commit/ca0c886abd6d3ef335eb74150cd23b89ebd17135,2017-04-19T14:59Z,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets , <S2SV_EndBug>"
210,CWE-787,"static pdf_creator_t * new_creator ( int * n_elements ) { pdf_creator_t * daddy ; static const pdf_creator_t creator_template [ ] = { { ""Title"" , """" } , { ""Author"" , """" } , { ""Subject"" , """" } , { ""Keywords"" , """" } , { ""Creator"" , """" } , { ""Producer"" , """" } , { ""CreationDate"" , """" } , { ""ModDate"" , """" } , { ""Trapped"" , """" } , } ; daddy = malloc ( sizeof ( creator_template ) ) ; memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ; if ( n_elements ) * n_elements = sizeof ( creator_template ) / sizeof ( creator_template [ 0 ] ) ; return daddy ; }
","<S2SV_ModStart> ; daddy = safe_calloc <S2SV_ModEnd> ( sizeof (
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,<S2SV_StartBug> daddy = malloc ( sizeof ( creator_template ) ) ; <S2SV_EndBug>
2826,CWE-255,"int vt_reset_keyboard ( int fd ) { int kb ; kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ; if ( ioctl ( fd , KDSKBMODE , kb ) < 0 ) return - errno ; return 0 ; }
","<S2SV_ModStart> { int kb , r <S2SV_ModStart> K_UNICODE : K_XLATE ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_debug_errno ( r , ""Keyboard<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>XLATE<S2SV_blank>or<S2SV_blank>UNICODE<S2SV_blank>mode,<S2SV_blank>not<S2SV_blank>resetting:<S2SV_blank>%m"" ) ; return 0 ; } else if ( r < 0 ) return r
",systemd@systemd/9725f1a10f80f5e0ae7d9b60547458622aeb322f,CVE-2018-20839,https://github.com/systemd/systemd/commit/9725f1a10f80f5e0ae7d9b60547458622aeb322f,2019-05-17T04:29Z,<S2SV_StartBug> int kb ; <S2SV_EndBug> <S2SV_StartBug> kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ; <S2SV_EndBug>
1976,CWE-119,"const char * vpx_svc_dump_statistics ( SvcContext * svc_ctx ) { int number_of_frames , number_of_keyframes , encode_frame_count ; int i , j ; uint32_t bytes_total = 0 ; double scale [ COMPONENTS ] ; double psnr [ COMPONENTS ] ; double mse [ COMPONENTS ] ; double y_scale ; SvcInternal * const si = get_svc_internal ( svc_ctx ) ; if ( svc_ctx == NULL || si == NULL ) return NULL ; svc_log_reset ( svc_ctx ) ; encode_frame_count = si -> encode_frame_count ; if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ; svc_log ( svc_ctx , SVC_LOG_INFO , ""\\n"" ) ; number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ; for ( i = 0 ; i < si -> layers ; ++ i ) { number_of_frames = encode_frame_count ; if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && ( i == 1 || i == 3 ) ) { number_of_frames -= number_of_keyframes ; } svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Average<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f],<S2SV_blank>Bytes=[%u]\\n"" , i , ( double ) si -> psnr_sum [ i ] [ 0 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 1 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 2 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 3 ] / number_of_frames , si -> bytes_sum [ i ] ) ; y_scale = si -> width * si -> height * 255.0 * 255.0 * number_of_frames ; scale [ 1 ] = y_scale ; scale [ 2 ] = scale [ 3 ] = y_scale / 4 ; scale [ 0 ] = y_scale * 1.5 ; for ( j = 0 ; j < COMPONENTS ; j ++ ) { psnr [ j ] = calc_psnr ( si -> sse_sum [ i ] [ j ] / scale [ j ] ) ; mse [ j ] = si -> sse_sum [ i ] [ j ] * 255.0 * 255.0 / scale [ j ] ; } svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n"" , i , psnr [ 0 ] , psnr [ 1 ] , psnr [ 2 ] , psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>MSE=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n"" , i , mse [ 0 ] , mse [ 1 ] , mse [ 2 ] , mse [ 3 ] ) ; bytes_total += si -> bytes_sum [ i ] ; si -> bytes_sum [ i ] = 0 ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] = 0 ; si -> sse_sum [ i ] [ j ] = 0 ; } } si -> encode_frame_count = 0 ; svc_log ( svc_ctx , SVC_LOG_INFO , ""Total<S2SV_blank>Bytes=[%u]\\n"" , bytes_total ) ; return vpx_svc_get_message ( svc_ctx ) ; }
","<S2SV_ModStart> { int number_of_frames <S2SV_ModEnd> ; int i <S2SV_ModStart> double y_scale ; SvcInternal_t <S2SV_ModEnd> * const si <S2SV_ModStart> svc_ctx ) ; number_of_frames = si -> psnr_pkt_received <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( number_of_frames <S2SV_ModEnd> <= 0 ) <S2SV_ModStart> ""\\n"" ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ; i < svc_ctx -> spatial_layers <S2SV_ModEnd> ; ++ i <S2SV_ModStart> i ) { <S2SV_ModEnd> svc_log ( svc_ctx <S2SV_ModStart> } si -> psnr_pkt_received <S2SV_ModEnd> = 0 ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int number_of_frames , number_of_keyframes , encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> <S2SV_StartBug> encode_frame_count = si -> encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ; <S2SV_EndBug> <S2SV_StartBug> number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < si -> layers ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> number_of_frames = encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> si -> encode_frame_count = 0 ; <S2SV_EndBug>"
1429,CWE-119,"static double get_prediction_decay_rate ( VP8_COMP * cpi , FIRSTPASS_STATS * next_frame ) { double prediction_decay_rate ; double motion_decay ; double motion_pct = next_frame -> pcnt_motion ; prediction_decay_rate = next_frame -> pcnt_inter ; motion_decay = ( 1.0 - ( motion_pct / 20.0 ) ) ; if ( motion_decay < prediction_decay_rate ) prediction_decay_rate = motion_decay ; { double this_mv_rabs ; double this_mv_cabs ; double distance_factor ; this_mv_rabs = fabs ( next_frame -> mvr_abs * motion_pct ) ; this_mv_cabs = fabs ( next_frame -> mvc_abs * motion_pct ) ; distance_factor = sqrt ( ( this_mv_rabs * this_mv_rabs ) + ( this_mv_cabs * this_mv_cabs ) ) / 250.0 ; distance_factor = ( ( distance_factor > 1.0 ) ? 0.0 : ( 1.0 - distance_factor ) ) ; if ( distance_factor < prediction_decay_rate ) prediction_decay_rate = distance_factor ; } return prediction_decay_rate ; }
","<S2SV_ModStart> next_frame -> pcnt_motion ; ( void ) cpi
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> double motion_pct = next_frame -> pcnt_motion ; <S2SV_EndBug>
2207,CWE-119,"static __u8 * nci_extract_rf_params_nfcf_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcf_poll * nfcf_poll , __u8 * data ) { nfcf_poll -> bit_rate = * data ++ ; nfcf_poll -> sensf_res_len = * data ++ ; pr_debug ( ""bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\n"" , nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ; memcpy ( nfcf_poll -> sensf_res , data , nfcf_poll -> sensf_res_len ) ; data += nfcf_poll -> sensf_res_len ; return data ; }
","<S2SV_ModStart> -> sensf_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSF_RES_MAXSIZE )
",torvalds@linux/67de956ff5dc1d4f321e16cfbd63f5be3b691b43,CVE-2012-3364,https://github.com/torvalds/linux/commit/67de956ff5dc1d4f321e16cfbd63f5be3b691b43,2013-01-22T23:55Z,<S2SV_StartBug> nfcf_poll -> sensf_res_len = * data ++ ; <S2SV_EndBug>
1673,CWE-119,"static void write_ref_frames ( const VP9_COMP * cpi , vp9_writer * w ) { const VP9_COMMON * const cm = & cpi -> common ; const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { assert ( ! is_compound ) ; assert ( mbmi -> ref_frame [ 0 ] == vp9_get_segdata ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ; } else { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { vp9_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else { assert ( ! is_compound == ( cm -> reference_mode == SINGLE_REFERENCE ) ) ; } if ( is_compound ) { vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , vp9_get_pred_prob_comp_ref_p ( cm , xd ) ) ; } else { const int bit0 = mbmi -> ref_frame [ 0 ] != LAST_FRAME ; vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ; if ( bit0 ) { const int bit1 = mbmi -> ref_frame [ 0 ] != GOLDEN_FRAME ; vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ; } } } }
","<S2SV_ModStart> write_ref_frames ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) { const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { assert ( ! is_compound ) ; assert ( mbmi -> ref_frame [ 0 ] == get_segdata ( & <S2SV_ModEnd> cm -> seg <S2SV_ModStart> SEG_LVL_REF_FRAME ) ) ; } else { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { vpx_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else <S2SV_ModStart> ( ! is_compound == <S2SV_ModEnd> ( cm -> <S2SV_ModStart> -> reference_mode == <S2SV_ModEnd> SINGLE_REFERENCE ) ) <S2SV_ModStart> is_compound ) { vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> != LAST_FRAME ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> != GOLDEN_FRAME ; vpx_write <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void write_ref_frames ( const VP9_COMP * cpi , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! is_compound ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ; <S2SV_EndBug>"
7898,CWE-20,"void httpParseAuthorizationField ( HttpConnection * connection , char_t * value ) { char_t * p ; char_t * token ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Basic"" ) ) { error_t error ; size_t n ; char_t * separator ; connection -> request . auth . mode = HTTP_AUTH_MODE_BASIC ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\t"" , & p ) ; if ( token != NULL ) { error = base64Decode ( token , osStrlen ( token ) , token , & n ) ; if ( ! error ) { token [ n ] = '\\0' ; separator = strchr ( token , ':' ) ; if ( separator != NULL ) { * separator = '\\0' ; strSafeCopy ( connection -> request . auth . user , token , HTTP_SERVER_USERNAME_MAX_LEN ) ; token = separator + 1 ; connection -> request . auth . password = token ; } } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>password:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . password ) ; } # endif # if ( HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { size_t n ; char_t * separator ; char_t * name ; connection -> request . auth . mode = HTTP_AUTH_MODE_DIGEST ; token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { separator = strchr ( token , '=' ) ; if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""username"" ) ) { strSafeCopy ( connection -> request . auth . user , value , HTTP_SERVER_USERNAME_MAX_LEN ) ; } else if ( ! osStrcasecmp ( name , ""realm"" ) ) { connection -> request . auth . realm = value ; } else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { connection -> request . auth . nonce = value ; } else if ( ! osStrcasecmp ( name , ""uri"" ) ) { connection -> request . auth . uri = value ; } else if ( ! osStrcasecmp ( name , ""qop"" ) ) { connection -> request . auth . qop = value ; } else if ( ! osStrcasecmp ( name , ""nc"" ) ) { connection -> request . auth . nc = value ; } else if ( ! osStrcasecmp ( name , ""cnonce"" ) ) { connection -> request . auth . cnonce = value ; } else if ( ! osStrcasecmp ( name , ""response"" ) ) { connection -> request . auth . response = value ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { connection -> request . auth . opaque = value ; } token = osStrtok_r ( NULL , "","" , & p ) ; } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>realm:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . realm ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>uri:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . uri ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>qop:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . qop ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nc:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nc ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>cnonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . cnonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>response:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . response ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>opaque:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . opaque ) ; } # endif else { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED || HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) connection -> request . auth . found = TRUE ; if ( connection -> settings -> authCallback != NULL ) { connection -> status = connection -> settings -> authCallback ( connection , connection -> request . auth . user , connection -> request . uri ) ; } else { connection -> status = HTTP_ACCESS_ALLOWED ; } # endif }
","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> separator = strchr ( token , ':' ) ; <S2SV_EndBug> <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug>"
124,CWE-285,"static int __reiserfs_set_acl ( struct reiserfs_transaction_handle * th , struct inode * inode , int type , struct posix_acl * acl ) { char * name ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; if ( error < 0 ) return error ; else { if ( error == 0 ) acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = reiserfs_posix_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = reiserfs_xattr_set_handle ( th , inode , name , value , size , 0 ) ; if ( error == - ENODATA ) { error = 0 ; if ( type == ACL_TYPE_ACCESS ) { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; } } kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> } break ;
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug>"
3495,CWE-200,"static int snd_timer_user_params ( struct file * file , struct snd_timer_params __user * _params ) { struct snd_timer_user * tu ; struct snd_timer_params params ; struct snd_timer * t ; struct snd_timer_read * tr ; struct snd_timer_tread * ttr ; int err ; tu = file -> private_data ; if ( ! tu -> timeri ) return - EBADFD ; t = tu -> timeri -> timer ; if ( ! t ) return - EBADFD ; if ( copy_from_user ( & params , _params , sizeof ( params ) ) ) return - EFAULT ; if ( ! ( t -> hw . flags & SNDRV_TIMER_HW_SLAVE ) && params . ticks < 1 ) { err = - EINVAL ; goto _end ; } if ( params . queue_size > 0 && ( params . queue_size < 32 || params . queue_size > 1024 ) ) { err = - EINVAL ; goto _end ; } if ( params . filter & ~ ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | ( 1 << SNDRV_TIMER_EVENT_TICK ) | ( 1 << SNDRV_TIMER_EVENT_START ) | ( 1 << SNDRV_TIMER_EVENT_STOP ) | ( 1 << SNDRV_TIMER_EVENT_CONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_PAUSE ) | ( 1 << SNDRV_TIMER_EVENT_SUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_RESUME ) | ( 1 << SNDRV_TIMER_EVENT_MSTART ) | ( 1 << SNDRV_TIMER_EVENT_MSTOP ) | ( 1 << SNDRV_TIMER_EVENT_MCONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_MPAUSE ) | ( 1 << SNDRV_TIMER_EVENT_MSUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_MRESUME ) ) ) { err = - EINVAL ; goto _end ; } snd_timer_stop ( tu -> timeri ) ; spin_lock_irq ( & t -> lock ) ; tu -> timeri -> flags &= ~ ( SNDRV_TIMER_IFLG_AUTO | SNDRV_TIMER_IFLG_EXCLUSIVE | SNDRV_TIMER_IFLG_EARLY_EVENT ) ; if ( params . flags & SNDRV_TIMER_PSFLG_AUTO ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_AUTO ; if ( params . flags & SNDRV_TIMER_PSFLG_EXCLUSIVE ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_EXCLUSIVE ; if ( params . flags & SNDRV_TIMER_PSFLG_EARLY_EVENT ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_EARLY_EVENT ; spin_unlock_irq ( & t -> lock ) ; if ( params . queue_size > 0 && ( unsigned int ) tu -> queue_size != params . queue_size ) { if ( tu -> tread ) { ttr = kmalloc ( params . queue_size * sizeof ( * ttr ) , GFP_KERNEL ) ; if ( ttr ) { kfree ( tu -> tqueue ) ; tu -> queue_size = params . queue_size ; tu -> tqueue = ttr ; } } else { tr = kmalloc ( params . queue_size * sizeof ( * tr ) , GFP_KERNEL ) ; if ( tr ) { kfree ( tu -> queue ) ; tu -> queue_size = params . queue_size ; tu -> queue = tr ; } } } tu -> qhead = tu -> qtail = tu -> qused = 0 ; if ( tu -> timeri -> flags & SNDRV_TIMER_IFLG_EARLY_EVENT ) { if ( tu -> tread ) { struct snd_timer_tread tread ; tread . event = SNDRV_TIMER_EVENT_EARLY ; tread . tstamp . tv_sec = 0 ; tread . tstamp . tv_nsec = 0 ; tread . val = 0 ; snd_timer_user_append_to_tqueue ( tu , & tread ) ; } else { struct snd_timer_read * r = & tu -> queue [ 0 ] ; r -> resolution = 0 ; r -> ticks = 0 ; tu -> qused ++ ; tu -> qtail ++ ; } } tu -> filter = params . filter ; tu -> ticks = params . ticks ; err = 0 ; _end : if ( copy_to_user ( _params , & params , sizeof ( params ) ) ) return - EFAULT ; return err ; }
","<S2SV_ModStart> snd_timer_tread tread ; memset ( & tread , 0 , sizeof ( tread ) ) ;
",torvalds@linux/cec8f96e49d9be372fdb0c3836dcf31ec71e457e,CVE-2016-4569,https://github.com/torvalds/linux/commit/cec8f96e49d9be372fdb0c3836dcf31ec71e457e,2016-05-23T10:59Z,<S2SV_StartBug> tread . event = SNDRV_TIMER_EVENT_EARLY ; <S2SV_EndBug>
717,CWE-20,"int HTMLtagproc1 ( struct parsed_tag * tag , struct html_feed_environ * h_env ) { char * p , * q , * r ; int i , w , x , y , z , count , width ; struct readbuffer * obuf = h_env -> obuf ; struct environment * envs = h_env -> envs ; Str tmp ; int hseq ; int cmd ; # ifdef ID_EXT char * id = NULL ; # endif cmd = tag -> tagid ; if ( obuf -> flag & RB_PRE ) { switch ( cmd ) { case HTML_NOBR : case HTML_N_NOBR : case HTML_PRE_INT : case HTML_N_PRE_INT : return 1 ; } } switch ( cmd ) { case HTML_B : obuf -> in_bold ++ ; if ( obuf -> in_bold > 1 ) return 1 ; return 0 ; case HTML_N_B : if ( obuf -> in_bold == 1 && close_effect0 ( obuf , HTML_B ) ) obuf -> in_bold = 0 ; if ( obuf -> in_bold > 0 ) { obuf -> in_bold -- ; if ( obuf -> in_bold == 0 ) return 0 ; } return 1 ; case HTML_I : obuf -> in_italic ++ ; if ( obuf -> in_italic > 1 ) return 1 ; return 0 ; case HTML_N_I : if ( obuf -> in_italic == 1 && close_effect0 ( obuf , HTML_I ) ) obuf -> in_italic = 0 ; if ( obuf -> in_italic > 0 ) { obuf -> in_italic -- ; if ( obuf -> in_italic == 0 ) return 0 ; } return 1 ; case HTML_U : obuf -> in_under ++ ; if ( obuf -> in_under > 1 ) return 1 ; return 0 ; case HTML_N_U : if ( obuf -> in_under == 1 && close_effect0 ( obuf , HTML_U ) ) obuf -> in_under = 0 ; if ( obuf -> in_under > 0 ) { obuf -> in_under -- ; if ( obuf -> in_under == 0 ) return 0 ; } return 1 ; case HTML_EM : HTMLlineproc1 ( ""<i>"" , h_env ) ; return 1 ; case HTML_N_EM : HTMLlineproc1 ( ""</i>"" , h_env ) ; return 1 ; case HTML_STRONG : HTMLlineproc1 ( ""<b>"" , h_env ) ; return 1 ; case HTML_N_STRONG : HTMLlineproc1 ( ""</b>"" , h_env ) ; return 1 ; case HTML_Q : HTMLlineproc1 ( ""`"" , h_env ) ; return 1 ; case HTML_N_Q : HTMLlineproc1 ( ""\'"" , h_env ) ; return 1 ; case HTML_P : case HTML_N_P : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; if ( cmd == HTML_P ) { set_alignment ( obuf , tag ) ; obuf -> flag |= RB_P ; } return 1 ; case HTML_BR : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; h_env -> blank_lines = 0 ; return 1 ; case HTML_H : if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } HTMLlineproc1 ( ""<b>"" , h_env ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_H : HTMLlineproc1 ( ""</b>"" , h_env ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; close_anchor ( h_env , obuf ) ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_UL : case HTML_OL : case HTML_BLQ : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_BLQ ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( cmd == HTML_UL || cmd == HTML_OL ) { if ( parsedtag_get_value ( tag , ATTR_START , & count ) ) { envs [ h_env -> envc ] . count = count - 1 ; } } if ( cmd == HTML_OL ) { envs [ h_env -> envc ] . type = '1' ; if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { envs [ h_env -> envc ] . type = ( int ) * p ; } } if ( cmd == HTML_UL ) envs [ h_env -> envc ] . type = ul_type ( tag , 0 ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_N_UL : case HTML_N_OL : case HTML_N_DL : case HTML_N_BLQ : CLOSE_DT ; CLOSE_A ; if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; POP_ENV ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , INDENT_INCR , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } } close_anchor ( h_env , obuf ) ; return 1 ; case HTML_DL : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( parsedtag_exists ( tag , ATTR_COMPACT ) ) envs [ h_env -> envc ] . env = HTML_DL_COMPACT ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_LI : CLOSE_A ; CLOSE_DT ; if ( h_env -> envc > 0 ) { Str num ; flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; envs [ h_env -> envc ] . count ++ ; if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { count = atoi ( p ) ; if ( count > 0 ) envs [ h_env -> envc ] . count = count ; else envs [ h_env -> envc ] . count = 0 ; } switch ( envs [ h_env -> envc ] . env ) { case HTML_UL : envs [ h_env -> envc ] . type = ul_type ( tag , envs [ h_env -> envc ] . type ) ; for ( i = 0 ; i < INDENT_INCR - 3 ; i ++ ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; tmp = Strnew ( ) ; switch ( envs [ h_env -> envc ] . type ) { case 'd' : push_symbol ( tmp , UL_SYMBOL_DISC , symbol_width , 1 ) ; break ; case 'c' : push_symbol ( tmp , UL_SYMBOL_CIRCLE , symbol_width , 1 ) ; break ; case 's' : push_symbol ( tmp , UL_SYMBOL_SQUARE , symbol_width , 1 ) ; break ; default : push_symbol ( tmp , UL_SYMBOL ( ( h_env -> envc_real - 1 ) % MAX_UL_LEVEL ) , symbol_width , 1 ) ; break ; } if ( symbol_width == 1 ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; push_str ( obuf , symbol_width , tmp , PC_ASCII ) ; push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; set_space_to_prevchar ( obuf -> prevchar ) ; break ; case HTML_OL : if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) envs [ h_env -> envc ] . type = ( int ) * p ; switch ( ( envs [ h_env -> envc ] . count > 0 ) ? envs [ h_env -> envc ] . type : '1' ) { case 'i' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; break ; case 'I' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; case 'a' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; break ; case 'A' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; default : num = Sprintf ( ""%d"" , envs [ h_env -> envc ] . count ) ; break ; } if ( INDENT_INCR >= 4 ) Strcat_charp ( num , "".<S2SV_blank>"" ) ; else Strcat_char ( num , '.' ) ; push_spaces ( obuf , 1 , INDENT_INCR - num -> length ) ; push_str ( obuf , num -> length , num , PC_ASCII ) ; if ( INDENT_INCR >= 4 ) set_space_to_prevchar ( obuf -> prevchar ) ; break ; default : push_spaces ( obuf , 1 , INDENT_INCR ) ; break ; } } else { flushline ( h_env , obuf , 0 , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DT : CLOSE_A ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; } if ( ! ( obuf -> flag & RB_IN_DT ) ) { HTMLlineproc1 ( ""<b>"" , h_env ) ; obuf -> flag |= RB_IN_DT ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DD : CLOSE_A ; CLOSE_DT ; if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) { if ( obuf -> pos > envs [ h_env -> envc ] . indent ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; else push_spaces ( obuf , 1 , envs [ h_env -> envc ] . indent - obuf -> pos ) ; } else flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_TITLE : close_anchor ( h_env , obuf ) ; process_title ( tag ) ; obuf -> flag |= RB_TITLE ; obuf -> end_tag = HTML_N_TITLE ; return 1 ; case HTML_N_TITLE : if ( ! ( obuf -> flag & RB_TITLE ) ) return 1 ; obuf -> flag &= ~ RB_TITLE ; obuf -> end_tag = 0 ; tmp = process_n_title ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_TITLE_ALT : if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) h_env -> title = html_unquote ( p ) ; return 0 ; case HTML_FRAMESET : PUSH_ENV ( cmd ) ; push_charp ( obuf , 9 , ""--FRAME--"" , PC_ASCII ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_N_FRAMESET : if ( h_env -> envc > 0 ) { POP_ENV ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } return 0 ; case HTML_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= ( RB_NOFRAMES | RB_IGNORE_P ) ; return 1 ; case HTML_N_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag &= ~ RB_NOFRAMES ; return 1 ; case HTML_FRAME : q = r = NULL ; parsedtag_get_value ( tag , ATTR_SRC , & q ) ; parsedtag_get_value ( tag , ATTR_NAME , & r ) ; if ( q ) { q = html_quote ( q ) ; push_tag ( obuf , Sprintf ( ""<a<S2SV_blank>hseq=\\""%d\\""<S2SV_blank>href=\\""%s\\"">"" , cur_hseq ++ , q ) -> ptr , HTML_A ) ; if ( r ) q = html_quote ( r ) ; push_charp ( obuf , get_strwidth ( q ) , q , PC_ASCII ) ; push_tag ( obuf , ""</a>"" , HTML_N_A ) ; } flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_HR : close_anchor ( h_env , obuf ) ; tmp = process_hr ( tag , h_env -> limit , envs [ h_env -> envc ] . indent ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; set_space_to_prevchar ( obuf -> prevchar ) ; return 1 ; case HTML_PRE : x = parsedtag_exists ( tag , ATTR_FOR_TABLE ) ; CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! x ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } else fillline ( obuf , envs [ h_env -> envc ] . indent ) ; obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; h_env -> blank_lines ++ ; } obuf -> flag &= ~ RB_PRE ; close_anchor ( h_env , obuf ) ; return 1 ; case HTML_PRE_INT : i = obuf -> line -> length ; append_tags ( obuf ) ; if ( ! ( obuf -> flag & RB_SPECIAL ) ) { set_breakpoint ( obuf , obuf -> line -> length - i ) ; } obuf -> flag |= RB_PRE_INT ; return 0 ; case HTML_N_PRE_INT : push_tag ( obuf , ""</pre_int>"" , HTML_N_PRE_INT ) ; obuf -> flag &= ~ RB_PRE_INT ; if ( ! ( obuf -> flag & RB_SPECIAL ) && obuf -> pos > obuf -> bp . pos ) { set_prevchar ( obuf -> prevchar , """" , 0 ) ; obuf -> prev_ctype = PC_CTRL ; } return 1 ; case HTML_NOBR : obuf -> flag |= RB_NOBR ; obuf -> nobr_level ++ ; return 0 ; case HTML_N_NOBR : if ( obuf -> nobr_level > 0 ) obuf -> nobr_level -- ; if ( obuf -> nobr_level == 0 ) obuf -> flag &= ~ RB_NOBR ; return 0 ; case HTML_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PRE ; return 1 ; case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PLAIN | RB_IGNORE_P ) ; switch ( cmd ) { case HTML_LISTING : obuf -> end_tag = HTML_N_LISTING ; break ; case HTML_XMP : obuf -> end_tag = HTML_N_XMP ; break ; case HTML_PLAINTEXT : obuf -> end_tag = MAX_HTMLTAG ; break ; } return 1 ; case HTML_N_LISTING : case HTML_N_XMP : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PLAIN ; obuf -> end_tag = 0 ; return 1 ; case HTML_SCRIPT : obuf -> flag |= RB_SCRIPT ; obuf -> end_tag = HTML_N_SCRIPT ; return 1 ; case HTML_STYLE : obuf -> flag |= RB_STYLE ; obuf -> end_tag = HTML_N_STYLE ; return 1 ; case HTML_N_SCRIPT : obuf -> flag &= ~ RB_SCRIPT ; obuf -> end_tag = 0 ; return 1 ; case HTML_N_STYLE : obuf -> flag &= ~ RB_STYLE ; obuf -> end_tag = 0 ; return 1 ; case HTML_A : if ( obuf -> anchor . url ) close_anchor ( h_env , obuf ) ; hseq = 0 ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) obuf -> anchor . url = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TARGET , & p ) ) obuf -> anchor . target = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_REFERER , & p ) ) obuf -> anchor . referer = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) obuf -> anchor . title = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_ACCESSKEY , & p ) ) obuf -> anchor . accesskey = ( unsigned char ) * p ; if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) obuf -> anchor . hseq = hseq ; if ( hseq == 0 && obuf -> anchor . url ) { obuf -> anchor . hseq = cur_hseq ; tmp = process_anchor ( tag , h_env -> tagbuf -> ptr ) ; push_tag ( obuf , tmp -> ptr , HTML_A ) ; if ( displayLinkNumber ) HTMLlineproc1 ( getLinkNumberStr ( - 1 ) -> ptr , h_env ) ; return 1 ; } return 0 ; case HTML_N_A : close_anchor ( h_env , obuf ) ; return 1 ; case HTML_IMG : tmp = process_img ( tag , h_env -> limit ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_IMG_ALT : if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) obuf -> img_alt = Strnew_charp ( p ) ; # ifdef USE_IMAGE i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } # endif return 0 ; case HTML_N_IMG_ALT : if ( obuf -> img_alt ) { if ( ! close_effect0 ( obuf , HTML_IMG_ALT ) ) push_tag ( obuf , ""</img_alt>"" , HTML_N_IMG_ALT ) ; obuf -> img_alt = NULL ; } return 1 ; case HTML_INPUT_ALT : i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) { obuf -> input_alt . hseq = hseq ; } if ( parsedtag_get_value ( tag , ATTR_FID , & i ) ) { obuf -> input_alt . fid = i ; } if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { obuf -> input_alt . type = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { obuf -> input_alt . value = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_NAME , & p ) ) { obuf -> input_alt . name = Strnew_charp ( p ) ; } obuf -> input_alt . in = 1 ; return 0 ; case HTML_N_INPUT_ALT : if ( obuf -> input_alt . in ) { if ( ! close_effect0 ( obuf , HTML_INPUT_ALT ) ) push_tag ( obuf , ""</input_alt>"" , HTML_N_INPUT_ALT ) ; obuf -> input_alt . hseq = 0 ; obuf -> input_alt . fid = - 1 ; obuf -> input_alt . in = 0 ; obuf -> input_alt . type = NULL ; obuf -> input_alt . name = NULL ; obuf -> input_alt . value = NULL ; } return 1 ; case HTML_TABLE : close_anchor ( h_env , obuf ) ; obuf -> table_level ++ ; if ( obuf -> table_level >= MAX_TABLE ) break ; w = BORDER_NONE ; x = 2 ; y = 1 ; z = 0 ; width = 0 ; if ( parsedtag_exists ( tag , ATTR_BORDER ) ) { if ( parsedtag_get_value ( tag , ATTR_BORDER , & w ) ) { if ( w > 2 ) w = BORDER_THICK ; else if ( w < 0 ) { w = BORDER_THIN ; } } else w = BORDER_THIN ; } if ( DisplayBorders && w == BORDER_NONE ) w = BORDER_THIN ; if ( parsedtag_get_value ( tag , ATTR_WIDTH , & i ) ) { if ( obuf -> table_level == 0 ) width = REAL_WIDTH ( i , h_env -> limit - envs [ h_env -> envc ] . indent ) ; else width = RELATIVE_WIDTH ( i ) ; } if ( parsedtag_exists ( tag , ATTR_HBORDER ) ) w = BORDER_NOWIN ; # define MAX_CELLSPACING 1000 # define MAX_CELLPADDING 1000 # define MAX_VSPACE 1000 parsedtag_get_value ( tag , ATTR_CELLSPACING , & x ) ; parsedtag_get_value ( tag , ATTR_CELLPADDING , & y ) ; parsedtag_get_value ( tag , ATTR_VSPACE , & z ) ; if ( x > MAX_CELLSPACING ) x = MAX_CELLSPACING ; if ( y > MAX_CELLPADDING ) y = MAX_CELLPADDING ; if ( z > MAX_VSPACE ) z = MAX_VSPACE ; # ifdef ID_EXT parsedtag_get_value ( tag , ATTR_ID , & id ) ; # endif tables [ obuf -> table_level ] = begin_table ( w , x , y , z ) ; # ifdef ID_EXT if ( id != NULL ) tables [ obuf -> table_level ] -> id = Strnew_charp ( id ) ; # endif table_mode [ obuf -> table_level ] . pre_mode = 0 ; table_mode [ obuf -> table_level ] . indent_level = 0 ; table_mode [ obuf -> table_level ] . nobr_level = 0 ; table_mode [ obuf -> table_level ] . caption = 0 ; table_mode [ obuf -> table_level ] . end_tag = 0 ; # ifndef TABLE_EXPAND tables [ obuf -> table_level ] -> total_width = width ; # else tables [ obuf -> table_level ] -> real_width = width ; tables [ obuf -> table_level ] -> total_width = 0 ; # endif return 1 ; case HTML_N_TABLE : return 1 ; case HTML_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_SAVE_FLAG ( obuf ) ; RB_SET_ALIGN ( obuf , RB_CENTER ) ; return 1 ; case HTML_N_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & RB_PREMODE ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV_INT : CLOSE_P ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV_INT : CLOSE_P ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_FORM : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; tmp = process_form ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_FORM : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; process_n_form ( ) ; return 1 ; case HTML_INPUT : close_anchor ( h_env , obuf ) ; tmp = process_input ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_BUTTON : tmp = process_button ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_BUTTON : tmp = process_n_button ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_SELECT : close_anchor ( h_env , obuf ) ; tmp = process_select ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INSELECT ; obuf -> end_tag = HTML_N_SELECT ; return 1 ; case HTML_N_SELECT : obuf -> flag &= ~ RB_INSELECT ; obuf -> end_tag = 0 ; tmp = process_n_select ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_OPTION : return 1 ; case HTML_TEXTAREA : close_anchor ( h_env , obuf ) ; tmp = process_textarea ( tag , h_env -> limit ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INTXTA ; obuf -> end_tag = HTML_N_TEXTAREA ; return 1 ; case HTML_N_TEXTAREA : obuf -> flag &= ~ RB_INTXTA ; obuf -> end_tag = 0 ; tmp = process_n_textarea ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_ISINDEX : p = """" ; q = ""!CURRENT_URL!"" ; parsedtag_get_value ( tag , ATTR_PROMPT , & p ) ; parsedtag_get_value ( tag , ATTR_ACTION , & q ) ; tmp = Strnew_m_charp ( ""<form<S2SV_blank>method=get<S2SV_blank>action=\\"""" , html_quote ( q ) , ""\\"">"" , html_quote ( p ) , ""<input<S2SV_blank>type=text<S2SV_blank>name=\\""\\""<S2SV_blank>accept></form>"" , NULL ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_META : p = q = r = NULL ; parsedtag_get_value ( tag , ATTR_HTTP_EQUIV , & p ) ; parsedtag_get_value ( tag , ATTR_CONTENT , & q ) ; # ifdef USE_M17N parsedtag_get_value ( tag , ATTR_CHARSET , & r ) ; if ( r ) { SKIP_BLANKS ( r ) ; meta_charset = wc_guess_charset ( r , 0 ) ; } else if ( p && q && ! strcasecmp ( p , ""Content-Type"" ) && ( q = strcasestr ( q , ""charset"" ) ) != NULL ) { q += 7 ; SKIP_BLANKS ( q ) ; if ( * q == '=' ) { q ++ ; SKIP_BLANKS ( q ) ; meta_charset = wc_guess_charset ( q , 0 ) ; } } else # endif if ( p && q && ! strcasecmp ( p , ""refresh"" ) ) { int refresh_interval ; tmp = NULL ; refresh_interval = getMetaRefreshParam ( q , & tmp ) ; if ( tmp ) { q = html_quote ( tmp -> ptr ) ; tmp = Sprintf ( ""Refresh<S2SV_blank>(%d<S2SV_blank>sec)<S2SV_blank><a<S2SV_blank>href=\\""%s\\"">%s</a>"" , refresh_interval , q , q ) ; } else if ( refresh_interval > 0 ) tmp = Sprintf ( ""Refresh<S2SV_blank>(%d<S2SV_blank>sec)"" , refresh_interval ) ; if ( tmp ) { HTMLlineproc1 ( tmp -> ptr , h_env ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! is_redisplay && ! ( ( obuf -> flag & RB_NOFRAMES ) && RenderFrame ) ) { tag -> need_reconstruct = TRUE ; return 0 ; } } } return 1 ; case HTML_BASE : # if defined ( USE_M17N ) || defined ( USE_IMAGE ) p = NULL ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) { cur_baseURL = New ( ParsedURL ) ; parseURL ( p , cur_baseURL , NULL ) ; } # endif case HTML_MAP : case HTML_N_MAP : case HTML_AREA : return 0 ; case HTML_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>[DEL:</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , ""<s>"" , HTML_S ) ; } break ; } return 1 ; case HTML_N_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>:DEL]</U>"" , h_env ) ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , ""</s>"" , HTML_N_S ) ; } } break ; } return 1 ; case HTML_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>[S:</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , ""<s>"" , HTML_S ) ; } break ; } return 1 ; case HTML_N_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>:S]</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , ""</s>"" , HTML_N_S ) ; } } } return 1 ; case HTML_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>[INS:</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_ins ++ ; if ( obuf -> in_ins == 1 ) { push_tag ( obuf , ""<ins>"" , HTML_INS ) ; } break ; } return 1 ; case HTML_N_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>:INS]</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_ins == 0 ) return 1 ; if ( obuf -> in_ins == 1 && close_effect0 ( obuf , HTML_INS ) ) obuf -> in_ins = 0 ; if ( obuf -> in_ins > 0 ) { obuf -> in_ins -- ; if ( obuf -> in_ins == 0 ) { push_tag ( obuf , ""</ins>"" , HTML_N_INS ) ; } } break ; } return 1 ; case HTML_SUP : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( ""^"" , h_env ) ; return 1 ; case HTML_N_SUP : return 1 ; case HTML_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( ""["" , h_env ) ; return 1 ; case HTML_N_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( ""]"" , h_env ) ; return 1 ; case HTML_FONT : case HTML_N_FONT : case HTML_NOP : return 1 ; case HTML_BGSOUND : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<A<S2SV_blank>HREF=\\""%s\\"">bgsound(%s)</A>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_EMBED : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<A<S2SV_blank>HREF=\\""%s\\"">embed(%s)</A>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_APPLET : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_ARCHIVE , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<A<S2SV_blank>HREF=\\""%s\\"">applet<S2SV_blank>archive(%s)</A>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_BODY : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_BACKGROUND , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<IMG<S2SV_blank>SRC=\\""%s\\""<S2SV_blank>ALT=\\""bg<S2SV_blank>image(%s)\\""><BR>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } case HTML_N_HEAD : if ( obuf -> flag & RB_TITLE ) HTMLlineproc1 ( ""</title>"" , h_env ) ; case HTML_HEAD : case HTML_N_BODY : return 1 ; default : return 0 ; } return 0 ; }
","<S2SV_ModStart> ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (
",tats@w3m/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd,CVE-2016-9436,https://github.com/tats/w3m/commit/33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd,2017-01-20T15:59Z,<S2SV_StartBug> if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) { <S2SV_EndBug>
3035,CWE-190,"static inline void process_get_command ( conn * c , token_t * tokens , size_t ntokens , bool return_cas ) { char * key ; size_t nkey ; int i = 0 ; item * it ; token_t * key_token = & tokens [ KEY_TOKEN ] ; char * suffix ; assert ( c != NULL ) ; do { while ( key_token -> length != 0 ) { key = key_token -> value ; nkey = key_token -> length ; if ( nkey > KEY_MAX_LENGTH ) { out_string ( c , ""CLIENT_ERROR<S2SV_blank>bad<S2SV_blank>command<S2SV_blank>line<S2SV_blank>format"" ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } it = item_get ( key , nkey , c , DO_UPDATE ) ; if ( settings . detail_enabled ) { stats_prefix_record_get ( key , nkey , NULL != it ) ; } if ( it ) { if ( i >= c -> isize ) { item * * new_list = realloc ( c -> ilist , sizeof ( item * ) * c -> isize * 2 ) ; if ( new_list ) { c -> isize *= 2 ; c -> ilist = new_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } if ( return_cas || ! settings . inline_ascii_response ) { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( i >= c -> suffixsize ) { char * * new_suffix_list = realloc ( c -> suffixlist , sizeof ( char * ) * c -> suffixsize * 2 ) ; if ( new_suffix_list ) { c -> suffixsize *= 2 ; c -> suffixlist = new_suffix_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } suffix = do_cache_alloc ( c -> thread -> suffix_cache ) ; if ( suffix == NULL ) { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; out_of_memory ( c , ""SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>making<S2SV_blank>CAS<S2SV_blank>suffix"" ) ; item_remove ( it ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } * ( c -> suffixlist + i ) = suffix ; int suffix_len = make_ascii_get_suffix ( suffix , it , return_cas ) ; if ( add_iov ( c , ""VALUE<S2SV_blank>"" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 || ( settings . inline_ascii_response && add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix - 2 ) != 0 ) || add_iov ( c , suffix , suffix_len ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { add_iov ( c , ITEM_data ( it ) , it -> nbytes ) ; } else if ( add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( add_iov ( c , ""VALUE<S2SV_blank>"" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix + it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix ) != 0 || add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , "">%d<S2SV_blank>sending<S2SV_blank>key<S2SV_blank>"" , c -> sfd ) ; for ( ii = 0 ; ii < it -> nkey ; ++ ii ) { fprintf ( stderr , ""%c"" , key [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . slab_stats [ ITEM_clsid ( it ) ] . get_hits ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; * ( c -> ilist + i ) = it ; i ++ ; } else { pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . get_misses ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; MEMCACHED_COMMAND_GET ( c -> sfd , key , nkey , - 1 , 0 ) ; } key_token ++ ; } if ( key_token -> value != NULL ) { ntokens = tokenize_command ( key_token -> value , tokens , MAX_TOKENS ) ; key_token = tokens ; } } while ( key_token -> value != NULL ) ; c -> icurr = c -> ilist ; c -> ileft = i ; if ( return_cas || ! settings . inline_ascii_response ) { c -> suffixcurr = c -> suffixlist ; c -> suffixleft = i ; } if ( settings . verbose > 1 ) fprintf ( stderr , "">%d<S2SV_blank>END\\n"" , c -> sfd ) ; if ( key_token -> value != NULL || add_iov ( c , ""END\\r\\n"" , 5 ) != 0 || ( IS_UDP ( c -> transport ) && build_udp_headers ( c ) != 0 ) ) { out_of_memory ( c , ""SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>writing<S2SV_blank>get<S2SV_blank>response"" ) ; } else { conn_set_state ( c , conn_mwrite ) ; c -> msgcurr = 0 ; } }
","<S2SV_ModStart> } it = limited_get <S2SV_ModEnd> ( key , <S2SV_ModStart> nkey , c <S2SV_ModEnd> ) ; if
",memcached@memcached/a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00,CVE-2018-1000127,https://github.com/memcached/memcached/commit/a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00,2018-03-13T21:29Z,"<S2SV_StartBug> it = item_get ( key , nkey , c , DO_UPDATE ) ; <S2SV_EndBug>"
8335,CWE-264,"static int perf_event_read_group ( struct perf_event * event , u64 read_format , char __user * buf ) { struct perf_event * leader = event -> group_leader , * sub ; int n = 0 , size = 0 , ret = - EFAULT ; struct perf_event_context * ctx = leader -> ctx ; u64 values [ 5 ] ; u64 count , enabled , running ; mutex_lock ( & ctx -> mutex ) ; count = perf_event_read_value ( leader , & enabled , & running ) ; values [ n ++ ] = 1 + leader -> nr_siblings ; if ( read_format & PERF_FORMAT_TOTAL_TIME_ENABLED ) values [ n ++ ] = enabled ; if ( read_format & PERF_FORMAT_TOTAL_TIME_RUNNING ) values [ n ++ ] = running ; values [ n ++ ] = count ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( leader ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf , values , size ) ) goto unlock ; ret = size ; list_for_each_entry ( sub , & leader -> sibling_list , group_entry ) { n = 0 ; values [ n ++ ] = perf_event_read_value ( sub , & enabled , & running ) ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( sub ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf + ret , values , size ) ) { ret = - EFAULT ; goto unlock ; } ret += size ; } unlock : mutex_unlock ( & ctx -> mutex ) ; return ret ; }
","<S2SV_ModStart> * sub ; struct perf_event_context * ctx = leader -> ctx ; <S2SV_ModStart> 0 , ret ; u64 count , enabled , running ; u64 values [ 5 ] ; lockdep_assert_held ( & ctx -> mutex ) ; count = perf_event_read_value ( leader , & enabled , & running ) ; values [ n ++ ] = 1 + leader -> nr_siblings ; if ( read_format & PERF_FORMAT_TOTAL_TIME_ENABLED ) values [ n ++ ] = enabled ; if ( read_format & PERF_FORMAT_TOTAL_TIME_RUNNING ) values [ n ++ ] = running ; values [ n ++ ] = count ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( leader ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf , values , size ) ) return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ret = size <S2SV_ModStart> ) ) { return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> } ret += <S2SV_ModStart> size ; } <S2SV_ModEnd> return ret ;
",torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b,CVE-2016-6787,https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b,2016-12-28T07:59Z,"<S2SV_StartBug> int n = 0 , size = 0 , ret = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> struct perf_event_context * ctx = leader -> ctx ; <S2SV_EndBug> <S2SV_StartBug> ret = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> goto unlock ; <S2SV_EndBug> <S2SV_StartBug> unlock : <S2SV_EndBug>"
5497,CWE-59,"void shutdown_mib ( void ) { unload_all_mibs ( ) ; if ( tree_top ) { if ( tree_top -> label ) SNMP_FREE ( tree_top -> label ) ; SNMP_FREE ( tree_top ) ; } tree_head = NULL ; Mib = NULL ; if ( _mibindexes ) { int i ; for ( i = 0 ; i < _mibindex ; ++ i ) SNMP_FREE ( _mibindexes [ i ] ) ; free ( _mibindexes ) ; _mibindex = 0 ; _mibindex_max = 0 ; _mibindexes = NULL ; } if ( Prefix != NULL && Prefix != & Standard_Prefix [ 0 ] ) SNMP_FREE ( Prefix ) ; if ( Prefix ) Prefix = NULL ; SNMP_FREE ( confmibs ) ; SNMP_FREE ( confmibdir ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> Prefix != NULL
",net-snmp@net-snmp/4fd9a450444a434a993bc72f7c3486ccce41f602,CVE-2020-15861,https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602,2020-08-20T01:17Z,<S2SV_StartBug> if ( _mibindexes ) { <S2SV_EndBug>
3084,CWE-787,"static int hmac_create ( struct crypto_template * tmpl , struct rtattr * * tb ) { struct shash_instance * inst ; struct crypto_alg * alg ; struct shash_alg * salg ; int err ; int ds ; int ss ; err = crypto_check_attr_type ( tb , CRYPTO_ALG_TYPE_SHASH ) ; if ( err ) return err ; salg = shash_attr_alg ( tb [ 1 ] , 0 , 0 ) ; if ( IS_ERR ( salg ) ) return PTR_ERR ( salg ) ; err = - EINVAL ; ds = salg -> digestsize ; ss = salg -> statesize ; alg = & salg -> base ; if ( ds > alg -> cra_blocksize || ss < alg -> cra_blocksize ) goto out_put_alg ; inst = shash_alloc_instance ( ""hmac"" , alg ) ; err = PTR_ERR ( inst ) ; if ( IS_ERR ( inst ) ) goto out_put_alg ; err = crypto_init_shash_spawn ( shash_instance_ctx ( inst ) , salg , shash_crypto_instance ( inst ) ) ; if ( err ) goto out_free_inst ; inst -> alg . base . cra_priority = alg -> cra_priority ; inst -> alg . base . cra_blocksize = alg -> cra_blocksize ; inst -> alg . base . cra_alignmask = alg -> cra_alignmask ; ss = ALIGN ( ss , alg -> cra_alignmask + 1 ) ; inst -> alg . digestsize = ds ; inst -> alg . statesize = ss ; inst -> alg . base . cra_ctxsize = sizeof ( struct hmac_ctx ) + ALIGN ( ss * 2 , crypto_tfm_ctx_alignment ( ) ) ; inst -> alg . base . cra_init = hmac_init_tfm ; inst -> alg . base . cra_exit = hmac_exit_tfm ; inst -> alg . init = hmac_init ; inst -> alg . update = hmac_update ; inst -> alg . final = hmac_final ; inst -> alg . finup = hmac_finup ; inst -> alg . export = hmac_export ; inst -> alg . import = hmac_import ; inst -> alg . setkey = hmac_setkey ; err = shash_register_instance ( tmpl , inst ) ; if ( err ) { out_free_inst : shash_free_instance ( shash_crypto_instance ( inst ) ) ; } out_put_alg : crypto_mod_put ( alg ) ; return err ; }
","<S2SV_ModStart> salg ) ; alg = & salg -> base ; <S2SV_ModStart> - EINVAL ; if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ; <S2SV_ModStart> salg -> statesize <S2SV_ModEnd> ; if (
",torvalds@linux/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,CVE-2017-17806,https://github.com/torvalds/linux/commit/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,2017-12-20T23:29Z,<S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> ds = salg -> digestsize ; <S2SV_EndBug> <S2SV_StartBug> ss = salg -> statesize ; <S2SV_EndBug>
415,CWE-125,"static void handle_ppp ( netdissect_options * ndo , u_int proto , const u_char * p , int length ) { if ( ( proto & 0xff00 ) == 0x7e00 ) { ppp_hdlc ( ndo , p - 1 , length ) ; return ; } switch ( proto ) { case PPP_LCP : case PPP_IPCP : case PPP_OSICP : case PPP_MPLSCP : case PPP_IPV6CP : case PPP_CCP : case PPP_BACP : handle_ctrl_proto ( ndo , proto , p , length ) ; break ; case PPP_ML : handle_mlppp ( ndo , p , length ) ; break ; case PPP_CHAP : handle_chap ( ndo , p , length ) ; break ; case PPP_PAP : handle_pap ( ndo , p , length ) ; break ; case PPP_BAP : handle_bap ( ndo , p , length ) ; break ; case ETHERTYPE_IP : case PPP_VJNC : case PPP_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : case PPP_IPV6 : ip6_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPX : case PPP_IPX : ipx_print ( ndo , p , length ) ; break ; case PPP_OSI : isoclns_print ( ndo , p , length , length ) ; break ; case PPP_MPLS_UCAST : case PPP_MPLS_MCAST : mpls_print ( ndo , p , length ) ; break ; case PPP_COMP : ND_PRINT ( ( ndo , ""compressed<S2SV_blank>PPP<S2SV_blank>data"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , tok2str ( ppptype2str , ""unknown<S2SV_blank>PPP<S2SV_blank>protocol<S2SV_blank>(0x%04x)"" , proto ) ) ) ; print_unknown_data ( ndo , p , ""\\n\\t"" , length ) ; break ; } }
","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,"<S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug>"
4555,CWE-125,"mod_ty Ta3AST_FromNodeObject ( const node * n , PyCompilerFlags * flags , PyObject * filename , int feature_version , PyArena * arena ) { int i , j , k , num ; asdl_seq * stmts = NULL ; asdl_seq * type_ignores = NULL ; stmt_ty s ; node * ch ; struct compiling c ; mod_ty res = NULL ; asdl_seq * argtypes = NULL ; expr_ty ret , arg ; c . c_arena = arena ; c . c_filename = filename ; c . c_normalize = NULL ; c . c_normalize_args = NULL ; c . c_feature_version = feature_version ; if ( TYPE ( n ) == encoding_decl ) n = CHILD ( n , 0 ) ; k = 0 ; switch ( TYPE ( n ) ) { case file_input : stmts = _Ta3_asdl_seq_new ( num_stmts ( n ) , arena ) ; if ( ! stmts ) goto out ; for ( i = 0 ; i < NCH ( n ) - 1 ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == NEWLINE ) continue ; REQ ( ch , stmt ) ; num = num_stmts ( ch ) ; if ( num == 1 ) { s = ast_for_stmt ( & c , ch ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , k ++ , s ) ; } else { ch = CHILD ( ch , 0 ) ; REQ ( ch , simple_stmt ) ; for ( j = 0 ; j < num ; j ++ ) { s = ast_for_stmt ( & c , CHILD ( ch , j * 2 ) ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , k ++ , s ) ; } } } ch = CHILD ( n , NCH ( n ) - 1 ) ; REQ ( ch , ENDMARKER ) ; num = NCH ( ch ) ; type_ignores = _Ta3_asdl_seq_new ( num , arena ) ; if ( ! type_ignores ) goto out ; for ( i = 0 ; i < num ; i ++ ) { type_ignore_ty ti = TypeIgnore ( LINENO ( CHILD ( ch , i ) ) , arena ) ; if ( ! ti ) goto out ; asdl_seq_SET ( type_ignores , i , ti ) ; } res = Module ( stmts , type_ignores , arena ) ; break ; case eval_input : { expr_ty testlist_ast ; testlist_ast = ast_for_testlist ( & c , CHILD ( n , 0 ) ) ; if ( ! testlist_ast ) goto out ; res = Expression ( testlist_ast , arena ) ; break ; } case single_input : if ( TYPE ( CHILD ( n , 0 ) ) == NEWLINE ) { stmts = _Ta3_asdl_seq_new ( 1 , arena ) ; if ( ! stmts ) goto out ; asdl_seq_SET ( stmts , 0 , Pass ( n -> n_lineno , n -> n_col_offset , arena ) ) ; if ( ! asdl_seq_GET ( stmts , 0 ) ) goto out ; res = Interactive ( stmts , arena ) ; } else { n = CHILD ( n , 0 ) ; num = num_stmts ( n ) ; stmts = _Ta3_asdl_seq_new ( num , arena ) ; if ( ! stmts ) goto out ; if ( num == 1 ) { s = ast_for_stmt ( & c , n ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , 0 , s ) ; } else { REQ ( n , simple_stmt ) ; for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { if ( TYPE ( CHILD ( n , i ) ) == NEWLINE ) break ; s = ast_for_stmt ( & c , CHILD ( n , i ) ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , i / 2 , s ) ; } } res = Interactive ( stmts , arena ) ; } break ; case func_type_input : n = CHILD ( n , 0 ) ; REQ ( n , func_type ) ; if ( TYPE ( CHILD ( n , 1 ) ) == typelist ) { ch = CHILD ( n , 1 ) ; num = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) num ++ ; } argtypes = _Ta3_asdl_seq_new ( num , arena ) ; j = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { arg = ast_for_expr ( & c , CHILD ( ch , i ) ) ; if ( ! arg ) goto out ; asdl_seq_SET ( argtypes , j ++ , arg ) ; } } } else argtypes = _Ta3_asdl_seq_new ( 0 , arena ) ; ret = ast_for_expr ( & c , CHILD ( n , NCH ( n ) - 1 ) ) ; if ( ! ret ) goto out ; res = FunctionType ( argtypes , ret , arena ) ; break ; default : PyErr_Format ( PyExc_SystemError , ""invalid<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>Ta3AST_FromNode"" , TYPE ( n ) ) ; goto out ; } out : if ( c . c_normalize ) { Py_DECREF ( c . c_normalize ) ; PyTuple_SET_ITEM ( c . c_normalize_args , 1 , NULL ) ; Py_DECREF ( c . c_normalize_args ) ; } return res ; }
","<S2SV_ModStart> ; c . <S2SV_ModEnd> c_feature_version = feature_version <S2SV_ModStart> c_normalize ) ; <S2SV_ModEnd> } return res
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> c . c_normalize_args = NULL ; <S2SV_EndBug> <S2SV_StartBug> PyTuple_SET_ITEM ( c . c_normalize_args , 1 , NULL ) ; <S2SV_EndBug>"
6522,CWE-119,"cJSON * cJSON_CreateBool ( int b ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = b ? cJSON_True : cJSON_False ; return item ; }
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,
661,CWE-125,"void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) { if ( fields -> Len > 0 ) { Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Write ( s , fields -> Buffer , fields -> Len ) ; } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z,"<S2SV_StartBug> void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug>"
2703,CWE-119,"static __init int sctp_init ( void ) { int i ; int status = - EINVAL ; unsigned long goal ; unsigned long limit ; int max_share ; int order ; sock_skb_cb_check_size ( sizeof ( struct sctp_ulpevent ) ) ; status = - ENOBUFS ; sctp_bucket_cachep = kmem_cache_create ( ""sctp_bind_bucket"" , sizeof ( struct sctp_bind_bucket ) , 0 , SLAB_HWCACHE_ALIGN , NULL ) ; if ( ! sctp_bucket_cachep ) goto out ; sctp_chunk_cachep = kmem_cache_create ( ""sctp_chunk"" , sizeof ( struct sctp_chunk ) , 0 , SLAB_HWCACHE_ALIGN , NULL ) ; if ( ! sctp_chunk_cachep ) goto err_chunk_cachep ; status = percpu_counter_init ( & sctp_sockets_allocated , 0 , GFP_KERNEL ) ; if ( status ) goto err_percpu_counter_init ; sctp_max_instreams = SCTP_DEFAULT_INSTREAMS ; sctp_max_outstreams = SCTP_DEFAULT_OUTSTREAMS ; idr_init ( & sctp_assocs_id ) ; limit = nr_free_buffer_pages ( ) / 8 ; limit = max ( limit , 128UL ) ; sysctl_sctp_mem [ 0 ] = limit / 4 * 3 ; sysctl_sctp_mem [ 1 ] = limit ; sysctl_sctp_mem [ 2 ] = sysctl_sctp_mem [ 0 ] * 2 ; limit = ( sysctl_sctp_mem [ 1 ] ) << ( PAGE_SHIFT - 7 ) ; max_share = min ( 4UL * 1024 * 1024 , limit ) ; sysctl_sctp_rmem [ 0 ] = SK_MEM_QUANTUM ; sysctl_sctp_rmem [ 1 ] = 1500 * SKB_TRUESIZE ( 1 ) ; sysctl_sctp_rmem [ 2 ] = max ( sysctl_sctp_rmem [ 1 ] , max_share ) ; sysctl_sctp_wmem [ 0 ] = SK_MEM_QUANTUM ; sysctl_sctp_wmem [ 1 ] = 16 * 1024 ; sysctl_sctp_wmem [ 2 ] = max ( 64 * 1024 , max_share ) ; if ( totalram_pages >= ( 128 * 1024 ) ) goal = totalram_pages >> ( 22 - PAGE_SHIFT ) ; else goal = totalram_pages >> ( 24 - PAGE_SHIFT ) ; for ( order = 0 ; ( 1UL << order ) < goal ; order ++ ) ; do { sctp_assoc_hashsize = ( 1UL << order ) * PAGE_SIZE / sizeof ( struct sctp_hashbucket ) ; if ( ( sctp_assoc_hashsize > ( 64 * 1024 ) ) && order > 0 ) continue ; sctp_assoc_hashtable = ( struct sctp_hashbucket * ) __get_free_pages ( GFP_ATOMIC | __GFP_NOWARN , order ) ; } while ( ! sctp_assoc_hashtable && -- order > 0 ) ; if ( ! sctp_assoc_hashtable ) { pr_err ( ""Failed<S2SV_blank>association<S2SV_blank>hash<S2SV_blank>alloc\\n"" ) ; status = - ENOMEM ; goto err_ahash_alloc ; } for ( i = 0 ; i < sctp_assoc_hashsize ; i ++ ) { rwlock_init ( & sctp_assoc_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_assoc_hashtable [ i ] . chain ) ; } sctp_ep_hashsize = 64 ; sctp_ep_hashtable = kmalloc ( 64 * sizeof ( struct sctp_hashbucket ) , GFP_KERNEL ) ; if ( ! sctp_ep_hashtable ) { pr_err ( ""Failed<S2SV_blank>endpoint_hash<S2SV_blank>alloc\\n"" ) ; status = - ENOMEM ; goto err_ehash_alloc ; } for ( i = 0 ; i < sctp_ep_hashsize ; i ++ ) { rwlock_init ( & sctp_ep_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_ep_hashtable [ i ] . chain ) ; } do { sctp_port_hashsize = ( 1UL << order ) * PAGE_SIZE / sizeof ( struct sctp_bind_hashbucket ) ; if ( ( sctp_port_hashsize > ( 64 * 1024 ) ) && order > 0 ) continue ; sctp_port_hashtable = ( struct sctp_bind_hashbucket * ) __get_free_pages ( GFP_ATOMIC | __GFP_NOWARN , order ) ; } while ( ! sctp_port_hashtable && -- order > 0 ) ; if ( ! sctp_port_hashtable ) { pr_err ( ""Failed<S2SV_blank>bind<S2SV_blank>hash<S2SV_blank>alloc\\n"" ) ; status = - ENOMEM ; goto err_bhash_alloc ; } for ( i = 0 ; i < sctp_port_hashsize ; i ++ ) { spin_lock_init ( & sctp_port_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_port_hashtable [ i ] . chain ) ; } pr_info ( ""Hash<S2SV_blank>tables<S2SV_blank>configured<S2SV_blank>(established<S2SV_blank>%d<S2SV_blank>bind<S2SV_blank>%d)\\n"" , sctp_assoc_hashsize , sctp_port_hashsize ) ; sctp_sysctl_register ( ) ; INIT_LIST_HEAD ( & sctp_address_families ) ; sctp_v4_pf_init ( ) ; sctp_v6_pf_init ( ) ; status = sctp_v4_protosw_init ( ) ; if ( status ) goto err_protosw_init ; status = sctp_v6_protosw_init ( ) ; if ( status ) goto err_v6_protosw_init ; status = register_pernet_subsys ( & sctp_net_ops ) ; if ( status ) goto err_register_pernet_subsys ; status = sctp_v4_add_protocol ( ) ; if ( status ) goto err_add_protocol ; status = sctp_v6_add_protocol ( ) ; if ( status ) goto err_v6_add_protocol ; out : return status ; err_v6_add_protocol : sctp_v4_del_protocol ( ) ; err_add_protocol : unregister_pernet_subsys ( & sctp_net_ops ) ; err_register_pernet_subsys : sctp_v6_protosw_exit ( ) ; err_v6_protosw_init : sctp_v4_protosw_exit ( ) ; err_protosw_init : sctp_v4_pf_exit ( ) ; sctp_v6_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; err_bhash_alloc : kfree ( sctp_ep_hashtable ) ; err_ehash_alloc : free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; err_ahash_alloc : percpu_counter_destroy ( & sctp_sockets_allocated ) ; err_percpu_counter_init : kmem_cache_destroy ( sctp_chunk_cachep ) ; err_chunk_cachep : kmem_cache_destroy ( sctp_bucket_cachep ) ; goto out ; }
","<S2SV_ModStart> ; status = register_pernet_subsys ( & sctp_defaults_ops ) ; if ( status ) goto err_register_defaults ; status = <S2SV_ModStart> register_pernet_subsys ( & sctp_ctrlsock_ops ) ; if ( status ) goto err_register_ctrlsock <S2SV_ModEnd> ; status = <S2SV_ModStart> unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ; err_register_ctrlsock <S2SV_ModEnd> : sctp_v6_protosw_exit ( <S2SV_ModStart> ) ; err_protosw_init : unregister_pernet_subsys ( & sctp_defaults_ops ) ; err_register_defaults
",torvalds@linux/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4,CVE-2015-5283,https://github.com/torvalds/linux/commit/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4,2015-10-19T10:59Z,<S2SV_StartBug> status = sctp_v4_protosw_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> status = register_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> err_protosw_init : <S2SV_EndBug>
3045,CWE-125,"static int jpc_pi_nextrpcl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; uint_fast32_t trx0 ; uint_fast32_t try0 ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pchg -> rlvlnoend && pi -> rlvlno < pi -> maxrlvls ; ++ pi -> rlvlno ) { for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || ! ( pi -> x % ( 1 << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || ! ( pi -> y % ( 1 << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
","<S2SV_ModStart> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> x % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy ) <S2SV_ModStart> y % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )
",mdadams@jasper/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,CVE-2016-9583,https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,2018-08-01T17:29Z,<S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> x % ( 1 << rpx ) ) ) && <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> y % ( 1 << rpy ) ) ) ) { <S2SV_EndBug>
2172,CWE-119,"static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { # ifndef _MSC_VER char buf [ EXT2_BLOCK_SIZE ( data ) ] ; # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) return 0 ; else { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; return fileblock + start ; } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; return - 1 ; } } if ( fileblock < INDIRECT_BLOCKS ) { blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; } else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; if ( ! indir ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; if ( ! indir ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }
","<S2SV_ModStart> EXT4_EXTENTS_FLAG ) { char * buf = grub_malloc ( <S2SV_ModEnd> EXT2_BLOCK_SIZE ( data <S2SV_ModStart> ( data ) ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> struct grub_ext4_extent_header * <S2SV_ModStart> GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; free ( buf <S2SV_ModStart> len ) ) { free ( buf ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> start ) ; free ( buf ) ; <S2SV_ModStart> ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; free ( buf ) ; <S2SV_ModStart> 1 ; } free ( buf ) ; <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; }
",radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char buf [ EXT2_BLOCK_SIZE ( data ) ] ; <S2SV_EndBug> <S2SV_StartBug> grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> return fileblock + start ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug>"
6412,CWE-787,"GF_Err tenc_box_read ( GF_Box * s , GF_BitStream * bs ) { u8 iv_size ; GF_TrackEncryptionBox * ptr = ( GF_TrackEncryptionBox * ) s ; ISOM_DECREASE_SIZE ( ptr , 3 ) ; gf_bs_read_u8 ( bs ) ; if ( ! ptr -> version ) { gf_bs_read_u8 ( bs ) ; } else { ptr -> crypt_byte_block = gf_bs_read_int ( bs , 4 ) ; ptr -> skip_byte_block = gf_bs_read_int ( bs , 4 ) ; } ptr -> isProtected = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , 17 ) ; ptr -> key_info [ 0 ] = 0 ; ptr -> key_info [ 1 ] = 0 ; ptr -> key_info [ 2 ] = 0 ; ptr -> key_info [ 3 ] = iv_size = gf_bs_read_u8 ( bs ) ; gf_bs_read_data ( bs , ptr -> key_info + 4 , 16 ) ; if ( ! iv_size && ptr -> isProtected ) { ISOM_DECREASE_SIZE ( ptr , 1 ) ; iv_size = ptr -> key_info [ 20 ] = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , ptr -> key_info [ 20 ] ) ; gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ; } return GF_OK ; }
","<S2SV_ModStart> ] ) ; if ( ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>constant<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; ptr -> key_info [ 20 ] = 16 ; return GF_NON_COMPLIANT_BITSTREAM ; } <S2SV_ModStart> ) ; } else if ( ( iv_size != 0 ) && ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; return GF_NON_COMPLIANT_BITSTREAM ; }
",gpac@gpac/8986422c21fbd9a7bf6561cae65aae42077447e8,CVE-2021-31254,https://github.com/gpac/gpac/commit/8986422c21fbd9a7bf6561cae65aae42077447e8,2021-04-19T19:15Z,"<S2SV_StartBug> gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ; <S2SV_EndBug> <S2SV_StartBug> return GF_OK ; <S2SV_EndBug>"
799,CWE-772,"int virtio_gpu_object_create ( struct virtio_gpu_device * vgdev , unsigned long size , bool kernel , bool pinned , struct virtio_gpu_object * * bo_ptr ) { struct virtio_gpu_object * bo ; enum ttm_bo_type type ; size_t acc_size ; int ret ; if ( kernel ) type = ttm_bo_type_kernel ; else type = ttm_bo_type_device ; * bo_ptr = NULL ; acc_size = ttm_bo_dma_acc_size ( & vgdev -> mman . bdev , size , sizeof ( struct virtio_gpu_object ) ) ; bo = kzalloc ( sizeof ( struct virtio_gpu_object ) , GFP_KERNEL ) ; if ( bo == NULL ) return - ENOMEM ; size = roundup ( size , PAGE_SIZE ) ; ret = drm_gem_object_init ( vgdev -> ddev , & bo -> gem_base , size ) ; if ( ret != 0 ) return ret ; bo -> dumb = false ; virtio_gpu_init_ttm_placement ( bo , pinned ) ; ret = ttm_bo_init ( & vgdev -> mman . bdev , & bo -> tbo , size , type , & bo -> placement , 0 , ! kernel , NULL , acc_size , NULL , NULL , & virtio_gpu_ttm_bo_destroy ) ; if ( ret != 0 ) return ret ; * bo_ptr = bo ; return 0 ; }
","<S2SV_ModStart> != 0 ) { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> bo -> dumb
",torvalds@linux/385aee965b4e4c36551c362a334378d2985b722a,CVE-2017-10810,https://github.com/torvalds/linux/commit/385aee965b4e4c36551c362a334378d2985b722a,2017-07-04T20:29Z,<S2SV_StartBug> return ret ; <S2SV_EndBug>
961,CWE-119,"static int ExecuteSQL ( SQLHDBC hDbc , char * szSQL , char cDelimiter , int bColumnNames , int bHTMLTable ) { SQLHSTMT hStmt ; SQLTCHAR szSepLine [ 32001 ] ; SQLTCHAR szUcSQL [ 32001 ] ; SQLSMALLINT cols ; SQLINTEGER ret ; SQLLEN nRows = 0 ; szSepLine [ 0 ] = 0 ; ansi_to_unicode ( szSQL , szUcSQL ) ; if ( SQLAllocStmt ( hDbc , & hStmt ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , 0 ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLAllocStmt\\n"" ) ; return 0 ; } if ( buseED ) { ret = SQLExecDirect ( hStmt , szUcSQL , SQL_NTS ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n"" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n"" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecDirect\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; free ( szSepLine ) ; return 0 ; } } else { if ( SQLPrepare ( hStmt , szUcSQL , SQL_NTS ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLPrepare\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } ret = SQLExecute ( hStmt ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n"" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n"" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecute\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } } do { if ( SQLNumResultCols ( hStmt , & cols ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLNumResultCols\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } if ( cols > 0 ) { if ( bHTMLTable ) WriteHeaderHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteHeaderNormal ( hStmt , szSepLine ) ; else if ( cDelimiter && bColumnNames ) WriteHeaderDelimited ( hStmt , cDelimiter ) ; if ( bHTMLTable ) WriteBodyHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) nRows = WriteBodyNormal ( hStmt ) ; else WriteBodyDelimited ( hStmt , cDelimiter ) ; } if ( bHTMLTable ) WriteFooterHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteFooterNormal ( hStmt , szSepLine , nRows ) ; } while ( SQL_SUCCEEDED ( SQLMoreResults ( hStmt ) ) ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 1 ; }
","<S2SV_ModStart> SQL_DROP ) ; <S2SV_ModEnd> return 0 ;
",lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f,CVE-2018-7485,https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f#diff-d52750c7ba4e594410438569d8e2963aL24,2018-02-26T14:29Z,<S2SV_StartBug> free ( szSepLine ) ; <S2SV_EndBug>
6433,CWE-78,"static char_u * do_one_cmd ( char_u * * cmdlinep , int sourcing , # ifdef FEAT_EVAL struct condstack * cstack , # endif char_u * ( * fgetline ) ( int , void * , int ) , void * cookie ) { char_u * p ; linenr_T lnum ; long n ; char * errormsg = NULL ; char_u * after_modifier = NULL ; exarg_T ea ; int save_msg_scroll = msg_scroll ; cmdmod_T save_cmdmod ; int ni ; char_u * cmd ; vim_memset ( & ea , 0 , sizeof ( ea ) ) ; ea . line1 = 1 ; ea . line2 = 1 ; # ifdef FEAT_EVAL ++ ex_nesting_level ; # endif if ( quitmore # ifdef FEAT_EVAL && ! getline_equal ( fgetline , cookie , get_func_line ) # endif && ! getline_equal ( fgetline , cookie , getnextac ) ) -- quitmore ; save_cmdmod = cmdmod ; if ( ( * cmdlinep ) [ 0 ] == '#' && ( * cmdlinep ) [ 1 ] == '!' ) goto doend ; ea . cmd = * cmdlinep ; ea . cmdlinep = cmdlinep ; ea . getline = fgetline ; ea . cookie = cookie ; # ifdef FEAT_EVAL ea . cstack = cstack ; # endif if ( parse_command_modifiers ( & ea , & errormsg , FALSE ) == FAIL ) goto doend ; after_modifier = ea . cmd ; # ifdef FEAT_EVAL ea . skip = did_emsg || got_int || did_throw || ( cstack -> cs_idx >= 0 && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & CSF_ACTIVE ) ) ; # else ea . skip = ( if_level > 0 ) ; # endif cmd = ea . cmd ; ea . cmd = skip_range ( ea . cmd , NULL ) ; if ( * ea . cmd == '*' && vim_strchr ( p_cpo , CPO_STAR ) == NULL ) ea . cmd = skipwhite ( ea . cmd + 1 ) ; p = find_command ( & ea , NULL ) ; # ifdef FEAT_EVAL # ifdef FEAT_PROFILE if ( do_profiling == PROF_YES && ( ! ea . skip || cstack -> cs_idx == 0 || ( cstack -> cs_idx > 0 && ( cstack -> cs_flags [ cstack -> cs_idx - 1 ] & CSF_ACTIVE ) ) ) ) { int skip = did_emsg || got_int || did_throw ; if ( ea . cmdidx == CMD_catch ) skip = ! skip && ! ( cstack -> cs_idx >= 0 && ( cstack -> cs_flags [ cstack -> cs_idx ] & CSF_THROWN ) && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & CSF_CAUGHT ) ) ; else if ( ea . cmdidx == CMD_else || ea . cmdidx == CMD_elseif ) skip = skip || ! ( cstack -> cs_idx >= 0 && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & ( CSF_ACTIVE | CSF_TRUE ) ) ) ; else if ( ea . cmdidx == CMD_finally ) skip = FALSE ; else if ( ea . cmdidx != CMD_endif && ea . cmdidx != CMD_endfor && ea . cmdidx != CMD_endtry && ea . cmdidx != CMD_endwhile ) skip = ea . skip ; if ( ! skip ) { if ( getline_equal ( fgetline , cookie , get_func_line ) ) func_line_exec ( getline_cookie ( fgetline , cookie ) ) ; else if ( getline_equal ( fgetline , cookie , getsourceline ) ) script_line_exec ( ) ; } } # endif dbg_check_breakpoint ( & ea ) ; if ( ! ea . skip && got_int ) { ea . skip = TRUE ; ( void ) do_intthrow ( cstack ) ; } # endif if ( ! IS_USER_CMDIDX ( ea . cmdidx ) ) { if ( ea . cmdidx != CMD_SIZE ) ea . addr_type = cmdnames [ ( int ) ea . cmdidx ] . cmd_addr_type ; else ea . addr_type = ADDR_LINES ; if ( ea . cmdidx == CMD_wincmd && p != NULL ) get_wincmd_addr_type ( skipwhite ( p ) , & ea ) ; } ea . cmd = cmd ; if ( parse_cmd_address ( & ea , & errormsg , FALSE ) == FAIL ) goto doend ; ea . cmd = skipwhite ( ea . cmd ) ; while ( * ea . cmd == ':' ) ea . cmd = skipwhite ( ea . cmd + 1 ) ; if ( * ea . cmd == NUL || * ea . cmd == \'""\' || ( ea . nextcmd = check_nextcmd ( ea . cmd ) ) != NULL ) { if ( ea . skip ) goto doend ; if ( * ea . cmd == '|' || ( exmode_active && ea . line1 != ea . line2 ) ) { ea . cmdidx = CMD_print ; ea . argt = RANGE + COUNT + TRLBAR ; if ( ( errormsg = invalid_range ( & ea ) ) == NULL ) { correct_range ( & ea ) ; ex_print ( & ea ) ; } } else if ( ea . addr_count != 0 ) { if ( ea . line2 > curbuf -> b_ml . ml_line_count ) { if ( vim_strchr ( p_cpo , CPO_MINUS ) != NULL ) ea . line2 = - 1 ; else ea . line2 = curbuf -> b_ml . ml_line_count ; } if ( ea . line2 < 0 ) errormsg = _ ( e_invrange ) ; else { if ( ea . line2 == 0 ) curwin -> w_cursor . lnum = 1 ; else curwin -> w_cursor . lnum = ea . line2 ; beginline ( BL_SOL | BL_FIX ) ; } } goto doend ; } if ( p != NULL && ea . cmdidx == CMD_SIZE && ! ea . skip && ASCII_ISUPPER ( * ea . cmd ) && has_cmdundefined ( ) ) { int ret ; p = ea . cmd ; while ( ASCII_ISALNUM ( * p ) ) ++ p ; p = vim_strnsave ( ea . cmd , ( int ) ( p - ea . cmd ) ) ; ret = apply_autocmds ( EVENT_CMDUNDEFINED , p , p , TRUE , NULL ) ; vim_free ( p ) ; p = ( ret # ifdef FEAT_EVAL && ! aborting ( ) # endif ) ? find_command ( & ea , NULL ) : ea . cmd ; } # ifdef FEAT_USR_CMDS if ( p == NULL ) { if ( ! ea . skip ) errormsg = _ ( ""E464:<S2SV_blank>Ambiguous<S2SV_blank>use<S2SV_blank>of<S2SV_blank>user-defined<S2SV_blank>command"" ) ; goto doend ; } if ( * p == '!' && ea . cmd [ 1 ] == 0151 && ea . cmd [ 0 ] == 78 && ! IS_USER_CMDIDX ( ea . cmdidx ) ) { errormsg = uc_fun_cmd ( ) ; goto doend ; } # endif if ( ea . cmdidx == CMD_SIZE ) { if ( ! ea . skip ) { STRCPY ( IObuff , _ ( ""E492:<S2SV_blank>Not<S2SV_blank>an<S2SV_blank>editor<S2SV_blank>command"" ) ) ; if ( ! sourcing ) { if ( after_modifier != NULL ) append_command ( after_modifier ) ; else append_command ( * cmdlinep ) ; } errormsg = ( char * ) IObuff ; did_emsg_syntax = TRUE ; } goto doend ; } ni = ( ! IS_USER_CMDIDX ( ea . cmdidx ) && ( cmdnames [ ea . cmdidx ] . cmd_func == ex_ni # ifdef HAVE_EX_SCRIPT_NI || cmdnames [ ea . cmdidx ] . cmd_func == ex_script_ni # endif ) ) ; # ifndef FEAT_EVAL if ( ea . cmdidx == CMD_if ) ++ if_level ; if ( if_level ) { if ( ea . cmdidx == CMD_endif ) -- if_level ; goto doend ; } # endif if ( * p == '!' && ea . cmdidx != CMD_substitute && ea . cmdidx != CMD_smagic && ea . cmdidx != CMD_snomagic ) { ++ p ; ea . forceit = TRUE ; } else ea . forceit = FALSE ; if ( ! IS_USER_CMDIDX ( ea . cmdidx ) ) ea . argt = ( long ) cmdnames [ ( int ) ea . cmdidx ] . cmd_argt ; if ( ! ea . skip ) { # ifdef HAVE_SANDBOX if ( sandbox != 0 && ! ( ea . argt & SBOXOK ) ) { errormsg = _ ( e_sandbox ) ; goto doend ; } # endif if ( ! curbuf -> b_p_ma && ( ea . argt & MODIFY ) ) { errormsg = _ ( e_modifiable ) ; goto doend ; } if ( text_locked ( ) && ! ( ea . argt & CMDWIN ) && ! IS_USER_CMDIDX ( ea . cmdidx ) ) { errormsg = _ ( get_text_locked_msg ( ) ) ; goto doend ; } if ( ! ( ea . argt & CMDWIN ) && ea . cmdidx != CMD_checktime && ea . cmdidx != CMD_edit && ea . cmdidx != CMD_file && ! IS_USER_CMDIDX ( ea . cmdidx ) && curbuf_locked ( ) ) goto doend ; if ( ! ni && ! ( ea . argt & RANGE ) && ea . addr_count > 0 ) { errormsg = _ ( e_norange ) ; goto doend ; } } if ( ! ni && ! ( ea . argt & BANG ) && ea . forceit ) { errormsg = _ ( e_nobang ) ; goto doend ; } if ( ! ea . skip && ! ni ) { if ( ! global_busy && ea . line1 > ea . line2 ) { if ( msg_silent == 0 ) { if ( sourcing || exmode_active ) { errormsg = _ ( ""E493:<S2SV_blank>Backwards<S2SV_blank>range<S2SV_blank>given"" ) ; goto doend ; } if ( ask_yesno ( ( char_u * ) _ ( ""Backwards<S2SV_blank>range<S2SV_blank>given,<S2SV_blank>OK<S2SV_blank>to<S2SV_blank>swap"" ) , FALSE ) != 'y' ) goto doend ; } lnum = ea . line1 ; ea . line1 = ea . line2 ; ea . line2 = lnum ; } if ( ( errormsg = invalid_range ( & ea ) ) != NULL ) goto doend ; } if ( ( ea . argt & NOTADR ) && ea . addr_count == 0 ) ea . line2 = 1 ; correct_range ( & ea ) ; # ifdef FEAT_FOLDING if ( ( ( ea . argt & WHOLEFOLD ) || ea . addr_count >= 2 ) && ! global_busy && ea . addr_type == ADDR_LINES ) { ( void ) hasFolding ( ea . line1 , & ea . line1 , NULL ) ; ( void ) hasFolding ( ea . line2 , NULL , & ea . line2 ) ; } # endif # ifdef FEAT_QUICKFIX p = replace_makeprg ( & ea , p , cmdlinep ) ; if ( p == NULL ) goto doend ; # endif if ( ea . cmdidx == CMD_bang ) ea . arg = p ; else ea . arg = skipwhite ( p ) ; if ( ea . cmdidx == CMD_file && * ea . arg != NUL && curbuf_locked ( ) ) goto doend ; if ( ea . argt & ARGOPT ) while ( ea . arg [ 0 ] == '+' && ea . arg [ 1 ] == '+' ) if ( getargopt ( & ea ) == FAIL && ! ni ) { errormsg = _ ( e_invarg ) ; goto doend ; } if ( ea . cmdidx == CMD_write || ea . cmdidx == CMD_update ) { if ( * ea . arg == '>' ) { if ( * ++ ea . arg != '>' ) { errormsg = _ ( ""E494:<S2SV_blank>Use<S2SV_blank>w<S2SV_blank>or<S2SV_blank>w>>"" ) ; goto doend ; } ea . arg = skipwhite ( ea . arg + 1 ) ; ea . append = TRUE ; } else if ( * ea . arg == '!' && ea . cmdidx == CMD_write ) { ++ ea . arg ; ea . usefilter = TRUE ; } } if ( ea . cmdidx == CMD_read ) { if ( ea . forceit ) { ea . usefilter = TRUE ; ea . forceit = FALSE ; } else if ( * ea . arg == '!' ) { ++ ea . arg ; ea . usefilter = TRUE ; } } if ( ea . cmdidx == CMD_lshift || ea . cmdidx == CMD_rshift ) { ea . amount = 1 ; while ( * ea . arg == * ea . cmd ) { ++ ea . arg ; ++ ea . amount ; } ea . arg = skipwhite ( ea . arg ) ; } if ( ( ea . argt & EDITCMD ) && ! ea . usefilter ) ea . do_ecmd_cmd = getargcmd ( & ea . arg ) ; if ( ( ea . argt & TRLBAR ) && ! ea . usefilter ) separate_nextcmd ( & ea ) ; else if ( ea . cmdidx == CMD_bang || ea . cmdidx == CMD_terminal || ea . cmdidx == CMD_global || ea . cmdidx == CMD_vglobal || ea . usefilter ) { for ( p = ea . arg ; * p ; ++ p ) { if ( * p == '\\\\' && p [ 1 ] == '\\n' ) STRMOVE ( p , p + 1 ) ; else if ( * p == '\\n' ) { ea . nextcmd = p + 1 ; * p = NUL ; break ; } } } if ( ( ea . argt & DFLALL ) && ea . addr_count == 0 ) { buf_T * buf ; ea . line1 = 1 ; switch ( ea . addr_type ) { case ADDR_LINES : ea . line2 = curbuf -> b_ml . ml_line_count ; break ; case ADDR_LOADED_BUFFERS : buf = firstbuf ; while ( buf -> b_next != NULL && buf -> b_ml . ml_mfp == NULL ) buf = buf -> b_next ; ea . line1 = buf -> b_fnum ; buf = lastbuf ; while ( buf -> b_prev != NULL && buf -> b_ml . ml_mfp == NULL ) buf = buf -> b_prev ; ea . line2 = buf -> b_fnum ; break ; case ADDR_BUFFERS : ea . line1 = firstbuf -> b_fnum ; ea . line2 = lastbuf -> b_fnum ; break ; case ADDR_WINDOWS : ea . line2 = LAST_WIN_NR ; break ; case ADDR_TABS : ea . line2 = LAST_TAB_NR ; break ; case ADDR_TABS_RELATIVE : ea . line2 = 1 ; break ; case ADDR_ARGUMENTS : if ( ARGCOUNT == 0 ) ea . line1 = ea . line2 = 0 ; else ea . line2 = ARGCOUNT ; break ; # ifdef FEAT_QUICKFIX case ADDR_QUICKFIX : ea . line2 = qf_get_size ( & ea ) ; if ( ea . line2 == 0 ) ea . line2 = 1 ; break ; # endif } } if ( ( ea . argt & REGSTR ) && * ea . arg != NUL && ( ! IS_USER_CMDIDX ( ea . cmdidx ) || * ea . arg != '=' ) && ! ( ( ea . argt & COUNT ) && VIM_ISDIGIT ( * ea . arg ) ) ) { # ifndef FEAT_CLIPBOARD if ( * ea . arg == '*' || * ea . arg == '+' ) { errormsg = _ ( e_invalidreg ) ; goto doend ; } # endif if ( valid_yank_reg ( * ea . arg , ( ea . cmdidx != CMD_put && ! IS_USER_CMDIDX ( ea . cmdidx ) ) ) ) { ea . regname = * ea . arg ++ ; # ifdef FEAT_EVAL if ( ea . arg [ - 1 ] == '=' && ea . arg [ 0 ] != NUL ) { set_expr_line ( vim_strsave ( ea . arg ) ) ; ea . arg += STRLEN ( ea . arg ) ; } # endif ea . arg = skipwhite ( ea . arg ) ; } } if ( ( ea . argt & COUNT ) && VIM_ISDIGIT ( * ea . arg ) && ( ! ( ea . argt & BUFNAME ) || * ( p = skipdigits ( ea . arg ) ) == NUL || VIM_ISWHITE ( * p ) ) ) { n = getdigits ( & ea . arg ) ; ea . arg = skipwhite ( ea . arg ) ; if ( n <= 0 && ! ni && ( ea . argt & ZEROR ) == 0 ) { errormsg = _ ( e_zerocount ) ; goto doend ; } if ( ea . argt & NOTADR ) { ea . line2 = n ; if ( ea . addr_count == 0 ) ea . addr_count = 1 ; } else { ea . line1 = ea . line2 ; ea . line2 += n - 1 ; ++ ea . addr_count ; if ( ea . addr_type == ADDR_LINES && ea . line2 > curbuf -> b_ml . ml_line_count ) ea . line2 = curbuf -> b_ml . ml_line_count ; } } if ( ea . argt & EXFLAGS ) get_flags ( & ea ) ; if ( ! ni && ! ( ea . argt & EXTRA ) && * ea . arg != NUL && * ea . arg != \'""\' && ( * ea . arg != '|' || ( ea . argt & TRLBAR ) == 0 ) ) { errormsg = _ ( e_trailing ) ; goto doend ; } if ( ! ni && ( ea . argt & NEEDARG ) && * ea . arg == NUL ) { errormsg = _ ( e_argreq ) ; goto doend ; } # ifdef FEAT_EVAL if ( ea . skip ) { switch ( ea . cmdidx ) { case CMD_while : case CMD_endwhile : case CMD_for : case CMD_endfor : case CMD_if : case CMD_elseif : case CMD_else : case CMD_endif : case CMD_try : case CMD_catch : case CMD_finally : case CMD_endtry : case CMD_function : break ; case CMD_aboveleft : case CMD_and : case CMD_belowright : case CMD_botright : case CMD_browse : case CMD_call : case CMD_confirm : case CMD_delfunction : case CMD_djump : case CMD_dlist : case CMD_dsearch : case CMD_dsplit : case CMD_echo : case CMD_echoerr : case CMD_echomsg : case CMD_echon : case CMD_execute : case CMD_filter : case CMD_help : case CMD_hide : case CMD_ijump : case CMD_ilist : case CMD_isearch : case CMD_isplit : case CMD_keepalt : case CMD_keepjumps : case CMD_keepmarks : case CMD_keeppatterns : case CMD_leftabove : case CMD_let : case CMD_lockmarks : case CMD_lua : case CMD_match : case CMD_mzscheme : case CMD_noautocmd : case CMD_noswapfile : case CMD_perl : case CMD_psearch : case CMD_python : case CMD_py3 : case CMD_python3 : case CMD_return : case CMD_rightbelow : case CMD_ruby : case CMD_silent : case CMD_smagic : case CMD_snomagic : case CMD_substitute : case CMD_syntax : case CMD_tab : case CMD_tcl : case CMD_throw : case CMD_tilde : case CMD_topleft : case CMD_unlet : case CMD_verbose : case CMD_vertical : case CMD_wincmd : break ; default : goto doend ; } } # endif if ( ea . argt & XFILE ) { if ( expand_filename ( & ea , cmdlinep , & errormsg ) == FAIL ) goto doend ; } if ( ( ea . argt & BUFNAME ) && * ea . arg != NUL && ea . addr_count == 0 && ! IS_USER_CMDIDX ( ea . cmdidx ) ) { if ( ea . cmdidx == CMD_bdelete || ea . cmdidx == CMD_bwipeout || ea . cmdidx == CMD_bunload ) p = skiptowhite_esc ( ea . arg ) ; else { p = ea . arg + STRLEN ( ea . arg ) ; while ( p > ea . arg && VIM_ISWHITE ( p [ - 1 ] ) ) -- p ; } ea . line2 = buflist_findpat ( ea . arg , p , ( ea . argt & BUFUNL ) != 0 , FALSE , FALSE ) ; if ( ea . line2 < 0 ) goto doend ; ea . addr_count = 1 ; ea . arg = skipwhite ( p ) ; } if ( ea . cmdidx == CMD_try && ea . did_esilent > 0 ) { emsg_silent -= ea . did_esilent ; if ( emsg_silent < 0 ) emsg_silent = 0 ; ea . did_esilent = 0 ; } # ifdef FEAT_USR_CMDS if ( IS_USER_CMDIDX ( ea . cmdidx ) ) { do_ucmd ( & ea ) ; } else # endif { ea . errmsg = NULL ; ( cmdnames [ ea . cmdidx ] . cmd_func ) ( & ea ) ; if ( ea . errmsg != NULL ) errormsg = _ ( ea . errmsg ) ; } # ifdef FEAT_EVAL if ( need_rethrow ) do_throw ( cstack ) ; else if ( check_cstack ) { if ( source_finished ( fgetline , cookie ) ) do_finish ( & ea , TRUE ) ; else if ( getline_equal ( fgetline , cookie , get_func_line ) && current_func_returned ( ) ) do_return ( & ea , TRUE , FALSE , NULL ) ; } need_rethrow = check_cstack = FALSE ; # endif doend : if ( curwin -> w_cursor . lnum == 0 ) { curwin -> w_cursor . lnum = 1 ; curwin -> w_cursor . col = 0 ; } if ( errormsg != NULL && * errormsg != NUL && ! did_emsg ) { if ( sourcing ) { if ( errormsg != ( char * ) IObuff ) { STRCPY ( IObuff , errormsg ) ; errormsg = ( char * ) IObuff ; } append_command ( * cmdlinep ) ; } emsg ( errormsg ) ; } # ifdef FEAT_EVAL do_errthrow ( cstack , ( ea . cmdidx != CMD_SIZE && ! IS_USER_CMDIDX ( ea . cmdidx ) ) ? cmdnames [ ( int ) ea . cmdidx ] . cmd_name : ( char_u * ) NULL ) ; # endif if ( ea . verbose_save >= 0 ) p_verbose = ea . verbose_save ; free_cmdmod ( ) ; cmdmod = save_cmdmod ; if ( ea . save_msg_silent != - 1 ) { if ( ! did_emsg || msg_silent > ea . save_msg_silent ) msg_silent = ea . save_msg_silent ; emsg_silent -= ea . did_esilent ; if ( emsg_silent < 0 ) emsg_silent = 0 ; msg_scroll = save_msg_scroll ; if ( redirecting ( ) ) msg_col = 0 ; } # ifdef HAVE_SANDBOX if ( ea . did_sandbox ) -- sandbox ; # endif if ( ea . nextcmd && * ea . nextcmd == NUL ) ea . nextcmd = NULL ; # ifdef FEAT_EVAL -- ex_nesting_level ; # endif return ea . nextcmd ; }
","<S2SV_ModStart> endif if ( restricted != 0 && ( ea . argt & RESTRICT ) ) { errormsg = _ ( ""E981:<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ; goto doend ; } if (
",vim@vim/8c62a08faf89663e5633dc5036cd8695c80f1075,CVE-2019-20807,https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075,2020-05-28T14:15Z,<S2SV_StartBug> if ( ! curbuf -> b_p_ma && ( ea . argt & MODIFY ) ) <S2SV_EndBug>
6338,CWE-772,"gpol_ret * get_policy_2_svc ( gpol_arg * arg , struct svc_req * rqstp ) { static gpol_ret ret ; kadm5_ret_t ret2 ; char * prime_arg , * funcname ; gss_buffer_desc client_name , service_name ; OM_uint32 minor_stat ; kadm5_principal_ent_rec caller_ent ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gpol_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_get_policy"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> name ; ret . code = KADM5_AUTH_GET ; if ( ! CHANGEPW_SERVICE ( rqstp ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , NULL , NULL ) ) ret . code = KADM5_OK ; else { ret . code = kadm5_get_principal ( handle -> lhandle , handle -> current_caller , & caller_ent , KADM5_PRINCIPAL_NORMAL_MASK ) ; if ( ret . code == KADM5_OK ) { if ( caller_ent . aux_attributes & KADM5_POLICY && strcmp ( caller_ent . policy , arg -> name ) == 0 ) { ret . code = KADM5_OK ; } else ret . code = KADM5_AUTH_GET ; ret2 = kadm5_free_principal_ent ( handle -> lhandle , & caller_ent ) ; ret . code = ret . code ? ret . code : ret2 ; } } if ( ret . code == KADM5_OK ) { ret . code = kadm5_get_policy ( handle , arg -> name , & ret . rec ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , ( ( prime_arg == NULL ) ? ""(null)"" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } else { log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; } gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug>"
2209,CWE-000,"static int iwch_l2t_send ( struct t3cdev * tdev , struct sk_buff * skb , struct l2t_entry * l2e ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = l2t_send ( tdev , skb , l2e ) ; if ( error < 0 ) kfree_skb ( skb ) ; return error ; }
","<S2SV_ModStart> ; return error < 0 ? error : 0
",torvalds@linux/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3,CVE-2015-8812,https://github.com/torvalds/linux/commit/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3,2016-04-27T17:59Z,<S2SV_StartBug> return error ; <S2SV_EndBug>
7519,CWE-416,"static int do_last ( struct nameidata * nd , struct file * file , const struct open_flags * op ) { struct dentry * dir = nd -> path . dentry ; int open_flag = op -> open_flag ; bool will_truncate = ( open_flag & O_TRUNC ) != 0 ; bool got_write = false ; int acc_mode = op -> acc_mode ; unsigned seq ; struct inode * inode ; struct path path ; int error ; nd -> flags &= ~ LOOKUP_PARENT ; nd -> flags |= op -> intent ; if ( nd -> last_type != LAST_NORM ) { error = handle_dots ( nd , nd -> last_type ) ; if ( unlikely ( error ) ) return error ; goto finish_open ; } if ( ! ( open_flag & O_CREAT ) ) { if ( nd -> last . name [ nd -> last . len ] ) nd -> flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY ; error = lookup_fast ( nd , & path , & inode , & seq ) ; if ( likely ( error > 0 ) ) goto finish_lookup ; if ( error < 0 ) return error ; BUG_ON ( nd -> inode != dir -> d_inode ) ; BUG_ON ( nd -> flags & LOOKUP_RCU ) ; } else { error = complete_walk ( nd ) ; if ( error ) return error ; audit_inode ( nd -> name , dir , AUDIT_INODE_PARENT ) ; if ( unlikely ( nd -> last . name [ nd -> last . len ] ) ) return - EISDIR ; } if ( open_flag & ( O_CREAT | O_TRUNC | O_WRONLY | O_RDWR ) ) { error = mnt_want_write ( nd -> path . mnt ) ; if ( ! error ) got_write = true ; } if ( open_flag & O_CREAT ) inode_lock ( dir -> d_inode ) ; else inode_lock_shared ( dir -> d_inode ) ; error = lookup_open ( nd , & path , file , op , got_write ) ; if ( open_flag & O_CREAT ) inode_unlock ( dir -> d_inode ) ; else inode_unlock_shared ( dir -> d_inode ) ; if ( error ) goto out ; if ( file -> f_mode & FMODE_OPENED ) { if ( ( file -> f_mode & FMODE_CREATED ) || ! S_ISREG ( file_inode ( file ) -> i_mode ) ) will_truncate = false ; audit_inode ( nd -> name , file -> f_path . dentry , 0 ) ; goto opened ; } if ( file -> f_mode & FMODE_CREATED ) { open_flag &= ~ O_TRUNC ; will_truncate = false ; acc_mode = 0 ; path_to_nameidata ( & path , nd ) ; goto finish_open_created ; } if ( got_write ) { mnt_drop_write ( nd -> path . mnt ) ; got_write = false ; } error = follow_managed ( & path , nd ) ; if ( unlikely ( error < 0 ) ) return error ; audit_inode ( nd -> name , path . dentry , 0 ) ; if ( unlikely ( ( open_flag & ( O_EXCL | O_CREAT ) ) == ( O_EXCL | O_CREAT ) ) ) { path_to_nameidata ( & path , nd ) ; return - EEXIST ; } seq = 0 ; inode = d_backing_inode ( path . dentry ) ; finish_lookup : error = step_into ( nd , & path , 0 , inode , seq ) ; if ( unlikely ( error ) ) return error ; finish_open : error = complete_walk ( nd ) ; if ( error ) return error ; audit_inode ( nd -> name , nd -> path . dentry , 0 ) ; if ( open_flag & O_CREAT ) { error = - EISDIR ; if ( d_is_dir ( nd -> path . dentry ) ) goto out ; error = may_create_in_sticky ( dir , d_backing_inode ( nd -> path . dentry ) ) ; if ( unlikely ( error ) ) goto out ; } error = - ENOTDIR ; if ( ( nd -> flags & LOOKUP_DIRECTORY ) && ! d_can_lookup ( nd -> path . dentry ) ) goto out ; if ( ! d_is_reg ( nd -> path . dentry ) ) will_truncate = false ; if ( will_truncate ) { error = mnt_want_write ( nd -> path . mnt ) ; if ( error ) goto out ; got_write = true ; } finish_open_created : error = may_open ( & nd -> path , acc_mode , open_flag ) ; if ( error ) goto out ; BUG_ON ( file -> f_mode & FMODE_OPENED ) ; error = vfs_open ( & nd -> path , file ) ; if ( error ) goto out ; opened : error = ima_file_check ( file , op -> acc_mode ) ; if ( ! error && will_truncate ) error = handle_truncate ( file ) ; out : if ( unlikely ( error > 0 ) ) { WARN_ON ( 1 ) ; error = - EINVAL ; } if ( got_write ) mnt_drop_write ( nd -> path . mnt ) ; return error ; }
","<S2SV_ModStart> path . dentry ; kuid_t dir_uid = dir -> d_inode -> i_uid ; umode_t dir_mode = dir -> d_inode -> i_mode <S2SV_ModStart> = may_create_in_sticky ( dir_mode , dir_uid <S2SV_ModEnd> , d_backing_inode (
",torvalds@linux/d0cb50185ae942b03c4327be322055d622dc79f6,CVE-2020-8428,https://github.com/torvalds/linux/commit/d0cb50185ae942b03c4327be322055d622dc79f6,2020-01-29T00:15Z,"<S2SV_StartBug> struct dentry * dir = nd -> path . dentry ; <S2SV_EndBug> <S2SV_StartBug> error = may_create_in_sticky ( dir , <S2SV_EndBug>"
943,CWE-119,"static int xwd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { AVFrame * p = data ; const uint8_t * buf = avpkt -> data ; int i , ret , buf_size = avpkt -> size ; uint32_t version , header_size , vclass , ncolors ; uint32_t xoffset , be , bpp , lsize , rsize ; uint32_t pixformat , pixdepth , bunit , bitorder , bpad ; uint32_t rgb [ 3 ] ; uint8_t * ptr ; GetByteContext gb ; if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ; bytestream2_init ( & gb , buf , buf_size ) ; header_size = bytestream2_get_be32u ( & gb ) ; version = bytestream2_get_be32u ( & gb ) ; if ( version != XWD_VERSION ) { av_log ( avctx , AV_LOG_ERROR , ""unsupported<S2SV_blank>version\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( buf_size < header_size || header_size < XWD_HEADER_SIZE ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>header<S2SV_blank>size\\n"" ) ; return AVERROR_INVALIDDATA ; } pixformat = bytestream2_get_be32u ( & gb ) ; pixdepth = bytestream2_get_be32u ( & gb ) ; avctx -> width = bytestream2_get_be32u ( & gb ) ; avctx -> height = bytestream2_get_be32u ( & gb ) ; xoffset = bytestream2_get_be32u ( & gb ) ; be = bytestream2_get_be32u ( & gb ) ; bunit = bytestream2_get_be32u ( & gb ) ; bitorder = bytestream2_get_be32u ( & gb ) ; bpad = bytestream2_get_be32u ( & gb ) ; bpp = bytestream2_get_be32u ( & gb ) ; lsize = bytestream2_get_be32u ( & gb ) ; vclass = bytestream2_get_be32u ( & gb ) ; rgb [ 0 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 1 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 2 ] = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , 8 ) ; ncolors = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , header_size - ( XWD_HEADER_SIZE - 20 ) ) ; av_log ( avctx , AV_LOG_DEBUG , ""pixformat<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bunit<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bitorder<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpad<S2SV_blank>%"" PRIu32 ""\\n"" , pixformat , pixdepth , bunit , bitorder , bpad ) ; av_log ( avctx , AV_LOG_DEBUG , ""vclass<S2SV_blank>%"" PRIu32 "",<S2SV_blank>ncolors<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>be<S2SV_blank>%"" PRIu32 "",<S2SV_blank>lsize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>xoffset<S2SV_blank>%"" PRIu32 ""\\n"" , vclass , ncolors , bpp , be , lsize , xoffset ) ; av_log ( avctx , AV_LOG_DEBUG , ""red<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>green<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>blue<S2SV_blank>%0"" PRIx32 ""\\n"" , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; if ( pixformat > XWD_Z_PIXMAP ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>format\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixdepth == 0 || pixdepth > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>depth\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( xoffset ) { avpriv_request_sample ( avctx , ""xoffset<S2SV_blank>%"" PRIu32 """" , xoffset ) ; return AVERROR_PATCHWELCOME ; } if ( be > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>byte<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bitorder > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>bit<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bunit != 8 && bunit != 16 && bunit != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>unit\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpad != 8 && bpad != 16 && bpad != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>scan-line<S2SV_blank>pad\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpp == 0 || bpp > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ncolors > 256 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>colormap\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = av_image_check_size ( avctx -> width , avctx -> height , 0 , NULL ) ) < 0 ) return ret ; rsize = FFALIGN ( avctx -> width * bpp , bpad ) / 8 ; if ( lsize < rsize ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>scan-line\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & gb ) < ncolors * XWD_CMAP_SIZE + ( uint64_t ) avctx -> height * lsize ) { av_log ( avctx , AV_LOG_ERROR , ""input<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixformat != XWD_Z_PIXMAP ) { avpriv_report_missing_feature ( avctx , ""Pixmap<S2SV_blank>format<S2SV_blank>%"" PRIu32 , pixformat ) ; return AVERROR_PATCHWELCOME ; } avctx -> pix_fmt = AV_PIX_FMT_NONE ; switch ( vclass ) { case XWD_STATIC_GRAY : case XWD_GRAY_SCALE : if ( bpp != 1 && bpp != 8 ) return AVERROR_INVALIDDATA ; if ( pixdepth == 1 ) { avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ; } else if ( pixdepth == 8 ) { avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; } break ; case XWD_STATIC_COLOR : case XWD_PSEUDO_COLOR : if ( bpp == 8 ) avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; break ; case XWD_TRUE_COLOR : case XWD_DIRECT_COLOR : if ( bpp != 16 && bpp != 24 && bpp != 32 ) return AVERROR_INVALIDDATA ; if ( bpp == 16 && pixdepth == 15 ) { if ( rgb [ 0 ] == 0x7C00 && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x7C00 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE ; } else if ( bpp == 16 && pixdepth == 16 ) { if ( rgb [ 0 ] == 0xF800 && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0xF800 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE ; } else if ( bpp == 24 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24 ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24 ; } else if ( bpp == 32 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA ; } bytestream2_skipu ( & gb , ncolors * XWD_CMAP_SIZE ) ; break ; default : av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>visual<S2SV_blank>class\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( avctx -> pix_fmt == AV_PIX_FMT_NONE ) { avpriv_request_sample ( avctx , ""Unknown<S2SV_blank>file:<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>vclass<S2SV_blank>%"" PRIu32 """" , bpp , pixdepth , vclass ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> key_frame = 1 ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { uint32_t * dst = ( uint32_t * ) p -> data [ 1 ] ; uint8_t red , green , blue ; for ( i = 0 ; i < ncolors ; i ++ ) { bytestream2_skipu ( & gb , 4 ) ; red = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; green = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; blue = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 3 ) ; dst [ i ] = red << 16 | green << 8 | blue ; } } ptr = p -> data [ 0 ] ; for ( i = 0 ; i < avctx -> height ; i ++ ) { bytestream2_get_bufferu ( & gb , ptr , rsize ) ; bytestream2_skipu ( & gb , lsize - rsize ) ; ptr += p -> linesize [ 0 ] ; } * got_frame = 1 ; return buf_size ; }
","<S2SV_ModStart> ; if ( bpp == 1 && <S2SV_ModStart> else if ( bpp == 8 &&
",FFmpeg@FFmpeg/441026fcb13ac23aa10edc312bdacb6445a0ad06,CVE-2017-9991,https://github.com/FFmpeg/FFmpeg/commit/441026fcb13ac23aa10edc312bdacb6445a0ad06,2017-06-28T06:29Z,<S2SV_StartBug> if ( pixdepth == 1 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( pixdepth == 8 ) { <S2SV_EndBug>
2249,CWE-416,"static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { pipe_buf_get ( ipipe , ibuf ) ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
","<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
",torvalds@linux/6b3a707736301c2128ca85ce85fb13f60b5e350a,CVE-2019-11487,https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a,2019-04-23T22:29Z,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug>"
7366,CWE-352,"void set_content_type ( HttpResponse res , const char * mime ) { set_header ( res , ""Content-Type"" , mime ) ; }
","<S2SV_ModStart> , ""Content-Type"" , ""%s"" ,
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,"<S2SV_StartBug> set_header ( res , ""Content-Type"" , mime ) ; <S2SV_EndBug>"
8115,CWE-295,"DH * get_dh2048 ( void ) { static unsigned char dhp_2048 [ ] = { 0xD5 , 0x75 , 0xF1 , 0x23 , 0xC1 , 0x81 , 0x4B , 0x44 , 0x23 , 0xBE , 0x97 , 0x81 , 0x7A , 0xDA , 0x97 , 0x1F , 0x1F , 0x0D , 0xD5 , 0xEC , 0xC5 , 0x5F , 0x86 , 0x42 , 0x7F , 0x38 , 0xA3 , 0x95 , 0xEE , 0xA0 , 0x52 , 0x2C , 0xB7 , 0x20 , 0x29 , 0xC1 , 0xC7 , 0xE6 , 0x8E , 0x6F , 0xE5 , 0xC1 , 0x0D , 0xDD , 0x8A , 0xEF , 0x8D , 0xE7 , 0xA8 , 0x63 , 0xB4 , 0xF7 , 0x58 , 0x32 , 0x0E , 0x24 , 0xAC , 0x30 , 0x94 , 0xF5 , 0xC7 , 0x02 , 0x81 , 0x1B , 0xC7 , 0x68 , 0xE5 , 0x71 , 0xD7 , 0x1E , 0x3D , 0xE4 , 0x2E , 0x2F , 0xC0 , 0x0A , 0xED , 0x34 , 0xAC , 0xC0 , 0x1F , 0x0A , 0x56 , 0xA4 , 0x12 , 0x02 , 0xFD , 0x68 , 0xD2 , 0x4D , 0x5E , 0x0A , 0x5D , 0x78 , 0xE3 , 0xA0 , 0x85 , 0x75 , 0xD2 , 0xA9 , 0xC1 , 0xF2 , 0xAD , 0x65 , 0x11 , 0xDE , 0xE8 , 0x05 , 0x68 , 0x36 , 0x4C , 0x92 , 0x99 , 0x21 , 0xB9 , 0x69 , 0xD0 , 0x6F , 0xD8 , 0xA3 , 0xEA , 0x35 , 0x13 , 0x93 , 0xDC , 0x1B , 0x13 , 0x16 , 0xB2 , 0x15 , 0x8E , 0x10 , 0x22 , 0xCE , 0x01 , 0x1F , 0x1C , 0x09 , 0x86 , 0xD5 , 0xE7 , 0xCB , 0xCF , 0xFA , 0xED , 0x2F , 0xE2 , 0x3A , 0x65 , 0x14 , 0xC9 , 0xFA , 0x70 , 0x99 , 0xF7 , 0xE0 , 0x30 , 0xBF , 0x7F , 0xEA , 0x84 , 0x14 , 0x8A , 0x51 , 0xC9 , 0xE9 , 0x85 , 0x73 , 0x7F , 0xA1 , 0xB0 , 0xC3 , 0x33 , 0x9A , 0xAB , 0x69 , 0x4E , 0x75 , 0xFB , 0x12 , 0xB0 , 0x9E , 0xB1 , 0xD9 , 0xD1 , 0xB9 , 0x32 , 0x1D , 0xC6 , 0xD9 , 0x2C , 0xAA , 0xB0 , 0xC5 , 0x3E , 0x69 , 0x56 , 0xA2 , 0xB3 , 0xA2 , 0x81 , 0xCA , 0x9D , 0x77 , 0xBB , 0x52 , 0x44 , 0xA2 , 0xED , 0xE0 , 0xF0 , 0x2A , 0x81 , 0x85 , 0x90 , 0xB6 , 0x04 , 0x60 , 0xEB , 0x09 , 0x72 , 0x08 , 0x44 , 0xAF , 0x28 , 0xF5 , 0x15 , 0x34 , 0x87 , 0x5C , 0x8A , 0xB4 , 0x5B , 0x15 , 0x6A , 0xAD , 0x27 , 0x4E , 0xA0 , 0xDE , 0x99 , 0x22 , 0xCF , 0xAB , 0x4C , 0xFD , 0x75 , 0x10 , 0x5D , 0xFF , 0xE8 , 0x81 , 0x50 , 0xC4 , 0xC0 , 0x4B } ; static unsigned char dhg_2048 [ ] = { 0x02 } ; DH * dh = DH_new ( ) ; BIGNUM * p , * g ; if ( dh == NULL ) return NULL ; p = BN_bin2bn ( dhp_2048 , sizeof ( dhp_2048 ) , NULL ) ; g = BN_bin2bn ( dhg_2048 , sizeof ( dhg_2048 ) , NULL ) ; if ( p == NULL || g == NULL || ! DH_set0_pqg ( dh , p , NULL , g ) ) { DH_free ( dh ) ; BN_free ( p ) ; BN_free ( g ) ; return NULL ; } return dh ; }
","<S2SV_ModStart> ] = { 0xCF , 0x9F , 0x3A , 0x9C , 0xC5 , 0xA5 , 0x89 , 0x27 , 0x6D , 0x2C , 0x2C , 0xF3 , 0xA6 , 0x00 , 0xD2 , 0x7C , 0xEA , 0xFA , 0xF2 , 0x43 , 0x4F , 0x49 , 0x0A , 0xFC , 0xA6 , 0xE7 , 0x75 , 0xCA , 0x07 , 0xDC , 0xA5 , 0xF2 , 0x83 , 0x4E , 0x5A , 0xA0 , 0xA0 , 0xF5 , 0x9C , 0xFD , 0x02 , 0xE6 , 0x9E , 0xFC , 0x01 , 0x59 , 0xD7 , 0xB6 , 0xC1 , 0x4E , 0xC0 , 0xB6 , 0x71 , 0x49 , 0xF0 , 0xC7 , 0xD5 , 0x2F , 0x8D , 0xDF , 0xD3 , 0xF1 , 0x82 , 0x82 , 0x23 , 0x33 , 0x13 , 0x93 , 0xEB , 0x50 , 0x29 , 0xFD , 0x1B , 0x5A , 0x2F , 0xD5 , 0x08 , 0x99 , 0x64 , 0xE9 , 0x7B , 0x1A , 0xDD , 0x68 , 0x16 , 0x08 , 0xD0 , 0x13 , 0x82 , 0xB6 , 0x86 , 0x62 , 0x76 , 0xAA , 0x16 , 0x14 , 0xCC , 0x86 , 0x72 , 0x26 , 0x45 , 0x8E , 0x2A , 0x82 , 0x5B , 0x6F , 0xC1 , 0xDF , 0xAA , 0x18 , 0x43 , 0xB8 , 0xAD , 0x84 , 0x52 , 0xF2 , 0xD9 , 0x9C , 0xC0 , 0x47 , 0x52 , 0x1B , 0x8E , 0x42 , 0xC4 , 0xD3 , 0x61 , 0x7B , 0x65 , 0xA7 , 0x69 , 0x03 , 0xB5 , 0xD4 , 0x6C , 0x83 , 0x6A , 0x46 , 0x73 , 0xAF , 0x76 , 0x77 , 0x70 , 0xC2 , 0xD0 , 0x74 , 0xFE , 0x78 , 0xF5 , 0x75 , 0x3B , 0xCE , 0xE2 , 0xB6 , 0xA0 , 0x25 , 0xE9 , 0xE8 , 0x4B , 0xA2 , 0xF1 , 0x20 , 0x88 , 0x13 , 0x07 , 0xED , 0x66 , 0xBC , 0x46 , 0xA1 , 0xB3 , 0x44 , 0xAF , 0x2C , 0xED , 0x73 , 0x75 , 0x3D , 0x14 , 0x6E , 0x43 , 0x92 , 0x40 , 0x99 , 0xB0 , 0xD1 , 0xBF , 0x2C , 0x4D , 0x0F , 0x2A , 0x63 , 0xF4 , 0x85 , 0x7B , 0x1B , 0x0E , 0x48 , 0x5A , 0x06 , 0x02 , 0xA6 , 0x3D , 0x9E , 0x78 , 0x05 , 0xA8 , 0x7C , 0xAD , 0x54 , 0x49 , 0xDE , 0x7A , 0xE6 , 0x36 , 0x5C , 0x50 , 0xFC , 0x09 <S2SV_ModEnd> , 0x81 , <S2SV_ModStart> , 0x81 , 0x9E , 0x83 , 0x53 , 0x8C <S2SV_ModEnd> , 0x42 , <S2SV_ModStart> , 0x42 , 0xEF , 0x12 , 0x36 , 0x4F , 0x22 , 0x16 , 0x2A , 0x15 , 0x88 , 0x83 , 0xA9 , 0x00 , 0x66 , 0x9E , 0xD1 , 0xDC , 0x0F , 0x54 , 0xC0 , 0x32 , 0x5C , 0x4C , 0x5E , 0xE2 , 0x3D , 0xBC , 0x56 , 0x89 , 0x75 , 0x28 , 0xA3 <S2SV_ModEnd> } ; static
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,"<S2SV_StartBug> 0xD5 , 0x75 , 0xF1 , 0x23 , 0xC1 , 0x81 , 0x4B , 0x44 , 0x23 , 0xBE , <S2SV_EndBug> <S2SV_StartBug> 0xC5 , 0x5F , 0x86 , 0x42 , 0x7F , 0x38 , 0xA3 , 0x95 , 0xEE , 0xA0 , <S2SV_EndBug>"
290,CWE-125,"static void babel_print_v2 ( netdissect_options * ndo , const u_char * cp , u_int length ) { u_int i ; u_short bodylen ; u_char v4_prefix [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0xFF , 0xFF , 0 , 0 , 0 , 0 } ; u_char v6_prefix [ 16 ] = { 0 } ; ND_TCHECK2 ( * cp , 4 ) ; if ( length < 4 ) goto invalid ; bodylen = EXTRACT_16BITS ( cp + 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , bodylen ) ) ; i = 0 ; while ( i < bodylen ) { const u_char * message ; u_int type , len ; message = cp + 4 + i ; ND_TCHECK2 ( * message , 1 ) ; if ( ( type = message [ 0 ] ) == MESSAGE_PAD1 ) { ND_PRINT ( ( ndo , ndo -> ndo_vflag ? ""\\n\\tPad<S2SV_blank>1"" : ""<S2SV_blank>pad1"" ) ) ; i += 1 ; continue ; } ND_TCHECK2 ( * message , 2 ) ; ICHECK ( i , 2 ) ; len = message [ 1 ] ; ND_TCHECK2 ( * message , 2 + len ) ; ICHECK ( i , 2 + len ) ; switch ( type ) { case MESSAGE_PADN : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>padN"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\tPad<S2SV_blank>%d"" , len + 2 ) ) ; } break ; case MESSAGE_ACK_REQ : { u_short nonce , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>ack-req"" ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tAcknowledgment<S2SV_blank>Request<S2SV_blank>"" ) ) ; if ( len < 6 ) goto invalid ; nonce = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; ND_PRINT ( ( ndo , ""%04x<S2SV_blank>%s"" , nonce , format_interval ( interval ) ) ) ; } } break ; case MESSAGE_ACK : { u_short nonce ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>ack"" ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tAcknowledgment<S2SV_blank>"" ) ) ; if ( len < 2 ) goto invalid ; nonce = EXTRACT_16BITS ( message + 2 ) ; ND_PRINT ( ( ndo , ""%04x"" , nonce ) ) ; } } break ; case MESSAGE_HELLO : { u_short seqno , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>hello"" ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tHello<S2SV_blank>"" ) ) ; if ( len < 6 ) goto invalid ; seqno = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; ND_PRINT ( ( ndo , ""seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s"" , seqno , format_interval ( interval ) ) ) ; if ( len > 6 ) subtlvs_print ( ndo , message + 8 , message + 2 + len , type ) ; } } break ; case MESSAGE_IHU : { unsigned short txcost , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>ihu"" ) ) ; else { u_char address [ 16 ] ; int rc ; ND_PRINT ( ( ndo , ""\\n\\tIHU<S2SV_blank>"" ) ) ; if ( len < 6 ) goto invalid ; txcost = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; rc = network_address ( message [ 2 ] , message + 8 , len - 6 , address ) ; if ( rc < 0 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; break ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank>txcost<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s"" , format_address ( ndo , address ) , txcost , format_interval ( interval ) ) ) ; if ( ( u_int ) rc < len - 6 ) subtlvs_print ( ndo , message + 8 + rc , message + 2 + len , type ) ; } } break ; case MESSAGE_ROUTER_ID : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>router-id"" ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tRouter<S2SV_blank>Id"" ) ) ; if ( len < 10 ) goto invalid ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , format_id ( message + 4 ) ) ) ; } } break ; case MESSAGE_NH : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>nh"" ) ) ; else { int rc ; u_char nh [ 16 ] ; ND_PRINT ( ( ndo , ""\\n\\tNext<S2SV_blank>Hop"" ) ) ; if ( len < 2 ) goto invalid ; rc = network_address ( message [ 2 ] , message + 4 , len - 2 , nh ) ; if ( rc < 0 ) goto invalid ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , format_address ( ndo , nh ) ) ) ; } } break ; case MESSAGE_UPDATE : { if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>update"" ) ) ; if ( len < 1 ) ND_PRINT ( ( ndo , ""/truncated"" ) ) ; else ND_PRINT ( ( ndo , ""%s%s%s"" , ( message [ 3 ] & 0x80 ) ? ""/prefix"" : """" , ( message [ 3 ] & 0x40 ) ? ""/id"" : """" , ( message [ 3 ] & 0x3f ) ? ""/unknown"" : """" ) ) ; } else { u_short interval , seqno , metric ; u_char plen ; int rc ; u_char prefix [ 16 ] ; ND_PRINT ( ( ndo , ""\\n\\tUpdate"" ) ) ; if ( len < 10 ) goto invalid ; plen = message [ 4 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; rc = network_prefix ( message [ 2 ] , message [ 4 ] , message [ 5 ] , message + 12 , message [ 2 ] == 1 ? v4_prefix : v6_prefix , len - 10 , prefix ) ; if ( rc < 0 ) goto invalid ; interval = EXTRACT_16BITS ( message + 6 ) ; seqno = EXTRACT_16BITS ( message + 8 ) ; metric = EXTRACT_16BITS ( message + 10 ) ; ND_PRINT ( ( ndo , ""%s%s%s<S2SV_blank>%s<S2SV_blank>metric<S2SV_blank>%u<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s"" , ( message [ 3 ] & 0x80 ) ? ""/prefix"" : """" , ( message [ 3 ] & 0x40 ) ? ""/id"" : """" , ( message [ 3 ] & 0x3f ) ? ""/unknown"" : """" , format_prefix ( ndo , prefix , plen ) , metric , seqno , format_interval_update ( interval ) ) ) ; if ( message [ 3 ] & 0x80 ) { if ( message [ 2 ] == 1 ) memcpy ( v4_prefix , prefix , 16 ) ; else memcpy ( v6_prefix , prefix , 16 ) ; } if ( ( u_int ) rc < len - 10 ) subtlvs_print ( ndo , message + 12 + rc , message + 2 + len , type ) ; } } break ; case MESSAGE_REQUEST : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>request"" ) ) ; else { int rc ; u_char prefix [ 16 ] , plen ; ND_PRINT ( ( ndo , ""\\n\\tRequest<S2SV_blank>"" ) ) ; if ( len < 2 ) goto invalid ; plen = message [ 3 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; rc = network_prefix ( message [ 2 ] , message [ 3 ] , 0 , message + 4 , NULL , len - 2 , prefix ) ; if ( rc < 0 ) goto invalid ; ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , message [ 2 ] == 0 ? ""any"" : format_prefix ( ndo , prefix , plen ) ) ) ; } } break ; case MESSAGE_MH_REQUEST : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>mh-request"" ) ) ; else { int rc ; u_short seqno ; u_char prefix [ 16 ] , plen ; ND_PRINT ( ( ndo , ""\\n\\tMH-Request<S2SV_blank>"" ) ) ; if ( len < 14 ) goto invalid ; seqno = EXTRACT_16BITS ( message + 4 ) ; rc = network_prefix ( message [ 2 ] , message [ 3 ] , 0 , message + 16 , NULL , len - 14 , prefix ) ; if ( rc < 0 ) goto invalid ; plen = message [ 3 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; ND_PRINT ( ( ndo , ""(%u<S2SV_blank>hops)<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>id<S2SV_blank>%s"" , message [ 6 ] , format_prefix ( ndo , prefix , plen ) , seqno , format_id ( message + 8 ) ) ) ; } } break ; case MESSAGE_TSPC : if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>tspc"" ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tTS/PC<S2SV_blank>"" ) ) ; if ( len < 6 ) goto invalid ; ND_PRINT ( ( ndo , ""timestamp<S2SV_blank>%u<S2SV_blank>packetcounter<S2SV_blank>%u"" , EXTRACT_32BITS ( message + 4 ) , EXTRACT_16BITS ( message + 2 ) ) ) ; } break ; case MESSAGE_HMAC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>hmac"" ) ) ; else { unsigned j ; ND_PRINT ( ( ndo , ""\\n\\tHMAC<S2SV_blank>"" ) ) ; if ( len < 18 ) goto invalid ; ND_PRINT ( ( ndo , ""key-id<S2SV_blank>%u<S2SV_blank>digest-%u<S2SV_blank>"" , EXTRACT_16BITS ( message + 2 ) , len - 2 ) ) ; for ( j = 0 ; j < len - 2 ; j ++ ) ND_PRINT ( ( ndo , ""%02X"" , message [ 4 + j ] ) ) ; } } break ; case MESSAGE_UPDATE_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ss-update"" ) ) ; } else { u_char prefix [ 16 ] , src_prefix [ 16 ] ; u_short interval , seqno , metric ; u_char ae , plen , src_plen , omitted ; int rc ; int parsed_len = 10 ; ND_PRINT ( ( ndo , ""\\n\\tSS-Update"" ) ) ; if ( len < 10 ) goto invalid ; ae = message [ 2 ] ; src_plen = message [ 3 ] ; plen = message [ 4 ] ; omitted = message [ 5 ] ; interval = EXTRACT_16BITS ( message + 6 ) ; seqno = EXTRACT_16BITS ( message + 8 ) ; metric = EXTRACT_16BITS ( message + 10 ) ; rc = network_prefix ( ae , plen , omitted , message + 2 + parsed_len , ae == 1 ? v4_prefix : v6_prefix , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; parsed_len += rc ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>from"" , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>metric<S2SV_blank>%u<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s"" , format_prefix ( ndo , src_prefix , src_plen ) , metric , seqno , format_interval_update ( interval ) ) ) ; if ( ( u_int ) parsed_len < len ) subtlvs_print ( ndo , message + 2 + parsed_len , message + 2 + len , type ) ; } } break ; case MESSAGE_REQUEST_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>ss-request"" ) ) ; else { int rc , parsed_len = 3 ; u_char ae , plen , src_plen , prefix [ 16 ] , src_prefix [ 16 ] ; ND_PRINT ( ( ndo , ""\\n\\tSS-Request<S2SV_blank>"" ) ) ; if ( len < 3 ) goto invalid ; ae = message [ 2 ] ; plen = message [ 3 ] ; src_plen = message [ 4 ] ; rc = network_prefix ( ae , plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; parsed_len += rc ; if ( ae == 0 ) { ND_PRINT ( ( ndo , ""for<S2SV_blank>any"" ) ) ; } else { ND_PRINT ( ( ndo , ""for<S2SV_blank>(%s,<S2SV_blank>"" , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , ""%s)"" , format_prefix ( ndo , src_prefix , src_plen ) ) ) ; } } } break ; case MESSAGE_MH_REQUEST_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>ss-mh-request"" ) ) ; else { int rc , parsed_len = 14 ; u_short seqno ; u_char ae , plen , src_plen , prefix [ 16 ] , src_prefix [ 16 ] , hopc ; const u_char * router_id = NULL ; ND_PRINT ( ( ndo , ""\\n\\tSS-MH-Request<S2SV_blank>"" ) ) ; if ( len < 14 ) goto invalid ; ae = message [ 2 ] ; plen = message [ 3 ] ; seqno = EXTRACT_16BITS ( message + 4 ) ; hopc = message [ 6 ] ; src_plen = message [ 7 ] ; router_id = message + 8 ; rc = network_prefix ( ae , plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; ND_PRINT ( ( ndo , ""(%u<S2SV_blank>hops)<S2SV_blank>for<S2SV_blank>(%s,<S2SV_blank>"" , hopc , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , ""%s)<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>id<S2SV_blank>%s"" , format_prefix ( ndo , src_prefix , src_plen ) , seqno , format_id ( router_id ) ) ) ; } } break ; default : if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>unknown"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\tUnknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d"" , type ) ) ; } i += len + 2 ; } return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tstr ) ) ; return ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; return ; }
","<S2SV_ModStart> ( len < 10 <S2SV_ModEnd> ) ND_PRINT (
",the-tcpdump-group@tcpdump/12f66f69f7bf1ec1266ddbee90a7616cbf33696b,CVE-2018-14470,https://github.com/the-tcpdump-group/tcpdump/commit/12f66f69f7bf1ec1266ddbee90a7616cbf33696b,2019-10-03T16:15Z,<S2SV_StartBug> if ( len < 1 ) <S2SV_EndBug>
7692,CWE-834,"static unsigned int XBMInteger ( Image * image , short int * hex_digits ) { int c ; unsigned int value ; do { c = ReadBlobByte ( image ) ; if ( c == EOF ) return ( 0 ) ; } while ( ( c == '<S2SV_blank>' ) || ( c == '\\t' ) || ( c == '\\n' ) || ( c == '\\r' ) ) ; value = 0 ; do { if ( value > ( unsigned int ) ( INT_MAX / 10 ) ) break ; value *= 16 ; c &= 0xff ; if ( value > ( unsigned int ) ( INT_MAX - hex_digits [ c ] ) ) break ; value += hex_digits [ c ] ; c = ReadBlobByte ( image ) ; if ( c == EOF ) return ( 0 ) ; } while ( hex_digits [ c ] >= 0 ) ; return ( value ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModEnd> int XBMInteger ( <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; return ( ( int )
",ImageMagick@ImageMagick/d9a8234d211da30baf9526fbebe9a8438ea7e11c,CVE-2017-14175,https://github.com/ImageMagick/ImageMagick/commit/d9a8234d211da30baf9526fbebe9a8438ea7e11c,2017-09-07T06:29Z,"<S2SV_StartBug> static unsigned int XBMInteger ( Image * image , short int * hex_digits ) <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( value ) ; <S2SV_EndBug>"
1217,CWE-119,"static int xmlParse3986Port ( xmlURIPtr uri , const char * * str ) { const char * cur = * str ; unsigned port = 0 ; if ( ISA_DIGIT ( cur ) ) { while ( ISA_DIGIT ( cur ) ) { port = port * 10 + ( * cur - '0' ) ; cur ++ ; } if ( uri != NULL ) uri -> port = port & INT_MAX ; * str = cur ; return ( 0 ) ; } return ( 1 ) ; }
","<S2SV_ModStart> = port & USHRT_MAX <S2SV_ModEnd> ; * str
",external@libxml2/51e0cb2e5ec18eaf6fb331bc573ff27b743898f4,CVE-2017-7376,https://android.googlesource.com/platform/external/libxml2/+/51e0cb2e5ec18eaf6fb331bc573ff27b743898f4,2018-02-19T19:29Z,<S2SV_StartBug> uri -> port = port & INT_MAX ; <S2SV_EndBug>
2581,CWE-476,"static int show_stream ( WriterContext * w , AVFormatContext * fmt_ctx , int stream_idx , InputStream * ist , int in_program ) { AVStream * stream = ist -> st ; AVCodecParameters * par ; AVCodecContext * dec_ctx ; char val_str [ 128 ] ; const char * s ; AVRational sar , dar ; AVBPrint pbuf ; const AVCodecDescriptor * cd ; int ret = 0 ; const char * profile = NULL ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM ) ; print_int ( ""index"" , stream -> index ) ; par = stream -> codecpar ; dec_ctx = ist -> dec_ctx ; if ( cd = avcodec_descriptor_get ( par -> codec_id ) ) { print_str ( ""codec_name"" , cd -> name ) ; if ( ! do_bitexact ) { print_str ( ""codec_long_name"" , cd -> long_name ? cd -> long_name : ""unknown"" ) ; } } else { print_str_opt ( ""codec_name"" , ""unknown"" ) ; if ( ! do_bitexact ) { print_str_opt ( ""codec_long_name"" , ""unknown"" ) ; } } if ( ! do_bitexact && ( profile = avcodec_profile_name ( par -> codec_id , par -> profile ) ) ) print_str ( ""profile"" , profile ) ; else { if ( par -> profile != FF_PROFILE_UNKNOWN ) { char profile_num [ 12 ] ; snprintf ( profile_num , sizeof ( profile_num ) , ""%d"" , par -> profile ) ; print_str ( ""profile"" , profile_num ) ; } else print_str_opt ( ""profile"" , ""unknown"" ) ; } s = av_get_media_type_string ( par -> codec_type ) ; if ( s ) print_str ( ""codec_type"" , s ) ; else print_str_opt ( ""codec_type"" , ""unknown"" ) ; # if FF_API_LAVF_AVCTX if ( dec_ctx ) print_q ( ""codec_time_base"" , dec_ctx -> time_base , '/' ) ; # endif print_str ( ""codec_tag_string"" , av_fourcc2str ( par -> codec_tag ) ) ; print_fmt ( ""codec_tag"" , ""0x%04"" PRIx32 , par -> codec_tag ) ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : print_int ( ""width"" , par -> width ) ; print_int ( ""height"" , par -> height ) ; if ( dec_ctx ) { print_int ( ""coded_width"" , dec_ctx -> coded_width ) ; print_int ( ""coded_height"" , dec_ctx -> coded_height ) ; } print_int ( ""has_b_frames"" , par -> video_delay ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , NULL ) ; if ( sar . den ) { print_q ( ""sample_aspect_ratio"" , sar , ':' ) ; av_reduce ( & dar . num , & dar . den , par -> width * sar . num , par -> height * sar . den , 1024 * 1024 ) ; print_q ( ""display_aspect_ratio"" , dar , ':' ) ; } else { print_str_opt ( ""sample_aspect_ratio"" , ""N/A"" ) ; print_str_opt ( ""display_aspect_ratio"" , ""N/A"" ) ; } s = av_get_pix_fmt_name ( par -> format ) ; if ( s ) print_str ( ""pix_fmt"" , s ) ; else print_str_opt ( ""pix_fmt"" , ""unknown"" ) ; print_int ( ""level"" , par -> level ) ; if ( par -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( par -> color_range ) ) ; else print_str_opt ( ""color_range"" , ""N/A"" ) ; if ( par -> color_space != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ; else print_str_opt ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ; if ( par -> color_trc != AVCOL_TRC_UNSPECIFIED ) print_str ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ; else print_str_opt ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ; if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED ) print_str ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ; else print_str_opt ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ; if ( par -> chroma_location != AVCHROMA_LOC_UNSPECIFIED ) print_str ( ""chroma_location"" , av_chroma_location_name ( par -> chroma_location ) ) ; else print_str_opt ( ""chroma_location"" , av_chroma_location_name ( par -> chroma_location ) ) ; if ( par -> field_order == AV_FIELD_PROGRESSIVE ) print_str ( ""field_order"" , ""progressive"" ) ; else if ( par -> field_order == AV_FIELD_TT ) print_str ( ""field_order"" , ""tt"" ) ; else if ( par -> field_order == AV_FIELD_BB ) print_str ( ""field_order"" , ""bb"" ) ; else if ( par -> field_order == AV_FIELD_TB ) print_str ( ""field_order"" , ""tb"" ) ; else if ( par -> field_order == AV_FIELD_BT ) print_str ( ""field_order"" , ""bt"" ) ; else print_str_opt ( ""field_order"" , ""unknown"" ) ; # if FF_API_PRIVATE_OPT if ( dec_ctx && dec_ctx -> timecode_frame_start >= 0 ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_mpeg_tc_string ( tcbuf , dec_ctx -> timecode_frame_start ) ; print_str ( ""timecode"" , tcbuf ) ; } else { print_str_opt ( ""timecode"" , ""N/A"" ) ; } # endif if ( dec_ctx ) print_int ( ""refs"" , dec_ctx -> refs ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( par -> format ) ; if ( s ) print_str ( ""sample_fmt"" , s ) ; else print_str_opt ( ""sample_fmt"" , ""unknown"" ) ; print_val ( ""sample_rate"" , par -> sample_rate , unit_hertz_str ) ; print_int ( ""channels"" , par -> channels ) ; if ( par -> channel_layout ) { av_bprint_clear ( & pbuf ) ; av_bprint_channel_layout ( & pbuf , par -> channels , par -> channel_layout ) ; print_str ( ""channel_layout"" , pbuf . str ) ; } else { print_str_opt ( ""channel_layout"" , ""unknown"" ) ; } print_int ( ""bits_per_sample"" , av_get_bits_per_sample ( par -> codec_id ) ) ; break ; case AVMEDIA_TYPE_SUBTITLE : if ( par -> width ) print_int ( ""width"" , par -> width ) ; else print_str_opt ( ""width"" , ""N/A"" ) ; if ( par -> height ) print_int ( ""height"" , par -> height ) ; else print_str_opt ( ""height"" , ""N/A"" ) ; break ; } if ( dec_ctx && dec_ctx -> codec && dec_ctx -> codec -> priv_class && show_private_data ) { const AVOption * opt = NULL ; while ( opt = av_opt_next ( dec_ctx -> priv_data , opt ) ) { uint8_t * str ; if ( opt -> flags ) continue ; if ( av_opt_get ( dec_ctx -> priv_data , opt -> name , 0 , & str ) >= 0 ) { print_str ( opt -> name , str ) ; av_free ( str ) ; } } } if ( fmt_ctx -> iformat -> flags & AVFMT_SHOW_IDS ) print_fmt ( ""id"" , ""0x%x"" , stream -> id ) ; else print_str_opt ( ""id"" , ""N/A"" ) ; print_q ( ""r_frame_rate"" , stream -> r_frame_rate , '/' ) ; print_q ( ""avg_frame_rate"" , stream -> avg_frame_rate , '/' ) ; print_q ( ""time_base"" , stream -> time_base , '/' ) ; print_ts ( ""start_pts"" , stream -> start_time ) ; print_time ( ""start_time"" , stream -> start_time , & stream -> time_base ) ; print_ts ( ""duration_ts"" , stream -> duration ) ; print_time ( ""duration"" , stream -> duration , & stream -> time_base ) ; if ( par -> bit_rate > 0 ) print_val ( ""bit_rate"" , par -> bit_rate , unit_bit_per_second_str ) ; else print_str_opt ( ""bit_rate"" , ""N/A"" ) ; # if FF_API_LAVF_AVCTX if ( stream -> codec -> rc_max_rate > 0 ) print_val ( ""max_bit_rate"" , stream -> codec -> rc_max_rate , unit_bit_per_second_str ) ; else print_str_opt ( ""max_bit_rate"" , ""N/A"" ) ; # endif if ( dec_ctx && dec_ctx -> bits_per_raw_sample > 0 ) print_fmt ( ""bits_per_raw_sample"" , ""%d"" , dec_ctx -> bits_per_raw_sample ) ; else print_str_opt ( ""bits_per_raw_sample"" , ""N/A"" ) ; if ( stream -> nb_frames ) print_fmt ( ""nb_frames"" , ""%"" PRId64 , stream -> nb_frames ) ; else print_str_opt ( ""nb_frames"" , ""N/A"" ) ; if ( nb_streams_frames [ stream_idx ] ) print_fmt ( ""nb_read_frames"" , ""%"" PRIu64 , nb_streams_frames [ stream_idx ] ) ; else print_str_opt ( ""nb_read_frames"" , ""N/A"" ) ; if ( nb_streams_packets [ stream_idx ] ) print_fmt ( ""nb_read_packets"" , ""%"" PRIu64 , nb_streams_packets [ stream_idx ] ) ; else print_str_opt ( ""nb_read_packets"" , ""N/A"" ) ; if ( do_show_data ) writer_print_data ( w , ""extradata"" , par -> extradata , par -> extradata_size ) ; writer_print_data_hash ( w , ""extradata_hash"" , par -> extradata , par -> extradata_size ) ; # define PRINT_DISPOSITION ( flagname , name ) do { print_int ( name , ! ! ( stream -> disposition & AV_DISPOSITION_ ## flagname ) ) ; } while ( 0 ) if ( do_show_stream_disposition ) { writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION ) ; PRINT_DISPOSITION ( DEFAULT , ""default"" ) ; PRINT_DISPOSITION ( DUB , ""dub"" ) ; PRINT_DISPOSITION ( ORIGINAL , ""original"" ) ; PRINT_DISPOSITION ( COMMENT , ""comment"" ) ; PRINT_DISPOSITION ( LYRICS , ""lyrics"" ) ; PRINT_DISPOSITION ( KARAOKE , ""karaoke"" ) ; PRINT_DISPOSITION ( FORCED , ""forced"" ) ; PRINT_DISPOSITION ( HEARING_IMPAIRED , ""hearing_impaired"" ) ; PRINT_DISPOSITION ( VISUAL_IMPAIRED , ""visual_impaired"" ) ; PRINT_DISPOSITION ( CLEAN_EFFECTS , ""clean_effects"" ) ; PRINT_DISPOSITION ( ATTACHED_PIC , ""attached_pic"" ) ; PRINT_DISPOSITION ( TIMED_THUMBNAILS , ""timed_thumbnails"" ) ; writer_print_section_footer ( w ) ; } if ( do_show_stream_tags ) ret = show_tags ( w , stream -> metadata , in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS ) ; if ( stream -> nb_side_data ) { print_pkt_side_data ( w , stream -> codecpar , stream -> side_data , stream -> nb_side_data , SECTION_ID_STREAM_SIDE_DATA_LIST , SECTION_ID_STREAM_SIDE_DATA ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; return ret ; }
","<S2SV_ModStart> ) ) ; print_primaries ( w , <S2SV_ModEnd> par -> color_primaries <S2SV_ModStart> par -> color_primaries <S2SV_ModEnd> ) ; if
",FFmpeg@FFmpeg/837cb4325b712ff1aab531bf41668933f61d75d2,CVE-2017-14225,https://github.com/FFmpeg/FFmpeg/commit/837cb4325b712ff1aab531bf41668933f61d75d2,2017-09-09T08:29Z,<S2SV_StartBug> if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <S2SV_EndBug>
3671,CWE-310,"static void prefetch_enc ( void ) { prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ; }
","<S2SV_ModStart> void ) { enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; <S2SV_ModStart> void * ) & enc_tables <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( enc_tables <S2SV_ModEnd> ) ) ;
",gpg@libgcrypt/daedbbb5541cd8ecda1459d3b843ea4d92788762,CVE-2019-12904,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,2019-06-20T00:15Z,"<S2SV_StartBug> prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ; <S2SV_EndBug>"
1980,CWE-119,"void vpx_svc_release ( SvcContext * svc_ctx ) { SvcInternal * si ; if ( svc_ctx == NULL ) return ; si = ( SvcInternal * ) svc_ctx -> internal ; if ( si != NULL ) { free ( si -> buffer ) ; if ( si -> rc_stats_buf ) { free ( si -> rc_stats_buf ) ; } free ( si ) ; svc_ctx -> internal = NULL ; } }
","<S2SV_ModStart> svc_ctx ) { SvcInternal_t <S2SV_ModEnd> * si ; <S2SV_ModStart> si = ( SvcInternal_t <S2SV_ModEnd> * ) svc_ctx <S2SV_ModStart> free ( si <S2SV_ModEnd> ) ; svc_ctx
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> SvcInternal * si ; <S2SV_EndBug> <S2SV_StartBug> si = ( SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> <S2SV_StartBug> free ( si -> buffer ) ; <S2SV_EndBug>
2117,CWE-119,"static int su3000_i2c_transfer ( struct i2c_adapter * adap , struct i2c_msg msg [ ] , int num ) { struct dvb_usb_device * d = i2c_get_adapdata ( adap ) ; u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ; if ( ! d ) return - ENODEV ; if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) return - EAGAIN ; switch ( num ) { case 1 : switch ( msg [ 0 ] . addr ) { case SU3000_STREAM_CTRL : obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ; obuf [ 1 ] = 3 ; obuf [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ; break ; case DW2102_RC_QUERY : obuf [ 0 ] = 0x10 ; if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ; msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ; msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ; break ; default : obuf [ 0 ] = 0x08 ; obuf [ 1 ] = msg [ 0 ] . addr ; obuf [ 2 ] = msg [ 0 ] . len ; memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 , ibuf , 1 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ; } break ; case 2 : obuf [ 0 ] = 0x09 ; obuf [ 1 ] = msg [ 0 ] . len ; obuf [ 2 ] = msg [ 1 ] . len ; obuf [ 3 ] = msg [ 0 ] . addr ; memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 , ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ; memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ; break ; default : warn ( ""more<S2SV_blank>than<S2SV_blank>2<S2SV_blank>i2c<S2SV_blank>messages<S2SV_blank>at<S2SV_blank>a<S2SV_blank>time<S2SV_blank>is<S2SV_blank>not<S2SV_blank>handled<S2SV_blank>yet."" ) ; break ; } mutex_unlock ( & d -> i2c_mutex ) ; return num ; }
","<S2SV_ModStart> adap ) ; struct dw2102_state * state <S2SV_ModEnd> ; if ( <S2SV_ModStart> - ENODEV ; state = d -> priv ; <S2SV_ModStart> - EAGAIN ; if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> case SU3000_STREAM_CTRL : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> + 0x36 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 3 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 0 , <S2SV_ModStart> case DW2102_RC_QUERY : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 2 , <S2SV_ModStart> 1 ] = state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> 0 ] = state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> ; default : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x08 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> . addr ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> case 2 : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x09 ; state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> . len ; state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 4 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 4 , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> buf , & state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> & d -> data_mutex ) ; mutex_unlock ( & d ->
",torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125,CVE-2017-8062,https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125,2017-04-23T05:59Z,"<S2SV_StartBug> u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> switch ( num ) { <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 3 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x10 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x08 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 , <S2SV_EndBug> <S2SV_StartBug> ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x09 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 3 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 , <S2SV_EndBug> <S2SV_StartBug> ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & d -> i2c_mutex ) ; <S2SV_EndBug>"
1677,CWE-119,"static void write_sync_code ( struct vp9_write_bit_buffer * wb ) { vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ; vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ; vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ; }
","<S2SV_ModStart> write_sync_code ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> wb ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 8 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 8 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void write_sync_code ( struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ; <S2SV_EndBug>"
3264,CWE-476,"void jp2_box_dump ( jp2_box_t * box , FILE * out ) { jp2_boxinfo_t * boxinfo ; boxinfo = jp2_boxinfolookup ( box -> type ) ; assert ( boxinfo ) ; fprintf ( out , ""JP2<S2SV_blank>box:<S2SV_blank>"" ) ; fprintf ( out , ""type=%c%s%c<S2SV_blank>(0x%08"" PRIxFAST32 "");<S2SV_blank>length=%"" PRIuFAST32 ""\\n"" , \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ; if ( box -> ops -> dumpdata ) { ( * box -> ops -> dumpdata ) ( box , out ) ; } }
","
",mdadams@jasper/bdfe95a6e81ffb4b2fad31a76b57943695beed20,CVE-2016-10250,https://github.com/mdadams/jasper/commit/bdfe95a6e81ffb4b2fad31a76b57943695beed20,2017-03-15T14:59Z,
7691,CWE-834,"static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MagickPathExtent ] , name [ MagickPathExtent ] ; Image * image ; MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length , padding , value , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( sscanf ( buffer , ""static<S2SV_blank>short<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , ""static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , ""static<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) NULL ) p = ( unsigned char * ) name ; else p ++ ; if ( LocaleCompare ( ""bits[]"" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) { value = XBMInteger ( image , hex_digits ) ; * p ++ = ( unsigned char ) value ; if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) * p ++ = ( unsigned char ) ( value >> 8 ) ; } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { value = XBMInteger ( image , hex_digits ) ; * p ++ = ( unsigned char ) value ; } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 ) byte = ( size_t ) ( * p ++ ) ; SetPixelIndex ( image , ( Quantum ) ( ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) , q ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ( void ) SyncImage ( image , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> Image * image ; int c <S2SV_ModStart> , padding , <S2SV_ModEnd> version , width <S2SV_ModStart> . red = ( MagickRealType ) <S2SV_ModStart> . green = ( MagickRealType ) <S2SV_ModStart> . blue = ( MagickRealType ) <S2SV_ModStart> . red = 0.0 <S2SV_ModEnd> ; image -> <S2SV_ModStart> . green = 0.0 <S2SV_ModEnd> ; image -> <S2SV_ModStart> . blue = 0.0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c <S2SV_ModEnd> ; if ( <S2SV_ModStart> char ) ( c <S2SV_ModEnd> >> 8 ) <S2SV_ModStart> ++ ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) <S2SV_ModEnd> ; } p <S2SV_ModStart> byte = ( unsigned int <S2SV_ModEnd> ) ( *
",ImageMagick@ImageMagick/d9a8234d211da30baf9526fbebe9a8438ea7e11c,CVE-2017-14175,https://github.com/ImageMagick/ImageMagick/commit/d9a8234d211da30baf9526fbebe9a8438ea7e11c,2017-09-07T06:29Z,"<S2SV_StartBug> * image ; <S2SV_EndBug> <S2SV_StartBug> value , <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . red = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . green = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . blue = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . red = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . green = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) ( value >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> byte = ( size_t ) ( * p ++ ) ; <S2SV_EndBug>"
2107,CWE-200,"static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= MSG_TRUNC ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; } else { if ( ( sock -> state == SS_READY ) || ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( ( sock -> state != SS_READY ) && ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } exit : release_sock ( sk ) ; return res ; }
","<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
",torvalds@linux/60085c3d009b0df252547adb336d1ccca5ce52ec,CVE-2013-3235,https://github.com/torvalds/linux/commit/60085c3d009b0df252547adb336d1ccca5ce52ec,2013-04-22T11:41Z,"<S2SV_StartBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <S2SV_EndBug>"
4774,CWE-119,"int l2tp_recv ( int fd , struct l2tp_packet_t * * p , struct in_pktinfo * pkt_info , const char * secret , size_t secret_len ) { int n , length ; uint8_t * buf ; struct l2tp_hdr_t * hdr ; struct l2tp_avp_t * avp ; struct l2tp_dict_attr_t * da ; struct l2tp_attr_t * attr , * RV = NULL ; uint8_t * ptr ; struct l2tp_packet_t * pack ; struct sockaddr_in addr ; socklen_t len = sizeof ( addr ) ; struct msghdr msg ; char msg_control [ 128 ] ; struct cmsghdr * cmsg ; uint16_t orig_avp_len ; void * orig_avp_val ; * p = NULL ; if ( pkt_info ) { memset ( & msg , 0 , sizeof ( msg ) ) ; msg . msg_control = msg_control ; msg . msg_controllen = 128 ; n = recvmsg ( fd , & msg , MSG_PEEK ) ; if ( n < 0 ) { if ( errno == EAGAIN ) return - 1 ; log_error ( ""l2tp:<S2SV_blank>recvmsg:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; return 0 ; } for ( cmsg = CMSG_FIRSTHDR ( & msg ) ; cmsg != NULL ; cmsg = CMSG_NXTHDR ( & msg , cmsg ) ) { if ( cmsg -> cmsg_level == IPPROTO_IP && cmsg -> cmsg_type == IP_PKTINFO ) { memcpy ( pkt_info , CMSG_DATA ( cmsg ) , sizeof ( * pkt_info ) ) ; break ; } } } buf = mempool_alloc ( buf_pool ) ; if ( ! buf ) { log_emerg ( ""l2tp:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; return 0 ; } hdr = ( struct l2tp_hdr_t * ) buf ; ptr = ( uint8_t * ) ( hdr + 1 ) ; n = recvfrom ( fd , buf , L2TP_MAX_PACKET_SIZE , 0 , & addr , & len ) ; if ( n < 0 ) { mempool_free ( buf ) ; if ( errno == EAGAIN ) { return - 1 ; } else if ( errno == ECONNREFUSED ) { return - 2 ; } log_error ( ""l2tp:<S2SV_blank>recv:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; return 0 ; } if ( n < 6 ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%zu)\\n"" , n , sizeof ( * hdr ) ) ; goto out_err_hdr ; } if ( hdr -> T == 0 ) goto out_err_hdr ; if ( n < ntohs ( hdr -> length ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%i)\\n"" , n , ntohs ( hdr -> length ) ) ; goto out_err_hdr ; } if ( hdr -> ver == 2 ) { if ( hdr -> L == 0 ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\n"" ) ; if ( ! conf_avp_permissive ) goto out_err_hdr ; } if ( hdr -> S == 0 ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(S=0)\\n"" ) ; if ( ! conf_avp_permissive ) goto out_err_hdr ; } if ( hdr -> O == 1 ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(O=1)\\n"" ) ; if ( ! conf_avp_permissive ) goto out_err_hdr ; } } else if ( hdr -> ver != 3 ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>%i<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" , hdr -> ver ) ; goto out_err_hdr ; } pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) { log_emerg ( ""l2tp:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; goto out_err_hdr ; } memset ( pack , 0 , sizeof ( * pack ) ) ; INIT_LIST_HEAD ( & pack -> attrs ) ; memcpy ( & pack -> addr , & addr , sizeof ( addr ) ) ; memcpy ( & pack -> hdr , hdr , sizeof ( * hdr ) ) ; length = ntohs ( hdr -> length ) - sizeof ( * hdr ) ; while ( length ) { * ( uint16_t * ) ptr = ntohs ( * ( uint16_t * ) ptr ) ; avp = ( struct l2tp_avp_t * ) ptr ; if ( avp -> length > length ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(exceeds<S2SV_blank>message<S2SV_blank>length)\\n"" ) ; goto out_err ; } if ( avp -> vendor ) goto skip ; da = l2tp_dict_find_attr_by_id ( ntohs ( avp -> type ) ) ; if ( ! da ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>unknown<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%u)\\n"" , ntohs ( avp -> type ) , avp -> M ) ; if ( avp -> M && ! conf_avp_permissive ) goto out_err ; } else { if ( da -> M != - 1 && da -> M != avp -> M ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n"" , ntohs ( avp -> type ) , avp -> M , da -> M ) ; if ( ! conf_avp_permissive ) goto out_err ; } if ( da -> H != - 1 && da -> H != avp -> H ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>H=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n"" , ntohs ( avp -> type ) , avp -> H , da -> H ) ; if ( ! conf_avp_permissive ) goto out_err ; } if ( avp -> H ) { if ( ! RV ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>H=1,<S2SV_blank>but<S2SV_blank>Random-Vector<S2SV_blank>is<S2SV_blank>not<S2SV_blank>received)\\n"" , ntohs ( avp -> type ) ) ; goto out_err ; } if ( secret == NULL || secret_len == 0 ) { log_error ( ""l2tp:<S2SV_blank>impossible<S2SV_blank>to<S2SV_blank>decode"" ""<S2SV_blank>hidden<S2SV_blank>avp<S2SV_blank>(type<S2SV_blank>%hu):<S2SV_blank>no"" ""<S2SV_blank>secret<S2SV_blank>set)\\n"" , ntohs ( avp -> type ) ) ; goto out_err ; } if ( decode_avp ( avp , RV , secret , secret_len ) < 0 ) goto out_err ; } attr = mempool_alloc ( attr_pool ) ; memset ( attr , 0 , sizeof ( * attr ) ) ; list_add_tail ( & attr -> entry , & pack -> attrs ) ; if ( avp -> H ) { orig_avp_len = ntohs ( * ( uint16_t * ) avp -> val ) + sizeof ( * avp ) ; orig_avp_val = avp -> val + sizeof ( uint16_t ) ; } else { orig_avp_len = avp -> length ; orig_avp_val = avp -> val ; } attr -> attr = da ; attr -> M = avp -> M ; attr -> H = 0 ; attr -> length = orig_avp_len - sizeof ( * avp ) ; if ( attr -> attr -> id == Random_Vector ) RV = attr ; switch ( da -> type ) { case ATTR_TYPE_INT16 : if ( orig_avp_len != sizeof ( * avp ) + 2 ) goto out_err_len ; attr -> val . uint16 = ntohs ( * ( uint16_t * ) orig_avp_val ) ; break ; case ATTR_TYPE_INT32 : if ( orig_avp_len != sizeof ( * avp ) + 4 ) goto out_err_len ; attr -> val . uint32 = ntohl ( * ( uint32_t * ) orig_avp_val ) ; break ; case ATTR_TYPE_INT64 : if ( orig_avp_len != sizeof ( * avp ) + 8 ) goto out_err_len ; attr -> val . uint64 = be64toh ( * ( uint64_t * ) orig_avp_val ) ; break ; case ATTR_TYPE_OCTETS : attr -> val . octets = _malloc ( attr -> length ) ; if ( ! attr -> val . octets ) goto out_err_mem ; memcpy ( attr -> val . octets , orig_avp_val , attr -> length ) ; break ; case ATTR_TYPE_STRING : attr -> val . string = _malloc ( attr -> length + 1 ) ; if ( ! attr -> val . string ) goto out_err_mem ; memcpy ( attr -> val . string , orig_avp_val , attr -> length ) ; attr -> val . string [ attr -> length ] = 0 ; break ; } } skip : ptr += avp -> length ; length -= avp -> length ; } * p = pack ; mempool_free ( buf ) ; return 0 ; out_err : l2tp_packet_free ( pack ) ; out_err_hdr : mempool_free ( buf ) ; return 0 ; out_err_len : if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>incorrect<S2SV_blank>length<S2SV_blank>%i)\\n"" , ntohs ( avp -> type ) , orig_avp_len ) ; goto out_err ; out_err_mem : log_emerg ( ""l2tp:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; goto out_err ; }
","<S2SV_ModStart> secret_len ) { struct l2tp_packet_t * pack <S2SV_ModEnd> ; struct l2tp_hdr_t <S2SV_ModStart> avp ; struct l2tp_attr_t * <S2SV_ModEnd> RV = NULL <S2SV_ModStart> RV = NULL <S2SV_ModEnd> ; struct sockaddr_in <S2SV_ModStart> addr ; socklen_t addr_len ; uint16_t orig_avp_len ; void * orig_avp_val ; uint8_t * buf , * ptr ; int n , length ; * p = NULL ; if ( pkt_info ) { <S2SV_ModEnd> struct msghdr msg <S2SV_ModStart> struct msghdr msg ; struct cmsghdr * cmsg <S2SV_ModStart> 128 ] ; <S2SV_ModEnd> memset ( & <S2SV_ModStart> . msg_controllen = sizeof ( msg_control ) <S2SV_ModEnd> ; n = <S2SV_ModStart> 1 ) ; addr_len = sizeof ( addr ) ; <S2SV_ModStart> addr , & addr_len <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( n < sizeof ( * hdr ) <S2SV_ModEnd> ) { if <S2SV_ModStart> out_err_hdr ; } hdr -> flags = ntohs ( hdr -> flags ) ; if ( ! ( hdr -> flags & L2TP_FLAG_T ) <S2SV_ModEnd> ) goto out_err_hdr <S2SV_ModStart> goto out_err_hdr ; if ( ! ( hdr -> flags & L2TP_FLAG_L ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\n"" ) ; goto out_err_hdr ; } if ( ! ( hdr -> flags & L2TP_FLAG_S ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(S=0)\\n"" ) ; goto out_err_hdr ; } switch ( hdr -> flags & L2TP_VER_MASK ) { case 2 : if ( hdr -> flags & L2TP_FLAG_O ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(O=1)\\n"" ) ; goto out_err_hdr ; } break ; case 3 : break ; default : if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>%i<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" , hdr -> flags & L2TP_VER_MASK ) ; goto out_err_hdr ; } length = ntohs ( hdr -> length ) ; if ( length < sizeof ( * hdr ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%zu)\\n"" , length , sizeof ( * hdr ) ) ; goto out_err_hdr ; } else <S2SV_ModStart> ( n < length ) <S2SV_ModEnd> { if ( <S2SV_ModStart> , n , length ) <S2SV_ModEnd> ; goto out_err_hdr <S2SV_ModStart> out_err_hdr ; } pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) { log_emerg ( ""l2tp:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; goto out_err_hdr ; } memset ( pack , 0 , sizeof ( * pack ) ) ; INIT_LIST_HEAD ( & pack -> attrs ) ; memcpy ( & pack -> addr , & addr , sizeof ( addr ) ) ; memcpy ( & pack -> hdr , hdr , sizeof ( * hdr ) ) ; length -= sizeof ( * hdr ) ; while ( length > 0 ) { struct l2tp_dict_attr_t * da ; struct l2tp_attr_t * attr ; uint16_t avp_len ; if ( length < sizeof ( * avp ) <S2SV_ModEnd> ) { if <S2SV_ModStart> ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>avp<S2SV_blank>received\\n"" ) ; goto out_err ; } <S2SV_ModEnd> avp = ( <S2SV_ModStart> ) ptr ; avp -> flags = ntohs ( avp -> flags ) ; avp_len = avp -> flags & L2TP_AVP_LEN_MASK ; if ( avp_len < sizeof ( * avp ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>avp<S2SV_blank>received\\n"" ) ; goto out_err ; } else if ( length < avp_len <S2SV_ModEnd> ) { if <S2SV_ModStart> ( conf_verbose ) { <S2SV_ModStart> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) ; } if ( ( avp -> flags & L2TP_AVP_FLAG_M ) <S2SV_ModEnd> && ! conf_avp_permissive <S2SV_ModStart> - 1 && ! <S2SV_ModStart> -> M != ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) { if ( conf_verbose ) { log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n"" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) , da <S2SV_ModEnd> -> M ) <S2SV_ModStart> -> M ) ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> - 1 && ! <S2SV_ModStart> -> H != ! ( avp -> flags & L2TP_AVP_FLAG_H ) ) { if ( conf_verbose ) { log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>H=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n"" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_H ) , da <S2SV_ModEnd> -> H ) <S2SV_ModStart> -> H ) ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( avp -> flags & L2TP_AVP_FLAG_H <S2SV_ModEnd> ) { if <S2SV_ModStart> goto out_err ; <S2SV_ModEnd> orig_avp_len = ntohs <S2SV_ModStart> { orig_avp_len = avp_len <S2SV_ModEnd> ; orig_avp_val = <S2SV_ModStart> ; } attr = mempool_alloc ( attr_pool ) ; memset ( attr , 0 , sizeof ( * attr ) ) ; attr <S2SV_ModStart> -> M = ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) <S2SV_ModEnd> ; attr -> <S2SV_ModStart> ( * avp ) ; list_add_tail ( & attr -> entry , & pack -> attrs <S2SV_ModStart> : ptr += avp_len <S2SV_ModEnd> ; length -= <S2SV_ModStart> ; length -= avp_len <S2SV_ModEnd> ; } *
",accel-ppp@accel-ppp/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,CVE-2020-15173,https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,2020-09-09T23:15Z,"<S2SV_StartBug> int n , length ; <S2SV_EndBug> <S2SV_StartBug> struct l2tp_dict_attr_t * da ; <S2SV_EndBug> <S2SV_StartBug> struct l2tp_attr_t * attr , * RV = NULL ; <S2SV_EndBug> <S2SV_StartBug> socklen_t len = sizeof ( addr ) ; <S2SV_EndBug> <S2SV_StartBug> struct msghdr msg ; <S2SV_EndBug> <S2SV_StartBug> struct cmsghdr * cmsg ; <S2SV_EndBug> <S2SV_StartBug> msg . msg_controllen = 128 ; <S2SV_EndBug> <S2SV_StartBug> n = recvfrom ( fd , buf , L2TP_MAX_PACKET_SIZE , 0 , & addr , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( n < 6 ) { <S2SV_EndBug> <S2SV_StartBug> if ( hdr -> T == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( n < ntohs ( hdr -> length ) ) { <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%i)\\n"" , n , ntohs ( hdr -> length ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( hdr -> ver == 2 ) { <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( avp -> length > length ) { <S2SV_EndBug> <S2SV_StartBug> if ( conf_verbose ) <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>unknown<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%u)\\n"" , ntohs ( avp -> type ) , avp -> M ) ; <S2SV_EndBug> <S2SV_StartBug> if ( da -> M != - 1 && da -> M != avp -> M ) { <S2SV_EndBug> <S2SV_StartBug> if ( da -> H != - 1 && da -> H != avp -> H ) { <S2SV_EndBug> <S2SV_StartBug> if ( avp -> H ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> orig_avp_len = avp -> length ; <S2SV_EndBug> <S2SV_StartBug> attr -> attr = da ; <S2SV_EndBug> <S2SV_StartBug> attr -> M = avp -> M ; <S2SV_EndBug> <S2SV_StartBug> attr -> length = orig_avp_len - sizeof ( * avp ) ; <S2SV_EndBug> <S2SV_StartBug> ptr += avp -> length ; <S2SV_EndBug> <S2SV_StartBug> length -= avp -> length ; <S2SV_EndBug>"
2678,CWE-119,"IMPEG2D_ERROR_CODES_T impeg2d_vld_decode ( dec_state_t * ps_dec , WORD16 * pi2_outAddr , const UWORD8 * pu1_scan , UWORD8 * pu1_pos , UWORD16 u2_intra_flag , UWORD16 u2_chroma_flag , UWORD16 u2_d_picture , UWORD16 u2_intra_vlc_format , UWORD16 u2_mpeg2 , WORD32 * pi4_num_coeffs ) { UWORD32 u4_sym_len ; UWORD32 u4_decoded_value ; UWORD32 u4_level_first_byte ; WORD32 u4_level ; UWORD32 u4_run , u4_numCoeffs ; UWORD32 u4_buf ; UWORD32 u4_buf_nxt ; UWORD32 u4_offset ; UWORD32 * pu4_buf_aligned ; UWORD32 u4_bits ; stream_t * ps_stream = & ps_dec -> s_bit_stream ; WORD32 u4_pos ; UWORD32 u4_nz_cols ; UWORD32 u4_nz_rows ; * pi4_num_coeffs = 0 ; ps_dec -> u4_non_zero_cols = 0 ; ps_dec -> u4_non_zero_rows = 0 ; u4_nz_cols = ps_dec -> u4_non_zero_cols ; u4_nz_rows = ps_dec -> u4_non_zero_rows ; GET_TEMP_STREAM_DATA ( u4_buf , u4_buf_nxt , u4_offset , pu4_buf_aligned , ps_stream ) if ( u2_intra_flag ) { WORD32 dc_size ; WORD32 dc_diff ; WORD32 maxLen ; WORD32 idx ; maxLen = MPEG2_DCT_DC_SIZE_LEN ; idx = 0 ; if ( u2_chroma_flag != 0 ) { maxLen += 1 ; idx ++ ; } { WORD16 end = 0 ; UWORD32 maxLen_tmp = maxLen ; UWORD16 m_iBit ; IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , maxLen ) do { maxLen_tmp -- ; m_iBit = ( UWORD8 ) ( ( u4_bits >> maxLen_tmp ) & 0x1 ) ; end = gai2_impeg2d_dct_dc_size [ idx ] [ end ] [ m_iBit ] ; } while ( end > 0 ) ; dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET ; FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , ( maxLen - maxLen_tmp ) , pu4_buf_aligned ) } if ( dc_size != 0 ) { UWORD32 u4_bits ; IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , dc_size ) dc_diff = u4_bits ; if ( ( dc_diff & ( 1 << ( dc_size - 1 ) ) ) == 0 ) dc_diff -= ( 1 << dc_size ) - 1 ; } else { dc_diff = 0 ; } pi2_outAddr [ * pi4_num_coeffs ] = dc_diff ; pu1_pos [ * pi4_num_coeffs ] = pu1_scan [ 0 ] ; ( * pi4_num_coeffs ) ++ ; if ( 0 != dc_diff ) { u4_nz_cols |= 0x01 ; u4_nz_rows |= 0x01 ; } u4_numCoeffs = 1 ; } else { UWORD32 u4_bits ; IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , 1 ) if ( u4_bits == 1 ) { FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , 1 , pu4_buf_aligned ) IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 1 ) if ( u4_bits == 1 ) { pi2_outAddr [ * pi4_num_coeffs ] = - 1 ; } else { pi2_outAddr [ * pi4_num_coeffs ] = 1 ; } pu1_pos [ * pi4_num_coeffs ] = pu1_scan [ 0 ] ; ( * pi4_num_coeffs ) ++ ; u4_numCoeffs = 1 ; u4_nz_cols |= 0x01 ; u4_nz_rows |= 0x01 ; } else { u4_numCoeffs = 0 ; } } if ( 1 == u2_d_picture ) { PUT_TEMP_STREAM_DATA ( u4_buf , u4_buf_nxt , u4_offset , pu4_buf_aligned , ps_stream ) ps_dec -> u4_non_zero_cols = u4_nz_cols ; ps_dec -> u4_non_zero_rows = u4_nz_rows ; return ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ) ; } if ( 1 == u2_intra_vlc_format && u2_intra_flag ) { while ( 1 ) { UWORD32 lead_zeros ; WORD16 DecodedValue ; u4_sym_len = 17 ; IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , u4_sym_len ) DecodedValue = gau2_impeg2d_tab_one_1_9 [ u4_bits >> 8 ] ; u4_sym_len = ( DecodedValue & 0xf ) ; u4_level = DecodedValue >> 9 ; if ( 0 != u4_level ) { u4_run = ( ( DecodedValue >> 4 ) & 0x1f ) ; u4_numCoeffs += u4_run ; u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; pu1_pos [ * pi4_num_coeffs ] = u4_pos ; FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; ( * pi4_num_coeffs ) ++ ; } else { if ( DecodedValue == END_OF_BLOCK_ONE ) { u4_sym_len = 4 ; break ; } else { lead_zeros = CLZ ( u4_bits ) - 20 ; if ( 0 != lead_zeros ) { u4_bits = ( u4_bits >> ( 6 - lead_zeros ) ) & 0x001F ; if ( 1 == lead_zeros ) { u4_sym_len = ( ( u4_bits & 0x18 ) >> 3 ) == 2 ? 11 : 10 ; } else { u4_sym_len = 11 + lead_zeros ; } FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) u4_bits = ( ( lead_zeros - 1 ) << 5 ) + u4_bits ; DecodedValue = gau2_impeg2d_tab_one_10_16 [ u4_bits ] ; u4_run = BITS ( DecodedValue , 8 , 4 ) ; u4_level = ( ( WORD16 ) DecodedValue ) >> 9 ; u4_numCoeffs += u4_run ; u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; pu1_pos [ * pi4_num_coeffs ] = u4_pos ; pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; ( * pi4_num_coeffs ) ++ ; } else if ( u2_mpeg2 == 1 ) { u4_sym_len = 6 ; FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 18 ) u4_decoded_value = u4_bits ; u4_run = ( u4_decoded_value >> 12 ) ; u4_level = ( u4_decoded_value & 0x0FFF ) ; if ( u4_level ) u4_level = ( u4_level - ( ( u4_level & 0x0800 ) << 1 ) ) ; u4_numCoeffs += u4_run ; u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; pu1_pos [ * pi4_num_coeffs ] = u4_pos ; pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; ( * pi4_num_coeffs ) ++ ; } else { u4_sym_len = 6 ; FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 14 ) u4_decoded_value = u4_bits ; u4_run = ( u4_decoded_value >> 8 ) ; u4_level_first_byte = ( u4_decoded_value & 0x0FF ) ; if ( u4_level_first_byte & 0x7F ) { u4_level = ( u4_level_first_byte - ( ( u4_level_first_byte & 0x80 ) << 1 ) ) ; } else { IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 8 ) u4_level = u4_bits ; u4_level = ( u4_level - ( u4_level_first_byte << 1 ) ) ; } u4_numCoeffs += u4_run ; u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; pu1_pos [ * pi4_num_coeffs ] = u4_pos ; pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; ( * pi4_num_coeffs ) ++ ; } } } u4_nz_cols |= 1 << ( u4_pos & 0x7 ) ; u4_nz_rows |= 1 << ( u4_pos >> 0x3 ) ; } IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) if ( u4_numCoeffs > 64 ) { return IMPEG2D_MB_TEX_DECODE_ERR ; } } else { while ( 1 ) { UWORD32 lead_zeros ; UWORD16 DecodedValue ; u4_sym_len = 17 ; IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , u4_sym_len ) DecodedValue = gau2_impeg2d_tab_zero_1_9 [ u4_bits >> 8 ] ; u4_sym_len = BITS ( DecodedValue , 3 , 0 ) ; u4_level = ( ( WORD16 ) DecodedValue ) >> 9 ; if ( 0 != u4_level ) { u4_run = BITS ( DecodedValue , 8 , 4 ) ; u4_numCoeffs += u4_run ; u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; pu1_pos [ * pi4_num_coeffs ] = u4_pos ; FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; ( * pi4_num_coeffs ) ++ ; } else { if ( DecodedValue == END_OF_BLOCK_ZERO ) { u4_sym_len = 2 ; break ; } else { lead_zeros = CLZ ( u4_bits ) - 20 ; if ( 0 != lead_zeros ) { u4_bits = ( u4_bits >> ( 6 - lead_zeros ) ) & 0x001F ; u4_sym_len = 11 + lead_zeros ; u4_bits = ( ( lead_zeros - 1 ) << 5 ) + u4_bits ; DecodedValue = gau2_impeg2d_tab_zero_10_16 [ u4_bits ] ; u4_run = BITS ( DecodedValue , 8 , 4 ) ; u4_level = ( ( WORD16 ) DecodedValue ) >> 9 ; u4_numCoeffs += u4_run ; u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; pu1_pos [ * pi4_num_coeffs ] = u4_pos ; if ( 1 == lead_zeros ) u4_sym_len -- ; FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; ( * pi4_num_coeffs ) ++ ; } else if ( u2_mpeg2 == 1 ) { u4_sym_len = 6 ; FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 18 ) u4_decoded_value = u4_bits ; u4_run = ( u4_decoded_value >> 12 ) ; u4_level = ( u4_decoded_value & 0x0FFF ) ; if ( u4_level ) u4_level = ( u4_level - ( ( u4_level & 0x0800 ) << 1 ) ) ; u4_numCoeffs += u4_run ; u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; pu1_pos [ * pi4_num_coeffs ] = u4_pos ; pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; ( * pi4_num_coeffs ) ++ ; } else { u4_sym_len = 6 ; FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 14 ) u4_decoded_value = u4_bits ; u4_run = ( u4_decoded_value >> 8 ) ; u4_level_first_byte = ( u4_decoded_value & 0x0FF ) ; if ( u4_level_first_byte & 0x7F ) { u4_level = ( u4_level_first_byte - ( ( u4_level_first_byte & 0x80 ) << 1 ) ) ; } else { IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 8 ) u4_level = u4_bits ; u4_level = ( u4_level - ( u4_level_first_byte << 1 ) ) ; } u4_numCoeffs += u4_run ; u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; pu1_pos [ * pi4_num_coeffs ] = u4_pos ; pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; ( * pi4_num_coeffs ) ++ ; } } } u4_nz_cols |= 1 << ( u4_pos & 0x7 ) ; u4_nz_rows |= 1 << ( u4_pos >> 0x3 ) ; } if ( u4_numCoeffs > 64 ) { return IMPEG2D_MB_TEX_DECODE_ERR ; } IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) } PUT_TEMP_STREAM_DATA ( u4_buf , u4_buf_nxt , u4_offset , pu4_buf_aligned , ps_stream ) ps_dec -> u4_non_zero_cols = u4_nz_cols ; ps_dec -> u4_non_zero_rows = u4_nz_rows ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
","<S2SV_ModStart> 0x3 ) ; <S2SV_ModEnd> if ( u4_numCoeffs <S2SV_ModStart> IMPEG2D_MB_TEX_DECODE_ERR ; } } IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) <S2SV_ModStart> 0x3 ) ; <S2SV_ModEnd> if ( u4_numCoeffs <S2SV_ModStart> return IMPEG2D_MB_TEX_DECODE_ERR ; }
",external@libmpeg2/8b4ed5a23175b7ffa56eea4678db7287f825e985,CVE-2016-0836,https://android.googlesource.com/platform/external/libmpeg2/+/8b4ed5a23175b7ffa56eea4678db7287f825e985,2016-04-18T00:59Z,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return IMPEG2D_MB_TEX_DECODE_ERR ; <S2SV_EndBug>
2341,CWE-284,"WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) { return IV_FAIL ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }
","<S2SV_ModStart> = 2 ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ;
",external@libavc/7109ce3f8f90a28ca9f0ee6e14f6ac5e414c62cf,CVE-2016-3878,https://android.googlesource.com/platform/external/libavc/+/7109ce3f8f90a28ca9f0ee6e14f6ac5e414c62cf,2016-09-11T21:59Z,"<S2SV_StartBug> ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , <S2SV_EndBug>"
5556,CWE-835,"int lookup ( struct sip_msg * _m , char * _t , char * _f , char * _s ) { unsigned int flags ; urecord_t * r ; str aor , uri ; ucontact_t * ptr , * it ; int res ; int ret ; str path_dst ; str flags_s ; pv_value_t val ; int_str istr ; str sip_instance = { 0 , 0 } , call_id = { 0 , 0 } ; flags = 0 ; if ( _f && _f [ 0 ] != 0 ) { if ( fixup_get_svalue ( _m , ( gparam_p ) _f , & flags_s ) != 0 ) { LM_ERR ( ""invalid<S2SV_blank>owner<S2SV_blank>uri<S2SV_blank>parameter"" ) ; return - 1 ; } for ( res = 0 ; res < flags_s . len ; res ++ ) { switch ( flags_s . s [ res ] ) { case 'm' : flags |= REG_LOOKUP_METHODFILTER_FLAG ; break ; case 'b' : flags |= REG_LOOKUP_NOBRANCH_FLAG ; break ; default : LM_WARN ( ""unsuported<S2SV_blank>flag<S2SV_blank>%c<S2SV_blank>\\n"" , flags_s . s [ res ] ) ; } } } if ( _s ) { if ( pv_get_spec_value ( _m , ( pv_spec_p ) _s , & val ) != 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>PV<S2SV_blank>value\\n"" ) ; return - 1 ; } if ( ( val . flags & PV_VAL_STR ) == 0 ) { LM_ERR ( ""PV<S2SV_blank>vals<S2SV_blank>is<S2SV_blank>not<S2SV_blank>string\\n"" ) ; return - 1 ; } uri = val . rs ; } else { if ( _m -> new_uri . s ) uri = _m -> new_uri ; else uri = _m -> first_line . u . request . uri ; } if ( extract_aor ( & uri , & aor , & sip_instance , & call_id ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>address<S2SV_blank>of<S2SV_blank>record\\n"" ) ; return - 3 ; } get_act_time ( ) ; ul . lock_udomain ( ( udomain_t * ) _t , & aor ) ; res = ul . get_urecord ( ( udomain_t * ) _t , & aor , & r ) ; if ( res > 0 ) { LM_DBG ( ""\'%.*s\'<S2SV_blank>Not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>usrloc\\n"" , aor . len , ZSW ( aor . s ) ) ; ul . unlock_udomain ( ( udomain_t * ) _t , & aor ) ; return - 1 ; } ptr = r -> contacts ; ret = - 1 ; search_valid_contact : while ( ( ptr ) && ! ( VALID_CONTACT ( ptr , act_time ) && ( ret = - 2 ) && allowed_method ( _m , ptr , flags ) ) ) ptr = ptr -> next ; if ( ptr == 0 ) { LM_DBG ( ""nothing<S2SV_blank>found<S2SV_blank>!\\n"" ) ; goto done ; } if ( sip_instance . len && sip_instance . s ) { LM_DBG ( ""ruri<S2SV_blank>has<S2SV_blank>gruu<S2SV_blank>in<S2SV_blank>lookup\\n"" ) ; if ( ptr -> instance . len - 2 != sip_instance . len || memcmp ( ptr -> instance . s + 1 , sip_instance . s , sip_instance . len ) ) { LM_DBG ( ""no<S2SV_blank>match<S2SV_blank>to<S2SV_blank>sip<S2SV_blank>instace<S2SV_blank>-<S2SV_blank>[%.*s]<S2SV_blank>-<S2SV_blank>[%.*s]\\n"" , ptr -> instance . len - 2 , ptr -> instance . s + 1 , sip_instance . len , sip_instance . s ) ; ptr = ptr -> next ; goto search_valid_contact ; } LM_DBG ( ""matched<S2SV_blank>sip<S2SV_blank>instace\\n"" ) ; } if ( call_id . len && call_id . s ) { if ( ptr -> callid . len != call_id . len || memcmp ( ptr -> callid . s , call_id . s , call_id . len ) ) { LM_DBG ( ""no<S2SV_blank>match<S2SV_blank>to<S2SV_blank>call<S2SV_blank>id<S2SV_blank>-<S2SV_blank>[%.*s]<S2SV_blank>-<S2SV_blank>[%.*s]\\n"" , ptr -> callid . len , ptr -> callid . s , call_id . len , call_id . s ) ; ptr = ptr -> next ; goto search_valid_contact ; } it = ptr -> next ; while ( it ) { if ( VALID_CONTACT ( it , act_time ) ) { if ( it -> instance . len - 2 == sip_instance . len && memcmp ( it -> instance . s + 1 , sip_instance . s , sip_instance . len ) == 0 ) if ( it -> last_modified > ptr -> last_modified ) { break ; } } } if ( it != NULL ) { ret = - 1 ; goto done ; } } LM_DBG ( ""found<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>match\\n"" ) ; ret = 1 ; if ( ptr ) { LM_DBG ( ""setting<S2SV_blank>as<S2SV_blank>ruri<S2SV_blank><%.*s>\\n"" , ptr -> c . len , ptr -> c . s ) ; if ( set_ruri ( _m , & ptr -> c ) < 0 ) { LM_ERR ( ""unable<S2SV_blank>to<S2SV_blank>rewrite<S2SV_blank>Request-URI\\n"" ) ; ret = - 3 ; goto done ; } if ( ptr -> path . s && ptr -> path . len ) { if ( get_path_dst_uri ( & ptr -> path , & path_dst ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>dst_uri<S2SV_blank>for<S2SV_blank>Path\\n"" ) ; ret = - 3 ; goto done ; } if ( set_path_vector ( _m , & ptr -> path ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>path<S2SV_blank>vector\\n"" ) ; ret = - 3 ; goto done ; } if ( set_dst_uri ( _m , & path_dst ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>dst_uri<S2SV_blank>of<S2SV_blank>Path\\n"" ) ; ret = - 3 ; goto done ; } } else if ( ptr -> received . s && ptr -> received . len ) { if ( set_dst_uri ( _m , & ptr -> received ) < 0 ) { ret = - 3 ; goto done ; } } set_ruri_q ( ptr -> q ) ; setbflag ( 0 , ptr -> cflags ) ; if ( ptr -> sock ) _m -> force_send_socket = ptr -> sock ; if ( attr_avp_name != - 1 ) { istr . s = ptr -> attr ; if ( add_avp_last ( AVP_VAL_STR , attr_avp_name , istr ) != 0 ) { LM_ERR ( ""Failed<S2SV_blank>to<S2SV_blank>populate<S2SV_blank>attr<S2SV_blank>avp!\\n"" ) ; } } ptr = ptr -> next ; } if ( flags & REG_LOOKUP_NOBRANCH_FLAG || ( sip_instance . len && sip_instance . s ) ) goto done ; LM_DBG ( ""looking<S2SV_blank>for<S2SV_blank>branches\\n"" ) ; for ( ; ptr ; ptr = ptr -> next ) { if ( VALID_CONTACT ( ptr , act_time ) && allowed_method ( _m , ptr , flags ) ) { path_dst . len = 0 ; if ( ptr -> path . s && ptr -> path . len && get_path_dst_uri ( & ptr -> path , & path_dst ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>dst_uri<S2SV_blank>for<S2SV_blank>Path\\n"" ) ; continue ; } LM_DBG ( ""setting<S2SV_blank>branch<S2SV_blank><%.*s>\\n"" , ptr -> c . len , ptr -> c . s ) ; if ( append_branch ( _m , & ptr -> c , path_dst . len ? & path_dst : & ptr -> received , & ptr -> path , ptr -> q , ptr -> cflags , ptr -> sock ) == - 1 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>a<S2SV_blank>branch\\n"" ) ; continue ; } if ( attr_avp_name != - 1 ) { istr . s = ptr -> attr ; if ( add_avp_last ( AVP_VAL_STR , attr_avp_name , istr ) != 0 ) { LM_ERR ( ""Failed<S2SV_blank>to<S2SV_blank>populate<S2SV_blank>attr<S2SV_blank>avp!\\n"" ) ; } } } } done : ul . release_urecord ( r ) ; ul . unlock_udomain ( ( udomain_t * ) _t , & aor ) ; return ret ; }
","<S2SV_ModStart> ; } } it = it -> next ;
",OpenSIPS@opensips/54e027adfa486cfcf993828512b2e273aeb163c2,CVE-2013-3722,https://github.com/OpenSIPS/opensips/commit/54e027adfa486cfcf993828512b2e273aeb163c2,2020-02-17T17:15Z,<S2SV_StartBug> } <S2SV_EndBug>
617,CWE-20,"static void dissect_rpcap_packet ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * top_tree , proto_tree * parent_tree , gint offset , proto_item * top_item ) { proto_tree * tree ; proto_item * ti ; nstime_t ts ; tvbuff_t * new_tvb ; guint caplen , len , frame_no ; gint reported_length_remaining ; ti = proto_tree_add_item ( parent_tree , hf_packet , tvb , offset , 20 , ENC_NA ) ; tree = proto_item_add_subtree ( ti , ett_packet ) ; ts . secs = tvb_get_ntohl ( tvb , offset ) ; ts . nsecs = tvb_get_ntohl ( tvb , offset + 4 ) * 1000 ; proto_tree_add_time ( tree , hf_timestamp , tvb , offset , 8 , & ts ) ; offset += 8 ; caplen = tvb_get_ntohl ( tvb , offset ) ; ti = proto_tree_add_item ( tree , hf_caplen , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; len = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_len , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; frame_no = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_npkt , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; proto_item_append_text ( ti , "",<S2SV_blank>Frame<S2SV_blank>%u"" , frame_no ) ; proto_item_append_text ( top_item , ""<S2SV_blank>Frame<S2SV_blank>%u"" , frame_no ) ; reported_length_remaining = tvb_reported_length_remaining ( tvb , offset ) ; if ( caplen > ( guint ) reported_length_remaining ) { expert_add_info ( pinfo , ti , & ei_caplen_too_big ) ; return ; } new_tvb = tvb_new_subset ( tvb , offset , caplen , len ) ; if ( decode_content && linktype != WTAP_ENCAP_UNKNOWN ) { dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; if ( ! info_added ) { col_prepend_fence_fstr ( pinfo -> cinfo , COL_PROTOCOL , ""R|"" ) ; col_prepend_fence_fstr ( pinfo -> cinfo , COL_INFO , ""Remote<S2SV_blank>|<S2SV_blank>"" ) ; info_added = TRUE ; register_frame_end_routine ( pinfo , rpcap_frame_end ) ; } } else { if ( linktype == WTAP_ENCAP_UNKNOWN ) { proto_item_append_text ( ti , "",<S2SV_blank>Unknown<S2SV_blank>link-layer<S2SV_blank>type"" ) ; } call_dissector ( data_handle , new_tvb , pinfo , top_tree ) ; } }
","<S2SV_ModStart> ; gint reported_length_remaining ; struct eth_phdr eth ; void * phdr <S2SV_ModStart> WTAP_ENCAP_UNKNOWN ) { switch ( linktype ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> pinfo , top_tree , TRUE , phdr
",wireshark@wireshark/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,CVE-2016-5358,https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,2016-08-07T16:59Z,"<S2SV_StartBug> gint reported_length_remaining ; <S2SV_EndBug> <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; <S2SV_EndBug>"
7468,CWE-476,"VTermState * vterm_obtain_state ( VTerm * vt ) { VTermState * state ; if ( vt -> state ) return vt -> state ; state = vterm_state_new ( vt ) ; vt -> state = state ; state -> combine_chars_size = 16 ; state -> combine_chars = vterm_allocator_malloc ( state -> vt , state -> combine_chars_size * sizeof ( state -> combine_chars [ 0 ] ) ) ; state -> tabstops = vterm_allocator_malloc ( state -> vt , ( state -> cols + 7 ) / 8 ) ; state -> lineinfo = vterm_allocator_malloc ( state -> vt , state -> rows * sizeof ( VTermLineInfo ) ) ; state -> encoding_utf8 . enc = vterm_lookup_encoding ( ENC_UTF8 , 'u' ) ; if ( * state -> encoding_utf8 . enc -> init != NULL ) ( * state -> encoding_utf8 . enc -> init ) ( state -> encoding_utf8 . enc , state -> encoding_utf8 . data ) ; vterm_parser_set_callbacks ( vt , & parser_callbacks , state ) ; return state ; }
","<S2SV_ModStart> ( vt ) ; if ( state == NULL ) return NULL
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,<S2SV_StartBug> state = vterm_state_new ( vt ) ; <S2SV_EndBug>
3025,CWE-399,"static int misaligned_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_sign_extend ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } switch ( width_shift ) { case 1 : if ( do_sign_extend ) { regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s16 * ) & buffer ; } else { regs -> regs [ destreg ] = ( __u64 ) * ( __u16 * ) & buffer ; } break ; case 2 : regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s32 * ) & buffer ; break ; case 3 : regs -> regs [ destreg ] = buffer ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_load,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } else { __u64 lo , hi ; switch ( width_shift ) { case 1 : misaligned_kernel_word_load ( address , do_sign_extend , & regs -> regs [ destreg ] ) ; break ; case 2 : asm ( ""ldlo.l<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : ""=r"" ( lo ) : ""r"" ( address ) ) ; asm ( ""ldhi.l<S2SV_blank>%1,<S2SV_blank>3,<S2SV_blank>%0"" : ""=r"" ( hi ) : ""r"" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; case 3 : asm ( ""ldlo.q<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : ""=r"" ( lo ) : ""r"" ( address ) ) ; asm ( ""ldhi.q<S2SV_blank>%1,<S2SV_blank>7,<S2SV_blank>%0"" : ""=r"" ( hi ) : ""r"" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_load,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } return 0 ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug>"
1877,CWE-119,"void vp9_set_segment_data ( struct segmentation * seg , signed char * feature_data , unsigned char abs_delta ) { seg -> abs_delta = abs_delta ; vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ; }
","<S2SV_ModStart> = abs_delta ; memcpy <S2SV_ModEnd> ( seg ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ; <S2SV_EndBug>"
1357,CWE-119,"int vp8_alloc_frame_buffers ( VP8_COMMON * oci , int width , int height ) { int i ; vp8_de_alloc_frame_buffers ( oci ) ; if ( ( width & 0xf ) != 0 ) width += 16 - ( width & 0xf ) ; if ( ( height & 0xf ) != 0 ) height += 16 - ( height & 0xf ) ; for ( i = 0 ; i < NUM_YV12_BUFFERS ; i ++ ) { oci -> fb_idx_ref_cnt [ i ] = 0 ; oci -> yv12_fb [ i ] . flags = 0 ; if ( vp8_yv12_alloc_frame_buffer ( & oci -> yv12_fb [ i ] , width , height , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ; } oci -> new_fb_idx = 0 ; oci -> lst_fb_idx = 1 ; oci -> gld_fb_idx = 2 ; oci -> alt_fb_idx = 3 ; oci -> fb_idx_ref_cnt [ 0 ] = 1 ; oci -> fb_idx_ref_cnt [ 1 ] = 1 ; oci -> fb_idx_ref_cnt [ 2 ] = 1 ; oci -> fb_idx_ref_cnt [ 3 ] = 1 ; if ( vp8_yv12_alloc_frame_buffer ( & oci -> temp_scale_frame , width , 16 , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ; oci -> mb_rows = height >> 4 ; oci -> mb_cols = width >> 4 ; oci -> MBs = oci -> mb_rows * oci -> mb_cols ; oci -> mode_info_stride = oci -> mb_cols + 1 ; oci -> mip = vpx_calloc ( ( oci -> mb_cols + 1 ) * ( oci -> mb_rows + 1 ) , sizeof ( MODE_INFO ) ) ; if ( ! oci -> mip ) goto allocation_fail ; oci -> mi = oci -> mip + oci -> mode_info_stride + 1 ; oci -> above_context = vpx_calloc ( sizeof ( ENTROPY_CONTEXT_PLANES ) * oci -> mb_cols , 1 ) ; if ( ! oci -> above_context ) goto allocation_fail ; # if CONFIG_POSTPROC if ( vp8_yv12_alloc_frame_buffer ( & oci -> post_proc_buffer , width , height , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ; oci -> post_proc_buffer_int_used = 0 ; vpx_memset ( & oci -> postproc_state , 0 , sizeof ( oci -> postproc_state ) ) ; vpx_memset ( oci -> post_proc_buffer . buffer_alloc , 128 , oci -> post_proc_buffer . frame_size ) ; oci -> pp_limits_buffer = vpx_memalign ( 16 , 24 * ( ( oci -> mb_cols + 1 ) & ~ 1 ) ) ; if ( ! oci -> pp_limits_buffer ) goto allocation_fail ; # endif return 0 ; allocation_fail : vp8_de_alloc_frame_buffers ( oci ) ; return 1 ; }
","<S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( & oci <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( oci ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( & oci -> postproc_state , 0 , sizeof ( oci -> postproc_state ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( oci -> post_proc_buffer . buffer_alloc , 128 , <S2SV_EndBug>"
2251,CWE-416,"static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags , struct dev_pagemap * * pgmap ) { struct mm_struct * mm = vma -> vm_mm ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) { pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { * pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ; if ( * pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) get_page ( page ) ; if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }
","<S2SV_ModStart> & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags
",torvalds@linux/6b3a707736301c2128ca85ce85fb13f60b5e350a,CVE-2019-11487,https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a,2019-04-23T22:29Z,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug>
2318,CWE-20,"static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; int res , ret ; if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; futex_wait_queue_me ( hb , & q , to ) ; spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { WARN_ON ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - EFAULT ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - EINTR ) { ret = - EWOULDBLOCK ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }
","<S2SV_ModStart> res , ret ; if ( uaddr == uaddr2 ) return - EINVAL
",torvalds@linux/6f7b0a2a5c0fb03be7c25bd1745baa50582348ef,CVE-2012-6647,https://github.com/torvalds/linux/commit/6f7b0a2a5c0fb03be7c25bd1745baa50582348ef,2014-05-26T22:55Z,"<S2SV_StartBug> int res , ret ; <S2SV_EndBug>"
1300,CWE-476,"int nfc_llcp_send_cc ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( ""Sending<S2SV_blank>CC\\n"" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; size += miux_tlv_length ; rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; size += rw_tlv_length ; skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( ""error<S2SV_blank>%d\\n"" , err ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }
","<S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
",torvalds@linux/58bdd544e2933a21a51eecf17c3f5f94038261b5,CVE-2019-12818,https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5,2019-06-14T02:29Z,<S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug>
378,CWE-476,"krb5_error_code _kdc_as_rep ( kdc_request_t r , krb5_data * reply , const char * from , struct sockaddr * from_addr , int datagram_reply ) { krb5_context context = r -> context ; krb5_kdc_configuration * config = r -> config ; KDC_REQ * req = & r -> req ; KDC_REQ_BODY * b = NULL ; AS_REP rep ; KDCOptions f ; krb5_enctype setype ; krb5_error_code ret = 0 ; Key * skey ; int found_pa = 0 ; int i , flags = HDB_F_FOR_AS_REQ ; METHOD_DATA error_method ; const PA_DATA * pa ; memset ( & rep , 0 , sizeof ( rep ) ) ; error_method . len = 0 ; error_method . val = NULL ; ret = _kdc_fast_unwrap_request ( r ) ; if ( ret ) { _kdc_r_log ( r , 0 , ""FAST<S2SV_blank>unwrap<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%d"" , from , ret ) ; goto out ; } b = & req -> req_body ; f = b -> kdc_options ; if ( f . canonicalize ) flags |= HDB_F_CANON ; if ( b -> sname == NULL ) { ret = KRB5KRB_ERR_GENERIC ; _kdc_set_e_text ( r , ""No<S2SV_blank>server<S2SV_blank>in<S2SV_blank>request"" ) ; } else { ret = _krb5_principalname2krb5_principal ( context , & r -> server_princ , * ( b -> sname ) , b -> realm ) ; if ( ret == 0 ) ret = krb5_unparse_name ( context , r -> server_princ , & r -> server_name ) ; } if ( ret ) { kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>malformed<S2SV_blank>server<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s"" , from ) ; goto out ; } if ( b -> cname == NULL ) { ret = KRB5KRB_ERR_GENERIC ; _kdc_set_e_text ( r , ""No<S2SV_blank>client<S2SV_blank>in<S2SV_blank>request"" ) ; } else { ret = _krb5_principalname2krb5_principal ( context , & r -> client_princ , * ( b -> cname ) , b -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , r -> client_princ , & r -> client_name ) ; } if ( ret ) { kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>malformed<S2SV_blank>client<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s"" , from ) ; goto out ; } kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , r -> client_name , from , r -> server_name ) ; if ( _kdc_is_anonymous ( context , r -> client_princ ) ) { if ( ! _kdc_is_anon_request ( b ) ) { kdc_log ( context , config , 0 , ""Anonymous<S2SV_blank>ticket<S2SV_blank>w/o<S2SV_blank>anonymous<S2SV_blank>flag"" ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } } else if ( _kdc_is_anon_request ( b ) ) { kdc_log ( context , config , 0 , ""Request<S2SV_blank>for<S2SV_blank>a<S2SV_blank>anonymous<S2SV_blank>ticket<S2SV_blank>with<S2SV_blank>non<S2SV_blank>"" ""anonymous<S2SV_blank>client<S2SV_blank>name:<S2SV_blank>%s"" , r -> client_name ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_db_fetch ( context , config , r -> client_princ , HDB_F_GET_CLIENT | flags , NULL , & r -> clientdb , & r -> client ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""client<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> client_name ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { char * fixed_client_name = NULL ; ret = krb5_unparse_name ( context , r -> client -> entry . principal , & fixed_client_name ) ; if ( ret ) { goto out ; } kdc_log ( context , config , 0 , ""WRONG_REALM<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s"" , r -> client_name , fixed_client_name ) ; free ( fixed_client_name ) ; ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , KRB5_KDC_ERR_WRONG_REALM , NULL , r -> server_princ , NULL , & r -> client -> entry . principal -> realm , NULL , NULL , reply ) ; goto out ; } else if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> client_name , msg ) ; krb5_free_error_message ( context , msg ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_db_fetch ( context , config , r -> server_princ , HDB_F_GET_SERVER | HDB_F_GET_KRBTGT | flags , NULL , NULL , & r -> server ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> server_name ) ; goto out ; } else if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> server_name , msg ) ; krb5_free_error_message ( context , msg ) ; ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , r -> server_princ ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , r -> client , b -> etype . val , b -> etype . len , & r -> sessionetype , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Client<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>common<S2SV_blank>enctypes<S2SV_blank>with<S2SV_blank>KDC<S2SV_blank>"" ""to<S2SV_blank>use<S2SV_blank>for<S2SV_blank>the<S2SV_blank>session<S2SV_blank>key"" , r -> client_name , from ) ; goto out ; } if ( req -> padata ) { unsigned int n ; log_patypes ( context , config , req -> padata ) ; for ( n = 0 ; ! found_pa && n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ; n ++ ) { if ( pat [ n ] . validate == NULL ) continue ; if ( r -> armor_crypto == NULL && ( pat [ n ] . flags & PA_REQ_FAST ) ) continue ; kdc_log ( context , config , 5 , ""Looking<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>pa-data<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ; i = 0 ; pa = _kdc_find_padata ( req , & i , pat [ n ] . type ) ; if ( pa ) { ret = pat [ n ] . validate ( r , pa ) ; if ( ret != 0 ) { goto out ; } kdc_log ( context , config , 0 , ""%s<S2SV_blank>pre-authentication<S2SV_blank>succeeded<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ; found_pa = 1 ; r -> et . flags . pre_authent = 1 ; } } } if ( found_pa == 0 ) { Key * ckey = NULL ; size_t n ; for ( n = 0 ; n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ; n ++ ) { if ( ( pat [ n ] . flags & PA_ANNOUNCE ) == 0 ) continue ; ret = krb5_padata_add ( context , & error_method , pat [ n ] . type , NULL , 0 ) ; if ( ret ) goto out ; } ret = _kdc_find_etype ( context , config -> preauth_use_strongest_session_key , TRUE , r -> client , b -> etype . val , b -> etype . len , NULL , & ckey ) ; if ( ret == 0 ) { if ( older_enctype ( ckey -> key . keytype ) ) { ret = get_pa_etype_info ( context , config , & error_method , ckey ) ; if ( ret ) goto out ; } ret = get_pa_etype_info2 ( context , config , & error_method , ckey ) ; if ( ret ) goto out ; } if ( require_preauth_p ( r ) || _kdc_is_anon_request ( b ) ) { ret = KRB5KDC_ERR_PREAUTH_REQUIRED ; _kdc_set_e_text ( r , ""Need<S2SV_blank>to<S2SV_blank>use<S2SV_blank>PA-ENC-TIMESTAMP/PA-PK-AS-REQ"" ) ; goto out ; } if ( ckey == NULL ) { ret = KRB5KDC_ERR_CLIENT_NOTYET ; _kdc_set_e_text ( r , ""Doesn\'t<S2SV_blank>have<S2SV_blank>a<S2SV_blank>client<S2SV_blank>key<S2SV_blank>available"" ) ; goto out ; } krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ; ret = krb5_copy_keyblock_contents ( r -> context , & ckey -> key , & r -> reply_key ) ; if ( ret ) goto out ; } if ( r -> clientdb -> hdb_auth_status ) { r -> clientdb -> hdb_auth_status ( context , r -> clientdb , r -> client , HDB_AUTH_SUCCESS ) ; } ret = _kdc_check_access ( context , config , r -> client , r -> client_name , r -> server , r -> server_name , req , & error_method ) ; if ( ret ) goto out ; ret = _kdc_get_preferred_key ( context , config , r -> server , r -> server_name , & setype , & skey ) ; if ( ret ) goto out ; if ( f . renew || f . validate || f . proxy || f . forwarded || f . enc_tkt_in_skey || ( _kdc_is_anon_request ( b ) && ! config -> allow_anonymous ) ) { ret = KRB5KDC_ERR_BADOPTION ; _kdc_set_e_text ( r , ""Bad<S2SV_blank>KDC<S2SV_blank>options"" ) ; goto out ; } rep . pvno = 5 ; rep . msg_type = krb_as_rep ; if ( _kdc_is_anonymous ( context , r -> client_princ ) ) { Realm anon_realm = KRB5_ANON_REALM ; ret = copy_Realm ( & anon_realm , & rep . crealm ) ; } else ret = copy_Realm ( & r -> client -> entry . principal -> realm , & rep . crealm ) ; if ( ret ) goto out ; ret = _krb5_principal2principalname ( & rep . cname , r -> client -> entry . principal ) ; if ( ret ) goto out ; rep . ticket . tkt_vno = 5 ; ret = copy_Realm ( & r -> server -> entry . principal -> realm , & rep . ticket . realm ) ; if ( ret ) goto out ; _krb5_principal2principalname ( & rep . ticket . sname , r -> server -> entry . principal ) ; # define CNT ( sp , t ) ( ( ( sp ) -> sname -> name_type ) == KRB5_NT_ ## t ) if ( CNT ( b , UNKNOWN ) || CNT ( b , PRINCIPAL ) || CNT ( b , SRV_INST ) || CNT ( b , SRV_HST ) || CNT ( b , SRV_XHST ) ) rep . ticket . sname . name_type = b -> sname -> name_type ; # undef CNT r -> et . flags . initial = 1 ; if ( r -> client -> entry . flags . forwardable && r -> server -> entry . flags . forwardable ) r -> et . flags . forwardable = f . forwardable ; else if ( f . forwardable ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>forwardable"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( r -> client -> entry . flags . proxiable && r -> server -> entry . flags . proxiable ) r -> et . flags . proxiable = f . proxiable ; else if ( f . proxiable ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>proxiable"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( r -> client -> entry . flags . postdate && r -> server -> entry . flags . postdate ) r -> et . flags . may_postdate = f . allow_postdate ; else if ( f . allow_postdate ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>postdate"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( ! _kdc_check_addresses ( context , config , b -> addresses , from_addr ) ) { _kdc_set_e_text ( r , ""Bad<S2SV_blank>address<S2SV_blank>list<S2SV_blank>in<S2SV_blank>requested"" ) ; ret = KRB5KRB_AP_ERR_BADADDR ; goto out ; } ret = copy_PrincipalName ( & rep . cname , & r -> et . cname ) ; if ( ret ) goto out ; ret = copy_Realm ( & rep . crealm , & r -> et . crealm ) ; if ( ret ) goto out ; { time_t start ; time_t t ; start = r -> et . authtime = kdc_time ; if ( f . postdated && req -> req_body . from ) { ALLOC ( r -> et . starttime ) ; start = * r -> et . starttime = * req -> req_body . from ; r -> et . flags . invalid = 1 ; r -> et . flags . postdated = 1 ; } _kdc_fix_time ( & b -> till ) ; t = * b -> till ; if ( r -> client -> entry . max_life ) t = start + min ( t - start , * r -> client -> entry . max_life ) ; if ( r -> server -> entry . max_life ) t = start + min ( t - start , * r -> server -> entry . max_life ) ; # if 0 t = min ( t , start + realm -> max_life ) ; # endif r -> et . endtime = t ; if ( f . renewable_ok && r -> et . endtime < * b -> till ) { f . renewable = 1 ; if ( b -> rtime == NULL ) { ALLOC ( b -> rtime ) ; * b -> rtime = 0 ; } if ( * b -> rtime < * b -> till ) * b -> rtime = * b -> till ; } if ( f . renewable && b -> rtime ) { t = * b -> rtime ; if ( t == 0 ) t = MAX_TIME ; if ( r -> client -> entry . max_renew ) t = start + min ( t - start , * r -> client -> entry . max_renew ) ; if ( r -> server -> entry . max_renew ) t = start + min ( t - start , * r -> server -> entry . max_renew ) ; # if 0 t = min ( t , start + realm -> max_renew ) ; # endif ALLOC ( r -> et . renew_till ) ; * r -> et . renew_till = t ; r -> et . flags . renewable = 1 ; } } if ( _kdc_is_anon_request ( b ) ) r -> et . flags . anonymous = 1 ; if ( b -> addresses ) { ALLOC ( r -> et . caddr ) ; copy_HostAddresses ( b -> addresses , r -> et . caddr ) ; } r -> et . transited . tr_type = DOMAIN_X500_COMPRESS ; krb5_data_zero ( & r -> et . transited . contents ) ; r -> ek . last_req . val = malloc ( 2 * sizeof ( * r -> ek . last_req . val ) ) ; if ( r -> ek . last_req . val == NULL ) { ret = ENOMEM ; goto out ; } r -> ek . last_req . len = 0 ; if ( r -> client -> entry . pw_end && ( config -> kdc_warn_pwexpire == 0 || kdc_time + config -> kdc_warn_pwexpire >= * r -> client -> entry . pw_end ) ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_PW_EXPTIME ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = * r -> client -> entry . pw_end ; ++ r -> ek . last_req . len ; } if ( r -> client -> entry . valid_end ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_ACCT_EXPTIME ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = * r -> client -> entry . valid_end ; ++ r -> ek . last_req . len ; } if ( r -> ek . last_req . len == 0 ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_NONE ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = 0 ; ++ r -> ek . last_req . len ; } r -> ek . nonce = b -> nonce ; if ( r -> client -> entry . valid_end || r -> client -> entry . pw_end ) { ALLOC ( r -> ek . key_expiration ) ; if ( r -> client -> entry . valid_end ) { if ( r -> client -> entry . pw_end ) * r -> ek . key_expiration = min ( * r -> client -> entry . valid_end , * r -> client -> entry . pw_end ) ; else * r -> ek . key_expiration = * r -> client -> entry . valid_end ; } else * r -> ek . key_expiration = * r -> client -> entry . pw_end ; } else r -> ek . key_expiration = NULL ; r -> ek . flags = r -> et . flags ; r -> ek . authtime = r -> et . authtime ; if ( r -> et . starttime ) { ALLOC ( r -> ek . starttime ) ; * r -> ek . starttime = * r -> et . starttime ; } r -> ek . endtime = r -> et . endtime ; if ( r -> et . renew_till ) { ALLOC ( r -> ek . renew_till ) ; * r -> ek . renew_till = * r -> et . renew_till ; } ret = copy_Realm ( & rep . ticket . realm , & r -> ek . srealm ) ; if ( ret ) goto out ; ret = copy_PrincipalName ( & rep . ticket . sname , & r -> ek . sname ) ; if ( ret ) goto out ; if ( r -> et . caddr ) { ALLOC ( r -> ek . caddr ) ; copy_HostAddresses ( r -> et . caddr , r -> ek . caddr ) ; } if ( r -> session_key . keytype == ETYPE_NULL ) { ret = krb5_generate_random_keyblock ( context , r -> sessionetype , & r -> session_key ) ; if ( ret ) goto out ; } if ( r -> reply_key . keytype == ETYPE_NULL ) { _kdc_set_e_text ( r , ""Client<S2SV_blank>have<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>key"" ) ; ret = KRB5KDC_ERR_CLIENT_NOTYET ; goto out ; } ret = copy_EncryptionKey ( & r -> session_key , & r -> et . key ) ; if ( ret ) goto out ; ret = copy_EncryptionKey ( & r -> session_key , & r -> ek . key ) ; if ( ret ) goto out ; if ( r -> outpadata . len ) { ALLOC ( rep . padata ) ; if ( rep . padata == NULL ) { ret = ENOMEM ; goto out ; } ret = copy_METHOD_DATA ( & r -> outpadata , rep . padata ) ; if ( ret ) goto out ; } if ( send_pac_p ( context , req ) ) { generate_pac ( r , skey ) ; } _kdc_log_timestamp ( context , config , ""AS-REQ"" , r -> et . authtime , r -> et . starttime , r -> et . endtime , r -> et . renew_till ) ; ret = _kdc_add_KRB5SignedPath ( context , config , r -> server , setype , r -> client -> entry . principal , NULL , NULL , & r -> et ) ; if ( ret ) goto out ; log_as_req ( context , config , r -> reply_key . keytype , setype , b ) ; r -> et . flags . enc_pa_rep = r -> ek . flags . enc_pa_rep = 1 ; i = 0 ; pa = _kdc_find_padata ( req , & i , KRB5_PADATA_REQ_ENC_PA_REP ) ; if ( pa ) { ret = add_enc_pa_rep ( r ) ; if ( ret ) { const char * msg = krb5_get_error_message ( r -> context , ret ) ; _kdc_r_log ( r , 0 , ""add_enc_pa_rep<S2SV_blank>failed:<S2SV_blank>%s:<S2SV_blank>%d"" , msg , ret ) ; krb5_free_error_message ( r -> context , msg ) ; goto out ; } } ret = _kdc_encode_reply ( context , config , r -> armor_crypto , req -> req_body . nonce , & rep , & r -> et , & r -> ek , setype , r -> server -> entry . kvno , & skey -> key , r -> client -> entry . kvno , & r -> reply_key , 0 , & r -> e_text , reply ) ; if ( ret ) goto out ; if ( datagram_reply && reply -> length > config -> max_datagram_reply_length ) { krb5_data_free ( reply ) ; ret = KRB5KRB_ERR_RESPONSE_TOO_BIG ; _kdc_set_e_text ( r , ""Reply<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>large"" ) ; } out : free_AS_REP ( & rep ) ; if ( ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply -> length == 0 ) { ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , ret , r -> e_text , r -> server_princ , & r -> client_princ -> name , & r -> client_princ -> realm , NULL , NULL , reply ) ; if ( ret ) goto out2 ; } out2 : free_EncTicketPart ( & r -> et ) ; free_EncKDCRepPart ( & r -> ek ) ; free_KDCFastState ( & r -> fast ) ; if ( error_method . len ) free_METHOD_DATA ( & error_method ) ; if ( r -> outpadata . len ) free_METHOD_DATA ( & r -> outpadata ) ; if ( r -> client_princ ) { krb5_free_principal ( context , r -> client_princ ) ; r -> client_princ = NULL ; } if ( r -> client_name ) { free ( r -> client_name ) ; r -> client_name = NULL ; } if ( r -> server_princ ) { krb5_free_principal ( context , r -> server_princ ) ; r -> server_princ = NULL ; } if ( r -> server_name ) { free ( r -> server_name ) ; r -> server_name = NULL ; } if ( r -> client ) _kdc_free_ent ( context , r -> client ) ; if ( r -> server ) _kdc_free_ent ( context , r -> server ) ; if ( r -> armor_crypto ) { krb5_crypto_destroy ( r -> context , r -> armor_crypto ) ; r -> armor_crypto = NULL ; } krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ; krb5_free_keyblock_contents ( r -> context , & r -> session_key ) ; return ret ; }
","<S2SV_ModStart> -> server_princ , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> name : NULL , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> realm : NULL <S2SV_ModEnd> , NULL ,
",heimdal@heimdal/1a6a6e462dc2ac6111f9e02c6852ddec4849b887,CVE-2017-17439,https://github.com/heimdal/heimdal/commit/1a6a6e462dc2ac6111f9e02c6852ddec4849b887,2017-12-06T15:29Z,"<S2SV_StartBug> & r -> client_princ -> name , <S2SV_EndBug> <S2SV_StartBug> & r -> client_princ -> realm , <S2SV_EndBug>"
2180,CWE-20,"int res_inverse ( vorbis_dsp_state * vd , vorbis_info_residue * info , ogg_int32_t * * in , int * nonzero , int ch ) { int i , j , k , s , used = 0 ; codec_setup_info * ci = ( codec_setup_info * ) vd -> vi -> codec_setup ; codebook * phrasebook = ci -> book_param + info -> groupbook ; int samples_per_partition = info -> grouping ; int partitions_per_word = phrasebook -> dim ; int pcmend = ci -> blocksizes [ vd -> W ] ; if ( info -> type < 2 ) { int max = pcmend >> 1 ; int end = ( info -> end < max ? info -> end : max ) ; int n = end - info -> begin ; if ( n > 0 ) { int partvals = n / samples_per_partition ; int partwords = ( partvals + partitions_per_word - 1 ) / partitions_per_word ; for ( i = 0 ; i < ch ; i ++ ) if ( nonzero [ i ] ) in [ used ++ ] = in [ i ] ; ch = used ; if ( used ) { char * * partword = ( char * * ) alloca ( ch * sizeof ( * partword ) ) ; for ( j = 0 ; j < ch ; j ++ ) partword [ j ] = ( char * ) alloca ( partwords * partitions_per_word * sizeof ( * partword [ j ] ) ) ; for ( s = 0 ; s < info -> stages ; s ++ ) { for ( i = 0 ; i < partvals ; ) { if ( s == 0 ) { partword [ 0 ] [ i + partitions_per_word - 1 ] = 1 ; for ( k = partitions_per_word - 2 ; k >= 0 ; k -- ) partword [ 0 ] [ i + k ] = partword [ 0 ] [ i + k + 1 ] * info -> partitions ; for ( j = 1 ; j < ch ; j ++ ) for ( k = partitions_per_word - 1 ; k >= 0 ; k -- ) partword [ j ] [ i + k ] = partword [ j - 1 ] [ i + k ] ; for ( j = 0 ; j < ch ; j ++ ) { int temp = vorbis_book_decode ( phrasebook , & vd -> opb ) ; if ( temp == - 1 ) goto eopbreak ; for ( k = 0 ; k < partitions_per_word ; k ++ ) { ogg_uint32_t div = partword [ j ] [ i + k ] ; partword [ j ] [ i + k ] = temp / div ; temp -= partword [ j ] [ i + k ] * div ; } } } for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) for ( j = 0 ; j < ch ; j ++ ) { long offset = info -> begin + i * samples_per_partition ; if ( info -> stagemasks [ ( int ) partword [ j ] [ i ] ] & ( 1 << s ) ) { codebook * stagebook = ci -> book_param + info -> stagebooks [ ( partword [ j ] [ i ] << 3 ) + s ] ; if ( info -> type ) { if ( vorbis_book_decodev_add ( stagebook , in [ j ] + offset , & vd -> opb , samples_per_partition , - 8 ) == - 1 ) goto eopbreak ; } else { if ( vorbis_book_decodevs_add ( stagebook , in [ j ] + offset , & vd -> opb , samples_per_partition , - 8 ) == - 1 ) goto eopbreak ; } } } } } } } } else { int max = ( pcmend * ch ) >> 1 ; int end = ( info -> end < max ? info -> end : max ) ; int n = end - info -> begin ; if ( n > 0 ) { int partvals = n / samples_per_partition ; int partwords = ( partvals + partitions_per_word - 1 ) / partitions_per_word ; char * partword = ( char * ) alloca ( partwords * partitions_per_word * sizeof ( * partword ) ) ; int beginoff = info -> begin / ch ; for ( i = 0 ; i < ch ; i ++ ) if ( nonzero [ i ] ) break ; if ( i == ch ) return ( 0 ) ; samples_per_partition /= ch ; for ( s = 0 ; s < info -> stages ; s ++ ) { for ( i = 0 ; i < partvals ; ) { if ( s == 0 ) { int temp ; partword [ i + partitions_per_word - 1 ] = 1 ; for ( k = partitions_per_word - 2 ; k >= 0 ; k -- ) partword [ i + k ] = partword [ i + k + 1 ] * info -> partitions ; temp = vorbis_book_decode ( phrasebook , & vd -> opb ) ; if ( temp == - 1 ) goto eopbreak ; for ( k = 0 ; k < partitions_per_word ; k ++ ) { ogg_uint32_t div = partword [ i + k ] ; partword [ i + k ] = temp / div ; temp -= partword [ i + k ] * div ; } } for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) if ( info -> stagemasks [ ( int ) partword [ i ] ] & ( 1 << s ) ) { codebook * stagebook = ci -> book_param + info -> stagebooks [ ( partword [ i ] << 3 ) + s ] ; if ( vorbis_book_decodevv_add ( stagebook , in , i * samples_per_partition + beginoff , ch , & vd -> opb , samples_per_partition , - 8 ) == - 1 ) goto eopbreak ; } } } } } eopbreak : return 0 ; }
","<S2SV_ModStart> * samples_per_partition ; int idx = ( int ) partword [ j ] [ i ] ; if ( idx < info -> partitions && <S2SV_ModEnd> info -> stagemasks <S2SV_ModStart> -> stagemasks [ idx <S2SV_ModEnd> ] & (
",external@tremolo/659030a2e80c38fb8da0a4eb68695349eec6778b,CVE-2016-3756,https://android.googlesource.com/platform/external/tremolo/+/659030a2e80c38fb8da0a4eb68695349eec6778b,2016-07-11T01:59Z,<S2SV_StartBug> if ( info -> stagemasks [ ( int ) partword [ j ] [ i ] ] & ( 1 << s ) ) { <S2SV_EndBug>
3129,CWE-399,"static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) { guint32 size ; int end_offset ; if ( di -> conformant_run ) return offset ; offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ; end_offset = offset + ( size * 2 ) ; if ( end_offset < offset ) { end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ; } while ( offset < end_offset ) offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ; return offset ; }
","<S2SV_ModStart> while ( offset > 0 && offset <S2SV_ModStart> < end_offset ) { <S2SV_ModStart> hf_keybuffer ) ; }
",wireshark@wireshark/b4d16b4495b732888e12baf5b8a7e9bf2665e22b,CVE-2016-5350,https://github.com/wireshark/wireshark/commit/b4d16b4495b732888e12baf5b8a7e9bf2665e22b,2016-08-07T16:59Z,<S2SV_StartBug> while ( offset < end_offset ) <S2SV_EndBug> <S2SV_StartBug> return offset ; <S2SV_EndBug>
1530,CWE-119,"MB_PREDICTION_MODE vp9_above_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO * above_mi , int b ) { if ( b == 0 || b == 1 ) { if ( ! above_mi || is_inter_block ( & above_mi -> mbmi ) ) return DC_PRED ; return get_y_mode ( above_mi , b + 2 ) ; } else { assert ( b == 2 || b == 3 ) ; return cur_mi -> bmi [ b - 2 ] . as_mode ; } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_above_block_mode ( const
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> MB_PREDICTION_MODE vp9_above_block_mode ( const MODE_INFO * cur_mi , <S2SV_EndBug>"
8201,CWE-79,"void interprete ( char * lbook , char * path ) { int status , i , j , n , message_id , inactive ; char list [ 1000 ] , section [ 256 ] , str [ NAME_LENGTH ] , str1 [ NAME_LENGTH ] , str2 [ NAME_LENGTH ] , edit_id [ 80 ] , file_name [ 256 ] , command [ 256 ] , enc_path [ 256 ] , dec_path [ 256 ] , uname [ 80 ] , full_name [ 256 ] , user_email [ 256 ] , logbook [ 256 ] , logbook_enc [ 256 ] , * experiment , group [ 256 ] , css [ 256 ] , * pfile , attachment [ MAX_PATH_LENGTH ] , str3 [ NAME_LENGTH ] , thumb_name [ 256 ] , sid [ 32 ] , error_str [ 256 ] , subdir [ 256 ] , * s ; LOGBOOK * lbs ; FILE * f ; strcpy ( dec_path , path ) ; url_decode ( dec_path ) ; strcpy ( enc_path , dec_path ) ; url_encode ( enc_path , sizeof ( enc_path ) ) ; strencode2 ( command , isparam ( ""cmd"" ) ? getparam ( ""cmd"" ) : """" , sizeof ( command ) ) ; strencode2 ( group , isparam ( ""group"" ) ? getparam ( ""group"" ) : """" , sizeof ( group ) ) ; experiment = getparam ( ""exp"" ) ; if ( getcfg ( lbook , ""Logging<S2SV_blank>Level"" , str , sizeof ( str ) ) ) _logging_level = atoi ( str ) ; else _logging_level = 2 ; set_condition ( """" ) ; message_id = atoi ( dec_path ) ; if ( isparam ( ""jcmd"" ) && * getparam ( ""jcmd"" ) ) strlcpy ( command , getparam ( ""jcmd"" ) , sizeof ( command ) ) ; if ( stricmp ( command , ""loc"" ) == 0 ) { show_http_header ( NULL , FALSE , NULL ) ; if ( isparam ( ""value"" ) && * getparam ( ""value"" ) ) rsputs ( loc ( getparam ( ""value"" ) ) ) ; s = loc ( ""Drop<S2SV_blank>attachments<S2SV_blank>here..."" ) ; s = loc ( ""Insert<S2SV_blank>Timestamp"" ) ; if ( s ) s = NULL ; return ; } if ( experiment && experiment [ 0 ] ) { strcpy ( logbook_enc , experiment ) ; strcpy ( logbook , experiment ) ; url_decode ( logbook ) ; for ( i = 0 ; ; i ++ ) { if ( ! enumgrp ( i , str ) ) break ; if ( strieq ( logbook , str ) ) break ; } if ( ! strieq ( logbook , str ) ) { sprintf ( str , ""Error:<S2SV_blank>logbook<S2SV_blank>\\""%s\\""<S2SV_blank>not<S2SV_blank>defined<S2SV_blank>in<S2SV_blank>%s"" , logbook_enc , CFGFILE ) ; show_error ( str ) ; return ; } } else { strcpy ( logbook_enc , lbook ) ; strcpy ( logbook , lbook ) ; url_decode ( logbook ) ; } setcfg_topgroup ( """" ) ; sprintf ( str , ""Top<S2SV_blank>group<S2SV_blank>%s"" , logbook ) ; if ( getcfg ( ""global"" , str , list , sizeof ( list ) ) ) { setcfg_topgroup ( logbook ) ; logbook [ 0 ] = 0 ; } for ( i = j = 0 ; ; i ++ ) { if ( ! enumgrp ( i , str ) ) break ; if ( is_logbook ( str ) ) { if ( ! strieq ( str , lb_list [ j ++ ] . name ) ) { el_index_logbooks ( ) ; break ; } } } if ( lb_list [ j ] . name [ 0 ] != 0 ) el_index_logbooks ( ) ; if ( ! logbook [ 0 ] ) { if ( getcfg ( group , ""Self<S2SV_blank>register"" , str , sizeof ( str ) ) && atoi ( str ) > 0 ) { if ( ! do_self_register ( NULL , getparam ( ""cmd"" ) ) ) return ; } if ( strieq ( command , loc ( ""Activate"" ) ) && isparam ( ""new_user_name"" ) && isparam ( ""code"" ) ) { if ( ! activate_user ( NULL , getparam ( ""new_user_name"" ) , atoi ( getparam ( ""code"" ) ) ) ) return ; setparam ( ""cfg_user"" , getparam ( ""new_user_name"" ) ) ; get_user_line ( NULL , getparam ( ""new_user_name"" ) , NULL , full_name , user_email , NULL , NULL , NULL ) ; sprintf ( str , ""%s<S2SV_blank><b>&lt;%s&gt;</b>"" , full_name , user_email ) ; sprintf ( str2 , loc ( ""Activation<S2SV_blank>notice<S2SV_blank>has<S2SV_blank>been<S2SV_blank>sent<S2SV_blank>to<S2SV_blank>%s"" ) , str ) ; setparam ( ""notice"" , str2 ) ; show_config_page ( NULL ) ; return ; } if ( strieq ( command , loc ( ""Save"" ) ) ) { if ( isparam ( ""config"" ) ) { if ( ! isparam ( ""config"" ) || ! save_user_config ( NULL , getparam ( ""config"" ) , FALSE ) ) return ; } redirect ( NULL , ""."" ) ; return ; } if ( isparam ( ""cmd"" ) || isparam ( ""newpwd"" ) ) { if ( isparam ( ""newpwd"" ) || strieq ( command , loc ( ""Change<S2SV_blank>password"" ) ) ) { if ( sid_check ( getparam ( ""sid"" ) , uname ) ) setparam ( ""unm"" , uname ) ; show_change_pwd_page ( NULL ) ; return ; } } if ( isparam ( ""uname"" ) && isparam ( ""upassword"" ) ) { strlcpy ( uname , getparam ( ""uname"" ) , sizeof ( uname ) ) ; sprintf ( str , ""LOGIN<S2SV_blank>user<S2SV_blank>\\""%s\\""<S2SV_blank>(attempt)<S2SV_blank>for<S2SV_blank>logbook<S2SV_blank>selection<S2SV_blank>page"" , uname ) ; write_logfile ( NULL , str ) ; if ( isparam ( ""redir"" ) ) strlcpy ( str , getparam ( ""redir"" ) , sizeof ( str ) ) ; else strlcpy ( str , isparam ( ""cmdline"" ) ? getparam ( ""cmdline"" ) : """" , sizeof ( str ) ) ; if ( ! auth_verify_password ( NULL , uname , getparam ( ""upassword"" ) , error_str , sizeof ( error_str ) ) ) { if ( error_str [ 0 ] ) show_error ( error_str ) ; else show_login_page ( NULL , str , 1 ) ; return ; } if ( get_user_line ( NULL , uname , NULL , full_name , NULL , NULL , NULL , NULL ) == 2 ) { if ( ! getcfg ( group , ""Self<S2SV_blank>register"" , str , sizeof ( str ) ) || atoi ( str ) == 0 ) { show_login_page ( NULL , str , 1 ) ; return ; } # ifdef HAVE_PAM getcfg ( NULL , ""Authentication"" , str , sizeof ( str ) ) ; if ( stristr ( str , ""PAM"" ) ) { show_new_user_page ( NULL , uname ) ; return ; } # endif } set_user_password ( NULL , uname , getparam ( ""upassword"" ) ) ; sprintf ( str , ""LOGIN<S2SV_blank>user<S2SV_blank>\\""%s\\""<S2SV_blank>(success)"" , uname ) ; write_logfile ( NULL , str ) ; sid_new ( NULL , uname , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; set_sid_cookie ( NULL , sid , full_name ) ; return ; } if ( ! logbook [ 0 ] && getcfg ( ""global"" , ""Selection<S2SV_blank>page"" , str , sizeof ( str ) ) ) { if ( strstr ( str , ""http://"" ) || strstr ( str , ""https://"" ) ) { redirect ( NULL , str ) ; return ; } if ( str [ 0 ] == DIR_SEPARATOR || str [ 1 ] == ':' ) strlcpy ( file_name , str , sizeof ( file_name ) ) ; else { strlcpy ( file_name , logbook_dir , sizeof ( file_name ) ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } send_file_direct ( file_name ) ; return ; } if ( strieq ( command , ""Synchronize"" ) ) { synchronize ( NULL , SYNC_HTML ) ; return ; } } for ( n = 0 ; lb_list [ n ] . name [ 0 ] ; n ++ ) ; if ( ! logbook [ 0 ] && ! path [ 0 ] ) { if ( n > 1 ) { if ( strieq ( command , loc ( ""Forgot"" ) ) ) { show_forgot_pwd_page ( NULL ) ; return ; } show_selection_page ( ) ; return ; } strcpy ( logbook , lb_list [ 0 ] . name ) ; strcpy ( logbook_enc , logbook ) ; url_encode ( logbook_enc , sizeof ( logbook_enc ) ) ; } for ( i = 0 ; lb_list [ i ] . name [ 0 ] ; i ++ ) if ( strieq ( logbook , lb_list [ i ] . name ) ) break ; lbs = & lb_list [ i ] ; if ( lbs -> top_group [ 0 ] ) setcfg_topgroup ( lbs -> top_group ) ; if ( getcfg ( logbook , ""Theme"" , str , sizeof ( str ) ) ) strlcpy ( theme_name , str , sizeof ( theme_name ) ) ; else strlcpy ( theme_name , ""default"" , sizeof ( theme_name ) ) ; lbs = lb_list + i ; lbs -> n_attr = scan_attributes ( lbs -> name ) ; if ( lbs -> n_attr < 0 ) return ; if ( isparam ( ""acmd"" ) && * getparam ( ""acmd"" ) ) { if ( strieq ( getparam ( ""acmd"" ) , ""Upload"" ) ) show_uploader_json ( lbs ) ; return ; } getcfg ( lbs -> name , ""Authentication"" , str , sizeof ( str ) ) ; if ( stristr ( str , ""Webserver"" ) ) { if ( http_user [ 0 ] ) { if ( ! sid_check ( getparam ( ""sid"" ) , http_user ) ) { sid_new ( lbs , http_user , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; set_sid_cookie ( lbs , sid , http_user ) ; } } else { sprintf ( str , ""Error:<S2SV_blank>Misconfigured<S2SV_blank>webserver,<S2SV_blank>did<S2SV_blank>not<S2SV_blank>get<S2SV_blank>X-Forwarded-User<S2SV_blank>from<S2SV_blank>it."" ) ; show_error ( str ) ; return ; } } if ( isparam ( ""uname"" ) && isparam ( ""upassword"" ) ) { strlcpy ( uname , getparam ( ""uname"" ) , sizeof ( uname ) ) ; sprintf ( str , ""LOGIN<S2SV_blank>user<S2SV_blank>\\""%s\\""<S2SV_blank>(attempt)"" , uname ) ; write_logfile ( lbs , str ) ; if ( isparam ( ""redir"" ) ) strlcpy ( str , getparam ( ""redir"" ) , sizeof ( str ) ) ; else strlcpy ( str , isparam ( ""cmdline"" ) ? getparam ( ""cmdline"" ) : """" , sizeof ( str ) ) ; if ( ! auth_verify_password ( lbs , uname , getparam ( ""upassword"" ) , error_str , sizeof ( error_str ) ) ) { if ( error_str [ 0 ] ) show_error ( error_str ) ; else show_login_page ( lbs , str , 1 ) ; return ; } if ( get_user_line ( lbs , uname , NULL , full_name , NULL , NULL , NULL , & inactive ) == 2 ) { if ( ! getcfg ( lbs -> name , ""Self<S2SV_blank>register"" , str , sizeof ( str ) ) || atoi ( str ) == 0 ) { show_login_page ( lbs , str , 1 ) ; return ; } # ifdef HAVE_PAM getcfg ( lbs -> name , ""Authentication"" , str , sizeof ( str ) ) ; if ( stristr ( str , ""PAM"" ) ) { show_new_user_page ( lbs , uname ) ; return ; } # endif } if ( inactive ) { show_error ( ""This<S2SV_blank>account<S2SV_blank>is<S2SV_blank>currently<S2SV_blank>deactivated"" ) ; return ; } if ( ! check_login_user ( lbs , getparam ( ""uname"" ) ) ) { show_error ( ""User<S2SV_blank>has<S2SV_blank>no<S2SV_blank>access<S2SV_blank>to<S2SV_blank>this<S2SV_blank>logbook"" ) ; return ; } set_user_password ( lbs , uname , getparam ( ""upassword"" ) ) ; sprintf ( str , ""LOGIN<S2SV_blank>user<S2SV_blank>\\""%s\\""<S2SV_blank>(success)"" , uname ) ; write_logfile ( lbs , str ) ; sid_new ( lbs , uname , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; set_sid_cookie ( lbs , sid , full_name ) ; return ; } if ( chkext ( path , "".gif"" ) || chkext ( path , "".jpg"" ) || chkext ( path , "".png"" ) || chkext ( path , "".ico"" ) || chkext ( path , "".htm"" ) || chkext ( path , "".css"" ) ) { strlcpy ( str , resource_dir , sizeof ( str ) ) ; strlcat ( str , path , sizeof ( str ) ) ; if ( exist_file ( str ) ) { send_file_direct ( str ) ; return ; } else { strlcpy ( str , resource_dir , sizeof ( str ) ) ; strlcat ( str , ""themes"" , sizeof ( str ) ) ; strlcat ( str , DIR_SEPARATOR_STR , sizeof ( str ) ) ; strlcat ( str , theme_name , sizeof ( str ) ) ; strlcat ( str , DIR_SEPARATOR_STR , sizeof ( str ) ) ; strlcat ( str , path , sizeof ( str ) ) ; if ( exist_file ( str ) ) { send_file_direct ( str ) ; return ; } } } if ( ! logbook [ 0 ] ) { strencode2 ( str2 , path , sizeof ( str2 ) ) ; sprintf ( str , ""%s:<S2SV_blank><b>%s</b>"" , loc ( ""Invalid<S2SV_blank>URL"" ) , str2 ) ; show_error ( str ) ; return ; } if ( strieq ( command , loc ( ""Activate"" ) ) && isparam ( ""unm"" ) && isparam ( ""code"" ) && ! isparam ( ""new_user_name"" ) ) { strlcpy ( uname , getparam ( ""unm"" ) , sizeof ( uname ) ) ; if ( ! activate_user ( lbs , uname , atoi ( getparam ( ""code"" ) ) ) ) return ; sprintf ( str , ""ACTIVATE<S2SV_blank>user<S2SV_blank>\\""%s\\""<S2SV_blank>(success)"" , uname ) ; write_logfile ( lbs , str ) ; sid_new ( lbs , uname , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; sprintf ( str , ""?cmd=%s&notice=%s.<S2SV_blank>%s"" , loc ( ""Config"" ) , loc ( ""Your<S2SV_blank>account<S2SV_blank>has<S2SV_blank>been<S2SV_blank>activated"" ) , loc ( ""Please<S2SV_blank>subscribe<S2SV_blank>to<S2SV_blank>logbooks<S2SV_blank>if<S2SV_blank>you<S2SV_blank>want<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>automatic<S2SV_blank>email<S2SV_blank>notifications"" ) ) ; setparam ( ""redir"" , str ) ; set_sid_cookie ( lbs , sid , uname ) ; return ; } # ifdef HAVE_PAM if ( strieq ( command , loc ( ""Save"" ) ) && isparam ( ""new_user_name"" ) && ! isparam ( ""config"" ) ) { save_user_config ( NULL , getparam ( ""new_user_name"" ) , 1 ) ; redirect ( lbs , """" ) ; check_login ( lbs , NULL ) ; return ; } # endif if ( getcfg ( lbs -> name , ""Password<S2SV_blank>file"" , str , sizeof ( str ) ) ) { strlcpy ( css , ""elog.css"" , sizeof ( css ) ) ; if ( lbs != NULL && getcfg ( lbs -> name , ""CSS"" , str , sizeof ( str ) ) ) strlcpy ( css , str , sizeof ( css ) ) ; else if ( lbs == NULL && getcfg ( ""global"" , ""CSS"" , str , sizeof ( str ) ) ) strlcpy ( css , str , sizeof ( css ) ) ; if ( getcfg ( lbs -> name , ""Guest<S2SV_blank>menu<S2SV_blank>commands"" , str , sizeof ( str ) ) ) { if ( sid_check ( getparam ( ""sid"" ) , uname ) ) setparam ( ""unm"" , uname ) ; } if ( uname [ 0 ] && ! isparam ( ""new_user_name"" ) ) { if ( ! set_user_login_time ( lbs , uname ) ) { show_error ( loc ( ""File<S2SV_blank>system<S2SV_blank>full,<S2SV_blank>ELOG<S2SV_blank>cannot<S2SV_blank>continue<S2SV_blank>to<S2SV_blank>work"" ) ) ; return ; } } if ( ! ( getcfg ( lbs -> name , ""Guest<S2SV_blank>menu<S2SV_blank>commands"" , str , sizeof ( str ) ) && ! isparam ( ""fail"" ) ) ) { if ( strcmp ( path , css ) != 0 ) { if ( getcfg ( lbs -> name , ""Self<S2SV_blank>register"" , str , sizeof ( str ) ) && atoi ( str ) > 0 ) { if ( ! do_self_register ( lbs , command ) ) return ; } if ( ! check_login ( lbs , getparam ( ""sid"" ) ) ) return ; } } } if ( strieq ( command , loc ( ""Login"" ) ) ) { check_login ( lbs , """" ) ; return ; } if ( strieq ( command , loc ( ""New"" ) ) || strieq ( command , loc ( ""Edit"" ) ) || strieq ( command , loc ( ""Reply"" ) ) || strieq ( command , loc ( ""Duplicate"" ) ) || strieq ( command , loc ( ""Delete"" ) ) || strieq ( command , loc ( ""Upload"" ) ) || strieq ( command , loc ( ""Submit"" ) ) || strieq ( command , loc ( ""Preview"" ) ) ) { sprintf ( str , ""%s?cmd=%s"" , path , command ) ; } if ( strieq ( command , loc ( ""Delete"" ) ) || strieq ( command , loc ( ""Config"" ) ) || strieq ( command , loc ( ""Copy<S2SV_blank>to"" ) ) || strieq ( command , loc ( ""Move<S2SV_blank>to"" ) ) ) { sprintf ( str , ""%s?cmd=%s"" , path , command ) ; } if ( strieq ( command , loc ( ""Back"" ) ) ) { if ( isparam ( ""edit_id"" ) ) { el_lock_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , NULL , FALSE ) ; el_draft_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , NULL , FALSE ) ; strlcpy ( edit_id , getparam ( ""edit_id"" ) , sizeof ( edit_id ) ) ; sprintf ( str , ""../%s/%s"" , logbook_enc , edit_id ) ; } else sprintf ( str , ""../%s/"" , logbook_enc ) ; if ( getcfg ( lbs -> name , ""Back<S2SV_blank>to<S2SV_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) strcpy ( str , ""../"" ) ; redirect ( lbs , str ) ; return ; } if ( strieq ( command , ""XDelete"" ) ) { if ( getparam ( ""edit_id"" ) ) { status = el_delete_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , TRUE , NULL , TRUE , TRUE ) ; if ( status != EL_SUCCESS ) { sprintf ( str , ""%s<S2SV_blank>=<S2SV_blank>%d"" , loc ( ""Error<S2SV_blank>deleting<S2SV_blank>message:<S2SV_blank>status"" ) , status ) ; show_error ( str ) ; return ; } } redirect ( lbs , """" ) ; return ; } if ( strieq ( command , ""Unlock"" ) ) { if ( isparam ( ""edit_id"" ) ) { el_lock_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , NULL , FALSE ) ; strlcpy ( edit_id , getparam ( ""edit_id"" ) , sizeof ( edit_id ) ) ; sprintf ( str , ""../%s/%s"" , logbook_enc , edit_id ) ; } else sprintf ( str , ""../%s/"" , logbook_enc ) ; if ( getcfg ( lbs -> name , ""Back<S2SV_blank>to<S2SV_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) strcpy ( str , ""../"" ) ; redirect ( lbs , str ) ; return ; } if ( strieq ( command , loc ( ""List"" ) ) ) { if ( getcfg ( lbs -> name , ""Back<S2SV_blank>to<S2SV_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) { redirect ( lbs , ""../"" ) ; return ; } show_elog_list ( lbs , 0 , 0 , 0 , TRUE , NULL ) ; return ; } if ( strieq ( command , loc ( ""Cancel"" ) ) ) { sprintf ( str , ""../%s/%s"" , logbook_enc , path ) ; redirect ( lbs , str ) ; return ; } strlcpy ( str , isparam ( ""last"" ) ? getparam ( ""last"" ) : """" , sizeof ( str ) ) ; if ( strchr ( str , '<S2SV_blank>' ) ) { i = atoi ( strchr ( str , '<S2SV_blank>' ) ) ; sprintf ( str , ""last%d"" , i ) ; if ( isparam ( ""mode"" ) ) { sprintf ( str + strlen ( str ) , ""?mode="" ) ; strlcat ( str , getparam ( ""mode"" ) , sizeof ( str ) ) ; } redirect ( lbs , str ) ; return ; } strlcpy ( str , isparam ( ""past"" ) ? getparam ( ""past"" ) : """" , sizeof ( str ) ) ; if ( strchr ( str , '<S2SV_blank>' ) ) { i = atoi ( strchr ( str , '<S2SV_blank>' ) ) ; sprintf ( str , ""past%d"" , i ) ; redirect ( lbs , str ) ; return ; } if ( strncmp ( path , ""past"" , 4 ) == 0 && ( isdigit ( path [ 4 ] ) || isdigit ( path [ 5 ] ) ) && isparam ( ""cmd"" ) == 0 ) { show_elog_list ( lbs , atoi ( path + 4 ) , 0 , 0 , FALSE , NULL ) ; return ; } if ( strncmp ( path , ""last"" , 4 ) == 0 && ! chkext ( path , "".png"" ) && ( ! isparam ( ""cmd"" ) || strieq ( getparam ( ""cmd"" ) , loc ( ""Select"" ) ) ) && ! isparam ( ""newpwd"" ) && atoi ( path + 4 ) > 0 ) { show_elog_list ( lbs , 0 , atoi ( path + 4 ) , 0 , FALSE , NULL ) ; return ; } if ( strncmp ( path , ""page"" , 4 ) == 0 && isparam ( ""cmd"" ) == 0 ) { if ( ! path [ 4 ] ) show_elog_list ( lbs , 0 , 0 , - 1 , FALSE , NULL ) ; else show_elog_list ( lbs , 0 , 0 , atoi ( path + 4 ) , FALSE , NULL ) ; return ; } if ( strieq ( dec_path , ""cal.html"" ) ) { show_calendar ( lbs ) ; return ; } if ( strieq ( dec_path , ""elog.rdf"" ) ) { show_rss_feed ( lbs ) ; return ; } if ( strieq ( dec_path , ""upload.html"" ) ) { show_uploader ( lbs ) ; return ; } if ( isparam ( ""jcmd"" ) && isparam ( ""jcmd"" ) && strieq ( getparam ( ""jcmd"" ) , ""JUpload"" ) ) { show_uploader_finished ( lbs ) ; return ; } pfile = dec_path ; if ( strchr ( pfile , '/' ) && pfile [ 13 ] != '/' && isdigit ( pfile [ 0 ] ) ) pfile = strchr ( pfile , '/' ) + 1 ; if ( ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '_' ) || ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '/' ) || chkext ( pfile , "".gif"" ) || chkext ( pfile , "".ico"" ) || chkext ( pfile , "".jpg"" ) || chkext ( pfile , "".jpeg"" ) || chkext ( pfile , "".png"" ) || chkext ( pfile , "".css"" ) || chkext ( pfile , "".js"" ) || chkext ( pfile , "".html"" ) ) { if ( ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '_' ) || ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '/' ) ) { if ( pfile [ 13 ] == '/' ) pfile [ 13 ] = '_' ; strlcpy ( file_name , lbs -> data_dir , sizeof ( file_name ) ) ; generate_subdir_name ( pfile , subdir , sizeof ( subdir ) ) ; strlcat ( file_name , subdir , sizeof ( file_name ) ) ; strlcat ( file_name , pfile , sizeof ( file_name ) ) ; } else { strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; if ( file_name [ 0 ] && file_name [ strlen ( file_name ) - 1 ] != DIR_SEPARATOR ) strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; strlcat ( file_name , ""themes"" , sizeof ( file_name ) ) ; strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; if ( theme_name [ 0 ] ) { strlcat ( file_name , theme_name , sizeof ( file_name ) ) ; strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; } strlcat ( file_name , pfile , sizeof ( file_name ) ) ; } if ( isparam ( ""thumb"" ) ) { get_thumb_name ( file_name , thumb_name , sizeof ( thumb_name ) , 0 ) ; if ( thumb_name [ 0 ] ) send_file_direct ( thumb_name ) ; else send_file_direct ( file_name ) ; } else send_file_direct ( file_name ) ; return ; } if ( ! logbook [ 0 ] ) { show_selection_page ( ) ; return ; } if ( strchr ( dec_path , '/' ) ) { message_id = atoi ( dec_path ) ; n = atoi ( strchr ( dec_path , '/' ) + 1 ) - 1 ; status = el_retrieve_attachment ( lbs , message_id , n , attachment ) ; if ( status != EL_SUCCESS || n >= MAX_ATTACHMENTS ) { sprintf ( str , ""Attachment<S2SV_blank>#%d<S2SV_blank>of<S2SV_blank>entry<S2SV_blank>#%d<S2SV_blank>not<S2SV_blank>found"" , n + 1 , message_id ) ; show_error ( str ) ; } else { if ( isparam ( ""thumb"" ) ) strlcat ( attachment , ""?thumb=1"" , sizeof ( attachment ) ) ; redirect ( lbs , attachment ) ; } return ; } if ( getcfg ( lbs -> name , ""Types"" , str , sizeof ( str ) ) ) { show_upgrade_page ( lbs ) ; return ; } if ( isparam ( ""cmd_first.x"" ) ) strcpy ( command , loc ( ""First"" ) ) ; if ( isparam ( ""cmd_previous.x"" ) ) strcpy ( command , loc ( ""Previous"" ) ) ; if ( isparam ( ""cmd_next.x"" ) ) strcpy ( command , loc ( ""Next"" ) ) ; if ( isparam ( ""cmd_last.x"" ) ) strcpy ( command , loc ( ""Last"" ) ) ; if ( command [ 0 ] && ! is_user_allowed ( lbs , command ) ) { if ( isparam ( ""uname"" ) ) get_full_name ( lbs , getparam ( ""uname"" ) , full_name ) ; else full_name [ 0 ] = 0 ; strencode2 ( str2 , command , sizeof ( str2 ) ) ; strencode2 ( str3 , full_name , sizeof ( str3 ) ) ; sprintf ( str , loc ( ""Error:<S2SV_blank>Command<S2SV_blank>\\""<b>%s</b>\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>user<S2SV_blank>\\""<b>%s</b>\\"""" ) , str2 , str3 ) ; show_error ( str ) ; return ; } if ( ! is_command_allowed ( lbs , command , message_id ) ) { if ( strieq ( command , loc ( ""New"" ) ) && ! isparam ( ""unm"" ) ) { show_login_page ( lbs , _cmdline , 0 ) ; return ; } strencode2 ( str2 , command , sizeof ( str3 ) ) ; sprintf ( str , loc ( ""Error:<S2SV_blank>Command<S2SV_blank>\\""<b>%s</b>\\""<S2SV_blank>not<S2SV_blank>allowed"" ) , str2 ) ; show_error ( str ) ; return ; } if ( strieq ( command , loc ( ""Help"" ) ) ) { if ( getcfg ( lbs -> name , ""Help<S2SV_blank>URL"" , str , sizeof ( str ) ) ) { if ( strstr ( str , ""http://"" ) || strstr ( str , ""https://"" ) ) { redirect ( lbs , str ) ; return ; } strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , ""resources"" , sizeof ( file_name ) ) ; strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; f = fopen ( file_name , ""r"" ) ; if ( f == NULL ) { sprintf ( str , ""Cannot<S2SV_blank>find<S2SV_blank>file<S2SV_blank>\\""%s\\"""" , file_name ) ; show_error ( str ) ; } else { fclose ( f ) ; send_file_direct ( file_name ) ; } return ; } strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , ""resources"" , sizeof ( file_name ) ) ; strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; strlcat ( file_name , ""eloghelp_"" , sizeof ( file_name ) ) ; if ( getcfg ( ""global"" , ""Language"" , str , sizeof ( str ) ) ) { for ( i = 0 ; i < ( int ) strlen ( str ) ; i ++ ) str [ i ] = my_tolower ( str [ i ] ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } else strlcat ( file_name , ""english"" , sizeof ( file_name ) ) ; strlcat ( file_name , "".html"" , sizeof ( file_name ) ) ; f = fopen ( file_name , ""r"" ) ; if ( f == NULL ) redirect ( lbs , ""https://elog.psi.ch/elog/eloghelp_english.html"" ) ; else { fclose ( f ) ; send_file_direct ( file_name ) ; } return ; } if ( strieq ( command , loc ( ""HelpELCode"" ) ) ) { strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , ""resources"" , sizeof ( file_name ) ) ; strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; strlcat ( file_name , ""elcode_"" , sizeof ( file_name ) ) ; if ( getcfg ( ""global"" , ""Language"" , str , sizeof ( str ) ) ) { for ( i = 0 ; i < ( int ) strlen ( str ) ; i ++ ) str [ i ] = my_tolower ( str [ i ] ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } else strlcat ( file_name , ""english"" , sizeof ( file_name ) ) ; strlcat ( file_name , "".html"" , sizeof ( file_name ) ) ; f = fopen ( file_name , ""r"" ) ; if ( f == NULL ) redirect ( lbs , ""https://elog.psi.ch/elog/elcode_english.html"" ) ; else { fclose ( f ) ; send_file_direct ( file_name ) ; } return ; } if ( strieq ( command , loc ( ""New"" ) ) ) { if ( check_drafts ( lbs ) ) return ; show_edit_form ( lbs , 0 , FALSE , FALSE , FALSE , FALSE , FALSE , FALSE ) ; return ; } for ( i = 0 ; i < MAX_ATTACHMENTS ; i ++ ) { sprintf ( str , ""delatt%d"" , i ) ; if ( isparam ( str ) || ( isparam ( ""smcmd"" ) && stricmp ( getparam ( ""smcmd"" ) , str ) == 0 ) ) { sprintf ( str , ""attachment%d"" , i ) ; strlcpy ( file_name , getparam ( str ) , sizeof ( file_name ) ) ; el_delete_attachment ( lbs , file_name ) ; for ( j = i ; j < MAX_ATTACHMENTS ; j ++ ) { sprintf ( str , ""attachment%d"" , j + 1 ) ; if ( isparam ( str ) ) strlcpy ( file_name , getparam ( str ) , sizeof ( file_name ) ) ; else file_name [ 0 ] = 0 ; sprintf ( str , ""attachment%d"" , j ) ; if ( file_name [ 0 ] ) setparam ( str , file_name ) ; else unsetparam ( str ) ; } show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , FALSE , TRUE , TRUE , FALSE , FALSE , FALSE ) ; return ; } } if ( strieq ( command , loc ( ""Upload"" ) ) || strieq ( command , ""Upload"" ) ) { show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , FALSE , TRUE , TRUE , FALSE , FALSE , FALSE ) ; return ; } if ( strieq ( command , loc ( ""Edit"" ) ) ) { if ( message_id ) { show_edit_form ( lbs , message_id , FALSE , TRUE , FALSE , FALSE , FALSE , FALSE ) ; return ; } else if ( isparam ( ""nsel"" ) ) { show_edit_form ( lbs , 0 , FALSE , TRUE , FALSE , FALSE , FALSE , FALSE ) ; return ; } } if ( strieq ( command , loc ( ""Reply"" ) ) ) { show_edit_form ( lbs , message_id , TRUE , FALSE , FALSE , FALSE , FALSE , FALSE ) ; return ; } if ( strieq ( command , loc ( ""Update"" ) ) ) { show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , FALSE , TRUE , FALSE , TRUE , FALSE , FALSE ) ; return ; } if ( ( strieq ( command , loc ( ""Save"" ) ) || strieq ( command , ""Save"" ) ) && ! isparam ( ""cfgpage"" ) && ! isparam ( ""new_user_name"" ) ) { if ( isparam ( ""unm"" ) ) strlcpy ( str , getparam ( ""unm"" ) , sizeof ( str ) ) ; else strlcpy ( str , loc ( ""user"" ) , sizeof ( str ) ) ; setparam ( ""draft"" , str ) ; submit_elog ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Duplicate"" ) ) ) { if ( message_id ) { show_edit_form ( lbs , message_id , FALSE , FALSE , FALSE , FALSE , TRUE , FALSE ) ; return ; } } if ( strieq ( command , loc ( ""Preview"" ) ) ) { show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , FALSE , TRUE , FALSE , TRUE , FALSE , TRUE ) ; return ; } if ( strieq ( command , loc ( ""Submit"" ) ) || strieq ( command , ""Submit"" ) ) { if ( isparam ( ""mirror_id"" ) ) submit_elog_mirror ( lbs ) ; else submit_elog ( lbs ) ; if ( isparam ( ""sidclose"" ) ) sid_remove ( getparam ( ""sid"" ) ) ; return ; } if ( strieq ( command , loc ( ""Find"" ) ) ) { if ( dec_path [ 0 ] ) { sprintf ( str , ""../%s/?cmd=%s"" , lbs -> name_enc , loc ( ""Find"" ) ) ; redirect ( lbs , str ) ; return ; } show_find_form ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Search"" ) ) ) { if ( dec_path [ 0 ] && atoi ( dec_path ) == 0 && strchr ( dec_path , '/' ) != NULL ) { strencode2 ( str2 , dec_path , sizeof ( str2 ) ) ; sprintf ( str , ""%s:<S2SV_blank><b>%s</b>"" , loc ( ""Invalid<S2SV_blank>URL"" ) , str2 ) ; show_error ( str ) ; return ; } show_elog_list ( lbs , 0 , 0 , 0 , TRUE , NULL ) ; return ; } if ( strieq ( command , loc ( ""Last<S2SV_blank>day"" ) ) ) { redirect ( lbs , ""past1"" ) ; return ; } if ( strieq ( command , loc ( ""Last<S2SV_blank>10"" ) ) ) { redirect ( lbs , ""last10"" ) ; return ; } if ( strieq ( command , loc ( ""Copy<S2SV_blank>to"" ) ) ) { copy_to ( lbs , message_id , isparam ( ""destc"" ) ? getparam ( ""destc"" ) : """" , 0 , 0 ) ; return ; } if ( strieq ( command , loc ( ""Move<S2SV_blank>to"" ) ) ) { copy_to ( lbs , message_id , isparam ( ""destm"" ) ? getparam ( ""destm"" ) : """" , 1 , 0 ) ; return ; } if ( strieq ( command , loc ( ""Admin"" ) ) || strieq ( command , loc ( ""Change<S2SV_blank>config<S2SV_blank>file"" ) ) ) { show_admin_page ( lbs , NULL ) ; return ; } sprintf ( str , loc ( ""Change<S2SV_blank>%s"" ) , ""[global]"" ) ; if ( strieq ( command , str ) ) { show_admin_page ( lbs , ""global"" ) ; return ; } sprintf ( str2 , ""[global<S2SV_blank>%s]"" , lbs -> top_group ) ; sprintf ( str , loc ( ""Change<S2SV_blank>%s"" ) , str2 ) ; if ( strieq ( command , str ) ) { show_admin_page ( lbs , lbs -> top_group ) ; return ; } if ( strieq ( command , loc ( ""Delete<S2SV_blank>this<S2SV_blank>logbook"" ) ) ) { show_logbook_delete ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Rename<S2SV_blank>this<S2SV_blank>logbook"" ) ) ) { show_logbook_rename ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Create<S2SV_blank>new<S2SV_blank>logbook"" ) ) ) { if ( isparam ( ""tmp"" ) && strieq ( getparam ( ""tmp"" ) , ""Cancel"" ) ) { if ( getcfg ( lbs -> name , ""Password<S2SV_blank>file"" , str , sizeof ( str ) ) ) sprintf ( str , ""?cmd=%s"" , loc ( ""Change<S2SV_blank>config<S2SV_blank>file"" ) ) ; else sprintf ( str , ""?cmd=%s"" , loc ( ""Config"" ) ) ; redirect ( lbs , str ) ; return ; } show_logbook_new ( lbs ) ; return ; } if ( strieq ( command , ""GetPwdFile"" ) ) { char allow [ 256 ] ; allow [ 0 ] = 0 ; getcfg ( ""global"" , ""Allow<S2SV_blank>clone"" , allow , sizeof ( allow ) ) ; if ( atoi ( allow ) == 1 ) { if ( get_password_file ( lbs , file_name , sizeof ( file_name ) ) ) send_file_direct ( file_name ) ; } else { show_http_header ( NULL , FALSE , NULL ) ; rsputs ( loc ( ""Cloning<S2SV_blank>not<S2SV_blank>allowed.<S2SV_blank>Set<S2SV_blank>\\""Allow<S2SV_blank>clone<S2SV_blank>=<S2SV_blank>1\\""<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>cloning."" ) ) ; rsputs ( ""\\r\\n"" ) ; return ; } return ; } if ( strieq ( command , loc ( ""Change<S2SV_blank>password"" ) ) || ( isparam ( ""newpwd"" ) && ! strieq ( command , loc ( ""Cancel"" ) ) && ! strieq ( command , loc ( ""Save"" ) ) ) ) { show_change_pwd_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Save"" ) ) && ( isparam ( ""cfgpage"" ) || isparam ( ""new_user_name"" ) ) ) { if ( isparam ( ""config"" ) && isparam ( ""new_user_name"" ) ) { if ( ! strieq ( getparam ( ""config"" ) , getparam ( ""new_user_name"" ) ) ) { if ( get_user_line ( lbs , getparam ( ""new_user_name"" ) , NULL , NULL , NULL , NULL , NULL , NULL ) == 1 ) { sprintf ( str , ""%s<S2SV_blank>\\""%s\\""<S2SV_blank>%s"" , loc ( ""Login<S2SV_blank>name"" ) , getparam ( ""new_user_name"" ) , loc ( ""exists<S2SV_blank>already"" ) ) ; show_error ( str ) ; return ; } } if ( ! save_user_config ( lbs , isparam ( ""config"" ) ? getparam ( ""config"" ) : """" , FALSE ) ) return ; redirect ( lbs , """" ) ; return ; } else if ( isparam ( ""new_user_name"" ) ) { if ( ! save_user_config ( lbs , getparam ( ""new_user_name"" ) , TRUE ) ) return ; } else { if ( isparam ( ""global"" ) ) { if ( strieq ( getparam ( ""global"" ) , ""global"" ) ) strcpy ( section , ""global"" ) ; else { sprintf ( section , ""global<S2SV_blank>"" ) ; strlcat ( section , getparam ( ""global"" ) , sizeof ( section ) ) ; } } else strlcpy ( section , lbs -> name , sizeof ( section ) ) ; if ( ! save_admin_config ( section , _mtext , str ) ) { show_error ( str ) ; return ; } } if ( lbs ) sprintf ( str , ""../%s/"" , lbs -> name_enc ) ; else sprintf ( str , ""."" ) ; if ( isparam ( ""new_user_name"" ) ) { sprintf ( str + strlen ( str ) , ""?cmd=%s&cfg_user="" , loc ( ""Config"" ) ) ; strlcat ( str , getparam ( ""new_user_name"" ) , sizeof ( str ) ) ; } else if ( isparam ( ""cfg_user"" ) ) { sprintf ( str + strlen ( str ) , ""?cmd=%s&cfg_user="" , loc ( ""Config"" ) ) ; strlcat ( str , getparam ( ""cfg_user"" ) , sizeof ( str ) ) ; } else if ( getcfg ( lbs -> name , ""password<S2SV_blank>file"" , str2 , sizeof ( str2 ) ) ) sprintf ( str + strlen ( str ) , ""?cmd=%s"" , loc ( ""Config"" ) ) ; redirect ( lbs , str ) ; return ; } if ( strieq ( command , loc ( ""Activate"" ) ) && isparam ( ""new_user_name"" ) && isparam ( ""code"" ) ) { if ( ! activate_user ( lbs , getparam ( ""new_user_name"" ) , atoi ( getparam ( ""code"" ) ) ) ) return ; setparam ( ""cfg_user"" , getparam ( ""new_user_name"" ) ) ; get_user_line ( lbs , getparam ( ""new_user_name"" ) , NULL , full_name , user_email , NULL , NULL , NULL ) ; sprintf ( str , ""%s<S2SV_blank><b>&lt;%s&gt;</b>"" , full_name , user_email ) ; sprintf ( str2 , loc ( ""Activation<S2SV_blank>notice<S2SV_blank>has<S2SV_blank>been<S2SV_blank>sent<S2SV_blank>to<S2SV_blank>%s"" ) , str ) ; setparam ( ""notice"" , str2 ) ; show_config_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Remove<S2SV_blank>user"" ) ) && isparam ( ""config"" ) ) { if ( ! remove_user ( lbs , getparam ( ""config"" ) ) ) return ; if ( isparam ( ""unm"" ) && strieq ( getparam ( ""config"" ) , getparam ( ""unm"" ) ) ) { write_logfile ( lbs , ""LOGOUT"" ) ; sid_remove ( getparam ( ""sid"" ) ) ; set_sid_cookie ( lbs , """" , """" ) ; } unsetparam ( ""cfg_user"" ) ; show_config_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""New<S2SV_blank>user"" ) ) ) { show_new_user_page ( lbs , NULL ) ; return ; } if ( strieq ( command , loc ( ""Forgot"" ) ) ) { show_forgot_pwd_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Config"" ) ) ) { if ( ! getcfg ( lbs -> name , ""Password<S2SV_blank>file"" , str , sizeof ( str ) ) ) show_admin_page ( lbs , NULL ) ; else show_config_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Download"" ) ) || strieq ( command , ""Download"" ) ) { show_download_page ( lbs , dec_path ) ; return ; } if ( strieq ( command , loc ( ""Import"" ) ) ) { strcpy ( str , loc ( ""CSV<S2SV_blank>Import"" ) ) ; url_encode ( str , sizeof ( str ) ) ; sprintf ( str1 , ""?cmd=%s"" , str ) ; strcpy ( str , loc ( ""XML<S2SV_blank>Import"" ) ) ; url_encode ( str , sizeof ( str ) ) ; sprintf ( str2 , ""?cmd=%s"" , str ) ; show_query ( lbs , loc ( ""ELOG<S2SV_blank>import"" ) , loc ( ""Please<S2SV_blank>choose<S2SV_blank>format<S2SV_blank>to<S2SV_blank>import:"" ) , ""CSV"" , str1 , ""XML"" , str2 ) ; return ; } if ( strieq ( command , loc ( ""CSV<S2SV_blank>Import"" ) ) ) { show_import_page_csv ( lbs ) ; return ; } if ( strieq ( command , loc ( ""XML<S2SV_blank>Import"" ) ) ) { show_import_page_xml ( lbs ) ; return ; } if ( strieq ( command , ""getmd5"" ) ) { show_md5_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Synchronize"" ) ) ) { synchronize ( lbs , SYNC_HTML ) ; return ; } if ( strieq ( command , loc ( ""Logout"" ) ) ) { write_logfile ( lbs , ""LOGOUT"" ) ; if ( getcfg ( lbs -> name , ""Logout<S2SV_blank>to<S2SV_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) { sprintf ( str , ""../"" ) ; setparam ( ""redir"" , str ) ; } else { if ( getcfg ( lbs -> name , ""Logout<S2SV_blank>to<S2SV_blank>URL"" , str , sizeof ( str ) ) ) setparam ( ""redir"" , str ) ; } set_sid_cookie ( lbs , """" , """" ) ; sid_remove ( getparam ( ""sid"" ) ) ; return ; } if ( strieq ( command , loc ( ""Delete"" ) ) ) { show_elog_delete ( lbs , message_id ) ; return ; } if ( strieq ( command , ""IM"" ) ) { call_image_magick ( lbs ) ; return ; } if ( ! _cmdline [ 0 ] && getcfg ( lbs -> name , ""Welcome<S2SV_blank>page"" , str , sizeof ( str ) ) && str [ 0 ] ) { if ( str [ 0 ] == DIR_SEPARATOR || str [ 1 ] == ':' ) strcpy ( file_name , str ) ; else { strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } send_file_direct ( file_name ) ; return ; } if ( ! _cmdline [ 0 ] && getcfg ( lbs -> name , ""Start<S2SV_blank>page"" , str , sizeof ( str ) ) && str [ 0 ] ) { redirect ( lbs , str ) ; return ; } if ( dec_path [ 0 ] == 0 ) show_elog_list ( lbs , 0 , 0 , 0 , TRUE , NULL ) ; else show_elog_entry ( lbs , dec_path , command ) ; return ; }
","<S2SV_ModStart> ""value"" ) ) { strencode2 ( str , getparam ( ""value"" ) , sizeof ( str ) ) ; <S2SV_ModStart> ( loc ( str ) ) ; } <S2SV_ModEnd> s = loc
",ritt@elog/eefdabb714f26192f585083ef96c8413e459a1d1,CVE-2019-20375,https://bitbucket.org/ritt/elog/commit/eefdabb714f26192f585083ef96c8413e459a1d1,2020-01-10T05:15Z,"<S2SV_StartBug> if ( isparam ( ""value"" ) && * getparam ( ""value"" ) ) <S2SV_EndBug> <S2SV_StartBug> rsputs ( loc ( getparam ( ""value"" ) ) ) ; <S2SV_EndBug>"
2784,CWE-119,"WORD32 ih264d_parse_bslice ( dec_struct_t * ps_dec , UWORD16 u2_first_mb_in_slice ) { dec_pic_params_t * ps_pps = ps_dec -> ps_cur_pps ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD8 u1_ref_idx_re_flag_lx ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 u4_temp , ui_temp1 ; WORD32 i_temp ; WORD32 ret ; { WORD8 * pi1_buf ; WORD16 * pi2_mv = ps_dec -> s_default_mv_pred . i2_mv ; WORD32 * pi4_mv = ( WORD32 * ) pi2_mv ; WORD16 * pi16_refFrame ; pi1_buf = ps_dec -> s_default_mv_pred . i1_ref_frame ; pi16_refFrame = ( WORD16 * ) pi1_buf ; * pi4_mv = 0 ; * ( pi4_mv + 1 ) = 0 ; * pi16_refFrame = OUT_OF_RANGE_REF ; ps_dec -> s_default_mv_pred . u1_col_ref_pic_idx = ( UWORD8 ) - 1 ; ps_dec -> s_default_mv_pred . u1_pic_type = ( UWORD8 ) - 1 ; } ps_slice -> u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>num_ref_idx_override_flag"" , ps_slice -> u1_num_ref_idx_active_override_flag ) ; u4_temp = ps_dec -> ps_cur_pps -> u1_num_ref_idx_lx_active [ 0 ] ; ui_temp1 = ps_dec -> ps_cur_pps -> u1_num_ref_idx_lx_active [ 1 ] ; if ( ps_slice -> u1_num_ref_idx_active_override_flag ) { u4_temp = 1 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>num_ref_idx_l0_active_minus1"" , u4_temp - 1 ) ; ui_temp1 = 1 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>num_ref_idx_l1_active_minus1"" , ui_temp1 - 1 ) ; } { UWORD8 u1_max_ref_idx = MAX_FRAMES ; if ( ps_slice -> u1_field_pic_flag ) { u1_max_ref_idx = MAX_FRAMES << 1 ; } if ( ( u4_temp > u1_max_ref_idx ) || ( ui_temp1 > u1_max_ref_idx ) ) { return ERROR_NUM_REF ; } ps_slice -> u1_num_ref_idx_lx_active [ 0 ] = u4_temp ; ps_slice -> u1_num_ref_idx_lx_active [ 1 ] = ui_temp1 ; } { UWORD8 init_idx_flg = ( ps_dec -> u1_pr_sl_type != ps_dec -> ps_cur_slice -> u1_slice_type ) ; if ( ps_dec -> u1_first_pb_nal_in_pic || ( init_idx_flg & ! ps_dec -> u1_sl_typ_5_9 ) || ps_dec -> u1_num_ref_idx_lx_active_prev != ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ) ih264d_init_ref_idx_lx_b ( ps_dec ) ; if ( ps_dec -> u1_first_pb_nal_in_pic & ps_dec -> u1_sl_typ_5_9 ) ps_dec -> u1_first_pb_nal_in_pic = 0 ; } ps_dec -> u1_num_ref_idx_lx_active_prev = ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; u1_ref_idx_re_flag_lx = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>ref_pic_list_reordering_flag_l0"" , u1_ref_idx_re_flag_lx ) ; if ( u1_ref_idx_re_flag_lx ) { WORD8 ret ; ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_mod_dpb [ 0 ] ; ret = ih264d_ref_idx_reordering ( ps_dec , 0 ) ; if ( ret == - 1 ) return ERROR_REFIDX_ORDER_T ; } else ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; u1_ref_idx_re_flag_lx = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>ref_pic_list_reordering_flag_l1"" , u1_ref_idx_re_flag_lx ) ; if ( u1_ref_idx_re_flag_lx ) { WORD8 ret ; ps_dec -> ps_ref_pic_buf_lx [ 1 ] = ps_dec -> ps_dpb_mgr -> ps_mod_dpb [ 1 ] ; ret = ih264d_ref_idx_reordering ( ps_dec , 1 ) ; if ( ret == - 1 ) return ERROR_REFIDX_ORDER_T ; } else ps_dec -> ps_ref_pic_buf_lx [ 1 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 1 ] ; { void * * ppv_map_ref_idx_to_poc_lx ; WORD8 idx ; struct pic_buffer_t * ps_pic ; ppv_map_ref_idx_to_poc_lx = ps_dec -> ppv_map_ref_idx_to_poc + FRM_LIST_L0 ; ppv_map_ref_idx_to_poc_lx [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx ++ ; for ( idx = 0 ; idx < ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ idx ] ; ppv_map_ref_idx_to_poc_lx [ idx ] = ( ps_pic -> pu1_buf1 ) ; } ppv_map_ref_idx_to_poc_lx = ps_dec -> ppv_map_ref_idx_to_poc + FRM_LIST_L1 ; ppv_map_ref_idx_to_poc_lx [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx ++ ; for ( idx = 0 ; idx < ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 1 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 1 ] [ idx ] ; ppv_map_ref_idx_to_poc_lx [ idx ] = ( ps_pic -> pu1_buf1 ) ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { void * * ppv_map_ref_idx_to_poc_lx_t , * * ppv_map_ref_idx_to_poc_lx_b ; ppv_map_ref_idx_to_poc_lx_t = ps_dec -> ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L0 ; ppv_map_ref_idx_to_poc_lx_b = ps_dec -> ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L0 ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_t ++ ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_b ++ ; for ( idx = 0 ; idx < ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ idx ] ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ 1 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t [ 1 ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t += 2 ; ppv_map_ref_idx_to_poc_lx_b += 2 ; } ppv_map_ref_idx_to_poc_lx_t = ps_dec -> ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L1 ; ppv_map_ref_idx_to_poc_lx_b = ps_dec -> ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L1 ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_t ++ ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_b ++ ; for ( idx = 0 ; idx < ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 1 ] ; idx ++ ) { UWORD8 u1_tmp_idx = idx << 1 ; ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 1 ] [ idx ] ; ppv_map_ref_idx_to_poc_lx_t [ u1_tmp_idx ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ u1_tmp_idx + 1 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ u1_tmp_idx ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t [ u1_tmp_idx + 1 ] = ( ps_pic -> pu1_buf1 ) + 1 ; } } if ( ps_dec -> u4_num_cores >= 3 ) { WORD32 num_entries ; WORD32 size ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; memcpy ( ( void * ) ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc , ps_dec -> ppv_map_ref_idx_to_poc , size ) ; } } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) ) { ih264d_convert_frm_mbaff_list ( ps_dec ) ; } if ( ps_pps -> u1_wted_bipred_idc == 1 ) { ret = ih264d_parse_pred_weight_table ( ps_slice , ps_bitstrm ) ; if ( ret != OK ) return ret ; ih264d_form_pred_weight_matrix ( ps_dec ) ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; } else if ( ps_pps -> u1_wted_bipred_idc == 2 ) { ps_slice -> u2_log2Y_crwd = 0x0505 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; ih264d_get_implicit_weights ( ps_dec ) ; } else ps_dec -> ps_cur_slice -> u2_log2Y_crwd = 0 ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_slice -> u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ; else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; } if ( ps_pps -> u1_entropy_coding_mode == CABAC ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_CABAC_INIT_IDC ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> u1_cabac_init_idc = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>cabac_init_idc"" , ps_slice -> u1_cabac_init_idc ) ; } i_temp = ps_pps -> u1_pic_init_qp + ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( i_temp < 0 ) || ( i_temp > 51 ) ) { return ERROR_INV_RANGE_QP_T ; } ps_slice -> u1_slice_qp = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_qp_delta"" , ( WORD8 ) ( ps_slice -> u1_slice_qp - ps_pps -> u1_pic_init_qp ) ) ; if ( ps_pps -> u1_deblocking_filter_parameters_present_flag == 1 ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > SLICE_BOUNDARY_DBLK_DISABLED ) { return ERROR_INV_SLICE_HDR_T ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>disable_deblocking_filter_idc"" , u4_temp ) ; ps_slice -> u1_disable_dblk_filter_idc = u4_temp ; if ( u4_temp != 1 ) { i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_alpha_c0_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_alpha_c0_offset_div2"" , ps_slice -> i1_slice_alpha_c0_offset >> 1 ) ; i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_beta_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_beta_offset_div2"" , ps_slice -> i1_slice_beta_offset >> 1 ) ; } else { ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } } else { ps_slice -> u1_disable_dblk_filter_idc = 0 ; ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } ps_dec -> u1_slice_header_done = 2 ; if ( ps_pps -> u1_entropy_coding_mode ) { SWITCHOFFTRACE ; SWITCHONTRACECABAC ; ps_dec -> pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac ; ps_dec -> pf_parse_inter_mb = ih264d_parse_bmb_cabac ; ih264d_init_cabac_contexts ( B_SLICE , ps_dec ) ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff ; else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff ; } else { SWITCHONTRACE ; SWITCHOFFTRACECABAC ; ps_dec -> pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc ; ps_dec -> pf_parse_inter_mb = ih264d_parse_bmb_cavlc ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff ; else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff ; } ret = ih264d_cal_col_pic ( ps_dec ) ; if ( ret != OK ) return ret ; ps_dec -> u1_B = 1 ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_bmb ; ret = ps_dec -> pf_parse_inter_slice ( ps_dec , ps_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; return OK ; }
","<S2SV_ModStart> -> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> -> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_bitstrm ->
",external@libavc/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,CVE-2016-0842,https://android.googlesource.com/platform/external/libavc/+/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,2016-04-18T00:59Z,<S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ; <S2SV_EndBug>
1558,CWE-119,"void vp9_iwht4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { if ( eob > 1 ) vp9_iwht4x4_16_add ( input , dest , stride ) ; else vp9_iwht4x4_1_add ( input , dest , stride ) ; }
","<S2SV_ModStart> vp9_iwht4x4_add ( const tran_low_t <S2SV_ModEnd> * input , <S2SV_ModStart> > 1 ) vpx_iwht4x4_16_add <S2SV_ModEnd> ( input , <S2SV_ModStart> ) ; else vpx_iwht4x4_1_add <S2SV_ModEnd> ( input ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> void vp9_iwht4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { <S2SV_EndBug> <S2SV_StartBug> vp9_iwht4x4_16_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_iwht4x4_1_add ( input , dest , stride ) ; <S2SV_EndBug>"
371,CWE-362,"static int faultin_page ( struct task_struct * tsk , struct vm_area_struct * vma , unsigned long address , unsigned int * flags , int * nonblocking ) { unsigned int fault_flags = 0 ; int ret ; if ( ( * flags & ( FOLL_POPULATE | FOLL_MLOCK ) ) == FOLL_MLOCK ) return - ENOENT ; if ( ( * flags & FOLL_POPULATE ) && ( stack_guard_page_start ( vma , address ) || stack_guard_page_end ( vma , address + PAGE_SIZE ) ) ) return - ENOENT ; if ( * flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( * flags & FOLL_REMOTE ) fault_flags |= FAULT_FLAG_REMOTE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( * flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( * flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = handle_mm_fault ( vma , address , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { if ( ret & VM_FAULT_OOM ) return - ENOMEM ; if ( ret & ( VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE ) ) return * flags & FOLL_HWPOISON ? - EHWPOISON : - EFAULT ; if ( ret & ( VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV ) ) return - EFAULT ; BUG ( ) ; } if ( tsk ) { if ( ret & VM_FAULT_MAJOR ) tsk -> maj_flt ++ ; else tsk -> min_flt ++ ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking ) * nonblocking = 0 ; return - EBUSY ; } if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) ) * flags &= ~ FOLL_WRITE ; return 0 ; }
","<S2SV_ModStart> ) * flags |= FOLL_COW <S2SV_ModEnd> ; return 0
",torvalds@linux/19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619,CVE-2016-5195,https://github.com/torvalds/linux/commit/19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619,2016-11-10T21:59Z,<S2SV_StartBug> * flags &= ~ FOLL_WRITE ; <S2SV_EndBug>
3589,CWE-190,"jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) { jas_stream_t * in ; jas_iccprof_t * prof ; if ( ! ( in = jas_stream_memopen ( JAS_CAST ( char * , buf ) , len ) ) ) goto error ; if ( ! ( prof = jas_iccprof_load ( in ) ) ) goto error ; jas_stream_close ( in ) ; return prof ; error : if ( in ) jas_stream_close ( in ) ; return 0 ; }
","<S2SV_ModStart> * jas_iccprof_createfrombuf ( jas_uchar <S2SV_ModEnd> * buf ,
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,"<S2SV_StartBug> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <S2SV_EndBug>"
3337,CWE-119,"int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>HWCR<S2SV_blank>wrmsr:<S2SV_blank>0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>MMIO_CONF_BASE<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , ""%s:<S2SV_blank>MSR_IA32_DEBUGCTLMSR<S2SV_blank>0x%llx,<S2SV_blank>nop\\n"" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case MSR_IA32_MISC_ENABLE : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case MSR_KVM_WALL_CLOCK_NEW : case MSR_KVM_WALL_CLOCK : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case MSR_KVM_SYSTEM_TIME_NEW : case MSR_KVM_SYSTEM_TIME : { kvmclock_reset ( vcpu ) ; vcpu -> arch . time = data ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; if ( ! ( data & 1 ) ) break ; vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ; break ; } case MSR_KVM_ASYNC_PF_EN : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case MSR_KVM_STEAL_TIME : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & KVM_STEAL_RESERVED_MASK ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & KVM_MSR_ENABLED ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ; break ; case MSR_KVM_PV_EOI_EN : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case MSR_IA32_MCG_CTL : case MSR_IA32_MCG_STATUS : case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1 : return set_msr_mce ( vcpu , msr , data ) ; case MSR_K7_EVNTSEL0 : case MSR_K7_EVNTSEL1 : case MSR_K7_EVNTSEL2 : case MSR_K7_EVNTSEL3 : if ( data != 0 ) vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_PERFCTR0 : case MSR_K7_PERFCTR1 : case MSR_K7_PERFCTR2 : case MSR_K7_PERFCTR3 : vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_P6_PERFCTR0 : case MSR_P6_PERFCTR1 : pr = true ; case MSR_P6_EVNTSEL0 : case MSR_P6_EVNTSEL1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , ""disabled<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_CLK_CTL : break ; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case MSR_IA32_BBL_CR_CTL3 : vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; case MSR_AMD64_OSVW_ID_LENGTH : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case MSR_AMD64_OSVW_STATUS : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , ""unhandled<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; } } return 0 ; }
","<S2SV_ModStart> | 1 ) ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break
",torvalds@linux/c300aa64ddf57d9c5d9c898a64b36877345dd4a9,CVE-2013-1796,https://github.com/torvalds/linux/commit/c300aa64ddf57d9c5d9c898a64b36877345dd4a9,2013-03-22T11:59Z,<S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug>
5817,CWE-000,"static int ext4_split_unwritten_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags ) { struct ext4_extent * ex , newex , orig_ex ; struct ext4_extent * ex1 = NULL ; struct ext4_extent * ex2 = NULL ; struct ext4_extent * ex3 = NULL ; ext4_lblk_t ee_block , eof_block ; unsigned int allocated , ee_len , depth ; ext4_fsblk_t newblock ; int err = 0 ; int may_zeroout ; ext_debug ( ""ext4_split_unwritten_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len ) ; eof_block = ( inode -> i_size + inode -> i_sb -> s_blocksize - 1 ) >> inode -> i_sb -> s_blocksize_bits ; if ( eof_block < map -> m_lblk + map -> m_len ) eof_block = map -> m_lblk + map -> m_len ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; allocated = ee_len - ( map -> m_lblk - ee_block ) ; newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ; ex2 = ex ; orig_ex . ee_block = ex -> ee_block ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_store_pblock ( & orig_ex , ext4_ext_pblock ( ex ) ) ; may_zeroout = ee_block + ee_len <= eof_block ; if ( ( map -> m_lblk == ee_block ) && ( allocated <= map -> m_len ) ) return allocated ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; if ( map -> m_lblk > ee_block ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } if ( ! ex1 && allocated > map -> m_len ) ex2 -> ee_len = cpu_to_le16 ( map -> m_len ) ; if ( allocated > map -> m_len ) { unsigned int newdepth ; ex3 = & newex ; ex3 -> ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; ext4_ext_store_pblock ( ex3 , newblock + map -> m_len ) ; ex3 -> ee_len = cpu_to_le16 ( allocated - map -> m_len ) ; ext4_ext_mark_uninitialized ( ex3 ) ; err = ext4_ext_insert_extent ( handle , inode , path , ex3 , flags ) ; if ( err == - ENOSPC && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; newdepth = ext_depth ( inode ) ; ee_len -= ext4_ext_get_actual_len ( ex3 ) ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; may_zeroout = ee_block + ee_len <= eof_block ; depth = newdepth ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } ex = path [ depth ] . p_ext ; if ( ex2 != & newex ) ex2 = ex ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; allocated = map -> m_len ; } if ( ex1 && ex1 != ex ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } ex2 -> ee_block = cpu_to_le32 ( map -> m_lblk ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; ex2 -> ee_len = cpu_to_le16 ( allocated ) ; ext4_ext_mark_uninitialized ( ex2 ) ; if ( ex2 != ex ) goto insert ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; ext_debug ( ""out<S2SV_blank>here\\n"" ) ; goto out ; insert : err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err == - ENOSPC && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ? err : allocated ; fix_extent_len : ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }
","<S2SV_ModStart> flags ) { ext4_lblk_t eof_block ; ext4_lblk_t ee_block ; <S2SV_ModStart> ext4_extent * ex <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> ; unsigned int ee_len ; int split_flag = 0 , depth <S2SV_ModEnd> ; ext_debug ( <S2SV_ModStart> ex ) ; split_flag |= <S2SV_ModEnd> ee_block + ee_len <S2SV_ModStart> ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 ; split_flag |= EXT4_EXT_MARK_UNINIT2 ; flags |= EXT4_GET_BLOCKS_PRE_IO ; return ext4_split_extent <S2SV_ModEnd> ( handle , <S2SV_ModStart> inode , path , map , split_flag <S2SV_ModEnd> , flags ) <S2SV_ModStart> , flags ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3,CVE-2011-3638,https://github.com/torvalds/linux/commit/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3,2013-03-01T12:37Z,"<S2SV_StartBug> struct ext4_extent * ex , newex , orig_ex ; <S2SV_EndBug> <S2SV_StartBug> unsigned int allocated , ee_len , depth ; <S2SV_EndBug> <S2SV_StartBug> allocated = ee_len - ( map -> m_lblk - ee_block ) ; <S2SV_EndBug> <S2SV_StartBug> may_zeroout = ee_block + ee_len <= eof_block ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_get_access ( handle , inode , path + depth ) ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_insert_extent ( handle , inode , path , ex3 , flags ) ; <S2SV_EndBug>"
2778,CWE-416,"static OPJ_BOOL opj_j2k_write_mco ( opj_j2k_t * p_j2k , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { OPJ_BYTE * l_current_data = 00 ; OPJ_UINT32 l_mco_size ; opj_tcp_t * l_tcp = 00 ; opj_simple_mcc_decorrelation_data_t * l_mcc_record ; OPJ_UINT32 i ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; l_tcp = & ( p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] ) ; l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; if ( l_mco_size > p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size ) { OPJ_BYTE * new_header_tile_data = ( OPJ_BYTE * ) opj_realloc ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size ) ; if ( ! new_header_tile_data ) { opj_free ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data ) ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data = NULL ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = 0 ; opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>write<S2SV_blank>MCO<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; } p_j2k -> m_specific_param . m_encoder . m_header_tile_data = new_header_tile_data ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = l_mco_size ; } opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , l_mco_size - 2 , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , l_tcp -> m_nb_mcc_records , 1 ) ; ++ l_current_data ; l_mcc_record = l_tcp -> m_mcc_records ; for ( i = 0 ; i < l_tcp -> m_nb_mcc_records ; ++ i ) { opj_write_bytes ( l_current_data , l_mcc_record -> m_index , 1 ) ; ++ l_current_data ; ++ l_mcc_record ; } if ( opj_stream_write_data ( p_stream , p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size , p_manager ) != l_mco_size ) { return OPJ_FALSE ; } return OPJ_TRUE ; }
","<S2SV_ModStart> ] ) ; <S2SV_ModEnd> l_mco_size = 5 <S2SV_ModStart> l_mco_size ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;
",uclouvain@openjpeg/940100c28ae28931722290794889cf84a92c5f6f,CVE-2015-8871,https://github.com/uclouvain/openjpeg/commit/940100c28ae28931722290794889cf84a92c5f6f,2016-09-21T14:25Z,"<S2SV_StartBug> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <S2SV_EndBug> <S2SV_StartBug> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <S2SV_EndBug>"
2010,CWE-119,"static void extend_plane ( uint8_t * const src , int src_stride , int width , int height , int extend_top , int extend_left , int extend_bottom , int extend_right ) { int i ; const int linesize = extend_left + extend_right + width ; uint8_t * src_ptr1 = src ; uint8_t * src_ptr2 = src + width - 1 ; uint8_t * dst_ptr1 = src - extend_left ; uint8_t * dst_ptr2 = src + width ; for ( i = 0 ; i < height ; ++ i ) { vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; src_ptr1 += src_stride ; src_ptr2 += src_stride ; dst_ptr1 += src_stride ; dst_ptr2 += src_stride ; } src_ptr1 = src - extend_left ; src_ptr2 = src + src_stride * ( height - 1 ) - extend_left ; dst_ptr1 = src + src_stride * - extend_top - extend_left ; dst_ptr2 = src + src_stride * height - extend_left ; for ( i = 0 ; i < extend_top ; ++ i ) { vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ; dst_ptr1 += src_stride ; } for ( i = 0 ; i < extend_bottom ; ++ i ) { vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ; dst_ptr2 += src_stride ; } }
","<S2SV_ModStart> i ) { memset <S2SV_ModEnd> ( dst_ptr1 , <S2SV_ModStart> extend_left ) ; memset <S2SV_ModEnd> ( dst_ptr2 , <S2SV_ModStart> i ) { memcpy <S2SV_ModEnd> ( dst_ptr1 , <S2SV_ModStart> i ) { memcpy <S2SV_ModEnd> ( dst_ptr2 ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug>"
4029,CWE-119,"static struct dentry * proc_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data ) { int err ; struct super_block * sb ; struct pid_namespace * ns ; char * options ; if ( flags & MS_KERNMOUNT ) { ns = ( struct pid_namespace * ) data ; options = NULL ; } else { ns = task_active_pid_ns ( current ) ; options = data ; if ( ! ns_capable ( ns -> user_ns , CAP_SYS_ADMIN ) ) return ERR_PTR ( - EPERM ) ; } sb = sget ( fs_type , proc_test_super , proc_set_super , flags , ns ) ; if ( IS_ERR ( sb ) ) return ERR_CAST ( sb ) ; if ( ! proc_parse_options ( options , ns ) ) { deactivate_locked_super ( sb ) ; return ERR_PTR ( - EINVAL ) ; } if ( ! sb -> s_root ) { err = proc_fill_super ( sb ) ; if ( err ) { deactivate_locked_super ( sb ) ; return ERR_PTR ( err ) ; } sb -> s_flags |= MS_ACTIVE ; sb -> s_iflags |= SB_I_NOEXEC ; } return dget ( sb -> s_root ) ; }
","<S2SV_ModStart> sb ) ; sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ;
",torvalds@linux/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d,CVE-2016-1583,https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d,2016-06-27T10:59Z,"<S2SV_StartBug> if ( ! proc_parse_options ( options , ns ) ) { <S2SV_EndBug>"
2733,CWE-269,"static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( arg_zsh ) { if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { if ( is_link ( ""/etc/skel/.zshrc"" ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.zshrc<S2SV_blank>file\\n"" ) ; exit ( 1 ) ; } if ( copy_file ( ""/etc/skel/.zshrc"" , fname ) == 0 ) { if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ; fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; } } else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; fclose ( fp ) ; if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ; if ( chmod ( fname , S_IRUSR | S_IWUSR ) < 0 ) errExit ( ""chown"" ) ; fs_logger2 ( ""touch"" , fname ) ; } } free ( fname ) ; } else if ( arg_csh ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { if ( is_link ( ""/etc/skel/.cshrc"" ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.cshrc<S2SV_blank>file\\n"" ) ; exit ( 1 ) ; } if ( copy_file ( ""/etc/skel/.cshrc"" , fname ) == 0 ) { if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ; fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ; } } else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; fclose ( fp ) ; if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ; if ( chmod ( fname , S_IRUSR | S_IWUSR ) < 0 ) errExit ( ""chown"" ) ; fs_logger2 ( ""touch"" , fname ) ; } } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) { if ( is_link ( ""/etc/skel/.bashrc"" ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.bashrc<S2SV_blank>file\\n"" ) ; exit ( 1 ) ; } if ( copy_file ( ""/etc/skel/.bashrc"" , fname ) == 0 ) { if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ; fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ; } } free ( fname ) ; } }
","<S2SV_ModStart> ; if ( is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> 0 ) { copy_file_as_user ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ; fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( ""touch"" , fname ) ; } free ( fname ) ; } else if ( arg_csh ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <S2SV_ModStart> ( is_link ( fname <S2SV_ModEnd> ) ) { <S2SV_ModStart> ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname <S2SV_ModEnd> ) ; exit <S2SV_ModStart> } if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { copy_file_as_user ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) ; fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( ""touch"" , fname ) ; } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir <S2SV_ModEnd> ) == - <S2SV_ModStart> ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) { copy_file_as_user ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger <S2SV_ModStart> ; fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",netblue30@firejail/903fd8a0789ca3cc3c21d84cd0282481515592ef,CVE-2017-5940,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,2017-02-09T18:59Z,"<S2SV_StartBug> if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( is_link ( ""/etc/skel/.zshrc"" ) ) { <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.zshrc<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.zshrc"" , fname ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> errExit ( ""chown"" ) ; <S2SV_EndBug> <S2SV_StartBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( arg_csh ) { <S2SV_EndBug>"
7612,CWE-190,"void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 , int c0 , int r1 , int c1 ) { int i ; if ( mat0 -> data_ ) { if ( ! ( mat0 -> flags_ & JAS_MATRIX_REF ) ) { jas_free ( mat0 -> data_ ) ; } mat0 -> data_ = 0 ; mat0 -> datasize_ = 0 ; } if ( mat0 -> rows_ ) { jas_free ( mat0 -> rows_ ) ; mat0 -> rows_ = 0 ; } mat0 -> flags_ |= JAS_MATRIX_REF ; mat0 -> numrows_ = r1 - r0 + 1 ; mat0 -> numcols_ = c1 - c0 + 1 ; mat0 -> maxrows_ = mat0 -> numrows_ ; if ( ! ( mat0 -> rows_ = jas_alloc2 ( mat0 -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { abort ( ) ; } for ( i = 0 ; i < mat0 -> numrows_ ; ++ i ) { mat0 -> rows_ [ i ] = mat1 -> rows_ [ r0 + i ] + c0 ; } mat0 -> xstart_ = mat1 -> xstart_ + c0 ; mat0 -> ystart_ = mat1 -> ystart_ + r0 ; mat0 -> xend_ = mat0 -> xstart_ + mat0 -> numcols_ ; mat0 -> yend_ = mat0 -> ystart_ + mat0 -> numrows_ ; }
","<S2SV_ModStart> * mat1 , jas_matind_t r0 , jas_matind_t c0 , jas_matind_t r1 , jas_matind_t <S2SV_ModEnd> c1 ) { <S2SV_ModStart> c1 ) { jas_matind_t <S2SV_ModEnd> i ; if
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,"<S2SV_StartBug> void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 , <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug>"
4097,CWE-189,"STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; int count , i ; count = be32_to_cpu ( aclp -> acl_cnt ) ; acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }
","<S2SV_ModStart> aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED
",torvalds@linux/fa8b18edd752a8b4e9d1ee2cd615b82c93cf8bba,CVE-2012-0038,https://github.com/torvalds/linux/commit/fa8b18edd752a8b4e9d1ee2cd615b82c93cf8bba,2012-05-17T11:00Z,<S2SV_StartBug> count = be32_to_cpu ( aclp -> acl_cnt ) ; <S2SV_EndBug>
2885,CWE-20,"static INT AirPDcapScanForKeys ( PAIRPDCAP_CONTEXT ctx , const guint8 * data , const guint mac_header_len , const guint tot_len , AIRPDCAP_SEC_ASSOCIATION_ID id ) { const UCHAR * addr ; guint bodyLength ; PAIRPDCAP_SEC_ASSOCIATION sta_sa ; PAIRPDCAP_SEC_ASSOCIATION sa ; guint offset = 0 ; const guint8 dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x88 , 0x8E } ; const guint8 bt_dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x19 , 0x58 , 0x00 , 0x03 } ; const guint8 tdls_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x89 , 0x0D , 0x02 , 0X0C } ; const EAPOL_RSN_KEY * pEAPKey ; # ifdef _DEBUG # define MSGBUF_LEN 255 CHAR msgbuf [ MSGBUF_LEN ] ; # endif AIRPDCAP_DEBUG_TRACE_START ( ""AirPDcapScanForKeys"" ) ; offset = mac_header_len ; if ( memcmp ( data + offset , dot1x_header , 8 ) == 0 || memcmp ( data + offset , bt_dot1x_header , 8 ) == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Authentication:<S2SV_blank>EAPOL<S2SV_blank>packet"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 8 ; if ( data [ offset + 1 ] != 3 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>EAPOL-Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } bodyLength = pntoh16 ( data + offset + 2 ) ; if ( ( tot_len - offset - 4 ) < bodyLength ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 4 ; pEAPKey = ( const EAPOL_RSN_KEY * ) ( data + offset ) ; if ( pEAPKey -> type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR && pEAPKey -> type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>valid<S2SV_blank>key<S2SV_blank>descriptor<S2SV_blank>type"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 1 ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""No<S2SV_blank>SA<S2SV_blank>for<S2SV_blank>BSSID<S2SV_blank>found"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_REQ_DATA ; } if ( AirPDcapRsna4WHandshake ( ctx , data , sa , offset , tot_len ) == AIRPDCAP_RET_SUCCESS_HANDSHAKE ) return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; if ( mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Message<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } if ( AIRPDCAP_EAP_KEY ( data [ offset + 1 ] ) != 0 || AIRPDCAP_EAP_ACK ( data [ offset + 1 ] ) != 1 || AIRPDCAP_EAP_MIC ( data [ offset ] ) != 1 || AIRPDCAP_EAP_SEC ( data [ offset ] ) != 1 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Key<S2SV_blank>bitfields<S2SV_blank>not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } memcpy ( id . sta , broadcast_mac , AIRPDCAP_MAC_LEN ) ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( ( addr = AirPDcapGetStaAddress ( ( const AIRPDCAP_MAC_FRAME_ADDR4 * ) ( data ) ) ) != NULL ) { memcpy ( id . sta , addr , AIRPDCAP_MAC_LEN ) ; # ifdef _DEBUG g_snprintf ( msgbuf , MSGBUF_LEN , ""ST_MAC:<S2SV_blank>%2X.%2X.%2X.%2X.%2X.%2X\\t"" , id . sta [ 0 ] , id . sta [ 1 ] , id . sta [ 2 ] , id . sta [ 3 ] , id . sta [ 4 ] , id . sta [ 5 ] ) ; # endif AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , msgbuf , AIRPDCAP_DEBUG_LEVEL_3 ) ; } else { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""SA<S2SV_blank>not<S2SV_blank>found"" , AIRPDCAP_DEBUG_LEVEL_5 ) ; return AIRPDCAP_RET_REQ_DATA ; } sta_sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sta_sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } return ( AirPDcapDecryptWPABroadcastKey ( pEAPKey , sta_sa -> wpa . ptk + 16 , sa , tot_len - offset + 1 ) ) ; } else if ( memcmp ( data + offset , tdls_header , 10 ) == 0 ) { const guint8 * initiator , * responder ; guint8 action ; guint status , offset_rsne = 0 , offset_fte = 0 , offset_link = 0 , offset_timeout = 0 ; AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Authentication:<S2SV_blank>TDLS<S2SV_blank>Action<S2SV_blank>Frame"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 10 ; action = data [ offset ] ; if ( action != 1 && action != 2 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>Response<S2SV_blank>nor<S2SV_blank>confirm"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset ++ ; status = pntoh16 ( data + offset ) ; if ( status != 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""TDLS<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>successfull"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 5 ; while ( offset < ( tot_len - 2 ) ) { if ( data [ offset ] == 48 ) { offset_rsne = offset ; } else if ( data [ offset ] == 55 ) { offset_fte = offset ; } else if ( data [ offset ] == 56 ) { offset_timeout = offset ; } else if ( data [ offset ] == 101 ) { offset_link = offset ; } if ( tot_len < offset + data [ offset + 1 ] + 2 ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += data [ offset + 1 ] + 2 ; } if ( offset_rsne == 0 || offset_fte == 0 || offset_timeout == 0 || offset_link == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Cannot<S2SV_blank>Find<S2SV_blank>all<S2SV_blank>necessary<S2SV_blank>IEs"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Found<S2SV_blank>RSNE/Fast<S2SV_blank>BSS/Timeout<S2SV_blank>Interval/Link<S2SV_blank>IEs"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; initiator = & data [ offset_link + 8 ] ; responder = & data [ offset_link + 14 ] ; if ( memcmp ( initiator , responder , AIRPDCAP_MAC_LEN ) < 0 ) { memcpy ( id . sta , initiator , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , responder , AIRPDCAP_MAC_LEN ) ; } else { memcpy ( id . sta , responder , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , initiator , AIRPDCAP_MAC_LEN ) ; } sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( sa -> validKey ) { if ( memcmp ( sa -> wpa . nonce , data + offset_fte + 52 , AIRPDCAP_WPA_NONCE_LEN ) == 0 ) { return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } else { AIRPDCAP_SEC_ASSOCIATION * tmp_sa = g_new ( AIRPDCAP_SEC_ASSOCIATION , 1 ) ; memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; sa -> next = tmp_sa ; sa -> validKey = FALSE ; } } if ( AirPDcapTDLSDeriveKey ( sa , data , offset_rsne , offset_fte , offset_timeout , offset_link , action ) == AIRPDCAP_RET_SUCCESS ) { AIRPDCAP_DEBUG_TRACE_END ( ""AirPDcapScanForKeys"" ) ; return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } } else { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Skipping:<S2SV_blank>not<S2SV_blank>an<S2SV_blank>EAPOL<S2SV_blank>packet"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; } AIRPDCAP_DEBUG_TRACE_END ( ""AirPDcapScanForKeys"" ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; }
","<S2SV_ModStart> if ( ( ( <S2SV_ModStart> ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) )
",wireshark@wireshark/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4,CVE-2016-5351,https://github.com/wireshark/wireshark/commit/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4,2016-08-07T16:59Z,<S2SV_StartBug> if ( ( tot_len - offset - 4 ) < bodyLength ) { <S2SV_EndBug>
2162,CWE-20,"static void f2fs_put_super ( struct super_block * sb ) { struct f2fs_sb_info * sbi = F2FS_SB ( sb ) ; int i ; f2fs_quota_off_umount ( sb ) ; mutex_lock ( & sbi -> umount_mutex ) ; if ( is_sbi_flag_set ( sbi , SBI_IS_DIRTY ) || ! is_set_ckpt_flags ( sbi , CP_UMOUNT_FLAG ) ) { struct cp_control cpc = { . reason = CP_UMOUNT , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_wait_discard_bios ( sbi ) ; if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = { . reason = CP_UMOUNT | CP_TRIMMED , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_destroy_stats ( sbi ) ; release_ino_entry ( sbi , true ) ; f2fs_leave_shrinker ( sbi ) ; mutex_unlock ( & sbi -> umount_mutex ) ; f2fs_flush_merged_writes ( sbi ) ; iput ( sbi -> node_inode ) ; iput ( sbi -> meta_inode ) ; destroy_node_manager ( sbi ) ; destroy_segment_manager ( sbi ) ; kfree ( sbi -> ckpt ) ; f2fs_unregister_sysfs ( sbi ) ; sb -> s_fs_info = NULL ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> raw_super ) ; destroy_device_list ( sbi ) ; mempool_destroy ( sbi -> write_io_dummy ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif destroy_percpu_info ( sbi ) ; for ( i = 0 ; i < NR_PAGE_TYPE ; i ++ ) kfree ( sbi -> write_io [ i ] ) ; kfree ( sbi ) ; }
","<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , true
",torvalds@linux/638164a2718f337ea224b747cf5977ef143166a4,CVE-2017-18200,https://github.com/torvalds/linux/commit/638164a2718f337ea224b747cf5977ef143166a4,2018-02-26T03:29Z,<S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug>
2829,CWE-255,"static int toggle_utf8 ( const char * name , int fd , bool utf8 ) { int r ; struct termios tc = { } ; assert ( name ) ; r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ; if ( r < 0 ) return log_warning_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , enable_disable ( utf8 ) , name ) ; r = loop_write ( fd , utf8 ? ""\\033%G"" : ""\\033%@"" , 3 , false ) ; if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>term<S2SV_blank>processing<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , enable_disable ( utf8 ) , name ) ; r = tcgetattr ( fd , & tc ) ; if ( r >= 0 ) { SET_FLAG ( tc . c_iflag , IUTF8 , utf8 ) ; r = tcsetattr ( fd , TCSANOW , & tc ) ; } if ( r < 0 ) return log_warning_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>iutf8<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , enable_disable ( utf8 ) , name ) ; log_debug ( ""UTF-8<S2SV_blank>kbdmode<S2SV_blank>%sd<S2SV_blank>on<S2SV_blank>%s"" , enable_disable ( utf8 ) , name ) ; return 0 ; }
","<S2SV_ModStart> ; assert ( name ) ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_warning_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m"" , name ) ; return 0 ; } else if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" ,
",systemd@systemd/9725f1a10f80f5e0ae7d9b60547458622aeb322f,CVE-2018-20839,https://github.com/systemd/systemd/commit/9725f1a10f80f5e0ae7d9b60547458622aeb322f,2019-05-17T04:29Z,<S2SV_StartBug> assert ( name ) ; <S2SV_EndBug>
3296,CWE-399,"void br_mdb_notify ( struct net_device * dev , struct net_bridge_port * port , struct br_ip * group , int type ) { struct br_mdb_entry entry ; entry . ifindex = port -> dev -> ifindex ; entry . addr . proto = group -> proto ; entry . addr . u . ip4 = group -> u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) entry . addr . u . ip6 = group -> u . ip6 ; # endif __br_mdb_notify ( dev , & entry , type ) ; }
","<S2SV_ModStart> struct br_mdb_entry entry ; memset ( & entry , 0 , sizeof ( entry ) )
",torvalds@linux/c085c49920b2f900ba716b4ca1c1a55ece9872cc,CVE-2013-2636,https://github.com/torvalds/linux/commit/c085c49920b2f900ba716b4ca1c1a55ece9872cc,2013-03-22T11:59Z,<S2SV_StartBug> struct br_mdb_entry entry ; <S2SV_EndBug>
6534,CWE-119,"cJSON * cJSON_DetachItemFromArray ( cJSON * array , int which ) { cJSON * c = array -> child ; while ( c && which > 0 ) { c = c -> next ; -- which ; } if ( ! c ) return 0 ; if ( c -> prev ) c -> prev -> next = c -> next ; if ( c -> next ) c -> next -> prev = c -> prev ; if ( c == array -> child ) array -> child = c -> next ; c -> prev = c -> next = 0 ; return c ; }
","<S2SV_ModStart> > 0 ) <S2SV_ModEnd> c = c <S2SV_ModStart> c -> next , which -- ; <S2SV_ModEnd> if ( !
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,<S2SV_StartBug> while ( c && which > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = c -> next ; <S2SV_EndBug>
3596,CWE-476,"int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) { dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; struct flush_cmd_control * fcc ; int err = 0 ; if ( SM_I ( sbi ) -> fcc_info ) { fcc = SM_I ( sbi ) -> fcc_info ; goto init_thread ; } fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , GFP_KERNEL ) ; if ( ! fcc ) return - ENOMEM ; atomic_set ( & fcc -> issued_flush , 0 ) ; atomic_set ( & fcc -> issing_flush , 0 ) ; init_waitqueue_head ( & fcc -> flush_wait_queue ) ; init_llist_head ( & fcc -> issue_list ) ; SM_I ( sbi ) -> fcc_info = fcc ; init_thread : fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , ""f2fs_flush-%u:%u"" , MAJOR ( dev ) , MINOR ( dev ) ) ; if ( IS_ERR ( fcc -> f2fs_issue_flush ) ) { err = PTR_ERR ( fcc -> f2fs_issue_flush ) ; kfree ( fcc ) ; SM_I ( sbi ) -> fcc_info = NULL ; return err ; } return err ; }
","<S2SV_ModStart> = fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;
",torvalds@linux/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,CVE-2017-18241,https://github.com/torvalds/linux/commit/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,2018-03-21T16:29Z,<S2SV_StartBug> init_thread : <S2SV_EndBug>
3487,CWE-119,"int process ( register int code , unsigned char * * fill ) { int incode ; static unsigned char firstchar ; if ( code == clear ) { codesize = datasize + 1 ; codemask = ( 1 << codesize ) - 1 ; avail = clear + 2 ; oldcode = - 1 ; return 1 ; } if ( oldcode == - 1 ) { * ( * fill ) ++ = suffix [ code ] ; firstchar = oldcode = code ; return 1 ; } if ( code > avail ) { fprintf ( stderr , ""code<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>%d\\n"" , code , avail ) ; return 0 ; } incode = code ; if ( code == avail ) { * stackp ++ = firstchar ; code = oldcode ; } while ( code > clear ) { * stackp ++ = suffix [ code ] ; code = prefix [ code ] ; } * stackp ++ = firstchar = suffix [ code ] ; prefix [ avail ] = oldcode ; suffix [ avail ] = firstchar ; avail ++ ; if ( ( ( avail & codemask ) == 0 ) && ( avail < 4096 ) ) { codesize ++ ; codemask += avail ; } oldcode = incode ; do { * ( * fill ) ++ = * -- stackp ; } while ( stackp > stack ) ; return 1 ; }
","<S2SV_ModStart> 1 ) { if ( code >= clear ) { fprintf ( stderr , ""bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\n"" , code , clear ) ; return 0 ; }
",vadz@libtiff/ce6841d9e41d621ba23cf18b190ee6a23b2cc833,CVE-2013-4244,https://github.com/vadz/libtiff/commit/ce6841d9e41d621ba23cf18b190ee6a23b2cc833,2013-09-28T19:55Z,<S2SV_StartBug> * ( * fill ) ++ = suffix [ code ] ; <S2SV_EndBug>
3051,CWE-20,"static void _out_result ( conn_t out , nad_t nad ) { int attr ; jid_t from , to ; char * rkey ; int rkeylen ; attr = nad_find_attr ( nad , 0 , - 1 , ""from"" , NULL ) ; if ( attr < 0 || ( from = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , ""missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>from<S2SV_blank>on<S2SV_blank>db<S2SV_blank>result<S2SV_blank>packet"" ) ; nad_free ( nad ) ; return ; } attr = nad_find_attr ( nad , 0 , - 1 , ""to"" , NULL ) ; if ( attr < 0 || ( to = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , ""missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>to<S2SV_blank>on<S2SV_blank>db<S2SV_blank>result<S2SV_blank>packet"" ) ; jid_free ( from ) ; nad_free ( nad ) ; return ; } rkey = s2s_route_key ( NULL , to -> domain , from -> domain ) ; rkeylen = strlen ( rkey ) ; if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 ) { log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , out -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ; xhash_put ( out -> states , pstrdup ( xhash_pool ( out -> states ) , rkey ) , ( void * ) conn_VALID ) ; log_debug ( ZONE , ""%s<S2SV_blank>valid,<S2SV_blank>flushing<S2SV_blank>queue"" , rkey ) ; out_flush_route_queue ( out -> s2s , rkey , rkeylen ) ; free ( rkey ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; return ; } log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>invalid"" , out -> fd -> fd , out -> ip , out -> port , rkey ) ; log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>closing<S2SV_blank>connection"" , out -> fd -> fd , out -> ip , out -> port ) ; sx_error ( out -> s , stream_err_INVALID_ID , ""dialback<S2SV_blank>negotiation<S2SV_blank>failed"" ) ; sx_close ( out -> s ) ; out_bounce_route_queue ( out -> s2s , rkey , rkeylen , stanza_err_SERVICE_UNAVAILABLE ) ; free ( rkey ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; }
","<S2SV_ModStart> ) >= 0 && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS
",Jabberd2@jabberd2/aabcffae560d5fd00cd1d2ffce5d760353cf0a4d,CVE-2012-3525,https://github.com/Jabberd2/jabberd2/commit/aabcffae560d5fd00cd1d2ffce5d760353cf0a4d,2012-08-25T16:55Z,"<S2SV_StartBug> if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 ) { <S2SV_EndBug>"
3428,CWE-404,"long keyctl_set_reqkey_keyring ( int reqkey_defl ) { struct cred * new ; int ret , old_setting ; old_setting = current_cred_xxx ( jit_keyring ) ; if ( reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE ) return old_setting ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; switch ( reqkey_defl ) { case KEY_REQKEY_DEFL_THREAD_KEYRING : ret = install_thread_keyring_to_cred ( new ) ; if ( ret < 0 ) goto error ; goto set ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { if ( ret != - EEXIST ) goto error ; ret = 0 ; } goto set ; case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_SESSION_KEYRING : case KEY_REQKEY_DEFL_USER_KEYRING : case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : goto set ; case KEY_REQKEY_DEFL_NO_CHANGE : case KEY_REQKEY_DEFL_GROUP_KEYRING : default : ret = - EINVAL ; goto error ; } set : new -> jit_keyring = reqkey_defl ; commit_creds ( new ) ; return old_setting ; error : abort_creds ( new ) ; return ret ; }
","<S2SV_ModStart> < 0 ) goto error ; <S2SV_ModEnd> goto set ;
",torvalds@linux/c9f838d104fed6f2f61d68164712e3204bf5271b,CVE-2017-7472,https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b,2017-05-11T19:29Z,<S2SV_StartBug> if ( ret < 0 ) { <S2SV_EndBug>
5651,CWE-119,"static void scalar32_min_max_or ( struct bpf_reg_state * dst_reg , struct bpf_reg_state * src_reg ) { bool src_known = tnum_subreg_is_const ( src_reg -> var_off ) ; bool dst_known = tnum_subreg_is_const ( dst_reg -> var_off ) ; struct tnum var32_off = tnum_subreg ( dst_reg -> var_off ) ; s32 smin_val = src_reg -> smin_value ; u32 umin_val = src_reg -> umin_value ; if ( src_known && dst_known ) return ; dst_reg -> u32_min_value = max ( dst_reg -> u32_min_value , umin_val ) ; dst_reg -> u32_max_value = var32_off . value | var32_off . mask ; if ( dst_reg -> s32_min_value < 0 || smin_val < 0 ) { dst_reg -> s32_min_value = S32_MIN ; dst_reg -> s32_max_value = S32_MAX ; } else { dst_reg -> s32_min_value = dst_reg -> umin_value ; dst_reg -> s32_max_value = dst_reg -> umax_value ; } }
","<S2SV_ModStart> = src_reg -> s32_min_value <S2SV_ModEnd> ; u32 umin_val <S2SV_ModStart> = src_reg -> u32_min_value <S2SV_ModEnd> ; if ( <S2SV_ModStart> = dst_reg -> u32_min_value <S2SV_ModEnd> ; dst_reg -> <S2SV_ModStart> = dst_reg -> u32_max_value <S2SV_ModEnd> ; } }
",torvalds@linux/5b9fbeb75b6a98955f628e205ac26689bcb1383e,CVE-2020-27194,https://github.com/torvalds/linux/commit/5b9fbeb75b6a98955f628e205ac26689bcb1383e,2020-10-16T21:15Z,<S2SV_StartBug> s32 smin_val = src_reg -> smin_value ; <S2SV_EndBug> <S2SV_StartBug> u32 umin_val = src_reg -> umin_value ; <S2SV_EndBug> <S2SV_StartBug> dst_reg -> s32_min_value = dst_reg -> umin_value ; <S2SV_EndBug> <S2SV_StartBug> dst_reg -> s32_max_value = dst_reg -> umax_value ; <S2SV_EndBug>
3069,CWE-416,"static void lo_release ( struct gendisk * disk , fmode_t mode ) { struct loop_device * lo = disk -> private_data ; int err ; if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ; mutex_lock ( & lo -> lo_ctl_mutex ) ; if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) { err = loop_clr_fd ( lo ) ; if ( ! err ) return ; } else if ( lo -> lo_state == Lo_bound ) { blk_mq_freeze_queue ( lo -> lo_queue ) ; blk_mq_unfreeze_queue ( lo -> lo_queue ) ; } mutex_unlock ( & lo -> lo_ctl_mutex ) ; }
","<S2SV_ModStart> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> disk -> private_data <S2SV_ModStart> disk -> private_data ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> mutex_unlock ( & loop_index_mutex <S2SV_ModEnd> ) ; }
",torvalds@linux/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,CVE-2018-5344,https://github.com/torvalds/linux/commit/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,2018-01-12T09:29Z,<S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug>
4058,CWE-119,"static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char explicit_vr [ MaxTextExtent ] , implicit_vr [ MaxTextExtent ] , magick [ MaxTextExtent ] , photometric [ MaxTextExtent ] ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , index , * redmap ; MagickBooleanType explicit_file , explicit_retry , polarity , sequence , use_explicit ; MagickOffsetType offset ; Quantum * scale ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; register unsigned char * p ; size_t bits_allocated , bytes_per_pixel , colors , depth , height , length , mask , max_value , number_scenes , quantum , samples_per_pixel , signed_data , significant_bits , status , width , window_width ; ssize_t count , scene , window_center , y ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MaxTextExtent ) ; bits_allocated = 8 ; bytes_per_pixel = 1 ; polarity = MagickFalse ; data = ( unsigned char * ) NULL ; depth = 8 ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; max_value = 255UL ; mask = 0xffff ; number_scenes = 1 ; samples_per_pixel = 1 ; scale = ( Quantum * ) NULL ; sequence = MagickFalse ; signed_data = ( ~ 0UL ) ; significant_bits = 0 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; window_center = 0 ; window_width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MaxTextExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strcmp ( implicit_vr , ""xs"" ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MaxTextExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strcmp ( implicit_vr , ""!!"" ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strcmp ( explicit_vr , ""OB"" ) == 0 ) || ( strcmp ( explicit_vr , ""UN"" ) == 0 ) || ( strcmp ( explicit_vr , ""OW"" ) == 0 ) || ( strcmp ( explicit_vr , ""SQ"" ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ( int ) ReadBlobLSBLong ( image ) ; else datum = ( int ) ReadBlobLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ( int ) ReadBlobLSBShort ( image ) ; else datum = ( int ) ReadBlobShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strcmp ( implicit_vr , ""SS"" ) == 0 ) || ( strcmp ( implicit_vr , ""US"" ) == 0 ) ) quantum = 2 ; else if ( ( strcmp ( implicit_vr , ""UL"" ) == 0 ) || ( strcmp ( implicit_vr , ""SL"" ) == 0 ) || ( strcmp ( implicit_vr , ""FL"" ) == 0 ) ) quantum = 4 ; else if ( strcmp ( implicit_vr , ""FD"" ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ( int ) ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ( int ) ReadBlobLSBShort ( image ) ; else datum = ( int ) ReadBlobShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ( int ) ReadBlobLSBLong ( image ) ; else datum = ( int ) ReadBlobLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MaxTextExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MaxTextExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 0 ; subtype = 0 ; ( void ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MaxTextExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { bits_allocated = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( datum > 8 ) bytes_per_pixel = 2 ; depth = bits_allocated ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; max_value = ( 1UL << bits_allocated ) - 1 ; break ; } case 0x0101 : { significant_bits = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( significant_bits > 8 ) bytes_per_pixel = 2 ; depth = significant_bits ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; max_value = ( 1UL << significant_bits ) - 1 ; mask = ( size_t ) GetQuantumRange ( significant_bits ) ; break ; } case 0x0102 : { break ; } case 0x0103 : { signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) window_width = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( signed_data == 0xffff ) signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ( ( int ) ReadBlobLSBLong ( image ) ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MaxTextExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property ) ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ; scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * scale ) ) ; if ( scale == ( Quantum * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; range = GetQuantumRange ( depth ) ; for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ( ( int ) ReadBlobLSBLong ( image ) ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = depth ; image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelPacket * ) NULL ) && ( samples_per_pixel == 1 ) ) { size_t one ; one = 1 ; if ( colors == 0 ) colors = one << depth ; if ( AcquireImageColormap ( image , one << depth ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . green = ( Quantum ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . blue = ( Quantum ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; image -> colormap [ i ] . green = ( Quantum ) index ; image -> colormap [ i ] . blue = ( Quantum ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; if ( stream_info -> segment_count > 1 ) { bytes_per_pixel = 1 ; depth = 8 ; } for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ( ( int ) ReadBlobLSBLong ( image ) ) ; stream_info -> remaining -= 64 ; } if ( ( samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 1 : { SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 2 : { SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 3 : { SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } default : break ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; int byte ; LongPixelPacket pixel ; byte = 0 ; i = 0 ; if ( ( window_center != 0 ) && ( window_width == 0 ) ) window_width = ( size_t ) window_center ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) window_width = 0 ; } ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - ReadDCMShort ( stream_info , image ) ) : ReadDCMShort ( stream_info , image ) ) ; else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ( int ) ReadDCMShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = pixel_value ; if ( window_width == 0 ) { if ( signed_data == 1 ) index = pixel_value - 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) pixel_value <= window_min ) index = 0 ; else if ( ( ssize_t ) pixel_value > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( pixel_value - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index ) ; SetPixelIndex ( indexes + x , index ) ; pixel . red = 1U * image -> colormap [ index ] . red ; pixel . green = 1U * image -> colormap [ index ] . green ; pixel . blue = 1U * image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { pixel . red = scale [ pixel . red ] ; pixel . green = scale [ pixel . green ] ; pixel . blue = scale [ pixel . blue ] ; } } SetPixelRed ( q , pixel . red ) ; SetPixelGreen ( q , pixel . green ) ; SetPixelBlue ( q , pixel . blue ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> segment_count > 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - ReadDCMShort ( stream_info , image ) ) : ReadDCMShort ( stream_info , image ) ) ; if ( signed_data == 1 ) pixel_value = ( ( signed short ) pixel_value ) ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ( int ) ReadDCMShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = pixel_value ; if ( window_width == 0 ) { if ( signed_data == 1 ) index = pixel_value - 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) pixel_value <= window_min ) index = 0 ; else if ( ( ssize_t ) pixel_value > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( pixel_value - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index ) ; SetPixelIndex ( indexes + x , ( ( ( size_t ) GetPixelIndex ( indexes + x ) ) | ( ( ( size_t ) index ) << 8 ) ) ) ; pixel . red = 1U * image -> colormap [ index ] . red ; pixel . green = 1U * image -> colormap [ index ] . green ; pixel . blue = 1U * image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { pixel . red = scale [ pixel . red ] ; pixel . green = scale [ pixel . green ] ; pixel . blue = scale [ pixel . blue ] ; } } SetPixelRed ( q , ( ( ( size_t ) GetPixelRed ( q ) ) | ( ( ( size_t ) pixel . red ) << 8 ) ) ) ; SetPixelGreen ( q , ( ( ( size_t ) GetPixelGreen ( q ) ) | ( ( ( size_t ) pixel . green ) << 8 ) ) ) ; SetPixelBlue ( q , ( ( ( size_t ) GetPixelBlue ( q ) ) | ( ( ( size_t ) pixel . blue ) << 8 ) ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( IsGrayImage ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( scale != ( Quantum * ) NULL ) scale = ( Quantum * ) RelinquishMagickMemory ( scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,<S2SV_StartBug> image -> colorspace = RGBColorspace ; <S2SV_EndBug>
7104,CWE-119,"static int cac_cac1_get_certificate ( sc_card_t * card , u8 * * out_buf , size_t * out_len ) { u8 buf [ CAC_MAX_SIZE ] ; u8 * out_ptr ; size_t size = 0 ; size_t left = 0 ; size_t len , next_len ; sc_apdu_t apdu ; int r = SC_SUCCESS ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_VERBOSE ) ; size = left = * out_buf ? * out_len : sizeof ( buf ) ; out_ptr = * out_buf ? * out_buf : buf ; sc_format_apdu ( card , & apdu , SC_APDU_CASE_2_SHORT , CAC_INS_GET_CERTIFICATE , 0 , 0 ) ; next_len = MIN ( left , 100 ) ; for ( ; left > 0 ; left -= len , out_ptr += len ) { len = next_len ; apdu . resp = out_ptr ; apdu . le = len ; apdu . resplen = left ; r = sc_transmit_apdu ( card , & apdu ) ; if ( r < 0 ) { break ; } if ( apdu . resplen == 0 ) { r = SC_ERROR_INTERNAL ; break ; } if ( apdu . sw1 != 0x63 || apdu . sw2 < 1 ) { r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; left -= len ; break ; } next_len = MIN ( left , apdu . sw2 ) ; } if ( r < 0 ) { SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , r ) ; } r = size - left ; if ( * out_buf == NULL ) { * out_buf = malloc ( r ) ; if ( * out_buf == NULL ) { SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_OUT_OF_MEMORY ) ; } memcpy ( * out_buf , buf , r ) ; } * out_len = r ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , r ) ; }
","<S2SV_ModStart> ; size_t len <S2SV_ModEnd> ; sc_apdu_t apdu <S2SV_ModStart> 0 ) ; len <S2SV_ModEnd> = MIN ( <S2SV_ModStart> > 0 ; ) { <S2SV_ModEnd> apdu . resp <S2SV_ModStart> break ; } left -= len ; out_ptr += len ; len <S2SV_ModEnd> = MIN (
",OpenSC@OpenSC/b75c002cfb1fd61cd20ec938ff4937d7b1a94278,CVE-2019-19481,https://github.com/OpenSC/OpenSC/commit/b75c002cfb1fd61cd20ec938ff4937d7b1a94278,2019-12-01T23:15Z,"<S2SV_StartBug> size_t len , next_len ; <S2SV_EndBug> <S2SV_StartBug> next_len = MIN ( left , 100 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ; left > 0 ; left -= len , out_ptr += len ) { <S2SV_EndBug> <S2SV_StartBug> next_len = MIN ( left , apdu . sw2 ) ; <S2SV_EndBug>"
6239,CWE-000,"static void addFormVars ( cchar * buf ) { char * pair , * tok ; pair = stok ( sclone ( buf ) , ""&"" , & tok ) ; while ( pair != 0 ) { mprAddItem ( app -> formData , sclone ( pair ) ) ; pair = stok ( 0 , ""&"" , & tok ) ; } }
","<S2SV_ModStart> while ( pair <S2SV_ModEnd> ) { mprAddItem
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,<S2SV_StartBug> while ( pair != 0 ) { <S2SV_EndBug>
2447,CWE-119,"int copy_creds ( struct task_struct * p , unsigned long clone_flags ) { # ifdef CONFIG_KEYS struct thread_group_cred * tgcred ; # endif struct cred * new ; int ret ; if ( # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) { p -> real_cred = get_cred ( p -> cred ) ; get_cred ( p -> cred ) ; alter_cred_subscribers ( p -> cred , 2 ) ; kdebug ( ""share_creds(%p{%d,%d})"" , p -> cred , atomic_read ( & p -> cred -> usage ) , read_cred_subscribers ( p -> cred ) ) ; atomic_inc ( & p -> cred -> user -> processes ) ; return 0 ; } new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; if ( clone_flags & CLONE_NEWUSER ) { ret = create_user_ns ( new ) ; if ( ret < 0 ) goto error_put ; } new -> user_ns = new -> user -> user_ns ; # ifdef CONFIG_KEYS if ( new -> thread_keyring ) { key_put ( new -> thread_keyring ) ; new -> thread_keyring = NULL ; if ( clone_flags & CLONE_THREAD ) install_thread_keyring_to_cred ( new ) ; } if ( ! ( clone_flags & CLONE_THREAD ) ) { tgcred = kmalloc ( sizeof ( * tgcred ) , GFP_KERNEL ) ; if ( ! tgcred ) { ret = - ENOMEM ; goto error_put ; } atomic_set ( & tgcred -> usage , 1 ) ; spin_lock_init ( & tgcred -> lock ) ; tgcred -> process_keyring = NULL ; tgcred -> session_keyring = key_get ( new -> tgcred -> session_keyring ) ; release_tgcred ( new ) ; new -> tgcred = tgcred ; } # endif atomic_inc ( & new -> user -> processes ) ; p -> cred = p -> real_cred = get_cred ( new ) ; alter_cred_subscribers ( new , 2 ) ; validate_creds ( new ) ; return 0 ; error_put : put_cred ( new ) ; return ret ; }
","<S2SV_ModStart> int ret ; p -> replacement_session_keyring = NULL ;
",torvalds@linux/79549c6dfda0603dba9a70a53467ce62d9335c33,CVE-2012-2745,https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33,2012-08-09T10:29Z,<S2SV_StartBug> if ( <S2SV_EndBug>
5588,CWE-399,"static int cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection ) { int sock ; cib_remote_opaque_t * private = cib -> variant_opaque ; struct sockaddr_in addr ; int rc = 0 ; char * server = private -> server ; int ret_ga ; struct addrinfo * res ; struct addrinfo hints ; xmlNode * answer = NULL ; xmlNode * login = NULL ; static struct mainloop_fd_callbacks cib_fd_callbacks = { . dispatch = cib_remote_dispatch , . destroy = cib_remote_connection_destroy , } ; connection -> socket = 0 ; connection -> session = NULL ; sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ; if ( sock == - 1 ) { crm_perror ( LOG_ERR , ""Socket<S2SV_blank>creation<S2SV_blank>failed"" ) ; return - 1 ; } bzero ( & hints , sizeof ( struct addrinfo ) ) ; hints . ai_flags = AI_CANONNAME ; hints . ai_family = AF_INET ; hints . ai_socktype = SOCK_RAW ; if ( hints . ai_family == AF_INET6 ) { hints . ai_protocol = IPPROTO_ICMPV6 ; } else { hints . ai_protocol = IPPROTO_ICMP ; } crm_debug ( ""Looking<S2SV_blank>up<S2SV_blank>%s"" , server ) ; ret_ga = getaddrinfo ( server , NULL , & hints , & res ) ; if ( ret_ga ) { crm_err ( ""getaddrinfo:<S2SV_blank>%s"" , gai_strerror ( ret_ga ) ) ; close ( sock ) ; return - 1 ; } if ( res -> ai_canonname ) { server = res -> ai_canonname ; } crm_debug ( ""Got<S2SV_blank>address<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , server , private -> server ) ; if ( ! res -> ai_addr ) { fprintf ( stderr , ""getaddrinfo<S2SV_blank>failed"" ) ; crm_exit ( 1 ) ; } # if 1 memcpy ( & addr , res -> ai_addr , res -> ai_addrlen ) ; # else memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = inet_addr ( server ) ; # endif addr . sin_port = htons ( private -> port ) ; if ( connect ( sock , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) { crm_perror ( LOG_ERR , ""Connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ; close ( sock ) ; return - 1 ; } if ( connection -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H gnutls_global_init ( ) ; gnutls_anon_allocate_client_credentials ( & anon_cred_c ) ; connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ; if ( connection -> session == NULL ) { crm_perror ( LOG_ERR , ""Session<S2SV_blank>creation<S2SV_blank>for<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ; close ( sock ) ; cib_tls_close ( cib ) ; return - 1 ; } # else return - EPROTONOSUPPORT ; # endif } else { connection -> session = GUINT_TO_POINTER ( sock ) ; } login = create_xml_node ( NULL , ""cib_command"" ) ; crm_xml_add ( login , ""op"" , ""authenticate"" ) ; crm_xml_add ( login , ""user"" , private -> user ) ; crm_xml_add ( login , ""password"" , private -> passwd ) ; crm_xml_add ( login , ""hidden"" , ""password"" ) ; crm_send_remote_msg ( connection -> session , login , connection -> encrypted ) ; free_xml ( login ) ; answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ; crm_log_xml_trace ( answer , ""Reply"" ) ; if ( answer == NULL ) { rc = - EPROTO ; } else { const char * msg_type = crm_element_value ( answer , F_CIB_OPERATION ) ; const char * tmp_ticket = crm_element_value ( answer , F_CIB_CLIENTID ) ; if ( safe_str_neq ( msg_type , CRM_OP_REGISTER ) ) { crm_err ( ""Invalid<S2SV_blank>registration<S2SV_blank>message:<S2SV_blank>%s"" , msg_type ) ; rc = - EPROTO ; } else if ( tmp_ticket == NULL ) { rc = - EPROTO ; } else { connection -> token = strdup ( tmp_ticket ) ; } } if ( rc != 0 ) { cib_tls_close ( cib ) ; } connection -> socket = sock ; connection -> source = mainloop_add_fd ( ""cib-remote"" , G_PRIORITY_HIGH , connection -> socket , cib , & cib_fd_callbacks ) ; return rc ; }
","<S2SV_ModStart> remote_connection_s * connection , gboolean event_channel <S2SV_ModStart> -> variant_opaque ; <S2SV_ModEnd> int rc = <S2SV_ModStart> = 0 ; int disconnected = 0 <S2SV_ModEnd> ; xmlNode * <S2SV_ModStart> mainloop_fd_callbacks cib_fd_callbacks = { 0 , } ; cib_fd_callbacks <S2SV_ModEnd> . dispatch = <S2SV_ModStart> . dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch ; cib_fd_callbacks <S2SV_ModEnd> . destroy = <S2SV_ModStart> destroy = cib_remote_connection_destroy <S2SV_ModEnd> ; connection -> <S2SV_ModStart> ; sock = crm_remote_tcp_connect ( private -> server , private -> port ) ; if ( sock <= 0 ) { crm_perror ( LOG_ERR , ""remote<S2SV_blank>tcp<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> server , private -> port ) ; } connection -> socket = sock ; <S2SV_ModEnd> if ( connection <S2SV_ModStart> # ifdef HAVE_GNUTLS_GNUTLS_H if ( remote_gnutls_credentials_init == FALSE ) { <S2SV_ModStart> anon_cred_c ) ; remote_gnutls_credentials_init = TRUE ; } connection -> session = crm_create_anon_tls_session <S2SV_ModEnd> ( sock , <S2SV_ModStart> sock , GNUTLS_CLIENT , anon_cred_c ) ; if ( crm_initiate_client_tls_handshake ( connection -> session , DEFAULT_CLIENT_HANDSHAKE_TIMEOUT ) != 0 ) { crm_err ( ""Session<S2SV_blank>creation<S2SV_blank>for<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> <S2SV_ModEnd> server , private <S2SV_ModStart> port ) ; gnutls_deinit ( * connection -> session ) ; gnutls_free ( connection -> session ) ; connection -> session = NULL <S2SV_ModEnd> ; cib_tls_close ( <S2SV_ModStart> login ) ; <S2SV_ModEnd> crm_recv_remote_msg ( connection <S2SV_ModStart> -> session , & connection -> recv_buf , <S2SV_ModStart> connection -> encrypted , - 1 , & disconnected ) ; if ( disconnected ) { rc = - ENOTCONN ; } answer = crm_parse_remote_buffer ( & connection -> recv_buf <S2SV_ModStart> ; } } free_xml ( answer ) ; answer = NULL ; <S2SV_ModStart> cib ) ; return rc ; } crm_trace ( ""remote<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>established"" ) <S2SV_ModEnd> ; connection ->
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z,"<S2SV_StartBug> cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection ) <S2SV_EndBug> <S2SV_StartBug> struct sockaddr_in addr ; <S2SV_EndBug> <S2SV_StartBug> char * server = private -> server ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> . dispatch = cib_remote_dispatch , <S2SV_EndBug> <S2SV_StartBug> . destroy = cib_remote_connection_destroy , <S2SV_EndBug> <S2SV_StartBug> sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ; <S2SV_EndBug> <S2SV_StartBug> gnutls_global_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ; <S2SV_EndBug> <S2SV_StartBug> close ( sock ) ; <S2SV_EndBug> <S2SV_StartBug> answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc != 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
629,CWE-787,"opj_image_t * tgatoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f ; opj_image_t * image ; unsigned int image_width , image_height , pixel_bit_depth ; unsigned int x , y ; int flip_image = 0 ; opj_image_cmptparm_t cmptparm [ 4 ] ; int numcomps ; OPJ_COLOR_SPACE color_space ; OPJ_BOOL mono ; OPJ_BOOL save_alpha ; int subsampling_dx , subsampling_dy ; int i ; f = fopen ( filename , ""rb"" ) ; if ( ! f ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>!!\\n"" , filename ) ; return 0 ; } if ( ! tga_readheader ( f , & pixel_bit_depth , & image_width , & image_height , & flip_image ) ) { fclose ( f ) ; return NULL ; } if ( ! ( ( pixel_bit_depth == 24 ) || ( pixel_bit_depth == 32 ) ) ) { fclose ( f ) ; return NULL ; } memset ( & cmptparm [ 0 ] , 0 , 4 * sizeof ( opj_image_cmptparm_t ) ) ; mono = ( pixel_bit_depth == 8 ) || ( pixel_bit_depth == 16 ) ; save_alpha = ( pixel_bit_depth == 16 ) || ( pixel_bit_depth == 32 ) ; if ( mono ) { color_space = OPJ_CLRSPC_GRAY ; numcomps = save_alpha ? 2 : 1 ; } else { numcomps = save_alpha ? 4 : 3 ; color_space = OPJ_CLRSPC_SRGB ; } subsampling_dx = parameters -> subsampling_dx ; subsampling_dy = parameters -> subsampling_dy ; for ( i = 0 ; i < numcomps ; i ++ ) { cmptparm [ i ] . prec = 8 ; cmptparm [ i ] . bpp = 8 ; cmptparm [ i ] . sgnd = 0 ; cmptparm [ i ] . dx = ( OPJ_UINT32 ) subsampling_dx ; cmptparm [ i ] . dy = ( OPJ_UINT32 ) subsampling_dy ; cmptparm [ i ] . w = image_width ; cmptparm [ i ] . h = image_height ; } image = opj_image_create ( ( OPJ_UINT32 ) numcomps , & cmptparm [ 0 ] , color_space ) ; if ( ! image ) { fclose ( f ) ; return NULL ; } image -> x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; image -> y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; image -> x1 = ! image -> x0 ? ( OPJ_UINT32 ) ( image_width - 1 ) * ( OPJ_UINT32 ) subsampling_dx + 1 : image -> x0 + ( OPJ_UINT32 ) ( image_width - 1 ) * ( OPJ_UINT32 ) subsampling_dx + 1 ; image -> y1 = ! image -> y0 ? ( OPJ_UINT32 ) ( image_height - 1 ) * ( OPJ_UINT32 ) subsampling_dy + 1 : image -> y0 + ( OPJ_UINT32 ) ( image_height - 1 ) * ( OPJ_UINT32 ) subsampling_dy + 1 ; for ( y = 0 ; y < image_height ; y ++ ) { int index ; if ( flip_image ) { index = ( int ) ( ( image_height - y - 1 ) * image_width ) ; } else { index = ( int ) ( y * image_width ) ; } if ( numcomps == 3 ) { for ( x = 0 ; x < image_width ; x ++ ) { unsigned char r , g , b ; if ( ! fread ( & b , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & g , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & r , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } image -> comps [ 0 ] . data [ index ] = r ; image -> comps [ 1 ] . data [ index ] = g ; image -> comps [ 2 ] . data [ index ] = b ; index ++ ; } } else if ( numcomps == 4 ) { for ( x = 0 ; x < image_width ; x ++ ) { unsigned char r , g , b , a ; if ( ! fread ( & b , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & g , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & r , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & a , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } image -> comps [ 0 ] . data [ index ] = r ; image -> comps [ 1 ] . data [ index ] = g ; image -> comps [ 2 ] . data [ index ] = b ; image -> comps [ 3 ] . data [ index ] = a ; index ++ ; } } else { fprintf ( stderr , ""Currently<S2SV_blank>unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>:<S2SV_blank>%s\\n"" , filename ) ; } } fclose ( f ) ; return image ; }
","<S2SV_ModStart> OPJ_CLRSPC_SRGB ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }
",uclouvain@openjpeg/2cd30c2b06ce332dede81cccad8b334cde997281,CVE-2017-14040,https://github.com/uclouvain/openjpeg/commit/2cd30c2b06ce332dede81cccad8b334cde997281,2017-08-30T22:29Z,<S2SV_StartBug> subsampling_dx = parameters -> subsampling_dx ; <S2SV_EndBug>
5877,CWE-416,"static void ndpi_reset_packet_line_info ( struct ndpi_packet_struct * packet ) { packet -> parsed_lines = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 , packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet -> http_num_headers = 0 ; }
","<S2SV_ModStart> , packet -> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet ->
",ntop@nDPI/6a9f5e4f7c3fd5ddab3e6727b071904d76773952,CVE-2020-15475,https://github.com/ntop/nDPI/commit/6a9f5e4f7c3fd5ddab3e6727b071904d76773952,2020-07-01T11:15Z,"<S2SV_StartBug> packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , <S2SV_EndBug>"
252,CWE-119,"static int dtls1_buffer_record ( SSL * s , record_pqueue * queue , unsigned char * priority ) { DTLS1_RECORD_DATA * rdata ; pitem * item ; if ( pqueue_size ( queue -> q ) >= 100 ) return 0 ; rdata = OPENSSL_malloc ( sizeof ( DTLS1_RECORD_DATA ) ) ; item = pitem_new ( priority , rdata ) ; if ( rdata == NULL || item == NULL ) { if ( rdata != NULL ) OPENSSL_free ( rdata ) ; if ( item != NULL ) pitem_free ( item ) ; SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; return ( 0 ) ; } rdata -> packet = s -> packet ; rdata -> packet_length = s -> packet_length ; memcpy ( & ( rdata -> rbuf ) , & ( s -> s3 -> rbuf ) , sizeof ( SSL3_BUFFER ) ) ; memcpy ( & ( rdata -> rrec ) , & ( s -> s3 -> rrec ) , sizeof ( SSL3_RECORD ) ) ; item -> data = rdata ; # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == SSL3_ST_SR_FINISHED_A || s -> state == SSL3_ST_CR_FINISHED_A ) ) { BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_GET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif s -> packet = NULL ; s -> packet_length = 0 ; memset ( & ( s -> s3 -> rbuf ) , 0 , sizeof ( SSL3_BUFFER ) ) ; memset ( & ( s -> s3 -> rrec ) , 0 , sizeof ( SSL3_RECORD ) ) ; if ( ! ssl3_setup_buffers ( s ) ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; OPENSSL_free ( rdata ) ; pitem_free ( item ) ; return ( 0 ) ; } if ( pqueue_insert ( queue -> q , item ) == NULL ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; OPENSSL_free ( rdata ) ; pitem_free ( item ) ; return ( 0 ) ; } return ( 1 ) ; }
","<S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
",openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f,CVE-2015-0206,https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f,2015-01-09T02:59Z,<S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug>
2063,CWE-119,"static int tiffcp ( TIFF * in , TIFF * out ) { uint16 bitspersample , samplesperpixel = 1 ; uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ; copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24 ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV ) ; else if ( input_compression == COMPRESSION_JPEG && samplesperpixel == 3 ) { TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_RGB ) ; } else CopyTag ( TIFFTAG_PHOTOMETRIC , 1 , TIFF_SHORT ) ; if ( fillorder != 0 ) TIFFSetField ( out , TIFFTAG_FILLORDER , fillorder ) ; else CopyTag ( TIFFTAG_FILLORDER , 1 , TIFF_SHORT ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; switch ( orientation ) { case ORIENTATION_BOTRIGHT : case ORIENTATION_RIGHTBOT : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>bottom-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_BOTLEFT ; case ORIENTATION_LEFTBOT : case ORIENTATION_BOTLEFT : break ; case ORIENTATION_TOPRIGHT : case ORIENTATION_RIGHTTOP : default : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>top-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_TOPLEFT ; case ORIENTATION_LEFTTOP : case ORIENTATION_TOPLEFT : break ; } TIFFSetField ( out , TIFFTAG_ORIENTATION , orientation ) ; if ( outtiled == - 1 ) outtiled = TIFFIsTiled ( in ) ; if ( outtiled ) { if ( tilewidth == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tilewidth ) ; if ( tilelength == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tilelength ) ; TIFFDefaultTileSize ( out , & tilewidth , & tilelength ) ; TIFFSetField ( out , TIFFTAG_TILEWIDTH , tilewidth ) ; TIFFSetField ( out , TIFFTAG_TILELENGTH , tilelength ) ; } else { if ( rowsperstrip == ( uint32 ) 0 ) { if ( ! TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ) { rowsperstrip = TIFFDefaultStripSize ( out , rowsperstrip ) ; } if ( rowsperstrip > length && rowsperstrip != ( uint32 ) - 1 ) rowsperstrip = length ; } else if ( rowsperstrip == ( uint32 ) - 1 ) rowsperstrip = length ; TIFFSetField ( out , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; } if ( config != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PLANARCONFIG , config ) ; else CopyField ( TIFFTAG_PLANARCONFIG , config ) ; if ( samplesperpixel <= 4 ) CopyTag ( TIFFTAG_TRANSFERFUNCTION , 4 , TIFF_SHORT ) ; CopyTag ( TIFFTAG_COLORMAP , 4 , TIFF_SHORT ) ; switch ( compression ) { case COMPRESSION_JPEG : TIFFSetField ( out , TIFFTAG_JPEGQUALITY , quality ) ; TIFFSetField ( out , TIFFTAG_JPEGCOLORMODE , jpegcolormode ) ; break ; case COMPRESSION_JBIG : CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; CopyTag ( TIFFTAG_FAXDCS , 1 , TIFF_ASCII ) ; break ; case COMPRESSION_LZW : case COMPRESSION_ADOBE_DEFLATE : case COMPRESSION_DEFLATE : case COMPRESSION_LZMA : if ( predictor != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PREDICTOR , predictor ) ; else CopyField ( TIFFTAG_PREDICTOR , predictor ) ; if ( preset != - 1 ) { if ( compression == COMPRESSION_ADOBE_DEFLATE || compression == COMPRESSION_DEFLATE ) TIFFSetField ( out , TIFFTAG_ZIPQUALITY , preset ) ; else if ( compression == COMPRESSION_LZMA ) TIFFSetField ( out , TIFFTAG_LZMAPRESET , preset ) ; } break ; case COMPRESSION_CCITTFAX3 : case COMPRESSION_CCITTFAX4 : if ( compression == COMPRESSION_CCITTFAX3 ) { if ( g3opts != ( uint32 ) - 1 ) TIFFSetField ( out , TIFFTAG_GROUP3OPTIONS , g3opts ) ; else CopyField ( TIFFTAG_GROUP3OPTIONS , g3opts ) ; } else CopyTag ( TIFFTAG_GROUP4OPTIONS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_BADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CLEANFAXDATA , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CONSECUTIVEBADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; break ; } { uint32 len32 ; void * * data ; if ( TIFFGetField ( in , TIFFTAG_ICCPROFILE , & len32 , & data ) ) TIFFSetField ( out , TIFFTAG_ICCPROFILE , len32 , data ) ; } { uint16 ninks ; const char * inknames ; if ( TIFFGetField ( in , TIFFTAG_NUMBEROFINKS , & ninks ) ) { TIFFSetField ( out , TIFFTAG_NUMBEROFINKS , ninks ) ; if ( TIFFGetField ( in , TIFFTAG_INKNAMES , & inknames ) ) { int inknameslen = strlen ( inknames ) + 1 ; const char * cp = inknames ; while ( ninks > 1 ) { cp = strchr ( cp , '\\0' ) ; cp ++ ; inknameslen += ( strlen ( cp ) + 1 ) ; ninks -- ; } TIFFSetField ( out , TIFFTAG_INKNAMES , inknameslen , inknames ) ; } } } { unsigned short pg0 , pg1 ; if ( pageInSeq == 1 ) { if ( pageNum < 0 ) { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; } else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } else { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) { if ( pageNum < 0 ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } } } for ( p = tags ; p < & tags [ NTAGS ] ; p ++ ) CopyTag ( p -> tag , p -> count , p -> type ) ; cf = pickCopyFunc ( in , out , bitspersample , samplesperpixel ) ; return ( cf ? ( * cf ) ( in , out , length , width , samplesperpixel ) : FALSE ) ; }
","<S2SV_ModStart> { uint16 bitspersample = 1
",vadz@libtiff/5c080298d59efa53264d7248bbe3a04660db6ef7,CVE-2017-5225,https://github.com/vadz/libtiff/commit/5c080298d59efa53264d7248bbe3a04660db6ef7,2017-01-12T11:59Z,"<S2SV_StartBug> uint16 bitspersample , samplesperpixel = 1 ; <S2SV_EndBug>"
1812,CWE-119,"static void set_rate_correction_factor ( VP9_COMP * cpi , double factor ) { if ( cpi -> common . frame_type == KEY_FRAME ) { cpi -> rc . key_frame_rate_correction_factor = factor ; } else { if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) && ! cpi -> rc . is_src_frame_alt_ref && ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) cpi -> rc . gf_rate_correction_factor = factor ; else cpi -> rc . rate_correction_factor = factor ; } }
","<S2SV_ModStart> factor ) { RATE_CONTROL * const rc = & cpi -> rc ; factor /= rcf_mult [ cpi -> rc . frame_size_selector ] ; factor = fclamp ( factor , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ; <S2SV_ModStart> KEY_FRAME ) { rc -> rate_correction_factors [ KF_STD ] = factor ; } else if ( cpi -> oxcf . pass == 2 ) { RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ; rc -> rate_correction_factors [ rf_lvl ] <S2SV_ModEnd> = factor ; <S2SV_ModStart> ) && ! rc -> <S2SV_ModEnd> is_src_frame_alt_ref && ! <S2SV_ModStart> is_src_frame_alt_ref && ! <S2SV_ModEnd> cpi -> use_svc <S2SV_ModStart> -> use_svc && ( <S2SV_ModStart> -> oxcf . rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rc -> rate_correction_factors [ GF_ARF_STD ] <S2SV_ModEnd> = factor ; <S2SV_ModStart> factor ; else rc -> rate_correction_factors [ INTER_NORMAL ] <S2SV_ModEnd> = factor ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> cpi -> rc . key_frame_rate_correction_factor = factor ; <S2SV_EndBug> <S2SV_StartBug> ! cpi -> rc . is_src_frame_alt_ref && <S2SV_EndBug> <S2SV_StartBug> ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) <S2SV_EndBug> <S2SV_StartBug> cpi -> rc . rate_correction_factor = factor ; <S2SV_EndBug>
1775,CWE-119,"static int test_candidate_kf ( struct twopass_rc * twopass , const FIRSTPASS_STATS * last_frame , const FIRSTPASS_STATS * this_frame , const FIRSTPASS_STATS * next_frame ) { int is_viable_kf = 0 ; if ( ( this_frame -> pcnt_second_ref < 0.10 ) && ( next_frame -> pcnt_second_ref < 0.10 ) && ( ( this_frame -> pcnt_inter < 0.05 ) || ( ( ( this_frame -> pcnt_inter - this_frame -> pcnt_neutral ) < 0.35 ) && ( ( this_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) < 2.5 ) && ( ( fabs ( last_frame -> coded_error - this_frame -> coded_error ) / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > 0.40 ) || ( fabs ( last_frame -> intra_error - this_frame -> intra_error ) / DOUBLE_DIVIDE_CHECK ( this_frame -> intra_error ) > 0.40 ) || ( ( next_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > 3.5 ) ) ) ) ) { int i ; const FIRSTPASS_STATS * start_pos = twopass -> stats_in ; FIRSTPASS_STATS local_next_frame = * next_frame ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double decay_accumulator = 1.0 ; for ( i = 0 ; i < 16 ; ++ i ) { double next_iiratio = ( IIKFACTOR1 * local_next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( local_next_frame . coded_error ) ) ; if ( next_iiratio > RMAX ) next_iiratio = RMAX ; if ( local_next_frame . pcnt_inter > 0.85 ) decay_accumulator *= local_next_frame . pcnt_inter ; else decay_accumulator *= ( 0.85 + local_next_frame . pcnt_inter ) / 2.0 ; boost_score += ( decay_accumulator * next_iiratio ) ; if ( ( local_next_frame . pcnt_inter < 0.05 ) || ( next_iiratio < 1.5 ) || ( ( ( local_next_frame . pcnt_inter - local_next_frame . pcnt_neutral ) < 0.20 ) && ( next_iiratio < 3.0 ) ) || ( ( boost_score - old_boost_score ) < 3.0 ) || ( local_next_frame . intra_error < 200 ) ) { break ; } old_boost_score = boost_score ; if ( EOF == input_stats ( twopass , & local_next_frame ) ) break ; } if ( boost_score > 30.0 && ( i > 3 ) ) { is_viable_kf = 1 ; } else { reset_fpf_position ( twopass , start_pos ) ; is_viable_kf = 0 ; } } return is_viable_kf ; }
","<S2SV_ModStart> int test_candidate_kf ( TWO_PASS <S2SV_ModEnd> * twopass , <S2SV_ModStart> = 0 ; double pcnt_intra = 1.0 - this_frame -> pcnt_inter ; double modified_pcnt_inter = this_frame -> pcnt_inter - this_frame -> pcnt_neutral ; <S2SV_ModStart> -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH <S2SV_ModEnd> ) && ( <S2SV_ModStart> -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH ) && ( ( this_frame -> pcnt_inter < VERY_LOW_INTER_THRESH ) || ( ( pcnt_intra > MIN_INTRA_LEVEL ) && ( pcnt_intra > ( INTRA_VS_INTER_THRESH * modified_pcnt_inter ) <S2SV_ModEnd> ) && ( <S2SV_ModStart> ) ) < KF_II_ERR_THRESHOLD <S2SV_ModEnd> ) && ( <S2SV_ModStart> coded_error ) > ERR_CHANGE_THRESHOLD <S2SV_ModEnd> ) || ( <S2SV_ModStart> intra_error ) > ERR_CHANGE_THRESHOLD <S2SV_ModEnd> ) || ( <S2SV_ModStart> ) ) > II_IMPROVEMENT_THRESHOLD <S2SV_ModEnd> ) ) ) <S2SV_ModStart> next_iiratio = ( BOOST_FACTOR <S2SV_ModEnd> * local_next_frame . <S2SV_ModStart> ( next_iiratio > KF_II_MAX ) next_iiratio = KF_II_MAX <S2SV_ModEnd> ; if (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static int test_candidate_kf ( struct twopass_rc * twopass , <S2SV_EndBug> <S2SV_StartBug> if ( ( this_frame -> pcnt_second_ref < 0.10 ) && <S2SV_EndBug> <S2SV_StartBug> ( next_frame -> pcnt_second_ref < 0.10 ) && <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) < 2.5 ) && <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > 0.40 ) || <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> intra_error ) > 0.40 ) || <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > 3.5 ) ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> double next_iiratio = ( IIKFACTOR1 * local_next_frame . intra_error / <S2SV_EndBug> <S2SV_StartBug> if ( next_iiratio > RMAX ) <S2SV_EndBug>"
971,CWE-416,"int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; dst
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug>"
3203,CWE-000,"static int sanity_check_raw_super ( struct f2fs_sb_info * sbi , struct buffer_head * bh ) { struct f2fs_super_block * raw_super = ( struct f2fs_super_block * ) ( bh -> b_data + F2FS_SUPER_OFFSET ) ; struct super_block * sb = sbi -> sb ; unsigned int blocksize ; if ( F2FS_SUPER_MAGIC != le32_to_cpu ( raw_super -> magic ) ) { f2fs_msg ( sb , KERN_INFO , ""Magic<S2SV_blank>Mismatch,<S2SV_blank>valid(0x%x)<S2SV_blank>-<S2SV_blank>read(0x%x)"" , F2FS_SUPER_MAGIC , le32_to_cpu ( raw_super -> magic ) ) ; return 1 ; } if ( F2FS_BLKSIZE != PAGE_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>page_cache_size<S2SV_blank>(%lu),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n"" , PAGE_SIZE ) ; return 1 ; } blocksize = 1 << le32_to_cpu ( raw_super -> log_blocksize ) ; if ( blocksize != F2FS_BLKSIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>blocksize<S2SV_blank>(%u),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n"" , blocksize ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_blocks_per_seg ) != 9 ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>blocks<S2SV_blank>per<S2SV_blank>segment<S2SV_blank>(%u)\\n"" , le32_to_cpu ( raw_super -> log_blocks_per_seg ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectorsize ) > F2FS_MAX_LOG_SECTOR_SIZE || le32_to_cpu ( raw_super -> log_sectorsize ) < F2FS_MIN_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>sectorsize<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectors_per_block ) + le32_to_cpu ( raw_super -> log_sectorsize ) != F2FS_MAX_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>sectors<S2SV_blank>per<S2SV_blank>block(%u)<S2SV_blank>log<S2SV_blank>sectorsize(%u)"" , le32_to_cpu ( raw_super -> log_sectors_per_block ) , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> node_ino ) != 1 || le32_to_cpu ( raw_super -> meta_ino ) != 2 || le32_to_cpu ( raw_super -> root_ino ) != 3 ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>Fs<S2SV_blank>Meta<S2SV_blank>Ino:<S2SV_blank>node(%u)<S2SV_blank>meta(%u)<S2SV_blank>root(%u)"" , le32_to_cpu ( raw_super -> node_ino ) , le32_to_cpu ( raw_super -> meta_ino ) , le32_to_cpu ( raw_super -> root_ino ) ) ; return 1 ; } if ( sanity_check_area_boundary ( sbi , bh ) ) return 1 ; return 0 ; }
","<S2SV_ModStart> } if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if (
",torvalds@linux/b9dd46188edc2f0d1f37328637860bb65a771124,CVE-2017-10662,https://github.com/torvalds/linux/commit/b9dd46188edc2f0d1f37328637860bb65a771124,2017-08-19T18:29Z,"<S2SV_StartBug> if ( sanity_check_area_boundary ( sbi , bh ) ) <S2SV_EndBug>"
2153,CWE-190,"static long mem_seek ( jas_stream_obj_t * obj , long offset , int origin ) { jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; long newpos ; JAS_DBGLOG ( 100 , ( ""mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\n"" , obj , offset , origin ) ) ; switch ( origin ) { case SEEK_SET : newpos = offset ; break ; case SEEK_END : newpos = m -> len_ - offset ; break ; case SEEK_CUR : newpos = m -> pos_ + offset ; break ; default : abort ( ) ; break ; } if ( newpos < 0 ) { return - 1 ; } m -> pos_ = newpos ; return m -> pos_ ; }
","<S2SV_ModStart> ) obj ; size_t <S2SV_ModEnd> newpos ; JAS_DBGLOG
",mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,CVE-2016-9262,https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,2017-03-23T18:59Z,<S2SV_StartBug> long newpos ; <S2SV_EndBug>
1700,CWE-119,"static void encode_rd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; SPEED_FEATURES * const sf = & cpi -> sf ; int mi_col ; vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; mi_col += MI_BLOCK_SIZE ) { int dummy_rate ; int64_t dummy_dist ; BLOCK_SIZE i ; MACROBLOCK * x = & cpi -> mb ; if ( sf -> adaptive_pred_interp_filter ) { for ( i = BLOCK_4X4 ; i < BLOCK_8X8 ; ++ i ) { const int num_4x4_w = num_4x4_blocks_wide_lookup [ i ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ i ] ; const int num_4x4_blk = MAX ( 4 , num_4x4_w * num_4x4_h ) ; for ( x -> sb_index = 0 ; x -> sb_index < 4 ; ++ x -> sb_index ) for ( x -> mb_index = 0 ; x -> mb_index < 4 ; ++ x -> mb_index ) for ( x -> b_index = 0 ; x -> b_index < 16 / num_4x4_blk ; ++ x -> b_index ) get_block_context ( x , i ) -> pred_interp_filter = SWITCHABLE ; } } vp9_zero ( cpi -> mb . pred_mv ) ; if ( ( sf -> partition_search_type == SEARCH_PARTITION && sf -> use_lastframe_partitioning ) || sf -> partition_search_type == FIXED_PARTITION || sf -> partition_search_type == VAR_BASED_PARTITION || sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) { const int idx_str = cm -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ; cpi -> mb . source_variance = UINT_MAX ; if ( sf -> partition_search_type == FIXED_PARTITION ) { set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , sf -> always_this_block_size ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 ) ; } else if ( sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) { BLOCK_SIZE bsize ; set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; bsize = get_rd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ; set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 ) ; } else if ( sf -> partition_search_type == VAR_BASED_PARTITION ) { choose_partitioning ( cpi , tile , mi_row , mi_col ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 ) ; } else { if ( ( cm -> current_video_frame % sf -> last_partitioning_redo_frequency ) == 0 || cm -> prev_mi == 0 || cm -> show_frame == 0 || cm -> frame_type == KEY_FRAME || cpi -> rc . is_src_frame_alt_ref || ( ( sf -> use_lastframe_partitioning == LAST_FRAME_PARTITION_LOW_MOTION ) && sb_has_motion ( cm , prev_mi_8x8 ) ) ) { if ( sf -> auto_min_max_partition_size ) { set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile , mi_row , mi_col , & sf -> min_partition_size , & sf -> max_partition_size ) ; } rd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; } else { if ( sf -> constrain_copy_partition && sb_has_motion ( cm , prev_mi_8x8 ) ) constrain_copy_partitioning ( cpi , tile , mi_8x8 , prev_mi_8x8 , mi_row , mi_col , BLOCK_16X16 ) ; else copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 ) ; } } } else { if ( sf -> auto_min_max_partition_size ) { set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile , mi_row , mi_col , & sf -> min_partition_size , & sf -> max_partition_size ) ; } rd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; } } }
","<S2SV_ModStart> * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> TileInfo * const <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; SPEED_FEATURES * const sf = & cpi -> sf ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( <S2SV_ModEnd> xd -> left_context <S2SV_ModStart> xd -> left_context ) ) ; memset ( xd -> left_seg_context <S2SV_ModStart> ( xd -> left_seg_context <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( mi_col = tile_info <S2SV_ModEnd> -> mi_col_start ; <S2SV_ModStart> ; mi_col < tile_info <S2SV_ModEnd> -> mi_col_end ; <S2SV_ModStart> MI_BLOCK_SIZE ) { const struct segmentation * const seg = & cm -> seg ; <S2SV_ModStart> int64_t dummy_dist ; RD_COST dummy_rdc ; int i ; int seg_skip = 0 ; const int idx_str = cm -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi = cm -> mi_grid_visible + idx_str <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ; i < 64 <S2SV_ModEnd> ; ++ i <S2SV_ModStart> ++ i ) td -> leaf_tree [ i ] . pred_interp_filter = SWITCHABLE ; for ( i = 0 ; i < 64 ; ++ i ) { td -> pc_tree [ i ] . vertical [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . vertical [ 1 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 1 ] . pred_interp_filter = SWITCHABLE ; } } vp9_zero ( x -> pred_mv ) ; td -> pc_root -> index = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; } x -> source_variance = UINT_MAX <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> sf -> partition_search_type <S2SV_ModStart> == FIXED_PARTITION || seg_skip ) { const BLOCK_SIZE bsize = seg_skip ? BLOCK_64X64 : sf -> always_this_block_size ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( cpi -> partition_search_skippable_frame ) { BLOCK_SIZE bsize ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; bsize = get_rd_var_based_fixed_partition ( cpi , x , mi_row , mi_col ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( <S2SV_ModStart> partition_search_type == VAR_BASED_PARTITION && cm -> frame_type != KEY_FRAME ) { choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else { if ( sf -> auto_min_max_partition_size <S2SV_ModEnd> ) { set_offsets <S2SV_ModStart> ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile_info , xd , mi_row , mi_col , & x -> min_partition_size , & x -> max_partition_size ) ; } rd_pick_partition ( cpi , td , tile_data <S2SV_ModEnd> , tp , <S2SV_ModStart> BLOCK_64X64 , & dummy_rdc , INT64_MAX , td -> pc_root <S2SV_ModEnd> ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void encode_rd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; <S2SV_EndBug> <S2SV_StartBug> int dummy_rate ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = BLOCK_4X4 ; i < BLOCK_8X8 ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( sf -> partition_search_type == SEARCH_PARTITION && <S2SV_EndBug> <S2SV_StartBug> sf -> partition_search_type == VAR_BASED_PARTITION || <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> & dummy_rate , & dummy_dist , 1 ) ; <S2SV_EndBug>"
8330,CWE-476,"static const char * escape_xml ( const char * text ) { static char * escaped ; static size_t escaped_size ; char * out ; size_t len ; for ( out = escaped , len = 0 ; * text ; ++ len , ++ out , ++ text ) { if ( ( len + 8 ) > escaped_size ) { char * bigger_escaped ; escaped_size += 128 ; bigger_escaped = realloc ( escaped , escaped_size ) ; if ( ! bigger_escaped ) { free ( escaped ) ; escaped = NULL ; escaped_size = 0 ; return "">>><S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank><<<"" ; } out = bigger_escaped + len ; escaped = bigger_escaped ; } switch ( * text ) { case '&' : strcpy ( out , ""&amp;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '<' : strcpy ( out , ""&lt;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '>' : strcpy ( out , ""&gt;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; default : * out = * text ; break ; } } * out = '\\x0' ; return escaped ; }
","<S2SV_ModStart> size_t len ; if ( ! strlen ( text ) ) return ""empty<S2SV_blank>string"" ;
",libexif@exif/f6334d9d32437ef13dc902f0a88a2be0063d9d1c,CVE-2021-27815,https://github.com/libexif/exif/commit/f6334d9d32437ef13dc902f0a88a2be0063d9d1c,2021-04-14T14:15Z,"<S2SV_StartBug> for ( out = escaped , len = 0 ; * text ; ++ len , ++ out , ++ text ) { <S2SV_EndBug>"
300,CWE-125,"static void atmarp_print ( netdissect_options * ndo , const u_char * bp , u_int length , u_int caplen ) { const struct atmarp_pkthdr * ap ; u_short pro , hrd , op ; ap = ( const struct atmarp_pkthdr * ) bp ; ND_TCHECK ( * ap ) ; hrd = ATMHRD ( ap ) ; pro = ATMPRO ( ap ) ; op = ATMOP ( ap ) ; if ( ! ND_TTEST2 ( * aar_tpa ( ap ) , ATMTPROTO_LEN ( ap ) ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; return ; } if ( ! ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ; } if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || ATMSPROTO_LEN ( ap ) != 4 || ATMTPROTO_LEN ( ap ) != 4 || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""%s,<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u/%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , ATMSPROTO_LEN ( ap ) , ATMTPROTO_LEN ( ap ) ) ) ; if ( ! ndo -> ndo_vflag ) { goto out ; } } ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>"" , ndo -> ndo_vflag ? "",<S2SV_blank>"" : """" , tok2str ( arpop_values , ""Unknown<S2SV_blank>(%u)"" , op ) ) ) ; switch ( op ) { case ARPOP_REQUEST : ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ; if ( ATMTHRD_LEN ( ap ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; break ; case ARPOP_REPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>"" ) ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREPLY : atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; break ; case ARPOP_NAK : ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; break ; default : ND_DEFAULTPRINT ( ( const u_char * ) ap , caplen ) ; return ; } out : ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> ( ndo , ""who-has<S2SV_blank>"" ) ) ; atmarp_tpaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> case ARPOP_REPLY : atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>"" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , ""at<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( ndo , ""for<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break
",the-tcpdump-group@tcpdump/13ab8d18617d616c7d343530f8a842e7143fb5cc,CVE-2017-13013,https://github.com/the-tcpdump-group/tcpdump/commit/13ab8d18617d616c7d343530f8a842e7143fb5cc,2017-09-14T06:29Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug>"
1846,CWE-119,"static void joint_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bsize , int_mv * frame_mv , int mi_row , int mi_col , int_mv single_newmv [ MAX_REF_FRAMES ] , int * rate_mv ) { const int pw = 4 * num_4x4_blocks_wide_lookup [ bsize ] ; const int ph = 4 * num_4x4_blocks_high_lookup [ bsize ] ; MACROBLOCKD * xd = & x -> e_mbd ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; const int refs [ 2 ] = { mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] } ; int_mv ref_mv [ 2 ] ; int ite , ref ; uint8_t * second_pred = vpx_memalign ( 16 , pw * ph * sizeof ( uint8_t ) ) ; const InterpKernel * kernel = vp9_get_interp_kernel ( mbmi -> interp_filter ) ; struct buf_2d backup_yv12 [ 2 ] [ MAX_MB_PLANE ] ; struct buf_2d scaled_first_yv12 = xd -> plane [ 0 ] . pre [ 0 ] ; int last_besterr [ 2 ] = { INT_MAX , INT_MAX } ; const YV12_BUFFER_CONFIG * const scaled_ref_frame [ 2 ] = { vp9_get_scaled_ref_frame ( cpi , mbmi -> ref_frame [ 0 ] ) , vp9_get_scaled_ref_frame ( cpi , mbmi -> ref_frame [ 1 ] ) } ; for ( ref = 0 ; ref < 2 ; ++ ref ) { ref_mv [ ref ] = mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] ; if ( scaled_ref_frame [ ref ] ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) backup_yv12 [ ref ] [ i ] = xd -> plane [ i ] . pre [ ref ] ; vp9_setup_pre_planes ( xd , ref , scaled_ref_frame [ ref ] , mi_row , mi_col , NULL ) ; } frame_mv [ refs [ ref ] ] . as_int = single_newmv [ refs [ ref ] ] . as_int ; } for ( ite = 0 ; ite < 4 ; ite ++ ) { struct buf_2d ref_yv12 [ 2 ] ; int bestsme = INT_MAX ; int sadpb = x -> sadperbit16 ; int_mv tmp_mv ; int search_range = 3 ; int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; int tmp_row_max = x -> mv_row_max ; int id = ite % 2 ; ref_yv12 [ 0 ] = xd -> plane [ 0 ] . pre [ 0 ] ; ref_yv12 [ 1 ] = xd -> plane [ 0 ] . pre [ 1 ] ; vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & xd -> block_refs [ ! id ] -> sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; if ( id ) xd -> plane [ 0 ] . pre [ 0 ] = ref_yv12 [ id ] ; vp9_set_mv_search_range ( x , & ref_mv [ id ] . as_mv ) ; tmp_mv . as_int = frame_mv [ refs [ id ] ] . as_int ; tmp_mv . as_mv . col >>= 3 ; tmp_mv . as_mv . row >>= 3 ; bestsme = vp9_refining_search_8p_c ( x , & tmp_mv . as_mv , sadpb , search_range , & cpi -> fn_ptr [ bsize ] , x -> nmvjointcost , x -> mvcost , & ref_mv [ id ] . as_mv , second_pred , pw , ph ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_av_var ( x , & tmp_mv . as_mv , & ref_mv [ id ] . as_mv , second_pred , & cpi -> fn_ptr [ bsize ] , 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) { int dis ; unsigned int sse ; bestsme = cpi -> find_fractional_mv_step_comp ( x , & tmp_mv . as_mv , & ref_mv [ id ] . as_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , 0 , cpi -> sf . subpel_iters_per_step , x -> nmvjointcost , x -> mvcost , & dis , & sse , second_pred , pw , ph ) ; } if ( id ) xd -> plane [ 0 ] . pre [ 0 ] = scaled_first_yv12 ; if ( bestsme < last_besterr [ id ] ) { frame_mv [ refs [ id ] ] . as_int = tmp_mv . as_int ; last_besterr [ id ] = bestsme ; } else { break ; } } * rate_mv = 0 ; for ( ref = 0 ; ref < 2 ; ++ ref ) { if ( scaled_ref_frame [ ref ] ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ ref ] = backup_yv12 [ ref ] [ i ] ; } * rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ ref ] ] . as_mv , & mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; } vpx_free ( second_pred ) ; }
","<S2SV_ModStart> ) { const VP9_COMMON * const cm = & cpi -> common ; const <S2SV_ModStart> , ref ; <S2SV_ModEnd> const InterpKernel * <S2SV_ModStart> * kernel = vp9_filter_kernels [ <S2SV_ModEnd> mbmi -> interp_filter <S2SV_ModStart> mbmi -> interp_filter ] ; struct scale_factors sf <S2SV_ModEnd> ; struct buf_2d <S2SV_ModStart> MAX_MB_PLANE ] ; <S2SV_ModEnd> int last_besterr [ <S2SV_ModStart> ) } ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , second_pred_alloc_16 [ 64 * 64 ] ) ; uint8_t * second_pred ; # else DECLARE_ALIGNED ( 16 , uint8_t , second_pred [ 64 * 64 ] ) ; # endif <S2SV_ModStart> ref ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> as_int ; } # if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height ) ; # endif <S2SV_ModStart> -> sadperbit16 ; MV <S2SV_ModEnd> tmp_mv ; int <S2SV_ModStart> 1 ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { second_pred = CONVERT_TO_BYTEPTR ( second_pred_alloc_16 ) ; vp9_highbd_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE , xd -> bd ) ; } else { second_pred = ( uint8_t * ) second_pred_alloc_16 ; <S2SV_ModStart> as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; } # else vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; # endif if ( id ) xd -> <S2SV_ModEnd> plane [ 0 <S2SV_ModStart> ) ; tmp_mv <S2SV_ModEnd> = frame_mv [ <S2SV_ModStart> ] ] . as_mv ; tmp_mv <S2SV_ModEnd> . col >>= <S2SV_ModStart> ; tmp_mv . <S2SV_ModEnd> row >>= 3 <S2SV_ModStart> , & tmp_mv , sadpb , search_range , & cpi -> fn_ptr [ bsize ] , & ref_mv [ id ] <S2SV_ModStart> . as_mv , second_pred <S2SV_ModEnd> ) ; if <S2SV_ModStart> , & tmp_mv <S2SV_ModEnd> , & ref_mv <S2SV_ModStart> = cpi -> find_fractional_mv_step <S2SV_ModEnd> ( x , <S2SV_ModStart> , & tmp_mv , & ref_mv [ id ] <S2SV_ModStart> . as_mv , <S2SV_ModEnd> cpi -> common <S2SV_ModStart> -> sf . mv . subpel_iters_per_step , NULL , <S2SV_ModEnd> x -> nmvjointcost <S2SV_ModStart> 0 ] = ref_yv12 [ 0 ] <S2SV_ModEnd> ; if ( <S2SV_ModStart> ] ] . as_mv = tmp_mv <S2SV_ModEnd> ; last_besterr [ <S2SV_ModStart> as_mv , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> const int pw = 4 * num_4x4_blocks_wide_lookup [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> uint8_t * second_pred = vpx_memalign ( 16 , pw * ph * sizeof ( uint8_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mbmi -> interp_filter ) ; <S2SV_EndBug> <S2SV_StartBug> struct buf_2d scaled_first_yv12 = xd -> plane [ 0 ] . pre [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> for ( ref = 0 ; ref < 2 ; ++ ref ) { <S2SV_EndBug> <S2SV_StartBug> ref_mv [ ref ] = mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> for ( ite = 0 ; ite < 4 ; ite ++ ) { <S2SV_EndBug> <S2SV_StartBug> int_mv tmp_mv ; <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , <S2SV_EndBug> <S2SV_StartBug> & xd -> block_refs [ ! id ] -> sf , <S2SV_EndBug> <S2SV_StartBug> tmp_mv . as_int = frame_mv [ refs [ id ] ] . as_int ; <S2SV_EndBug> <S2SV_StartBug> tmp_mv . as_mv . row >>= 3 ; <S2SV_EndBug> <S2SV_StartBug> bestsme = vp9_refining_search_8p_c ( x , & tmp_mv . as_mv , sadpb , <S2SV_EndBug> <S2SV_StartBug> bestsme = vp9_get_mvpred_av_var ( x , & tmp_mv . as_mv , & ref_mv [ id ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> bestsme = cpi -> find_fractional_mv_step_comp ( <S2SV_EndBug> <S2SV_StartBug> x , & tmp_mv . as_mv , <S2SV_EndBug> <S2SV_StartBug> & ref_mv [ id ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> 0 , cpi -> sf . subpel_iters_per_step , <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . pre [ 0 ] = scaled_first_yv12 ; <S2SV_EndBug> <S2SV_StartBug> frame_mv [ refs [ id ] ] . as_int = tmp_mv . as_int ; <S2SV_EndBug> <S2SV_StartBug> & mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> vpx_free ( second_pred ) ; <S2SV_EndBug>"
6718,CWE-444,"static ngx_int_t ngx_http_lua_adjust_subrequest ( ngx_http_request_t * sr , ngx_uint_t method , int always_forward_body , ngx_http_request_body_t * body , unsigned vars_action , ngx_array_t * extra_vars ) { ngx_http_request_t * r ; ngx_int_t rc ; ngx_http_core_main_conf_t * cmcf ; size_t size ; r = sr -> parent ; sr -> header_in = r -> header_in ; if ( body ) { sr -> request_body = body ; rc = ngx_http_lua_set_content_length_header ( sr , body -> buf ? ngx_buf_size ( body -> buf ) : 0 ) ; if ( rc != NGX_OK ) { return NGX_ERROR ; } } else if ( ! always_forward_body && method != NGX_HTTP_PUT && method != NGX_HTTP_POST && r -> headers_in . content_length_n > 0 ) { rc = ngx_http_lua_set_content_length_header ( sr , 0 ) ; if ( rc != NGX_OK ) { return NGX_ERROR ; } # if 1 sr -> request_body = NULL ; # endif } else { if ( ngx_http_lua_copy_request_headers ( sr , r ) != NGX_OK ) { return NGX_ERROR ; } if ( sr -> request_body ) { if ( sr -> request_body -> temp_file ) { if ( ngx_http_lua_copy_in_file_request_body ( sr ) != NGX_OK ) { return NGX_ERROR ; } } } } sr -> method = method ; switch ( method ) { case NGX_HTTP_GET : sr -> method_name = ngx_http_lua_get_method ; break ; case NGX_HTTP_POST : sr -> method_name = ngx_http_lua_post_method ; break ; case NGX_HTTP_PUT : sr -> method_name = ngx_http_lua_put_method ; break ; case NGX_HTTP_HEAD : sr -> method_name = ngx_http_lua_head_method ; break ; case NGX_HTTP_DELETE : sr -> method_name = ngx_http_lua_delete_method ; break ; case NGX_HTTP_OPTIONS : sr -> method_name = ngx_http_lua_options_method ; break ; case NGX_HTTP_MKCOL : sr -> method_name = ngx_http_lua_mkcol_method ; break ; case NGX_HTTP_COPY : sr -> method_name = ngx_http_lua_copy_method ; break ; case NGX_HTTP_MOVE : sr -> method_name = ngx_http_lua_move_method ; break ; case NGX_HTTP_PROPFIND : sr -> method_name = ngx_http_lua_propfind_method ; break ; case NGX_HTTP_PROPPATCH : sr -> method_name = ngx_http_lua_proppatch_method ; break ; case NGX_HTTP_LOCK : sr -> method_name = ngx_http_lua_lock_method ; break ; case NGX_HTTP_UNLOCK : sr -> method_name = ngx_http_lua_unlock_method ; break ; case NGX_HTTP_PATCH : sr -> method_name = ngx_http_lua_patch_method ; break ; case NGX_HTTP_TRACE : sr -> method_name = ngx_http_lua_trace_method ; break ; default : ngx_log_error ( NGX_LOG_ERR , r -> connection -> log , 0 , ""unsupported<S2SV_blank>HTTP<S2SV_blank>method:<S2SV_blank>%u"" , ( unsigned ) method ) ; return NGX_ERROR ; } if ( ! ( vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS ) ) { cmcf = ngx_http_get_module_main_conf ( sr , ngx_http_core_module ) ; size = cmcf -> variables . nelts * sizeof ( ngx_http_variable_value_t ) ; if ( vars_action & NGX_HTTP_LUA_COPY_ALL_VARS ) { sr -> variables = ngx_palloc ( sr -> pool , size ) ; if ( sr -> variables == NULL ) { return NGX_ERROR ; } ngx_memcpy ( sr -> variables , r -> variables , size ) ; } else { sr -> variables = ngx_pcalloc ( sr -> pool , size ) ; if ( sr -> variables == NULL ) { return NGX_ERROR ; } } } return ngx_http_lua_subrequest_add_extra_vars ( sr , extra_vars ) ; }
","<S2SV_ModStart> * r ; <S2SV_ModEnd> ngx_http_core_main_conf_t * cmcf <S2SV_ModStart> * cmcf ; int pr_not_chunked = 0 ; <S2SV_ModStart> = body ; <S2SV_ModEnd> } else if <S2SV_ModStart> 0 ) { sr -> request_body = NULL ; } else { if ( ! r -> headers_in . chunked ) { pr_not_chunked = 1 ; } if ( sr -> request_body && sr -> request_body -> temp_file ) { if ( ngx_http_lua_copy_in_file_request_body ( sr ) <S2SV_ModEnd> != NGX_OK ) <S2SV_ModStart> NGX_ERROR ; } } } <S2SV_ModEnd> if ( ngx_http_lua_copy_request_headers <S2SV_ModStart> sr , r , pr_not_chunked <S2SV_ModStart> return NGX_ERROR ; <S2SV_ModEnd> } sr ->
",openresty@lua-nginx-module/9ab38e8ee35fc08a57636b1b6190dca70b0076fa,CVE-2020-11724,https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa,2020-04-12T21:15Z,"<S2SV_StartBug> ngx_int_t rc ; <S2SV_EndBug> <S2SV_StartBug> size_t size ; <S2SV_EndBug> <S2SV_StartBug> rc = ngx_http_lua_set_content_length_header ( sr , <S2SV_EndBug> <S2SV_StartBug> rc = ngx_http_lua_set_content_length_header ( sr , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> # if 1 <S2SV_EndBug> <S2SV_StartBug> if ( ngx_http_lua_copy_request_headers ( sr , r ) != NGX_OK ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
990,CWE-284,"static int a2dp_command ( struct a2dp_stream_common * common , char cmd ) { char ack ; DEBUG ( ""A2DP<S2SV_blank>COMMAND<S2SV_blank>%s"" , dump_a2dp_ctrl_event ( cmd ) ) ; if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 ) { ERROR ( ""cmd<S2SV_blank>failed<S2SV_blank>(%s)"" , strerror ( errno ) ) ; skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } if ( a2dp_ctrl_receive ( common , & ack , 1 ) < 0 ) return - 1 ; DEBUG ( ""A2DP<S2SV_blank>COMMAND<S2SV_blank>%s<S2SV_blank>DONE<S2SV_blank>STATUS<S2SV_blank>%d"" , dump_a2dp_ctrl_event ( cmd ) , ack ) ; if ( ack == A2DP_CTRL_ACK_INCALL_FAILURE ) return ack ; if ( ack != A2DP_CTRL_ACK_SUCCESS ) return - 1 ; return 0 ; }
","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1 , MSG_NOSIGNAL )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 ) <S2SV_EndBug>"
3665,CWE-125,"static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; if ( g -> sect <= 0 || g -> head <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ; if ( type ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - EINTR ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = ""user<S2SV_blank>format"" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldStretch ; if ( lock_fdc ( drive ) ) return - EINTR ; if ( cmd != FDDEFPRM ) { if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) return - EINTR ; } oldStretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == FDDEFPRM ) DRS -> keep_data = - 1 ; else DRS -> keep_data = 1 ; if ( DRS -> maxblock > user_params [ drive ] . sect || DRS -> maxtrack || ( ( user_params [ drive ] . sect ^ oldStretch ) & ( FD_SWAPSIDES | FD_SECTBASEMASK ) ) ) invalidate_drive ( bdev ) ; else process_fd_request ( ) ; } return 0 ; }
","<S2SV_ModStart> ; if ( ( int ) <S2SV_ModStart> <= 0 || ( int ) <S2SV_ModStart> g -> head <= 0 || ( int ) ( g -> sect * g -> head )
",torvalds@linux/da99466ac243f15fbba65bd261bfc75ffa1532b6,CVE-2019-14283,https://github.com/torvalds/linux/commit/da99466ac243f15fbba65bd261bfc75ffa1532b6,2019-07-26T13:15Z,<S2SV_StartBug> if ( g -> sect <= 0 || <S2SV_EndBug> <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug>
1947,CWE-119,"static vpx_codec_err_t set_encoder_config ( VP9_CONFIG * oxcf , const vpx_codec_enc_cfg_t * cfg , const struct vp9_extracfg * extra_cfg ) { oxcf -> profile = cfg -> g_profile ; oxcf -> width = cfg -> g_w ; oxcf -> height = cfg -> g_h ; oxcf -> bit_depth = extra_cfg -> bit_depth ; oxcf -> framerate = ( double ) cfg -> g_timebase . den / cfg -> g_timebase . num ; if ( oxcf -> framerate > 180 ) oxcf -> framerate = 30 ; switch ( cfg -> g_pass ) { case VPX_RC_ONE_PASS : oxcf -> mode = MODE_GOODQUALITY ; break ; case VPX_RC_FIRST_PASS : oxcf -> mode = MODE_FIRSTPASS ; break ; case VPX_RC_LAST_PASS : oxcf -> mode = MODE_SECONDPASS_BEST ; break ; } oxcf -> lag_in_frames = cfg -> g_pass == VPX_RC_FIRST_PASS ? 0 : cfg -> g_lag_in_frames ; oxcf -> end_usage = USAGE_LOCAL_FILE_PLAYBACK ; if ( cfg -> rc_end_usage == VPX_CQ ) oxcf -> end_usage = USAGE_CONSTRAINED_QUALITY ; else if ( cfg -> rc_end_usage == VPX_Q ) oxcf -> end_usage = USAGE_CONSTANT_QUALITY ; else if ( cfg -> rc_end_usage == VPX_CBR ) oxcf -> end_usage = USAGE_STREAM_FROM_SERVER ; oxcf -> target_bandwidth = cfg -> rc_target_bitrate ; oxcf -> rc_max_intra_bitrate_pct = extra_cfg -> rc_max_intra_bitrate_pct ; oxcf -> best_allowed_q = q_trans [ cfg -> rc_min_quantizer ] ; oxcf -> worst_allowed_q = q_trans [ cfg -> rc_max_quantizer ] ; oxcf -> cq_level = q_trans [ extra_cfg -> cq_level ] ; oxcf -> fixed_q = - 1 ; oxcf -> under_shoot_pct = cfg -> rc_undershoot_pct ; oxcf -> over_shoot_pct = cfg -> rc_overshoot_pct ; oxcf -> maximum_buffer_size = cfg -> rc_buf_sz ; oxcf -> starting_buffer_level = cfg -> rc_buf_initial_sz ; oxcf -> optimal_buffer_level = cfg -> rc_buf_optimal_sz ; oxcf -> drop_frames_water_mark = cfg -> rc_dropframe_thresh ; oxcf -> two_pass_vbrbias = cfg -> rc_2pass_vbr_bias_pct ; oxcf -> two_pass_vbrmin_section = cfg -> rc_2pass_vbr_minsection_pct ; oxcf -> two_pass_vbrmax_section = cfg -> rc_2pass_vbr_maxsection_pct ; oxcf -> auto_key = cfg -> kf_mode == VPX_KF_AUTO && cfg -> kf_min_dist != cfg -> kf_max_dist ; oxcf -> key_freq = cfg -> kf_max_dist ; oxcf -> cpu_used = extra_cfg -> cpu_used ; oxcf -> encode_breakout = extra_cfg -> static_thresh ; oxcf -> play_alternate = extra_cfg -> enable_auto_alt_ref ; oxcf -> noise_sensitivity = extra_cfg -> noise_sensitivity ; oxcf -> sharpness = extra_cfg -> sharpness ; oxcf -> two_pass_stats_in = cfg -> rc_twopass_stats_in ; oxcf -> output_pkt_list = extra_cfg -> pkt_list ; oxcf -> arnr_max_frames = extra_cfg -> arnr_max_frames ; oxcf -> arnr_strength = extra_cfg -> arnr_strength ; oxcf -> arnr_type = extra_cfg -> arnr_type ; oxcf -> tuning = extra_cfg -> tuning ; oxcf -> tile_columns = extra_cfg -> tile_columns ; oxcf -> tile_rows = extra_cfg -> tile_rows ; oxcf -> lossless = extra_cfg -> lossless ; oxcf -> error_resilient_mode = cfg -> g_error_resilient ; oxcf -> frame_parallel_decoding_mode = extra_cfg -> frame_parallel_decoding_mode ; oxcf -> aq_mode = extra_cfg -> aq_mode ; oxcf -> frame_periodic_boost = extra_cfg -> frame_periodic_boost ; oxcf -> ss_number_layers = cfg -> ss_number_layers ; if ( oxcf -> ss_number_layers > 1 ) { vp9_copy ( oxcf -> ss_target_bitrate , cfg -> ss_target_bitrate ) ; } else if ( oxcf -> ss_number_layers == 1 ) { oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; } oxcf -> ts_number_layers = cfg -> ts_number_layers ; if ( oxcf -> ts_number_layers > 1 ) { vp9_copy ( oxcf -> ts_target_bitrate , cfg -> ts_target_bitrate ) ; vp9_copy ( oxcf -> ts_rate_decimator , cfg -> ts_rate_decimator ) ; } else if ( oxcf -> ts_number_layers == 1 ) { oxcf -> ts_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; oxcf -> ts_rate_decimator [ 0 ] = 1 ; } return VPX_CODEC_OK ; }
","<S2SV_ModStart> vpx_codec_err_t set_encoder_config ( VP9EncoderConfig <S2SV_ModEnd> * oxcf , <S2SV_ModStart> extra_cfg ) { const int is_vbr = cfg -> rc_end_usage == VPX_VBR ; int sl , tl ; <S2SV_ModStart> ; oxcf -> max_threads = ( int ) cfg -> g_threads ; oxcf -> <S2SV_ModStart> -> bit_depth = cfg -> g_bit_depth ; oxcf -> input_bit_depth = cfg -> g_input_bit_depth ; oxcf -> init_framerate <S2SV_ModEnd> = ( double <S2SV_ModStart> ( oxcf -> init_framerate <S2SV_ModEnd> > 180 ) <S2SV_ModStart> ) oxcf -> init_framerate = 30 ; oxcf -> mode = GOOD <S2SV_ModEnd> ; switch ( <S2SV_ModStart> : oxcf -> pass = 0 <S2SV_ModEnd> ; break ; <S2SV_ModStart> : oxcf -> pass = 1 <S2SV_ModEnd> ; break ; <S2SV_ModStart> : oxcf -> pass = 2 <S2SV_ModEnd> ; break ; <S2SV_ModStart> ; oxcf -> rc_mode = <S2SV_ModEnd> cfg -> rc_end_usage <S2SV_ModStart> cfg -> rc_end_usage <S2SV_ModEnd> ; oxcf -> <S2SV_ModStart> -> target_bandwidth = 1000 * <S2SV_ModStart> ; oxcf -> rc_max_inter_bitrate_pct = extra_cfg -> rc_max_inter_bitrate_pct ; oxcf -> gf_cbr_boost_pct = extra_cfg -> gf_cbr_boost_pct ; oxcf -> best_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( <S2SV_ModEnd> cfg -> rc_min_quantizer <S2SV_ModStart> cfg -> rc_min_quantizer ) <S2SV_ModEnd> ; oxcf -> <S2SV_ModStart> -> worst_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( <S2SV_ModEnd> cfg -> rc_max_quantizer <S2SV_ModStart> cfg -> rc_max_quantizer ) <S2SV_ModEnd> ; oxcf -> <S2SV_ModStart> -> cq_level = vp9_quantizer_to_qindex ( <S2SV_ModEnd> extra_cfg -> cq_level <S2SV_ModStart> extra_cfg -> cq_level ) <S2SV_ModEnd> ; oxcf -> <S2SV_ModStart> ; oxcf -> scaled_frame_width = cfg -> rc_scaled_width ; oxcf -> scaled_frame_height = cfg -> rc_scaled_height ; if ( cfg -> rc_resize_allowed == 1 ) { oxcf -> resize_mode = ( oxcf -> scaled_frame_width == 0 || oxcf -> scaled_frame_height == 0 ) ? RESIZE_DYNAMIC : RESIZE_FIXED ; } else { oxcf -> resize_mode = RESIZE_NONE ; } oxcf -> maximum_buffer_size_ms = is_vbr ? 240000 : <S2SV_ModEnd> cfg -> rc_buf_sz <S2SV_ModStart> ; oxcf -> starting_buffer_level_ms = is_vbr ? 60000 : <S2SV_ModEnd> cfg -> rc_buf_initial_sz <S2SV_ModStart> ; oxcf -> optimal_buffer_level_ms = is_vbr ? 60000 : <S2SV_ModEnd> cfg -> rc_buf_optimal_sz <S2SV_ModStart> ; oxcf -> speed = abs ( extra_cfg -> cpu_used ) <S2SV_ModEnd> ; oxcf -> <S2SV_ModStart> ; oxcf -> enable_auto_arf <S2SV_ModEnd> = extra_cfg -> <S2SV_ModStart> -> rc_twopass_stats_in ; # if CONFIG_FP_MB_STATS oxcf -> firstpass_mb_stats_in = cfg -> rc_firstpass_mb_stats_in ; # endif oxcf -> color_space = extra_cfg -> color_space <S2SV_ModEnd> ; oxcf -> <S2SV_ModStart> ; oxcf -> min_gf_interval = extra_cfg -> min_gf_interval ; oxcf -> max_gf_interval = extra_cfg -> max_gf_interval <S2SV_ModEnd> ; oxcf -> <S2SV_ModStart> ; oxcf -> content = extra_cfg -> content ; oxcf -> <S2SV_ModStart> ; oxcf -> <S2SV_ModEnd> error_resilient_mode = cfg <S2SV_ModStart> -> ss_number_layers ; oxcf -> ts_number_layers = cfg -> ts_number_layers ; oxcf -> temporal_layering_mode = ( enum vp9e_temporal_layering_mode ) cfg -> temporal_layering_mode ; for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ sl ] = cfg -> ss_enable_auto_alt_ref [ sl ] ; # endif for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { oxcf -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] = 1000 * cfg -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] ; } } if <S2SV_ModEnd> ( oxcf -> <S2SV_ModStart> oxcf -> ss_number_layers == 1 && oxcf -> pass != 0 ) { oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ 0 ] = extra_cfg -> enable_auto_alt_ref ; # endif } if ( oxcf -> ts_number_layers <S2SV_ModStart> 1 ) { for ( tl = 0 ; tl < VPX_TS_MAX_LAYERS ; ++ tl ) { oxcf -> ts_rate_decimator [ tl ] = cfg -> ts_rate_decimator [ tl ] ? cfg -> ts_rate_decimator [ tl ] : 1 ; } <S2SV_ModEnd> } else if <S2SV_ModStart> ( oxcf -> <S2SV_ModEnd> ts_number_layers == 1 <S2SV_ModStart> { oxcf -> <S2SV_ModEnd> ts_rate_decimator [ 0
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> VP9_CONFIG * oxcf , <S2SV_EndBug> <S2SV_StartBug> oxcf -> profile = cfg -> g_profile ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> width = cfg -> g_w ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> bit_depth = extra_cfg -> bit_depth ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> framerate > 180 ) <S2SV_EndBug> <S2SV_StartBug> oxcf -> framerate = 30 ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> mode = MODE_GOODQUALITY ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> mode = MODE_FIRSTPASS ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> mode = MODE_SECONDPASS_BEST ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> end_usage = USAGE_LOCAL_FILE_PLAYBACK ; <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> rc_end_usage == VPX_CQ ) <S2SV_EndBug> <S2SV_StartBug> oxcf -> target_bandwidth = cfg -> rc_target_bitrate ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> best_allowed_q = q_trans [ cfg -> rc_min_quantizer ] ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> worst_allowed_q = q_trans [ cfg -> rc_max_quantizer ] ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> cq_level = q_trans [ extra_cfg -> cq_level ] ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> maximum_buffer_size = cfg -> rc_buf_sz ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> starting_buffer_level = cfg -> rc_buf_initial_sz ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> optimal_buffer_level = cfg -> rc_buf_optimal_sz ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> cpu_used = extra_cfg -> cpu_used ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> play_alternate = extra_cfg -> enable_auto_alt_ref ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> output_pkt_list = extra_cfg -> pkt_list ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> arnr_type = extra_cfg -> arnr_type ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> tile_columns = extra_cfg -> tile_columns ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> lossless = extra_cfg -> lossless ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> ss_number_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( oxcf -> ss_target_bitrate , cfg -> ss_target_bitrate ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( oxcf -> ss_number_layers == 1 ) { <S2SV_EndBug> <S2SV_StartBug> oxcf -> ts_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; <S2SV_EndBug>"
4510,CWE-125,"node * Ta3Parser_ParseStringObject ( const char * s , PyObject * filename , grammar * g , int start , perrdetail * err_ret , int * flags ) { struct tok_state * tok ; int exec_input = start == file_input ; if ( initerr ( err_ret , filename ) < 0 ) return NULL ; if ( * flags & PyPARSE_IGNORE_COOKIE ) tok = Ta3Tokenizer_FromUTF8 ( s , exec_input ) ; else tok = Ta3Tokenizer_FromString ( s , exec_input ) ; if ( tok == NULL ) { err_ret -> error = PyErr_Occurred ( ) ? E_DECODE : E_NOMEM ; return NULL ; } # ifndef PGEN Py_INCREF ( err_ret -> filename ) ; tok -> filename = err_ret -> filename ; # endif return parsetok ( tok , g , start , err_ret , flags ) ; }
","<S2SV_ModStart> ; # endif if ( * flags & PyPARSE_ASYNC_ALWAYS ) tok -> async_always = 1 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> return parsetok ( tok , g , start , err_ret , flags ) ; <S2SV_EndBug>"
1378,CWE-119,"void vp8_copy_mem8x4_c ( unsigned char * src , int src_stride , unsigned char * dst , int dst_stride ) { int r ; for ( r = 0 ; r < 4 ; r ++ ) { # if ! ( CONFIG_FAST_UNALIGNED ) dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; dst [ 4 ] = src [ 4 ] ; dst [ 5 ] = src [ 5 ] ; dst [ 6 ] = src [ 6 ] ; dst [ 7 ] = src [ 7 ] ; # else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ; ( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ; # endif src += src_stride ; dst += dst_stride ; } }
","<S2SV_ModStart> ++ ) { memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> src += src_stride
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug>
3382,CWE-200,"void dump_global_data ( FILE * fp , data_t * data ) { # ifdef _WITH_VRRP_ char buf [ 64 ] ; # endif if ( ! data ) return ; conf_write ( fp , ""------<<S2SV_blank>Global<S2SV_blank>definitions<S2SV_blank>>------"" ) ; # if HAVE_DECL_CLONE_NEWNET conf_write ( fp , ""<S2SV_blank>Network<S2SV_blank>namespace<S2SV_blank>=<S2SV_blank>%s"" , data -> network_namespace ? data -> network_namespace : ""(default)"" ) ; # endif if ( data -> instance_name ) conf_write ( fp , ""<S2SV_blank>Instance<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s"" , data -> instance_name ) ; if ( data -> router_id ) conf_write ( fp , ""<S2SV_blank>Router<S2SV_blank>ID<S2SV_blank>=<S2SV_blank>%s"" , data -> router_id ) ; if ( data -> smtp_server . ss_family ) { conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>=<S2SV_blank>%s"" , inet_sockaddrtos ( & data -> smtp_server ) ) ; conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%u"" , ntohs ( inet_sockaddrport ( & data -> smtp_server ) ) ) ; } if ( data -> smtp_helo_name ) conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>HELO<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_helo_name ) ; if ( data -> smtp_connection_to ) conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>connection<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%lu"" , data -> smtp_connection_to / TIMER_HZ ) ; if ( data -> email_from ) { conf_write ( fp , ""<S2SV_blank>Email<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>=<S2SV_blank>%s"" , data -> email_from ) ; dump_list ( fp , data -> email ) ; } conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>smtp_alert<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_alert == - 1 ? ""unset"" : data -> smtp_alert ? ""on"" : ""off"" ) ; # ifdef _WITH_VRRP_ conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>smtp_alert_vrrp<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_alert_vrrp == - 1 ? ""unset"" : data -> smtp_alert_vrrp ? ""on"" : ""off"" ) ; # endif # ifdef _WITH_LVS_ conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>smtp_alert_checker<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_alert_checker == - 1 ? ""unset"" : data -> smtp_alert_checker ? ""on"" : ""off"" ) ; # endif # ifdef _WITH_VRRP_ conf_write ( fp , ""<S2SV_blank>Dynamic<S2SV_blank>interfaces<S2SV_blank>=<S2SV_blank>%s"" , data -> dynamic_interfaces ? ""true"" : ""false"" ) ; if ( data -> dynamic_interfaces ) conf_write ( fp , ""<S2SV_blank>Allow<S2SV_blank>interface<S2SV_blank>changes<S2SV_blank>=<S2SV_blank>%s"" , data -> allow_if_changes ? ""true"" : ""false"" ) ; if ( data -> no_email_faults ) conf_write ( fp , ""<S2SV_blank>Send<S2SV_blank>emails<S2SV_blank>for<S2SV_blank>fault<S2SV_blank>transitions<S2SV_blank>=<S2SV_blank>off"" ) ; # endif # ifdef _WITH_LVS_ if ( data -> lvs_tcp_timeout ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_tcp_timeout ) ; if ( data -> lvs_tcpfin_timeout ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>FIN<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_tcpfin_timeout ) ; if ( data -> lvs_udp_timeout ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_udp_timeout ) ; # ifdef _WITH_VRRP_ # ifndef _DEBUG_ if ( prog_type == PROG_TYPE_VRRP ) # endif conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>interface<S2SV_blank>=<S2SV_blank>%s"" , data -> default_ifp ? data -> default_ifp -> ifname : DFLT_INT ) ; if ( data -> lvs_syncd . vrrp ) { conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>vrrp<S2SV_blank>instance<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_syncd . vrrp -> iname ) ; if ( data -> lvs_syncd . ifname ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>interface<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_syncd . ifname ) ; conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>syncid<S2SV_blank>=<S2SV_blank>%u"" , data -> lvs_syncd . syncid ) ; # ifdef _HAVE_IPVS_SYNCD_ATTRIBUTES_ if ( data -> lvs_syncd . sync_maxlen ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>maxlen<S2SV_blank>=<S2SV_blank>%u"" , data -> lvs_syncd . sync_maxlen ) ; if ( data -> lvs_syncd . mcast_group . ss_family != AF_UNSPEC ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>%s"" , inet_sockaddrtos ( & data -> lvs_syncd . mcast_group ) ) ; if ( data -> lvs_syncd . mcast_port ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>mcast<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_syncd . mcast_port ) ; if ( data -> lvs_syncd . mcast_ttl ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>mcast<S2SV_blank>ttl<S2SV_blank>=<S2SV_blank>%u"" , data -> lvs_syncd . mcast_ttl ) ; # endif } # endif conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>flush<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_flush ? ""true"" : ""false"" ) ; # endif if ( data -> notify_fifo . name ) { conf_write ( fp , ""<S2SV_blank>Global<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s"" , data -> notify_fifo . name ) ; if ( data -> notify_fifo . script ) conf_write ( fp , ""<S2SV_blank>Global<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , cmd_str ( data -> notify_fifo . script ) , data -> notify_fifo . script -> uid , data -> notify_fifo . script -> gid ) ; } # ifdef _WITH_VRRP_ if ( data -> vrrp_notify_fifo . name ) { conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_notify_fifo . name ) ; if ( data -> vrrp_notify_fifo . script ) conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , cmd_str ( data -> vrrp_notify_fifo . script ) , data -> vrrp_notify_fifo . script -> uid , data -> vrrp_notify_fifo . script -> gid ) ; } # endif # ifdef _WITH_LVS_ if ( data -> lvs_notify_fifo . name ) { conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_notify_fifo . name ) ; if ( data -> lvs_notify_fifo . script ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , cmd_str ( data -> lvs_notify_fifo . script ) , data -> lvs_notify_fifo . script -> uid , data -> lvs_notify_fifo . script -> gid ) ; } # endif # ifdef _WITH_VRRP_ if ( data -> vrrp_mcast_group4 . sin_family ) { conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>IPv4<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>=<S2SV_blank>%s"" , inet_sockaddrtos ( ( struct sockaddr_storage * ) & data -> vrrp_mcast_group4 ) ) ; } if ( data -> vrrp_mcast_group6 . sin6_family ) { conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>IPv6<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>=<S2SV_blank>%s"" , inet_sockaddrtos ( ( struct sockaddr_storage * ) & data -> vrrp_mcast_group6 ) ) ; } conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>delay<S2SV_blank>=<S2SV_blank>%u"" , data -> vrrp_garp_delay / TIMER_HZ ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%u"" , data -> vrrp_garp_rep ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>refresh<S2SV_blank>timer<S2SV_blank>=<S2SV_blank>%lu"" , data -> vrrp_garp_refresh . tv_sec ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>refresh<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_refresh_rep ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>delay<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_lower_prio_delay == PARAMETER_UNSET ? PARAMETER_UNSET : data -> vrrp_garp_lower_prio_delay / TIMER_HZ ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_lower_prio_rep ) ; conf_write ( fp , ""<S2SV_blank>Send<S2SV_blank>advert<S2SV_blank>after<S2SV_blank>receive<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>advert<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_lower_prio_no_advert ? ""false"" : ""true"" ) ; conf_write ( fp , ""<S2SV_blank>Send<S2SV_blank>advert<S2SV_blank>after<S2SV_blank>receive<S2SV_blank>higher<S2SV_blank>priority<S2SV_blank>advert<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_higher_prio_send_advert ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>interval<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_interval ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>NA<S2SV_blank>interval<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_gna_interval ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>default<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_version ) ; if ( data -> vrrp_iptables_inchain [ 0 ] ) conf_write ( fp , ""<S2SV_blank>Iptables<S2SV_blank>input<S2SV_blank>chain<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_iptables_inchain ) ; if ( data -> vrrp_iptables_outchain [ 0 ] ) conf_write ( fp , ""<S2SV_blank>Iptables<S2SV_blank>output<S2SV_blank>chain<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_iptables_outchain ) ; # ifdef _HAVE_LIBIPSET_ conf_write ( fp , ""<S2SV_blank>Using<S2SV_blank>ipsets<S2SV_blank>=<S2SV_blank>%s"" , data -> using_ipsets ? ""true"" : ""false"" ) ; if ( data -> vrrp_ipset_address [ 0 ] ) conf_write ( fp , ""<S2SV_blank>ipset<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_ipset_address ) ; if ( data -> vrrp_ipset_address6 [ 0 ] ) conf_write ( fp , ""<S2SV_blank>ipset<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_ipset_address6 ) ; if ( data -> vrrp_ipset_address_iface6 [ 0 ] ) conf_write ( fp , ""<S2SV_blank>ipset<S2SV_blank>IPv6<S2SV_blank>address,iface<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_ipset_address_iface6 ) ; # endif conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>check<S2SV_blank>unicast_src<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_check_unicast_src ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>skip<S2SV_blank>check<S2SV_blank>advert<S2SV_blank>addresses<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_skip_check_adv_addr ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>strict<S2SV_blank>mode<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_strict ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_process_priority ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_no_swap ? ""true"" : ""false"" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u"" , data -> vrrp_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu"" , data -> vrrp_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_LVS_ conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d"" , data -> checker_process_priority ) ; conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s"" , data -> checker_no_swap ? ""true"" : ""false"" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u"" , data -> checker_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu"" , data -> checker_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_BFD_ conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d"" , data -> bfd_process_priority ) ; conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s"" , data -> bfd_no_swap ? ""true"" : ""false"" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u"" , data -> bfd_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu"" , data -> bfd_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_SNMP_VRRP_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>vrrp<S2SV_blank>%s"" , data -> enable_snmp_vrrp ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_CHECKER_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>checker<S2SV_blank>%s"" , data -> enable_snmp_checker ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_RFCV2_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>RFCv2<S2SV_blank>%s"" , data -> enable_snmp_rfcv2 ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_RFCV3_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>RFCv3<S2SV_blank>%s"" , data -> enable_snmp_rfcv3 ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>traps<S2SV_blank>%s"" , data -> enable_traps ? ""enabled"" : ""disabled"" ) ; conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>socket<S2SV_blank>=<S2SV_blank>%s"" , data -> snmp_socket ? data -> snmp_socket : ""default<S2SV_blank>(unix:/var/agentx/master)"" ) ; # endif # ifdef _WITH_DBUS_ conf_write ( fp , ""<S2SV_blank>DBus<S2SV_blank>%s"" , data -> enable_dbus ? ""enabled"" : ""disabled"" ) ; conf_write ( fp , ""<S2SV_blank>DBus<S2SV_blank>service<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s"" , data -> dbus_service_name ? data -> dbus_service_name : """" ) ; # endif conf_write ( fp , ""<S2SV_blank>Script<S2SV_blank>security<S2SV_blank>%s"" , script_security ? ""enabled"" : ""disabled"" ) ; conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>script<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , default_script_uid , default_script_gid ) ; # ifdef _WITH_VRRP_ conf_write ( fp , ""<S2SV_blank>vrrp_netlink_cmd_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_cmd_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>vrrp_netlink_cmd_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_cmd_rcv_bufs_force ) ; conf_write ( fp , ""<S2SV_blank>vrrp_netlink_monitor_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_monitor_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>vrrp_netlink_monitor_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_monitor_rcv_bufs_force ) ; # endif # ifdef _WITH_LVS_ conf_write ( fp , ""<S2SV_blank>lvs_netlink_cmd_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_cmd_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>lvs_netlink_cmd_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_cmd_rcv_bufs_force ) ; conf_write ( fp , ""<S2SV_blank>lvs_netlink_monitor_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_monitor_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>lvs_netlink_monitor_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_monitor_rcv_bufs_force ) ; conf_write ( fp , ""<S2SV_blank>rs_init_notifies<S2SV_blank>=<S2SV_blank>%u"" , global_data -> rs_init_notifies ) ; conf_write ( fp , ""<S2SV_blank>no_checker_emails<S2SV_blank>=<S2SV_blank>%u"" , global_data -> no_checker_emails ) ; # endif # ifdef _WITH_VRRP_ buf [ 0 ] = '\\0' ; if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_POLICY_MTU ) strcpy ( buf , ""<S2SV_blank>rx_bufs_policy<S2SV_blank>=<S2SV_blank>MTU"" ) ; else if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_POLICY_ADVERT ) strcpy ( buf , ""<S2SV_blank>rx_bufs_policy<S2SV_blank>=<S2SV_blank>ADVERT"" ) ; else if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_SIZE ) sprintf ( buf , ""<S2SV_blank>rx_bufs_size<S2SV_blank>=<S2SV_blank>%lu"" , global_data -> vrrp_rx_bufs_size ) ; if ( buf [ 0 ] ) conf_write ( fp , ""%s"" , buf ) ; conf_write ( fp , ""<S2SV_blank>rx_bufs_multiples<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_rx_bufs_multiples ) ; # endif }
","<S2SV_ModStart> vrrp_rx_bufs_multiples ) ; conf_write ( fp , ""<S2SV_blank>umask<S2SV_blank>=<S2SV_blank>0%o"" , global_data -> umask ) ;
",acassen@keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,CVE-2018-19045,https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,2018-11-08T20:29Z,<S2SV_StartBug> # endif <S2SV_EndBug>
6424,CWE-000,"int fdt_find_regions ( const void * fdt , char * const inc [ ] , int inc_count , char * const exc_prop [ ] , int exc_prop_count , struct fdt_region region [ ] , int max_regions , char * path , int path_len , int add_string_tab ) { int stack [ FDT_MAX_DEPTH ] = { 0 } ; char * end ; int nextoffset = 0 ; uint32_t tag ; int count = 0 ; int start = - 1 ; int depth = - 1 ; int want = 0 ; int base = fdt_off_dt_struct ( fdt ) ; end = path ; * end = '\\0' ; do { const struct fdt_property * prop ; const char * name ; const char * str ; int include = 0 ; int stop_at = 0 ; int offset ; int len ; offset = nextoffset ; tag = fdt_next_tag ( fdt , offset , & nextoffset ) ; stop_at = nextoffset ; switch ( tag ) { case FDT_PROP : include = want >= 2 ; stop_at = offset ; prop = fdt_get_property_by_offset ( fdt , offset , NULL ) ; str = fdt_string ( fdt , fdt32_to_cpu ( prop -> nameoff ) ) ; if ( ! str ) return - FDT_ERR_BADSTRUCTURE ; if ( str_in_list ( str , exc_prop , exc_prop_count ) ) include = 0 ; break ; case FDT_NOP : include = want >= 2 ; stop_at = offset ; break ; case FDT_BEGIN_NODE : depth ++ ; if ( depth == FDT_MAX_DEPTH ) return - FDT_ERR_BADSTRUCTURE ; name = fdt_get_name ( fdt , offset , & len ) ; if ( end - path + 2 + len >= path_len ) return - FDT_ERR_NOSPACE ; if ( end != path + 1 ) * end ++ = '/' ; strcpy ( end , name ) ; end += len ; stack [ depth ] = want ; if ( want == 1 ) stop_at = offset ; if ( str_in_list ( path , inc , inc_count ) ) want = 2 ; else if ( want ) want -- ; else stop_at = offset ; include = want ; break ; case FDT_END_NODE : if ( depth < 0 ) return - FDT_ERR_BADSTRUCTURE ; include = want ; want = stack [ depth -- ] ; while ( end > path && * -- end != '/' ) ; * end = '\\0' ; break ; case FDT_END : include = 1 ; break ; } if ( include && start == - 1 ) { if ( count && count <= max_regions && offset == region [ count - 1 ] . offset + region [ count - 1 ] . size - base ) start = region [ -- count ] . offset - base ; else start = offset ; } if ( ! include && start != - 1 ) { if ( count < max_regions ) { region [ count ] . offset = base + start ; region [ count ] . size = stop_at - start ; } count ++ ; start = - 1 ; } } while ( tag != FDT_END ) ; if ( nextoffset != fdt_size_dt_struct ( fdt ) ) return - FDT_ERR_BADLAYOUT ; if ( count < max_regions ) { region [ count ] . offset = base + start ; region [ count ] . size = nextoffset - start ; if ( add_string_tab ) region [ count ] . size += fdt_size_dt_strings ( fdt ) ; } count ++ ; return count ; }
","<S2SV_ModStart> fdt ) ; bool expect_end = false ; <S2SV_ModStart> = nextoffset ; if ( expect_end && tag != FDT_END ) return - FDT_ERR_BADLAYOUT ; <S2SV_ModStart> & len ) ; if ( ! depth && * name ) return - FDT_ERR_BADLAYOUT <S2SV_ModStart> = '\\0' ; if ( depth == - 1 ) expect_end = true ;
",u-boot@u-boot/8a7d4cf9820ea16fabd25a6379351b4dc291204b,CVE-2021-27097,https://github.com/u-boot/u-boot/commit/8a7d4cf9820ea16fabd25a6379351b4dc291204b,2021-02-17T23:15Z,"<S2SV_StartBug> end = path ; <S2SV_EndBug> <S2SV_StartBug> switch ( tag ) { <S2SV_EndBug> <S2SV_StartBug> name = fdt_get_name ( fdt , offset , & len ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug>"
116,CWE-285,"static int __ext4_set_acl ( handle_t * handle , struct inode * inode , int type , struct posix_acl * acl ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; if ( error < 0 ) return error ; else { inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; if ( error == 0 ) acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext4_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext4_xattr_set_handle ( handle , inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug>"
143,CWE-189,"static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; if ( ( int ) val < 0 ) write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
","<S2SV_ModStart> ; if ( pmc_overflow ( val ) <S2SV_ModEnd> ) write_pmc (
",torvalds@linux/0837e3242c73566fc1c0196b4ec61779c25ffc93,CVE-2011-4611,https://github.com/torvalds/linux/commit/0837e3242c73566fc1c0196b4ec61779c25ffc93,2012-05-17T11:00Z,<S2SV_StartBug> if ( ( int ) val < 0 ) <S2SV_EndBug>
2945,CWE-125,"static void core_anal_bytes ( RCore * core , const ut8 * buf , int len , int nops , int fmt ) { int stacksize = r_config_get_i ( core -> config , ""esil.stack.depth"" ) ; bool iotrap = r_config_get_i ( core -> config , ""esil.iotrap"" ) ; bool romem = r_config_get_i ( core -> config , ""esil.romem"" ) ; bool stats = r_config_get_i ( core -> config , ""esil.stats"" ) ; bool be = core -> print -> big_endian ; bool use_color = core -> print -> flags & R_PRINT_FLAGS_COLOR ; core -> parser -> relsub = r_config_get_i ( core -> config , ""asm.relsub"" ) ; int ret , i , j , idx , size ; const char * color = """" ; const char * esilstr ; const char * opexstr ; RAnalHint * hint ; RAnalEsil * esil = NULL ; RAsmOp asmop ; RAnalOp op = { 0 } ; ut64 addr ; bool isFirst = true ; unsigned int addrsize = r_config_get_i ( core -> config , ""esil.addr.size"" ) ; int totalsize = 0 ; if ( use_color ) { color = core -> cons -> pal . label ; } switch ( fmt ) { case 'j' : r_cons_printf ( ""["" ) ; break ; case 'r' : esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ; if ( ! esil ) { return ; } r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; break ; } for ( i = idx = ret = 0 ; idx < len && ( ! nops || ( nops && i < nops ) ) ; i ++ , idx += ret ) { addr = core -> offset + idx ; hint = r_anal_hint_get ( core -> anal , addr ) ; r_asm_set_pc ( core -> assembler , addr ) ; ( void ) r_asm_disassemble ( core -> assembler , & asmop , buf + idx , len - idx ) ; ret = r_anal_op ( core -> anal , & op , core -> offset + idx , buf + idx , len - idx , R_ANAL_OP_MASK_ESIL ) ; esilstr = R_STRBUF_SAFEGET ( & op . esil ) ; opexstr = R_STRBUF_SAFEGET ( & op . opex ) ; char * mnem = strdup ( r_asm_op_get_asm ( & asmop ) ) ; char * sp = strchr ( mnem , '<S2SV_blank>' ) ; if ( sp ) { * sp = 0 ; if ( op . prefix ) { char * arg = strdup ( sp + 1 ) ; char * sp = strchr ( arg , '<S2SV_blank>' ) ; if ( sp ) { * sp = 0 ; } free ( mnem ) ; mnem = arg ; } } if ( ret < 1 && fmt != 'd' ) { eprintf ( ""Oops<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""<S2SV_blank>("" , core -> offset + idx ) ; for ( i = idx , j = 0 ; i < core -> blocksize && j < 3 ; ++ i , ++ j ) { eprintf ( ""%02x<S2SV_blank>"" , buf [ i ] ) ; } eprintf ( ""...)\\n"" ) ; free ( mnem ) ; break ; } size = ( hint && hint -> size ) ? hint -> size : op . size ; if ( fmt == 'd' ) { char * opname = strdup ( r_asm_op_get_asm ( & asmop ) ) ; if ( opname ) { r_str_split ( opname , '<S2SV_blank>' ) ; char * d = r_asm_describe ( core -> assembler , opname ) ; if ( d && * d ) { r_cons_printf ( ""%s:<S2SV_blank>%s\\n"" , opname , d ) ; free ( d ) ; } else { eprintf ( ""Unknown<S2SV_blank>opcode\\n"" ) ; } free ( opname ) ; } } else if ( fmt == 'e' ) { if ( * esilstr ) { if ( use_color ) { r_cons_printf ( ""%s0x%"" PFMT64x Color_RESET ""<S2SV_blank>%s\\n"" , color , core -> offset + idx , esilstr ) ; } else { r_cons_printf ( ""0x%"" PFMT64x ""<S2SV_blank>%s\\n"" , core -> offset + idx , esilstr ) ; } } } else if ( fmt == 's' ) { totalsize += op . size ; } else if ( fmt == 'r' ) { if ( * esilstr ) { if ( use_color ) { r_cons_printf ( ""%s0x%"" PFMT64x Color_RESET ""\\n"" , color , core -> offset + idx ) ; } else { r_cons_printf ( ""0x%"" PFMT64x ""\\n"" , core -> offset + idx ) ; } r_anal_esil_parse ( esil , esilstr ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; } } else if ( fmt == 'j' ) { if ( isFirst ) { isFirst = false ; } else { r_cons_print ( "","" ) ; } r_cons_printf ( ""{\\""opcode\\"":\\""%s\\"","" , r_asm_op_get_asm ( & asmop ) ) ; { char strsub [ 128 ] = { 0 } ; r_parse_varsub ( core -> parser , NULL , core -> offset + idx , asmop . size , r_asm_op_get_asm ( & asmop ) , strsub , sizeof ( strsub ) ) ; { ut64 killme = UT64_MAX ; if ( r_io_read_i ( core -> io , op . ptr , & killme , op . refptr , be ) ) { core -> parser -> relsub_addr = killme ; } } char * p = strdup ( strsub ) ; if ( p ) { r_parse_filter ( core -> parser , addr , core -> flags , p , strsub , sizeof ( strsub ) , be ) ; free ( p ) ; } r_cons_printf ( ""\\""disasm\\"":\\""%s\\"","" , strsub ) ; } r_cons_printf ( ""\\""mnemonic\\"":\\""%s\\"","" , mnem ) ; if ( hint && hint -> opcode ) { r_cons_printf ( ""\\""ophint\\"":\\""%s\\"","" , hint -> opcode ) ; } r_cons_printf ( ""\\""sign\\"":%s,"" , r_str_bool ( op . sign ) ) ; r_cons_printf ( ""\\""prefix\\"":%"" PFMT64u "","" , op . prefix ) ; r_cons_printf ( ""\\""id\\"":%d,"" , op . id ) ; if ( opexstr && * opexstr ) { r_cons_printf ( ""\\""opex\\"":%s,"" , opexstr ) ; } r_cons_printf ( ""\\""addr\\"":%"" PFMT64u "","" , core -> offset + idx ) ; r_cons_printf ( ""\\""bytes\\"":\\"""" ) ; for ( j = 0 ; j < size ; j ++ ) { r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ; } r_cons_printf ( ""\\"","" ) ; if ( op . val != UT64_MAX ) { r_cons_printf ( ""\\""val\\"":<S2SV_blank>%"" PFMT64u "","" , op . val ) ; } if ( op . ptr != UT64_MAX ) { r_cons_printf ( ""\\""ptr\\"":<S2SV_blank>%"" PFMT64u "","" , op . ptr ) ; } r_cons_printf ( ""\\""size\\"":<S2SV_blank>%d,"" , size ) ; r_cons_printf ( ""\\""type\\"":<S2SV_blank>\\""%s\\"","" , r_anal_optype_to_string ( op . type ) ) ; if ( op . reg ) { r_cons_printf ( ""\\""reg\\"":<S2SV_blank>\\""%s\\"","" , op . reg ) ; } if ( op . ireg ) { r_cons_printf ( ""\\""ireg\\"":<S2SV_blank>\\""%s\\"","" , op . ireg ) ; } if ( op . scale ) { r_cons_printf ( ""\\""scale\\"":%d,"" , op . scale ) ; } if ( hint && hint -> esil ) { r_cons_printf ( ""\\""esil\\"":<S2SV_blank>\\""%s\\"","" , hint -> esil ) ; } else if ( * esilstr ) { r_cons_printf ( ""\\""esil\\"":<S2SV_blank>\\""%s\\"","" , esilstr ) ; } if ( hint && hint -> jump != UT64_MAX ) { op . jump = hint -> jump ; } if ( op . jump != UT64_MAX ) { r_cons_printf ( ""\\""jump\\"":%"" PFMT64u "","" , op . jump ) ; } if ( hint && hint -> fail != UT64_MAX ) { op . fail = hint -> fail ; } if ( op . refptr != - 1 ) { r_cons_printf ( ""\\""refptr\\"":%d,"" , op . refptr ) ; } if ( op . fail != UT64_MAX ) { r_cons_printf ( ""\\""fail\\"":%"" PFMT64u "","" , op . fail ) ; } r_cons_printf ( ""\\""cycles\\"":%d,"" , op . cycles ) ; if ( op . failcycles ) { r_cons_printf ( ""\\""failcycles\\"":%d,"" , op . failcycles ) ; } r_cons_printf ( ""\\""delay\\"":%d,"" , op . delay ) ; { const char * p = r_anal_stackop_tostring ( op . stackop ) ; if ( p && * p && strcmp ( p , ""null"" ) ) r_cons_printf ( ""\\""stack\\"":\\""%s\\"","" , p ) ; } if ( op . stackptr ) { r_cons_printf ( ""\\""stackptr\\"":%d,"" , op . stackptr ) ; } { const char * arg = ( op . type & R_ANAL_OP_TYPE_COND ) ? r_anal_cond_tostring ( op . cond ) : NULL ; if ( arg ) { r_cons_printf ( ""\\""cond\\"":\\""%s\\"","" , arg ) ; } } r_cons_printf ( ""\\""family\\"":\\""%s\\""}"" , r_anal_op_family_to_string ( op . family ) ) ; } else { # define printline ( k , fmt , arg ) { if ( use_color ) r_cons_printf ( ""%s%s:<S2SV_blank>"" Color_RESET , color , k ) ; else r_cons_printf ( ""%s:<S2SV_blank>"" , k ) ; if ( fmt ) r_cons_printf ( fmt , arg ) ; } printline ( ""address"" , ""0x%"" PFMT64x ""\\n"" , core -> offset + idx ) ; printline ( ""opcode"" , ""%s\\n"" , r_asm_op_get_asm ( & asmop ) ) ; printline ( ""mnemonic"" , ""%s\\n"" , mnem ) ; if ( hint ) { if ( hint -> opcode ) { printline ( ""ophint"" , ""%s\\n"" , hint -> opcode ) ; } # if 0 if ( hint -> addr != UT64_MAX ) { printline ( ""addr"" , ""0x%08"" PFMT64x ""\\n"" , ( hint -> addr + idx ) ) ; } # endif } printline ( ""prefix"" , ""%"" PFMT64u ""\\n"" , op . prefix ) ; printline ( ""id"" , ""%d\\n"" , op . id ) ; # if 0 if ( opexstr && * opexstr ) { printline ( ""opex"" , ""%s\\n"" , opexstr ) ; } # endif printline ( ""bytes"" , NULL , 0 ) ; for ( j = 0 ; j < size ; j ++ ) { r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ; } r_cons_newline ( ) ; if ( op . val != UT64_MAX ) printline ( ""val"" , ""0x%08"" PFMT64x ""\\n"" , op . val ) ; if ( op . ptr != UT64_MAX ) printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\n"" , op . ptr ) ; if ( op . refptr != - 1 ) printline ( ""refptr"" , ""%d\\n"" , op . refptr ) ; printline ( ""size"" , ""%d\\n"" , size ) ; printline ( ""sign"" , ""%s\\n"" , r_str_bool ( op . sign ) ) ; printline ( ""type"" , ""%s\\n"" , r_anal_optype_to_string ( op . type ) ) ; printline ( ""cycles"" , ""%d\\n"" , op . cycles ) ; if ( op . failcycles ) { printline ( ""failcycles"" , ""%d\\n"" , op . failcycles ) ; } { const char * t2 = r_anal_optype_to_string ( op . type2 ) ; if ( t2 && strcmp ( t2 , ""null"" ) ) { printline ( ""type2"" , ""%s\\n"" , t2 ) ; } } if ( op . reg ) { printline ( ""reg"" , ""%s\\n"" , op . reg ) ; } if ( op . ireg ) { printline ( ""ireg"" , ""%s\\n"" , op . ireg ) ; } if ( op . scale ) { printline ( ""scale"" , ""%d\\n"" , op . scale ) ; } if ( hint && hint -> esil ) { printline ( ""esil"" , ""%s\\n"" , hint -> esil ) ; } else if ( * esilstr ) { printline ( ""esil"" , ""%s\\n"" , esilstr ) ; } if ( hint && hint -> jump != UT64_MAX ) { op . jump = hint -> jump ; } if ( op . jump != UT64_MAX ) { printline ( ""jump"" , ""0x%08"" PFMT64x ""\\n"" , op . jump ) ; } if ( op . direction != 0 ) { const char * dir = op . direction == 1 ? ""read"" : op . direction == 2 ? ""write"" : op . direction == 4 ? ""exec"" : op . direction == 8 ? ""ref"" : ""none"" ; printline ( ""direction"" , ""%s\\n"" , dir ) ; } if ( hint && hint -> fail != UT64_MAX ) { op . fail = hint -> fail ; } if ( op . fail != UT64_MAX ) { printline ( ""fail"" , ""0x%08"" PFMT64x ""\\n"" , op . fail ) ; } if ( op . delay ) { printline ( ""delay"" , ""%d\\n"" , op . delay ) ; } printline ( ""stack"" , ""%s\\n"" , r_anal_stackop_tostring ( op . stackop ) ) ; { const char * arg = ( op . type & R_ANAL_OP_TYPE_COND ) ? r_anal_cond_tostring ( op . cond ) : NULL ; if ( arg ) { printline ( ""cond"" , ""%s\\n"" , arg ) ; } } printline ( ""family"" , ""%s\\n"" , r_anal_op_family_to_string ( op . family ) ) ; printline ( ""stackop"" , ""%s\\n"" , r_anal_stackop_tostring ( op . stackop ) ) ; if ( op . stackptr ) { printline ( ""stackptr"" , ""%"" PFMT64u ""\\n"" , op . stackptr ) ; } } free ( mnem ) ; r_anal_hint_free ( hint ) ; r_anal_op_fini ( & op ) ; } r_anal_op_fini ( & op ) ; if ( fmt == 'j' ) { r_cons_printf ( ""]"" ) ; r_cons_newline ( ) ; } else if ( fmt == 's' ) { r_cons_printf ( ""%d\\n"" , totalsize ) ; } r_anal_esil_free ( esil ) ; }
","<S2SV_ModStart> 0 ) ; int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; <S2SV_ModStart> ; j < minsz <S2SV_ModEnd> ; j ++ <S2SV_ModStart> ++ ) { ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : <S2SV_ModEnd> buf [ j <S2SV_ModStart> + idx ] ; r_cons_printf ( ""%02x"" , ch <S2SV_ModStart> != UT64_MAX ) { <S2SV_ModStart> val ) ; } <S2SV_ModStart> != UT64_MAX ) { <S2SV_ModStart> ptr ) ; } <S2SV_ModStart> - 1 ) { <S2SV_ModStart> refptr ) ; }
",radare@radare2/a1bc65c3db593530775823d6d7506a457ed95267,CVE-2018-20461,https://github.com/radare/radare2/commit/a1bc65c3db593530775823d6d7506a457ed95267,2018-12-25T19:29Z,"<S2SV_StartBug> for ( j = 0 ; j < size ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . val != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( op . ptr != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\n"" , op . ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . refptr != - 1 ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""refptr"" , ""%d\\n"" , op . refptr ) ; <S2SV_EndBug>"
1343,CWE-119,"void usage_exit ( ) { fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank>"" ""<keyframe-interval><S2SV_blank>[<error-resilient>]\\nSee<S2SV_blank>comments<S2SV_blank>in<S2SV_blank>"" ""simple_encoder.c<S2SV_blank>for<S2SV_blank>more<S2SV_blank>information.\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
","<S2SV_ModStart> void usage_exit ( void
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug>
456,CWE-189,"static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { res . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! res . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%zu<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%zu\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , NULL , acl_len ) ; else nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , acl_len ) ; if ( buf ) { ret = - ERANGE ; if ( acl_len > buflen ) goto out_free ; _copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ; } ret = acl_len ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ; if ( res . acl_scratch ) __free_page ( res . acl_scratch ) ; return ret ; }
","<S2SV_ModStart> . acl_data_offset , <S2SV_ModEnd> acl_len ) ;
",torvalds@linux/20e0fa98b751facf9a1101edaefbc19c82616a68,CVE-2012-2375,https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68,2012-06-13T10:24Z,<S2SV_StartBug> res . acl_len ) ; <S2SV_EndBug>
5479,CWE-416,"static void ext4_clamp_want_extra_isize ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_super_block * es = sbi -> s_es ; if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE && sbi -> s_want_extra_isize == 0 ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( EXT4_GOOD_OLD_INODE_SIZE + sbi -> s_want_extra_isize > sbi -> s_inode_size ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; ext4_msg ( sb , KERN_INFO , ""required<S2SV_blank>extra<S2SV_blank>inode<S2SV_blank>space<S2SV_blank>not<S2SV_blank>available"" ) ; } }
","<S2SV_ModStart> -> s_es ; unsigned def_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; <S2SV_ModStart> sbi -> s_inode_size == EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = 0 ; return ; } if ( sbi -> s_want_extra_isize < 4 ) { sbi -> s_want_extra_isize = def_extra_isize ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( ( sbi -> s_want_extra_isize > sbi -> s_inode_size ) || <S2SV_ModEnd> ( EXT4_GOOD_OLD_INODE_SIZE + <S2SV_ModStart> -> s_inode_size ) ) { sbi -> s_want_extra_isize = def_extra_isize <S2SV_ModEnd> ; ext4_msg (
",torvalds@linux/4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a,CVE-2019-19767,https://github.com/torvalds/linux/commit/4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a,2019-12-12T20:15Z,<S2SV_StartBug> if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE && <S2SV_EndBug> <S2SV_StartBug> sbi -> s_inode_size ) { <S2SV_EndBug>
223,CWE-190,"static void php_html_entities ( INTERNAL_FUNCTION_PARAMETERS , int all ) { char * str , * hint_charset = NULL ; int str_len , hint_charset_len = 0 ; size_t new_len ; long flags = ENT_COMPAT ; char * replaced ; zend_bool double_encode = 1 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s|ls!b"" , & str , & str_len , & flags , & hint_charset , & hint_charset_len , & double_encode ) == FAILURE ) { return ; } replaced = php_escape_html_entities_ex ( str , str_len , & new_len , all , ( int ) flags , hint_charset , double_encode TSRMLS_CC ) ; RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ; }
","<S2SV_ModStart> TSRMLS_CC ) ; if ( new_len > INT_MAX ) { efree ( replaced ) ; RETURN_FALSE ; }
",php@php-src/0da8b8b801f9276359262f1ef8274c7812d3dfda,CVE-2016-5094,https://github.com/php/php-src/commit/0da8b8b801f9276359262f1ef8274c7812d3dfda?w=1,2016-08-07T10:59Z,"<S2SV_StartBug> RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ; <S2SV_EndBug>"
6588,CWE-20,"void SetTransferMatrix ( double x11 , double x12 , double x21 , double x22 , double x , double y ) { if ( ( fabs ( x11 - 1. ) > 0.001 ) || ( fabs ( x22 - 1. ) > 0.001 ) || ( fabs ( x12 ) > 0.001 ) || ( fabs ( x21 ) > 0.001 ) || ( fabs ( x ) > 0.001 ) || ( fabs ( y ) > 0.001 ) ) { outpos += sprintf ( outpos , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , x11 , x12 , x21 , x22 , x , y ) ; } }
","<S2SV_ModStart> ) ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , <S2SV_ModStart> y ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
6927,CWE-400,"int do_mathemu ( struct pt_regs * regs , struct task_struct * fpt ) { int i ; int retcode = 0 ; unsigned long insn ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; # ifdef DEBUG_MATHEMU printk ( ""In<S2SV_blank>do_mathemu()...<S2SV_blank>pc<S2SV_blank>is<S2SV_blank>%08lx\\n"" , regs -> pc ) ; printk ( ""fpqdepth<S2SV_blank>is<S2SV_blank>%ld\\n"" , fpt -> thread . fpqdepth ) ; for ( i = 0 ; i < fpt -> thread . fpqdepth ; i ++ ) printk ( ""%d:<S2SV_blank>%08lx<S2SV_blank>at<S2SV_blank>%08lx\\n"" , i , fpt -> thread . fpqueue [ i ] . insn , ( unsigned long ) fpt -> thread . fpqueue [ i ] . insn_addr ) ; # endif if ( fpt -> thread . fpqdepth == 0 ) { # ifdef DEBUG_MATHEMU printk ( ""precise<S2SV_blank>trap<S2SV_blank>at<S2SV_blank>%08lx\\n"" , regs -> pc ) ; # endif if ( ! get_user ( insn , ( u32 __user * ) regs -> pc ) ) { retcode = do_one_mathemu ( insn , & fpt -> thread . fsr , fpt -> thread . float_regs ) ; if ( retcode ) { regs -> pc = regs -> npc ; regs -> npc += 4 ; } } return retcode ; } for ( i = 0 ; i < fpt -> thread . fpqdepth ; i ++ ) { retcode = do_one_mathemu ( fpt -> thread . fpqueue [ i ] . insn , & ( fpt -> thread . fsr ) , fpt -> thread . float_regs ) ; if ( ! retcode ) break ; } if ( retcode ) fpt -> thread . fsr &= ~ ( 0x3000 | FSR_CEXC_MASK ) ; else fpt -> thread . fsr &= ~ 0x3000 ; fpt -> thread . fpqdepth = 0 ; return retcode ; }
","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug>"
3567,CWE-119,"void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) { bloc = * offset ; while ( node && node -> symbol == INTERNAL_NODE ) { if ( get_bit ( fin ) ) { node = node -> right ; } else { node = node -> left ; } } if ( ! node ) { * ch = 0 ; return ; } * ch = node -> symbol ; * offset = bloc ; }
","<S2SV_ModStart> int * offset , int maxoffset <S2SV_ModStart> INTERNAL_NODE ) { if ( bloc >= maxoffset ) { * ch = 0 ; * offset = maxoffset + 1 ; return ; }
",ioquake@ioq3/d2b1d124d4055c2fcbe5126863487c52fd58cca1,CVE-2017-11721,https://github.com/ioquake/ioq3/commit/d2b1d124d4055c2fcbe5126863487c52fd58cca1,2017-08-03T08:29Z,"<S2SV_StartBug> void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) { <S2SV_EndBug> <S2SV_StartBug> while ( node && node -> symbol == INTERNAL_NODE ) { <S2SV_EndBug>"
1466,CWE-119,"int vp8_set_active_map ( VP8_COMP * cpi , unsigned char * map , unsigned int rows , unsigned int cols ) { if ( rows == cpi -> common . mb_rows && cols == cpi -> common . mb_cols ) { if ( map ) { vpx_memcpy ( cpi -> active_map , map , rows * cols ) ; cpi -> active_map_enabled = 1 ; } else cpi -> active_map_enabled = 0 ; return 0 ; } else { return - 1 ; } }
","<S2SV_ModStart> map ) { memcpy <S2SV_ModEnd> ( cpi ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( cpi -> active_map , map , rows * cols ) ; <S2SV_EndBug>"
4766,CWE-787,"GF_Err adts_dmx_process ( GF_Filter * filter ) { GF_ADTSDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u8 * data , * output ; u8 * start ; u32 pck_size , remain , prev_pck_size ; u64 cts = GF_FILTER_NO_TS ; if ( ! ctx -> duration . num ) adts_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> adts_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } else { return GF_OK ; } } prev_pck_size = ctx -> adts_buffer_size ; if ( pck && ! ctx -> resume_from ) { data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; if ( ! pck_size ) { gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_OK ; } if ( ctx -> byte_offset != GF_FILTER_NO_BO ) { u64 byte_offset = gf_filter_pck_get_byte_offset ( pck ) ; if ( ! ctx -> adts_buffer_size ) { ctx -> byte_offset = byte_offset ; } else if ( ctx -> byte_offset + ctx -> adts_buffer_size != byte_offset ) { ctx -> byte_offset = GF_FILTER_NO_BO ; if ( ( byte_offset != GF_FILTER_NO_BO ) && ( byte_offset > ctx -> adts_buffer_size ) ) { ctx -> byte_offset = byte_offset - ctx -> adts_buffer_size ; } } } if ( ctx -> adts_buffer_size + pck_size > ctx -> adts_buffer_alloc ) { ctx -> adts_buffer_alloc = ctx -> adts_buffer_size + pck_size ; ctx -> adts_buffer = gf_realloc ( ctx -> adts_buffer , ctx -> adts_buffer_alloc ) ; } memcpy ( ctx -> adts_buffer + ctx -> adts_buffer_size , data , pck_size ) ; ctx -> adts_buffer_size += pck_size ; } if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } if ( cts == GF_FILTER_NO_TS ) { prev_pck_size = 0 ; } remain = ctx -> adts_buffer_size ; start = ctx -> adts_buffer ; if ( ctx -> resume_from ) { start += ctx -> resume_from - 1 ; remain -= ctx -> resume_from - 1 ; ctx -> resume_from = 0 ; } while ( remain ) { u8 * sync ; u32 sync_pos , size , offset , bytes_to_drop = 0 , nb_blocks_per_frame ; if ( ! ctx -> tag_size && ( remain > 3 ) ) { if ( start [ 0 ] == 'I' && start [ 1 ] == 'D' && start [ 2 ] == '3' ) { if ( remain < 10 ) return GF_OK ; ctx -> tag_size = ( ( start [ 9 ] & 0x7f ) + ( ( start [ 8 ] & 0x7f ) << 7 ) + ( ( start [ 7 ] & 0x7f ) << 14 ) + ( ( start [ 6 ] & 0x7f ) << 21 ) ) ; bytes_to_drop = 10 ; if ( ctx -> id3_buffer_alloc < ctx -> tag_size + 10 ) { ctx -> id3_buffer = gf_realloc ( ctx -> id3_buffer , ctx -> tag_size + 10 ) ; ctx -> id3_buffer_alloc = ctx -> tag_size + 10 ; } memcpy ( ctx -> id3_buffer , start , 10 ) ; ctx -> id3_buffer_size = 10 ; goto drop_byte ; } } if ( ctx -> tag_size ) { if ( ctx -> tag_size > remain ) { bytes_to_drop = remain ; ctx -> tag_size -= remain ; } else { bytes_to_drop = ctx -> tag_size ; ctx -> tag_size = 0 ; } memcpy ( ctx -> id3_buffer + ctx -> id3_buffer_size , start , bytes_to_drop ) ; ctx -> id3_buffer_size += bytes_to_drop ; if ( ! ctx -> tag_size && ctx -> opid ) { id3dmx_flush ( filter , ctx -> id3_buffer , ctx -> id3_buffer_size , ctx -> opid , ctx -> expart ? & ctx -> vpid : NULL ) ; ctx -> id3_buffer_size = 0 ; } goto drop_byte ; } sync = memchr ( start , 0xFF , remain ) ; sync_pos = ( u32 ) ( sync ? sync - start : remain ) ; if ( remain - sync_pos < 7 ) { break ; } if ( ( sync [ 1 ] & 0xF0 ) != 0xF0 ) { GF_LOG ( ctx -> nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>invalid<S2SV_blank>ADTS<S2SV_blank>sync<S2SV_blank>bytes,<S2SV_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } if ( ! ctx -> bs ) { ctx -> bs = gf_bs_new ( sync + 1 , remain - sync_pos - 1 , GF_BITSTREAM_READ ) ; } else { gf_bs_reassign_buffer ( ctx -> bs , sync + 1 , remain - sync_pos - 1 ) ; } gf_bs_read_int ( ctx -> bs , 4 ) ; ctx -> hdr . is_mp2 = ( Bool ) gf_bs_read_int ( ctx -> bs , 1 ) ; ctx -> hdr . is_mp2 = 0 ; gf_bs_read_int ( ctx -> bs , 2 ) ; ctx -> hdr . no_crc = ( Bool ) gf_bs_read_int ( ctx -> bs , 1 ) ; ctx -> hdr . profile = 1 + gf_bs_read_int ( ctx -> bs , 2 ) ; ctx -> hdr . sr_idx = gf_bs_read_int ( ctx -> bs , 4 ) ; gf_bs_read_int ( ctx -> bs , 1 ) ; ctx -> hdr . nb_ch = gf_bs_read_int ( ctx -> bs , 3 ) ; gf_bs_read_int ( ctx -> bs , 4 ) ; ctx -> hdr . frame_size = gf_bs_read_int ( ctx -> bs , 13 ) ; gf_bs_read_int ( ctx -> bs , 11 ) ; nb_blocks_per_frame = gf_bs_read_int ( ctx -> bs , 2 ) ; ctx -> hdr . hdr_size = 7 ; if ( ! ctx -> hdr . no_crc ) { u32 skip ; if ( ! nb_blocks_per_frame ) { skip = 2 ; } else { skip = 2 + 2 * nb_blocks_per_frame ; } ctx -> hdr . hdr_size += skip ; gf_bs_skip_bytes ( ctx -> bs , skip ) ; } if ( ! ctx -> hdr . frame_size || ! GF_M4ASampleRates [ ctx -> hdr . sr_idx ] ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>Invalid<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header,<S2SV_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } if ( ( nb_blocks_per_frame > 2 ) || ( nb_blocks_per_frame && ctx -> hdr . nb_ch ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>Unsupported<S2SV_blank>multi-block<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header<S2SV_blank>-<S2SV_blank>patch<S2SV_blank>welcome\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } else if ( ! nb_blocks_per_frame ) { if ( ctx -> aacchcfg < 0 ) ctx -> hdr . nb_ch = - ctx -> aacchcfg ; else if ( ! ctx -> hdr . nb_ch ) ctx -> hdr . nb_ch = ctx -> aacchcfg ; if ( ! ctx -> hdr . nb_ch ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>Missing<S2SV_blank>channel<S2SV_blank>configuration<S2SV_blank>in<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header,<S2SV_blank>defaulting<S2SV_blank>to<S2SV_blank>stereo<S2SV_blank>-<S2SV_blank>use<S2SV_blank>`--aacchcfg`<S2SV_blank>to<S2SV_blank>force<S2SV_blank>config\\n"" ) ) ; ctx -> hdr . nb_ch = ctx -> aacchcfg = 2 ; } } if ( nb_blocks_per_frame == 2 ) { u32 pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; gf_m4a_parse_program_config_element ( ctx -> bs , & ctx -> acfg ) ; if ( ! ctx -> hdr . no_crc ) gf_bs_skip_bytes ( ctx -> bs , 2 ) ; ctx -> hdr . hdr_size += ( u32 ) gf_bs_get_position ( ctx -> bs ) - pos ; } if ( ctx -> hdr . nb_ch == 7 ) ctx -> hdr . nb_ch = 8 ; if ( ctx -> hdr . frame_size + 1 < remain ) { u32 next_frame = ctx -> hdr . frame_size ; if ( ( sync [ next_frame ] != 0xFF ) || ( ( sync [ next_frame + 1 ] & 0xF0 ) != 0xF0 ) ) { GF_LOG ( ctx -> nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>invalid<S2SV_blank>next<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>sync,<S2SV_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } } else if ( pck ) { if ( ctx -> timescale && ! prev_pck_size && ( cts != GF_FILTER_NO_TS ) ) { ctx -> cts = cts ; } break ; } adts_dmx_check_pid ( filter , ctx ) ; if ( ! ctx -> is_playing ) { ctx -> resume_from = 1 + ctx -> adts_buffer_size - remain ; return GF_OK ; } ctx -> nb_frames ++ ; size = ctx -> hdr . frame_size - ctx -> hdr . hdr_size ; offset = ctx -> hdr . hdr_size ; if ( ( nb_blocks_per_frame == 2 ) && ! ctx -> hdr . no_crc ) size -= 2 ; if ( ctx -> in_seek ) { u64 nb_samples_at_seek = ( u64 ) ( ctx -> start_range * GF_M4ASampleRates [ ctx -> sr_idx ] ) ; if ( ctx -> cts + ctx -> dts_inc >= nb_samples_at_seek ) { ctx -> in_seek = GF_FALSE ; } } bytes_to_drop = ctx -> hdr . frame_size ; if ( ctx -> timescale && ! prev_pck_size && ( cts != GF_FILTER_NO_TS ) ) { ctx -> cts = cts ; cts = GF_FILTER_NO_TS ; } if ( ! ctx -> in_seek ) { dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; memcpy ( output , sync + offset , size ) ; gf_filter_pck_set_dts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_duration ( dst_pck , ctx -> dts_inc ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; gf_filter_pck_set_sap ( dst_pck , GF_FILTER_SAP_1 ) ; if ( ctx -> byte_offset != GF_FILTER_NO_BO ) { gf_filter_pck_set_byte_offset ( dst_pck , ctx -> byte_offset + ctx -> hdr . hdr_size ) ; } gf_filter_pck_send ( dst_pck ) ; } adts_dmx_update_cts ( ctx ) ; if ( bytes_to_drop > remain ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>truncated<S2SV_blank>ADTS<S2SV_blank>frame!\\n"" ) ) ; bytes_to_drop = remain ; } drop_byte : if ( ! bytes_to_drop ) { bytes_to_drop = 1 ; } start += bytes_to_drop ; remain -= bytes_to_drop ; if ( prev_pck_size ) { if ( prev_pck_size > bytes_to_drop ) prev_pck_size -= bytes_to_drop ; else { prev_pck_size = 0 ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = pck ; if ( pck ) gf_filter_pck_ref_props ( & ctx -> src_pck ) ; } } if ( ctx -> byte_offset != GF_FILTER_NO_BO ) ctx -> byte_offset += bytes_to_drop ; } if ( ! pck ) { ctx -> adts_buffer_size = 0 ; return adts_dmx_process ( filter ) ; } else { if ( remain ) { memmove ( ctx -> adts_buffer , start , remain ) ; } ctx -> adts_buffer_size = remain ; gf_filter_pid_drop_packet ( ctx -> ipid ) ; } return GF_OK ; }
","<S2SV_ModStart> break ; } if ( ctx -> hdr . frame_size < ctx -> hdr . hdr_size ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>Corrupted<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header,<S2SV_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; }
",gpac@gpac/22774aa9e62f586319c8f107f5bae950fed900bc,CVE-2021-30019,https://github.com/gpac/gpac/commit/22774aa9e62f586319c8f107f5bae950fed900bc,2021-04-19T20:15Z,"<S2SV_StartBug> adts_dmx_check_pid ( filter , ctx ) ; <S2SV_EndBug>"
7084,CWE-787,"static void InsertRow ( Image * image , unsigned char * p , ssize_t y , int bpp , ExceptionInfo * exception ) { int bit ; Quantum index ; register Quantum * q ; ssize_t x ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }
","<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index
",ImageMagick@ImageMagick/b60d1ed0af37c50b91a40937825b4c61e8458095,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/b60d1ed0af37c50b91a40937825b4c61e8458095,2017-04-20T18:59Z,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug>
6806,CWE-476,"static int cit_get_packet_size ( struct gspca_dev * gspca_dev ) { struct usb_host_interface * alt ; struct usb_interface * intf ; intf = usb_ifnum_to_if ( gspca_dev -> dev , gspca_dev -> iface ) ; alt = usb_altnum_to_altsetting ( intf , gspca_dev -> alt ) ; if ( ! alt ) { pr_err ( ""Couldn\'t<S2SV_blank>get<S2SV_blank>altsetting\\n"" ) ; return - EIO ; } return le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; }
","<S2SV_ModStart> EIO ; } if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;
",torvalds@linux/a246b4d547708f33ff4d4b9a7a5dbac741dc89d8,CVE-2020-11668,https://github.com/torvalds/linux/commit/a246b4d547708f33ff4d4b9a7a5dbac741dc89d8,2020-04-09T21:15Z,<S2SV_StartBug> return le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug>
1590,CWE-119,"static REFERENCE_MODE read_frame_reference_mode ( const VP9_COMMON * cm , vp9_reader * r ) { if ( is_compound_reference_allowed ( cm ) ) { return vp9_read_bit ( r ) ? ( vp9_read_bit ( r ) ? REFERENCE_MODE_SELECT : COMPOUND_REFERENCE ) : SINGLE_REFERENCE ; } else { return SINGLE_REFERENCE ; } }
","<S2SV_ModStart> * cm , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> ) { return vpx_read_bit <S2SV_ModEnd> ( r ) <S2SV_ModStart> ) ? ( vpx_read_bit <S2SV_ModEnd> ( r )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_read_bit ( r ) ? ( vp9_read_bit ( r ) ? REFERENCE_MODE_SELECT <S2SV_EndBug>
4245,CWE-401,"struct clock_source * dce110_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce110_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } BREAK_TO_DEBUGGER ( ) ; return NULL ; }
","<S2SV_ModStart> base ; } kfree ( clk_src ) ;
",torvalds@linux/055e547478a11a6360c7ce05e2afc3e366968a12,CVE-2019-19083,https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12,2019-11-18T06:15Z,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug>
3158,CWE-20,"void exit_io_context ( void ) { struct io_context * ioc ; task_lock ( current ) ; ioc = current -> io_context ; current -> io_context = NULL ; task_unlock ( current ) ; if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; }
","<S2SV_ModStart> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; ioc <S2SV_ModStart> ; ioc = task <S2SV_ModEnd> -> io_context ; <S2SV_ModStart> -> io_context ; task <S2SV_ModEnd> -> io_context = <S2SV_ModStart> ; task_unlock ( task <S2SV_ModEnd> ) ; if
",torvalds@linux/b69f2292063d2caf37ca9aec7d63ded203701bf3,CVE-2012-0879,https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3,2012-05-17T11:00Z,<S2SV_StartBug> void exit_io_context ( void ) <S2SV_EndBug> <S2SV_StartBug> task_lock ( current ) ; <S2SV_EndBug> <S2SV_StartBug> ioc = current -> io_context ; <S2SV_EndBug> <S2SV_StartBug> current -> io_context = NULL ; <S2SV_EndBug> <S2SV_StartBug> task_unlock ( current ) ; <S2SV_EndBug>
8300,CWE-20,"static int x25_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct x25_sock * x25 = x25_sk ( sk ) ; struct sockaddr_x25 * sx25 = ( struct sockaddr_x25 * ) msg -> msg_name ; size_t copied ; int qbit , header_len ; struct sk_buff * skb ; unsigned char * asmptr ; int rc = - ENOTCONN ; lock_sock ( sk ) ; if ( x25 -> neighbour == NULL ) goto out ; header_len = x25 -> neighbour -> extended ? X25_EXT_MIN_LEN : X25_STD_MIN_LEN ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; if ( flags & MSG_OOB ) { rc = - EINVAL ; if ( sock_flag ( sk , SOCK_URGINLINE ) || ! skb_peek ( & x25 -> interrupt_in_queue ) ) goto out ; skb = skb_dequeue ( & x25 -> interrupt_in_queue ) ; if ( ! pskb_may_pull ( skb , X25_STD_MIN_LEN ) ) goto out_free_dgram ; skb_pull ( skb , X25_STD_MIN_LEN ) ; if ( test_bit ( X25_Q_BIT_FLAG , & x25 -> flags ) ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = 0x00 ; } msg -> msg_flags |= MSG_OOB ; } else { release_sock ( sk ) ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ) ; lock_sock ( sk ) ; if ( ! skb ) goto out ; if ( ! pskb_may_pull ( skb , header_len ) ) goto out_free_dgram ; qbit = ( skb -> data [ 0 ] & X25_Q_BIT ) == X25_Q_BIT ; skb_pull ( skb , header_len ) ; if ( test_bit ( X25_Q_BIT_FLAG , & x25 -> flags ) ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } msg -> msg_flags |= MSG_EOR ; rc = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( rc ) goto out_free_dgram ; if ( sx25 ) { sx25 -> sx25_family = AF_X25 ; sx25 -> sx25_addr = x25 -> dest_addr ; } msg -> msg_namelen = sizeof ( struct sockaddr_x25 ) ; x25_check_rbuf ( sk ) ; rc = copied ; out_free_dgram : skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return rc ; }
","<S2SV_ModStart> -> dest_addr ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> = sizeof ( * sx25 ) ; } <S2SV_ModEnd> x25_check_rbuf ( sk
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = sizeof ( struct sockaddr_x25 ) ; <S2SV_EndBug>
714,CWE-416,"static int l2tp_ip6_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_l2tpip6 * addr = ( struct sockaddr_l2tpip6 * ) uaddr ; struct net * net = sock_net ( sk ) ; __be32 v4addr = 0 ; int addr_type ; int err ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET6 ) return - EINVAL ; if ( addr_len < sizeof ( * addr ) ) return - EINVAL ; addr_type = ipv6_addr_type ( & addr -> l2tp_addr ) ; if ( addr_type == IPV6_ADDR_MAPPED ) return - EADDRNOTAVAIL ; if ( addr_type & IPV6_ADDR_MULTICAST ) return - EADDRNOTAVAIL ; err = - EADDRINUSE ; read_lock_bh ( & l2tp_ip6_lock ) ; if ( __l2tp_ip6_bind_lookup ( net , & addr -> l2tp_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip6_lock ) ; lock_sock ( sk ) ; err = - EINVAL ; if ( sk -> sk_state != TCP_CLOSE ) goto out_unlock ; rcu_read_lock ( ) ; if ( addr_type != IPV6_ADDR_ANY ) { struct net_device * dev = NULL ; if ( addr_type & IPV6_ADDR_LINKLOCAL ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && addr -> l2tp_scope_id ) { sk -> sk_bound_dev_if = addr -> l2tp_scope_id ; } if ( ! sk -> sk_bound_dev_if ) goto out_unlock_rcu ; err = - ENODEV ; dev = dev_get_by_index_rcu ( sock_net ( sk ) , sk -> sk_bound_dev_if ) ; if ( ! dev ) goto out_unlock_rcu ; } v4addr = LOOPBACK4_IPV6 ; err = - EADDRNOTAVAIL ; if ( ! ipv6_chk_addr ( sock_net ( sk ) , & addr -> l2tp_addr , dev , 0 ) ) goto out_unlock_rcu ; } rcu_read_unlock ( ) ; inet -> inet_rcv_saddr = inet -> inet_saddr = v4addr ; sk -> sk_v6_rcv_saddr = addr -> l2tp_addr ; np -> saddr = addr -> l2tp_addr ; l2tp_ip6_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip6_lock ) ; sk_add_bind_node ( sk , & l2tp_ip6_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip6_lock ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return 0 ; out_unlock_rcu : rcu_read_unlock ( ) ; out_unlock : release_sock ( sk ) ; return err ; out_in_use : read_unlock_bh ( & l2tp_ip6_lock ) ; return err ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> addr -> l2tp_family <S2SV_ModStart> ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ; if (
",torvalds@linux/32c231164b762dddefa13af5a0101032c70b50ef,CVE-2016-10200,https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef,2017-03-07T21:59Z,"<S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> <S2SV_StartBug> if ( sk -> sk_state != TCP_CLOSE ) <S2SV_EndBug>"
2505,CWE-264,"const char * string_of_NPNVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPNVxDisplay ) ; _ ( NPNVxtAppContext ) ; _ ( NPNVnetscapeWindow ) ; _ ( NPNVjavascriptEnabledBool ) ; _ ( NPNVasdEnabledBool ) ; _ ( NPNVisOfflineBool ) ; _ ( NPNVserviceManager ) ; _ ( NPNVDOMElement ) ; _ ( NPNVDOMWindow ) ; _ ( NPNVToolkit ) ; _ ( NPNVSupportsXEmbedBool ) ; _ ( NPNVWindowNPObject ) ; _ ( NPNVPluginElementNPObject ) ; _ ( NPNVSupportsWindowless ) ; # undef _ default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPNVserviceManager ) ; _ ( 11 , NPNVDOMElement ) ; _ ( 12 , NPNVDOMWindow ) ; _ ( 13 , NPNVToolkit ) ; # undef _ default : str = ""<unknown<S2SV_blank>variable>"" ; break ; } break ; } return str ; }
","<S2SV_ModStart> NPNVSupportsWindowless ) ; _ ( NPNVprivateModeBool ) ; _ ( NPNVsupportsAdvancedKeyHandling ) ;
",davidben@nspluginwrapper/7e4ab8e1189846041f955e6c83f72bc1624e7a98,CVE-2011-2486,https://github.com/davidben/nspluginwrapper/commit/7e4ab8e1189846041f955e6c83f72bc1624e7a98,2012-11-19T12:10Z,<S2SV_StartBug> # undef _ <S2SV_EndBug>
3194,CWE-119,"static int zerocopy_sg_from_iovec ( struct sk_buff * skb , const struct iovec * from , int offset , size_t count ) { int len = iov_length ( from , count ) - offset ; int copy = skb_headlen ( skb ) ; int size , offset1 = 0 ; int i = 0 ; while ( count && ( offset >= from -> iov_len ) ) { offset -= from -> iov_len ; ++ from ; -- count ; } while ( count && ( copy > 0 ) ) { size = min_t ( unsigned int , copy , from -> iov_len - offset ) ; if ( copy_from_user ( skb -> data + offset1 , from -> iov_base + offset , size ) ) return - EFAULT ; if ( copy > size ) { ++ from ; -- count ; offset = 0 ; } else offset += size ; copy -= size ; offset1 += size ; } if ( len == offset1 ) return 0 ; while ( count -- ) { struct page * page [ MAX_SKB_FRAGS ] ; int num_pages ; unsigned long base ; unsigned long truesize ; len = from -> iov_len - offset ; if ( ! len ) { offset = 0 ; ++ from ; continue ; } base = ( unsigned long ) from -> iov_base + offset ; size = ( ( base & ~ PAGE_MASK ) + len + ~ PAGE_MASK ) >> PAGE_SHIFT ; num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; if ( ( num_pages != size ) || ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) { for ( i = 0 ; i < num_pages ; i ++ ) put_page ( page [ i ] ) ; return - EFAULT ; } truesize = size * PAGE_SIZE ; skb -> data_len += len ; skb -> len += len ; skb -> truesize += truesize ; atomic_add ( truesize , & skb -> sk -> sk_wmem_alloc ) ; while ( len ) { int off = base & ~ PAGE_MASK ; int size = min_t ( int , len , PAGE_SIZE - off ) ; __skb_fill_page_desc ( skb , i , page [ i ] , off , size ) ; skb_shinfo ( skb ) -> nr_frags ++ ; base += size ; len -= size ; i ++ ; } offset = 0 ; ++ from ; } return 0 ; }
","<S2SV_ModStart> >> PAGE_SHIFT ; if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> num_pages != size <S2SV_ModStart> num_pages != size <S2SV_ModEnd> ) { for
",torvalds@linux/b92946e2919134ebe2a4083e4302236295ea2a73,CVE-2012-2119,https://github.com/torvalds/linux/commit/b92946e2919134ebe2a4083e4302236295ea2a73,2013-01-22T23:55Z,"<S2SV_StartBug> num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( num_pages != size ) || <S2SV_EndBug>"
6882,CWE-74,"static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( ""export-desktop-XXXXXX"" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , "".service"" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree gchar * expected_dbus_name = g_strndup ( name , strlen ( name ) - strlen ( "".service"" ) ) ; dbus_name = g_key_file_get_string ( keyfile , ""D-BUS<S2SV_blank>Service"" , ""Name"" , NULL ) ; if ( dbus_name == NULL || strcmp ( dbus_name , expected_dbus_name ) != 0 ) { return flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""D-Bus<S2SV_blank>service<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>name"" ) , name ) ; } } if ( g_str_has_suffix ( name , "".desktop"" ) ) { gsize length ; g_auto ( GStrv ) tags = g_key_file_get_string_list ( metadata , ""Application"" , ""tags"" , & length , NULL ) ; if ( tags != NULL ) { g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak-Tags"" , ( const char * const * ) tags , length ) ; } g_key_file_set_string ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak"" , app ) ; if ( previous_ids != NULL ) { const char * X_FLATPAK_RENAMED_FROM = ""X-Flatpak-RenamedFrom"" ; g_auto ( GStrv ) renamed_from = g_key_file_get_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , NULL , NULL ) ; g_autoptr ( GPtrArray ) merged = g_ptr_array_new_with_free_func ( g_free ) ; g_autoptr ( GHashTable ) seen = g_hash_table_new ( g_str_hash , g_str_equal ) ; const char * new_suffix ; for ( i = 0 ; renamed_from != NULL && renamed_from [ i ] != NULL ; i ++ ) { if ( ! g_hash_table_contains ( seen , renamed_from [ i ] ) ) { gchar * copy = g_strdup ( renamed_from [ i ] ) ; g_hash_table_insert ( seen , copy , copy ) ; g_ptr_array_add ( merged , g_steal_pointer ( & copy ) ) ; } } g_assert ( g_str_has_prefix ( name , app ) ) ; new_suffix = name + strlen ( app ) ; for ( i = 0 ; previous_ids [ i ] != NULL ; i ++ ) { g_autofree gchar * previous_desktop = g_strconcat ( previous_ids [ i ] , new_suffix , NULL ) ; if ( ! g_hash_table_contains ( seen , previous_desktop ) ) { g_hash_table_insert ( seen , previous_desktop , previous_desktop ) ; g_ptr_array_add ( merged , g_steal_pointer ( & previous_desktop ) ) ; } } if ( merged -> len > 0 ) { g_ptr_array_add ( merged , NULL ) ; g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , ( const char * const * ) merged -> pdata , merged -> len - 1 ) ; } } } groups = g_key_file_get_groups ( keyfile , NULL ) ; for ( i = 0 ; groups [ i ] != NULL ; i ++ ) { g_auto ( GStrv ) flatpak_run_opts = g_key_file_get_string_list ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL , NULL ) ; g_autofree char * flatpak_run_args = format_flatpak_run_args_from_run_opts ( flatpak_run_opts ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""TryExec"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-GNOME-Bugzilla-ExtraInfoScript"" , NULL ) ; new_exec = g_string_new ( """" ) ; g_string_append_printf ( new_exec , FLATPAK_BINDIR ""/flatpak<S2SV_blank>run<S2SV_blank>--branch=%s<S2SV_blank>--arch=%s"" , escaped_branch , escaped_arch ) ; if ( flatpak_run_args != NULL ) g_string_append_printf ( new_exec , ""%s"" , flatpak_run_args ) ; old_exec = g_key_file_get_string ( keyfile , groups [ i ] , ""Exec"" , NULL ) ; if ( old_exec && g_shell_parse_argv ( old_exec , & old_argc , & old_argv , NULL ) && old_argc >= 1 ) { int j ; g_autofree char * command = maybe_quote ( old_argv [ 0 ] ) ; g_string_append_printf ( new_exec , ""<S2SV_blank>--command=%s"" , command ) ; for ( j = 1 ; j < old_argc ; j ++ ) { if ( strcasecmp ( old_argv [ j ] , ""%f"" ) == 0 || strcasecmp ( old_argv [ j ] , ""%u"" ) == 0 ) { g_string_append ( new_exec , ""<S2SV_blank>--file-forwarding"" ) ; break ; } } g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; for ( j = 1 ; j < old_argc ; j ++ ) { g_autofree char * arg = maybe_quote ( old_argv [ j ] ) ; if ( strcasecmp ( arg , ""%f"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; else if ( strcasecmp ( arg , ""%u"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@u<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; else if ( g_str_has_prefix ( arg , ""@@"" ) ) g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ; else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ; } } else { g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; } g_key_file_set_string ( keyfile , groups [ i ] , G_KEY_FILE_DESKTOP_KEY_EXEC , new_exec -> str ) ; } new_data = g_key_file_to_data ( keyfile , & new_data_len , error ) ; if ( new_data == NULL ) goto out ; if ( ! flatpak_open_in_tmpdir_at ( parent_fd , 0755 , tmpfile_name , & out_stream , cancellable , error ) ) goto out ; if ( ! g_output_stream_write_all ( out_stream , new_data , new_data_len , NULL , cancellable , error ) ) goto out ; if ( ! g_output_stream_close ( out_stream , cancellable , error ) ) goto out ; if ( target ) * target = g_steal_pointer ( & tmpfile_name ) ; ret = TRUE ; out : if ( new_exec != NULL ) g_string_free ( new_exec , TRUE ) ; return ret ; }
","<S2SV_ModStart> ""@@"" ) ) { flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""Invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s"" <S2SV_ModEnd> ) , arg <S2SV_ModStart> arg ) ; goto out ; }
",flatpak@flatpak/a7401e638bf0c03102039e216ab1081922f140ae,CVE-2021-21381,https://github.com/flatpak/flatpak/commit/a7401e638bf0c03102039e216ab1081922f140ae,2021-03-11T17:15Z,"<S2SV_StartBug> g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ; <S2SV_EndBug>"
2481,CWE-120,"void mwifiex_set_wmm_params ( struct mwifiex_private * priv , struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { const u8 * vendor_ie ; const u8 * wmm_ie ; u8 wmm_oui [ ] = { 0x00 , 0x50 , 0xf2 , 0x02 } ; vendor_ie = cfg80211_find_vendor_ie ( WLAN_OUI_MICROSOFT , WLAN_OUI_TYPE_MICROSOFT_WMM , params -> beacon . tail , params -> beacon . tail_len ) ; if ( vendor_ie ) { wmm_ie = vendor_ie ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; priv -> wmm_enabled = 1 ; } else { memset ( & bss_cfg -> wmm_info , 0 , sizeof ( bss_cfg -> wmm_info ) ) ; memcpy ( & bss_cfg -> wmm_info . oui , wmm_oui , sizeof ( wmm_oui ) ) ; bss_cfg -> wmm_info . subtype = MWIFIEX_WMM_SUBTYPE ; bss_cfg -> wmm_info . version = MWIFIEX_WMM_VERSION ; priv -> wmm_enabled = 0 ; } bss_cfg -> qos_info = 0x00 ; return ; }
","<S2SV_ModStart> = vendor_ie ; if ( <S2SV_ModEnd> * ( wmm_ie <S2SV_ModStart> + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 )
",torvalds@linux/7caac62ed598a196d6ddf8d9c121e12e082cac3a,CVE-2019-14814,https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a,2019-09-20T19:15Z,"<S2SV_StartBug> memcpy ( & bss_cfg -> wmm_info , wmm_ie + <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; <S2SV_EndBug>"
2927,CWE-682,"static int find_low_bit ( unsigned int x ) { int i ; for ( i = 0 ; i <= 31 ; i ++ ) { if ( x & ( 1 << i ) ) return i ; } return 0 ; }
","<S2SV_ModStart> x & ( 1U << ( unsigned int ) <S2SV_ModEnd> i ) )
",jsummers@imageworsener/a00183107d4b84bc8a714290e824ca9c68dac738,CVE-2017-8326,https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738,2017-04-29T20:59Z,<S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug>
2614,CWE-264,"static int wrmsr_interception ( struct vcpu_svm * svm ) { struct msr_data msr ; u32 ecx = svm -> vcpu . arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( svm -> vcpu . arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( svm -> vcpu . arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; svm -> next_rip = kvm_rip_read ( & svm -> vcpu ) + 2 ; if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( & svm -> vcpu , 0 ) ; } else { trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( & svm -> vcpu ) ; } return 1 ; }
","<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( & svm
",torvalds@linux/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,CVE-2014-3610,https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,2014-11-10T11:55Z,"<S2SV_StartBug> if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { <S2SV_EndBug>"
2093,CWE-22,"void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d<S2SV_blank>%H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
","<S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> ) ) { if ( page_name_is_good ( page ) ) { <S2SV_ModStart> ; return ; } <S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> if ( page && page_name_is_good ( page )
",yarolig@didiwiki/5e5c796617e1712905dc5462b94bd5e6c08d15ea,CVE-2013-7448,https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea,2016-02-23T19:59Z,"<S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug>"
3960,CWE-415,"static OM_uint32 init_ctx_reselect ( OM_uint32 * minor_status , spnego_gss_ctx_id_t sc , OM_uint32 acc_negState , gss_OID supportedMech , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * tokflag ) { OM_uint32 tmpmin ; size_t i ; generic_gss_release_oid ( & tmpmin , & sc -> internal_mech ) ; gss_delete_sec_context ( & tmpmin , & sc -> ctx_handle , GSS_C_NO_BUFFER ) ; for ( i = 0 ; i < sc -> mech_set -> count ; i ++ ) { if ( g_OID_equal ( supportedMech , & sc -> mech_set -> elements [ i ] ) ) break ; } if ( i == sc -> mech_set -> count ) return GSS_S_DEFECTIVE_TOKEN ; sc -> internal_mech = & sc -> mech_set -> elements [ i ] ; if ( acc_negState != REQUEST_MIC ) return GSS_S_DEFECTIVE_TOKEN ; sc -> mech_complete = 0 ; sc -> mic_reqd = 1 ; * negState = REQUEST_MIC ; * tokflag = CONT_TOKEN_SEND ; return GSS_S_CONTINUE_NEEDED ; }
","<S2SV_ModStart> ; size_t i <S2SV_ModEnd> ; gss_delete_sec_context (
",krb5@krb5/f18ddf5d82de0ab7591a36e465bc24225776940f,CVE-2014-4343,https://github.com/krb5/krb5/commit/f18ddf5d82de0ab7591a36e465bc24225776940f,2014-08-14T05:01Z,<S2SV_StartBug> size_t i ; <S2SV_EndBug>
1477,CWE-119,"int vp8_regulate_q ( VP8_COMP * cpi , int target_bits_per_frame ) { int Q = cpi -> active_worst_quality ; cpi -> mb . zbin_over_quant = 0 ; if ( cpi -> oxcf . fixed_q >= 0 ) { Q = cpi -> oxcf . fixed_q ; if ( cpi -> common . frame_type == KEY_FRAME ) { Q = cpi -> oxcf . key_q ; } else if ( cpi -> oxcf . number_of_layers == 1 && cpi -> common . refresh_alt_ref_frame ) { Q = cpi -> oxcf . alt_q ; } else if ( cpi -> oxcf . number_of_layers == 1 && cpi -> common . refresh_golden_frame ) { Q = cpi -> oxcf . gold_q ; } } else { int i ; int last_error = INT_MAX ; int target_bits_per_mb ; int bits_per_mb_at_this_q ; double correction_factor ; if ( cpi -> common . frame_type == KEY_FRAME ) correction_factor = cpi -> key_frame_rate_correction_factor ; else { if ( cpi -> oxcf . number_of_layers == 1 && ( cpi -> common . refresh_alt_ref_frame || cpi -> common . refresh_golden_frame ) ) correction_factor = cpi -> gf_rate_correction_factor ; else correction_factor = cpi -> rate_correction_factor ; } if ( target_bits_per_frame >= ( INT_MAX >> BPER_MB_NORMBITS ) ) target_bits_per_mb = ( target_bits_per_frame / cpi -> common . MBs ) << BPER_MB_NORMBITS ; else target_bits_per_mb = ( target_bits_per_frame << BPER_MB_NORMBITS ) / cpi -> common . MBs ; i = cpi -> active_best_quality ; do { bits_per_mb_at_this_q = ( int ) ( .5 + correction_factor * vp8_bits_per_mb [ cpi -> common . frame_type ] [ i ] ) ; if ( bits_per_mb_at_this_q <= target_bits_per_mb ) { if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) Q = i ; else Q = i - 1 ; break ; } else last_error = bits_per_mb_at_this_q - target_bits_per_mb ; } while ( ++ i <= cpi -> active_worst_quality ) ; if ( Q >= MAXQ ) { int zbin_oqmax ; double Factor = 0.99 ; double factor_adjustment = 0.01 / 256.0 ; if ( cpi -> common . frame_type == KEY_FRAME ) zbin_oqmax = 0 ; else if ( cpi -> oxcf . number_of_layers == 1 && ( cpi -> common . refresh_alt_ref_frame || ( cpi -> common . refresh_golden_frame && ! cpi -> source_alt_ref_active ) ) ) zbin_oqmax = 16 ; else zbin_oqmax = ZBIN_OQ_MAX ; while ( cpi -> mb . zbin_over_quant < zbin_oqmax ) { cpi -> mb . zbin_over_quant ++ ; if ( cpi -> mb . zbin_over_quant > zbin_oqmax ) cpi -> mb . zbin_over_quant = zbin_oqmax ; bits_per_mb_at_this_q = ( int ) ( Factor * bits_per_mb_at_this_q ) ; Factor += factor_adjustment ; if ( Factor >= 0.999 ) Factor = 0.999 ; if ( bits_per_mb_at_this_q <= target_bits_per_mb ) break ; } } } return Q ; }
","<S2SV_ModStart> -> active_worst_quality ; if ( cpi -> force_maxqp == 1 ) { cpi -> active_worst_quality = cpi -> worst_quality ; return cpi -> worst_quality ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> int Q = cpi -> active_worst_quality ; <S2SV_EndBug>
120,CWE-285,"int jffs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int rc , xprefix ; switch ( type ) { case ACL_TYPE_ACCESS : xprefix = JFFS2_XPREFIX_ACL_ACCESS ; if ( acl ) { umode_t mode = inode -> i_mode ; rc = posix_acl_equiv_mode ( acl , & mode ) ; if ( rc < 0 ) return rc ; if ( inode -> i_mode != mode ) { struct iattr attr ; attr . ia_valid = ATTR_MODE | ATTR_CTIME ; attr . ia_mode = mode ; attr . ia_ctime = CURRENT_TIME_SEC ; rc = jffs2_do_setattr ( inode , & attr ) ; if ( rc < 0 ) return rc ; } if ( rc == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : xprefix = JFFS2_XPREFIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } rc = __jffs2_set_acl ( inode , xprefix , acl ) ; if ( ! rc ) set_cached_acl ( inode , type , acl ) ; return rc ; }
","<S2SV_ModStart> { umode_t mode ; rc = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( rc <S2SV_ModEnd> ) return rc <S2SV_ModStart> rc ; } <S2SV_ModEnd> } break ;
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc == 0 ) <S2SV_EndBug>"
1888,CWE-119,"static LAYER_CONTEXT * get_layer_context ( SVC * svc ) { return svc -> number_temporal_layers > 1 ? & svc -> layer_context [ svc -> temporal_layer_id ] : & svc -> layer_context [ svc -> spatial_layer_id ] ; }
","<S2SV_ModStart> * get_layer_context ( VP9_COMP * const cpi ) { if ( is_one_pass_cbr_svc ( cpi ) ) return & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers + cpi -> svc . temporal_layer_id ] ; else return ( cpi -> svc . <S2SV_ModEnd> number_temporal_layers > 1 <S2SV_ModStart> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) ? & cpi -> svc . layer_context [ cpi -> svc . <S2SV_ModEnd> temporal_layer_id ] : <S2SV_ModStart> ] : & cpi -> svc . layer_context [ cpi -> svc . <S2SV_ModEnd> spatial_layer_id ] ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> static LAYER_CONTEXT * get_layer_context ( SVC * svc ) { <S2SV_EndBug> <S2SV_StartBug> return svc -> number_temporal_layers > 1 ? <S2SV_EndBug> <S2SV_StartBug> & svc -> layer_context [ svc -> spatial_layer_id ] ; <S2SV_EndBug>
7191,CWE-552,"static long _syscall ( long num , long arg1 , long arg2 , long arg3 , long arg4 , long arg5 , long arg6 ) { long ret = - 1 ; oe_errno = 0 ; switch ( num ) { # if defined ( OE_SYS_creat ) case OE_SYS_creat : { const char * pathname = ( const char * ) arg1 ; oe_mode_t mode = ( oe_mode_t ) arg2 ; int flags = ( OE_O_CREAT | OE_O_WRONLY | OE_O_TRUNC ) ; ret = oe_open ( pathname , flags , mode ) ; if ( oe_errno == OE_ENOENT ) { oe_errno = OE_ENOSYS ; goto done ; } goto done ; } # endif # if defined ( OE_SYS_open ) case OE_SYS_open : { const char * pathname = ( const char * ) arg1 ; int flags = ( int ) arg2 ; uint32_t mode = ( uint32_t ) arg3 ; ret = oe_open ( pathname , flags , mode ) ; if ( ret < 0 && oe_errno == OE_ENOENT ) goto done ; goto done ; } # endif case OE_SYS_openat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; int flags = ( int ) arg3 ; uint32_t mode = ( uint32_t ) arg4 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } ret = oe_open ( pathname , flags , mode ) ; if ( ret < 0 && oe_errno == OE_ENOENT ) goto done ; goto done ; } case OE_SYS_lseek : { int fd = ( int ) arg1 ; ssize_t off = ( ssize_t ) arg2 ; int whence = ( int ) arg3 ; ret = oe_lseek ( fd , off , whence ) ; goto done ; } case OE_SYS_pread64 : { const int fd = ( int ) arg1 ; void * const buf = ( void * ) arg2 ; const size_t count = ( size_t ) arg3 ; const oe_off_t offset = ( oe_off_t ) arg4 ; ret = oe_pread ( fd , buf , count , offset ) ; goto done ; } case OE_SYS_pwrite64 : { const int fd = ( int ) arg1 ; const void * const buf = ( void * ) arg2 ; const size_t count = ( size_t ) arg3 ; const oe_off_t offset = ( oe_off_t ) arg4 ; ret = oe_pwrite ( fd , buf , count , offset ) ; goto done ; } case OE_SYS_readv : { int fd = ( int ) arg1 ; const struct oe_iovec * iov = ( const struct oe_iovec * ) arg2 ; int iovcnt = ( int ) arg3 ; ret = oe_readv ( fd , iov , iovcnt ) ; goto done ; } case OE_SYS_writev : { int fd = ( int ) arg1 ; const struct oe_iovec * iov = ( const struct oe_iovec * ) arg2 ; int iovcnt = ( int ) arg3 ; ret = oe_writev ( fd , iov , iovcnt ) ; goto done ; } case OE_SYS_read : { int fd = ( int ) arg1 ; void * buf = ( void * ) arg2 ; size_t count = ( size_t ) arg3 ; ret = oe_read ( fd , buf , count ) ; goto done ; } case OE_SYS_write : { int fd = ( int ) arg1 ; const void * buf = ( void * ) arg2 ; size_t count = ( size_t ) arg3 ; ret = oe_write ( fd , buf , count ) ; goto done ; } case OE_SYS_close : { int fd = ( int ) arg1 ; ret = oe_close ( fd ) ; goto done ; } case OE_SYS_dup : { int fd = ( int ) arg1 ; ret = oe_dup ( fd ) ; goto done ; } case OE_SYS_flock : { int fd = ( int ) arg1 ; int operation = ( int ) arg2 ; ret = oe_flock ( fd , operation ) ; goto done ; } case OE_SYS_fsync : { const int fd = ( int ) arg1 ; ret = oe_fsync ( fd ) ; goto done ; } case OE_SYS_fdatasync : { const int fd = ( int ) arg1 ; ret = oe_fdatasync ( fd ) ; goto done ; } # if defined ( OE_SYS_dup2 ) case OE_SYS_dup2 : { int oldfd = ( int ) arg1 ; int newfd = ( int ) arg2 ; ret = oe_dup2 ( oldfd , newfd ) ; goto done ; } # endif case OE_SYS_dup3 : { int oldfd = ( int ) arg1 ; int newfd = ( int ) arg2 ; int flags = ( int ) arg3 ; if ( flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } ret = oe_dup2 ( oldfd , newfd ) ; goto done ; } # if defined ( OE_SYS_stat ) case OE_SYS_stat : { const char * pathname = ( const char * ) arg1 ; struct oe_stat_t * buf = ( struct oe_stat_t * ) arg2 ; ret = oe_stat ( pathname , buf ) ; goto done ; } # endif case OE_SYS_newfstatat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; struct oe_stat_t * buf = ( struct oe_stat_t * ) arg3 ; int flags = ( int ) arg4 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } ret = oe_stat ( pathname , buf ) ; goto done ; } case OE_SYS_fstat : { const int fd = ( int ) arg1 ; struct oe_stat_t * const buf = ( struct oe_stat_t * ) arg2 ; ret = oe_fstat ( fd , buf ) ; goto done ; } # if defined ( OE_SYS_link ) case OE_SYS_link : { const char * oldpath = ( const char * ) arg1 ; const char * newpath = ( const char * ) arg2 ; ret = oe_link ( oldpath , newpath ) ; goto done ; } # endif case OE_SYS_linkat : { int olddirfd = ( int ) arg1 ; const char * oldpath = ( const char * ) arg2 ; int newdirfd = ( int ) arg3 ; const char * newpath = ( const char * ) arg4 ; int flags = ( int ) arg5 ; if ( olddirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( newdirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } ret = oe_link ( oldpath , newpath ) ; goto done ; } # if defined ( OE_SYS_unlink ) case OE_SYS_unlink : { const char * pathname = ( const char * ) arg1 ; ret = oe_unlink ( pathname ) ; goto done ; } # endif case OE_SYS_unlinkat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; int flags = ( int ) arg3 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( flags != OE_AT_REMOVEDIR && flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } if ( flags == OE_AT_REMOVEDIR ) ret = oe_rmdir ( pathname ) ; else ret = oe_unlink ( pathname ) ; goto done ; } # if defined ( OE_SYS_rename ) case OE_SYS_rename : { const char * oldpath = ( const char * ) arg1 ; const char * newpath = ( const char * ) arg2 ; ret = oe_rename ( oldpath , newpath ) ; goto done ; } # endif case OE_SYS_renameat : { int olddirfd = ( int ) arg1 ; const char * oldpath = ( const char * ) arg2 ; int newdirfd = ( int ) arg3 ; const char * newpath = ( const char * ) arg4 ; int flags = ( int ) arg5 ; if ( olddirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( newdirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } ret = oe_rename ( oldpath , newpath ) ; goto done ; } case OE_SYS_truncate : { const char * path = ( const char * ) arg1 ; ssize_t length = ( ssize_t ) arg2 ; ret = oe_truncate ( path , length ) ; goto done ; } # if defined ( OE_SYS_mkdir ) case OE_SYS_mkdir : { const char * pathname = ( const char * ) arg1 ; uint32_t mode = ( uint32_t ) arg2 ; ret = oe_mkdir ( pathname , mode ) ; goto done ; } # endif case OE_SYS_mkdirat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; uint32_t mode = ( uint32_t ) arg3 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } ret = oe_mkdir ( pathname , mode ) ; goto done ; } # if defined ( OE_SYS_rmdir ) case OE_SYS_rmdir : { const char * pathname = ( const char * ) arg1 ; ret = oe_rmdir ( pathname ) ; goto done ; } # endif # if defined ( OE_SYS_access ) case OE_SYS_access : { const char * pathname = ( const char * ) arg1 ; int mode = ( int ) arg2 ; ret = oe_access ( pathname , mode ) ; goto done ; } # endif case OE_SYS_faccessat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; int mode = ( int ) arg3 ; int flags = ( int ) arg4 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } if ( flags != 0 ) { oe_errno = OE_EINVAL ; goto done ; } ret = oe_access ( pathname , mode ) ; goto done ; } case OE_SYS_getdents64 : { unsigned int fd = ( unsigned int ) arg1 ; struct oe_dirent * ent = ( struct oe_dirent * ) arg2 ; unsigned int count = ( unsigned int ) arg3 ; ret = oe_getdents64 ( fd , ent , count ) ; goto done ; } case OE_SYS_ioctl : { int fd = ( int ) arg1 ; unsigned long request = ( unsigned long ) arg2 ; long p1 = arg3 ; long p2 = arg4 ; long p3 = arg5 ; long p4 = arg6 ; ret = oe_ioctl ( fd , request , p1 , p2 , p3 , p4 ) ; goto done ; } case OE_SYS_fcntl : { int fd = ( int ) arg1 ; int cmd = ( int ) arg2 ; uint64_t arg = ( uint64_t ) arg3 ; ret = oe_fcntl ( fd , cmd , arg ) ; goto done ; } case OE_SYS_mount : { const char * source = ( const char * ) arg1 ; const char * target = ( const char * ) arg2 ; const char * fstype = ( const char * ) arg3 ; unsigned long flags = ( unsigned long ) arg4 ; void * data = ( void * ) arg5 ; ret = oe_mount ( source , target , fstype , flags , data ) ; goto done ; } case OE_SYS_umount2 : { const char * target = ( const char * ) arg1 ; int flags = ( int ) arg2 ; ( void ) flags ; ret = oe_umount ( target ) ; goto done ; } case OE_SYS_getcwd : { char * buf = ( char * ) arg1 ; size_t size = ( size_t ) arg2 ; if ( ! oe_getcwd ( buf , size ) ) { ret = - 1 ; } else { ret = ( long ) size ; } goto done ; } case OE_SYS_chdir : { char * path = ( char * ) arg1 ; ret = oe_chdir ( path ) ; goto done ; } case OE_SYS_socket : { int domain = ( int ) arg1 ; int type = ( int ) arg2 ; int protocol = ( int ) arg3 ; ret = oe_socket ( domain , type , protocol ) ; goto done ; } case OE_SYS_connect : { int sd = ( int ) arg1 ; const struct oe_sockaddr * addr = ( const struct oe_sockaddr * ) arg2 ; oe_socklen_t addrlen = ( oe_socklen_t ) arg3 ; ret = oe_connect ( sd , addr , addrlen ) ; goto done ; } case OE_SYS_setsockopt : { int sockfd = ( int ) arg1 ; int level = ( int ) arg2 ; int optname = ( int ) arg3 ; void * optval = ( void * ) arg4 ; oe_socklen_t optlen = ( oe_socklen_t ) arg5 ; ret = oe_setsockopt ( sockfd , level , optname , optval , optlen ) ; goto done ; } case OE_SYS_getsockopt : { int sockfd = ( int ) arg1 ; int level = ( int ) arg2 ; int optname = ( int ) arg3 ; void * optval = ( void * ) arg4 ; oe_socklen_t * optlen = ( oe_socklen_t * ) arg5 ; ret = oe_getsockopt ( sockfd , level , optname , optval , optlen ) ; goto done ; } case OE_SYS_getpeername : { int sockfd = ( int ) arg1 ; struct sockaddr * addr = ( struct sockaddr * ) arg2 ; oe_socklen_t * addrlen = ( oe_socklen_t * ) arg3 ; ret = oe_getpeername ( sockfd , ( struct oe_sockaddr * ) addr , addrlen ) ; goto done ; } case OE_SYS_getsockname : { int sockfd = ( int ) arg1 ; struct sockaddr * addr = ( struct sockaddr * ) arg2 ; oe_socklen_t * addrlen = ( oe_socklen_t * ) arg3 ; ret = oe_getsockname ( sockfd , ( struct oe_sockaddr * ) addr , addrlen ) ; goto done ; } case OE_SYS_bind : { int sockfd = ( int ) arg1 ; struct oe_sockaddr * addr = ( struct oe_sockaddr * ) arg2 ; oe_socklen_t addrlen = ( oe_socklen_t ) arg3 ; ret = oe_bind ( sockfd , addr , addrlen ) ; goto done ; } case OE_SYS_listen : { int sockfd = ( int ) arg1 ; int backlog = ( int ) arg2 ; ret = oe_listen ( sockfd , backlog ) ; goto done ; } case OE_SYS_accept : { int sockfd = ( int ) arg1 ; struct oe_sockaddr * addr = ( struct oe_sockaddr * ) arg2 ; oe_socklen_t * addrlen = ( oe_socklen_t * ) arg3 ; ret = oe_accept ( sockfd , addr , addrlen ) ; goto done ; } case OE_SYS_sendto : { int sockfd = ( int ) arg1 ; const void * buf = ( void * ) arg2 ; size_t len = ( size_t ) arg3 ; int flags = ( int ) arg4 ; const struct oe_sockaddr * dest_add = ( const struct oe_sockaddr * ) arg5 ; oe_socklen_t addrlen = ( oe_socklen_t ) arg6 ; ret = oe_sendto ( sockfd , buf , len , flags , dest_add , addrlen ) ; goto done ; } case OE_SYS_recvfrom : { int sockfd = ( int ) arg1 ; void * buf = ( void * ) arg2 ; size_t len = ( size_t ) arg3 ; int flags = ( int ) arg4 ; const struct oe_sockaddr * dest_add = ( const struct oe_sockaddr * ) arg5 ; oe_socklen_t * addrlen = ( oe_socklen_t * ) arg6 ; ret = oe_recvfrom ( sockfd , buf , len , flags , dest_add , addrlen ) ; goto done ; } case OE_SYS_sendmsg : { int sockfd = ( int ) arg1 ; struct msghdr * buf = ( struct msghdr * ) arg2 ; int flags = ( int ) arg3 ; ret = oe_sendmsg ( sockfd , ( struct oe_msghdr * ) buf , flags ) ; goto done ; } case OE_SYS_recvmsg : { int sockfd = ( int ) arg1 ; struct msghdr * buf = ( struct msghdr * ) arg2 ; int flags = ( int ) arg3 ; ret = oe_recvmsg ( sockfd , ( struct oe_msghdr * ) buf , flags ) ; goto done ; } case OE_SYS_socketpair : { int domain = ( int ) arg1 ; int type = ( int ) arg2 ; int protocol = ( int ) arg3 ; int * sv = ( int * ) arg4 ; ret = oe_socketpair ( domain , type , protocol , sv ) ; goto done ; } case OE_SYS_shutdown : { int sockfd = ( int ) arg1 ; int how = ( int ) arg2 ; ret = oe_shutdown ( sockfd , how ) ; goto done ; } case OE_SYS_uname : { struct oe_utsname * buf = ( struct oe_utsname * ) arg1 ; ret = oe_uname ( buf ) ; goto done ; } # if defined ( OE_SYS_select ) case OE_SYS_select : { int nfds = ( int ) arg1 ; oe_fd_set * readfds = ( oe_fd_set * ) arg2 ; oe_fd_set * writefds = ( oe_fd_set * ) arg3 ; oe_fd_set * efds = ( oe_fd_set * ) arg4 ; struct oe_timeval * timeout = ( struct oe_timeval * ) arg5 ; ret = oe_select ( nfds , readfds , writefds , efds , timeout ) ; goto done ; } # endif case OE_SYS_pselect6 : { int nfds = ( int ) arg1 ; oe_fd_set * readfds = ( oe_fd_set * ) arg2 ; oe_fd_set * writefds = ( oe_fd_set * ) arg3 ; oe_fd_set * exceptfds = ( oe_fd_set * ) arg4 ; struct oe_timespec * ts = ( struct oe_timespec * ) arg5 ; struct oe_timeval buf ; struct oe_timeval * tv = NULL ; if ( ts ) { tv = & buf ; tv -> tv_sec = ts -> tv_sec ; tv -> tv_usec = ts -> tv_nsec / 1000 ; } ret = oe_select ( nfds , readfds , writefds , exceptfds , tv ) ; goto done ; } # if defined ( OE_SYS_poll ) case OE_SYS_poll : { struct oe_pollfd * fds = ( struct oe_pollfd * ) arg1 ; oe_nfds_t nfds = ( oe_nfds_t ) arg2 ; int millis = ( int ) arg3 ; ret = oe_poll ( fds , nfds , millis ) ; goto done ; } # endif case OE_SYS_ppoll : { struct oe_pollfd * fds = ( struct oe_pollfd * ) arg1 ; oe_nfds_t nfds = ( oe_nfds_t ) arg2 ; struct oe_timespec * ts = ( struct oe_timespec * ) arg3 ; void * sigmask = ( void * ) arg4 ; int timeout = - 1 ; if ( sigmask != NULL ) { oe_errno = OE_EINVAL ; goto done ; } if ( ts ) { int64_t mul ; int64_t div ; int64_t sum ; if ( oe_safe_mul_s64 ( ts -> tv_sec , 1000 , & mul ) != OE_OK ) { oe_errno = OE_EINVAL ; goto done ; } div = ts -> tv_nsec / 1000000 ; if ( oe_safe_add_s64 ( mul , div , & sum ) != OE_OK ) { oe_errno = OE_EINVAL ; goto done ; } if ( sum < OE_INT_MIN || sum > OE_INT_MAX ) { oe_errno = OE_EINVAL ; goto done ; } timeout = ( int ) sum ; } ret = oe_poll ( fds , nfds , timeout ) ; goto done ; } # if defined ( OE_SYS_epoll_create ) case OE_SYS_epoll_create : { int size = ( int ) arg1 ; ret = oe_epoll_create ( size ) ; goto done ; } # endif case OE_SYS_epoll_create1 : { int flags = ( int ) arg1 ; ret = oe_epoll_create1 ( flags ) ; goto done ; } # if defined ( OE_SYS_epoll_wait ) case OE_SYS_epoll_wait : { int epfd = ( int ) arg1 ; struct oe_epoll_event * events = ( struct oe_epoll_event * ) arg2 ; int maxevents = ( int ) arg3 ; int timeout = ( int ) arg4 ; ret = oe_epoll_wait ( epfd , events , maxevents , timeout ) ; goto done ; } # endif case OE_SYS_epoll_pwait : { int epfd = ( int ) arg1 ; struct oe_epoll_event * events = ( struct oe_epoll_event * ) arg2 ; int maxevents = ( int ) arg3 ; int timeout = ( int ) arg4 ; const oe_sigset_t * sigmask = ( const oe_sigset_t * ) arg5 ; ret = oe_epoll_pwait ( epfd , events , maxevents , timeout , sigmask ) ; goto done ; } case OE_SYS_epoll_ctl : { int epfd = ( int ) arg1 ; int op = ( int ) arg2 ; int fd = ( int ) arg3 ; struct oe_epoll_event * event = ( struct oe_epoll_event * ) arg4 ; ret = oe_epoll_ctl ( epfd , op , fd , event ) ; goto done ; } case OE_SYS_exit_group : { ret = 0 ; goto done ; } case OE_SYS_exit : { int status = ( int ) arg1 ; oe_exit ( status ) ; goto done ; } case OE_SYS_getpid : { ret = ( long ) oe_getpid ( ) ; goto done ; } case OE_SYS_getuid : { ret = ( long ) oe_getuid ( ) ; goto done ; } case OE_SYS_geteuid : { ret = ( long ) oe_geteuid ( ) ; goto done ; } case OE_SYS_getgid : { ret = ( long ) oe_getgid ( ) ; goto done ; } case OE_SYS_getpgid : { int pid = ( int ) arg1 ; ret = ( long ) oe_getpgid ( pid ) ; goto done ; } case OE_SYS_getgroups : { int size = ( int ) arg1 ; oe_gid_t * list = ( oe_gid_t * ) arg2 ; ret = ( long ) oe_getgroups ( size , list ) ; goto done ; } case OE_SYS_getegid : { ret = ( long ) oe_getegid ( ) ; goto done ; } case OE_SYS_getppid : { ret = ( long ) oe_getppid ( ) ; goto done ; } # if defined ( OE_SYS_getpgrp ) case OE_SYS_getpgrp : { ret = ( long ) oe_getpgrp ( ) ; goto done ; } # endif case OE_SYS_nanosleep : { struct oe_timespec * req = ( struct oe_timespec * ) arg1 ; struct oe_timespec * rem = ( struct oe_timespec * ) arg2 ; ret = ( long ) oe_nanosleep ( req , rem ) ; goto done ; } default : { oe_errno = OE_ENOSYS ; OE_TRACE_WARNING ( ""syscall<S2SV_blank>num=%ld<S2SV_blank>not<S2SV_blank>handled"" , num ) ; goto done ; } } done : return ret ; }
","<S2SV_ModStart> ) arg4 ; <S2SV_ModEnd> struct oe_sockaddr * <S2SV_ModStart> * dest_add = ( <S2SV_ModEnd> struct oe_sockaddr *
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,<S2SV_StartBug> const struct oe_sockaddr * dest_add = <S2SV_EndBug> <S2SV_StartBug> ( const struct oe_sockaddr * ) arg5 ; <S2SV_EndBug>
7993,CWE-787,"rfbBool rfbHandleAuthResult ( rfbClient * client ) { uint32_t authResult = 0 , reasonLen = 0 ; char * reason = NULL ; if ( ! ReadFromRFBServer ( client , ( char * ) & authResult , 4 ) ) return FALSE ; authResult = rfbClientSwap32IfLE ( authResult ) ; switch ( authResult ) { case rfbVncAuthOK : rfbClientLog ( ""VNC<S2SV_blank>authentication<S2SV_blank>succeeded\\n"" ) ; return TRUE ; break ; case rfbVncAuthFailed : if ( client -> major == 3 && client -> minor > 7 ) { if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return FALSE ; reasonLen = rfbClientSwap32IfLE ( reasonLen ) ; reason = malloc ( ( uint64_t ) reasonLen + 1 ) ; if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) { free ( reason ) ; return FALSE ; } reason [ reasonLen ] = 0 ; rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed:<S2SV_blank>%s\\n"" , reason ) ; free ( reason ) ; return FALSE ; } rfbClientLog ( ""VNC<S2SV_blank>authentication<S2SV_blank>failed\\n"" ) ; return FALSE ; case rfbVncAuthTooMany : rfbClientLog ( ""VNC<S2SV_blank>authentication<S2SV_blank>failed<S2SV_blank>-<S2SV_blank>too<S2SV_blank>many<S2SV_blank>tries\\n"" ) ; return FALSE ; } rfbClientLog ( ""Unknown<S2SV_blank>VNC<S2SV_blank>authentication<S2SV_blank>result:<S2SV_blank>%d\\n"" , ( int ) authResult ) ; return FALSE ; }
","<S2SV_ModStart> authResult = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> 7 ) { ReadReason ( client <S2SV_ModEnd> ) ; return
",LibVNC@libvncserver/e34bcbb759ca5bef85809967a268fdf214c1ad2c,CVE-2018-20748,https://github.com/LibVNC/libvncserver/commit/e34bcbb759ca5bef85809967a268fdf214c1ad2c,2019-01-30T18:29Z,"<S2SV_StartBug> uint32_t authResult = 0 , reasonLen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return FALSE ; <S2SV_EndBug>"
3759,CWE-287,"static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
","<S2SV_ModStart> siocb -> scm , false
",torvalds@linux/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,CVE-2012-3520,https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,2012-10-03T11:02Z,"<S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug>"
5490,CWE-787,"static int strncat_from_utf8_libarchive2 ( struct archive_string * as , const void * _p , size_t len , struct archive_string_conv * sc ) { const char * s ; int n ; char * p ; char * end ; uint32_t unicode ; # if HAVE_WCRTOMB mbstate_t shift_state ; memset ( & shift_state , 0 , sizeof ( shift_state ) ) ; # else wctomb ( NULL , L'\\0' ) ; # endif ( void ) sc ; if ( archive_string_ensure ( as , as -> length + len + 1 ) == NULL ) return ( - 1 ) ; s = ( const char * ) _p ; p = as -> s + as -> length ; end = as -> s + as -> buffer_length - MB_CUR_MAX - 1 ; while ( ( n = _utf8_to_unicode ( & unicode , s , len ) ) != 0 ) { wchar_t wc ; if ( p >= end ) { as -> length = p - as -> s ; if ( archive_string_ensure ( as , as -> length + len * 2 + 1 ) == NULL ) return ( - 1 ) ; p = as -> s + as -> length ; end = as -> s + as -> buffer_length - MB_CUR_MAX - 1 ; } if ( n < 0 ) { n *= - 1 ; wc = L'?' ; } else wc = ( wchar_t ) unicode ; s += n ; len -= n ; # if HAVE_WCRTOMB n = ( int ) wcrtomb ( p , wc , & shift_state ) ; # else n = ( int ) wctomb ( p , wc ) ; # endif if ( n == - 1 ) return ( - 1 ) ; p += n ; } as -> length = p - as -> s ; as -> s [ as -> length ] = '\\0' ; return ( 0 ) ; }
","<S2SV_ModStart> -> length + max ( <S2SV_ModStart> len * 2 , ( size_t ) MB_CUR_MAX )
",libarchive@libarchive/4f085eea879e2be745f4d9bf57e8513ae48157f4,CVE-2020-21674,https://github.com/libarchive/libarchive/commit/4f085eea879e2be745f4d9bf57e8513ae48157f4,2020-10-15T15:15Z,<S2SV_StartBug> as -> length + len * 2 + 1 ) == NULL ) <S2SV_EndBug>
2819,CWE-704,"static void n_tty_set_termios ( struct tty_struct * tty , struct ktermios * old ) { struct n_tty_data * ldata = tty -> disc_data ; if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ; ldata -> line_start = ldata -> read_tail ; if ( ! L_ICANON ( tty ) || ! read_cnt ( ldata ) ) { ldata -> canon_head = ldata -> read_tail ; ldata -> push = 0 ; } else { set_bit ( ( ldata -> read_head - 1 ) & ( N_TTY_BUF_SIZE - 1 ) , ldata -> read_flags ) ; ldata -> canon_head = ldata -> read_head ; ldata -> push = 1 ; } ldata -> commit_head = ldata -> read_head ; ldata -> erasing = 0 ; ldata -> lnext = 0 ; } ldata -> icanon = ( L_ICANON ( tty ) != 0 ) ; if ( I_ISTRIP ( tty ) || I_IUCLC ( tty ) || I_IGNCR ( tty ) || I_ICRNL ( tty ) || I_INLCR ( tty ) || L_ICANON ( tty ) || I_IXON ( tty ) || L_ISIG ( tty ) || L_ECHO ( tty ) || I_PARMRK ( tty ) ) { bitmap_zero ( ldata -> char_map , 256 ) ; if ( I_IGNCR ( tty ) || I_ICRNL ( tty ) ) set_bit ( '\\r' , ldata -> char_map ) ; if ( I_INLCR ( tty ) ) set_bit ( '\\n' , ldata -> char_map ) ; if ( L_ICANON ( tty ) ) { set_bit ( ERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( KILL_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOF_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( '\\n' , ldata -> char_map ) ; set_bit ( EOL_CHAR ( tty ) , ldata -> char_map ) ; if ( L_IEXTEN ( tty ) ) { set_bit ( WERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( LNEXT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOL2_CHAR ( tty ) , ldata -> char_map ) ; if ( L_ECHO ( tty ) ) set_bit ( REPRINT_CHAR ( tty ) , ldata -> char_map ) ; } } if ( I_IXON ( tty ) ) { set_bit ( START_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( STOP_CHAR ( tty ) , ldata -> char_map ) ; } if ( L_ISIG ( tty ) ) { set_bit ( INTR_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( QUIT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( SUSP_CHAR ( tty ) , ldata -> char_map ) ; } clear_bit ( __DISABLED_CHAR , ldata -> char_map ) ; ldata -> raw = 0 ; ldata -> real_raw = 0 ; } else { ldata -> raw = 1 ; if ( ( I_IGNBRK ( tty ) || ( ! I_BRKINT ( tty ) && ! I_PARMRK ( tty ) ) ) && ( I_IGNPAR ( tty ) || ! I_INPCK ( tty ) ) && ( tty -> driver -> flags & TTY_DRIVER_REAL_RAW ) ) ldata -> real_raw = 1 ; else ldata -> real_raw = 0 ; } if ( ! I_IXON ( tty ) && old && ( old -> c_iflag & IXON ) && ! tty -> flow_stopped ) { start_tty ( tty ) ; process_echoes ( tty ) ; } wake_up_interruptible ( & tty -> write_wait ) ; wake_up_interruptible ( & tty -> read_wait ) ; }
","<S2SV_ModStart> c_lflag ) & ( ICANON | EXTPROC ) <S2SV_ModEnd> ) { bitmap_zero
",torvalds@linux/966031f340185eddd05affcf72b740549f056348,CVE-2018-18386,https://github.com/torvalds/linux/commit/966031f340185eddd05affcf72b740549f056348,2018-10-17T20:29Z,<S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug>
3721,CWE-362,"static int ext4_split_extent_at ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , ext4_lblk_t split , int split_flag , int flags ) { ext4_fsblk_t newblock ; ext4_lblk_t ee_block ; struct ext4_extent * ex , newex , orig_ex ; struct ext4_extent * ex2 = NULL ; unsigned int ee_len , depth ; int err = 0 ; ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\n"" , inode -> i_ino , ( unsigned long long ) split ) ; ext4_ext_show_leaf ( inode , path ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; newblock = split - ee_block + ext4_ext_pblock ( ex ) ; BUG_ON ( split < ee_block || split >= ( ee_block + ee_len ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; if ( split == ee_block ) { if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) ext4_ext_mark_uninitialized ( ex ) ; else ext4_ext_mark_initialized ( ex ) ; if ( ! ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } memcpy ( & orig_ex , ex , sizeof ( orig_ex ) ) ; ex -> ee_len = cpu_to_le16 ( split - ee_block ) ; if ( split_flag & EXT4_EXT_MARK_UNINIT1 ) ext4_ext_mark_uninitialized ( ex ) ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; if ( err ) goto fix_extent_len ; ex2 = & newex ; ex2 -> ee_block = cpu_to_le32 ( split ) ; ex2 -> ee_len = cpu_to_le16 ( ee_len - ( split - ee_block ) ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) ext4_ext_mark_uninitialized ( ex2 ) ; err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err == - ENOSPC && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; fix_extent_len : ex -> ee_len = orig_ex . ee_len ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }
","<S2SV_ModStart> err = 0 ; BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) <S2SV_ModStart> ) ) { if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) { if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ; else err = ext4_ext_zeroout ( inode , ex ) ; } else
",torvalds@linux/dee1f973ca341c266229faa5a1a5bb268bed3531,CVE-2012-4508,https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531,2012-12-21T11:47Z,"<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug>"
2934,CWE-200,"static long __tun_chr_ioctl ( struct file * file , unsigned int cmd , unsigned long arg , int ifreq_len ) { struct tun_file * tfile = file -> private_data ; struct tun_struct * tun ; void __user * argp = ( void __user * ) arg ; struct sock_fprog fprog ; struct ifreq ifr ; int sndbuf ; int vnet_hdr_sz ; int ret ; if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) if ( copy_from_user ( & ifr , argp , ifreq_len ) ) return - EFAULT ; if ( cmd == TUNGETFEATURES ) { return put_user ( IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE | IFF_VNET_HDR , ( unsigned int __user * ) argp ) ; } rtnl_lock ( ) ; tun = __tun_get ( tfile ) ; if ( cmd == TUNSETIFF && ! tun ) { ifr . ifr_name [ IFNAMSIZ - 1 ] = '\\0' ; ret = tun_set_iff ( tfile -> net , file , & ifr ) ; if ( ret ) goto unlock ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - EFAULT ; goto unlock ; } ret = - EBADFD ; if ( ! tun ) goto unlock ; tun_debug ( KERN_INFO , tun , ""tun_chr_ioctl<S2SV_blank>cmd<S2SV_blank>%d\\n"" , cmd ) ; ret = 0 ; switch ( cmd ) { case TUNGETIFF : ret = tun_get_iff ( current -> nsproxy -> net_ns , tun , & ifr ) ; if ( ret ) break ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - EFAULT ; break ; case TUNSETNOCSUM : tun_debug ( KERN_INFO , tun , ""ignored:<S2SV_blank>set<S2SV_blank>checksum<S2SV_blank>%s\\n"" , arg ? ""disabled"" : ""enabled"" ) ; break ; case TUNSETPERSIST : if ( arg ) tun -> flags |= TUN_PERSIST ; else tun -> flags &= ~ TUN_PERSIST ; tun_debug ( KERN_INFO , tun , ""persist<S2SV_blank>%s\\n"" , arg ? ""enabled"" : ""disabled"" ) ; break ; case TUNSETOWNER : tun -> owner = ( uid_t ) arg ; tun_debug ( KERN_INFO , tun , ""owner<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n"" , tun -> owner ) ; break ; case TUNSETGROUP : tun -> group = ( gid_t ) arg ; tun_debug ( KERN_INFO , tun , ""group<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n"" , tun -> group ) ; break ; case TUNSETLINK : if ( tun -> dev -> flags & IFF_UP ) { tun_debug ( KERN_INFO , tun , ""Linktype<S2SV_blank>set<S2SV_blank>failed<S2SV_blank>because<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>up\\n"" ) ; ret = - EBUSY ; } else { tun -> dev -> type = ( int ) arg ; tun_debug ( KERN_INFO , tun , ""linktype<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n"" , tun -> dev -> type ) ; ret = 0 ; } break ; # ifdef TUN_DEBUG case TUNSETDEBUG : tun -> debug = arg ; break ; # endif case TUNSETOFFLOAD : ret = set_offload ( tun , arg ) ; break ; case TUNSETTXFILTER : ret = - EINVAL ; if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) break ; ret = update_filter ( & tun -> txflt , ( void __user * ) arg ) ; break ; case SIOCGIFHWADDR : memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ) ; ifr . ifr_hwaddr . sa_family = tun -> dev -> type ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - EFAULT ; break ; case SIOCSIFHWADDR : tun_debug ( KERN_DEBUG , tun , ""set<S2SV_blank>hw<S2SV_blank>address:<S2SV_blank>%pM\\n"" , ifr . ifr_hwaddr . sa_data ) ; ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ) ; break ; case TUNGETSNDBUF : sndbuf = tun -> socket . sk -> sk_sndbuf ; if ( copy_to_user ( argp , & sndbuf , sizeof ( sndbuf ) ) ) ret = - EFAULT ; break ; case TUNSETSNDBUF : if ( copy_from_user ( & sndbuf , argp , sizeof ( sndbuf ) ) ) { ret = - EFAULT ; break ; } tun -> socket . sk -> sk_sndbuf = sndbuf ; break ; case TUNGETVNETHDRSZ : vnet_hdr_sz = tun -> vnet_hdr_sz ; if ( copy_to_user ( argp , & vnet_hdr_sz , sizeof ( vnet_hdr_sz ) ) ) ret = - EFAULT ; break ; case TUNSETVNETHDRSZ : if ( copy_from_user ( & vnet_hdr_sz , argp , sizeof ( vnet_hdr_sz ) ) ) { ret = - EFAULT ; break ; } if ( vnet_hdr_sz < ( int ) sizeof ( struct virtio_net_hdr ) ) { ret = - EINVAL ; break ; } tun -> vnet_hdr_sz = vnet_hdr_sz ; break ; case TUNATTACHFILTER : ret = - EINVAL ; if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) break ; ret = - EFAULT ; if ( copy_from_user ( & fprog , argp , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , tun -> socket . sk ) ; break ; case TUNDETACHFILTER : ret = - EINVAL ; if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) break ; ret = sk_detach_filter ( tun -> socket . sk ) ; break ; default : ret = - EINVAL ; break ; } unlock : rtnl_unlock ( ) ; if ( tun ) tun_put ( tun ) ; return ret ; }
","<S2SV_ModStart> == 0x89 ) { <S2SV_ModStart> return - EFAULT ; } else memset ( & ifr , 0 , sizeof ( ifr ) )
",torvalds@linux/a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc,CVE-2012-6547,https://github.com/torvalds/linux/commit/a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc,2013-03-15T20:55Z,<S2SV_StartBug> if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug>
2611,CWE-476,"static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; tmp = ! ! tmp ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; if ( tmp && tmp == cluster -> cl_has_local && cluster -> cl_local_node != node -> nd_num ) return - EBUSY ; if ( tmp && ! cluster -> cl_has_local ) { ret = o2net_start_listening ( node ) ; if ( ret ) return ret ; } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } return count ; }
","<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> -> nd_num ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; goto out ; } <S2SV_ModStart> ( ret ) goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> nd_num ; } ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,CVE-2017-18216,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,2018-03-05T18:29Z,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> return count ; <S2SV_EndBug>
1438,CWE-119,"int vp8_find_best_sub_pixel_step ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * bestmv , int_mv * ref_mv , int error_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvcost [ 2 ] , int * distortion , unsigned int * sse1 ) { int bestmse = INT_MAX ; int_mv startmv ; int_mv this_mv ; unsigned char * z = ( * ( b -> base_src ) + b -> src ) ; int left , right , up , down , diag ; unsigned int sse ; int whichdir ; int thismse ; int y_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; # if ARCH_X86 || ARCH_X86_64 MACROBLOCKD * xd = & x -> e_mbd ; unsigned char * y_0 = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ; unsigned char * y ; y_stride = 32 ; vfp -> copymem ( y_0 - 1 - pre_stride , pre_stride , xd -> y_buf , y_stride , 18 ) ; y = xd -> y_buf + y_stride + 1 ; # else unsigned char * y = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ; y_stride = pre_stride ; # endif bestmv -> as_mv . row <<= 3 ; bestmv -> as_mv . col <<= 3 ; startmv = * bestmv ; bestmse = vfp -> vf ( y , y_stride , z , b -> src_stride , sse1 ) ; * distortion = bestmse ; bestmse += mv_err_cost ( bestmv , ref_mv , mvcost , error_per_bit ) ; this_mv . as_mv . row = startmv . as_mv . row ; this_mv . as_mv . col = ( ( startmv . as_mv . col - 8 ) | 4 ) ; thismse = vfp -> svf_halfpix_h ( y - 1 , y_stride , z , b -> src_stride , & sse ) ; left = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( left < bestmse ) { * bestmv = this_mv ; bestmse = left ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col += 8 ; thismse = vfp -> svf_halfpix_h ( y , y_stride , z , b -> src_stride , & sse ) ; right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( right < bestmse ) { * bestmv = this_mv ; bestmse = right ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col = startmv . as_mv . col ; this_mv . as_mv . row = ( ( startmv . as_mv . row - 8 ) | 4 ) ; thismse = vfp -> svf_halfpix_v ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ; up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( up < bestmse ) { * bestmv = this_mv ; bestmse = up ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . row += 8 ; thismse = vfp -> svf_halfpix_v ( y , y_stride , z , b -> src_stride , & sse ) ; down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( down < bestmse ) { * bestmv = this_mv ; bestmse = down ; * distortion = thismse ; * sse1 = sse ; } whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ; this_mv = startmv ; switch ( whichdir ) { case 0 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ; this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ; thismse = vfp -> svf_halfpix_hv ( y - 1 - y_stride , y_stride , z , b -> src_stride , & sse ) ; break ; case 1 : this_mv . as_mv . col += 4 ; this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ; thismse = vfp -> svf_halfpix_hv ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ; break ; case 2 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ; this_mv . as_mv . row += 4 ; thismse = vfp -> svf_halfpix_hv ( y - 1 , y_stride , z , b -> src_stride , & sse ) ; break ; case 3 : default : this_mv . as_mv . col += 4 ; this_mv . as_mv . row += 4 ; thismse = vfp -> svf_halfpix_hv ( y , y_stride , z , b -> src_stride , & sse ) ; break ; } diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( diag < bestmse ) { * bestmv = this_mv ; bestmse = diag ; * distortion = thismse ; * sse1 = sse ; } if ( bestmv -> as_mv . row < startmv . as_mv . row ) y -= y_stride ; if ( bestmv -> as_mv . col < startmv . as_mv . col ) y -- ; startmv = * bestmv ; this_mv . as_mv . row = startmv . as_mv . row ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col = startmv . as_mv . col - 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } left = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( left < bestmse ) { * bestmv = this_mv ; bestmse = left ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col += 4 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( right < bestmse ) { * bestmv = this_mv ; bestmse = right ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col = startmv . as_mv . col ; if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row = startmv . as_mv . row - 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( up < bestmse ) { * bestmv = this_mv ; bestmse = up ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . row += 4 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( down < bestmse ) { * bestmv = this_mv ; bestmse = down ; * distortion = thismse ; * sse1 = sse ; } whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ; this_mv = startmv ; switch ( whichdir ) { case 0 : if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row -= 2 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; ; } } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride - 1 , y_stride , 6 , 6 , z , b -> src_stride , & sse ) ; } } break ; case 1 : this_mv . as_mv . col += 2 ; if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } break ; case 2 : this_mv . as_mv . row += 2 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } break ; case 3 : this_mv . as_mv . col += 2 ; this_mv . as_mv . row += 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; break ; } diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( diag < bestmse ) { * bestmv = this_mv ; bestmse = diag ; * distortion = thismse ; * sse1 = sse ; } return bestmse ; }
","<S2SV_ModStart> as_mv . row *= 8 <S2SV_ModEnd> ; bestmv -> <S2SV_ModStart> as_mv . col *= 8 <S2SV_ModEnd> ; startmv =
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> bestmv -> as_mv . row <<= 3 ; <S2SV_EndBug> <S2SV_StartBug> bestmv -> as_mv . col <<= 3 ; <S2SV_EndBug>
8130,CWE-295,"void main_cleanup ( ) { # ifdef USE_OS_THREADS CLI * c ; unsigned i , threads ; THREAD_ID * thread_list ; CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_THREAD_LIST ] ) ; threads = 0 ; for ( c = thread_head ; c ; c = c -> thread_next ) threads ++ ; thread_list = str_alloc ( ( threads + 1 ) * sizeof ( THREAD_ID ) ) ; i = 0 ; for ( c = thread_head ; c ; c = c -> thread_next ) { thread_list [ i ++ ] = c -> thread_id ; s_log ( LOG_DEBUG , ""Terminating<S2SV_blank>a<S2SV_blank>thread<S2SV_blank>for<S2SV_blank>[%s]"" , c -> opt -> servname ) ; } if ( cron_thread_id ) { thread_list [ threads ++ ] = cron_thread_id ; s_log ( LOG_DEBUG , ""Terminating<S2SV_blank>the<S2SV_blank>cron<S2SV_blank>thread"" ) ; } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_THREAD_LIST ] ) ; if ( threads ) { s_log ( LOG_NOTICE , ""Terminating<S2SV_blank>%u<S2SV_blank>service<S2SV_blank>thread(s)"" , threads ) ; writesocket ( terminate_pipe [ 1 ] , """" , 1 ) ; for ( i = 0 ; i < threads ; ++ i ) { # ifdef USE_PTHREAD if ( pthread_join ( thread_list [ i ] , NULL ) ) s_log ( LOG_ERR , ""pthread_join()<S2SV_blank>failed"" ) ; # endif # ifdef USE_WIN32 if ( WaitForSingleObject ( thread_list [ i ] , INFINITE ) == WAIT_FAILED ) ioerror ( ""WaitForSingleObject"" ) ; if ( ! CloseHandle ( thread_list [ i ] ) ) ioerror ( ""CloseHandle"" ) ; # endif } s_log ( LOG_NOTICE , ""Service<S2SV_blank>threads<S2SV_blank>terminated"" ) ; } str_free ( thread_list ) ; # endif unbind_ports ( ) ; s_poll_free ( fds ) ; fds = NULL ; # if 0 str_stats ( ) ; # endif log_flush ( LOG_MODE_ERROR ) ; log_close ( SINK_SYSLOG | SINK_OUTFILE ) ; }
","<S2SV_ModStart> endif log_flush ( LOG_MODE_BUFFER <S2SV_ModEnd> ) ; log_close
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,<S2SV_StartBug> log_flush ( LOG_MODE_ERROR ) ; <S2SV_EndBug>
1964,CWE-119,"static vpx_codec_err_t decoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { if ( ! ctx -> priv ) { vpx_codec_alg_priv_t * alg_priv = vpx_memalign ( 32 , sizeof ( * alg_priv ) ) ; if ( alg_priv == NULL ) return VPX_CODEC_MEM_ERROR ; vp9_zero ( * alg_priv ) ; ctx -> priv = ( vpx_codec_priv_t * ) alg_priv ; ctx -> priv -> sz = sizeof ( * ctx -> priv ) ; ctx -> priv -> iface = ctx -> iface ; ctx -> priv -> alg_priv = alg_priv ; ctx -> priv -> alg_priv -> si . sz = sizeof ( ctx -> priv -> alg_priv -> si ) ; ctx -> priv -> init_flags = ctx -> init_flags ; if ( ctx -> config . dec ) { ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ; ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ; } } return VPX_CODEC_OK ; }
","<S2SV_ModStart> data ) { ( void ) data ; <S2SV_ModStart> { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> sizeof ( * priv <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; if ( priv <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ) return VPX_CODEC_MEM_ERROR <S2SV_ModEnd> ; ctx -> <S2SV_ModStart> vpx_codec_priv_t * ) priv <S2SV_ModEnd> ; ctx -> <S2SV_ModStart> -> init_flags ; priv -> si . sz = sizeof ( priv -> si ) ; priv -> flushed = 0 ; priv -> frame_parallel_decode = ( ctx -> config . dec && ( ctx -> config . dec -> threads > 1 ) && ( ctx -> init_flags & VPX_CODEC_USE_FRAME_THREADING ) ) ? 1 : 0 ; <S2SV_ModStart> dec ) { priv <S2SV_ModEnd> -> cfg = <S2SV_ModStart> dec = & priv <S2SV_ModEnd> -> cfg ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> if ( ! ctx -> priv ) { <S2SV_EndBug> <S2SV_StartBug> vpx_codec_alg_priv_t * alg_priv = vpx_memalign ( 32 , sizeof ( * alg_priv ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( alg_priv == NULL ) <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_MEM_ERROR ; <S2SV_EndBug> <S2SV_StartBug> ctx -> priv = ( vpx_codec_priv_t * ) alg_priv ; <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> config . dec ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ; <S2SV_EndBug> <S2SV_StartBug> ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ; <S2SV_EndBug>"
3957,CWE-119,"char * logger_get_mask_expanded ( struct t_gui_buffer * buffer , const char * mask ) { char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ; char * mask_decoded5 ; const char * dir_separator ; int length ; time_t seconds ; struct tm * date_tmp ; mask2 = NULL ; mask_decoded = NULL ; mask_decoded2 = NULL ; mask_decoded3 = NULL ; mask_decoded4 = NULL ; mask_decoded5 = NULL ; dir_separator = weechat_info_get ( ""dir_separator"" , """" ) ; if ( ! dir_separator ) return NULL ; mask2 = weechat_string_replace ( mask , dir_separator , ""\\01"" ) ; if ( ! mask2 ) goto end ; mask_decoded = weechat_buffer_string_replace_local_var ( buffer , mask2 ) ; if ( ! mask_decoded ) goto end ; mask_decoded2 = weechat_string_replace ( mask_decoded , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask_decoded2 ) goto end ; # ifdef __CYGWIN__ mask_decoded3 = weechat_string_replace ( mask_decoded2 , ""\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask_decoded3 = strdup ( mask_decoded2 ) ; # endif if ( ! mask_decoded3 ) goto end ; mask_decoded4 = weechat_string_replace ( mask_decoded3 , ""\\01"" , dir_separator ) ; if ( ! mask_decoded4 ) goto end ; length = strlen ( mask_decoded4 ) + 256 + 1 ; mask_decoded5 = malloc ( length ) ; if ( ! mask_decoded5 ) goto end ; seconds = time ( NULL ) ; date_tmp = localtime ( & seconds ) ; mask_decoded5 [ 0 ] = '\\0' ; strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ; if ( weechat_config_boolean ( logger_config_file_name_lower_case ) ) weechat_string_tolower ( mask_decoded5 ) ; if ( weechat_logger_plugin -> debug ) { weechat_printf_date_tags ( NULL , 0 , ""no_log"" , ""%s:<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>\\""%s\\"",<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\""%s\\"",<S2SV_blank>"" ""decoded<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\""%s\\"""" , LOGGER_PLUGIN_NAME , weechat_buffer_get_string ( buffer , ""name"" ) , mask , mask_decoded5 ) ; } end : if ( mask2 ) free ( mask2 ) ; if ( mask_decoded ) free ( mask_decoded ) ; if ( mask_decoded2 ) free ( mask_decoded2 ) ; if ( mask_decoded3 ) free ( mask_decoded3 ) ; if ( mask_decoded4 ) free ( mask_decoded4 ) ; return mask_decoded5 ; }
","<S2SV_ModStart> mask2 , * mask3 , * mask4 , * mask5 , * mask6 , * mask7 <S2SV_ModEnd> ; const char <S2SV_ModStart> = NULL ; mask3 = NULL ; mask4 = NULL ; mask5 = NULL ; mask6 = NULL ; mask7 <S2SV_ModEnd> = NULL ; <S2SV_ModStart> return NULL ; length = strlen ( mask <S2SV_ModEnd> ) + 256 <S2SV_ModStart> + 1 ; mask2 <S2SV_ModEnd> = malloc ( <S2SV_ModStart> if ( ! mask2 <S2SV_ModEnd> ) goto end <S2SV_ModStart> seconds ) ; mask2 <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = '\\0' ; if ( strftime ( mask2 <S2SV_ModEnd> , length - <S2SV_ModStart> - 1 , mask <S2SV_ModEnd> , date_tmp ) <S2SV_ModStart> , date_tmp ) == 0 ) mask2 [ 0 ] = '\\0' ; mask3 = weechat_string_replace ( mask2 , dir_separator , ""\\01"" ) ; if ( ! mask3 ) goto end ; mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ; if ( ! mask4 ) goto end ; mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask5 ) goto end ; # ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , ""\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask6 = strdup ( mask5 ) ; # endif if ( ! mask6 ) goto end ; mask7 = weechat_string_replace ( mask6 , ""\\01"" , dir_separator ) ; if ( ! mask7 ) goto end <S2SV_ModStart> ) weechat_string_tolower ( mask7 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , mask , mask7 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; if ( mask3 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask3 ) ; if ( mask4 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask4 ) ; if ( mask5 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask5 ) ; if ( mask6 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask6 <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return mask7 <S2SV_ModEnd> ; } <S2SV_null>
",weechat@weechat/f105c6f0b56fb5687b2d2aedf37cb1d1b434d556,CVE-2017-14727,https://github.com/weechat/weechat/commit/f105c6f0b56fb5687b2d2aedf37cb1d1b434d556,2017-09-23T20:29Z,"<S2SV_StartBug> char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ; <S2SV_EndBug> <S2SV_StartBug> mask_decoded = NULL ; <S2SV_EndBug> <S2SV_StartBug> mask2 = weechat_string_replace ( mask , dir_separator , ""\\01"" ) ; <S2SV_EndBug> <S2SV_StartBug> mask_decoded5 = malloc ( length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! mask_decoded5 ) <S2SV_EndBug> <S2SV_StartBug> mask_decoded5 [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ; <S2SV_EndBug> <S2SV_StartBug> weechat_string_tolower ( mask_decoded5 ) ; <S2SV_EndBug> <S2SV_StartBug> mask , mask_decoded5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mask_decoded ) <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded2 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded3 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded4 ) ; <S2SV_EndBug> <S2SV_StartBug> return mask_decoded5 ; <S2SV_EndBug>"
7325,CWE-20,"static char * base64_decode_string ( const char * enc ) { if ( enc == NULL ) return NULL ; char * dec = g_strdup ( enc ) ; gsize len ; g_base64_decode_inplace ( dec , & len ) ; dec [ len ] = '\\0' ; return dec ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static gchar <S2SV_ModEnd> * base64_decode_string ( <S2SV_ModStart> enc ) { gchar * dec ; gsize len ; <S2SV_ModStart> return NULL ; dec = ( gchar * ) g_base64_decode ( enc <S2SV_ModEnd> , & len <S2SV_ModStart> len ) ; if ( dec )
",cockpit-project@cockpit/c51f6177576d7e12614c64d316cf0b67addd17c9,CVE-2019-3804,https://github.com/cockpit-project/cockpit/commit/c51f6177576d7e12614c64d316cf0b67addd17c9,2019-03-26T18:29Z,"<S2SV_StartBug> static char * <S2SV_EndBug> <S2SV_StartBug> if ( enc == NULL ) <S2SV_EndBug> <S2SV_StartBug> char * dec = g_strdup ( enc ) ; <S2SV_EndBug> <S2SV_StartBug> g_base64_decode_inplace ( dec , & len ) ; <S2SV_EndBug>"
1566,CWE-119,"void vp9_loop_filter_frame_init ( VP9_COMMON * cm , int default_filt_lvl ) { int seg_id ; const int scale = 1 << ( default_filt_lvl >> 5 ) ; loop_filter_info_n * const lfi = & cm -> lf_info ; struct loopfilter * const lf = & cm -> lf ; const struct segmentation * const seg = & cm -> seg ; if ( lf -> last_sharpness_level != lf -> sharpness_level ) { update_sharpness ( lfi , lf -> sharpness_level ) ; lf -> last_sharpness_level = lf -> sharpness_level ; } for ( seg_id = 0 ; seg_id < MAX_SEGMENTS ; seg_id ++ ) { int lvl_seg = default_filt_lvl ; if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) { const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ; lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ; } if ( ! lf -> mode_ref_delta_enabled ) { vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ; } else { int ref , mode ; const int intra_lvl = lvl_seg + lf -> ref_deltas [ INTRA_FRAME ] * scale ; lfi -> lvl [ seg_id ] [ INTRA_FRAME ] [ 0 ] = clamp ( intra_lvl , 0 , MAX_LOOP_FILTER ) ; for ( ref = LAST_FRAME ; ref < MAX_REF_FRAMES ; ++ ref ) { for ( mode = 0 ; mode < MAX_MODE_LF_DELTAS ; ++ mode ) { const int inter_lvl = lvl_seg + lf -> ref_deltas [ ref ] * scale + lf -> mode_deltas [ mode ] * scale ; lfi -> lvl [ seg_id ] [ ref ] [ mode ] = clamp ( inter_lvl , 0 , MAX_LOOP_FILTER ) ; } } } } }
","<S2SV_ModStart> ; if ( segfeature_active <S2SV_ModEnd> ( seg , <S2SV_ModStart> int data = get_segdata <S2SV_ModEnd> ( seg , <S2SV_ModStart> mode_ref_delta_enabled ) { memset <S2SV_ModEnd> ( lfi ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ; <S2SV_EndBug>"
2072,CWE-119,"void mp_encode_lua_table_as_array ( lua_State * L , mp_buf * buf , int level ) { # if LUA_VERSION_NUM < 502 size_t len = lua_objlen ( L , - 1 ) , j ; # else size_t len = lua_rawlen ( L , - 1 ) , j ; # endif mp_encode_array ( L , buf , len ) ; for ( j = 1 ; j <= len ; j ++ ) { lua_pushnumber ( L , j ) ; lua_gettable ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }
","<S2SV_ModStart> len ) ; luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array"" ) ;
",antirez@redis/5ccb6f7a791bf3490357b00a898885759d98bab0,CVE-2018-11218,https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0,2018-06-17T17:29Z,<S2SV_StartBug> for ( j = 1 ; j <= len ; j ++ ) { <S2SV_EndBug>
3795,CWE-20,"static apr_status_t parse_chunk_size ( http_ctx_t * ctx , const char * buffer , apr_size_t len , int linelimit ) { apr_size_t i = 0 ; while ( i < len ) { char c = buffer [ i ] ; ap_xlate_proto_from_ascii ( & c , 1 ) ; if ( ctx -> state == BODY_CHUNK_END ) { if ( c == LF ) { ctx -> state = BODY_CHUNK ; } i ++ ; continue ; } if ( ctx -> state == BODY_CHUNK ) { if ( ! apr_isxdigit ( c ) ) { return APR_EGENERAL ; } else { ctx -> state = BODY_CHUNK_PART ; } ctx -> remaining = 0 ; ctx -> chunkbits = sizeof ( long ) * 8 ; ctx -> chunk_used = 0 ; } if ( c == ';' || c == CR ) { ctx -> state = BODY_CHUNK_EXT ; } else if ( c == LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state != BODY_CHUNK_EXT ) { int xvalue = 0 ; if ( ! ctx -> remaining && c == '0' ) { i ++ ; continue ; } if ( c >= '0' && c <= '9' ) { xvalue = c - '0' ; } else if ( c >= 'A' && c <= 'F' ) { xvalue = c - 'A' + 0xa ; } else if ( c >= 'a' && c <= 'f' ) { xvalue = c - 'a' + 0xa ; } else { return APR_EGENERAL ; } ctx -> remaining = ( ctx -> remaining << 4 ) | xvalue ; ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits <= 0 || ctx -> remaining < 0 ) { return APR_ENOSPC ; } } i ++ ; } ctx -> chunk_used += len ; if ( ctx -> chunk_used < 0 || ctx -> chunk_used > linelimit ) { return APR_ENOSPC ; } return APR_SUCCESS ; }
","<S2SV_ModStart> state == BODY_CHUNK_END || ctx -> state == BODY_CHUNK_END_LF <S2SV_ModStart> state = BODY_CHUNK ; } else if ( c == CR && ctx -> state == BODY_CHUNK_END ) { ctx -> state = BODY_CHUNK_END_LF ; } else { return APR_EINVAL <S2SV_ModStart> ) { return APR_EINVAL <S2SV_ModEnd> ; } else <S2SV_ModStart> = sizeof ( apr_off_t <S2SV_ModEnd> ) * 8 <S2SV_ModStart> ( c == LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_LF ) { return APR_EINVAL ; } else if ( c == CR ) { ctx -> state = BODY_CHUNK_LF ; } else if ( c == ';' <S2SV_ModEnd> ) { ctx <S2SV_ModStart> else if ( ctx -> state == BODY_CHUNK_EXT ) { if ( c != '\\t' && apr_iscntrl ( c ) ) { return APR_EINVAL ; } } else if ( ctx -> state == BODY_CHUNK_PART <S2SV_ModEnd> ) { int <S2SV_ModStart> { int xvalue <S2SV_ModEnd> ; if ( <S2SV_ModStart> ++ ; continue ; } ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits < 0 ) { return APR_ENOSPC <S2SV_ModStart> else { return APR_EINVAL <S2SV_ModEnd> ; } ctx <S2SV_ModStart> | xvalue ; if ( <S2SV_ModEnd> ctx -> remaining <S2SV_ModStart> APR_ENOSPC ; } } else { return APR_EGENERAL ;
",apache@httpd/e427c41257957b57036d5a549b260b6185d1dd73,CVE-2015-3183,https://github.com/apache/httpd/commit/e427c41257957b57036d5a549b260b6185d1dd73,2015-07-20T23:59Z,<S2SV_StartBug> if ( ctx -> state == BODY_CHUNK_END ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> state = BODY_CHUNK ; <S2SV_EndBug> <S2SV_StartBug> return APR_EGENERAL ; <S2SV_EndBug> <S2SV_StartBug> ctx -> chunkbits = sizeof ( long ) * 8 ; <S2SV_EndBug> <S2SV_StartBug> if ( c == ';' || c == CR ) { <S2SV_EndBug> <S2SV_StartBug> else if ( c == LF ) { <S2SV_EndBug> <S2SV_StartBug> int xvalue = 0 ; <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> return APR_EGENERAL ; <S2SV_EndBug> <S2SV_StartBug> ctx -> chunkbits -= 4 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
3923,CWE-200,"long vorbis_book_decodev_set ( codebook * book , ogg_int32_t * a , oggpack_buffer * b , int n , int point ) { if ( book -> used_entries > 0 ) { ogg_int32_t * v = book -> dec_buf ; int i , j ; if ( ! v ) return - 1 ; for ( i = 0 ; i < n ; ) { if ( decode_map ( book , b , v , point ) ) return - 1 ; for ( j = 0 ; j < book -> dim ; j ++ ) a [ i ++ ] = v [ j ] ; } } else { int i , j ; for ( i = 0 ; i < n ; ) { for ( j = 0 ; j < book -> dim ; j ++ ) a [ i ++ ] = 0 ; } } return 0 ; }
","<S2SV_ModStart> book -> dim && i < n <S2SV_ModStart> book -> dim && i < n
",external@tremolo/eeb4e45d5683f88488c083ecf142dc89bc3f0b47,CVE-2017-0814,https://android.googlesource.com/platform/external/tremolo/+/eeb4e45d5683f88488c083ecf142dc89bc3f0b47,2017-10-04T01:29Z,<S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug>
5327,CWE-125,"static void ttm_put_pages ( struct page * * pages , unsigned npages , int flags , enum ttm_caching_state cstate ) { struct ttm_page_pool * pool = ttm_get_pool ( flags , false , cstate ) ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool * huge = ttm_get_pool ( flags , true , cstate ) ; # endif unsigned long irq_flags ; unsigned i ; if ( pool == NULL ) { i = 0 ; while ( i < npages ) { # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ; # endif unsigned order = 0 , j ; if ( ! pages [ i ] ) { ++ i ; continue ; } # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) && ( npages - i ) >= HPAGE_PMD_NR ) { for ( j = 1 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ; } # endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; __free_pages ( pages [ i ] , order ) ; j = 1 << order ; while ( j ) { pages [ i ++ ] = NULL ; -- j ; } } return ; } i = 0 ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) { unsigned max_size , n2free ; spin_lock_irqsave ( & huge -> lock , irq_flags ) ; while ( ( npages - i ) >= HPAGE_PMD_NR ) { struct page * p = pages [ i ] ; unsigned j ; if ( ! p ) break ; for ( j = 1 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j != HPAGE_PMD_NR ) break ; list_add_tail ( & pages [ i ] -> lru , & huge -> list ) ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) pages [ i ++ ] = NULL ; huge -> npages ++ ; } max_size = _manager -> options . max_size ; max_size /= HPAGE_PMD_NR ; if ( huge -> npages > max_size ) n2free = huge -> npages - max_size ; else n2free = 0 ; spin_unlock_irqrestore ( & huge -> lock , irq_flags ) ; if ( n2free ) ttm_page_pool_free ( huge , n2free , false ) ; } # endif spin_lock_irqsave ( & pool -> lock , irq_flags ) ; while ( i < npages ) { if ( pages [ i ] ) { if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; list_add_tail ( & pages [ i ] -> lru , & pool -> list ) ; pages [ i ] = NULL ; pool -> npages ++ ; } ++ i ; } npages = 0 ; if ( pool -> npages > _manager -> options . max_size ) { npages = pool -> npages - _manager -> options . max_size ; if ( npages < NUM_PAGES_TO_ALLOC ) npages = NUM_PAGES_TO_ALLOC ; } spin_unlock_irqrestore ( & pool -> lock , irq_flags ) ; if ( npages ) ttm_page_pool_free ( pool , npages , false ) ; }
","<S2SV_ModStart> ) if ( ++ p <S2SV_ModEnd> != pages [ <S2SV_ModStart> ) if ( ++ p <S2SV_ModEnd> != pages [
",torvalds@linux/453393369dc9806d2455151e329c599684762428,CVE-2019-19927,https://github.com/torvalds/linux/commit/453393369dc9806d2455151e329c599684762428,2019-12-31T02:15Z,<S2SV_StartBug> if ( p ++ != pages [ i + j ] ) <S2SV_EndBug> <S2SV_StartBug> if ( p ++ != pages [ i + j ] ) <S2SV_EndBug>
1606,CWE-119,"static MB_PREDICTION_MODE read_intra_mode ( vp9_reader * r , const vp9_prob * p ) { return ( MB_PREDICTION_MODE ) vp9_read_tree ( r , vp9_intra_mode_tree , p ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static PREDICTION_MODE read_intra_mode ( vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> r , const vpx_prob <S2SV_ModEnd> * p ) <S2SV_ModStart> { return ( PREDICTION_MODE ) vpx_read_tree <S2SV_ModEnd> ( r ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode ( vp9_reader * r , const vp9_prob * p ) { <S2SV_EndBug> <S2SV_StartBug> return ( MB_PREDICTION_MODE ) vp9_read_tree ( r , vp9_intra_mode_tree , p ) ; <S2SV_EndBug>"
1365,CWE-119,"void vp8_default_bmode_probs ( vp8_prob p [ VP8_BINTRAMODES - 1 ] ) { vpx_memcpy ( p , vp8_bmode_prob , sizeof ( vp8_bmode_prob ) ) ; }
","<S2SV_ModStart> ] ) { memcpy <S2SV_ModEnd> ( p ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( p , vp8_bmode_prob , sizeof ( vp8_bmode_prob ) ) ; <S2SV_EndBug>"
3109,CWE-20,"static int dccp_packet ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info ctinfo , u_int8_t pf , unsigned int hooknum , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; enum ip_conntrack_dir dir = CTINFO2DIR ( ctinfo ) ; struct dccp_hdr _dh , * dh ; u_int8_t type , old_state , new_state ; enum ct_dccp_roles role ; dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; BUG_ON ( dh == NULL ) ; type = dh -> dccph_type ; if ( type == DCCP_PKT_RESET && ! test_bit ( IPS_SEEN_REPLY_BIT , & ct -> status ) ) { nf_ct_kill_acct ( ct , ctinfo , skb ) ; return NF_ACCEPT ; } spin_lock_bh ( & ct -> lock ) ; role = ct -> proto . dccp . role [ dir ] ; old_state = ct -> proto . dccp . state ; new_state = dccp_state_table [ role ] [ type ] [ old_state ] ; switch ( new_state ) { case CT_DCCP_REQUEST : if ( old_state == CT_DCCP_TIMEWAIT && role == CT_DCCP_ROLE_SERVER ) { ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_SERVER ; } break ; case CT_DCCP_RESPOND : if ( old_state == CT_DCCP_REQUEST ) ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; break ; case CT_DCCP_PARTOPEN : if ( old_state == CT_DCCP_RESPOND && type == DCCP_PKT_ACK && dccp_ack_seq ( dh ) == ct -> proto . dccp . handshake_seq ) set_bit ( IPS_ASSURED_BIT , & ct -> status ) ; break ; case CT_DCCP_IGNORE : if ( ct -> proto . dccp . last_dir == ! dir && ct -> proto . dccp . last_pkt == DCCP_PKT_REQUEST && type == DCCP_PKT_RESPONSE ) { ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; new_state = CT_DCCP_RESPOND ; break ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; spin_unlock_bh ( & ct -> lock ) ; if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>packet<S2SV_blank>ignored<S2SV_blank>"" ) ; return NF_ACCEPT ; case CT_DCCP_INVALID : spin_unlock_bh ( & ct -> lock ) ; if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>"" ) ; return - NF_ACCEPT ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; ct -> proto . dccp . state = new_state ; spin_unlock_bh ( & ct -> lock ) ; if ( new_state != old_state ) nf_conntrack_event_cache ( IPCT_PROTOINFO , ct ) ; nf_ct_refresh_acct ( ct , ctinfo , skb , timeouts [ new_state ] ) ; return NF_ACCEPT ; }
","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
",torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug>"
3167,CWE-189,"int midi_synth_load_patch ( int dev , int format , const char __user * addr , int offs , int count , int pmgr_flag ) { int orig_dev = synth_devs [ dev ] -> midi_dev ; struct sysex_info sysex ; int i ; unsigned long left , src_offs , eox_seen = 0 ; int first_byte = 1 ; int hdr_size = ( unsigned long ) & sysex . data [ 0 ] - ( unsigned long ) & sysex ; leave_sysex ( dev ) ; if ( ! prefix_cmd ( orig_dev , 0xf0 ) ) return 0 ; if ( format != SYSEX_PATCH ) { return - EINVAL ; } if ( count < hdr_size ) { return - EINVAL ; } count -= hdr_size ; if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) ) return - EFAULT ; if ( count < sysex . len ) { sysex . len = count ; } left = sysex . len ; src_offs = 0 ; for ( i = 0 ; i < left && ! signal_pending ( current ) ; i ++ ) { unsigned char data ; if ( get_user ( data , ( unsigned char __user * ) ( addr + hdr_size + i ) ) ) return - EFAULT ; eox_seen = ( i > 0 && data & 0x80 ) ; if ( eox_seen && data != 0xf7 ) data = 0xf7 ; if ( i == 0 ) { if ( data != 0xf0 ) { printk ( KERN_WARNING ""midi_synth:<S2SV_blank>Sysex<S2SV_blank>start<S2SV_blank>missing\\n"" ) ; return - EINVAL ; } } while ( ! midi_devs [ orig_dev ] -> outputc ( orig_dev , ( unsigned char ) ( data & 0xff ) ) && ! signal_pending ( current ) ) schedule ( ) ; if ( ! first_byte && data & 0x80 ) return 0 ; first_byte = 0 ; } if ( ! eox_seen ) midi_outc ( orig_dev , 0xf7 ) ; return 0 ; }
","<S2SV_ModStart> * addr , <S2SV_ModEnd> int count , <S2SV_ModStart> != SYSEX_PATCH ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> if ( count <S2SV_ModStart> < hdr_size ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> count -= hdr_size <S2SV_ModStart> copy_from_user ( & sysex , addr , hdr_size <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( ( unsigned ) count < ( unsigned ) <S2SV_ModEnd> sysex . len <S2SV_ModStart> . len ) <S2SV_ModEnd> sysex . len <S2SV_ModStart> = count ; <S2SV_ModEnd> left = sysex
",torvalds@linux/b769f49463711205d57286e64cf535ed4daf59e9,CVE-2011-1476,https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9,2012-06-21T23:55Z,"<S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) ) <S2SV_EndBug> <S2SV_StartBug> if ( count < sysex . len ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
699,CWE-189,"TSQuery parse_tsquery ( char * buf , PushFunction pushval , Datum opaque , bool isplain ) { struct TSQueryParserStateData state ; int i ; TSQuery query ; int commonlen ; QueryItem * ptr ; ListCell * cell ; state . buffer = buf ; state . buf = buf ; state . state = ( isplain ) ? WAITSINGLEOPERAND : WAITFIRSTOPERAND ; state . count = 0 ; state . polstr = NIL ; state . valstate = init_tsvector_parser ( state . buffer , true , true ) ; state . sumlen = 0 ; state . lenop = 64 ; state . curop = state . op = ( char * ) palloc ( state . lenop ) ; * ( state . curop ) = '\\0' ; makepol ( & state , pushval , opaque ) ; close_tsvector_parser ( state . valstate ) ; if ( list_length ( state . polstr ) == 0 ) { ereport ( NOTICE , ( errmsg ( ""text-search<S2SV_blank>query<S2SV_blank>doesn\'t<S2SV_blank>contain<S2SV_blank>lexemes:<S2SV_blank>\\""%s\\"""" , state . buffer ) ) ) ; query = ( TSQuery ) palloc ( HDRSIZETQ ) ; SET_VARSIZE ( query , HDRSIZETQ ) ; query -> size = 0 ; return query ; } commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ; query = ( TSQuery ) palloc0 ( commonlen ) ; SET_VARSIZE ( query , commonlen ) ; query -> size = list_length ( state . polstr ) ; ptr = GETQUERY ( query ) ; i = 0 ; foreach ( cell , state . polstr ) { QueryItem * item = ( QueryItem * ) lfirst ( cell ) ; switch ( item -> type ) { case QI_VAL : memcpy ( & ptr [ i ] , item , sizeof ( QueryOperand ) ) ; break ; case QI_VALSTOP : ptr [ i ] . type = QI_VALSTOP ; break ; case QI_OPR : memcpy ( & ptr [ i ] , item , sizeof ( QueryOperator ) ) ; break ; default : elog ( ERROR , ""unrecognized<S2SV_blank>QueryItem<S2SV_blank>type:<S2SV_blank>%d"" , item -> type ) ; } i ++ ; } memcpy ( ( void * ) GETOPERAND ( query ) , ( void * ) state . op , state . sumlen ) ; pfree ( state . op ) ; findoprnd ( ptr , query -> size ) ; return query ; }
","<S2SV_ModStart> query ; } if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,<S2SV_StartBug> } <S2SV_EndBug>
721,CWE-665,"int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; int format_chunk = 0 ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { int supported = TRUE , format ; if ( format_chunk ++ ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> ; uint32_t bcount ; CLEAR ( WaveHeader )
",dbry@WavPack/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe,CVE-2019-1010319,https://github.com/dbry/WavPack/commit/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe,2019-07-11T20:15Z,<S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug>
5511,CWE-190,"static s32 gf_hevc_read_sps_bs_internal ( GF_BitStream * bs , HEVCState * hevc , u8 layer_id , u32 * vui_flag_pos ) { s32 vps_id , sps_id = - 1 ; u32 i , nb_CTUs , depth ; HEVC_SPS * sps ; HEVC_VPS * vps ; HEVC_ProfileTierLevel ptl ; Bool multiLayerExtSpsFlag ; u8 sps_ext_or_max_sub_layers_minus1 , max_sub_layers_minus1 ; if ( vui_flag_pos ) * vui_flag_pos = 0 ; vps_id = gf_bs_read_int_log ( bs , 4 , ""vps_id"" ) ; if ( vps_id >= 16 ) { return - 1 ; } memset ( & ptl , 0 , sizeof ( ptl ) ) ; max_sub_layers_minus1 = 0 ; sps_ext_or_max_sub_layers_minus1 = 0 ; if ( layer_id == 0 ) max_sub_layers_minus1 = gf_bs_read_int_log ( bs , 3 , ""max_sub_layers_minus1"" ) ; else sps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log ( bs , 3 , ""sps_ext_or_max_sub_layers_minus1"" ) ; multiLayerExtSpsFlag = ( layer_id != 0 ) && ( sps_ext_or_max_sub_layers_minus1 == 7 ) ; if ( ! multiLayerExtSpsFlag ) { gf_bs_read_int_log ( bs , 1 , ""temporal_id_nesting_flag"" ) ; hevc_profile_tier_level ( bs , 1 , max_sub_layers_minus1 , & ptl , 0 ) ; } sps_id = gf_bs_read_ue_log ( bs , ""sps_id"" ) ; if ( ( sps_id < 0 ) || ( sps_id >= 16 ) ) { return - 1 ; } sps = & hevc -> sps [ sps_id ] ; if ( ! sps -> state ) { sps -> state = 1 ; sps -> id = sps_id ; sps -> vps_id = vps_id ; } sps -> ptl = ptl ; vps = & hevc -> vps [ vps_id ] ; sps -> max_sub_layers_minus1 = 0 ; sps -> sps_ext_or_max_sub_layers_minus1 = 0 ; sps -> colour_primaries = 2 ; sps -> transfer_characteristic = 2 ; sps -> matrix_coeffs = 2 ; if ( multiLayerExtSpsFlag ) { sps -> update_rep_format_flag = gf_bs_read_int_log ( bs , 1 , ""update_rep_format_flag"" ) ; if ( sps -> update_rep_format_flag ) { sps -> rep_format_idx = gf_bs_read_int_log ( bs , 8 , ""rep_format_idx"" ) ; } else { sps -> rep_format_idx = vps -> rep_format_idx [ layer_id ] ; } sps -> width = vps -> rep_formats [ sps -> rep_format_idx ] . pic_width_luma_samples ; sps -> height = vps -> rep_formats [ sps -> rep_format_idx ] . pic_height_luma_samples ; sps -> chroma_format_idc = vps -> rep_formats [ sps -> rep_format_idx ] . chroma_format_idc ; sps -> bit_depth_luma = vps -> rep_formats [ sps -> rep_format_idx ] . bit_depth_luma ; sps -> bit_depth_chroma = vps -> rep_formats [ sps -> rep_format_idx ] . bit_depth_chroma ; sps -> separate_colour_plane_flag = vps -> rep_formats [ sps -> rep_format_idx ] . separate_colour_plane_flag ; sps -> ptl = vps -> ext_ptl [ 0 ] ; } else { sps -> chroma_format_idc = gf_bs_read_ue_log ( bs , ""chroma_format_idc"" ) ; if ( sps -> chroma_format_idc == 3 ) sps -> separate_colour_plane_flag = gf_bs_read_int_log ( bs , 1 , ""separate_colour_plane_flag"" ) ; sps -> width = gf_bs_read_ue_log ( bs , ""width"" ) ; sps -> height = gf_bs_read_ue_log ( bs , ""height"" ) ; if ( ( sps -> cw_flag = gf_bs_read_int_log ( bs , 1 , ""conformance_window_flag"" ) ) ) { u32 SubWidthC , SubHeightC ; if ( sps -> chroma_format_idc == 1 ) { SubWidthC = SubHeightC = 2 ; } else if ( sps -> chroma_format_idc == 2 ) { SubWidthC = 2 ; SubHeightC = 1 ; } else { SubWidthC = SubHeightC = 1 ; } sps -> cw_left = gf_bs_read_ue_log ( bs , ""conformance_window_left"" ) ; sps -> cw_right = gf_bs_read_ue_log ( bs , ""conformance_window_right"" ) ; sps -> cw_top = gf_bs_read_ue_log ( bs , ""conformance_window_top"" ) ; sps -> cw_bottom = gf_bs_read_ue_log ( bs , ""conformance_window_bottom"" ) ; sps -> width -= SubWidthC * ( sps -> cw_left + sps -> cw_right ) ; sps -> height -= SubHeightC * ( sps -> cw_top + sps -> cw_bottom ) ; } sps -> bit_depth_luma = 8 + gf_bs_read_ue_log ( bs , ""bit_depth_luma_minus8"" ) ; sps -> bit_depth_chroma = 8 + gf_bs_read_ue_log ( bs , ""bit_depth_chroma_minus8"" ) ; } sps -> log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log ( bs , ""log2_max_pic_order_cnt_lsb_minus4"" ) ; if ( ! multiLayerExtSpsFlag ) { sps -> sub_layer_ordering_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""sub_layer_ordering_info_present_flag"" ) ; for ( i = sps -> sub_layer_ordering_info_present_flag ? 0 : sps -> max_sub_layers_minus1 ; i <= sps -> max_sub_layers_minus1 ; i ++ ) { gf_bs_read_ue_log_idx ( bs , ""max_dec_pic_buffering"" , i ) ; gf_bs_read_ue_log_idx ( bs , ""num_reorder_pics"" , i ) ; gf_bs_read_ue_log_idx ( bs , ""max_latency_increase"" , i ) ; } } sps -> log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log ( bs , ""log2_min_luma_coding_block_size_minus3"" ) ; sps -> log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log ( bs , ""log2_diff_max_min_luma_coding_block_size"" ) ; sps -> max_CU_width = ( 1 << ( sps -> log2_min_luma_coding_block_size + sps -> log2_diff_max_min_luma_coding_block_size ) ) ; sps -> max_CU_height = ( 1 << ( sps -> log2_min_luma_coding_block_size + sps -> log2_diff_max_min_luma_coding_block_size ) ) ; sps -> log2_min_transform_block_size = 2 + gf_bs_read_ue_log ( bs , ""log2_min_transform_block_size_minus2"" ) ; sps -> log2_max_transform_block_size = sps -> log2_min_transform_block_size + gf_bs_read_ue_log ( bs , ""log2_max_transform_block_size"" ) ; depth = 0 ; sps -> max_transform_hierarchy_depth_inter = gf_bs_read_ue_log ( bs , ""max_transform_hierarchy_depth_inter"" ) ; sps -> max_transform_hierarchy_depth_intra = gf_bs_read_ue_log ( bs , ""max_transform_hierarchy_depth_intra"" ) ; while ( ( u32 ) ( sps -> max_CU_width >> sps -> log2_diff_max_min_luma_coding_block_size ) > ( u32 ) ( 1 << ( sps -> log2_min_transform_block_size + depth ) ) ) { depth ++ ; } sps -> max_CU_depth = sps -> log2_diff_max_min_luma_coding_block_size + depth ; nb_CTUs = ( ( sps -> width + sps -> max_CU_width - 1 ) / sps -> max_CU_width ) * ( ( sps -> height + sps -> max_CU_height - 1 ) / sps -> max_CU_height ) ; sps -> bitsSliceSegmentAddress = 0 ; while ( nb_CTUs > ( u32 ) ( 1 << sps -> bitsSliceSegmentAddress ) ) { sps -> bitsSliceSegmentAddress ++ ; } sps -> scaling_list_enable_flag = gf_bs_read_int_log ( bs , 1 , ""scaling_list_enable_flag"" ) ; if ( sps -> scaling_list_enable_flag ) { sps -> infer_scaling_list_flag = 0 ; sps -> scaling_list_ref_layer_id = 0 ; if ( multiLayerExtSpsFlag ) { sps -> infer_scaling_list_flag = gf_bs_read_int_log ( bs , 1 , ""infer_scaling_list_flag"" ) ; } if ( sps -> infer_scaling_list_flag ) { sps -> scaling_list_ref_layer_id = gf_bs_read_int_log ( bs , 6 , ""scaling_list_ref_layer_id"" ) ; } else { sps -> scaling_list_data_present_flag = gf_bs_read_int_log ( bs , 1 , ""scaling_list_data_present_flag"" ) ; if ( sps -> scaling_list_data_present_flag ) { hevc_scaling_list_data ( bs ) ; } } } sps -> asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""asymmetric_motion_partitions_enabled_flag"" ) ; sps -> sample_adaptive_offset_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""sample_adaptive_offset_enabled_flag"" ) ; if ( ( sps -> pcm_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""pcm_enabled_flag"" ) ) ) { sps -> pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log ( bs , 4 , ""pcm_sample_bit_depth_luma_minus1"" ) ; sps -> pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log ( bs , 4 , ""pcm_sample_bit_depth_chroma_minus1"" ) ; sps -> log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log ( bs , ""log2_min_pcm_luma_coding_block_size_minus3"" ) ; sps -> log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log ( bs , ""log2_diff_max_min_pcm_luma_coding_block_size"" ) ; sps -> pcm_loop_filter_disable_flag = gf_bs_read_int_log ( bs , 1 , ""pcm_loop_filter_disable_flag"" ) ; } sps -> num_short_term_ref_pic_sets = gf_bs_read_ue_log ( bs , ""num_short_term_ref_pic_sets"" ) ; if ( sps -> num_short_term_ref_pic_sets > 64 ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( ""[HEVC]<S2SV_blank>Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>short<S2SV_blank>term<S2SV_blank>reference<S2SV_blank>picture<S2SV_blank>sets<S2SV_blank>%d\\n"" , sps -> num_short_term_ref_pic_sets ) ) ; return - 1 ; } for ( i = 0 ; i < sps -> num_short_term_ref_pic_sets ; i ++ ) { Bool ret = hevc_parse_short_term_ref_pic_set ( bs , sps , i ) ; if ( ! ret ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( ""[HEVC]<S2SV_blank>Invalid<S2SV_blank>short_term_ref_pic_set\\n"" ) ) ; return - 1 ; } } sps -> long_term_ref_pics_present_flag = gf_bs_read_int_log ( bs , 1 , ""long_term_ref_pics_present_flag"" ) ; if ( sps -> long_term_ref_pics_present_flag ) { sps -> num_long_term_ref_pic_sps = gf_bs_read_ue_log ( bs , ""num_long_term_ref_pic_sps"" ) ; for ( i = 0 ; i < sps -> num_long_term_ref_pic_sps ; i ++ ) { gf_bs_read_int_log_idx ( bs , sps -> log2_max_pic_order_cnt_lsb , ""lt_ref_pic_poc_lsb_sps"" , i ) ; gf_bs_read_int_log_idx ( bs , 1 , ""used_by_curr_pic_lt_sps_flag"" , i ) ; } } sps -> temporal_mvp_enable_flag = gf_bs_read_int_log ( bs , 1 , ""temporal_mvp_enable_flag"" ) ; sps -> strong_intra_smoothing_enable_flag = gf_bs_read_int_log ( bs , 1 , ""strong_intra_smoothing_enable_flag"" ) ; if ( vui_flag_pos ) * vui_flag_pos = ( u32 ) gf_bs_get_bit_offset ( bs ) ; if ( ( sps -> vui_parameters_present_flag = gf_bs_read_int_log ( bs , 1 , ""vui_parameters_present_flag"" ) ) ) { sps -> aspect_ratio_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""aspect_ratio_info_present_flag"" ) ; if ( sps -> aspect_ratio_info_present_flag ) { sps -> sar_idc = gf_bs_read_int_log ( bs , 8 , ""aspect_ratio_idc"" ) ; if ( sps -> sar_idc == 255 ) { sps -> sar_width = gf_bs_read_int_log ( bs , 16 , ""aspect_ratio_width"" ) ; sps -> sar_height = gf_bs_read_int_log ( bs , 16 , ""aspect_ratio_height"" ) ; } else if ( sps -> sar_idc < 17 ) { sps -> sar_width = hevc_sar [ sps -> sar_idc ] . w ; sps -> sar_height = hevc_sar [ sps -> sar_idc ] . h ; } } if ( ( sps -> overscan_info_present = gf_bs_read_int_log ( bs , 1 , ""overscan_info_present"" ) ) ) sps -> overscan_appropriate = gf_bs_read_int_log ( bs , 1 , ""overscan_appropriate"" ) ; sps -> video_signal_type_present_flag = gf_bs_read_int_log ( bs , 1 , ""video_signal_type_present_flag"" ) ; if ( sps -> video_signal_type_present_flag ) { sps -> video_format = gf_bs_read_int_log ( bs , 3 , ""video_format"" ) ; sps -> video_full_range_flag = gf_bs_read_int_log ( bs , 1 , ""video_full_range_flag"" ) ; if ( ( sps -> colour_description_present_flag = gf_bs_read_int_log ( bs , 1 , ""colour_description_present_flag"" ) ) ) { sps -> colour_primaries = gf_bs_read_int_log ( bs , 8 , ""colour_primaries"" ) ; sps -> transfer_characteristic = gf_bs_read_int_log ( bs , 8 , ""transfer_characteristic"" ) ; sps -> matrix_coeffs = gf_bs_read_int_log ( bs , 8 , ""matrix_coefficients"" ) ; } } if ( ( sps -> chroma_loc_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""chroma_loc_info_present_flag"" ) ) ) { sps -> chroma_sample_loc_type_top_field = gf_bs_read_ue_log ( bs , ""chroma_sample_loc_type_top_field"" ) ; sps -> chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log ( bs , ""chroma_sample_loc_type_bottom_field"" ) ; } sps -> neutra_chroma_indication_flag = gf_bs_read_int_log ( bs , 1 , ""neutra_chroma_indication_flag"" ) ; sps -> field_seq_flag = gf_bs_read_int_log ( bs , 1 , ""field_seq_flag"" ) ; sps -> frame_field_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""frame_field_info_present_flag"" ) ; if ( ( sps -> default_display_window_flag = gf_bs_read_int_log ( bs , 1 , ""default_display_window_flag"" ) ) ) { sps -> left_offset = gf_bs_read_ue_log ( bs , ""display_window_left_offset"" ) ; sps -> right_offset = gf_bs_read_ue_log ( bs , ""display_window_right_offset"" ) ; sps -> top_offset = gf_bs_read_ue_log ( bs , ""display_window_top_offset"" ) ; sps -> bottom_offset = gf_bs_read_ue_log ( bs , ""display_window_bottom_offset"" ) ; } sps -> has_timing_info = gf_bs_read_int_log ( bs , 1 , ""has_timing_info"" ) ; if ( sps -> has_timing_info ) { sps -> num_units_in_tick = gf_bs_read_int_log ( bs , 32 , ""num_units_in_tick"" ) ; sps -> time_scale = gf_bs_read_int_log ( bs , 32 , ""time_scale"" ) ; sps -> poc_proportional_to_timing_flag = gf_bs_read_int_log ( bs , 1 , ""poc_proportional_to_timing_flag"" ) ; if ( sps -> poc_proportional_to_timing_flag ) sps -> num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log ( bs , ""num_ticks_poc_diff_one_minus1"" ) ; if ( ( sps -> hrd_parameters_present_flag = gf_bs_read_int_log ( bs , 1 , ""hrd_parameters_present_flag"" ) ) ) { return sps_id ; } } if ( gf_bs_read_int_log ( bs , 1 , ""bitstream_restriction_flag"" ) ) { gf_bs_read_int_log ( bs , 1 , ""tiles_fixed_structure_flag"" ) ; gf_bs_read_int_log ( bs , 1 , ""motion_vectors_over_pic_boundaries_flag"" ) ; gf_bs_read_int_log ( bs , 1 , ""restricted_ref_pic_lists_flag"" ) ; gf_bs_read_ue_log ( bs , ""min_spatial_segmentation_idc"" ) ; gf_bs_read_ue_log ( bs , ""max_bytes_per_pic_denom"" ) ; gf_bs_read_ue_log ( bs , ""max_bits_per_min_cu_denom"" ) ; gf_bs_read_ue_log ( bs , ""log2_max_mv_length_horizontal"" ) ; gf_bs_read_ue_log ( bs , ""log2_max_mv_length_vertical"" ) ; } } if ( gf_bs_read_int_log ( bs , 1 , ""sps_extension_flag"" ) ) { # if 0 while ( gf_bs_available ( bs ) ) { gf_bs_read_int ( bs , 1 ) ; } # endif } return sps_id ; }
","<S2SV_ModStart> ; if ( ( vps_id < 0 ) || ( <S2SV_ModStart> vps_id >= 16 )
",gpac@gpac/51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,CVE-2021-30022,https://github.com/gpac/gpac/commit/51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,2021-04-19T20:15Z,<S2SV_StartBug> if ( vps_id >= 16 ) { <S2SV_EndBug>
8373,CWE-362,"static int raw_sendmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipcm_cookie ipc ; struct rtable * rt = NULL ; int free = 0 ; __be32 daddr ; __be32 saddr ; u8 tos ; int err ; err = - EMSGSIZE ; if ( len > 0xFFFF ) goto out ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { struct sockaddr_in * usin = ( struct sockaddr_in * ) msg -> msg_name ; err = - EINVAL ; if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ; if ( usin -> sin_family != AF_INET ) { static int complained ; if ( ! complained ++ ) printk ( KERN_INFO ""%s<S2SV_blank>forgot<S2SV_blank>to<S2SV_blank>set<S2SV_blank>AF_INET<S2SV_blank>in<S2SV_blank>"" ""raw<S2SV_blank>sendmsg.<S2SV_blank>Fix<S2SV_blank>it!\\n"" , current -> comm ) ; err = - EAFNOSUPPORT ; if ( usin -> sin_family ) goto out ; } daddr = usin -> sin_addr . s_addr ; } else { err = - EDESTADDRREQ ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; daddr = inet -> inet_daddr ; } ipc . addr = inet -> inet_saddr ; ipc . opt = NULL ; ipc . tx_flags = 0 ; ipc . oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sock_net ( sk ) , msg , & ipc ) ; if ( err ) goto out ; if ( ipc . opt ) free = 1 ; } saddr = ipc . addr ; ipc . addr = daddr ; if ( ! ipc . opt ) ipc . opt = inet -> opt ; if ( ipc . opt ) { err = - EINVAL ; if ( inet -> hdrincl ) goto done ; if ( ipc . opt -> srr ) { if ( ! daddr ) goto done ; daddr = ipc . opt -> faddr ; } } tos = RT_CONN_FLAGS ( sk ) ; if ( msg -> msg_flags & MSG_DONTROUTE ) tos |= RTO_ONLINK ; if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; } { struct flowi4 fl4 ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , FLOWI_FLAG_CAN_SLEEP , daddr , saddr , 0 , 0 ) ; if ( ! inet -> hdrincl ) { err = raw_probe_proto_opt ( & fl4 , msg ) ; if ( err ) goto done ; } security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( sock_net ( sk ) , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; goto done ; } } err = - EACCES ; if ( rt -> rt_flags & RTCF_BROADCAST && ! sock_flag ( sk , SOCK_BROADCAST ) ) goto done ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = raw_send_hdrinc ( sk , msg -> msg_iov , len , & rt , msg -> msg_flags ) ; else { if ( ! ipc . addr ) ipc . addr = rt -> rt_dst ; lock_sock ( sk ) ; err = ip_append_data ( sk , ip_generic_getfrag , msg -> msg_iov , len , 0 , & ipc , & rt , msg -> msg_flags ) ; if ( err ) ip_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) { err = ip_push_pending_frames ( sk ) ; if ( err == - ENOBUFS && ! inet -> recverr ) err = 0 ; } release_sock ( sk ) ; } done : if ( free ) kfree ( ipc . opt ) ; ip_rt_put ( rt ) ; out : if ( err < 0 ) return err ; return len ; do_confirm : dst_confirm ( & rt -> dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }
","<S2SV_ModStart> int err ; struct ip_options_data opt_copy ; <S2SV_ModStart> . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } <S2SV_ModEnd> if ( ipc <S2SV_ModStart> . opt -> opt . <S2SV_ModStart> . opt -> opt .
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> <S2SV_StartBug> ipc . opt = inet -> opt ; <S2SV_EndBug> <S2SV_StartBug> if ( ipc . opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> daddr = ipc . opt -> faddr ; <S2SV_EndBug>
2208,CWE-000,"int iwch_cxgb3_ofld_send ( struct t3cdev * tdev , struct sk_buff * skb ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = cxgb3_ofld_send ( tdev , skb ) ; if ( error < 0 ) kfree_skb ( skb ) ; return error ; }
","<S2SV_ModStart> ; return error < 0 ? error : 0
",torvalds@linux/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3,CVE-2015-8812,https://github.com/torvalds/linux/commit/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3,2016-04-27T17:59Z,<S2SV_StartBug> return error ; <S2SV_EndBug>
4156,CWE-617,"krb5_error_code kdc_process_s4u2proxy_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , const krb5_enc_tkt_part * t2enc , const krb5_db_entry * server , krb5_const_principal server_princ , krb5_const_principal proxy_princ , const char * * status ) { krb5_error_code errcode ; if ( request -> kdc_options & ( NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY ) ) { return KRB5KDC_ERR_BADOPTION ; } if ( ! krb5_principal_compare ( kdc_context , server -> princ , server_princ ) ) { return KRB5KDC_ERR_SERVER_NOMATCH ; } if ( ! isflagset ( t2enc -> flags , TKT_FLG_FORWARDABLE ) ) { * status = ""EVIDENCE_TKT_NOT_FORWARDABLE"" ; return KRB5_TKT_NOT_FORWARDABLE ; } errcode = check_allowed_to_delegate_to ( kdc_context , t2enc -> client , server , proxy_princ ) ; if ( errcode ) { * status = ""NOT_ALLOWED_TO_DELEGATE"" ; return errcode ; } return 0 ; }
","<S2SV_ModStart> ) ) { * status = ""INVALID_S4U2PROXY_OPTIONS"" ; <S2SV_ModStart> ) ) { * status = ""EVIDENCE_TICKET_MISMATCH"" ;
",krb5@krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970,CVE-2017-11368,https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970,2017-08-09T18:29Z,<S2SV_StartBug> return KRB5KDC_ERR_BADOPTION ; <S2SV_EndBug> <S2SV_StartBug> server_princ ) ) { <S2SV_EndBug>
3472,CWE-20,"static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; register Quantum * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowCUTReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; ldblk = 0 ; while ( ( int ) RunCountMasked != 0 ) { i = 1 ; if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; if ( offset < 0 ) ThrowCUTReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; EncodedByte -= i + 1 ; ldblk += ( ssize_t ) RunCountMasked ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; RunCountMasked = RunCount & 0x7F ; } if ( EncodedByte != 1 ) goto CUT_KO ; i = 0 ; if ( ldblk == ( int ) Header . Width ) i = 8 ; if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; if ( i == 0 ) goto CUT_KO ; depth = i ; image -> columns = Header . Width ; image -> rows = Header . Height ; image -> depth = 8 ; image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; if ( image_info -> ping != MagickFalse ) goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; i = ( ssize_t ) strlen ( clone_info -> filename ) ; j = i ; while ( -- i > 0 ) { if ( clone_info -> filename [ i ] == '.' ) { break ; } if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\' || clone_info -> filename [ i ] == ':' ) { i = j ; break ; } } ( void ) CopyMagickString ( clone_info -> filename + i , "".PAL"" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { ( void ) CopyMagickString ( clone_info -> filename + i , "".pal"" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info -> filename [ i ] = '\\0' ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info = DestroyImageInfo ( clone_info ) ; clone_info = NULL ; goto NoPalette ; } } } if ( ( palette = AcquireImage ( clone_info , exception ) ) == NULL ) goto NoPalette ; status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ErasePalette : palette = DestroyImage ( palette ) ; palette = NULL ; goto NoPalette ; } if ( palette != NULL ) { ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; if ( strncmp ( PalHeader . FileId , ""AH"" , 2 ) != 0 ) goto ErasePalette ; PalHeader . Version = ReadBlobLSBShort ( palette ) ; PalHeader . Size = ReadBlobLSBShort ( palette ) ; PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; image -> colors = PalHeader . MaxIndex + 1 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) goto NoMemory ; if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) { j = ( ssize_t ) TellBlob ( palette ) ; if ( ( j % 512 ) > 512 - 6 ) { j = ( ( j / 512 ) + 1 ) * 512 ; offset = SeekBlob ( palette , j , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / PalHeader . MaxRed ) ; } image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) { image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; } image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) { image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; } } if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } NoPalette : if ( palette == NULL ) { image -> colors = 256 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { NoMemory : ThrowCUTReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == NULL ) goto NoMemory ; offset = SeekBlob ( image , 6 , SEEK_SET ) ; if ( offset < 0 ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) { EncodedByte = ReadBlobLSBShort ( image ) ; ptrB = BImgBuff ; j = ldblk ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; while ( ( int ) RunCountMasked != 0 ) { if ( ( ssize_t ) RunCountMasked > j ) { RunCountMasked = ( unsigned char ) j ; if ( j == 0 ) { break ; } } if ( ( int ) RunCount > 0x80 ) { RunValue = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) memset ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; } else { ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; } ptrB += ( int ) RunCountMasked ; j -= ( int ) RunCountMasked ; if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; } InsertRow ( image , depth , BImgBuff , i , exception ) ; } ( void ) SyncImage ( image , exception ) ; if ( palette == NULL ) { if ( ( image -> storage_class == PseudoClass ) && ( SetImageGray ( image , exception ) != MagickFalse ) ) { if ( GetCutColors ( image , exception ) == 2 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { register Quantum sample ; sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; if ( image -> colormap [ i ] . red != sample ) goto Finish ; if ( image -> colormap [ i ] . green != sample ) goto Finish ; if ( image -> colormap [ i ] . blue != sample ) goto Finish ; } image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) { if ( GetPixelRed ( image , q ) == ScaleCharToQuantum ( 1 ) ) { SetPixelRed ( image , QuantumRange , q ) ; SetPixelGreen ( image , QuantumRange , q ) ; SetPixelBlue ( image , QuantumRange , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; } } } } Finish : if ( BImgBuff != NULL ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , tag ) \\\n{ <S2SV_ModEnd> if ( palette <S2SV_ModStart> tag ) ; \\\n} <S2SV_ModEnd> Image * image <S2SV_ModStart> goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
",ImageMagick@ImageMagick/cdb383749ef7b68a38891440af8cc23e0115306d,CVE-2019-13135,https://github.com/ImageMagick/ImageMagick/commit/cdb383749ef7b68a38891440af8cc23e0115306d,2019-07-01T20:15Z,"<S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug>"
4046,CWE-362,"static struct sock * dccp_v6_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * ireq6 = inet6_rsk ( req ) ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; struct ipv6_txoptions * opt ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( dst == NULL ) { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; ipv6_addr_copy ( & fl6 . daddr , & ireq6 -> rmt_addr ) ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; ipv6_addr_copy ( & fl6 . saddr , & ireq6 -> loc_addr ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = inet_rsk ( req ) -> rmt_port ; fl6 . fl6_sport = inet_rsk ( req ) -> loc_port ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p , false ) ; if ( IS_ERR ( dst ) ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & ireq6 -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & ireq6 -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & ireq6 -> loc_addr ) ; newsk -> sk_bound_dev_if = ireq6 -> iif ; newinet -> opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( ireq6 -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( ireq6 -> pktopts , GFP_ATOMIC ) ; kfree_skb ( ireq6 -> pktopts ) ; ireq6 -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt != NULL ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; if ( opt != NULL && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; return NULL ; }
","<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug>
4552,CWE-125,"static int FstringParser_ConcatFstring ( FstringParser * state , const char * * str , const char * end , int raw , int recurse_lvl , struct compiling * c , const node * n ) { FstringParser_check_invariants ( state ) ; while ( 1 ) { PyObject * literal = NULL ; expr_ty expression = NULL ; int result = fstring_find_literal_and_expr ( str , end , raw , recurse_lvl , & literal , & expression , c , n ) ; if ( result < 0 ) return - 1 ; if ( ! literal ) { } else if ( ! state -> last_str ) { state -> last_str = literal ; literal = NULL ; } else { assert ( PyUnicode_GET_LENGTH ( literal ) != 0 ) ; if ( FstringParser_ConcatAndDel ( state , literal ) < 0 ) return - 1 ; literal = NULL ; } assert ( ! state -> last_str || PyUnicode_GET_LENGTH ( state -> last_str ) != 0 ) ; assert ( literal == NULL ) ; if ( result == 1 ) continue ; if ( ! expression ) break ; if ( ! state -> last_str ) { } else { expr_ty str = make_str_node_and_del ( & state -> last_str , c , n ) ; if ( ! str || ExprList_Append ( & state -> expr_list , str ) < 0 ) return - 1 ; } if ( ExprList_Append ( & state -> expr_list , expression ) < 0 ) return - 1 ; } if ( recurse_lvl == 0 && * str < end - 1 ) { ast_error ( c , n , ""f-string:<S2SV_blank>unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>string"" ) ; return - 1 ; } if ( recurse_lvl != 0 && * * str != '}' ) { ast_error ( c , n , ""f-string:<S2SV_blank>expecting<S2SV_blank>\'}\'"" ) ; return - 1 ; } FstringParser_check_invariants ( state ) ; return 0 ; }
","<S2SV_ModStart> state ) ; state -> fmode = 1 ; <S2SV_ModStart> } assert ( <S2SV_ModEnd> literal == NULL
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> while ( 1 ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! state -> last_str || <S2SV_EndBug>
3254,CWE-125,"static int decode_rt_routing_info ( netdissect_options * ndo , const u_char * pptr , char * buf , u_int buflen ) { uint8_t route_target [ 8 ] ; u_int plen ; ND_TCHECK ( pptr [ 0 ] ) ; plen = pptr [ 0 ] ; if ( 0 == plen ) { snprintf ( buf , buflen , ""default<S2SV_blank>route<S2SV_blank>target"" ) ; return 1 ; } if ( 32 > plen ) return - 1 ; plen -= 32 ; if ( 64 < plen ) return - 1 ; memset ( & route_target , 0 , sizeof ( route_target ) ) ; ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ; memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ; if ( plen % 8 ) { ( ( u_char * ) & route_target ) [ ( plen + 7 ) / 8 - 1 ] &= ( ( 0xff00 >> ( plen % 8 ) ) & 0xff ) ; } snprintf ( buf , buflen , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ; return 5 + ( plen + 7 ) / 8 ; trunc : return - 2 ; }
","<S2SV_ModStart> u_int plen ; char asbuf [ sizeof ( astostr ) ] ; <S2SV_ModStart> - 1 ; ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <S2SV_ModStart> ( pptr [ 5 <S2SV_ModEnd> ] , ( <S2SV_ModStart> & pptr [ 5 <S2SV_ModEnd> ] , ( <S2SV_ModStart> , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" , asbuf <S2SV_ModEnd> , bgp_vpn_rd_print (
",the-tcpdump-group@tcpdump/bd4e697ebd6c8457efa8f28f6831fc929b88a014,CVE-2017-13053,https://github.com/the-tcpdump-group/tcpdump/commit/bd4e697ebd6c8457efa8f28f6831fc929b88a014,2017-09-14T06:29Z,"<S2SV_StartBug> ND_TCHECK ( pptr [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> plen -= 32 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , <S2SV_EndBug>"
569,CWE-119,"static int kempf_decode_tile ( G2MContext * c , int tile_x , int tile_y , const uint8_t * src , int src_size ) { int width , height ; int hdr , zsize , npal , tidx = - 1 , ret ; int i , j ; const uint8_t * src_end = src + src_size ; uint8_t pal [ 768 ] , transp [ 3 ] ; uLongf dlen = ( c -> tile_width + 1 ) * c -> tile_height ; int sub_type ; int nblocks , cblocks , bstride ; int bits , bitbuf , coded ; uint8_t * dst = c -> framebuf + tile_x * c -> tile_width * 3 + tile_y * c -> tile_height * c -> framebuf_stride ; if ( src_size < 2 ) return AVERROR_INVALIDDATA ; width = FFMIN ( c -> width - tile_x * c -> tile_width , c -> tile_width ) ; height = FFMIN ( c -> height - tile_y * c -> tile_height , c -> tile_height ) ; hdr = * src ++ ; sub_type = hdr >> 5 ; if ( sub_type == 0 ) { int j ; memcpy ( transp , src , 3 ) ; src += 3 ; for ( j = 0 ; j < height ; j ++ , dst += c -> framebuf_stride ) for ( i = 0 ; i < width ; i ++ ) memcpy ( dst + i * 3 , transp , 3 ) ; return 0 ; } else if ( sub_type == 1 ) { return jpg_decode_data ( & c -> jc , width , height , src , src_end - src , dst , c -> framebuf_stride , NULL , 0 , 0 , 0 ) ; } if ( sub_type != 2 ) { memcpy ( transp , src , 3 ) ; src += 3 ; } npal = * src ++ + 1 ; memcpy ( pal , src , npal * 3 ) ; src += npal * 3 ; if ( sub_type != 2 ) { for ( i = 0 ; i < npal ; i ++ ) { if ( ! memcmp ( pal + i * 3 , transp , 3 ) ) { tidx = i ; break ; } } } if ( src_end - src < 2 ) return 0 ; zsize = ( src [ 0 ] << 8 ) | src [ 1 ] ; src += 2 ; if ( src_end - src < zsize ) return AVERROR_INVALIDDATA ; ret = uncompress ( c -> kempf_buf , & dlen , src , zsize ) ; if ( ret ) return AVERROR_INVALIDDATA ; src += zsize ; if ( sub_type == 2 ) { kempf_restore_buf ( c -> kempf_buf , dlen , dst , c -> framebuf_stride , NULL , 0 , width , height , pal , npal , tidx ) ; return 0 ; } nblocks = * src ++ + 1 ; cblocks = 0 ; bstride = FFALIGN ( width , 16 ) >> 4 ; bits = 0 ; for ( i = 0 ; i < ( FFALIGN ( height , 16 ) >> 4 ) ; i ++ ) { for ( j = 0 ; j < ( FFALIGN ( width , 16 ) >> 4 ) ; j ++ ) { if ( ! bits ) { bitbuf = * src ++ ; bits = 8 ; } coded = bitbuf & 1 ; bits -- ; bitbuf >>= 1 ; cblocks += coded ; if ( cblocks > nblocks ) return AVERROR_INVALIDDATA ; c -> kempf_flags [ j + i * bstride ] = coded ; } } memset ( c -> jpeg_tile , 0 , c -> tile_stride * height ) ; jpg_decode_data ( & c -> jc , width , height , src , src_end - src , c -> jpeg_tile , c -> tile_stride , c -> kempf_flags , bstride , nblocks , 0 ) ; kempf_restore_buf ( c -> kempf_buf , dlen , dst , c -> framebuf_stride , c -> jpeg_tile , c -> tile_stride , width , height , pal , npal , tidx ) ; return 0 ; }
","<S2SV_ModStart> src < zsize + ( sub_type != 2 ) <S2SV_ModStart> bits ) { if ( src >= src_end ) return AVERROR_INVALIDDATA ;
",FFmpeg@FFmpeg/2960576378d17d71cc8dccc926352ce568b5eec1,CVE-2013-4264,https://github.com/FFmpeg/FFmpeg/commit/2960576378d17d71cc8dccc926352ce568b5eec1,2013-11-23T17:55Z,<S2SV_StartBug> if ( src_end - src < zsize ) <S2SV_EndBug> <S2SV_StartBug> bitbuf = * src ++ ; <S2SV_EndBug>
2872,CWE-119,"static int decode_cblk ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * codsty , Jpeg2000T1Context * t1 , Jpeg2000Cblk * cblk , int width , int height , int bandpos ) { int passno = cblk -> npasses , pass_t = 2 , bpno = cblk -> nonzerobits - 1 , y ; int clnpass_cnt = 0 ; int bpass_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_BYPASS ; int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; for ( y = 0 ; y < height ; y ++ ) memset ( t1 -> data [ y ] , 0 , width * sizeof ( * * t1 -> data ) ) ; if ( ! cblk -> length ) return 0 ; for ( y = 0 ; y < height + 2 ; y ++ ) memset ( t1 -> flags [ y ] , 0 , ( width + 2 ) * sizeof ( * * t1 -> flags ) ) ; cblk -> data [ cblk -> length ] = 0xff ; cblk -> data [ cblk -> length + 1 ] = 0xff ; ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; while ( passno -- ) { switch ( pass_t ) { case 0 : decode_sigpass ( t1 , width , height , bpno + 1 , bandpos , bpass_csty_symbol && ( clnpass_cnt >= 4 ) , vert_causal_ctx_csty_symbol ) ; break ; case 1 : decode_refpass ( t1 , width , height , bpno + 1 ) ; if ( bpass_csty_symbol && clnpass_cnt >= 4 ) ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; break ; case 2 : decode_clnpass ( s , t1 , width , height , bpno + 1 , bandpos , codsty -> cblk_style & JPEG2000_CBLK_SEGSYM , vert_causal_ctx_csty_symbol ) ; clnpass_cnt = clnpass_cnt + 1 ; if ( bpass_csty_symbol && clnpass_cnt >= 4 ) ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; break ; } pass_t ++ ; if ( pass_t == 3 ) { bpno -- ; pass_t = 0 ; } } return 0 ; }
","<S2SV_ModStart> cblk_style & JPEG2000_CBLK_VSC ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH )
",FFmpeg@FFmpeg/9a271a9368eaabf99e6c2046103acb33957e63b7,CVE-2013-7018,https://github.com/FFmpeg/FFmpeg/commit/9a271a9368eaabf99e6c2046103acb33957e63b7,2013-12-09T16:36Z,<S2SV_StartBug> int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; <S2SV_EndBug>
4867,CWE-362,"static int mptctl_do_mpt_command ( struct mpt_ioctl_command karg , void __user * mfPtr ) { MPT_ADAPTER * ioc ; MPT_FRAME_HDR * mf = NULL ; MPIHeader_t * hdr ; char * psge ; struct buflist bufIn ; struct buflist bufOut ; dma_addr_t dma_addr_in ; dma_addr_t dma_addr_out ; int sgSize = 0 ; int iocnum , flagsLength ; int sz , rc = 0 ; int msgContext ; u16 req_idx ; ulong timeout ; unsigned long timeleft ; struct scsi_device * sdev ; unsigned long flags ; u8 function ; bufIn . kptr = bufOut . kptr = NULL ; bufIn . len = bufOut . len = 0 ; if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_do_mpt_command()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } spin_lock_irqsave ( & ioc -> taskmgmt_lock , flags ) ; if ( ioc -> ioc_reset_in_progress ) { spin_unlock_irqrestore ( & ioc -> taskmgmt_lock , flags ) ; printk ( KERN_ERR MYNAM ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Busy<S2SV_blank>with<S2SV_blank>diagnostic<S2SV_blank>reset\\n"" , __FILE__ , __LINE__ ) ; return - EBUSY ; } spin_unlock_irqrestore ( & ioc -> taskmgmt_lock , flags ) ; if ( karg . maxReplyBytes < 0 || karg . dataInSize < 0 || karg . dataOutSize < 0 || karg . dataSgeOffset < 0 || karg . maxSenseBytes < 0 || karg . dataSgeOffset > ioc -> req_sz / 4 ) return - EINVAL ; sz = karg . dataSgeOffset * 4 ; if ( karg . dataInSize > 0 ) sz += ioc -> SGE_size ; if ( karg . dataOutSize > 0 ) sz += ioc -> SGE_size ; if ( sz > ioc -> req_sz ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Request<S2SV_blank>frame<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d)<S2SV_blank>maximum<S2SV_blank>(%d)\\n"" , ioc -> name , __FILE__ , __LINE__ , sz , ioc -> req_sz ) ; return - EFAULT ; } if ( ( mf = mpt_get_msg_frame ( mptctl_id , ioc ) ) == NULL ) return - EAGAIN ; hdr = ( MPIHeader_t * ) mf ; msgContext = le32_to_cpu ( hdr -> MsgContext ) ; req_idx = le16_to_cpu ( mf -> u . frame . hwhdr . msgctxu . fld . req_idx ) ; if ( copy_from_user ( mf , mfPtr , karg . dataSgeOffset * 4 ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>MF<S2SV_blank>from<S2SV_blank>mpt_ioctl_command<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , mfPtr ) ; function = - 1 ; rc = - EFAULT ; goto done_free_mem ; } hdr -> MsgContext = cpu_to_le32 ( msgContext ) ; function = hdr -> Function ; dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""sending<S2SV_blank>mpi<S2SV_blank>function<S2SV_blank>(0x%02X),<S2SV_blank>req=%p\\n"" , ioc -> name , hdr -> Function , mf ) ) ; switch ( function ) { case MPI_FUNCTION_IOC_FACTS : case MPI_FUNCTION_PORT_FACTS : karg . dataOutSize = karg . dataInSize = 0 ; break ; case MPI_FUNCTION_CONFIG : { Config_t * config_frame ; config_frame = ( Config_t * ) mf ; dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""\\ttype=0x%02x<S2SV_blank>ext_type=0x%02x<S2SV_blank>"" ""number=0x%02x<S2SV_blank>action=0x%02x\\n"" , ioc -> name , config_frame -> Header . PageType , config_frame -> ExtPageType , config_frame -> Header . PageNumber , config_frame -> Action ) ) ; break ; } case MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND : case MPI_FUNCTION_FC_EX_LINK_SRVC_SEND : case MPI_FUNCTION_FW_UPLOAD : case MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR : case MPI_FUNCTION_FW_DOWNLOAD : case MPI_FUNCTION_FC_PRIMITIVE_SEND : case MPI_FUNCTION_TOOLBOX : case MPI_FUNCTION_SAS_IO_UNIT_CONTROL : break ; case MPI_FUNCTION_SCSI_IO_REQUEST : if ( ioc -> sh ) { SCSIIORequest_t * pScsiReq = ( SCSIIORequest_t * ) mf ; int qtag = MPI_SCSIIO_CONTROL_UNTAGGED ; int scsidir = 0 ; int dataSize ; u32 id ; id = ( ioc -> devices_per_bus == 0 ) ? 256 : ioc -> devices_per_bus ; if ( pScsiReq -> TargetID > id ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Target<S2SV_blank>ID<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.<S2SV_blank>\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - ENODEV ; goto done_free_mem ; } if ( pScsiReq -> Bus >= ioc -> number_of_buses ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Target<S2SV_blank>Bus<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.<S2SV_blank>\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - ENODEV ; goto done_free_mem ; } pScsiReq -> MsgFlags &= ~ MPI_SCSIIO_MSGFLGS_SENSE_WIDTH ; pScsiReq -> MsgFlags |= mpt_msg_flags ( ioc ) ; if ( karg . maxSenseBytes > MPT_SENSE_BUFFER_SIZE ) pScsiReq -> SenseBufferLength = MPT_SENSE_BUFFER_SIZE ; else pScsiReq -> SenseBufferLength = karg . maxSenseBytes ; pScsiReq -> SenseBufferLowAddr = cpu_to_le32 ( ioc -> sense_buf_low_dma + ( req_idx * MPT_SENSE_BUFFER_ALLOC ) ) ; shost_for_each_device ( sdev , ioc -> sh ) { struct scsi_target * starget = scsi_target ( sdev ) ; VirtTarget * vtarget = starget -> hostdata ; if ( vtarget == NULL ) continue ; if ( ( pScsiReq -> TargetID == vtarget -> id ) && ( pScsiReq -> Bus == vtarget -> channel ) && ( vtarget -> tflags & MPT_TARGET_FLAGS_Q_YES ) ) qtag = MPI_SCSIIO_CONTROL_SIMPLEQ ; } if ( karg . dataOutSize > 0 ) { scsidir = MPI_SCSIIO_CONTROL_WRITE ; dataSize = karg . dataOutSize ; } else { scsidir = MPI_SCSIIO_CONTROL_READ ; dataSize = karg . dataInSize ; } pScsiReq -> Control = cpu_to_le32 ( scsidir | qtag ) ; pScsiReq -> DataLength = cpu_to_le32 ( dataSize ) ; } else { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""SCSI<S2SV_blank>driver<S2SV_blank>is<S2SV_blank>not<S2SV_blank>loaded.<S2SV_blank>\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - EFAULT ; goto done_free_mem ; } break ; case MPI_FUNCTION_SMP_PASSTHROUGH : break ; case MPI_FUNCTION_SATA_PASSTHROUGH : if ( ! ioc -> sh ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""SCSI<S2SV_blank>driver<S2SV_blank>is<S2SV_blank>not<S2SV_blank>loaded.<S2SV_blank>\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - EFAULT ; goto done_free_mem ; } break ; case MPI_FUNCTION_RAID_ACTION : break ; case MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH : if ( ioc -> sh ) { SCSIIORequest_t * pScsiReq = ( SCSIIORequest_t * ) mf ; int qtag = MPI_SCSIIO_CONTROL_SIMPLEQ ; int scsidir = MPI_SCSIIO_CONTROL_READ ; int dataSize ; pScsiReq -> MsgFlags &= ~ MPI_SCSIIO_MSGFLGS_SENSE_WIDTH ; pScsiReq -> MsgFlags |= mpt_msg_flags ( ioc ) ; if ( karg . maxSenseBytes > MPT_SENSE_BUFFER_SIZE ) pScsiReq -> SenseBufferLength = MPT_SENSE_BUFFER_SIZE ; else pScsiReq -> SenseBufferLength = karg . maxSenseBytes ; pScsiReq -> SenseBufferLowAddr = cpu_to_le32 ( ioc -> sense_buf_low_dma + ( req_idx * MPT_SENSE_BUFFER_ALLOC ) ) ; if ( karg . dataOutSize > 0 ) { scsidir = MPI_SCSIIO_CONTROL_WRITE ; dataSize = karg . dataOutSize ; } else { scsidir = MPI_SCSIIO_CONTROL_READ ; dataSize = karg . dataInSize ; } pScsiReq -> Control = cpu_to_le32 ( scsidir | qtag ) ; pScsiReq -> DataLength = cpu_to_le32 ( dataSize ) ; } else { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""SCSI<S2SV_blank>driver<S2SV_blank>is<S2SV_blank>not<S2SV_blank>loaded.<S2SV_blank>\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - EFAULT ; goto done_free_mem ; } break ; case MPI_FUNCTION_SCSI_TASK_MGMT : { SCSITaskMgmt_t * pScsiTm ; pScsiTm = ( SCSITaskMgmt_t * ) mf ; dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""\\tTaskType=0x%x<S2SV_blank>MsgFlags=0x%x<S2SV_blank>"" ""TaskMsgContext=0x%x<S2SV_blank>id=%d<S2SV_blank>channel=%d\\n"" , ioc -> name , pScsiTm -> TaskType , le32_to_cpu ( pScsiTm -> TaskMsgContext ) , pScsiTm -> MsgFlags , pScsiTm -> TargetID , pScsiTm -> Bus ) ) ; break ; } case MPI_FUNCTION_IOC_INIT : { IOCInit_t * pInit = ( IOCInit_t * ) mf ; u32 high_addr , sense_high ; if ( sizeof ( dma_addr_t ) == sizeof ( u64 ) ) { high_addr = cpu_to_le32 ( ( u32 ) ( ( u64 ) ioc -> req_frames_dma >> 32 ) ) ; sense_high = cpu_to_le32 ( ( u32 ) ( ( u64 ) ioc -> sense_buf_pool_dma >> 32 ) ) ; } else { high_addr = 0 ; sense_high = 0 ; } if ( ( pInit -> Flags != 0 ) || ( pInit -> MaxDevices != ioc -> facts . MaxDevices ) || ( pInit -> MaxBuses != ioc -> facts . MaxBuses ) || ( pInit -> ReplyFrameSize != cpu_to_le16 ( ioc -> reply_sz ) ) || ( pInit -> HostMfaHighAddr != high_addr ) || ( pInit -> SenseBufferHighAddr != sense_high ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""IOC_INIT<S2SV_blank>issued<S2SV_blank>with<S2SV_blank>1<S2SV_blank>or<S2SV_blank>more<S2SV_blank>incorrect<S2SV_blank>parameters.<S2SV_blank>Rejected.\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - EFAULT ; goto done_free_mem ; } } break ; default : printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Illegal<S2SV_blank>request<S2SV_blank>(function<S2SV_blank>0x%x)<S2SV_blank>\\n"" , ioc -> name , __FILE__ , __LINE__ , hdr -> Function ) ; rc = - EFAULT ; goto done_free_mem ; } psge = ( char * ) ( ( ( int * ) mf ) + karg . dataSgeOffset ) ; flagsLength = 0 ; if ( karg . dataOutSize > 0 ) sgSize ++ ; if ( karg . dataInSize > 0 ) sgSize ++ ; if ( sgSize > 0 ) { if ( karg . dataOutSize > 0 ) { if ( karg . dataInSize > 0 ) { flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT | MPI_SGE_FLAGS_END_OF_BUFFER | MPI_SGE_FLAGS_DIRECTION ) << MPI_SGE_FLAGS_SHIFT ; } else { flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE ; } flagsLength |= karg . dataOutSize ; bufOut . len = karg . dataOutSize ; bufOut . kptr = pci_alloc_consistent ( ioc -> pcidev , bufOut . len , & dma_addr_out ) ; if ( bufOut . kptr == NULL ) { rc = - ENOMEM ; goto done_free_mem ; } else { ioc -> add_sge ( psge , flagsLength , dma_addr_out ) ; psge += ioc -> SGE_size ; if ( copy_from_user ( bufOut . kptr , karg . dataOutBufPtr , bufOut . len ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>Unable<S2SV_blank>"" ""to<S2SV_blank>read<S2SV_blank>user<S2SV_blank>data<S2SV_blank>"" ""struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , karg . dataOutBufPtr ) ; rc = - EFAULT ; goto done_free_mem ; } } } if ( karg . dataInSize > 0 ) { flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ ; flagsLength |= karg . dataInSize ; bufIn . len = karg . dataInSize ; bufIn . kptr = pci_alloc_consistent ( ioc -> pcidev , bufIn . len , & dma_addr_in ) ; if ( bufIn . kptr == NULL ) { rc = - ENOMEM ; goto done_free_mem ; } else { ioc -> add_sge ( psge , flagsLength , dma_addr_in ) ; } } } else { ioc -> add_sge ( psge , flagsLength , ( dma_addr_t ) - 1 ) ; } SET_MGMT_MSG_CONTEXT ( ioc -> ioctl_cmds . msg_context , hdr -> MsgContext ) ; INITIALIZE_MGMT_STATUS ( ioc -> ioctl_cmds . status ) if ( hdr -> Function == MPI_FUNCTION_SCSI_TASK_MGMT ) { mutex_lock ( & ioc -> taskmgmt_cmds . mutex ) ; if ( mpt_set_taskmgmt_in_progress_flag ( ioc ) != 0 ) { mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; goto done_free_mem ; } DBG_DUMP_TM_REQUEST_FRAME ( ioc , ( u32 * ) mf ) ; if ( ( ioc -> facts . IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q ) && ( ioc -> facts . MsgVersion >= MPI_VERSION_01_05 ) ) mpt_put_msg_frame_hi_pri ( mptctl_id , ioc , mf ) ; else { rc = mpt_send_handshake_request ( mptctl_id , ioc , sizeof ( SCSITaskMgmt_t ) , ( u32 * ) mf , CAN_SLEEP ) ; if ( rc != 0 ) { dfailprintk ( ioc , printk ( MYIOC_s_ERR_FMT ""send_handshake<S2SV_blank>FAILED!<S2SV_blank>(ioc<S2SV_blank>%p,<S2SV_blank>mf<S2SV_blank>%p)\\n"" , ioc -> name , ioc , mf ) ) ; mpt_clear_taskmgmt_in_progress_flag ( ioc ) ; rc = - ENODATA ; mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; goto done_free_mem ; } } } else mpt_put_msg_frame ( mptctl_id , ioc , mf ) ; timeout = ( karg . timeout > 0 ) ? karg . timeout : MPT_IOCTL_DEFAULT_TIMEOUT ; retry_wait : timeleft = wait_for_completion_timeout ( & ioc -> ioctl_cmds . done , HZ * timeout ) ; if ( ! ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_COMMAND_GOOD ) ) { rc = - ETIME ; dfailprintk ( ioc , printk ( MYIOC_s_ERR_FMT ""%s:<S2SV_blank>TIMED<S2SV_blank>OUT!\\n"" , ioc -> name , __func__ ) ) ; if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_DID_IOCRESET ) { if ( function == MPI_FUNCTION_SCSI_TASK_MGMT ) mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; goto done_free_mem ; } if ( ! timeleft ) { printk ( MYIOC_s_WARN_FMT ""mpt<S2SV_blank>cmd<S2SV_blank>timeout,<S2SV_blank>doorbell=0x%08x"" ""<S2SV_blank>function=0x%x\\n"" , ioc -> name , mpt_GetIocState ( ioc , 0 ) , function ) ; if ( function == MPI_FUNCTION_SCSI_TASK_MGMT ) mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; mptctl_timeout_expired ( ioc , mf ) ; mf = NULL ; } else goto retry_wait ; goto done_free_mem ; } if ( function == MPI_FUNCTION_SCSI_TASK_MGMT ) mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; mf = NULL ; if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_RF_VALID ) { if ( karg . maxReplyBytes < ioc -> reply_sz ) { sz = min ( karg . maxReplyBytes , 4 * ioc -> ioctl_cmds . reply [ 2 ] ) ; } else { sz = min ( ioc -> reply_sz , 4 * ioc -> ioctl_cmds . reply [ 2 ] ) ; } if ( sz > 0 ) { if ( copy_to_user ( karg . replyFrameBufPtr , ioc -> ioctl_cmds . reply , sz ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>reply<S2SV_blank>frame<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , karg . replyFrameBufPtr ) ; rc = - ENODATA ; goto done_free_mem ; } } } if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_SENSE_VALID ) { sz = min ( karg . maxSenseBytes , MPT_SENSE_BUFFER_SIZE ) ; if ( sz > 0 ) { if ( copy_to_user ( karg . senseDataPtr , ioc -> ioctl_cmds . sense , sz ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>sense<S2SV_blank>data<S2SV_blank>to<S2SV_blank>user<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , karg . senseDataPtr ) ; rc = - ENODATA ; goto done_free_mem ; } } } if ( ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_COMMAND_GOOD ) && ( karg . dataInSize > 0 ) && ( bufIn . kptr ) ) { if ( copy_to_user ( karg . dataInBufPtr , bufIn . kptr , karg . dataInSize ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>data<S2SV_blank>to<S2SV_blank>user<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , karg . dataInBufPtr ) ; rc = - ENODATA ; } } done_free_mem : CLEAR_MGMT_STATUS ( ioc -> ioctl_cmds . status ) SET_MGMT_MSG_CONTEXT ( ioc -> ioctl_cmds . msg_context , 0 ) ; if ( bufOut . kptr != NULL ) { pci_free_consistent ( ioc -> pcidev , bufOut . len , ( void * ) bufOut . kptr , dma_addr_out ) ; } if ( bufIn . kptr != NULL ) { pci_free_consistent ( ioc -> pcidev , bufIn . len , ( void * ) bufIn . kptr , dma_addr_in ) ; } if ( mf ) mpt_free_msg_frame ( ioc , mf ) ; return rc ; }
","<S2SV_ModStart> int mptctl_do_mpt_command ( MPT_ADAPTER * ioc , <S2SV_ModStart> mfPtr ) { <S2SV_ModEnd> MPT_FRAME_HDR * mf <S2SV_ModStart> 0 ; int <S2SV_ModEnd> flagsLength ; int <S2SV_ModStart> = 0 ; <S2SV_ModEnd> spin_lock_irqsave ( &
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,"<S2SV_StartBug> mptctl_do_mpt_command ( struct mpt_ioctl_command karg , void __user * mfPtr ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> int iocnum , flagsLength ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug>"
6346,CWE-772,"generic_ret * modify_principal_2_svc ( mprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; gss_buffer_desc client_name , service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; restriction_t * rp ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> rec . principal , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_MODIFY , arg -> rec . principal , & rp ) || kadm5int_acl_impose_restrictions ( handle -> context , & arg -> rec , & arg -> mask , rp ) ) { ret . code = KADM5_AUTH_MODIFY ; log_unauth ( ""kadm5_modify_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_modify_principal ( ( void * ) handle , & arg -> rec , arg -> mask ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_modify_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug>"
622,CWE-125,"static const ut8 * r_bin_dwarf_parse_attr_value ( const ut8 * obuf , int obuf_len , RBinDwarfAttrSpec * spec , RBinDwarfAttrValue * value , const RBinDwarfCompUnitHdr * hdr , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf ; const ut8 * buf_end = obuf + obuf_len ; size_t j ; if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { return NULL ; } value -> form = spec -> attr_form ; value -> name = spec -> attr_name ; value -> encoding . block . data = NULL ; value -> encoding . str_struct . string = NULL ; value -> encoding . str_struct . offset = 0 ; switch ( spec -> attr_form ) { case DW_FORM_addr : switch ( hdr -> pointer_size ) { case 1 : value -> encoding . address = READ ( buf , ut8 ) ; break ; case 2 : value -> encoding . address = READ ( buf , ut16 ) ; break ; case 4 : value -> encoding . address = READ ( buf , ut32 ) ; break ; case 8 : value -> encoding . address = READ ( buf , ut64 ) ; break ; default : eprintf ( ""DWARF:<S2SV_blank>Unexpected<S2SV_blank>pointer<S2SV_blank>size:<S2SV_blank>%u\\n"" , ( unsigned ) hdr -> pointer_size ) ; return NULL ; } break ; case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ; if ( value -> encoding . block . length > 0 ) { value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; } } break ; case DW_FORM_block4 : value -> encoding . block . length = READ ( buf , ut32 ) ; if ( value -> encoding . block . length > 0 ) { ut8 * data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; if ( data ) { for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { data [ j ] = READ ( buf , ut8 ) ; } } value -> encoding . block . data = data ; } break ; case DW_FORM_data2 : value -> encoding . data = READ ( buf , ut16 ) ; break ; case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ; break ; case DW_FORM_data8 : value -> encoding . data = READ ( buf , ut64 ) ; break ; case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ; buf += ( strlen ( ( const char * ) buf ) + 1 ) ; break ; case DW_FORM_block : buf = r_uleb128 ( buf , buf_end - buf , & value -> encoding . block . length ) ; if ( ! buf ) { return NULL ; } value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; } break ; case DW_FORM_block1 : value -> encoding . block . length = READ ( buf , ut8 ) ; value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length + 1 ) ; for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; } break ; case DW_FORM_flag : value -> encoding . flag = READ ( buf , ut8 ) ; break ; case DW_FORM_sdata : buf = r_leb128 ( buf , & value -> encoding . sdata ) ; break ; case DW_FORM_strp : value -> encoding . str_struct . offset = READ ( buf , ut32 ) ; if ( debug_str && value -> encoding . str_struct . offset < debug_str_len ) { value -> encoding . str_struct . string = strdup ( ( const char * ) ( debug_str + value -> encoding . str_struct . offset ) ) ; } else { value -> encoding . str_struct . string = NULL ; } break ; case DW_FORM_udata : { ut64 ndata = 0 ; const ut8 * data = ( const ut8 * ) & ndata ; buf = r_uleb128 ( buf , R_MIN ( sizeof ( data ) , ( size_t ) ( buf_end - buf ) ) , & ndata ) ; memcpy ( & value -> encoding . data , data , sizeof ( value -> encoding . data ) ) ; value -> encoding . str_struct . string = NULL ; } break ; case DW_FORM_ref_addr : value -> encoding . reference = READ ( buf , ut64 ) ; break ; case DW_FORM_ref1 : value -> encoding . reference = READ ( buf , ut8 ) ; break ; case DW_FORM_ref2 : value -> encoding . reference = READ ( buf , ut16 ) ; break ; case DW_FORM_ref4 : value -> encoding . reference = READ ( buf , ut32 ) ; break ; case DW_FORM_ref8 : value -> encoding . reference = READ ( buf , ut64 ) ; break ; case DW_FORM_data1 : value -> encoding . data = READ ( buf , ut8 ) ; break ; default : eprintf ( ""Unknown<S2SV_blank>DW_FORM<S2SV_blank>0x%02"" PFMT64x ""\\n"" , spec -> attr_form ) ; value -> encoding . data = 0 ; return NULL ; } return buf ; }
","<S2SV_ModStart> || obuf_len < 1 <S2SV_ModEnd> ) { return <S2SV_ModStart> } break ; # if 0 <S2SV_ModStart> ; break ; # endif <S2SV_ModStart> length ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ut8 ) ; } <S2SV_ModStart> 1 ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ut8 ) ; }
",radare@radare2/2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d,CVE-2017-16805,https://github.com/radare/radare2/commit/2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d,2017-11-13T21:29Z,"<S2SV_StartBug> if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { <S2SV_EndBug> <S2SV_StartBug> case DW_FORM_data2 : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug>"
574,CWE-200,"IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; impeg2d_bit_stream_get ( ps_stream , 10 ) ; ps_dec -> e_pic_type = ( e_pic_type_t ) impeg2d_bit_stream_get ( ps_stream , 3 ) ; if ( ( ps_dec -> e_pic_type < I_PIC ) || ( ps_dec -> e_pic_type > D_PIC ) ) { impeg2d_next_code ( ps_dec , PICTURE_START_CODE ) ; return IMPEG2D_INVALID_PIC_TYPE ; } impeg2d_bit_stream_get ( ps_stream , 16 ) ; if ( ps_dec -> e_pic_type == P_PIC || ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_forw_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_back_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_back_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> u2_is_mpeg2 == 0 ) { ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ; } while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) { impeg2d_bit_stream_get ( ps_stream , 9 ) ; } impeg2d_bit_stream_get_bit ( ps_stream ) ; impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
","<S2SV_ModStart> 0 ) { if ( ps_dec -> u2_forw_f_code < 1 || ps_dec -> u2_forw_f_code > 7 || ps_dec -> u2_back_f_code < 1 || ps_dec -> u2_back_f_code > 7 ) { return IMPEG2D_UNKNOWN_ERROR ; }
",external@libmpeg2/29a78a11844fc027fa44be7f8bd8dc1cf8bf89f6,CVE-2017-13205,https://android.googlesource.com/platform/external/libmpeg2/+/29a78a11844fc027fa44be7f8bd8dc1cf8bf89f6,2018-01-12T23:29Z,<S2SV_StartBug> ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; <S2SV_EndBug>
2740,CWE-399,"static void free_huge_page ( struct page * page ) { struct hstate * h = page_hstate ( page ) ; int nid = page_to_nid ( page ) ; struct address_space * mapping ; mapping = ( struct address_space * ) page_private ( page ) ; set_page_private ( page , 0 ) ; page -> mapping = NULL ; BUG_ON ( page_count ( page ) ) ; BUG_ON ( page_mapcount ( page ) ) ; INIT_LIST_HEAD ( & page -> lru ) ; spin_lock ( & hugetlb_lock ) ; if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) { update_and_free_page ( h , page ) ; h -> surplus_huge_pages -- ; h -> surplus_huge_pages_node [ nid ] -- ; } else { enqueue_huge_page ( h , page ) ; } spin_unlock ( & hugetlb_lock ) ; if ( mapping ) hugetlb_put_quota ( mapping , 1 ) ; }
","<S2SV_ModStart> ) ; struct hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> * ) page_private <S2SV_ModStart> hugetlb_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , 1 )
",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z,<S2SV_StartBug> struct address_space * mapping ; <S2SV_EndBug> <S2SV_StartBug> if ( mapping ) <S2SV_EndBug>
3695,CWE-399,"static long vhost_net_set_backend ( struct vhost_net * n , unsigned index , int fd ) { struct socket * sock , * oldsock ; struct vhost_virtqueue * vq ; struct vhost_net_virtqueue * nvq ; struct vhost_net_ubuf_ref * ubufs , * oldubufs = NULL ; int r ; mutex_lock ( & n -> dev . mutex ) ; r = vhost_dev_check_owner ( & n -> dev ) ; if ( r ) goto err ; if ( index >= VHOST_NET_VQ_MAX ) { r = - ENOBUFS ; goto err ; } vq = & n -> vqs [ index ] . vq ; nvq = & n -> vqs [ index ] ; mutex_lock ( & vq -> mutex ) ; if ( ! vhost_vq_access_ok ( vq ) ) { r = - EFAULT ; goto err_vq ; } sock = get_socket ( fd ) ; if ( IS_ERR ( sock ) ) { r = PTR_ERR ( sock ) ; goto err_vq ; } oldsock = rcu_dereference_protected ( vq -> private_data , lockdep_is_held ( & vq -> mutex ) ) ; if ( sock != oldsock ) { ubufs = vhost_net_ubuf_alloc ( vq , sock && vhost_sock_zcopy ( sock ) ) ; if ( IS_ERR ( ubufs ) ) { r = PTR_ERR ( ubufs ) ; goto err_ubufs ; } vhost_net_disable_vq ( n , vq ) ; rcu_assign_pointer ( vq -> private_data , sock ) ; r = vhost_init_used ( vq ) ; if ( r ) goto err_used ; r = vhost_net_enable_vq ( n , vq ) ; if ( r ) goto err_used ; oldubufs = nvq -> ubufs ; nvq -> ubufs = ubufs ; n -> tx_packets = 0 ; n -> tx_zcopy_err = 0 ; n -> tx_flush = false ; } mutex_unlock ( & vq -> mutex ) ; if ( oldubufs ) { vhost_net_ubuf_put_and_wait ( oldubufs ) ; mutex_lock ( & vq -> mutex ) ; vhost_zerocopy_signal_used ( n , vq ) ; mutex_unlock ( & vq -> mutex ) ; } if ( oldsock ) { vhost_net_flush_vq ( n , index ) ; fput ( oldsock -> file ) ; } mutex_unlock ( & n -> dev . mutex ) ; return 0 ; err_used : rcu_assign_pointer ( vq -> private_data , oldsock ) ; vhost_net_enable_vq ( n , vq ) ; if ( ubufs ) vhost_net_ubuf_put_and_wait ( ubufs ) ; err_ubufs : fput ( sock -> file ) ; err_vq : mutex_unlock ( & vq -> mutex ) ; err : mutex_unlock ( & n -> dev . mutex ) ; return r ; }
","<S2SV_ModStart> oldubufs ) { vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( oldubufs ) <S2SV_ModStart> ( ubufs ) vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( ubufs )
",torvalds@linux/dd7633ecd553a5e304d349aa6f8eb8a0417098c5,CVE-2013-4127,https://github.com/torvalds/linux/commit/dd7633ecd553a5e304d349aa6f8eb8a0417098c5,2013-07-29T13:59Z,<S2SV_StartBug> vhost_net_ubuf_put_and_wait ( oldubufs ) ; <S2SV_EndBug> <S2SV_StartBug> vhost_net_ubuf_put_and_wait ( ubufs ) ; <S2SV_EndBug>
3491,CWE-119,"static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; count = ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) iris_info . name ) ; if ( ( size_t ) count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; if ( ( size_t ) count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = ( size_t ) ( iris_info . bytes_per_pixel > 1 ? 65535 : 256 ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ( ssize_t ) ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , ( ssize_t ) iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , ( ssize_t ) iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader""
",ImageMagick@ImageMagick/ce98a7acbcfca7f0a178f4b1e7b957e419e0cc99,CVE-2016-9556,https://github.com/ImageMagick/ImageMagick/commit/ce98a7acbcfca7f0a178f4b1e7b957e419e0cc99,2017-03-23T18:59Z,<S2SV_StartBug> iris_info . dimension = ReadBlobMSBShort ( image ) ; <S2SV_EndBug>
3627,CWE-125,"static void rpl_daoack_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_daoack * daoack = ( const struct nd_rpl_daoack * ) bp ; const char * dagid_str = ""<elided>"" ; ND_TCHECK2 ( * daoack , ND_RPL_DAOACK_MIN_LEN ) ; if ( length < ND_RPL_DAOACK_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAOACK_MIN_LEN ; length -= ND_RPL_DAOACK_MIN_LEN ; if ( RPL_DAOACK_D ( daoack -> rpl_flags ) ) { ND_TCHECK2 ( daoack -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]"" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ; return ; tooshort : ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-length<S2SV_blank>too<S2SV_blank>short]"" ) ) ; return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ; <S2SV_EndBug>"
1833,CWE-119,"int vp9_rc_regulate_q ( const VP9_COMP * cpi , int target_bits_per_frame , int active_best_quality , int active_worst_quality ) { const VP9_COMMON * const cm = & cpi -> common ; int q = active_worst_quality ; int last_error = INT_MAX ; int i , target_bits_per_mb ; const double correction_factor = get_rate_correction_factor ( cpi ) ; target_bits_per_mb = ( ( uint64_t ) target_bits_per_frame << BPER_MB_NORMBITS ) / cm -> MBs ; i = active_best_quality ; do { const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i , correction_factor ) ; if ( bits_per_mb_at_this_q <= target_bits_per_mb ) { if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) q = i ; else q = i - 1 ; break ; } else { last_error = bits_per_mb_at_this_q - target_bits_per_mb ; } } while ( ++ i <= active_worst_quality ) ; return q ; }
","<S2SV_ModStart> i , target_bits_per_mb , bits_per_mb_at_this_q <S2SV_ModStart> ; do { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && cpi -> svc . temporal_layer_id == 0 && cpi -> svc . spatial_layer_id == 0 ) { bits_per_mb_at_this_q = ( int ) vp9_cyclic_refresh_rc_bits_per_mb ( cpi , i , correction_factor ) ; } else { <S2SV_ModEnd> bits_per_mb_at_this_q = ( <S2SV_ModStart> i , correction_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> if ( bits_per_mb_at_this_q <S2SV_ModStart> active_worst_quality ) ; if ( cpi -> oxcf . rc_mode == VPX_CBR && ( cpi -> rc . rc_1_frame * cpi -> rc . rc_2_frame == - 1 ) && cpi -> rc . q_1_frame != cpi -> rc . q_2_frame ) { q = clamp ( q , MIN ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) , MAX ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int i , target_bits_per_mb ; <S2SV_EndBug> <S2SV_StartBug> const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i , <S2SV_EndBug> <S2SV_StartBug> correction_factor ) ; <S2SV_EndBug> <S2SV_StartBug> return q ; <S2SV_EndBug>"
6558,CWE-119,"static char * print_string_ptr ( const char * str ) { const char * ptr ; char * ptr2 , * out ; int len = 0 ; unsigned char token ; if ( ! str ) return cJSON_strdup ( """" ) ; ptr = str ; while ( ( token = * ptr ) && ++ len ) { if ( strchr ( ""\\""\\\\\\b\\f\\n\\r\\t"" , token ) ) ++ len ; else if ( token < 32 ) len += 5 ; ++ ptr ; } if ( ! ( out = ( char * ) cJSON_malloc ( len + 3 ) ) ) return 0 ; ptr2 = out ; ptr = str ; * ptr2 ++ = \'\\""\' ; while ( * ptr ) { if ( ( unsigned char ) * ptr > 31 && * ptr != \'\\""\' && * ptr != '\\\\' ) * ptr2 ++ = * ptr ++ ; else { * ptr2 ++ = '\\\\' ; switch ( token = * ptr ++ ) { case '\\\\' : * ptr2 ++ = '\\\\' ; break ; case \'\\""\' : * ptr2 ++ = \'\\""\' ; break ; case '\\b' : * ptr2 ++ = 'b' ; break ; case '\\f' : * ptr2 ++ = 'f' ; break ; case '\\n' : * ptr2 ++ = 'n' ; break ; case '\\r' : * ptr2 ++ = 'r' ; break ; case '\\t' : * ptr2 ++ = 't' ; break ; default : sprintf ( ptr2 , ""u%04x"" , token ) ; ptr2 += 5 ; break ; } } } * ptr2 ++ = \'\\""\' ; * ptr2 ++ = 0 ; return out ; }
","<S2SV_ModStart> char * str , printbuffer * p <S2SV_ModStart> * ptr ; char * ptr2 , * out ; <S2SV_ModEnd> int len = <S2SV_ModStart> len = 0 , flag = 0 ; <S2SV_ModEnd> unsigned char token <S2SV_ModStart> ! str ) { if ( p ) out = ensure ( p , 3 ) ; else out = ( char * ) cJSON_malloc ( 3 ) ; if ( ! out ) return 0 ; strcpy ( out , ""\\""\\"""" ) ; return out ; } for ( ptr = str ; * ptr ; ptr ++ ) flag |= ( ( * ptr > 0 && * ptr < 32 ) || ( * ptr == \'\\""\' ) || ( * ptr == '\\\\' ) ) ? 1 : 0 ; if ( ! flag ) { len = ptr - str ; if ( p ) out = ensure ( p , len + 3 ) ; else out = ( char * ) cJSON_malloc ( len + 3 ) ; if ( ! out ) return 0 ; ptr2 = out ; * ptr2 ++ = \'\\""\' ; strcpy ( ptr2 , str ) ; ptr2 [ len ] = \'\\""\' ; ptr2 [ len + 1 ] = 0 ; return out ; } ptr = str ; <S2SV_ModEnd> while ( ( <S2SV_ModStart> token ) ) len ++ ; <S2SV_ModEnd> else if ( <S2SV_ModStart> += 5 ; ptr ++ ; } if ( p ) out = ensure ( p , <S2SV_ModEnd> len + 3 <S2SV_ModStart> + 3 ) ; else out = ( char * ) cJSON_malloc ( len + 3 ) ; if ( ! out ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> += 5 ; break ; } } } * ptr2 ++ = \'\\""\' ; <S2SV_ModEnd> * ptr2 ++
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,"<S2SV_StartBug> static char * print_string_ptr ( const char * str ) <S2SV_EndBug> <S2SV_StartBug> char * ptr2 , * out ; <S2SV_EndBug> <S2SV_StartBug> int len = 0 ; <S2SV_EndBug> <S2SV_StartBug> return cJSON_strdup ( """" ) ; <S2SV_EndBug> <S2SV_StartBug> ++ len ; <S2SV_EndBug> <S2SV_StartBug> ++ ptr ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( out = ( char * ) cJSON_malloc ( len + 3 ) ) ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug>"
2176,CWE-119,"static grub_err_t read_foo ( struct grub_disk * disk , grub_disk_addr_t sector , grub_size_t size , char * buf ) { if ( disk != NULL ) { const int blocksize = 512 ; int ret ; RIOBind * iob = disk -> data ; if ( bio ) iob = bio ; ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) , ( ut8 * ) buf , size * blocksize ) ; if ( ret == - 1 ) return 1 ; } else eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; return 0 ; }
","<S2SV_ModStart> { if ( ! disk ) { eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; return 1 ; } <S2SV_ModEnd> const int blocksize <S2SV_ModStart> blocksize = 512 <S2SV_ModEnd> ; RIOBind * <S2SV_ModStart> ( bio ) { <S2SV_ModStart> = bio ; } if ( <S2SV_ModEnd> iob -> read_at <S2SV_ModStart> * blocksize ) <S2SV_ModEnd> == - 1 <S2SV_ModStart> - 1 ) { <S2SV_ModStart> 1 ; } <S2SV_ModEnd> return 0 ;
",radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z,"<S2SV_StartBug> if ( disk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> const int blocksize = 512 ; <S2SV_EndBug> <S2SV_StartBug> if ( bio ) iob = bio ; <S2SV_EndBug> <S2SV_StartBug> ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) , <S2SV_EndBug> <S2SV_StartBug> ( ut8 * ) buf , size * blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == - 1 ) <S2SV_EndBug> <S2SV_StartBug> } else eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; <S2SV_EndBug>"
838,CWE-369,"void * _TIFFmalloc ( tmsize_t s ) { return ( malloc ( ( size_t ) s ) ) ; }
","<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
",vadz@libtiff/3c5eb8b1be544e41d2c336191bc4936300ad7543,CVE-2014-8130,https://github.com/vadz/libtiff/commit/3c5eb8b1be544e41d2c336191bc4936300ad7543,2018-03-12T02:29Z,<S2SV_StartBug> { <S2SV_EndBug>
2490,CWE-000,"static void unix_release_sock ( struct sock * sk , int embrion ) { struct unix_sock * u = unix_sk ( sk ) ; struct path path ; struct sock * skpair ; struct sk_buff * skb ; int state ; unix_remove_socket ( sk ) ; unix_state_lock ( sk ) ; sock_orphan ( sk ) ; sk -> sk_shutdown = SHUTDOWN_MASK ; path = u -> path ; u -> path . dentry = NULL ; u -> path . mnt = NULL ; state = sk -> sk_state ; sk -> sk_state = TCP_CLOSE ; unix_state_unlock ( sk ) ; wake_up_interruptible_all ( & u -> peer_wait ) ; skpair = unix_peer ( sk ) ; if ( skpair != NULL ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_SEQPACKET ) { unix_state_lock ( skpair ) ; skpair -> sk_shutdown = SHUTDOWN_MASK ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || embrion ) skpair -> sk_err = ECONNRESET ; unix_state_unlock ( skpair ) ; skpair -> sk_state_change ( skpair ) ; sk_wake_async ( skpair , SOCK_WAKE_WAITD , POLL_HUP ) ; } sock_put ( skpair ) ; unix_peer ( sk ) = NULL ; } while ( ( skb = skb_dequeue ( & sk -> sk_receive_queue ) ) != NULL ) { if ( state == TCP_LISTEN ) unix_release_sock ( skb -> sk , 1 ) ; UNIXCB ( skb ) . consumed = skb -> len ; kfree_skb ( skb ) ; } if ( path . dentry ) path_put ( & path ) ; sock_put ( sk ) ; if ( unix_tot_inflight ) unix_gc ( ) ; }
","<S2SV_ModStart> ) ; } unix_dgram_peer_wake_disconnect ( sk , skpair ) ;
",torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c,CVE-2013-7446,https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c,2015-12-28T11:59Z,<S2SV_StartBug> sock_put ( skpair ) ; <S2SV_EndBug>
3734,CWE-416,"static int mif_process_cmpt ( mif_hdr_t * hdr , char * buf ) { jas_tvparser_t * tvp ; mif_cmpt_t * cmpt ; int id ; cmpt = 0 ; tvp = 0 ; if ( ! ( cmpt = mif_cmpt_create ( ) ) ) { goto error ; } cmpt -> tlx = 0 ; cmpt -> tly = 0 ; cmpt -> sampperx = 0 ; cmpt -> samppery = 0 ; cmpt -> width = 0 ; cmpt -> height = 0 ; cmpt -> prec = 0 ; cmpt -> sgnd = - 1 ; cmpt -> data = 0 ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { goto error ; } while ( ! ( id = jas_tvparser_next ( tvp ) ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case MIF_TLX : cmpt -> tlx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_TLY : cmpt -> tly = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_WIDTH : cmpt -> width = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HEIGHT : cmpt -> height = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HSAMP : cmpt -> sampperx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_VSAMP : cmpt -> samppery = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_PREC : cmpt -> prec = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_SGND : cmpt -> sgnd = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_DATA : if ( ! ( cmpt -> data = jas_strdup ( jas_tvparser_getval ( tvp ) ) ) ) { return - 1 ; } break ; } } jas_tvparser_destroy ( tvp ) ; if ( ! cmpt -> sampperx || ! cmpt -> samppery ) { goto error ; } if ( mif_hdr_addcmpt ( hdr , hdr -> numcmpts , cmpt ) ) { goto error ; } return 0 ; error : if ( cmpt ) { mif_cmpt_destroy ( cmpt ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } return - 1 ; }
","<S2SV_ModStart> ; } } <S2SV_ModEnd> if ( ! <S2SV_ModStart> error ; } jas_tvparser_destroy ( tvp ) ;
",mdadams@jasper/df5d2867e8004e51e18b89865bc4aa69229227b3,CVE-2015-5221,https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3,2017-07-25T18:29Z,<S2SV_StartBug> jas_tvparser_destroy ( tvp ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>
1532,CWE-119,"void vp9_foreach_transformed_block_in_plane ( const MACROBLOCKD * const xd , BLOCK_SIZE bsize , int plane , foreach_transformed_block_visitor visit , void * arg ) { const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; const MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) : mbmi -> tx_size ; const BLOCK_SIZE plane_bsize = get_plane_block_size ( bsize , pd ) ; const int num_4x4_w = num_4x4_blocks_wide_lookup [ plane_bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ plane_bsize ] ; const int step = 1 << ( tx_size << 1 ) ; int i ; if ( xd -> mb_to_right_edge < 0 || xd -> mb_to_bottom_edge < 0 ) { int r , c ; int max_blocks_wide = num_4x4_w ; int max_blocks_high = num_4x4_h ; if ( xd -> mb_to_right_edge < 0 ) max_blocks_wide += ( xd -> mb_to_right_edge >> ( 5 + pd -> subsampling_x ) ) ; if ( xd -> mb_to_bottom_edge < 0 ) max_blocks_high += ( xd -> mb_to_bottom_edge >> ( 5 + pd -> subsampling_y ) ) ; i = 0 ; for ( r = 0 ; r < num_4x4_h ; r += ( 1 << tx_size ) ) { for ( c = 0 ; c < num_4x4_w ; c += ( 1 << tx_size ) ) { if ( r < max_blocks_high && c < max_blocks_wide ) visit ( plane , i , plane_bsize , tx_size , arg ) ; i += step ; } } } else { for ( i = 0 ; i < num_4x4_w * num_4x4_h ; i += step ) visit ( plane , i , plane_bsize , tx_size , arg ) ; } }
","<S2SV_ModStart> get_uv_tx_size ( mbmi , pd <S2SV_ModStart> ; int i = 0 , r , c ; const int max_blocks_wide = num_4x4_w + <S2SV_ModEnd> ( xd -> <S2SV_ModStart> xd -> mb_to_right_edge >= 0 ? 0 : <S2SV_ModEnd> xd -> mb_to_right_edge <S2SV_ModStart> ) ) ; const int max_blocks_high = num_4x4_h + <S2SV_ModEnd> ( xd -> <S2SV_ModStart> xd -> mb_to_bottom_edge >= 0 ? 0 : <S2SV_ModEnd> xd -> mb_to_bottom_edge <S2SV_ModStart> ) ) ; const int extra_step = ( ( num_4x4_w - max_blocks_wide ) >> tx_size ) * step <S2SV_ModEnd> ; for ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> r < max_blocks_high <S2SV_ModStart> r < max_blocks_high ; r += ( 1 << tx_size ) ) { for ( c = 0 ; <S2SV_ModEnd> c < max_blocks_wide <S2SV_ModStart> c < max_blocks_wide ; c += ( 1 << tx_size ) ) { <S2SV_ModEnd> visit ( plane <S2SV_ModStart> step ; } i += extra_step <S2SV_ModEnd> ; } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> if ( xd -> mb_to_right_edge < 0 || xd -> mb_to_bottom_edge < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( xd -> mb_to_bottom_edge < 0 ) <S2SV_EndBug> <S2SV_StartBug> i = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( r = 0 ; r < num_4x4_h ; r += ( 1 << tx_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( r < max_blocks_high && c < max_blocks_wide ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
2467,CWE-119,"static void unqueue_me_pi ( struct futex_q * q ) { WARN_ON ( plist_node_empty ( & q -> list ) ) ; plist_del ( & q -> list , & q -> list . plist ) ; BUG_ON ( ! q -> pi_state ) ; free_pi_state ( q -> pi_state ) ; q -> pi_state = NULL ; spin_unlock ( q -> lock_ptr ) ; drop_futex_key_refs ( & q -> key ) ; }
","<S2SV_ModStart> lock_ptr ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/7ada876a8703f23befbb20a7465a702ee39b1704,CVE-2014-0205,https://github.com/torvalds/linux/commit/7ada876a8703f23befbb20a7465a702ee39b1704,2014-09-28T19:55Z,<S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug>
5366,CWE-401,"static int8_t parse_ext_option ( uint16_t * dst , uint8_t * * packet_data_pptr , uint8_t * packet_data_start_ptr , uint16_t packet_len , uint16_t * message_left ) { uint16_t option_number = * dst ; if ( option_number == 13 ) { uint8_t option_ext ; int8_t read_result = sn_coap_parser_read_packet_u8 ( & option_ext , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } else { option_number += option_ext ; * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; } } else if ( option_number == 14 ) { int8_t read_result = sn_coap_parser_read_packet_u16 ( & option_number , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } else { option_number += 269 ; * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 2 ) ; } } else if ( option_number == 15 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>option<S2SV_blank>number(15)!"" ) ; return - 1 ; } * dst = option_number ; return 0 ; }
","<S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , option_ext , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left = <S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , 269 , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left =
",mjurczak@mbed-coap/4647a68e364401e81dbd370728127d844f221d93,CVE-2020-12887,https://github.com/mjurczak/mbed-coap/commit/4647a68e364401e81dbd370728127d844f221d93,2020-06-18T19:15Z,<S2SV_StartBug> option_number += option_ext ; <S2SV_EndBug> <S2SV_StartBug> option_number += 269 ; <S2SV_EndBug>
3885,CWE-264,"static int multipath_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct multipath * m = ( struct multipath * ) ti -> private ; struct block_device * bdev = NULL ; fmode_t mode = 0 ; unsigned long flags ; int r = 0 ; spin_lock_irqsave ( & m -> lock , flags ) ; if ( ! m -> current_pgpath ) __choose_pgpath ( m , 0 ) ; if ( m -> current_pgpath ) { bdev = m -> current_pgpath -> path . dev -> bdev ; mode = m -> current_pgpath -> path . dev -> mode ; } if ( m -> queue_io ) r = - EAGAIN ; else if ( ! bdev ) r = - EIO ; spin_unlock_irqrestore ( & m -> lock , flags ) ; return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; }
","<S2SV_ModStart> flags ) ; if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;
",torvalds@linux/ec8013beddd717d1740cfefb1a9b900deef85462,CVE-2011-4127,https://github.com/torvalds/linux/commit/ec8013beddd717d1740cfefb1a9b900deef85462,2012-07-03T16:40Z,"<S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug>"
3622,CWE-125,"void icmp6_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 , int fragmented ) { const struct icmp6_hdr * dp ; const struct ip6_hdr * ip ; const struct ip6_hdr * oip ; const struct udphdr * ouh ; int dport ; const u_char * ep ; u_int prot ; dp = ( const struct icmp6_hdr * ) bp ; ip = ( const struct ip6_hdr * ) bp2 ; oip = ( const struct ip6_hdr * ) ( dp + 1 ) ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> icmp6_cksum ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , udp_sum ; if ( ND_TTEST2 ( bp [ 0 ] , length ) ) { udp_sum = EXTRACT_16BITS ( & dp -> icmp6_cksum ) ; sum = icmp6_cksum ( ndo , ip , dp , length ) ; if ( sum != 0 ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>icmp6<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>-><S2SV_blank>0x%04x!]<S2SV_blank>"" , udp_sum , in_cksum_shouldbe ( udp_sum , sum ) ) ) ; else ND_PRINT ( ( ndo , ""[icmp6<S2SV_blank>sum<S2SV_blank>ok]<S2SV_blank>"" ) ) ; } } ND_PRINT ( ( ndo , ""ICMP6,<S2SV_blank>%s"" , tok2str ( icmp6_type_values , ""unknown<S2SV_blank>icmp6<S2SV_blank>type<S2SV_blank>(%u)"" , dp -> icmp6_type ) ) ) ; if ( ndo -> ndo_vflag && ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; switch ( dp -> icmp6_type ) { case ICMP6_DST_UNREACH : ND_TCHECK ( oip -> ip6_dst ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , tok2str ( icmp6_dst_unreach_code_values , ""unknown<S2SV_blank>unreach<S2SV_blank>code<S2SV_blank>(%u)"" , dp -> icmp6_code ) ) ) ; switch ( dp -> icmp6_code ) { case ICMP6_DST_UNREACH_NOROUTE : case ICMP6_DST_UNREACH_ADMIN : case ICMP6_DST_UNREACH_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_DST_UNREACH_BEYONDSCOPE : ND_PRINT ( ( ndo , ""<S2SV_blank>%s,<S2SV_blank>source<S2SV_blank>address<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , ip6addr_string ( ndo , & oip -> ip6_src ) ) ) ; break ; case ICMP6_DST_UNREACH_NOPORT : if ( ( ouh = get_upperlayer ( ndo , ( const u_char * ) oip , & prot ) ) == NULL ) goto trunc ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( prot ) { case IPPROTO_TCP : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; break ; case IPPROTO_UDP : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , udpport_string ( ndo , dport ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , oip -> ip6_nxt , dport ) ) ; break ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , bp , ""\\n\\t"" , length ) ; return ; } break ; } break ; case ICMP6_PACKET_TOO_BIG : ND_TCHECK ( dp -> icmp6_mtu ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>mtu<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_mtu ) ) ) ; break ; case ICMP6_TIME_EXCEEDED : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_TIME_EXCEED_TRANSIT : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_TIME_EXCEED_REASSEMBLY : ND_PRINT ( ( ndo , ""<S2SV_blank>(reassembly)"" ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>unknown<S2SV_blank>code<S2SV_blank>(%u)"" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_PARAM_PROB : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_PARAMPROB_HEADER : ND_PRINT ( ( ndo , "",<S2SV_blank>erroneous<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_NEXTHEADER : ND_PRINT ( ( ndo , "",<S2SV_blank>next<S2SV_blank>header<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_OPTION : ND_PRINT ( ( ndo , "",<S2SV_blank>option<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>code-#%d"" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_ECHO_REQUEST : case ICMP6_ECHO_REPLY : ND_TCHECK ( dp -> icmp6_seq ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp6_seq ) ) ) ; break ; case ICMP6_MEMBERSHIP_QUERY : if ( length == MLD_MINLEN ) { mld6_print ( ndo , ( const u_char * ) dp ) ; } else if ( length >= MLDV2_MINLEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>v2"" ) ) ; mldv2_query_print ( ndo , ( const u_char * ) dp , length ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>unknown-version<S2SV_blank>(len<S2SV_blank>%u)<S2SV_blank>"" , length ) ) ; } break ; case ICMP6_MEMBERSHIP_REPORT : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ICMP6_MEMBERSHIP_REDUCTION : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ND_ROUTER_SOLICIT : # define RTSOLLEN 8 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + RTSOLLEN , length - RTSOLLEN ) ; } break ; case ND_ROUTER_ADVERT : # define RTADVLEN 16 if ( ndo -> ndo_vflag ) { const struct nd_router_advert * p ; p = ( const struct nd_router_advert * ) dp ; ND_TCHECK ( p -> nd_ra_retransmit ) ; ND_PRINT ( ( ndo , ""\\n\\thop<S2SV_blank>limit<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]"" "",<S2SV_blank>pref<S2SV_blank>%s,<S2SV_blank>router<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>reachable<S2SV_blank>time<S2SV_blank>%ums,<S2SV_blank>retrans<S2SV_blank>timer<S2SV_blank>%ums"" , ( u_int ) p -> nd_ra_curhoplimit , bittok2str ( icmp6_opt_ra_flag_values , ""none"" , ( p -> nd_ra_flags_reserved ) ) , get_rtpref ( p -> nd_ra_flags_reserved ) , EXTRACT_16BITS ( & p -> nd_ra_router_lifetime ) , EXTRACT_32BITS ( & p -> nd_ra_reachable ) , EXTRACT_32BITS ( & p -> nd_ra_retransmit ) ) ) ; icmp6_opt_print ( ndo , ( const u_char * ) dp + RTADVLEN , length - RTADVLEN ) ; } break ; case ND_NEIGHBOR_SOLICIT : { const struct nd_neighbor_solicit * p ; p = ( const struct nd_neighbor_solicit * ) dp ; ND_TCHECK ( p -> nd_ns_target ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>who<S2SV_blank>has<S2SV_blank>%s"" , ip6addr_string ( ndo , & p -> nd_ns_target ) ) ) ; if ( ndo -> ndo_vflag ) { # define NDSOLLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDSOLLEN , length - NDSOLLEN ) ; } } break ; case ND_NEIGHBOR_ADVERT : { const struct nd_neighbor_advert * p ; p = ( const struct nd_neighbor_advert * ) dp ; ND_TCHECK ( p -> nd_na_target ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>tgt<S2SV_blank>is<S2SV_blank>%s"" , ip6addr_string ( ndo , & p -> nd_na_target ) ) ) ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( icmp6_nd_na_flag_values , ""none"" , EXTRACT_32BITS ( & p -> nd_na_flags_reserved ) ) ) ) ; # define NDADVLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDADVLEN , length - NDADVLEN ) ; # undef NDADVLEN } } break ; case ND_REDIRECT : # define RDR ( i ) ( ( const struct nd_redirect * ) ( i ) ) ND_TCHECK ( RDR ( dp ) -> nd_rd_dst ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_dst ) ) ) ; ND_TCHECK ( RDR ( dp ) -> nd_rd_target ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>to<S2SV_blank>%s"" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_target ) ) ) ; # define REDIRECTLEN 40 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + REDIRECTLEN , length - REDIRECTLEN ) ; } break ; # undef REDIRECTLEN # undef RDR case ICMP6_ROUTER_RENUMBERING : icmp6_rrenum_print ( ndo , bp , ep ) ; break ; case ICMP6_NI_QUERY : case ICMP6_NI_REPLY : icmp6_nodeinfo_print ( ndo , length , bp , ep ) ; break ; case IND_SOLICIT : case IND_ADVERT : break ; case ICMP6_V2_MEMBERSHIP_REPORT : mldv2_report_print ( ndo , ( const u_char * ) dp , length ) ; break ; case ICMP6_MOBILEPREFIX_SOLICIT : case ICMP6_HADISCOV_REQUEST : ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; break ; case ICMP6_HADISCOV_REPLY : if ( ndo -> ndo_vflag ) { const struct in6_addr * in6 ; const u_char * cp ; ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; cp = ( const u_char * ) dp + length ; in6 = ( const struct in6_addr * ) ( dp + 1 ) ; for ( ; ( const u_char * ) in6 < cp ; in6 ++ ) { ND_TCHECK ( * in6 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , in6 ) ) ) ; } } break ; case ICMP6_MOBILEPREFIX_ADVERT : if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; ND_TCHECK ( dp -> icmp6_data16 [ 1 ] ) ; if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""M"" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & 0x40 ) ND_PRINT ( ( ndo , ""O"" ) ) ; # define MPADVLEN 8 icmp6_opt_print ( ndo , ( const u_char * ) dp + MPADVLEN , length - MPADVLEN ) ; } break ; case ND_RPL_MESSAGE : rpl_print ( ndo , dp , & dp -> icmp6_data8 [ 0 ] , length - sizeof ( struct icmp6_hdr ) + 4 ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , bp , ""\\n\\t"" , length ) ; return ; } if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; }
","<S2SV_ModStart> ( ndo , ""%s"" , icmp6_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug>"
93,CWE-125,"static const u_char * ikev1_id_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep _U_ , uint32_t phase , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { # define USE_IPSECDOI_IN_PHASE1 1 const struct ikev1_pl_id * p ; struct ikev1_pl_id id ; static const char * idtypestr [ ] = { ""IPv4"" , ""IPv4net"" , ""IPv6"" , ""IPv6net"" , } ; static const char * ipsecidtypestr [ ] = { NULL , ""IPv4"" , ""FQDN"" , ""user<S2SV_blank>FQDN"" , ""IPv4net"" , ""IPv6"" , ""IPv6net"" , ""IPv4range"" , ""IPv6range"" , ""ASN1<S2SV_blank>DN"" , ""ASN1<S2SV_blank>GN"" , ""keyid"" , } ; int len ; const u_char * data ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_ID ) ) ) ; p = ( const struct ikev1_pl_id * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; if ( sizeof ( * p ) < item_len ) { data = ( const u_char * ) ( p + 1 ) ; len = item_len - sizeof ( * p ) ; } else { data = NULL ; len = 0 ; } # if 0 ND_PRINT ( ( ndo , ""<S2SV_blank>[phase=%d<S2SV_blank>doi=%d<S2SV_blank>proto=%d]"" , phase , doi , proto ) ) ; # endif switch ( phase ) { # ifndef USE_IPSECDOI_IN_PHASE1 case 1 : # endif default : ND_PRINT ( ( ndo , ""<S2SV_blank>idtype=%s"" , STR_OR_ID ( id . d . id_type , idtypestr ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>doi_data=%u"" , ( uint32_t ) ( ntohl ( id . d . doi_data ) & 0xffffff ) ) ) ; break ; # ifdef USE_IPSECDOI_IN_PHASE1 case 1 : # endif case 2 : { const struct ipsecdoi_id * doi_p ; struct ipsecdoi_id doi_id ; const char * p_name ; doi_p = ( const struct ipsecdoi_id * ) ext ; ND_TCHECK ( * doi_p ) ; UNALIGNED_MEMCPY ( & doi_id , ext , sizeof ( doi_id ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>idtype=%s"" , STR_OR_ID ( doi_id . type , ipsecidtypestr ) ) ) ; if ( ! ndo -> ndo_nflag && doi_id . proto_id && ( p_name = netdb_protoname ( doi_id . proto_id ) ) != NULL ) ND_PRINT ( ( ndo , ""<S2SV_blank>protoid=%s"" , p_name ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>protoid=%u"" , doi_id . proto_id ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>port=%d"" , ntohs ( doi_id . port ) ) ) ; if ( ! len ) break ; if ( data == NULL ) goto trunc ; ND_TCHECK2 ( * data , len ) ; switch ( doi_id . type ) { case IPSECDOI_ID_IPV4_ADDR : if ( len < 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>4]"" , len ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s"" , len , ipaddr_string ( ndo , data ) ) ) ; len = 0 ; break ; case IPSECDOI_ID_FQDN : case IPSECDOI_ID_USER_FQDN : { int i ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>"" , len ) ) ; for ( i = 0 ; i < len ; i ++ ) safeputchar ( ndo , data [ i ] ) ; len = 0 ; break ; } case IPSECDOI_ID_IPV4_ADDR_SUBNET : { const u_char * mask ; if ( len < 8 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>8]"" , len ) ) ; else { mask = data + sizeof ( struct in_addr ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s/%u.%u.%u.%u"" , len , ipaddr_string ( ndo , data ) , mask [ 0 ] , mask [ 1 ] , mask [ 2 ] , mask [ 3 ] ) ) ; } len = 0 ; break ; } case IPSECDOI_ID_IPV6_ADDR : if ( len < 16 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>16]"" , len ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s"" , len , ip6addr_string ( ndo , data ) ) ) ; len = 0 ; break ; case IPSECDOI_ID_IPV6_ADDR_SUBNET : { const u_char * mask ; if ( len < 20 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]"" , len ) ) ; else { mask = ( const u_char * ) ( data + sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"" , len , ip6addr_string ( ndo , data ) , mask [ 0 ] , mask [ 1 ] , mask [ 2 ] , mask [ 3 ] , mask [ 4 ] , mask [ 5 ] , mask [ 6 ] , mask [ 7 ] , mask [ 8 ] , mask [ 9 ] , mask [ 10 ] , mask [ 11 ] , mask [ 12 ] , mask [ 13 ] , mask [ 14 ] , mask [ 15 ] ) ) ; } len = 0 ; break ; } case IPSECDOI_ID_IPV4_ADDR_RANGE : if ( len < 8 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>8]"" , len ) ) ; else { ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s-%s"" , len , ipaddr_string ( ndo , data ) , ipaddr_string ( ndo , data + sizeof ( struct in_addr ) ) ) ) ; } len = 0 ; break ; case IPSECDOI_ID_IPV6_ADDR_RANGE : if ( len < 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" , len ) ) ; else { ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s-%s"" , len , ip6addr_string ( ndo , data ) , ip6addr_string ( ndo , data + sizeof ( struct in6_addr ) ) ) ) ; } len = 0 ; break ; case IPSECDOI_ID_DER_ASN1_DN : case IPSECDOI_ID_DER_ASN1_GN : case IPSECDOI_ID_KEY_ID : break ; } break ; } } if ( data && len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d"" , len ) ) ; if ( 2 < ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) data , len ) ) goto trunc ; } } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_ID ) ) ) ; return NULL ; }
","<S2SV_ModStart> ( len < 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" <S2SV_ModEnd> , len )
",the-tcpdump-group@tcpdump/061e7371a944588f231cb1b66d6fb070b646e376,CVE-2017-13689,https://github.com/the-tcpdump-group/tcpdump/commit/061e7371a944588f231cb1b66d6fb070b646e376,2017-09-14T06:29Z,<S2SV_StartBug> if ( len < 20 ) <S2SV_EndBug>
7743,CWE-000,"static struct nfs4_state * nfs4_opendata_to_nfs4_state ( struct nfs4_opendata * data ) { struct inode * inode ; struct nfs4_state * state = NULL ; struct nfs_delegation * delegation ; int ret ; if ( ! data -> rpc_done ) { state = nfs4_try_open_cached ( data ) ; goto out ; } ret = - EAGAIN ; if ( ! ( data -> f_attr . valid & NFS_ATTR_FATTR ) ) goto err ; inode = nfs_fhget ( data -> dir -> d_sb , & data -> o_res . fh , & data -> f_attr ) ; ret = PTR_ERR ( inode ) ; if ( IS_ERR ( inode ) ) goto err ; ret = - ENOMEM ; state = nfs4_get_open_state ( inode , data -> owner ) ; if ( state == NULL ) goto err_put_inode ; if ( data -> o_res . delegation_type != 0 ) { int delegation_flags = 0 ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( inode ) -> delegation ) ; if ( delegation ) delegation_flags = delegation -> flags ; rcu_read_unlock ( ) ; if ( ( delegation_flags & 1UL << NFS_DELEGATION_NEED_RECLAIM ) == 0 ) nfs_inode_set_delegation ( state -> inode , data -> owner -> so_cred , & data -> o_res ) ; else nfs_inode_reclaim_delegation ( state -> inode , data -> owner -> so_cred , & data -> o_res ) ; } update_open_stateid ( state , & data -> o_res . stateid , NULL , data -> o_arg . open_flags ) ; iput ( inode ) ; out : return state ; err_put_inode : iput ( inode ) ; err : return ERR_PTR ( ret ) ; }
","<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; iput
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,<S2SV_StartBug> data -> o_arg . open_flags ) ; <S2SV_EndBug>
8233,CWE-200,"void add_interrupt_randomness ( int irq , int irq_flags ) { struct entropy_store * r ; struct fast_pool * fast_pool = this_cpu_ptr ( & irq_randomness ) ; struct pt_regs * regs = get_irq_regs ( ) ; unsigned long now = jiffies ; cycles_t cycles = random_get_entropy ( ) ; __u32 c_high , j_high ; __u64 ip ; unsigned long seed ; int credit = 0 ; if ( cycles == 0 ) cycles = get_reg ( fast_pool , regs ) ; c_high = ( sizeof ( cycles ) > 4 ) ? cycles >> 32 : 0 ; j_high = ( sizeof ( now ) > 4 ) ? now >> 32 : 0 ; fast_pool -> pool [ 0 ] ^= cycles ^ j_high ^ irq ; fast_pool -> pool [ 1 ] ^= now ^ c_high ; ip = regs ? instruction_pointer ( regs ) : _RET_IP_ ; fast_pool -> pool [ 2 ] ^= ip ; fast_pool -> pool [ 3 ] ^= ( sizeof ( ip ) > 4 ) ? ip >> 32 : get_reg ( fast_pool , regs ) ; fast_mix ( fast_pool ) ; add_interrupt_bench ( cycles ) ; if ( unlikely ( crng_init == 0 ) ) { if ( ( fast_pool -> count >= 64 ) && crng_fast_load ( ( char * ) fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ) { fast_pool -> count = 0 ; fast_pool -> last = now ; } return ; } if ( ( fast_pool -> count < 64 ) && ! time_after ( now , fast_pool -> last + HZ ) ) return ; r = & input_pool ; if ( ! spin_trylock ( & r -> lock ) ) return ; fast_pool -> last = now ; __mix_pool_bytes ( r , & fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ; if ( arch_get_random_seed_long ( & seed ) ) { __mix_pool_bytes ( r , & seed , sizeof ( seed ) ) ; credit = 1 ; } spin_unlock ( & r -> lock ) ; fast_pool -> count = 0 ; credit_entropy_bits ( r , credit + 1 ) ; }
","<S2SV_ModStart> cycles ) ; this_cpu_add ( net_rand_state . s1 , fast_pool -> pool [ cycles & 3 ] ) ;
",torvalds@linux/f227e3ec3b5cad859ad15666874405e8c1bbc1d4,CVE-2020-16166,https://github.com/torvalds/linux/commit/f227e3ec3b5cad859ad15666874405e8c1bbc1d4,2020-07-30T21:15Z,<S2SV_StartBug> if ( unlikely ( crng_init == 0 ) ) { <S2SV_EndBug>
5155,CWE-674,"static void renameColumnFunc ( sqlite3_context * context , int NotUsed , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; RenameCtx sCtx ; const char * zSql = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zDb = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * zTable = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; int iCol = sqlite3_value_int ( argv [ 5 ] ) ; const char * zNew = ( const char * ) sqlite3_value_text ( argv [ 6 ] ) ; int bQuote = sqlite3_value_int ( argv [ 7 ] ) ; int bTemp = sqlite3_value_int ( argv [ 8 ] ) ; const char * zOld ; int rc ; Parse sParse ; Walker sWalker ; Index * pIdx ; int i ; Table * pTab ; # ifndef SQLITE_OMIT_AUTHORIZATION sqlite3_xauth xAuth = db -> xAuth ; # endif UNUSED_PARAMETER ( NotUsed ) ; if ( zSql == 0 ) return ; if ( zTable == 0 ) return ; if ( zNew == 0 ) return ; if ( iCol < 0 ) return ; sqlite3BtreeEnterAll ( db ) ; pTab = sqlite3FindTable ( db , zTable , zDb ) ; if ( pTab == 0 || iCol >= pTab -> nCol ) { sqlite3BtreeLeaveAll ( db ) ; return ; } zOld = pTab -> aCol [ iCol ] . zName ; memset ( & sCtx , 0 , sizeof ( sCtx ) ) ; sCtx . iCol = ( ( iCol == pTab -> iPKey ) ? - 1 : iCol ) ; # ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = 0 ; # endif rc = renameParseSql ( & sParse , zDb , 0 , db , zSql , bTemp ) ; memset ( & sWalker , 0 , sizeof ( Walker ) ) ; sWalker . pParse = & sParse ; sWalker . xExprCallback = renameColumnExprCb ; sWalker . xSelectCallback = renameColumnSelectCb ; sWalker . u . pRename = & sCtx ; sCtx . pTab = pTab ; if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; if ( sParse . pNewTable ) { Select * pSelect = sParse . pNewTable -> pSelect ; if ( pSelect ) { sParse . rc = SQLITE_OK ; sqlite3SelectPrep ( & sParse , sParse . pNewTable -> pSelect , 0 ) ; rc = ( db -> mallocFailed ? SQLITE_NOMEM : sParse . rc ) ; if ( rc == SQLITE_OK ) { sqlite3WalkSelect ( & sWalker , pSelect ) ; } if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; } else { int bFKOnly = sqlite3_stricmp ( zTable , sParse . pNewTable -> zName ) ; FKey * pFKey ; assert ( sParse . pNewTable -> pSelect == 0 ) ; sCtx . pTab = sParse . pNewTable ; if ( bFKOnly == 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) sParse . pNewTable -> aCol [ iCol ] . zName ) ; if ( sCtx . iCol < 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) & sParse . pNewTable -> iPKey ) ; } sqlite3WalkExprList ( & sWalker , sParse . pNewTable -> pCheck ) ; for ( pIdx = sParse . pNewTable -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3WalkExprList ( & sWalker , pIdx -> aColExpr ) ; } for ( pIdx = sParse . pNewIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3WalkExprList ( & sWalker , pIdx -> aColExpr ) ; } } # ifndef SQLITE_OMIT_GENERATED_COLUMNS for ( i = 0 ; i < sParse . pNewTable -> nCol ; i ++ ) { sqlite3WalkExpr ( & sWalker , sParse . pNewTable -> aCol [ i ] . pDflt ) ; } # endif for ( pFKey = sParse . pNewTable -> pFKey ; pFKey ; pFKey = pFKey -> pNextFrom ) { for ( i = 0 ; i < pFKey -> nCol ; i ++ ) { if ( bFKOnly == 0 && pFKey -> aCol [ i ] . iFrom == iCol ) { renameTokenFind ( & sParse , & sCtx , ( void * ) & pFKey -> aCol [ i ] ) ; } if ( 0 == sqlite3_stricmp ( pFKey -> zTo , zTable ) && 0 == sqlite3_stricmp ( pFKey -> aCol [ i ] . zCol , zOld ) ) { renameTokenFind ( & sParse , & sCtx , ( void * ) pFKey -> aCol [ i ] . zCol ) ; } } } } } else if ( sParse . pNewIndex ) { sqlite3WalkExprList ( & sWalker , sParse . pNewIndex -> aColExpr ) ; sqlite3WalkExpr ( & sWalker , sParse . pNewIndex -> pPartIdxWhere ) ; } else { TriggerStep * pStep ; rc = renameResolveTrigger ( & sParse , ( bTemp ? 0 : zDb ) ) ; if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; for ( pStep = sParse . pNewTrigger -> step_list ; pStep ; pStep = pStep -> pNext ) { if ( pStep -> zTarget ) { Table * pTarget = sqlite3LocateTable ( & sParse , 0 , pStep -> zTarget , zDb ) ; if ( pTarget == pTab ) { if ( pStep -> pUpsert ) { ExprList * pUpsertSet = pStep -> pUpsert -> pUpsertSet ; renameColumnElistNames ( & sParse , & sCtx , pUpsertSet , zOld ) ; } renameColumnIdlistNames ( & sParse , & sCtx , pStep -> pIdList , zOld ) ; renameColumnElistNames ( & sParse , & sCtx , pStep -> pExprList , zOld ) ; } } } if ( sParse . pTriggerTab == pTab ) { renameColumnIdlistNames ( & sParse , & sCtx , sParse . pNewTrigger -> pColumns , zOld ) ; } renameWalkTrigger ( & sWalker , sParse . pNewTrigger ) ; } assert ( rc == SQLITE_OK ) ; rc = renameEditSql ( context , & sCtx , zSql , zNew , bQuote ) ; renameColumnFunc_done : if ( rc != SQLITE_OK ) { if ( sParse . zErrMsg ) { renameColumnParseError ( context , 0 , argv [ 1 ] , argv [ 2 ] , & sParse ) ; } else { sqlite3_result_error_code ( context , rc ) ; } } renameParseCleanup ( & sParse ) ; renameTokenFree ( db , sCtx . pList ) ; # ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = xAuth ; # endif sqlite3BtreeLeaveAll ( db ) ; }
","<S2SV_ModStart> pSelect ) { pSelect -> selFlags &= ~ SF_View ; <S2SV_ModStart> & sParse , <S2SV_ModEnd> pSelect , 0
",sqlite@sqlite/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,CVE-2019-19645,https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,2019-12-09T16:15Z,"<S2SV_StartBug> sParse . rc = SQLITE_OK ; <S2SV_EndBug> <S2SV_StartBug> sqlite3SelectPrep ( & sParse , sParse . pNewTable -> pSelect , 0 ) ; <S2SV_EndBug>"
275,CWE-20,"static gboolean parse_netscreen_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { int sec ; int dsec ; char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; char direction [ 2 ] ; guint pkt_len ; char cap_src [ 13 ] ; char cap_dst [ 13 ] ; guint8 * pd ; gchar * p ; int n , i = 0 ; guint offset = 0 ; gchar dststr [ 13 ] ; phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9u:%12s->%12s/"" , & sec , & dsec , cap_int , direction , & pkt_len , cap_src , cap_dst ) < 5 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""netscreen:<S2SV_blank>Can\'t<S2SV_blank>parse<S2SV_blank>packet-header"" ) ; return - 1 ; } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""netscreen:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> ts . secs = sec ; phdr -> ts . nsecs = dsec * 100000000 ; phdr -> len = pkt_len ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; while ( 1 ) { if ( file_gets ( line , NETSCREEN_LINE_LENGTH , fh ) == NULL ) { break ; } for ( p = & line [ 0 ] ; g_ascii_isspace ( * p ) ; p ++ ) ; if ( * p == '\\0' ) { break ; } n = parse_single_hex_dump_line ( p , pd , offset ) ; if ( offset == 0 && n < 6 ) { if ( info_line ( line ) ) { if ( ++ i <= NETSCREEN_MAX_INFOLINES ) { continue ; } } else { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""netscreen:<S2SV_blank>cannot<S2SV_blank>parse<S2SV_blank>hex-data"" ) ; return FALSE ; } } if ( n == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""netscreen:<S2SV_blank>cannot<S2SV_blank>parse<S2SV_blank>hex-data"" ) ; return FALSE ; } offset += n ; if ( offset > pkt_len ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""netscreen:<S2SV_blank>too<S2SV_blank>much<S2SV_blank>hex-data"" ) ; return FALSE ; } } if ( strncmp ( cap_int , ""adsl"" , 4 ) == 0 ) { g_snprintf ( dststr , 13 , ""%02x%02x%02x%02x%02x%02x"" , pd [ 0 ] , pd [ 1 ] , pd [ 2 ] , pd [ 3 ] , pd [ 4 ] , pd [ 5 ] ) ; if ( strncmp ( dststr , cap_dst , 12 ) == 0 ) phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; else phdr -> pkt_encap = WTAP_ENCAP_PPP ; } else if ( strncmp ( cap_int , ""seri"" , 4 ) == 0 ) phdr -> pkt_encap = WTAP_ENCAP_PPP ; else phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; phdr -> caplen = offset ; return TRUE ; }
","<S2SV_ModStart> ) { int pkt_len ; int <S2SV_ModStart> 2 ] ; <S2SV_ModEnd> char cap_src [ <S2SV_ModStart> = 0 ; int <S2SV_ModEnd> offset = 0 <S2SV_ModStart> ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9d:%12s->%12s/"" <S2SV_ModEnd> , & sec <S2SV_ModStart> return - 1 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""netscreen:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE
",wireshark@wireshark/11edc83b98a61e890d7bb01855389d40e984ea82,CVE-2016-5357,https://github.com/wireshark/wireshark/commit/11edc83b98a61e890d7bb01855389d40e984ea82,2016-08-07T16:59Z,"<S2SV_StartBug> int sec ; <S2SV_EndBug> <S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> <S2SV_StartBug> guint offset = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9u:%12s->%12s/"" , <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug>"
7448,CWE-125,"static void l2tp_framing_cap_print ( netdissect_options * ndo , const u_char * dat ) { const uint32_t * ptr = ( const uint32_t * ) dat ; if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_CAP_ASYNC_MASK ) { ND_PRINT ( ( ndo , ""A"" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_CAP_SYNC_MASK ) { ND_PRINT ( ( ndo , ""S"" ) ) ; } }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,"<S2SV_StartBug> l2tp_framing_cap_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug>"
4684,CWE-416,"static void host_callback ( void * arg , int status , int timeouts , unsigned char * abuf , int alen ) { struct host_query * hquery = ( struct host_query * ) arg ; int addinfostatus = ARES_SUCCESS ; hquery -> timeouts += timeouts ; hquery -> remaining -- ; if ( status == ARES_SUCCESS ) { addinfostatus = ares__parse_into_addrinfo ( abuf , alen , hquery -> ai ) ; } else if ( status == ARES_EDESTRUCTION ) { end_hquery ( hquery , status ) ; } if ( ! hquery -> remaining ) { if ( addinfostatus != ARES_SUCCESS ) { end_hquery ( hquery , addinfostatus ) ; } else if ( hquery -> ai -> nodes ) { end_hquery ( hquery , ARES_SUCCESS ) ; } else if ( status == ARES_ENOTFOUND ) { next_lookup ( hquery , status ) ; } else { end_hquery ( hquery , status ) ; } } }
","<S2SV_ModStart> status ) ; return ;
",c-ares@c-ares/1cc7e83c3bdfaafbc5919c95025592d8de3a170e,CVE-2020-14354,https://github.com/c-ares/c-ares/commit/1cc7e83c3bdfaafbc5919c95025592d8de3a170e,2021-05-13T14:15Z,<S2SV_StartBug> } <S2SV_EndBug>
3041,CWE-125,"static void ubik_print ( netdissect_options * ndo , register const u_char * bp ) { int ubik_op ; int32_t temp ; ubik_op = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>ubik<S2SV_blank>call<S2SV_blank>%s"" , tok2str ( ubik_req , ""op#%d"" , ubik_op ) ) ) ; bp += sizeof ( struct rx_header ) + 4 ; switch ( ubik_op ) { case 10000 : ND_TCHECK2 ( bp [ 0 ] , 4 ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>syncsite<S2SV_blank>%s"" , temp ? ""yes"" : ""no"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>votestart"" ) ) ; DATEOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 10003 : ND_PRINT ( ( ndo , ""<S2SV_blank>site"" ) ) ; UINTOUT ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20002 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; tok2str ( ubik_lock_types , ""type<S2SV_blank>%d"" , temp ) ; break ; case 20003 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; break ; case 20005 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; break ; case 20006 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20009 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; break ; case 20012 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>oldversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>newversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; default : ; } return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|ubik]"" ) ) ; }
","<S2SV_ModStart> ( ) ; ND_TCHECK_32BITS ( bp ) ;
",the-tcpdump-group@tcpdump/aa0858100096a3490edf93034a80e66a4d61aad5,CVE-2017-13049,https://github.com/the-tcpdump-group/tcpdump/commit/aa0858100096a3490edf93034a80e66a4d61aad5,2017-09-14T06:29Z,<S2SV_StartBug> temp = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug>
5414,CWE-532,"int _pam_parse ( int argc , const char * * argv ) { int ctrl = 0 ; const char * current_secret = NULL ; memset ( tac_srv , 0 , sizeof ( tacplus_server_t ) * TAC_PLUS_MAXSERVERS ) ; memset ( & tac_srv_addr , 0 , sizeof ( struct addrinfo ) * TAC_PLUS_MAXSERVERS ) ; memset ( & tac_sock_addr , 0 , sizeof ( struct sockaddr ) * TAC_PLUS_MAXSERVERS ) ; memset ( & tac_sock6_addr , 0 , sizeof ( struct sockaddr_in6 ) * TAC_PLUS_MAXSERVERS ) ; tac_srv_no = 0 ; tac_service [ 0 ] = 0 ; tac_protocol [ 0 ] = 0 ; tac_prompt [ 0 ] = 0 ; tac_login [ 0 ] = 0 ; for ( ctrl = 0 ; argc -- > 0 ; ++ argv ) { if ( ! strcmp ( * argv , ""debug"" ) ) { ctrl |= PAM_TAC_DEBUG ; } else if ( ! strcmp ( * argv , ""use_first_pass"" ) ) { ctrl |= PAM_TAC_USE_FIRST_PASS ; } else if ( ! strcmp ( * argv , ""try_first_pass"" ) ) { ctrl |= PAM_TAC_TRY_FIRST_PASS ; } else if ( ! strncmp ( * argv , ""service="" , 8 ) ) { xstrcpy ( tac_service , * argv + 8 , sizeof ( tac_service ) ) ; } else if ( ! strncmp ( * argv , ""protocol="" , 9 ) ) { xstrcpy ( tac_protocol , * argv + 9 , sizeof ( tac_protocol ) ) ; } else if ( ! strncmp ( * argv , ""prompt="" , 7 ) ) { xstrcpy ( tac_prompt , * argv + 7 , sizeof ( tac_prompt ) ) ; unsigned long chr ; for ( chr = 0 ; chr < strlen ( tac_prompt ) ; chr ++ ) { if ( tac_prompt [ chr ] == '_' ) { tac_prompt [ chr ] = '<S2SV_blank>' ; } } } else if ( ! strncmp ( * argv , ""login="" , 6 ) ) { xstrcpy ( tac_login , * argv + 6 , sizeof ( tac_login ) ) ; } else if ( ! strcmp ( * argv , ""acct_all"" ) ) { ctrl |= PAM_TAC_ACCT ; } else if ( ! strncmp ( * argv , ""server="" , 7 ) ) { if ( tac_srv_no < TAC_PLUS_MAXSERVERS ) { struct addrinfo hints , * servers , * server ; int rv ; char * close_bracket , * server_name , * port , server_buf [ 256 ] ; memset ( & hints , 0 , sizeof hints ) ; memset ( & server_buf , 0 , sizeof ( server_buf ) ) ; hints . ai_family = AF_UNSPEC ; hints . ai_socktype = SOCK_STREAM ; if ( strlen ( * argv + 7 ) >= sizeof ( server_buf ) ) { _pam_log ( LOG_ERR , ""server<S2SV_blank>address<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>sorry"" ) ; continue ; } strcpy ( server_buf , * argv + 7 ) ; if ( * server_buf == '[' && ( close_bracket = strchr ( server_buf , ']' ) ) != NULL ) { server_name = server_buf + 1 ; _pam_log ( LOG_ERR , ""reading<S2SV_blank>server<S2SV_blank>address<S2SV_blank>as:<S2SV_blank>%s<S2SV_blank>"" , server_name ) ; port = strchr ( close_bracket , ':' ) ; * close_bracket = '\\0' ; } else { server_name = server_buf ; port = strchr ( server_buf , ':' ) ; } if ( port != NULL ) { * port = '\\0' ; port ++ ; } _pam_log ( LOG_DEBUG , ""sending<S2SV_blank>server<S2SV_blank>address<S2SV_blank>to<S2SV_blank>getaddrinfo<S2SV_blank>as:<S2SV_blank>%s<S2SV_blank>"" , server_name ) ; if ( ( rv = getaddrinfo ( server_name , ( port == NULL ) ? ""49"" : port , & hints , & servers ) ) == 0 ) { for ( server = servers ; server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS ; server = server -> ai_next ) { set_tac_srv_addr ( tac_srv_no , server ) ; set_tac_srv_key ( tac_srv_no , current_secret ) ; tac_srv_no ++ ; } _pam_log ( LOG_DEBUG , ""%s:<S2SV_blank>server<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>"" , __FUNCTION__ , tac_srv_no ) ; freeaddrinfo ( servers ) ; } else { _pam_log ( LOG_ERR , ""skip<S2SV_blank>invalid<S2SV_blank>server:<S2SV_blank>%s<S2SV_blank>(getaddrinfo:<S2SV_blank>%s)"" , server_name , gai_strerror ( rv ) ) ; } } else { _pam_log ( LOG_ERR , ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>servers<S2SV_blank>(%d)<S2SV_blank>exceeded,<S2SV_blank>skipping"" , TAC_PLUS_MAXSERVERS ) ; } } else if ( ! strncmp ( * argv , ""secret="" , 7 ) ) { current_secret = * argv + 7 ; if ( tac_srv_no == 0 ) { _pam_log ( LOG_ERR , ""secret<S2SV_blank>set<S2SV_blank>but<S2SV_blank>no<S2SV_blank>servers<S2SV_blank>configured<S2SV_blank>yet"" ) ; } else { set_tac_srv_key ( tac_srv_no - 1 , current_secret ) ; } } else if ( ! strncmp ( * argv , ""timeout="" , 8 ) ) { # ifdef HAVE_STRTOL tac_timeout = strtol ( * argv + 8 , NULL , 10 ) ; # else tac_timeout = atoi ( * argv + 8 ) ; # endif if ( tac_timeout == LONG_MAX ) { _pam_log ( LOG_ERR , ""timeout<S2SV_blank>parameter<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>parsed<S2SV_blank>as<S2SV_blank>integer:<S2SV_blank>%s"" , * argv ) ; tac_timeout = 0 ; } else { tac_readtimeout_enable = 1 ; } } else { _pam_log ( LOG_WARNING , ""unrecognized<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ; } } if ( ctrl & PAM_TAC_DEBUG ) { unsigned long n ; _pam_log ( LOG_DEBUG , ""%d<S2SV_blank>servers<S2SV_blank>defined"" , tac_srv_no ) ; for ( n = 0 ; n < tac_srv_no ; n ++ ) { _pam_log ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'%s\'<S2SV_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) , tac_srv [ n ] . key ) ; } _pam_log ( LOG_DEBUG , ""tac_service=\'%s\'"" , tac_service ) ; _pam_log ( LOG_DEBUG , ""tac_protocol=\'%s\'"" , tac_protocol ) ; _pam_log ( LOG_DEBUG , ""tac_prompt=\'%s\'"" , tac_prompt ) ; _pam_log ( LOG_DEBUG , ""tac_login=\'%s\'"" , tac_login ) ; } return ctrl ; }
","<S2SV_ModStart> ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'********\'<S2SV_blank>}"" <S2SV_ModEnd> , n , <S2SV_ModStart> -> ai_addr ) <S2SV_ModEnd> ) ; }
",kravietz@pam_tacplus/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0,CVE-2020-13881,https://github.com/kravietz/pam_tacplus/commit/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0,2020-06-06T19:15Z,"<S2SV_StartBug> _pam_log ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'%s\'<S2SV_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) , <S2SV_EndBug>"
196,CWE-119,"int phar_verify_signature ( php_stream * fp , size_t end_of_phar , php_uint32 sig_type , char * sig , int sig_len , char * fname , char * * signature , int * signature_len , char * * error ) { int read_size , len ; zend_off_t read_len ; unsigned char buf [ 1024 ] ; php_stream_rewind ( fp ) ; switch ( sig_type ) { case PHAR_SIG_OPENSSL : { # ifdef PHAR_HAVE_OPENSSL BIO * in ; EVP_PKEY * key ; EVP_MD * mdtype = ( EVP_MD * ) EVP_sha1 ( ) ; EVP_MD_CTX md_ctx ; # else int tempsig ; # endif zend_string * pubkey = NULL ; char * pfile ; php_stream * pfp ; # ifndef PHAR_HAVE_OPENSSL if ( ! zend_hash_str_exists ( & module_registry , ""openssl"" , sizeof ( ""openssl"" ) - 1 ) ) { if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>not<S2SV_blank>loaded"" ) ; } return FAILURE ; } # endif spprintf ( & pfile , 0 , ""%s.pubkey"" , fname ) ; pfp = php_stream_open_wrapper ( pfile , ""rb"" , 0 , NULL ) ; efree ( pfile ) ; if ( ! pfp || ! ( pubkey = php_stream_copy_to_mem ( pfp , PHP_STREAM_COPY_ALL , 0 ) ) || ! ZSTR_LEN ( pubkey ) ) { if ( pfp ) { php_stream_close ( pfp ) ; } if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>public<S2SV_blank>key<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>read"" ) ; } return FAILURE ; } php_stream_close ( pfp ) ; # ifndef PHAR_HAVE_OPENSSL tempsig = sig_len ; if ( FAILURE == phar_call_openssl_signverify ( 0 , fp , end_of_phar , pubkey ? ZSTR_VAL ( pubkey ) : NULL , pubkey ? ZSTR_LEN ( pubkey ) : 0 , & sig , & tempsig ) ) { if ( pubkey ) { zend_string_release ( pubkey ) ; } if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>verified"" ) ; } return FAILURE ; } if ( pubkey ) { zend_string_release ( pubkey ) ; } sig_len = tempsig ; # else in = BIO_new_mem_buf ( pubkey ? ZSTR_VAL ( pubkey ) : NULL , pubkey ? ZSTR_LEN ( pubkey ) : 0 ) ; if ( NULL == in ) { zend_string_release ( pubkey ) ; if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>processed"" ) ; } return FAILURE ; } key = PEM_read_bio_PUBKEY ( in , NULL , NULL , NULL ) ; BIO_free ( in ) ; zend_string_release ( pubkey ) ; if ( NULL == key ) { if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>processed"" ) ; } return FAILURE ; } EVP_VerifyInit ( & md_ctx , mdtype ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } php_stream_seek ( fp , 0 , SEEK_SET ) ; while ( read_size && ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { EVP_VerifyUpdate ( & md_ctx , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } if ( EVP_VerifyFinal ( & md_ctx , ( unsigned char * ) sig , sig_len , key ) != 1 ) { EVP_MD_CTX_cleanup ( & md_ctx ) ; if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>openssl<S2SV_blank>signature"" ) ; } return FAILURE ; } EVP_MD_CTX_cleanup ( & md_ctx ) ; # endif * signature_len = phar_hex_str ( ( const char * ) sig , sig_len , signature ) ; } break ; # ifdef PHAR_HASH_OK case PHAR_SIG_SHA512 : { unsigned char digest [ 64 ] ; PHP_SHA512_CTX context ; PHP_SHA512Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA512Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA512Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } case PHAR_SIG_SHA256 : { unsigned char digest [ 32 ] ; PHP_SHA256_CTX context ; PHP_SHA256Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA256Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA256Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } # else case PHAR_SIG_SHA512 : case PHAR_SIG_SHA256 : if ( error ) { spprintf ( error , 0 , ""unsupported<S2SV_blank>signature"" ) ; } return FAILURE ; # endif case PHAR_SIG_SHA1 : { unsigned char digest [ 20 ] ; PHP_SHA1_CTX context ; PHP_SHA1Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA1Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA1Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } case PHAR_SIG_MD5 : { unsigned char digest [ 16 ] ; PHP_MD5_CTX context ; PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } default : if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>or<S2SV_blank>unsupported<S2SV_blank>signature"" ) ; } return FAILURE ; } return SUCCESS ; }
","<S2SV_ModStart> PHP_SHA512_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_SHA256_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_SHA1_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_MD5_CTX context ; if ( sig_len < sizeof ( digest <S2SV_ModEnd> ) ) { <S2SV_ModStart> FAILURE ; } PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; }
",php@php-src/0bfb970f43acd1e81d11be1154805f86655f15d5,CVE-2016-7414,https://github.com/php/php-src/commit/0bfb970f43acd1e81d11be1154805f86655f15d5?w=1,2016-09-17T21:59Z,"<S2SV_StartBug> PHP_SHA512Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_SHA256Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_SHA1Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_MD5Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; <S2SV_EndBug>"
58,CWE-59,"static void vrrp_tfile_end_handler ( void ) { vrrp_tracked_file_t * tfile = LIST_TAIL_DATA ( vrrp_data -> vrrp_track_files ) ; struct stat statb ; FILE * tf ; int ret ; if ( ! tfile -> file_path ) { report_config_error ( CONFIG_GENERAL_ERROR , ""No<S2SV_blank>file<S2SV_blank>set<S2SV_blank>for<S2SV_blank>track_file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>removing"" , tfile -> fname ) ; free_list_element ( vrrp_data -> vrrp_track_files , vrrp_data -> vrrp_track_files -> tail ) ; return ; } if ( track_file_init == TRACK_FILE_NO_INIT ) return ; ret = stat ( tfile -> file_path , & statb ) ; if ( ! ret ) { if ( track_file_init == TRACK_FILE_CREATE ) { return ; } if ( ( statb . st_mode & S_IFMT ) != S_IFREG ) { report_config_error ( CONFIG_GENERAL_ERROR , ""Cannot<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>it<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file"" , tfile -> fname ) ; return ; } if ( reload ) return ; } if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { if ( ( tf = fopen ( tfile -> file_path , ""w"" ) ) ) { fprintf ( tf , ""%d\\n"" , track_file_init_value ) ; fclose ( tf ) ; } else report_config_error ( CONFIG_GENERAL_ERROR , ""Unable<S2SV_blank>to<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s"" , tfile -> fname ) ; } }
","<S2SV_ModStart> ( tf = fopen_safe <S2SV_ModEnd> ( tfile ->
",acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306,CVE-2018-19044,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,2018-11-08T20:29Z,"<S2SV_StartBug> if ( ( tf = fopen ( tfile -> file_path , ""w"" ) ) ) { <S2SV_EndBug>"
7947,CWE-415,"static int parse_key_constraints ( struct sshbuf * m , struct sshkey * k , time_t * deathp , u_int * secondsp , int * confirmp , char * * sk_providerp ) { u_char ctype ; int r ; u_int seconds , maxsign = 0 ; char * ext_name = NULL ; struct sshbuf * b = NULL ; while ( sshbuf_len ( m ) ) { if ( ( r = sshbuf_get_u8 ( m , & ctype ) ) != 0 ) { error_fr ( r , ""parse<S2SV_blank>constraint<S2SV_blank>type"" ) ; goto err ; } switch ( ctype ) { case SSH_AGENT_CONSTRAIN_LIFETIME : if ( * deathp != 0 ) { error_f ( ""lifetime<S2SV_blank>already<S2SV_blank>set"" ) ; goto err ; } if ( ( r = sshbuf_get_u32 ( m , & seconds ) ) != 0 ) { error_fr ( r , ""parse<S2SV_blank>lifetime<S2SV_blank>constraint"" ) ; goto err ; } * deathp = monotime ( ) + seconds ; * secondsp = seconds ; break ; case SSH_AGENT_CONSTRAIN_CONFIRM : if ( * confirmp != 0 ) { error_f ( ""confirm<S2SV_blank>already<S2SV_blank>set"" ) ; goto err ; } * confirmp = 1 ; break ; case SSH_AGENT_CONSTRAIN_MAXSIGN : if ( k == NULL ) { error_f ( ""maxsign<S2SV_blank>not<S2SV_blank>valid<S2SV_blank>here"" ) ; goto err ; } if ( maxsign != 0 ) { error_f ( ""maxsign<S2SV_blank>already<S2SV_blank>set"" ) ; goto err ; } if ( ( r = sshbuf_get_u32 ( m , & maxsign ) ) != 0 ) { error_fr ( r , ""parse<S2SV_blank>maxsign<S2SV_blank>constraint"" ) ; goto err ; } if ( ( r = sshkey_enable_maxsign ( k , maxsign ) ) != 0 ) { error_fr ( r , ""enable<S2SV_blank>maxsign"" ) ; goto err ; } break ; case SSH_AGENT_CONSTRAIN_EXTENSION : if ( ( r = sshbuf_get_cstring ( m , & ext_name , NULL ) ) != 0 ) { error_fr ( r , ""parse<S2SV_blank>constraint<S2SV_blank>extension"" ) ; goto err ; } debug_f ( ""constraint<S2SV_blank>ext<S2SV_blank>%s"" , ext_name ) ; if ( strcmp ( ext_name , ""sk-provider@openssh.com"" ) == 0 ) { if ( sk_providerp == NULL ) { error_f ( ""%s<S2SV_blank>not<S2SV_blank>valid<S2SV_blank>here"" , ext_name ) ; goto err ; } if ( * sk_providerp != NULL ) { error_f ( ""%s<S2SV_blank>already<S2SV_blank>set"" , ext_name ) ; goto err ; } if ( ( r = sshbuf_get_cstring ( m , sk_providerp , NULL ) ) != 0 ) { error_fr ( r , ""parse<S2SV_blank>%s"" , ext_name ) ; goto err ; } } else { error_f ( ""unsupported<S2SV_blank>constraint<S2SV_blank>\\""%s\\"""" , ext_name ) ; goto err ; } free ( ext_name ) ; break ; default : error_f ( ""Unknown<S2SV_blank>constraint<S2SV_blank>%d"" , ctype ) ; err : free ( ext_name ) ; sshbuf_free ( b ) ; return - 1 ; } } return 0 ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> while ( sshbuf_len <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } switch <S2SV_ModStart> ""lifetime<S2SV_blank>already<S2SV_blank>set"" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } * <S2SV_ModStart> ""confirm<S2SV_blank>already<S2SV_blank>set"" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } * <S2SV_ModStart> ""maxsign<S2SV_blank>not<S2SV_blank>valid<S2SV_blank>here"" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ""maxsign<S2SV_blank>already<S2SV_blank>set"" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } break <S2SV_ModStart> ( r = parse_key_constraint_extension ( m , sk_providerp ) ) != 0 ) goto out ; break ; default : error_f ( <S2SV_ModEnd> ""Unknown<S2SV_blank>constraint<S2SV_blank>%d"" , ctype <S2SV_ModStart> ctype ) ; r = SSH_ERR_FEATURE_UNSUPPORTED ; goto out ; } } r = 0 ; out : return r <S2SV_ModEnd> ; } <S2SV_null>
",openssh@openssh-portable/e04fd6dde16de1cdc5a4d9946397ff60d96568db,CVE-2021-28041,https://github.com/openssh/openssh-portable/commit/e04fd6dde16de1cdc5a4d9946397ff60d96568db,2021-03-05T21:15Z,"<S2SV_StartBug> char * ext_name = NULL ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ( r = sshbuf_get_cstring ( m , & ext_name , NULL ) ) != 0 ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug>"
1974,CWE-119,"static int svc_log ( SvcContext * svc_ctx , int level , const char * fmt , ... ) { char buf [ 512 ] ; int retval = 0 ; va_list ap ; SvcInternal * const si = get_svc_internal ( svc_ctx ) ; if ( level > svc_ctx -> log_level ) { return retval ; } va_start ( ap , fmt ) ; retval = vsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ; va_end ( ap ) ; if ( svc_ctx -> log_print ) { printf ( ""%s"" , buf ) ; } else { strncat ( si -> message_buffer , buf , sizeof ( si -> message_buffer ) - strlen ( si -> message_buffer ) - 1 ) ; } if ( level == SVC_LOG_ERROR ) { si -> codec_ctx -> err_detail = si -> message_buffer ; } return retval ; }
","<S2SV_ModStart> * svc_ctx , SVC_LOG_LEVEL <S2SV_ModEnd> level , const <S2SV_ModStart> va_list ap ; SvcInternal_t <S2SV_ModEnd> * const si
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static int svc_log ( SvcContext * svc_ctx , int level , const char * fmt , ... ) { <S2SV_EndBug> <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug>"
7870,CWE-20,"uint16_t enc624j600ReadPhyReg ( NetInterface * interface , uint8_t address ) { enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ; enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , MICMD_MIIRD ) ; usleep ( 100 ) ; while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) { } enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , 0x00 ) ; return enc624j600ReadReg ( interface , ENC624J600_REG_MIRD ) ; }
","<S2SV_ModStart> address ) { uint16_t status ; <S2SV_ModStart> ( interface , ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT <S2SV_ModEnd> | address ) <S2SV_ModStart> ( interface , ENC624J600_MICMD , ENC624J600_MICMD_MIIRD <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> 100 ) ; do { status = <S2SV_ModEnd> enc624j600ReadReg ( interface <S2SV_ModStart> ( interface , ENC624J600_MISTAT ) ; } while ( ( status & ENC624J600_MISTAT_BUSY <S2SV_ModEnd> ) != 0 <S2SV_ModStart> != 0 ) ; <S2SV_ModEnd> enc624j600WriteReg ( interface <S2SV_ModStart> ( interface , ENC624J600_MICMD <S2SV_ModEnd> , 0x00 ) <S2SV_ModStart> ( interface , ENC624J600_MIRD <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , MICMD_MIIRD ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> return enc624j600ReadReg ( interface , ENC624J600_REG_MIRD ) ; <S2SV_EndBug>"
3073,CWE-119,"static int Downmix_Command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { downmix_module_t * pDwmModule = ( downmix_module_t * ) self ; downmix_object_t * pDownmixer ; int retsize ; if ( pDwmModule == NULL || pDwmModule -> context . state == DOWNMIX_STATE_UNINITIALIZED ) { return - EINVAL ; } pDownmixer = ( downmix_object_t * ) & pDwmModule -> context ; ALOGV ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>%"" PRIu32 ""<S2SV_blank>cmdSize<S2SV_blank>%"" PRIu32 , cmdCode , cmdSize ) ; switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } * ( int * ) pReplyData = Downmix_Init ( pDwmModule ) ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } * ( int * ) pReplyData = Downmix_Configure ( pDwmModule , ( effect_config_t * ) pCmdData , false ) ; break ; case EFFECT_CMD_RESET : Downmix_Reset ( pDownmixer , false ) ; break ; case EFFECT_CMD_GET_PARAM : ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pReplyData:<S2SV_blank>%p"" , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || pReplyData == NULL || * replySize < ( int ) sizeof ( effect_param_t ) + 2 * sizeof ( int32_t ) ) { return - EINVAL ; } effect_param_t * rep = ( effect_param_t * ) pReplyData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ; ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>param<S2SV_blank>%"" PRId32 "",<S2SV_blank>replySize<S2SV_blank>%"" PRIu32 , * ( int32_t * ) rep -> data , rep -> vsize ) ; rep -> status = Downmix_getParameter ( pDownmixer , * ( int32_t * ) rep -> data , & rep -> vsize , rep -> data + sizeof ( int32_t ) ) ; * replySize = sizeof ( effect_param_t ) + sizeof ( int32_t ) + rep -> vsize ; break ; case EFFECT_CMD_SET_PARAM : ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pReplyData<S2SV_blank>%p"" , cmdSize , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || ( cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ) || pReplyData == NULL || * replySize != ( int ) sizeof ( int32_t ) ) { return - EINVAL ; } effect_param_t * cmd = ( effect_param_t * ) pCmdData ; * ( int * ) pReplyData = Downmix_setParameter ( pDownmixer , * ( int32_t * ) cmd -> data , cmd -> vsize , cmd -> data + sizeof ( int32_t ) ) ; break ; case EFFECT_CMD_SET_PARAM_DEFERRED : ALOGW ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_DEFERRED<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME"" ) ; break ; case EFFECT_CMD_SET_PARAM_COMMIT : ALOGW ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_COMMIT<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME"" ) ; break ; case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_INITIALIZED ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_ACTIVE ; ALOGV ( ""EFFECT_CMD_ENABLE()<S2SV_blank>OK"" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_ACTIVE ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_INITIALIZED ; ALOGV ( ""EFFECT_CMD_DISABLE()<S2SV_blank>OK"" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_DEVICE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_DEVICE:<S2SV_blank>0x%08"" PRIx32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_VOLUME : { if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) * 2 ) { return - EINVAL ; } ALOGW ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_VOLUME<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME"" ) ; float left = ( float ) ( * ( uint32_t * ) pCmdData ) / ( 1 << 24 ) ; float right = ( float ) ( * ( ( uint32_t * ) pCmdData + 1 ) ) / ( 1 << 24 ) ; ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_VOLUME:<S2SV_blank>left<S2SV_blank>%f,<S2SV_blank>right<S2SV_blank>%f<S2SV_blank>"" , left , right ) ; break ; } case EFFECT_CMD_SET_AUDIO_MODE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_AUDIO_MODE:<S2SV_blank>%"" PRIu32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_CONFIG_REVERSE : case EFFECT_CMD_SET_INPUT_DEVICE : break ; default : ALOGW ( ""Downmix_Command<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>%"" PRIu32 , cmdCode ) ; return - EINVAL ; } return 0 ; }
","<S2SV_ModStart> == NULL || replySize == NULL || <S2SV_ModStart> ) || pReplyData == NULL || replySize <S2SV_ModStart> ) || pReplyData == NULL || replySize <S2SV_ModStart> == NULL || replySize == NULL || <S2SV_ModStart> == NULL || replySize == NULL || <S2SV_ModStart> if ( pReplyData == NULL || replySize
",frameworks@av/aeea52da00d210587fb3ed895de3d5f2e0264c88,CVE-2015-3842,https://android.googlesource.com/platform/frameworks/av/+/aeea52da00d210587fb3ed895de3d5f2e0264c88,2015-10-01T00:59Z,<S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> <S2SV_StartBug> || pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> <S2SV_StartBug> pReplyData == NULL || <S2SV_EndBug> <S2SV_StartBug> || pReplyData == NULL || * replySize != ( int ) sizeof ( int32_t ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug>
4031,CWE-399,"static int rock_continue ( struct rock_state * rs ) { int ret = 1 ; int blocksize = 1 << rs -> inode -> i_blkbits ; const int min_de_size = offsetof ( struct rock_ridge , u ) ; kfree ( rs -> buffer ) ; rs -> buffer = NULL ; if ( ( unsigned ) rs -> cont_offset > blocksize - min_de_size || ( unsigned ) rs -> cont_size > blocksize || ( unsigned ) ( rs -> cont_offset + rs -> cont_size ) > blocksize ) { printk ( KERN_NOTICE ""rock:<S2SV_blank>corrupted<S2SV_blank>directory<S2SV_blank>entry.<S2SV_blank>"" ""extent=%d,<S2SV_blank>offset=%d,<S2SV_blank>size=%d\\n"" , rs -> cont_extent , rs -> cont_offset , rs -> cont_size ) ; ret = - EIO ; goto out ; } if ( rs -> cont_extent ) { struct buffer_head * bh ; rs -> buffer = kmalloc ( rs -> cont_size , GFP_KERNEL ) ; if ( ! rs -> buffer ) { ret = - ENOMEM ; goto out ; } ret = - EIO ; bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; if ( bh ) { memcpy ( rs -> buffer , bh -> b_data + rs -> cont_offset , rs -> cont_size ) ; put_bh ( bh ) ; rs -> chr = rs -> buffer ; rs -> len = rs -> cont_size ; rs -> cont_extent = 0 ; rs -> cont_size = 0 ; rs -> cont_offset = 0 ; return 0 ; } printk ( ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>rock-ridge<S2SV_blank>attributes\\n"" ) ; } out : kfree ( rs -> buffer ) ; rs -> buffer = NULL ; return ret ; }
","<S2SV_ModStart> - EIO ; if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;
",torvalds@linux/f54e18f1b831c92f6512d2eedb224cd63d607d3d,CVE-2014-9420,https://github.com/torvalds/linux/commit/f54e18f1b831c92f6512d2eedb224cd63d607d3d,2014-12-26T00:59Z,"<S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug>"
304,CWE-119,"PHP_FUNCTION ( radius_get_vendor_attr ) { int res ; const void * data ; int len ; u_int32_t vendor ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & data , & len ) == FAILURE ) { return ; } res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ; if ( res == - 1 ) { RETURN_FALSE ; } else { array_init ( return_value ) ; add_assoc_long ( return_value , ""attr"" , res ) ; add_assoc_long ( return_value , ""vendor"" , vendor ) ; add_assoc_stringl ( return_value , ""data"" , ( char * ) data , len , 1 ) ; return ; } }
","<S2SV_ModStart> radius_get_vendor_attr ) { <S2SV_ModEnd> const void * <S2SV_ModStart> void * data , * raw <S2SV_ModStart> ; u_int32_t vendor ; unsigned char type ; size_t data_len <S2SV_ModStart> ""s"" , & raw <S2SV_ModEnd> , & len <S2SV_ModStart> return ; } if ( <S2SV_ModEnd> rad_get_vendor_attr ( & <S2SV_ModStart> vendor , & type , & data , & data_len , raw , len ) <S2SV_ModEnd> == - 1 <S2SV_ModStart> , ""attr"" , type <S2SV_ModEnd> ) ; add_assoc_long <S2SV_ModStart> ) data , data_len <S2SV_ModEnd> , 1 )
",LawnGnome@php-radius/13c149b051f82b709e8d7cc32111e84b49d57234,CVE-2013-2220,https://github.com/LawnGnome/php-radius/commit/13c149b051f82b709e8d7cc32111e84b49d57234,2013-07-31T13:20Z,"<S2SV_StartBug> int res ; <S2SV_EndBug> <S2SV_StartBug> const void * data ; <S2SV_EndBug> <S2SV_StartBug> u_int32_t vendor ; <S2SV_EndBug> <S2SV_StartBug> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & data , & len ) == FAILURE ) { <S2SV_EndBug> <S2SV_StartBug> res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ; <S2SV_EndBug> <S2SV_StartBug> add_assoc_long ( return_value , ""attr"" , res ) ; <S2SV_EndBug> <S2SV_StartBug> add_assoc_stringl ( return_value , ""data"" , ( char * ) data , len , 1 ) ; <S2SV_EndBug>"
3861,CWE-264,"int append_camera_metadata ( camera_metadata_t * dst , const camera_metadata_t * src ) { if ( dst == NULL || src == NULL ) return ERROR ; if ( dst -> entry_capacity < src -> entry_count + dst -> entry_count ) return ERROR ; if ( dst -> data_capacity < src -> data_count + dst -> data_count ) return ERROR ; memcpy ( get_entries ( dst ) + dst -> entry_count , get_entries ( src ) , sizeof ( camera_metadata_buffer_entry_t [ src -> entry_count ] ) ) ; memcpy ( get_data ( dst ) + dst -> data_count , get_data ( src ) , sizeof ( uint8_t [ src -> data_count ] ) ) ; if ( dst -> data_count != 0 ) { camera_metadata_buffer_entry_t * entry = get_entries ( dst ) + dst -> entry_count ; for ( size_t i = 0 ; i < src -> entry_count ; i ++ , entry ++ ) { if ( calculate_camera_metadata_entry_data_size ( entry -> type , entry -> count ) > 0 ) { entry -> data . offset += dst -> data_count ; } } } if ( dst -> entry_count == 0 ) { dst -> flags |= src -> flags & FLAG_SORTED ; } else if ( src -> entry_count != 0 ) { dst -> flags &= ~ FLAG_SORTED ; } else { } dst -> entry_count += src -> entry_count ; dst -> data_count += src -> data_count ; assert ( validate_camera_metadata_structure ( dst , NULL ) == OK ) ; return OK ; }
","<S2SV_ModStart> src == NULL ) return ERROR ; if ( src -> entry_count + dst -> entry_count < src -> entry_count ) return ERROR ; if ( src -> data_count + dst -> data_count < src -> data_count
",system@media/e9e44f797742f52996ebf307740dad58c28fd9b5,CVE-2016-3915,https://android.googlesource.com/platform/system/media/+/e9e44f797742f52996ebf307740dad58c28fd9b5,2016-10-10T10:59Z,<S2SV_StartBug> if ( dst == NULL || src == NULL ) return ERROR ; <S2SV_EndBug>
1928,CWE-119,"static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , int ctr_id , va_list args ) { vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ; if ( frame != NULL ) { YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp9_copy_reference_enc ( ctx -> cpi , ref_frame_to_vp9_reframe ( frame -> frame_type ) , & sd ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug>"
4581,CWE-125,"static PyObject * parsenumber ( struct compiling * c , const char * s ) { char * dup , * end ; PyObject * res = NULL ; assert ( s != NULL ) ; if ( strchr ( s , '_' ) == NULL ) { return parsenumber_raw ( c , s ) ; } dup = PyMem_Malloc ( strlen ( s ) + 1 ) ; end = dup ; for ( ; * s ; s ++ ) { if ( * s != '_' ) { * end ++ = * s ; } } * end = '\\0' ; res = parsenumber_raw ( c , dup ) ; PyMem_Free ( dup ) ; return res ; }
","<S2SV_ModStart> 1 ) ; if ( dup == NULL ) { return PyErr_NoMemory ( ) ; }
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> end = dup ; <S2SV_EndBug>
3529,CWE-264,"static int load_state_from_tss16 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_16 * tss ) { int ret ; u8 cpl ; ctxt -> _eip = tss -> ip ; ctxt -> eflags = tss -> flag | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> ax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> cx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> dx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> bx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> sp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> bp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> si ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> di ; set_segment_selector ( ctxt , tss -> ldt , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; cpl = tss -> cs & 3 ; ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; return X86EMUL_CONTINUE ; }
","<S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z,"<S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug>"
1204,CWE-190,"SQLITE_PRIVATE ExprList * sqlite3ExprListAppend ( Parse * pParse , ExprList * pList , Expr * pExpr ) { struct ExprList_item * pItem ; sqlite3 * db = pParse -> db ; assert ( db != 0 ) ; if ( pList == 0 ) { pList = sqlite3DbMallocRawNN ( db , sizeof ( ExprList ) ) ; if ( pList == 0 ) { goto no_mem ; } pList -> nExpr = 0 ; } else if ( ( pList -> nExpr & ( pList -> nExpr - 1 ) ) == 0 ) { ExprList * pNew ; pNew = sqlite3DbRealloc ( db , pList , sizeof ( * pList ) + ( 2 * pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ; if ( pNew == 0 ) { goto no_mem ; } pList = pNew ; } pItem = & pList -> a [ pList -> nExpr ++ ] ; assert ( offsetof ( struct ExprList_item , zName ) == sizeof ( pItem -> pExpr ) ) ; assert ( offsetof ( struct ExprList_item , pExpr ) == 0 ) ; memset ( & pItem -> zName , 0 , sizeof ( * pItem ) - offsetof ( struct ExprList_item , zName ) ) ; pItem -> pExpr = pExpr ; return pList ; no_mem : sqlite3ExprDelete ( db , pExpr ) ; sqlite3ExprListDelete ( db , pList ) ; return 0 ; }
","<S2SV_ModStart> ( 2 * ( sqlite3_int64 )
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z,<S2SV_StartBug> sizeof ( * pList ) + ( 2 * pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ; <S2SV_EndBug>
516,CWE-119,"void WT_Interpolate ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; const EAS_SAMPLE * loopEnd ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; } pOutputBuffer = pWTIntFrame -> pAudioBuffer ; loopEnd = ( const EAS_SAMPLE * ) pWTVoice -> loopEnd + 1 ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = pWTVoice -> phaseFrac ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; acc0 = ( EAS_I32 ) ( pSamples - loopEnd ) ; if ( acc0 >= 0 ) pSamples = ( const EAS_SAMPLE * ) pWTVoice -> loopStart + acc0 ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }
","<S2SV_ModStart> ALOGE ( ""b/26366256"" ) ; android_errorWriteLog ( 0x534e4554 , ""26366256""
",external@sonivox/24d7c408c52143bce7b49de82f3913fd8d1219cf,CVE-2016-0838,https://android.googlesource.com/platform/external/sonivox/+/24d7c408c52143bce7b49de82f3913fd8d1219cf,2016-04-18T00:59Z,"<S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug>"
2487,CWE-000,"static int unix_dgram_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct sockaddr_un * sunaddr = ( struct sockaddr_un * ) addr ; struct sock * other ; unsigned int hash ; int err ; if ( addr -> sa_family != AF_UNSPEC ) { err = unix_mkname ( sunaddr , alen , & hash ) ; if ( err < 0 ) goto out ; alen = err ; if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! unix_sk ( sk ) -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; restart : other = unix_find_other ( net , sunaddr , alen , sock -> type , hash , & err ) ; if ( ! other ) goto out ; unix_state_double_lock ( sk , other ) ; if ( sock_flag ( other , SOCK_DEAD ) ) { unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; goto restart ; } err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } else { other = NULL ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) ) { struct sock * old_peer = unix_peer ( sk ) ; unix_peer ( sk ) = other ; unix_state_double_unlock ( sk , other ) ; if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ; sock_put ( old_peer ) ; } else { unix_peer ( sk ) = other ; unix_state_double_unlock ( sk , other ) ; } return 0 ; out_unlock : unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; out : return err ; }
","<S2SV_ModStart> = other ; unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;
",torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c,CVE-2013-7446,https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c,2015-12-28T11:59Z,"<S2SV_StartBug> unix_state_double_unlock ( sk , other ) ; <S2SV_EndBug>"
4292,CWE-362,"static void clear_evtchn_to_irq_row ( unsigned row ) { unsigned col ; for ( col = 0 ; col < EVTCHN_PER_ROW ; col ++ ) evtchn_to_irq [ row ] [ col ] = - 1 ; }
","<S2SV_ModStart> col ++ ) WRITE_ONCE ( <S2SV_ModStart> [ col ] , - 1 ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,CVE-2020-27675,https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,2020-10-22T21:15Z,<S2SV_StartBug> evtchn_to_irq [ row ] [ col ] = - 1 ; <S2SV_EndBug>
556,CWE-415,"SPL_METHOD ( SplDoublyLinkedList , offsetSet ) { zval * zindex , * value ; spl_dllist_object * intern ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""zz"" , & zindex , & value ) == FAILURE ) { return ; } intern = Z_SPLDLLIST_P ( getThis ( ) ) ; if ( Z_TYPE_P ( zindex ) == IS_NULL ) { spl_ptr_llist_push ( intern -> llist , value ) ; } else { zend_long index ; spl_ptr_llist_element * element ; index = spl_offset_convert_to_long ( zindex ) ; if ( index < 0 || index >= intern -> llist -> count ) { zval_ptr_dtor ( value ) ; zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" , 0 ) ; return ; } element = spl_ptr_llist_offset ( intern -> llist , index , intern -> flags & SPL_DLLIST_IT_LIFO ) ; if ( element != NULL ) { if ( intern -> llist -> dtor ) { intern -> llist -> dtor ( element ) ; } zval_ptr_dtor ( & element -> data ) ; ZVAL_COPY_VALUE ( & element -> data , value ) ; if ( intern -> llist -> ctor ) { intern -> llist -> ctor ( element ) ; } } else { zval_ptr_dtor ( value ) ; zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid"" , 0 ) ; return ; } } }
","<S2SV_ModStart> count ) { <S2SV_ModEnd> zend_throw_exception ( spl_ce_OutOfRangeException
",php@php-src/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5,CVE-2016-3132,https://github.com/php/php-src/commit/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5?w=1,2016-08-07T10:59Z,<S2SV_StartBug> zval_ptr_dtor ( value ) ; <S2SV_EndBug>
1855,CWE-119,"static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const TileInfo * const tile , BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) { MACROBLOCKD * xd = & x -> e_mbd ; VP9_COMMON * cm = & cpi -> common ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; int bestsme = INT_MAX ; int further_steps , step_param ; int sadpb = x -> sadperbit16 ; MV mvp_full ; int ref = mbmi -> ref_frame [ 0 ] ; MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; int tmp_row_max = x -> mv_row_max ; const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ; MV pred_mv [ 3 ] ; pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) backup_yv12 [ i ] = xd -> plane [ i ] . pre [ 0 ] ; vp9_setup_pre_planes ( xd , 0 , scaled_ref_frame , mi_row , mi_col , NULL ) ; } vp9_set_mv_search_range ( x , & ref_mv ) ; if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) { step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) + cpi -> mv_step_param ) >> 1 ; } else { step_param = cpi -> mv_step_param ; } if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 && cpi -> common . show_frame ) { int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) , b_width_log2 ( bsize ) ) ) ; step_param = MAX ( step_param , boffset ) ; } if ( cpi -> sf . adaptive_motion_search ) { int bwl = b_width_log2_lookup [ bsize ] ; int bhl = b_height_log2_lookup [ bsize ] ; int i ; int tlevel = x -> pred_mv_sad [ ref ] >> ( bwl + bhl + 4 ) ; if ( tlevel < 5 ) step_param += 2 ; for ( i = LAST_FRAME ; i <= ALTREF_FRAME && cpi -> common . show_frame ; ++ i ) { if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) { x -> pred_mv [ ref ] . as_int = 0 ; tmp_mv -> as_int = INVALID_MV ; if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } return ; } } } mvp_full = pred_mv [ x -> mv_best_ref_index [ ref ] ] ; mvp_full . col >>= 3 ; mvp_full . row >>= 3 ; further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; if ( cpi -> sf . search_method == FAST_DIAMOND ) { bestsme = vp9_fast_dia_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == FAST_HEX ) { bestsme = vp9_fast_hex_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == HEX ) { bestsme = vp9_hex_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == SQUARE ) { bestsme = vp9_square_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == BIGDIA ) { bestsme = vp9_bigdia_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else { bestsme = vp9_full_pixel_diamond ( cpi , x , & mvp_full , step_param , sadpb , further_steps , 1 , & cpi -> fn_ptr [ bsize ] , & ref_mv , & tmp_mv -> as_mv ) ; } x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . subpel_force_stop , cpi -> sf . subpel_iters_per_step , x -> nmvjointcost , x -> mvcost , & dis , & x -> pred_sse [ ref ] ) ; } * rate_mv = vp9_mv_bit_cost ( & tmp_mv -> as_mv , & ref_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ; if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } }
","<S2SV_ModStart> * x , <S2SV_ModEnd> BLOCK_SIZE bsize , <S2SV_ModStart> -> e_mbd ; const <S2SV_ModStart> { { 0 , 0 <S2SV_ModStart> INT_MAX ; int <S2SV_ModEnd> step_param ; int <S2SV_ModStart> MV ref_mv = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> x -> mv_row_max ; int cost_list [ 5 ] <S2SV_ModStart> 0 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> 1 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> [ ref ] <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> sf . mv . auto_mv_step_size && cm -> <S2SV_ModEnd> show_frame ) { <S2SV_ModStart> ( vp9_init_search_range ( <S2SV_ModEnd> x -> max_mv_context <S2SV_ModStart> -> mv_step_param ) / 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> bsize < BLOCK_64X64 <S2SV_ModEnd> ) { int <S2SV_ModStart> 2 * ( b_width_log2_lookup [ BLOCK_64X64 ] <S2SV_ModEnd> - MIN ( <S2SV_ModStart> - MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ) ) ; <S2SV_ModStart> [ bsize ] <S2SV_ModEnd> ; int tlevel <S2SV_ModStart> += 2 ; if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { int i ; <S2SV_ModStart> <= ALTREF_FRAME && cm -> <S2SV_ModEnd> show_frame ; ++ <S2SV_ModStart> ref ] . row = 0 ; x -> pred_mv [ ref ] . col <S2SV_ModEnd> = 0 ; <S2SV_ModStart> < MAX_MB_PLANE ; ++ i <S2SV_ModEnd> ) xd -> <S2SV_ModStart> } return ; } <S2SV_ModStart> >>= 3 ; bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max <S2SV_ModEnd> ; if ( <S2SV_ModStart> < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step <S2SV_ModEnd> ( x , <S2SV_ModStart> & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , <S2SV_ModStart> bsize ] , <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> -> sf . mv . subpel_force_stop , <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis <S2SV_ModEnd> , & x <S2SV_ModStart> [ ref ] , NULL , 0 , 0 <S2SV_ModStart> sf . adaptive_motion_search <S2SV_ModEnd> ) x -> <S2SV_ModStart> [ ref ] <S2SV_ModEnd> = tmp_mv -> <S2SV_ModStart> = tmp_mv -> as_mv <S2SV_ModEnd> ; if (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; <S2SV_EndBug> <S2SV_StartBug> int further_steps , step_param ; <S2SV_EndBug> <S2SV_StartBug> MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> int tmp_row_max = x -> mv_row_max ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) { <S2SV_EndBug> <S2SV_StartBug> step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) + <S2SV_EndBug> <S2SV_StartBug> cpi -> mv_step_param ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 && <S2SV_EndBug> <S2SV_StartBug> int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) , <S2SV_EndBug> <S2SV_StartBug> int bhl = b_height_log2_lookup [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> for ( i = LAST_FRAME ; i <= ALTREF_FRAME && cpi -> common . show_frame ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; <S2SV_EndBug> <S2SV_StartBug> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , <S2SV_EndBug> <S2SV_StartBug> & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . search_method == FAST_HEX ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . search_method == HEX ) { <S2SV_EndBug> <S2SV_StartBug> & dis , & x -> pred_sse [ ref ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ; <S2SV_EndBug>"
6185,CWE-639,"int ca_validate_pubkey ( struct iked * env , struct iked_static_id * id , void * data , size_t len , struct iked_id * out ) { BIO * rawcert = NULL ; RSA * peerrsa = NULL , * localrsa = NULL ; EC_KEY * peerec = NULL ; EVP_PKEY * peerkey = NULL , * localkey = NULL ; int ret = - 1 ; FILE * fp = NULL ; char idstr [ IKED_ID_SIZE ] ; char file [ PATH_MAX ] ; struct iked_id idp ; switch ( id -> id_type ) { case IKEV2_ID_IPV4 : case IKEV2_ID_FQDN : case IKEV2_ID_UFQDN : case IKEV2_ID_IPV6 : break ; default : log_debug ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s"" , __func__ , print_map ( id -> id_type , ikev2_id_map ) ) ; return ( - 1 ) ; } bzero ( & idp , sizeof ( idp ) ) ; if ( ( idp . id_buf = ibuf_new ( id -> id_data , id -> id_length ) ) == NULL ) goto done ; idp . id_type = id -> id_type ; idp . id_offset = id -> id_offset ; if ( ikev2_print_id ( & idp , idstr , sizeof ( idstr ) ) == - 1 ) goto done ; if ( len == 0 && data ) { peerkey = ( EVP_PKEY * ) data ; } if ( len > 0 ) { if ( ( rawcert = BIO_new_mem_buf ( data , len ) ) == NULL ) goto done ; if ( ( peerkey = EVP_PKEY_new ( ) ) == NULL ) goto sslerr ; if ( ( peerrsa = d2i_RSAPublicKey_bio ( rawcert , NULL ) ) ) { if ( ! EVP_PKEY_set1_RSA ( peerkey , peerrsa ) ) { goto sslerr ; } } else if ( BIO_reset ( rawcert ) == 1 && ( peerec = d2i_EC_PUBKEY_bio ( rawcert , NULL ) ) ) { if ( ! EVP_PKEY_set1_EC_KEY ( peerkey , peerec ) ) { goto sslerr ; } } else { log_debug ( ""%s:<S2SV_blank>unknown<S2SV_blank>key<S2SV_blank>type<S2SV_blank>received"" , __func__ ) ; goto sslerr ; } } lc_idtype ( idstr ) ; if ( strlcpy ( file , IKED_PUBKEY_DIR , sizeof ( file ) ) >= sizeof ( file ) || strlcat ( file , idstr , sizeof ( file ) ) >= sizeof ( file ) ) { log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>id<S2SV_blank>too<S2SV_blank>long<S2SV_blank>%s"" , __func__ , idstr ) ; goto done ; } if ( ( fp = fopen ( file , ""r"" ) ) == NULL ) { logit ( len == 0 ? LOG_DEBUG : LOG_INFO , ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>public<S2SV_blank>key<S2SV_blank>%s"" , __func__ , file ) ; goto done ; } localkey = PEM_read_PUBKEY ( fp , NULL , NULL , NULL ) ; if ( localkey == NULL ) { rewind ( fp ) ; localrsa = PEM_read_RSAPublicKey ( fp , NULL , NULL , NULL ) ; fclose ( fp ) ; if ( localrsa == NULL ) goto sslerr ; if ( ( localkey = EVP_PKEY_new ( ) ) == NULL ) goto sslerr ; if ( ! EVP_PKEY_set1_RSA ( localkey , localrsa ) ) goto sslerr ; } else { fclose ( fp ) ; } if ( localkey == NULL ) goto sslerr ; if ( peerkey && ! EVP_PKEY_cmp ( peerkey , localkey ) ) { log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>%s"" , __func__ , file ) ; goto done ; } log_debug ( ""%s:<S2SV_blank>valid<S2SV_blank>public<S2SV_blank>key<S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s"" , __func__ , file ) ; if ( out && ca_pubkey_serialize ( localkey , out ) ) goto done ; ret = 0 ; sslerr : if ( ret != 0 ) ca_sslerror ( __func__ ) ; done : ibuf_release ( idp . id_buf ) ; if ( localkey != NULL ) EVP_PKEY_free ( localkey ) ; if ( peerrsa != NULL ) RSA_free ( peerrsa ) ; if ( peerec != NULL ) EC_KEY_free ( peerec ) ; if ( localrsa != NULL ) RSA_free ( localrsa ) ; if ( rawcert != NULL ) { BIO_free ( rawcert ) ; if ( peerkey != NULL ) EVP_PKEY_free ( peerkey ) ; } return ( ret ) ; }
","<S2SV_ModStart> ( peerkey && <S2SV_ModEnd> EVP_PKEY_cmp ( peerkey <S2SV_ModStart> , localkey ) != 1
",openbsd@src/7afb2d41c6d373cf965285840b85c45011357115,CVE-2020-16088,https://github.com/openbsd/src/commit/7afb2d41c6d373cf965285840b85c45011357115,2020-07-28T12:15Z,"<S2SV_StartBug> if ( peerkey && ! EVP_PKEY_cmp ( peerkey , localkey ) ) { <S2SV_EndBug>"
7874,CWE-20,"error_t enc624j600UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint16_t hashTable [ 4 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""Updating<S2SV_blank>MAC<S2SV_blank>filter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = enc624j600CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 23 ) & 0x3F ; hashTable [ k / 16 ] |= ( 1 << ( k % 16 ) ) ; } } enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , hashTable [ 1 ] ) ; enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ; enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ; return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> ) ) ;
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ; <S2SV_EndBug>"
2883,CWE-426,"static void set_own_dir ( const char * argv0 ) { size_t l = strlen ( argv0 ) ; while ( l && argv0 [ l - 1 ] != '/' ) l -- ; if ( l == 0 ) memcpy ( own_dir , ""."" , 2 ) ; else { memcpy ( own_dir , argv0 , l - 1 ) ; own_dir [ l ] = 0 ; } }
","<S2SV_ModStart> == 0 ) # ifdef SUPER_SECURE memcpy ( own_dir , ""/dev/null/"" , 2 ) ; # else <S2SV_ModStart> 2 ) ; # endif
",rofl0r@proxychains-ng/9ab7dbeb3baff67a51d0c5e71465c453be0890b5,CVE-2015-3887,https://github.com/rofl0r/proxychains-ng/commit/9ab7dbeb3baff67a51d0c5e71465c453be0890b5#diff-803c5170888b8642f2a97e5e9423d399,2017-09-21T16:29Z,"<S2SV_StartBug> memcpy ( own_dir , ""."" , 2 ) ; <S2SV_EndBug>"
6524,CWE-119,"cJSON * cJSON_CreateFloatArray ( double * numbers , int count ) { int i ; cJSON * n = 0 , * p = 0 , * a = cJSON_CreateArray ( ) ; for ( i = 0 ; a && i < count ; ++ i ) { n = cJSON_CreateFloat ( numbers [ i ] ) ; if ( ! i ) a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }
","<S2SV_ModStart> * cJSON_CreateFloatArray ( const float <S2SV_ModEnd> * numbers , <S2SV_ModStart> < count ; i ++ <S2SV_ModEnd> ) { n <S2SV_ModStart> { n = cJSON_CreateNumber <S2SV_ModEnd> ( numbers [ <S2SV_ModStart> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,"<S2SV_StartBug> cJSON * cJSON_CreateFloatArray ( double * numbers , int count ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> n = cJSON_CreateFloat ( numbers [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug>"
