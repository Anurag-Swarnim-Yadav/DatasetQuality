index,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,localization_target
585,CWE-119,"static int http_buf_read ( URLContext * h , uint8_t * buf , int size ) { HTTPContext * s = h -> priv_data ; int len ; len = s -> buf_end - s -> buf_ptr ; if ( len > 0 ) { if ( len > size ) len = size ; memcpy ( buf , s -> buf_ptr , len ) ; s -> buf_ptr += len ; } else { <S2SV_StartBug> int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> target_end >= 0 && s -> off >= target_end ) return AVERROR_EOF ; len = ffurl_read ( s -> hd , buf , size ) ; <S2SV_StartBug> if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> target_end >= 0 && s -> off < target_end ) { av_log ( h , AV_LOG_ERROR , <S2SV_StartBug> ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRId64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRId64 ""\\n"" , <S2SV_EndBug> s -> off , target_end ) ; return AVERROR ( EIO ) ; } } if ( len > 0 ) { s -> off += len ; if ( s -> chunksize > 0 ) s -> chunksize -= len ; } return len ; }
","<S2SV_ModStart> } else { uint64_t <S2SV_ModEnd> target_end = s <S2SV_ModStart> s -> chunksize == UINT64_MAX ) <S2SV_ModEnd> && s -> <S2SV_ModStart> s -> chunksize == UINT64_MAX ) && s -> off < <S2SV_ModEnd> target_end ) { <S2SV_ModStart> AV_LOG_ERROR , ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRIu64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRIu64 <S2SV_ModEnd> ""\\n"" , s
",FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa,CVE-2016-10190,https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa,2017-02-09T15:59Z,"<S2SV_StartBug> int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> <S2SV_StartBug> if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> <S2SV_StartBug> ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRId64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRId64 ""\\n"" , <S2SV_EndBug>"
7632,CWE-190,"jpc_streamlist_t * jpc_ppmstabtostreams ( jpc_ppxstab_t * tab ) { jpc_streamlist_t * streams ; <S2SV_StartBug> uchar * dataptr ; <S2SV_EndBug> uint_fast32_t datacnt ; uint_fast32_t tpcnt ; jpc_ppxstabent_t * ent ; int entno ; jas_stream_t * stream ; int n ; if ( ! ( streams = jpc_streamlist_create ( ) ) ) { goto error ; } if ( ! tab -> numents ) { return streams ; } entno = 0 ; ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; for ( ; ; ) { if ( datacnt < 4 ) { goto error ; } if ( ! ( stream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jpc_streamlist_insert ( streams , jpc_streamlist_numstreams ( streams ) , stream ) ) { goto error ; } tpcnt = ( dataptr [ 0 ] << 24 ) | ( dataptr [ 1 ] << 16 ) | ( dataptr [ 2 ] << 8 ) | dataptr [ 3 ] ; datacnt -= 4 ; dataptr += 4 ; while ( tpcnt ) { if ( ! datacnt ) { if ( ++ entno >= tab -> numents ) { goto error ; } ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; } n = JAS_MIN ( tpcnt , datacnt ) ; if ( jas_stream_write ( stream , dataptr , n ) != n ) { goto error ; } tpcnt -= n ; dataptr += n ; datacnt -= n ; } jas_stream_rewind ( stream ) ; if ( ! datacnt ) { if ( ++ entno >= tab -> numents ) { break ; } ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; } } return streams ; error : if ( streams ) { jpc_streamlist_destroy ( streams ) ; } return 0 ; }
","<S2SV_ModStart> * streams ; jas_uchar <S2SV_ModEnd> * dataptr ;
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> uchar * dataptr ; <S2SV_EndBug>
568,CWE-59,"static int mountpoint_last ( struct nameidata * nd , struct path * path ) { int error = 0 ; struct dentry * dentry ; struct dentry * dir = nd -> path . dentry ; if ( nd -> flags & LOOKUP_RCU ) { if ( unlazy_walk ( nd , NULL ) ) { error = - ECHILD ; goto out ; } } nd -> flags &= ~ LOOKUP_PARENT ; if ( unlikely ( nd -> last_type != LAST_NORM ) ) { error = handle_dots ( nd , nd -> last_type ) ; if ( error ) goto out ; dentry = dget ( nd -> path . dentry ) ; goto done ; } mutex_lock ( & dir -> d_inode -> i_mutex ) ; dentry = d_lookup ( dir , & nd -> last ) ; if ( ! dentry ) { dentry = d_alloc ( dir , & nd -> last ) ; if ( ! dentry ) { error = - ENOMEM ; mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } dentry = lookup_real ( dir -> d_inode , dentry , nd -> flags ) ; error = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) { mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } } mutex_unlock ( & dir -> d_inode -> i_mutex ) ; done : if ( ! dentry -> d_inode || d_is_negative ( dentry ) ) { error = - ENOENT ; dput ( dentry ) ; goto out ; } path -> dentry = dentry ; <S2SV_StartBug> path -> mnt = mntget ( nd -> path . mnt ) ; <S2SV_EndBug> if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ; <S2SV_StartBug> follow_mount ( path ) ; <S2SV_EndBug> error = 0 ; out : terminate_walk ( nd ) ; return error ; }
","<S2SV_ModStart> -> mnt = <S2SV_ModEnd> nd -> path <S2SV_ModStart> path . mnt <S2SV_ModEnd> ; if ( <S2SV_ModStart> return 1 ; mntget ( path -> mnt ) ;
",torvalds@linux/295dc39d941dc2ae53d5c170365af4c9d5c16212,CVE-2014-5045,https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212,2014-08-01T11:13Z,<S2SV_StartBug> path -> mnt = mntget ( nd -> path . mnt ) ; <S2SV_EndBug> <S2SV_StartBug> follow_mount ( path ) ; <S2SV_EndBug>
8359,CWE-362,"static struct rtable * icmp_route_lookup ( struct net * net , struct sk_buff * skb_in , const struct iphdr * iph , __be32 saddr , u8 tos , int type , int code , struct icmp_bxm * param ) { struct flowi4 fl4 = { <S2SV_StartBug> . daddr = ( param -> replyopts . srr ? <S2SV_EndBug> <S2SV_StartBug> param -> replyopts . faddr : iph -> saddr ) , <S2SV_EndBug> . saddr = saddr , . flowi4_tos = RT_TOS ( tos ) , . flowi4_proto = IPPROTO_ICMP , . fl4_icmp_type = type , . fl4_icmp_code = code , } ; struct rtable * rt , * rt2 ; int err ; security_skb_classify_flow ( skb_in , flowi4_to_flowi ( & fl4 ) ) ; rt = __ip_route_output_key ( net , & fl4 ) ; if ( IS_ERR ( rt ) ) return rt ; rt2 = rt ; if ( ! fl4 . saddr ) fl4 . saddr = rt -> rt_src ; rt = ( struct rtable * ) xfrm_lookup ( net , & rt -> dst , flowi4_to_flowi ( & fl4 ) , NULL , 0 ) ; if ( ! IS_ERR ( rt ) ) { if ( rt != rt2 ) return rt ; } else if ( PTR_ERR ( rt ) == - EPERM ) { rt = NULL ; } else return rt ; err = xfrm_decode_session_reverse ( skb_in , flowi4_to_flowi ( & fl4 ) , AF_INET ) ; if ( err ) goto relookup_failed ; if ( inet_addr_type ( net , fl4 . saddr ) == RTN_LOCAL ) { rt2 = __ip_route_output_key ( net , & fl4 ) ; if ( IS_ERR ( rt2 ) ) err = PTR_ERR ( rt2 ) ; } else { struct flowi4 fl4_2 = { } ; unsigned long orefdst ; fl4_2 . daddr = fl4 . saddr ; rt2 = ip_route_output_key ( net , & fl4_2 ) ; if ( IS_ERR ( rt2 ) ) { err = PTR_ERR ( rt2 ) ; goto relookup_failed ; } orefdst = skb_in -> _skb_refdst ; err = ip_route_input ( skb_in , fl4 . daddr , fl4 . saddr , RT_TOS ( tos ) , rt2 -> dst . dev ) ; dst_release ( & rt2 -> dst ) ; rt2 = skb_rtable ( skb_in ) ; skb_in -> _skb_refdst = orefdst ; } if ( err ) goto relookup_failed ; rt2 = ( struct rtable * ) xfrm_lookup ( net , & rt2 -> dst , flowi4_to_flowi ( & fl4 ) , NULL , XFRM_LOOKUP_ICMP ) ; if ( ! IS_ERR ( rt2 ) ) { dst_release ( & rt -> dst ) ; rt = rt2 ; } else if ( PTR_ERR ( rt2 ) == - EPERM ) { if ( rt ) dst_release ( & rt -> dst ) ; return rt2 ; } else { err = PTR_ERR ( rt2 ) ; goto relookup_failed ; } return rt ; relookup_failed : if ( rt ) return rt ; return ERR_PTR ( err ) ; }
","<S2SV_ModStart> -> replyopts . opt . opt . <S2SV_ModStart> param -> replyopts . opt . opt
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,"<S2SV_StartBug> . daddr = ( param -> replyopts . srr ? <S2SV_EndBug> <S2SV_StartBug> param -> replyopts . faddr : iph -> saddr ) , <S2SV_EndBug>"
6344,CWE-772,"generic_ret * init_2_svc ( krb5_ui_4 * arg , struct svc_req * rqstp ) { static generic_ret ret ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; kadm5_server_handle_t handle ; OM_uint32 minor_stat ; const char * errmsg = NULL ; size_t clen , slen ; char * cdots , * sdots ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( * arg , rqstp , & handle ) ) ) goto exit_func ; if ( ! ( ret . code = check_handle ( ( void * ) handle ) ) ) { ret . api_version = handle -> api_version ; } free_server_handle ( handle ) ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( ret . code != 0 ) errmsg = krb5_get_error_message ( NULL , ret . code ) ; clen = client_name . length ; trunc_name ( & clen , & cdots ) ; slen = service_name . length ; trunc_name ( & slen , & sdots ) ; krb5_klog_syslog ( LOG_NOTICE , _ ( ""Request:<S2SV_blank>kadm5_init,<S2SV_blank>%.*s%s,<S2SV_blank>%s,<S2SV_blank>"" ""client=%.*s%s,<S2SV_blank>service=%.*s%s,<S2SV_blank>addr=%s,<S2SV_blank>"" ""vers=%d,<S2SV_blank>flavor=%d"" ) , ( int ) clen , ( char * ) client_name . value , cdots , errmsg ? errmsg : _ ( ""success"" ) , ( int ) clen , ( char * ) client_name . value , cdots , ( int ) slen , ( char * ) service_name . value , sdots , client_addr ( rqstp -> rq_xprt ) , ret . api_version & ~ ( KADM5_API_VERSION_MASK ) , rqstp -> rq_cred . oa_flavor ) ; if ( errmsg != NULL ) krb5_free_error_message ( NULL , errmsg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : return ( & ret ) ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; kadm5_server_handle_t handle <S2SV_ModStart> errmsg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> return ( &
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug>"
438,CWE-416,"int ppp_register_net_channel ( struct net * net , struct ppp_channel * chan ) { struct channel * pch ; struct ppp_net * pn ; pch = kzalloc ( sizeof ( struct channel ) , GFP_KERNEL ) ; if ( ! pch ) return - ENOMEM ; pn = ppp_pernet ( net ) ; pch -> ppp = NULL ; pch -> chan = chan ; <S2SV_StartBug> pch -> chan_net = net ; <S2SV_EndBug> chan -> ppp = pch ; init_ppp_file ( & pch -> file , CHANNEL ) ; pch -> file . hdrlen = chan -> hdrlen ; # ifdef CONFIG_PPP_MULTILINK pch -> lastseq = - 1 ; # endif init_rwsem ( & pch -> chan_sem ) ; spin_lock_init ( & pch -> downl ) ; rwlock_init ( & pch -> upl ) ; spin_lock_bh ( & pn -> all_channels_lock ) ; pch -> file . index = ++ pn -> last_channel_index ; list_add ( & pch -> list , & pn -> new_channels ) ; atomic_inc ( & channel_count ) ; spin_unlock_bh ( & pn -> all_channels_lock ) ; return 0 ; }
","<S2SV_ModStart> -> chan_net = get_net ( net ) <S2SV_ModEnd> ; chan ->
",torvalds@linux/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,CVE-2016-4805,https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,2016-05-23T10:59Z,<S2SV_StartBug> pch -> chan_net = net ; <S2SV_EndBug>
2617,CWE-834,"static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox ""BoundingBox:"" # define BeginDocument ""BeginDocument:"" # define BeginXMPPacket ""<?xpacket<S2SV_blank>begin="" # define EndXMPPacket ""<?xpacket<S2SV_blank>end="" # define ICCProfile ""BeginICCProfile:"" # define CMYKCustomColor ""CMYKCustomColor:"" # define CMYKProcessColor ""CMYKProcessColor:"" # define DocumentMedia ""DocumentMedia:"" # define DocumentCustomColors ""DocumentCustomColors:"" # define DocumentProcessColors ""DocumentProcessColors:"" # define EndDocument ""EndDocument:"" # define HiResBoundingBox ""HiResBoundingBox:"" # define ImageData ""ImageData:"" # define PageBoundingBox ""PageBoundingBox:"" # define LanguageLevel ""LanguageLevel:"" # define PageMedia ""PageMedia:"" # define Pages ""Pages:"" # define PhotoshopProfile ""BeginPhotoshop:"" # define PostscriptLevel ""!PS-"" # define RenderPostscriptText ""<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>"" # define SpotColor ""+<S2SV_blank>"" char command [ MaxTextExtent ] , * density , filename [ MaxTextExtent ] , geometry [ MaxTextExtent ] , input_filename [ MaxTextExtent ] , message [ MaxTextExtent ] , * options , postscript_filename [ MaxTextExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length , priority ; ssize_t count ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> x_resolution == 0.0 ) || ( image -> y_resolution == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution . x = image -> x_resolution ; resolution . y = image -> y_resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) ResetMagickMemory ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) ResetMagickMemory ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) ResetMagickMemory ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; priority = 0 ; columns = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; skip = MagickFalse ; pages = ( ~ 0UL ) ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , ""ps:Level"" , command + 4 ) ; if ( GlobExpression ( command , ""*EPSF-*"" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel ""<S2SV_blank>%lu"" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages ""<S2SV_blank>%lu"" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData ""<S2SV_blank>%lu<S2SV_blank>%lu"" , & columns , & rows ) ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MaxTextExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , ""icc"" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * p ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile ""<S2SV_blank>%lu"" , & extent ) ; if ( count != 1 ) continue ; <S2SV_StartBug> length = extent ; <S2SV_EndBug> profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * p ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , ""8bim"" , profile ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { register size_t i ; p = command ; profile = StringToStringInfo ( command ) ; for ( i = GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , i + 1 ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , i ) ; ( void ) SetImageProfile ( image , ""xmp"" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , ""*Cyan*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Magenta*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Yellow*"" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MaxTextExtent ] , * value ; register char * p ; ( void ) FormatLocaleString ( property , MaxTextExtent , ""ps:SpotColor-%.20g"" , ( double ) ( spotcolor ++ ) ) ; for ( p = command ; * p != '\\0' ; p ++ ) if ( isspace ( ( int ) ( unsigned char ) * p ) != 0 ) break ; value = AcquireString ( p ) ; ( void ) SubstituteString ( & value , ""("" , """" ) ; ( void ) SubstituteString ( & value , "")"" , """" ) ; ( void ) StripString ( value ) ; ( void ) SetImageProperty ( image , property , value ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%gx%g%+.15g%+.15g"" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , ""ps:HiResBoundingBox"" , geometry ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , ""eps:fit-page"" ) ; if ( option != ( char * ) NULL ) { char * geometry ; MagickStatusType flags ; geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\'"" , option ) ; image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> x_resolution / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> y_resolution / delta . y ) - 0.5 ) ; geometry = DestroyString ( geometry ) ; fitPage = MagickTrue ; } ( void ) CloseBlob ( image ) ; if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( & image -> exception , FileOpenError , ""UnableToOpenFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , ""/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{"" ""dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\n"" ""<</UseCIEColor<S2SV_blank>true>>setpagedevice\\n"" , MaxTextExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MaxTextExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MaxTextExtent , ""%g<S2SV_blank>%g<S2SV_blank>translate\\n"" , - hires_bounds . x1 , - hires_bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:mono"" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:cmyk"" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( ""ps:alpha"" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( """" ) ; options = AcquireString ( """" ) ; ( void ) FormatLocaleString ( density , MaxTextExtent , ""%gx%g"" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MaxTextExtent , ""-g%.20gx%.20g<S2SV_blank>"" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pages , MaxTextExtent , ""-dFirstPage=%.20g<S2SV_blank>"" ""-dLastPage=%.20g<S2SV_blank>"" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MaxTextExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , ""eps:use-cropbox"" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , ""-dEPSCrop<S2SV_blank>"" , MaxTextExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , ""-dEPSFitPage<S2SV_blank>"" , MaxTextExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MaxTextExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , ""%d"" , MaxTextExtent ) ; ( void ) FormatLocaleString ( command , MaxTextExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , ""<S2SV_blank>-c<S2SV_blank>showpage"" , MaxTextExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , ""PostscriptDelegateFailed"" , ""`%s\'"" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , ""BMP"" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } if ( image_info -> number_scenes != 0 ) { Image * clone_image ; register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MaxTextExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MaxTextExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }
","<S2SV_ModStart> length = extent ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" )
",ImageMagick@ImageMagick/8598a497e2d1f556a34458cf54b40ba40674734c,CVE-2017-14172,https://github.com/ImageMagick/ImageMagick/commit/8598a497e2d1f556a34458cf54b40ba40674734c,2017-09-07T06:29Z,<S2SV_StartBug> length = extent ; <S2SV_EndBug>
137,CWE-000,"int snd_usbmidi_create ( struct snd_card * card , struct usb_interface * iface , struct list_head * midi_list , const struct snd_usb_audio_quirk * quirk ) { struct snd_usb_midi * umidi ; struct snd_usb_midi_endpoint_info endpoints [ MIDI_MAX_ENDPOINTS ] ; int out_ports , in_ports ; int i , err ; umidi = kzalloc ( sizeof ( * umidi ) , GFP_KERNEL ) ; if ( ! umidi ) return - ENOMEM ; umidi -> dev = interface_to_usbdev ( iface ) ; umidi -> card = card ; umidi -> iface = iface ; umidi -> quirk = quirk ; umidi -> usb_protocol_ops = & snd_usbmidi_standard_ops ; spin_lock_init ( & umidi -> disc_lock ) ; init_rwsem ( & umidi -> disc_rwsem ) ; mutex_init ( & umidi -> mutex ) ; umidi -> usb_id = USB_ID ( le16_to_cpu ( umidi -> dev -> descriptor . idVendor ) , le16_to_cpu ( umidi -> dev -> descriptor . idProduct ) ) ; setup_timer ( & umidi -> error_timer , snd_usbmidi_error_timer , ( unsigned long ) umidi ) ; memset ( endpoints , 0 , sizeof ( endpoints ) ) ; switch ( quirk ? quirk -> type : QUIRK_MIDI_STANDARD_INTERFACE ) { case QUIRK_MIDI_STANDARD_INTERFACE : err = snd_usbmidi_get_ms_info ( umidi , endpoints ) ; if ( umidi -> usb_id == USB_ID ( 0x0763 , 0x0150 ) ) umidi -> usb_protocol_ops = & snd_usbmidi_maudio_broken_running_status_ops ; break ; case QUIRK_MIDI_US122L : umidi -> usb_protocol_ops = & snd_usbmidi_122l_ops ; case QUIRK_MIDI_FIXED_ENDPOINT : memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; break ; case QUIRK_MIDI_YAMAHA : err = snd_usbmidi_detect_yamaha ( umidi , & endpoints [ 0 ] ) ; break ; case QUIRK_MIDI_ROLAND : err = snd_usbmidi_detect_roland ( umidi , & endpoints [ 0 ] ) ; break ; case QUIRK_MIDI_MIDIMAN : umidi -> usb_protocol_ops = & snd_usbmidi_midiman_ops ; memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = 0 ; break ; case QUIRK_MIDI_NOVATION : umidi -> usb_protocol_ops = & snd_usbmidi_novation_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_RAW_BYTES : umidi -> usb_protocol_ops = & snd_usbmidi_raw_ops ; if ( umidi -> usb_id == USB_ID ( 0x07fd , 0x0001 ) ) usb_set_interface ( umidi -> dev , 0 , 0 ) ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_EMAGIC : umidi -> usb_protocol_ops = & snd_usbmidi_emagic_ops ; memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; break ; case QUIRK_MIDI_CME : umidi -> usb_protocol_ops = & snd_usbmidi_cme_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_AKAI : umidi -> usb_protocol_ops = & snd_usbmidi_akai_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; endpoints [ 1 ] . out_cables = 0 ; break ; case QUIRK_MIDI_FTDI : umidi -> usb_protocol_ops = & snd_usbmidi_ftdi_ops ; err = usb_control_msg ( umidi -> dev , usb_sndctrlpipe ( umidi -> dev , 0 ) , 3 , 0x40 , 0x60 , 0 , NULL , 0 , 1000 ) ; if ( err < 0 ) break ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_CH345 : umidi -> usb_protocol_ops = & snd_usbmidi_ch345_broken_sysex_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; default : dev_err ( & umidi -> dev -> dev , ""invalid<S2SV_blank>quirk<S2SV_blank>type<S2SV_blank>%d\\n"" , quirk -> type ) ; err = - ENXIO ; break ; } if ( err < 0 ) { kfree ( umidi ) ; return err ; } out_ports = 0 ; in_ports = 0 ; for ( i = 0 ; i < MIDI_MAX_ENDPOINTS ; ++ i ) { out_ports += hweight16 ( endpoints [ i ] . out_cables ) ; in_ports += hweight16 ( endpoints [ i ] . in_cables ) ; } err = snd_usbmidi_create_rawmidi ( umidi , out_ports , in_ports ) ; if ( err < 0 ) { kfree ( umidi ) ; return err ; } if ( quirk && quirk -> type == QUIRK_MIDI_MIDIMAN ) err = snd_usbmidi_create_endpoints_midiman ( umidi , & endpoints [ 0 ] ) ; else err = snd_usbmidi_create_endpoints ( umidi , endpoints ) ; if ( err < 0 ) { <S2SV_StartBug> snd_usbmidi_free ( umidi ) ; <S2SV_EndBug> return err ; } usb_autopm_get_interface_no_resume ( umidi -> iface ) ; list_add_tail ( & umidi -> list , midi_list ) ; return 0 ; }
","<S2SV_ModStart> 0 ) { <S2SV_ModEnd> return err ;
",torvalds@linux/07d86ca93db7e5cdf4743564d98292042ec21af7,CVE-2016-2384,https://github.com/torvalds/linux/commit/07d86ca93db7e5cdf4743564d98292042ec21af7,2016-04-27T17:59Z,<S2SV_StartBug> snd_usbmidi_free ( umidi ) ; <S2SV_EndBug>
4646,CWE-190,"<S2SV_StartBug> int mongo_env_read_socket ( mongo * conn , void * buf , int len ) { <S2SV_EndBug> char * cbuf = buf ; while ( len ) { <S2SV_StartBug> int sent = recv ( conn -> sock , cbuf , len , 0 ) ; <S2SV_EndBug> if ( sent == 0 || sent == - 1 ) { __mongo_set_error ( conn , MONGO_IO_ERROR , strerror ( errno ) , errno ) ; return MONGO_ERROR ; } cbuf += sent ; len -= sent ; } return MONGO_OK ; }
","<S2SV_ModStart> * buf , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> len ) { size_t <S2SV_ModEnd> sent = recv
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,"<S2SV_StartBug> int mongo_env_read_socket ( mongo * conn , void * buf , int len ) { <S2SV_EndBug> <S2SV_StartBug> int sent = recv ( conn -> sock , cbuf , len , 0 ) ; <S2SV_EndBug>"
236,CWE-125,"int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) { char obj_txt [ 128 ] ; <S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug> BIO_write ( bio , ""\\n"" , 1 ) ; return 1 ; }
","<S2SV_ModStart> 128 ] ; <S2SV_ModEnd> OBJ_obj2txt ( obj_txt <S2SV_ModStart> 0 ) ; BIO_printf <S2SV_ModEnd> ( bio , <S2SV_ModStart> ( bio , ""%s\\n"" , obj_txt <S2SV_ModEnd> ) ; return
",openssl@openssl/0ed26acce328ec16a3aa635f1ca37365e8c7403a,CVE-2016-2180,https://github.com/openssl/openssl/commit/0ed26acce328ec16a3aa635f1ca37365e8c7403a,2016-08-01T02:59Z,"<S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug>"
1738,CWE-119,"static void encode_block_pass1 ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { MACROBLOCK * const x = ( MACROBLOCK * ) arg ; MACROBLOCKD * const xd = & x -> e_mbd ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> int i , j ; uint8_t * dst ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; dst = & pd -> dst . buf [ 4 * j * pd -> dst . stride + 4 * i ] ; vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; if ( p -> eobs [ block ] > 0 ) <S2SV_StartBug> xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> }
","<S2SV_ModStart> plane ] ; tran_low_t <S2SV_ModEnd> * const dqcoeff <S2SV_ModStart> > 0 ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ; return ; } # endif x <S2SV_ModEnd> -> itxm_add ( <S2SV_ModStart> ] ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug>"
5,CWE-362,"struct request * blk_mq_tag_to_rq ( struct blk_mq_tags * tags , unsigned int tag ) { <S2SV_StartBug> struct request * rq = tags -> rqs [ tag ] ; <S2SV_EndBug> <S2SV_StartBug> struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ; <S2SV_EndBug> if ( ! is_flush_request ( rq , fq , tag ) ) return rq ; return fq -> flush_rq ; }
","<S2SV_ModStart> tag ) { return <S2SV_ModEnd> tags -> rqs <S2SV_ModStart> tag ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z,"<S2SV_StartBug> struct request * rq = tags -> rqs [ tag ] ; <S2SV_EndBug> <S2SV_StartBug> struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ; <S2SV_EndBug>"
7183,CWE-552,"static ssize_t _hostsock_recvmsg ( oe_fd_t * sock_ , struct oe_msghdr * msg , int flags ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_errno = 0 ; void * buf = NULL ; <S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> if ( ! sock || ! msg || ( msg -> msg_iovlen && ! msg -> msg_iov ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_StartBug> { <S2SV_EndBug> if ( oe_syscall_recvmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen , <S2SV_StartBug> & msg -> msg_namelen , <S2SV_EndBug> buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen , <S2SV_StartBug> & msg -> msg_controllen , <S2SV_EndBug> flags ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret == - 1 ) OE_RAISE_ERRNO ( oe_errno ) ; } <S2SV_StartBug> if ( oe_iov_sync ( msg -> msg_iov , ( int ) msg -> msg_iovlen , buf , buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; done : if ( buf ) oe_free ( buf ) ; return ret ; }
","<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size = 0 ; oe_socklen_t namelen_out = 0 ; size_t controllen_out <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_ModStart> msg_namelen , & namelen_out <S2SV_ModEnd> , buf , <S2SV_ModStart> msg_controllen , & controllen_out <S2SV_ModEnd> , flags ) <S2SV_ModStart> } if ( ! msg -> msg_name ) msg -> msg_namelen = 0 ; else { if ( namelen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( msg -> msg_namelen >= namelen_out ) msg -> msg_namelen = namelen_out ; } if ( ! msg -> msg_control ) msg -> msg_controllen = 0 ; else { if ( msg -> msg_controllen >= controllen_out ) msg -> msg_controllen = controllen_out ; else msg -> msg_flags |= OE_MSG_CTRUNC ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if (
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,"<S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> & msg -> msg_namelen , <S2SV_EndBug> <S2SV_StartBug> & msg -> msg_controllen , <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_sync ( msg -> msg_iov , ( int ) msg -> msg_iovlen , buf , buf_size ) != 0 ) <S2SV_EndBug>"
1901,CWE-119,"<S2SV_StartBug> static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree , <S2SV_EndBug> <S2SV_StartBug> int16_t extra , uint8_t token , <S2SV_EndBug> uint8_t skip_eob_node , unsigned int * counts ) { ( * t ) -> token = token ; ( * t ) -> extra = extra ; ( * t ) -> context_tree = context_tree ; ( * t ) -> skip_eob_node = skip_eob_node ; ( * t ) ++ ; ++ counts [ token ] ; }
","<S2SV_ModStart> t , const vpx_prob <S2SV_ModEnd> * context_tree , <S2SV_ModStart> * context_tree , int32_t <S2SV_ModEnd> extra , uint8_t
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree , <S2SV_EndBug> <S2SV_StartBug> int16_t extra , uint8_t token , <S2SV_EndBug>"
510,CWE-125,"static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_UDP_TUNNEL | SKB_GSO_UDP_TUNNEL_CSUM ) ) segs = skb_udp_tunnel_segment ( skb , features , true ) ; else { const struct ipv6hdr * ipv6h ; struct udphdr * uh ; if ( ! pskb_may_pull ( skb , sizeof ( struct udphdr ) ) ) goto out ; uh = udp_hdr ( skb ) ; ipv6h = ipv6_hdr ( skb ) ; uh -> check = 0 ; csum = skb_checksum ( skb , 0 , skb -> len , 0 ) ; uh -> check = udp_v6_check ( skb -> len , & ipv6h -> saddr , & ipv6h -> daddr , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; skb -> ip_summed = CHECKSUM_NONE ; if ( ! skb -> encap_hdr_csum ) features |= NETIF_F_HW_CSUM ; tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug> * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; fptr -> identification = skb_shinfo ( skb ) -> ip6_frag_id ; segs = skb_segment ( skb , features ) ; } out : return segs ; }
","<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z,<S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug>
1180,CWE-125,"void __skb_tstamp_tx ( struct sk_buff * orig_skb , struct skb_shared_hwtstamps * hwtstamps , struct sock * sk , int tstype ) { struct sk_buff * skb ; <S2SV_StartBug> bool tsonly ; <S2SV_EndBug> if ( ! sk ) return ; tsonly = sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY ; if ( ! skb_may_tx_timestamp ( sk , tsonly ) ) return ; if ( tsonly ) { # ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP && <S2SV_StartBug> sk -> sk_type == SOCK_STREAM ) <S2SV_EndBug> skb = tcp_get_timestamping_opt_stats ( sk ) ; <S2SV_StartBug> else <S2SV_EndBug> # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ; } else { skb = skb_clone ( orig_skb , GFP_ATOMIC ) ; } if ( ! skb ) return ; if ( tsonly ) { skb_shinfo ( skb ) -> tx_flags = skb_shinfo ( orig_skb ) -> tx_flags ; skb_shinfo ( skb ) -> tskey = skb_shinfo ( orig_skb ) -> tskey ; } if ( hwtstamps ) * skb_hwtstamps ( skb ) = * hwtstamps ; else skb -> tstamp = ktime_get_real ( ) ; <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; bool tsonly , opt_stats = false <S2SV_ModStart> == SOCK_STREAM ) { <S2SV_ModStart> sk ) ; opt_stats = true ; } <S2SV_ModStart> sk , tstype , opt_stats
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,"<S2SV_StartBug> bool tsonly ; <S2SV_EndBug> <S2SV_StartBug> sk -> sk_type == SOCK_STREAM ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <S2SV_EndBug>"
1892,CWE-119,"void vp9_restore_layer_context ( VP9_COMP * const cpi ) { <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> const int old_frame_since_key = cpi -> rc . frames_since_key ; const int old_frame_to_key = cpi -> rc . frames_to_key ; cpi -> rc = lc -> rc ; cpi -> twopass = lc -> twopass ; cpi -> oxcf . target_bandwidth = lc -> target_bandwidth ; <S2SV_StartBug> cpi -> oxcf . starting_buffer_level = lc -> starting_buffer_level ; <S2SV_EndBug> cpi -> oxcf . optimal_buffer_level = lc -> optimal_buffer_level ; cpi -> oxcf . maximum_buffer_size = lc -> maximum_buffer_size ; cpi -> output_framerate = lc -> framerate ; if ( cpi -> svc . number_temporal_layers > 1 ) { cpi -> rc . frames_since_key = old_frame_since_key ; cpi -> rc . frames_to_key = old_frame_to_key ; } }
","<S2SV_ModStart> = get_layer_context ( cpi <S2SV_ModEnd> ) ; const <S2SV_ModStart> ; cpi -> alt_ref_source <S2SV_ModEnd> = lc -> <S2SV_ModStart> = lc -> alt_ref_source <S2SV_ModEnd> ; if (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> oxcf . starting_buffer_level = lc -> starting_buffer_level ; <S2SV_EndBug>
1188,CWE-264,"static struct cifsSesInfo * <S2SV_StartBug> cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username ) <S2SV_EndBug> { struct list_head * tmp ; struct cifsSesInfo * ses ; write_lock ( & cifs_tcp_ses_lock ) ; <S2SV_StartBug> list_for_each ( tmp , & server -> smb_ses_list ) { <S2SV_EndBug> ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ; <S2SV_StartBug> if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ++ ses -> ses_count ; write_unlock ( & cifs_tcp_ses_lock ) ; return ses ; } write_unlock ( & cifs_tcp_ses_lock ) ; return NULL ; }
","<S2SV_ModStart> * server , struct smb_vol * vol ) { <S2SV_ModEnd> struct cifsSesInfo * <S2SV_ModStart> cifs_tcp_ses_lock ) ; list_for_each_entry ( ses <S2SV_ModEnd> , & server <S2SV_ModStart> server -> smb_ses_list , smb_ses_list ) { switch ( server -> secType ) { case Kerberos : if ( vol -> linux_uid != ses -> linux_uid ) continue ; break ; default : <S2SV_ModEnd> if ( strncmp <S2SV_ModStart> -> userName , vol -> <S2SV_ModStart> ) continue ; if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ; }
",torvalds@linux/4ff67b720c02c36e54d55b88c2931879b7db1cd2,CVE-2011-1585,https://github.com/torvalds/linux/commit/4ff67b720c02c36e54d55b88c2931879b7db1cd2,2013-06-08T13:05Z,"<S2SV_StartBug> cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username ) <S2SV_EndBug> <S2SV_StartBug> list_for_each ( tmp , & server -> smb_ses_list ) { <S2SV_EndBug> <S2SV_StartBug> if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug>"
3871,CWE-362,"int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) { struct inode * inode = d_inode ( dentry ) ; int error , rc = 0 ; int orphan = 0 ; const unsigned int ia_valid = attr -> ia_valid ; error = inode_change_ok ( inode , attr ) ; if ( error ) return error ; if ( is_quota_modification ( inode , attr ) ) { error = dquot_initialize ( inode ) ; if ( error ) return error ; } if ( ( ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { handle_t * handle ; handle = ext4_journal_start ( inode , EXT4_HT_QUOTA , ( EXT4_MAXQUOTAS_INIT_BLOCKS ( inode -> i_sb ) + EXT4_MAXQUOTAS_DEL_BLOCKS ( inode -> i_sb ) ) + 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } error = dquot_transfer ( inode , attr ) ; if ( error ) { ext4_journal_stop ( handle ) ; return error ; } if ( attr -> ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( attr -> ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; error = ext4_mark_inode_dirty ( handle , inode ) ; ext4_journal_stop ( handle ) ; } if ( attr -> ia_valid & ATTR_SIZE ) { handle_t * handle ; loff_t oldsize = inode -> i_size ; int shrink = ( attr -> ia_size <= inode -> i_size ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { struct ext4_sb_info * sbi = EXT4_SB ( inode -> i_sb ) ; if ( attr -> ia_size > sbi -> s_bitmap_maxbytes ) return - EFBIG ; } if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( IS_I_VERSION ( inode ) && attr -> ia_size != inode -> i_size ) inode_inc_iversion ( inode ) ; if ( ext4_should_order_data ( inode ) && ( attr -> ia_size < inode -> i_size ) ) { error = ext4_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( error ) goto err_out ; } if ( attr -> ia_size != inode -> i_size ) { handle = ext4_journal_start ( inode , EXT4_HT_INODE , 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } if ( ext4_handle_valid ( handle ) && shrink ) { error = ext4_orphan_add ( handle , inode ) ; orphan = 1 ; } if ( ! shrink ) { inode -> i_mtime = ext4_current_time ( inode ) ; inode -> i_ctime = inode -> i_mtime ; } down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; EXT4_I ( inode ) -> i_disksize = attr -> ia_size ; rc = ext4_mark_inode_dirty ( handle , inode ) ; if ( ! error ) error = rc ; if ( ! error ) i_size_write ( inode , attr -> ia_size ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_journal_stop ( handle ) ; if ( error ) { if ( orphan ) ext4_orphan_del ( NULL , inode ) ; goto err_out ; } } if ( ! shrink ) pagecache_isize_extended ( inode , oldsize , inode -> i_size ) ; if ( orphan ) { if ( ! ext4_should_journal_data ( inode ) ) { ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ext4_inode_resume_unlocked_dio ( inode ) ; } else ext4_wait_for_tail_page_commit ( inode ) ; } <S2SV_StartBug> truncate_pagecache ( inode , inode -> i_size ) ; <S2SV_EndBug> if ( shrink ) <S2SV_StartBug> ext4_truncate ( inode ) ; <S2SV_EndBug> } if ( ! rc ) { setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; } if ( orphan && inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; if ( ! rc && ( ia_valid & ATTR_MODE ) ) rc = posix_acl_chmod ( inode , inode -> i_mode ) ; err_out : ext4_std_error ( inode -> i_sb , error ) ; if ( ! error ) error = rc ; return error ; }
","<S2SV_ModStart> ) ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ext4_truncate ( inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem
",torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,CVE-2015-8839,https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,2016-05-02T10:59Z,"<S2SV_StartBug> truncate_pagecache ( inode , inode -> i_size ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_truncate ( inode ) ; <S2SV_EndBug>"
3598,CWE-125,"static int decode_multicast_vpn ( netdissect_options * ndo , const u_char * pptr , char * buf , u_int buflen ) { uint8_t route_type , route_length , addr_length , sg_length ; u_int offset ; ND_TCHECK2 ( pptr [ 0 ] , 2 ) ; route_type = * pptr ++ ; route_length = * pptr ++ ; snprintf ( buf , buflen , ""Route-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_multicast_vpn_route_type_values , ""Unknown"" , route_type ) , route_type , route_length ) ; switch ( route_type ) { case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>RD:<S2SV_blank>%s,<S2SV_blank>Originator<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , pptr ) , bgp_vpn_ip_print ( ndo , pptr + BGP_VPN_RD_LEN , ( route_length - BGP_VPN_RD_LEN ) << 3 ) ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN + 4 ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>RD:<S2SV_blank>%s,<S2SV_blank>Source-AS<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , pptr ) , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + BGP_VPN_RD_LEN ) ) ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>RD:<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , pptr ) ) ; pptr += BGP_VPN_RD_LEN ; sg_length = bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ; addr_length = route_length - sg_length ; ND_TCHECK2 ( pptr [ 0 ] , addr_length ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>Originator<S2SV_blank>%s"" , bgp_vpn_ip_print ( ndo , pptr , addr_length << 3 ) ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>RD:<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , pptr ) ) ; pptr += BGP_VPN_RD_LEN ; bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN : case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN : <S2SV_StartBug> ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; <S2SV_EndBug> offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>RD:<S2SV_blank>%s,<S2SV_blank>Source-AS<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , pptr ) , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + BGP_VPN_RD_LEN ) ) ) ; <S2SV_StartBug> pptr += BGP_VPN_RD_LEN ; <S2SV_EndBug> bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF : default : break ; } return route_length + 2 ; trunc : return - 2 ; }
","<S2SV_ModStart> ] , BGP_VPN_RD_LEN + 4 <S2SV_ModStart> pptr += BGP_VPN_RD_LEN + 4
",the-tcpdump-group@tcpdump/d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514,CVE-2017-13043,https://github.com/the-tcpdump-group/tcpdump/commit/d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514,2017-09-14T06:29Z,"<S2SV_StartBug> ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> pptr += BGP_VPN_RD_LEN ; <S2SV_EndBug>"
623,CWE-125,"static const ut8 * r_bin_dwarf_parse_comp_unit ( Sdb * s , const ut8 * obuf , RBinDwarfCompUnit * cu , const RBinDwarfDebugAbbrev * da , size_t offset , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf , * buf_end = obuf + ( cu -> hdr . length - 7 ) ; ut64 abbr_code ; size_t i ; if ( cu -> hdr . length > debug_str_len ) { return NULL ; } while ( buf && buf < buf_end && buf >= obuf ) { if ( cu -> length && cu -> capacity == cu -> length ) { r_bin_dwarf_expand_cu ( cu ) ; } buf = r_uleb128 ( buf , buf_end - buf , & abbr_code ) ; if ( abbr_code > da -> length || ! buf ) { return NULL ; } r_bin_dwarf_init_die ( & cu -> dies [ cu -> length ] ) ; if ( ! abbr_code ) { cu -> dies [ cu -> length ] . abbrev_code = 0 ; cu -> length ++ ; buf ++ ; continue ; } cu -> dies [ cu -> length ] . abbrev_code = abbr_code ; cu -> dies [ cu -> length ] . tag = da -> decls [ abbr_code - 1 ] . tag ; abbr_code += offset ; if ( da -> capacity < abbr_code ) { return NULL ; } for ( i = 0 ; i < da -> decls [ abbr_code - 1 ] . length ; i ++ ) { if ( cu -> dies [ cu -> length ] . length == cu -> dies [ cu -> length ] . capacity ) { r_bin_dwarf_expand_die ( & cu -> dies [ cu -> length ] ) ; } if ( i >= cu -> dies [ cu -> length ] . capacity || i >= da -> decls [ abbr_code - 1 ] . capacity ) { eprintf ( ""Warning:<S2SV_blank>malformed<S2SV_blank>dwarf<S2SV_blank>attribute<S2SV_blank>capacity<S2SV_blank>doesn\'t<S2SV_blank>match<S2SV_blank>length\\n"" ) ; break ; } memset ( & cu -> dies [ cu -> length ] . attr_values [ i ] , 0 , sizeof ( cu -> dies [ cu -> length ] . attr_values [ i ] ) ) ; buf = r_bin_dwarf_parse_attr_value ( buf , buf_end - buf , & da -> decls [ abbr_code - 1 ] . specs [ i ] , & cu -> dies [ cu -> length ] . attr_values [ i ] , & cu -> hdr , debug_str , debug_str_len ) ; if ( cu -> dies [ cu -> length ] . attr_values [ i ] . name == DW_AT_comp_dir ) { const char * name = cu -> dies [ cu -> length ] . attr_values [ i ] . encoding . str_struct . string ; sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ; } cu -> dies [ cu -> length ] . length ++ ; } cu -> length ++ ; } return buf ; }
","
",radare@radare2/2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d,CVE-2017-16805,https://github.com/radare/radare2/commit/2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d,2017-11-13T21:29Z,
3808,CWE-787,"static int decode_frame_common ( AVCodecContext * avctx , PNGDecContext * s , AVFrame * p , AVPacket * avpkt ) { AVDictionary * metadata = NULL ; uint32_t tag , length ; int decode_next_dat = 0 ; int ret ; for ( ; ; ) { length = bytestream2_get_bytes_left ( & s -> gb ) ; if ( length <= 0 ) { if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && length == 0 ) { if ( ! ( s -> state & PNG_IDAT ) ) return 0 ; else goto exit_loop ; } av_log ( avctx , AV_LOG_ERROR , ""%d<S2SV_blank>bytes<S2SV_blank>left\\n"" , length ) ; if ( s -> state & PNG_ALLIMAGE && avctx -> strict_std_compliance <= FF_COMPLIANCE_NORMAL ) goto exit_loop ; ret = AVERROR_INVALIDDATA ; goto fail ; } length = bytestream2_get_be32 ( & s -> gb ) ; if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) ) { av_log ( avctx , AV_LOG_ERROR , ""chunk<S2SV_blank>too<S2SV_blank>big\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail ; } tag = bytestream2_get_le32 ( & s -> gb ) ; if ( avctx -> debug & FF_DEBUG_STARTCODE ) av_log ( avctx , AV_LOG_DEBUG , ""png:<S2SV_blank>tag=%c%c%c%c<S2SV_blank>length=%u\\n"" , ( tag & 0xff ) , ( ( tag >> 8 ) & 0xff ) , ( ( tag >> 16 ) & 0xff ) , ( ( tag >> 24 ) & 0xff ) , length ) ; if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : case MKTAG ( 't' , 'E' , 'X' , 't' ) : case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : case MKTAG ( 't' , 'R' , 'N' , 'S' ) : break ; default : goto skip_tag ; } } switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : if ( ( ret = decode_ihdr_chunk ( avctx , s , length ) ) < 0 ) goto fail ; break ; case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : if ( ( ret = decode_phys_chunk ( avctx , s ) ) < 0 ) goto fail ; break ; case MKTAG ( 'f' , 'c' , 'T' , 'L' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ( ret = decode_fctl_chunk ( avctx , s , length ) ) < 0 ) goto fail ; decode_next_dat = 1 ; break ; case MKTAG ( 'f' , 'd' , 'A' , 'T' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ! decode_next_dat ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_get_be32 ( & s -> gb ) ; length -= 4 ; case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ! decode_next_dat ) goto skip_tag ; if ( ( ret = decode_idat_chunk ( avctx , s , length , p ) ) < 0 ) goto fail ; break ; case MKTAG ( 'P' , 'L' , 'T' , 'E' ) : if ( decode_plte_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'R' , 'N' , 'S' ) : if ( decode_trns_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'E' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 0 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , ""Broken<S2SV_blank>tEXt<S2SV_blank>chunk\\n"" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 'z' , 'T' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 1 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , ""Broken<S2SV_blank>zTXt<S2SV_blank>chunk\\n"" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 's' , 'T' , 'E' , 'R' ) : { int mode = bytestream2_get_byte ( & s -> gb ) ; AVStereo3D * stereo3d = av_stereo3d_create_side_data ( p ) ; if ( ! stereo3d ) goto fail ; if ( mode == 0 || mode == 1 ) { stereo3d -> type = AV_STEREO3D_SIDEBYSIDE ; stereo3d -> flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT ; } else { av_log ( avctx , AV_LOG_WARNING , ""Unknown<S2SV_blank>value<S2SV_blank>in<S2SV_blank>sTER<S2SV_blank>chunk<S2SV_blank>(%d)\\n"" , mode ) ; } bytestream2_skip ( & s -> gb , 4 ) ; break ; } case MKTAG ( 'I' , 'E' , 'N' , 'D' ) : if ( ! ( s -> state & PNG_ALLIMAGE ) ) av_log ( avctx , AV_LOG_ERROR , ""IEND<S2SV_blank>without<S2SV_blank>all<S2SV_blank>image\\n"" ) ; if ( ! ( s -> state & ( PNG_ALLIMAGE | PNG_IDAT ) ) ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_skip ( & s -> gb , 4 ) ; goto exit_loop ; default : skip_tag : bytestream2_skip ( & s -> gb , length + 4 ) ; break ; } } exit_loop : if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( s -> bits_per_pixel <= 4 ) handle_small_bpp ( s , p ) ; if ( s -> has_trns && s -> color_type != PNG_COLOR_TYPE_PALETTE ) { size_t byte_depth = s -> bit_depth > 8 ? 2 : 1 ; size_t raw_bpp = s -> bpp - byte_depth ; unsigned x , y ; <S2SV_StartBug> for ( y = 0 ; y < s -> height ; ++ y ) { <S2SV_EndBug> uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ; for ( x = s -> width ; x > 0 ; -- x ) { uint8_t * pixel = & row [ s -> bpp * ( x - 1 ) ] ; memmove ( pixel , & row [ raw_bpp * ( x - 1 ) ] , raw_bpp ) ; if ( ! memcmp ( pixel , s -> transparent_color_be , raw_bpp ) ) { memset ( & pixel [ raw_bpp ] , 0 , byte_depth ) ; } else { memset ( & pixel [ raw_bpp ] , 0xff , byte_depth ) ; } } } } if ( s -> last_picture . f -> data [ 0 ] ) { if ( ! ( avpkt -> flags & AV_PKT_FLAG_KEY ) && avctx -> codec_tag != AV_RL32 ( ""MPNG"" ) && s -> last_picture . f -> width == p -> width && s -> last_picture . f -> height == p -> height && s -> last_picture . f -> format == p -> format ) { if ( CONFIG_PNG_DECODER && avctx -> codec_id != AV_CODEC_ID_APNG ) handle_p_frame_png ( s , p ) ; else if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ( ret = handle_p_frame_apng ( avctx , s , p ) ) < 0 ) goto fail ; } } ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; av_frame_set_metadata ( p , metadata ) ; metadata = NULL ; return 0 ; fail : av_dict_free ( & metadata ) ; ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; return ret ; }
","<S2SV_ModStart> , y ; av_assert0 ( s -> bit_depth > 1 ) ;
",FFmpeg@FFmpeg/e477f09d0b3619f3d29173b2cd593e17e2d1978e,CVE-2017-7863,https://github.com/FFmpeg/FFmpeg/commit/e477f09d0b3619f3d29173b2cd593e17e2d1978e,2017-04-14T04:59Z,<S2SV_StartBug> for ( y = 0 ; y < s -> height ; ++ y ) { <S2SV_EndBug>
2887,CWE-125,"static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , ""ptr"" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , ""byte"" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""word"" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""dword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""qword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""oword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""tbyte"" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , ""+-"" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }
","<S2SV_ModStart> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> = temp ; } <S2SV_ModStart> += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> = X86R_UNDEFINED ; }
",radare@radare2/9b46d38dd3c4de6048a488b655c7319f845af185,CVE-2018-20456,https://github.com/radare/radare2/commit/9b46d38dd3c4de6048a488b655c7319f845af185,2018-12-25T19:29Z,<S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug>
2542,CWE-416,"CURLcode Curl_close ( struct Curl_easy * data ) { struct Curl_multi * m ; if ( ! data ) return CURLE_OK ; Curl_expire_clear ( data ) ; m = data -> multi ; if ( m ) curl_multi_remove_handle ( data -> multi , data ) ; <S2SV_StartBug> if ( data -> multi_easy ) <S2SV_EndBug> <S2SV_StartBug> curl_multi_cleanup ( data -> multi_easy ) ; <S2SV_EndBug> Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; data -> magic = 0 ; if ( data -> state . rangestringalloc ) free ( data -> state . range ) ; Curl_free_request_state ( data ) ; Curl_ssl_close_all ( data ) ; Curl_safefree ( data -> state . first_host ) ; Curl_safefree ( data -> state . scratch ) ; Curl_ssl_free_certinfo ( data ) ; free ( data -> req . newurl ) ; data -> req . newurl = NULL ; if ( data -> change . referer_alloc ) { Curl_safefree ( data -> change . referer ) ; data -> change . referer_alloc = FALSE ; } data -> change . referer = NULL ; Curl_up_free ( data ) ; Curl_safefree ( data -> state . buffer ) ; Curl_safefree ( data -> state . headerbuff ) ; Curl_safefree ( data -> state . ulbuf ) ; Curl_flush_cookies ( data , 1 ) ; Curl_digest_cleanup ( data ) ; Curl_safefree ( data -> info . contenttype ) ; Curl_safefree ( data -> info . wouldredirect ) ; Curl_resolver_cleanup ( data -> state . resolver ) ; Curl_http2_cleanup_dependencies ( data ) ; Curl_convert_close ( data ) ; if ( data -> share ) { Curl_share_lock ( data , CURL_LOCK_DATA_SHARE , CURL_LOCK_ACCESS_SINGLE ) ; data -> share -> dirty -- ; Curl_share_unlock ( data , CURL_LOCK_DATA_SHARE ) ; } Curl_wildcard_dtor ( & data -> wildcard ) ; Curl_freeset ( data ) ; free ( data ) ; return CURLE_OK ; }
","<S2SV_ModStart> -> multi_easy ) { <S2SV_ModStart> multi_easy ) ; data -> multi_easy = NULL ; }
",curl@curl/81d135d67155c5295b1033679c606165d4e28f3f,CVE-2018-16840,https://github.com/curl/curl/commit/81d135d67155c5295b1033679c606165d4e28f3f,2018-10-31T18:29Z,<S2SV_StartBug> if ( data -> multi_easy ) <S2SV_EndBug> <S2SV_StartBug> curl_multi_cleanup ( data -> multi_easy ) ; <S2SV_EndBug>
2131,CWE-119,"SPL_METHOD ( SplObjectStorage , unserialize ) { spl_SplObjectStorage * intern = Z_SPLOBJSTORAGE_P ( getThis ( ) ) ; char * buf ; size_t buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval entry , inf ; zval * pcount , * pmembers ; spl_SplObjectStorageElement * element ; zend_long count ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s"" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; pcount = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize ( pcount , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pcount ) != IS_LONG ) { goto outexcept ; } -- p ; <S2SV_StartBug> count = Z_LVAL_P ( pcount ) ; <S2SV_EndBug> while ( count -- > 0 ) { spl_SplObjectStorageElement * pelement ; zend_string * hash ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'O' && * p != 'C' && * p != 'r' ) { goto outexcept ; } if ( ! php_var_unserialize ( & entry , & p , s + buf_len , & var_hash ) ) { goto outexcept ; } <S2SV_StartBug> if ( Z_TYPE ( entry ) != IS_OBJECT ) { <S2SV_EndBug> zval_ptr_dtor ( & entry ) ; goto outexcept ; } if ( * p == ',' ) { ++ p ; if ( ! php_var_unserialize ( & inf , & p , s + buf_len , & var_hash ) ) { zval_ptr_dtor ( & entry ) ; goto outexcept ; } <S2SV_StartBug> } else { <S2SV_EndBug> ZVAL_UNDEF ( & inf ) ; } hash = spl_object_storage_get_hash ( intern , getThis ( ) , & entry ) ; if ( ! hash ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept ; } pelement = spl_object_storage_get ( intern , hash ) ; spl_object_storage_free_hash ( intern , hash ) ; if ( pelement ) { if ( ! Z_ISUNDEF ( pelement -> inf ) ) { var_push_dtor ( & var_hash , & pelement -> inf ) ; } if ( ! Z_ISUNDEF ( pelement -> obj ) ) { var_push_dtor ( & var_hash , & pelement -> obj ) ; } } element = spl_object_storage_attach ( intern , getThis ( ) , & entry , Z_ISUNDEF ( inf ) ? NULL : & inf ) ; var_replace ( & var_hash , & entry , & element -> obj ) ; var_replace ( & var_hash , & inf , & element -> inf ) ; zval_ptr_dtor ( & entry ) ; ZVAL_UNDEF ( & entry ) ; zval_ptr_dtor ( & inf ) ; ZVAL_UNDEF ( & inf ) ; } if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' || * ++ p != ':' ) { goto outexcept ; } ++ p ; pmembers = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize ( pmembers , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pmembers ) != IS_ARRAY ) { goto outexcept ; } object_properties_load ( & intern -> std , Z_ARRVAL_P ( pmembers ) ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return ; outexcept : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 , ""Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%pd<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; return ; }
","<S2SV_ModStart> Z_LVAL_P ( pcount ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <S2SV_ModStart> } if ( <S2SV_ModEnd> * p == <S2SV_ModStart> ; } } if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <S2SV_ModEnd> ; } hash
",php@php-src/61cdd1255d5b9c8453be71aacbbf682796ac77d4,CVE-2016-7480,https://github.com/php/php-src/commit/61cdd1255d5b9c8453be71aacbbf682796ac77d4,2017-01-11T07:59Z,<S2SV_StartBug> count = Z_LVAL_P ( pcount ) ; <S2SV_EndBug> <S2SV_StartBug> if ( Z_TYPE ( entry ) != IS_OBJECT ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug>
2154,CWE-190,"static int mem_write ( jas_stream_obj_t * obj , char * buf , int cnt ) { <S2SV_StartBug> int n ; <S2SV_EndBug> int ret ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; <S2SV_StartBug> long newbufsize ; <S2SV_EndBug> long newpos ; assert ( buf ) ; assert ( cnt >= 0 ) ; JAS_DBGLOG ( 100 , ( ""mem_write(%p,<S2SV_blank>%p,<S2SV_blank>%d)\\n"" , obj , buf , cnt ) ) ; newpos = m -> pos_ + cnt ; if ( newpos > m -> bufsize_ && m -> growable_ ) { newbufsize = m -> bufsize_ ; while ( newbufsize < newpos ) { <S2SV_StartBug> newbufsize <<= 1 ; <S2SV_EndBug> assert ( newbufsize >= 0 ) ; } <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%z\\n"" , m -> bufsize_ , <S2SV_EndBug> newbufsize ) ) ; JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%ul\\n"" , m -> bufsize_ , JAS_CAST ( unsigned long , newbufsize ) ) ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } } <S2SV_StartBug> if ( m -> pos_ > m -> len_ ) { <S2SV_EndBug> n = JAS_MIN ( m -> pos_ , m -> bufsize_ ) - m -> len_ ; if ( n > 0 ) { memset ( & m -> buf_ [ m -> len_ ] , 0 , n ) ; m -> len_ += n ; } if ( m -> pos_ != m -> len_ ) { return 0 ; } } n = m -> bufsize_ - m -> pos_ ; ret = JAS_MIN ( n , cnt ) ; if ( ret > 0 ) { memcpy ( & m -> buf_ [ m -> pos_ ] , buf , ret ) ; m -> pos_ += ret ; } if ( m -> pos_ > m -> len_ ) { m -> len_ = m -> pos_ ; } assert ( ret == cnt ) ; return ret ; }
","<S2SV_ModStart> cnt ) { size_t <S2SV_ModEnd> n ; int <S2SV_ModStart> ) obj ; size_t newbufsize ; size_t <S2SV_ModEnd> newpos ; assert <S2SV_ModStart> newpos ) { if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) { <S2SV_ModEnd> JAS_DBGLOG ( 100 <S2SV_ModStart> 100 , ( ""new<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>would<S2SV_blank>cause<S2SV_blank>overflow\\n"" ) ) ; <S2SV_ModEnd> return - 1 <S2SV_ModStart> ; } } JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%zu\\n"" , m -> bufsize_ , newbufsize ) ) ; assert ( newbufsize > 0 ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } }
",mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,CVE-2016-9262,https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,2017-03-23T18:59Z,"<S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> long newbufsize ; <S2SV_EndBug> <S2SV_StartBug> newbufsize <<= 1 ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%z\\n"" , m -> bufsize_ , <S2SV_EndBug> <S2SV_StartBug> if ( m -> pos_ > m -> len_ ) { <S2SV_EndBug>"
5684,CWE-125,"void cisco_autorp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len ) { int type ; int numrps ; int hold ; <S2SV_StartBug> ND_TCHECK ( bp [ 0 ] ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>auto-rp<S2SV_blank>"" ) ) ; type = bp [ 0 ] ; switch ( type ) { case 0x11 : ND_PRINT ( ( ndo , ""candidate-advert"" ) ) ; break ; case 0x12 : ND_PRINT ( ( ndo , ""mapping"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""type-0x%02x"" , type ) ) ; break ; } ND_TCHECK ( bp [ 1 ] ) ; numrps = bp [ 1 ] ; ND_TCHECK2 ( bp [ 2 ] , 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>Hold<S2SV_blank>"" ) ) ; hold = EXTRACT_16BITS ( & bp [ 2 ] ) ; if ( hold ) unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ; else ND_PRINT ( ( ndo , ""FOREVER"" ) ) ; bp += 8 ; len -= 8 ; while ( numrps -- ) { int nentries ; char s ; <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>RP<S2SV_blank>%s"" , ipaddr_string ( ndo , bp ) ) ) ; <S2SV_StartBug> ND_TCHECK ( bp [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( bp [ 4 ] & 0x3 ) { <S2SV_EndBug> case 0 : ND_PRINT ( ( ndo , ""<S2SV_blank>PIMv?"" ) ) ; break ; case 1 : ND_PRINT ( ( ndo , ""<S2SV_blank>PIMv1"" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , ""<S2SV_blank>PIMv2"" ) ) ; break ; case 3 : ND_PRINT ( ( ndo , ""<S2SV_blank>PIMv1+2"" ) ) ; break ; } <S2SV_StartBug> if ( bp [ 4 ] & 0xfc ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[rsvd=0x%02x]"" , bp [ 4 ] & 0xfc ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( bp [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> nentries = bp [ 5 ] ; <S2SV_EndBug> <S2SV_StartBug> bp += 6 ; len -= 6 ; <S2SV_EndBug> s = '<S2SV_blank>' ; for ( ; nentries ; nentries -- ) { <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 6 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%c%s%s/%d"" , s , bp [ 0 ] & 1 ? ""!"" : """" , ipaddr_string ( ndo , & bp [ 2 ] ) , bp [ 1 ] ) ) ; if ( bp [ 0 ] & 0x02 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>bidir"" ) ) ; } if ( bp [ 0 ] & 0xfc ) { ND_PRINT ( ( ndo , ""[rsvd=0x%02x]"" , bp [ 0 ] & 0xfc ) ) ; } s = ',' ; bp += 6 ; len -= 6 ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|autorp]"" ) ) ; return ; }
","<S2SV_ModStart> int hold ; if ( len < 8 ) goto trunc ; <S2SV_ModStart> char s ; if ( len < 4 ) goto trunc ; <S2SV_ModStart> ) ) ; bp += 4 ; len -= 4 ; if ( len < 1 ) goto trunc ; <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] & 0x3 <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] & 0xfc <S2SV_ModStart> , bp [ 0 <S2SV_ModEnd> ] & 0xfc <S2SV_ModStart> ) ) ; bp += 1 ; len -= 1 ; if ( len < 1 ) goto trunc ; <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> = bp [ 0 <S2SV_ModEnd> ] ; bp <S2SV_ModStart> ; bp += 1 ; len -= 1 <S2SV_ModEnd> ; s = <S2SV_ModStart> -- ) { if ( len < 6 ) goto trunc ;
",the-tcpdump-group@tcpdump/5dc1860d8267b1e0cb78c9ffa2a40bea2fdb3ddc,CVE-2017-13030,https://github.com/the-tcpdump-group/tcpdump/commit/5dc1860d8267b1e0cb78c9ffa2a40bea2fdb3ddc,2017-09-14T06:29Z,"<S2SV_StartBug> ND_TCHECK ( bp [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( bp [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( bp [ 4 ] & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp [ 4 ] & 0xfc ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[rsvd=0x%02x]"" , bp [ 4 ] & 0xfc ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( bp [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> nentries = bp [ 5 ] ; <S2SV_EndBug> <S2SV_StartBug> bp += 6 ; len -= 6 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 6 ) ; <S2SV_EndBug>"
2506,CWE-264,"const char * string_of_NPPVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPPVpluginNameString ) ; _ ( NPPVpluginDescriptionString ) ; _ ( NPPVpluginWindowBool ) ; _ ( NPPVpluginTransparentBool ) ; _ ( NPPVjavaClass ) ; _ ( NPPVpluginWindowSize ) ; _ ( NPPVpluginTimerInterval ) ; _ ( NPPVpluginScriptableInstance ) ; _ ( NPPVpluginScriptableIID ) ; _ ( NPPVjavascriptPushCallerBool ) ; _ ( NPPVpluginKeepLibraryInMemory ) ; _ ( NPPVpluginNeedsXEmbed ) ; _ ( NPPVpluginScriptableNPObject ) ; _ ( NPPVformValue ) ; <S2SV_StartBug> # undef _ <S2SV_EndBug> default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPPVpluginScriptableInstance ) ; # undef _ default : str = ""<unknown<S2SV_blank>variable>"" ; break ; } break ; } return str ; }
","<S2SV_ModStart> NPPVformValue ) ; _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ;
",davidben@nspluginwrapper/7e4ab8e1189846041f955e6c83f72bc1624e7a98,CVE-2011-2486,https://github.com/davidben/nspluginwrapper/commit/7e4ab8e1189846041f955e6c83f72bc1624e7a98,2012-11-19T12:10Z,<S2SV_StartBug> # undef _ <S2SV_EndBug>
3155,CWE-119,"int add_control_packet ( struct mt_packet * packet , enum mt_cptype cptype , void * cpdata , unsigned short data_len ) { unsigned char * data = packet -> data + packet -> size ; unsigned int act_size = data_len + ( cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN ) ; <S2SV_StartBug> if ( packet -> size + act_size > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"" ) , MT_PACKET_LEN ) ; return - 1 ; } if ( cptype == MT_CPTYPE_PLAINDATA ) { memcpy ( data , cpdata , data_len ) ; packet -> size += data_len ; return data_len ; } memcpy ( data , mt_mactelnet_cpmagic , sizeof ( mt_mactelnet_cpmagic ) ) ; data [ 4 ] = cptype ; # if BYTE_ORDER == LITTLE_ENDIAN { unsigned int templen ; templen = htonl ( data_len ) ; memcpy ( data + 5 , & templen , sizeof ( templen ) ) ; } # else memcpy ( data + 5 , & data_len , sizeof ( data_len ) ) ; # endif if ( data_len > 0 ) { memcpy ( data + MT_CPHEADER_LEN , cpdata , data_len ) ; } packet -> size += act_size ; return act_size ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> act_size > MT_PACKET_LEN <S2SV_ModStart> act_size > MT_PACKET_LEN - packet -> size
",haakonnessjoen@MAC-Telnet/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,CVE-2016-7115,https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,2016-08-30T17:59Z,<S2SV_StartBug> if ( packet -> size + act_size > MT_PACKET_LEN ) { <S2SV_EndBug>
3018,CWE-399,"static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; <S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | MSR_PMM ) ; mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
","<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug>"
515,CWE-119,"void WT_InterpolateNoLoop ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> return ; } pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = ( EAS_I32 ) pWTVoice -> phaseFrac ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }
","<S2SV_ModStart> ALOGE ( ""b/26366256"" ) ; android_errorWriteLog ( 0x534e4554 , ""26366256""
",external@sonivox/24d7c408c52143bce7b49de82f3913fd8d1219cf,CVE-2016-0838,https://android.googlesource.com/platform/external/sonivox/+/24d7c408c52143bce7b49de82f3913fd8d1219cf,2016-04-18T00:59Z,"<S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug>"
1332,CWE-119,"<S2SV_StartBug> static void usage ( char * progname ) { <S2SV_EndBug> printf ( ""Usage:\\n"" ) ; printf ( ""%s<S2SV_blank><input_yuv><S2SV_blank><width>x<height><S2SV_blank><target_width>x<target_height><S2SV_blank>"" , <S2SV_StartBug> progname ) ; <S2SV_EndBug> printf ( ""<output_yuv><S2SV_blank>[<frames>]\\n"" ) ; }
","<S2SV_ModStart> void usage ( <S2SV_ModEnd> ) { printf <S2SV_ModStart> ( ""%s<S2SV_blank><input_yuv><S2SV_blank><width>x<height><S2SV_blank><target_width>x<target_height><S2SV_blank>"" , exec_name <S2SV_ModEnd> ) ; printf
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> static void usage ( char * progname ) { <S2SV_EndBug> <S2SV_StartBug> progname ) ; <S2SV_EndBug>
3055,CWE-190,"PHPAPI PHP_FUNCTION ( fread ) { zval * arg1 ; long len ; php_stream * stream ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""rl"" , & arg1 , & len ) == FAILURE ) { RETURN_FALSE ; } PHP_STREAM_TO_ZVAL ( stream , & arg1 ) ; if ( len <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0"" ) ; RETURN_FALSE ; } <S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ; <S2SV_EndBug> Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }
","<S2SV_ModStart> RETURN_FALSE ; } if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; }
",php@php-src/abd159cce48f3e34f08e4751c568e09677d5ec9c,CVE-2016-5096,https://github.com/php/php-src/commit/abd159cce48f3e34f08e4751c568e09677d5ec9c?w=1,2016-08-07T10:59Z,<S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ; <S2SV_EndBug>
5855,CWE-20,"void beforeSleep ( struct aeEventLoop * eventLoop ) { REDIS_NOTUSED ( eventLoop ) ; listNode * ln ; redisClient * c ; <S2SV_StartBug> if ( server . vm_enabled && listLength ( server . io_ready_clients ) ) { <S2SV_EndBug> listIter li ; listRewind ( server . io_ready_clients , & li ) ; while ( ( ln = listNext ( & li ) ) ) { c = ln -> value ; struct redisCommand * cmd ; listDelNode ( server . io_ready_clients , ln ) ; c -> flags &= ( ~ REDIS_IO_WAIT ) ; <S2SV_StartBug> server . vm_blocked_clients -- ; <S2SV_EndBug> aeCreateFileEvent ( server . el , c -> fd , AE_READABLE , readQueryFromClient , c ) ; cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; redisAssert ( cmd != NULL ) ; call ( c , cmd ) ; resetClient ( c ) ; if ( c -> querybuf && sdslen ( c -> querybuf ) > 0 ) processInputBuffer ( c ) ; } } while ( listLength ( server . unblocked_clients ) ) { ln = listFirst ( server . unblocked_clients ) ; redisAssert ( ln != NULL ) ; c = ln -> value ; listDelNode ( server . unblocked_clients , ln ) ; if ( c -> querybuf && sdslen ( c -> querybuf ) > 0 ) processInputBuffer ( c ) ; } flushAppendOnlyFile ( ) ; }
","<S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> && listLength ( <S2SV_ModStart> ; server . cache_blocked_clients <S2SV_ModEnd> -- ; aeCreateFileEvent
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,<S2SV_StartBug> if ( server . vm_enabled && listLength ( server . io_ready_clients ) ) { <S2SV_EndBug> <S2SV_StartBug> server . vm_blocked_clients -- ; <S2SV_EndBug>
520,CWE-200,"int sbusfb_ioctl_helper ( unsigned long cmd , unsigned long arg , struct fb_info * info , int type , int fb_depth , unsigned long fb_size ) { switch ( cmd ) { case FBIOGTYPE : { struct fbtype __user * f = ( struct fbtype __user * ) arg ; if ( put_user ( type , & f -> fb_type ) || __put_user ( info -> var . yres , & f -> fb_height ) || __put_user ( info -> var . xres , & f -> fb_width ) || __put_user ( fb_depth , & f -> fb_depth ) || __put_user ( 0 , & f -> fb_cmsize ) || __put_user ( fb_size , & f -> fb_cmsize ) ) return - EFAULT ; return 0 ; } case FBIOPUTCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; struct fb_cmap cmap ; u16 red , green , blue ; u8 red8 , green8 , blue8 ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; cmap . len = 1 ; cmap . red = & red ; cmap . green = & green ; cmap . blue = & blue ; cmap . transp = NULL ; for ( i = 0 ; i < count ; i ++ ) { int err ; if ( get_user ( red8 , & ured [ i ] ) || get_user ( green8 , & ugreen [ i ] ) || get_user ( blue8 , & ublue [ i ] ) ) return - EFAULT ; red = red8 << 8 ; green = green8 << 8 ; blue = blue8 << 8 ; cmap . start = index + i ; err = fb_set_cmap ( & cmap , info ) ; if ( err ) return err ; } return 0 ; } case FBIOGETCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; struct fb_cmap * cmap = & info -> cmap ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> u8 red , green , blue ; if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; if ( index + count > cmap -> len ) return - EINVAL ; for ( i = 0 ; i < count ; i ++ ) { red = cmap -> red [ index + i ] >> 8 ; green = cmap -> green [ index + i ] >> 8 ; blue = cmap -> blue [ index + i ] >> 8 ; if ( put_user ( red , & ured [ i ] ) || put_user ( green , & ugreen [ i ] ) || put_user ( blue , & ublue [ i ] ) ) return - EFAULT ; } return 0 ; } default : return - EINVAL ; } }
","<S2SV_ModStart> * ublue ; unsigned <S2SV_ModStart> -> cmap ; unsigned
",torvalds@linux/250c6c49e3b68756b14983c076183568636e2bde,CVE-2018-6412,https://github.com/torvalds/linux/commit/250c6c49e3b68756b14983c076183568636e2bde,2018-01-31T07:29Z,"<S2SV_StartBug> int index , count , i ; <S2SV_EndBug> <S2SV_StartBug> int index , count , i ; <S2SV_EndBug>"
6366,CWE-401,"static int htc_config_pipe_credits ( struct htc_target * target ) { struct sk_buff * skb ; struct htc_config_pipe_msg * cp_msg ; int ret ; unsigned long time_left ; skb = alloc_skb ( 50 + sizeof ( struct htc_frame_hdr ) , GFP_ATOMIC ) ; if ( ! skb ) { dev_err ( target -> dev , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>send<S2SV_blank>buffer\\n"" ) ; return - ENOMEM ; } skb_reserve ( skb , sizeof ( struct htc_frame_hdr ) ) ; cp_msg = skb_put ( skb , sizeof ( struct htc_config_pipe_msg ) ) ; cp_msg -> message_id = cpu_to_be16 ( HTC_MSG_CONFIG_PIPE_ID ) ; cp_msg -> pipe_id = USB_WLAN_TX_PIPE ; cp_msg -> credits = target -> credits ; target -> htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS ; ret = htc_issue_send ( target , skb , skb -> len , 0 , ENDPOINT0 ) ; if ( ret ) goto err ; time_left = wait_for_completion_timeout ( & target -> cmd_wait , HZ ) ; if ( ! time_left ) { dev_err ( target -> dev , ""HTC<S2SV_blank>credit<S2SV_blank>config<S2SV_blank>timeout\\n"" ) ; <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> } return 0 ; err : kfree_skb ( skb ) ; return - EINVAL ; }
","<S2SV_ModStart> ""HTC<S2SV_blank>credit<S2SV_blank>config<S2SV_blank>timeout\\n"" ) ; kfree_skb ( skb ) ;
",torvalds@linux/853acf7caf10b828102d92d05b5c101666a6142b,CVE-2019-19073,https://github.com/torvalds/linux/commit/853acf7caf10b828102d92d05b5c101666a6142b,2019-11-18T06:15Z,<S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug>
7875,CWE-20,"void enc624j600UpdateMacConfig ( NetInterface * interface ) { uint16_t duplexMode ; <S2SV_StartBug> duplexMode = enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PHYDPX ; <S2SV_EndBug> if ( duplexMode ) { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 | MACON2_FULDPX ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x15 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x12 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PHYDPX <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX <S2SV_ModEnd> ) ; enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_FD <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT <S2SV_ModEnd> ) ; enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_HD <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> duplexMode = enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PHYDPX ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x15 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x12 ) ; <S2SV_EndBug>"
6944,CWE-400,"static enum hrtimer_restart perf_swevent_hrtimer ( struct hrtimer * hrtimer ) { enum hrtimer_restart ret = HRTIMER_RESTART ; struct perf_sample_data data ; struct pt_regs * regs ; struct perf_event * event ; u64 period ; event = container_of ( hrtimer , struct perf_event , hw . hrtimer ) ; if ( event -> state != PERF_EVENT_STATE_ACTIVE ) return HRTIMER_NORESTART ; event -> pmu -> read ( event ) ; perf_sample_data_init ( & data , 0 ) ; data . period = event -> hw . last_period ; regs = get_irq_regs ( ) ; if ( regs && ! perf_exclude_event ( event , regs ) ) { if ( ! ( event -> attr . exclude_idle && current -> pid == 0 ) ) <S2SV_StartBug> if ( perf_event_overflow ( event , 0 , & data , regs ) ) <S2SV_EndBug> ret = HRTIMER_NORESTART ; } period = max_t ( u64 , 10000 , event -> hw . sample_period ) ; hrtimer_forward_now ( hrtimer , ns_to_ktime ( period ) ) ; return ret ; }
","<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> if ( perf_event_overflow ( event , 0 , & data , regs ) ) <S2SV_EndBug>"
4052,CWE-119,"static Image * ReadAVSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register PixelPacket * q ; register ssize_t x ; register unsigned char * p ; size_t height , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobMSBLong ( image ) ; height = ReadBlobMSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { ssize_t length ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) 4 * image -> columns ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( q -> opacity != OpaqueOpacity ) image -> matte = MagickTrue ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; width = ReadBlobMSBLong ( image ) ; height = ReadBlobMSBLong ( image ) ; if ( ( width != 0UL ) && ( height != 0UL ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( width != 0UL ) && ( height != 0UL ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug>"
5404,CWE-358,"void DefragRegisterTests ( void ) { # ifdef UNITTESTS UtRegisterTest ( ""DefragInOrderSimpleTest"" , DefragInOrderSimpleTest ) ; UtRegisterTest ( ""DefragReverseSimpleTest"" , DefragReverseSimpleTest ) ; UtRegisterTest ( ""DefragSturgesNovakBsdTest"" , DefragSturgesNovakBsdTest ) ; UtRegisterTest ( ""DefragSturgesNovakLinuxTest"" , DefragSturgesNovakLinuxTest ) ; UtRegisterTest ( ""DefragSturgesNovakWindowsTest"" , DefragSturgesNovakWindowsTest ) ; UtRegisterTest ( ""DefragSturgesNovakSolarisTest"" , DefragSturgesNovakSolarisTest ) ; UtRegisterTest ( ""DefragSturgesNovakFirstTest"" , DefragSturgesNovakFirstTest ) ; UtRegisterTest ( ""DefragSturgesNovakLastTest"" , DefragSturgesNovakLastTest ) ; UtRegisterTest ( ""DefragIPv4NoDataTest"" , DefragIPv4NoDataTest ) ; UtRegisterTest ( ""DefragIPv4TooLargeTest"" , DefragIPv4TooLargeTest ) ; UtRegisterTest ( ""IPV6DefragInOrderSimpleTest"" , IPV6DefragInOrderSimpleTest ) ; UtRegisterTest ( ""IPV6DefragReverseSimpleTest"" , IPV6DefragReverseSimpleTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakBsdTest"" , IPV6DefragSturgesNovakBsdTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakLinuxTest"" , IPV6DefragSturgesNovakLinuxTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakWindowsTest"" , IPV6DefragSturgesNovakWindowsTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakSolarisTest"" , IPV6DefragSturgesNovakSolarisTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakFirstTest"" , IPV6DefragSturgesNovakFirstTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakLastTest"" , IPV6DefragSturgesNovakLastTest ) ; UtRegisterTest ( ""DefragVlanTest"" , DefragVlanTest ) ; UtRegisterTest ( ""DefragVlanQinQTest"" , DefragVlanQinQTest ) ; UtRegisterTest ( ""DefragTrackerReuseTest"" , DefragTrackerReuseTest ) ; UtRegisterTest ( ""DefragTimeoutTest"" , DefragTimeoutTest ) ; UtRegisterTest ( ""DefragMfIpv4Test"" , DefragMfIpv4Test ) ; UtRegisterTest ( ""DefragMfIpv6Test"" , DefragMfIpv6Test ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }
","<S2SV_ModStart> DefragMfIpv6Test ) ; UtRegisterTest ( ""DefragTestBadProto"" , DefragTestBadProto ) ;
",inliniac@suricata/4a04f814b15762eb446a5ead4d69d021512df6f8,CVE-2017-7177,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,2017-03-18T20:59Z,<S2SV_StartBug> # endif <S2SV_EndBug>
703,CWE-000,"static void sas_eh_handle_sas_errors ( struct Scsi_Host * shost , struct list_head * work_q ) { struct scsi_cmnd * cmd , * n ; enum task_disposition res = TASK_IS_DONE ; int tmf_resp , need_reset ; struct sas_internal * i = to_sas_internal ( shost -> transportt ) ; unsigned long flags ; struct sas_ha_struct * ha = SHOST_TO_SAS_HA ( shost ) ; LIST_HEAD ( done ) ; list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct sas_task * task ; spin_lock_irqsave ( & dev -> done_lock , flags ) ; task = TO_SAS_TASK ( cmd ) ; spin_unlock_irqrestore ( & dev -> done_lock , flags ) ; if ( ! task ) list_move_tail ( & cmd -> eh_entry , & done ) ; } Again : list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { struct sas_task * task = TO_SAS_TASK ( cmd ) ; list_del_init ( & cmd -> eh_entry ) ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; need_reset = task -> task_state_flags & SAS_TASK_NEED_DEV_RESET ; spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; if ( need_reset ) { SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>requests<S2SV_blank>reset\\n"" , __func__ , task ) ; goto reset ; } SAS_DPRINTK ( ""trying<S2SV_blank>to<S2SV_blank>find<S2SV_blank>task<S2SV_blank>0x%p\\n"" , task ) ; res = sas_scsi_find_task ( task ) ; switch ( res ) { case TASK_IS_DONE : SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>done\\n"" , __func__ , task ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> continue ; case TASK_IS_ABORTED : SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>aborted\\n"" , __func__ , task ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> continue ; case TASK_IS_AT_LU : SAS_DPRINTK ( ""task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>at<S2SV_blank>LU:<S2SV_blank>lu<S2SV_blank>recover\\n"" , task ) ; reset : tmf_resp = sas_recover_lu ( task -> dev , cmd ) ; if ( tmf_resp == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( ""dev<S2SV_blank>%016llx<S2SV_blank>LU<S2SV_blank>%llx<S2SV_blank>is<S2SV_blank>"" ""recovered\\n"" , SAS_ADDR ( task -> dev ) , cmd -> device -> lun ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> sas_scsi_clear_queue_lu ( work_q , cmd ) ; goto Again ; } case TASK_IS_NOT_AT_LU : case TASK_ABORT_FAILED : SAS_DPRINTK ( ""task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>not<S2SV_blank>at<S2SV_blank>LU:<S2SV_blank>I_T<S2SV_blank>recover\\n"" , task ) ; tmf_resp = sas_recover_I_T ( task -> dev ) ; if ( tmf_resp == TMF_RESP_FUNC_COMPLETE || tmf_resp == - ENODEV ) { struct domain_device * dev = task -> dev ; SAS_DPRINTK ( ""I_T<S2SV_blank>%016llx<S2SV_blank>recovered\\n"" , SAS_ADDR ( task -> dev -> sas_addr ) ) ; sas_eh_finish_cmd ( cmd ) ; sas_scsi_clear_queue_I_T ( work_q , dev ) ; goto Again ; } try_to_reset_cmd_device ( cmd ) ; if ( i -> dft -> lldd_clear_nexus_port ) { struct asd_sas_port * port = task -> dev -> port ; SAS_DPRINTK ( ""clearing<S2SV_blank>nexus<S2SV_blank>for<S2SV_blank>port:%d\\n"" , port -> id ) ; res = i -> dft -> lldd_clear_nexus_port ( port ) ; if ( res == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( ""clear<S2SV_blank>nexus<S2SV_blank>port:%d<S2SV_blank>"" ""succeeded\\n"" , port -> id ) ; sas_eh_finish_cmd ( cmd ) ; sas_scsi_clear_queue_port ( work_q , port ) ; goto Again ; } } if ( i -> dft -> lldd_clear_nexus_ha ) { SAS_DPRINTK ( ""clear<S2SV_blank>nexus<S2SV_blank>ha\\n"" ) ; res = i -> dft -> lldd_clear_nexus_ha ( ha ) ; if ( res == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( ""clear<S2SV_blank>nexus<S2SV_blank>ha<S2SV_blank>"" ""succeeded\\n"" ) ; sas_eh_finish_cmd ( cmd ) ; goto clear_q ; } } SAS_DPRINTK ( ""error<S2SV_blank>from<S2SV_blank><S2SV_blank>device<S2SV_blank>%llx,<S2SV_blank>LUN<S2SV_blank>%llx<S2SV_blank>"" ""couldn\'t<S2SV_blank>be<S2SV_blank>recovered<S2SV_blank>in<S2SV_blank>any<S2SV_blank>way\\n"" , SAS_ADDR ( task -> dev -> sas_addr ) , cmd -> device -> lun ) ; sas_eh_finish_cmd ( cmd ) ; goto clear_q ; } } out : list_splice_tail ( & done , work_q ) ; list_splice_tail_init ( & ha -> eh_ata_q , work_q ) ; return ; clear_q : SAS_DPRINTK ( ""---<S2SV_blank>Exit<S2SV_blank>%s<S2SV_blank>--<S2SV_blank>clear_q\\n"" , __func__ ) ; list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) sas_eh_finish_cmd ( cmd ) ; goto out ; }
","<S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> lun ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
",torvalds@linux/318aaf34f1179b39fa9c30fa0f3288b645beee39,CVE-2018-10021,https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39,2018-04-11T17:29Z,<S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug>
2637,CWE-74,"PS_SERIALIZER_DECODE_FUNC ( php_binary ) { const char * p ; char * name ; const char * endptr = val + vallen ; zval * current ; int namelen ; int has_value ; php_unserialize_data_t var_hash ; <S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> for ( p = val ; p < endptr ; ) { <S2SV_StartBug> zval * * tmp ; <S2SV_EndBug> namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ; if ( namelen < 0 || namelen > PS_BIN_MAX || ( p + namelen ) >= endptr ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } has_value = * p & PS_BIN_UNDEF ? 0 : 1 ; name = estrndup ( p + 1 , namelen ) ; p += namelen + 1 ; if ( zend_hash_find ( & EG ( symbol_table ) , name , namelen + 1 , ( void * * ) & tmp ) == SUCCESS ) { if ( ( Z_TYPE_PP ( tmp ) == IS_ARRAY && Z_ARRVAL_PP ( tmp ) == & EG ( symbol_table ) ) || * tmp == PS ( http_session_vars ) ) { <S2SV_StartBug> efree ( name ) ; <S2SV_EndBug> continue ; } } if ( has_value ) { ALLOC_INIT_ZVAL ( current ) ; if ( php_var_unserialize ( & current , ( const unsigned char * * ) & p , ( const unsigned char * ) endptr , & var_hash TSRMLS_CC ) ) { <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> } else { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } var_push_dtor_no_addref ( & var_hash , & current ) ; } <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> efree ( name ) ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return SUCCESS ; }
","<S2SV_ModStart> php_unserialize_data_t var_hash ; int skip = 0 ; <S2SV_ModStart> * * tmp ; skip = 0 <S2SV_ModStart> ) ) { skip = 1 <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { if ( ! skip ) { <S2SV_ModStart> TSRMLS_CC ) ; } <S2SV_ModStart> ) ; } if ( ! skip ) { <S2SV_ModStart> namelen ) ; }
",php@php-src/8763c6090d627d8bb0ee1d030c30e58f406be9ce,CVE-2016-7125,https://github.com/php/php-src/commit/8763c6090d627d8bb0ee1d030c30e58f406be9ce?w=1,2016-09-12T01:59Z,"<S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> <S2SV_StartBug> zval * * tmp ; <S2SV_EndBug> <S2SV_StartBug> efree ( name ) ; <S2SV_EndBug> <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug>"
1189,CWE-264,"static struct cifsSesInfo * cifs_get_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * volume_info ) { int rc = - ENOMEM , xid ; struct cifsSesInfo * ses ; xid = GetXid ( ) ; <S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug> if ( ses ) { cFYI ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>found<S2SV_blank>(status=%d)"" , ses -> status ) ; cifs_put_tcp_session ( server ) ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } if ( ses -> need_reconnect ) { cFYI ( 1 , ""Session<S2SV_blank>needs<S2SV_blank>reconnect"" ) ; rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } } mutex_unlock ( & ses -> session_mutex ) ; FreeXid ( xid ) ; return ses ; } cFYI ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>not<S2SV_blank>found"" ) ; ses = sesInfoAlloc ( ) ; if ( ses == NULL ) goto get_ses_fail ; ses -> server = server ; if ( server -> addr . sockAddr6 . sin6_family == AF_INET6 ) sprintf ( ses -> serverName , ""%pI6"" , & server -> addr . sockAddr6 . sin6_addr ) ; else sprintf ( ses -> serverName , ""%pI4"" , & server -> addr . sockAddr . sin_addr . s_addr ) ; if ( volume_info -> username ) strncpy ( ses -> userName , volume_info -> username , MAX_USERNAME_SIZE ) ; if ( volume_info -> password ) { ses -> password = kstrdup ( volume_info -> password , GFP_KERNEL ) ; if ( ! ses -> password ) goto get_ses_fail ; } if ( volume_info -> domainname ) { int len = strlen ( volume_info -> domainname ) ; ses -> domainName = kmalloc ( len + 1 , GFP_KERNEL ) ; if ( ses -> domainName ) strcpy ( ses -> domainName , volume_info -> domainname ) ; } ses -> linux_uid = volume_info -> linux_uid ; ses -> overrideSecFlg = volume_info -> secFlg ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( ! rc ) rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; mutex_unlock ( & ses -> session_mutex ) ; if ( rc ) goto get_ses_fail ; write_lock ( & cifs_tcp_ses_lock ) ; list_add ( & ses -> smb_ses_list , & server -> smb_ses_list ) ; write_unlock ( & cifs_tcp_ses_lock ) ; FreeXid ( xid ) ; return ses ; get_ses_fail : sesInfoFree ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }
","<S2SV_ModStart> server , volume_info <S2SV_ModEnd> ) ; if
",torvalds@linux/4ff67b720c02c36e54d55b88c2931879b7db1cd2,CVE-2011-1585,https://github.com/torvalds/linux/commit/4ff67b720c02c36e54d55b88c2931879b7db1cd2,2013-06-08T13:05Z,"<S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug>"
896,CWE-20,"size_t cdf_count_chain ( const cdf_sat_t * sat , cdf_secid_t sid , size_t size ) { size_t i , j ; <S2SV_StartBug> cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ; <S2SV_EndBug> DPRINTF ( ( ""Chain:"" ) ) ; for ( j = i = 0 ; sid >= 0 ; i ++ , j ++ ) { DPRINTF ( ( ""<S2SV_blank>%d"" , sid ) ) ; if ( j >= CDF_LOOP_LIMIT ) { DPRINTF ( ( ""Counting<S2SV_blank>chain<S2SV_blank>loop<S2SV_blank>limit"" ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } <S2SV_StartBug> if ( sid > maxsector ) { <S2SV_EndBug> DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n"" , sid , maxsector ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } sid = CDF_TOLE4 ( ( uint32_t ) sat -> sat_tab [ sid ] ) ; } if ( i == 0 ) { DPRINTF ( ( ""<S2SV_blank>none,<S2SV_blank>sid:<S2SV_blank>%d\\n"" , sid ) ) ; return ( size_t ) - 1 ; } DPRINTF ( ( ""\\n"" ) ) ; return i ; }
","<S2SV_ModStart> ( cdf_secid_t ) ( <S2SV_ModStart> * size ) / sizeof ( maxsector ) ) <S2SV_ModStart> if ( sid >= maxsector ) { DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>>=<S2SV_blank>%d\\n"" <S2SV_ModEnd> , sid ,
",file@file/40bade80cbe2af1d0b2cd0420cebd5d5905a2382,CVE-2014-3480,https://github.com/file/file/commit/40bade80cbe2af1d0b2cd0420cebd5d5905a2382,2014-07-09T11:07Z,<S2SV_StartBug> cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sid > maxsector ) { <S2SV_EndBug>
4649,CWE-190,"<S2SV_StartBug> static char * mongo_data_append ( char * start , const void * data , int len ) { <S2SV_EndBug> memcpy ( start , data , len ) ; return start + len ; }
","<S2SV_ModStart> * data , size_t <S2SV_ModEnd> len ) {
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,"<S2SV_StartBug> static char * mongo_data_append ( char * start , const void * data , int len ) { <S2SV_EndBug>"
3455,CWE-399,"static void enable_nmi_window ( struct kvm_vcpu * vcpu ) { struct vcpu_svm * svm = to_svm ( vcpu ) ; if ( ( svm -> vcpu . arch . hflags & ( HF_NMI_MASK | HF_IRET_MASK ) ) == HF_NMI_MASK ) return ; svm -> nmi_singlestep = true ; svm -> vmcb -> save . rflags |= ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; <S2SV_StartBug> update_db_bp_intercept ( vcpu ) ; <S2SV_EndBug> }
","<S2SV_ModStart> X86_EFLAGS_RF ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/cbdb967af3d54993f5814f1cee0ed311a055377d,CVE-2015-8104,https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d,2015-11-16T11:59Z,<S2SV_StartBug> update_db_bp_intercept ( vcpu ) ; <S2SV_EndBug>
2489,CWE-000,"static int unix_dgram_sendmsg ( struct socket * sock , struct msghdr * msg , size_t len ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_un * , sunaddr , msg -> msg_name ) ; struct sock * other = NULL ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie scm ; int max_level ; int data_len = 0 ; <S2SV_StartBug> wait_for_unix_gc ( ) ; <S2SV_EndBug> err = scm_send ( sock , msg , & scm , false ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = NULL ; err = - ENOTCONN ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > SKB_MAX_ALLOC ) { data_len = min_t ( size_t , len - SKB_MAX_ALLOC , MAX_SKB_FRAGS * PAGE_SIZE ) ; data_len = PAGE_ALIGN ( data_len ) ; BUILD_BUG_ON ( SKB_MAX_ALLOC < PAGE_SIZE ) ; } skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & MSG_DONTWAIT , & err , PAGE_ALLOC_COSTLY_ORDER ) ; if ( skb == NULL ) goto out ; err = unix_scm_to_skb ( & scm , skb , true ) ; if ( err < 0 ) goto out_free ; max_level = err + 1 ; skb_put ( skb , len - data_len ) ; skb -> data_len = data_len ; skb -> len = len ; err = skb_copy_datagram_from_iter ( skb , 0 , & msg -> msg_iter , len ) ; if ( err ) goto out_free ; timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ; restart : if ( ! other ) { err = - ECONNRESET ; if ( sunaddr == NULL ) goto out_free ; other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ; if ( other == NULL ) goto out_free ; } if ( sk_filter ( other , skb ) < 0 ) { err = len ; goto out_free ; } <S2SV_StartBug> unix_state_lock ( other ) ; <S2SV_EndBug> err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; <S2SV_StartBug> if ( sock_flag ( other , SOCK_DEAD ) ) { <S2SV_EndBug> unix_state_unlock ( other ) ; sock_put ( other ) ; <S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( sk ) ; <S2SV_EndBug> if ( unix_peer ( sk ) == other ) { <S2SV_StartBug> unix_peer ( sk ) = NULL ; <S2SV_EndBug> unix_state_unlock ( sk ) ; unix_dgram_disconnected ( sk , other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; } else { unix_state_unlock ( sk ) ; } other = NULL ; if ( err ) goto out_free ; goto restart ; } err = - EPIPE ; if ( other -> sk_shutdown & RCV_SHUTDOWN ) goto out_unlock ; if ( sk -> sk_type != SOCK_SEQPACKET ) { err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } <S2SV_StartBug> if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! timeo ) { <S2SV_EndBug> err = - EAGAIN ; <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> } <S2SV_StartBug> timeo = unix_wait_for_peer ( other , timeo ) ; <S2SV_EndBug> err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } if ( sock_flag ( other , SOCK_RCVTSTAMP ) ) __net_timestamp ( skb ) ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other ) ; sock_put ( other ) ; scm_destroy ( & scm ) ; return len ; out_unlock : <S2SV_StartBug> unix_state_unlock ( other ) ; <S2SV_EndBug> out_free : kfree_skb ( skb ) ; out : if ( other ) sock_put ( other ) ; scm_destroy ( & scm ) ; return err ; }
","<S2SV_ModStart> = 0 ; int sk_locked ; <S2SV_ModStart> out_free ; } sk_locked = 0 ; <S2SV_ModStart> other ) ; restart_locked : <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> SOCK_DEAD ) ) ) <S2SV_ModStart> other ) ; if ( ! sk_locked ) unix_state_lock ( sk ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( unix_peer <S2SV_ModStart> ) = NULL ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <S2SV_ModStart> } if ( unlikely ( <S2SV_ModStart> other ) ) ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModEnd> ) { err <S2SV_ModStart> - EAGAIN ; sk_locked = 1 ; <S2SV_ModStart> out_unlock ; } if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <S2SV_ModEnd> if ( sock_flag <S2SV_ModStart> ; out_unlock : if ( sk_locked ) unix_state_unlock ( sk ) ;
",torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c,CVE-2013-7446,https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c,2015-12-28T11:59Z,"<S2SV_StartBug> wait_for_unix_gc ( ) ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( other ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_flag ( other , SOCK_DEAD ) ) { <S2SV_EndBug> <S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> unix_peer ( sk ) = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! timeo ) { <S2SV_EndBug> <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> <S2SV_StartBug> timeo = unix_wait_for_peer ( other , timeo ) ; <S2SV_EndBug> <S2SV_StartBug> unix_state_unlock ( other ) ; <S2SV_EndBug>"
4067,CWE-119,"static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register PixelPacket * q ; register unsigned char * p ; register ssize_t i , x ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { if ( c == ( int ) '#' ) { char * comment ; register char * p ; size_t length ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( ( c == EOF ) || ( c == ( int ) '\\n' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) == MagickFalse ) c = ReadBlobByte ( image ) ; else { register char * p ; p = keyword ; do { if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } while ( isalnum ( c ) || ( c == '_' ) ) ; * p = '\\0' ; value_expected = MagickFalse ; while ( ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) || ( c == '=' ) ) { if ( c == '=' ) value_expected = MagickTrue ; c = ReadBlobByte ( image ) ; } if ( LocaleCompare ( keyword , ""Y"" ) == 0 ) value_expected = MagickTrue ; if ( value_expected == MagickFalse ) continue ; p = value ; while ( ( c != '\\n' ) && ( c != '\\0' ) ) { if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; switch ( * keyword ) { case 'F' : case 'f' : { if ( LocaleCompare ( keyword , ""format"" ) == 0 ) { ( void ) CopyMagickString ( format , value , MaxTextExtent ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'G' : case 'g' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( value , ( char * * ) NULL ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'P' : case 'p' : { if ( LocaleCompare ( keyword , ""primaries"" ) == 0 ) { float chromaticity [ 6 ] , white_point [ 2 ] ; ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" , & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] , & white_point [ 0 ] , & white_point [ 1 ] ) ; image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; image -> chromaticity . white_point . x = white_point [ 0 ] , image -> chromaticity . white_point . y = white_point [ 1 ] ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'Y' : case 'y' : { if ( strcmp ( keyword , ""Y"" ) == 0 ) { int height , width ; ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } default : { ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } } } if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } if ( ( LocaleCompare ( format , ""32-bit_rle_rgbe"" ) != 0 ) && ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) SetImageColorspace ( image , RGBColorspace ) ; if ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) == 0 ) ( void ) SetImageColorspace ( image , XYZColorspace ) ; image -> compression = ( image -> columns < 8 ) || ( image -> columns > 0x7ffff ) ? NoCompression : RLECompression ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( image -> compression != RLECompression ) { count = ReadBlob ( image , 4 * image -> columns * sizeof ( * pixels ) , pixels ) ; if ( count != ( ssize_t ) ( 4 * image -> columns * sizeof ( * pixels ) ) ) break ; } else { count = ReadBlob ( image , 4 * sizeof ( * pixel ) , pixel ) ; if ( count != 4 ) break ; if ( ( size_t ) ( ( ( ( size_t ) pixel [ 2 ] ) << 8 ) | pixel [ 3 ] ) != image -> columns ) { ( void ) memcpy ( pixels , pixel , 4 * sizeof ( * pixel ) ) ; count = ReadBlob ( image , 4 * ( image -> columns - 1 ) * sizeof ( * pixels ) , pixels + 4 ) ; image -> compression = NoCompression ; } else { p = pixels ; for ( i = 0 ; i < 4 ; i ++ ) { end = & pixels [ ( i + 1 ) * image -> columns ] ; while ( p < end ) { count = ReadBlob ( image , 2 * sizeof ( * pixel ) , pixel ) ; if ( count < 1 ) break ; if ( pixel [ 0 ] > 128 ) { count = ( ssize_t ) pixel [ 0 ] - 128 ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; while ( count -- > 0 ) * p ++ = pixel [ 1 ] ; } else { count = ( ssize_t ) pixel [ 0 ] ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; * p ++ = pixel [ 1 ] ; if ( -- count > 0 ) { count = ReadBlob ( image , ( size_t ) count * sizeof ( * p ) , p ) ; if ( count < 1 ) break ; p += count ; } } } } } } q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; i = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> compression == RLECompression ) { pixel [ 0 ] = pixels [ x ] ; pixel [ 1 ] = pixels [ x + image -> columns ] ; pixel [ 2 ] = pixels [ x + 2 * image -> columns ] ; pixel [ 3 ] = pixels [ x + 3 * image -> columns ] ; } else { pixel [ 0 ] = pixels [ i ++ ] ; pixel [ 1 ] = pixels [ i ++ ] ; pixel [ 2 ] = pixels [ i ++ ] ; pixel [ 3 ] = pixels [ i ++ ] ; } SetPixelRed ( q , 0 ) ; SetPixelGreen ( q , 0 ) ; SetPixelBlue ( q , 0 ) ; if ( pixel [ 3 ] != 0 ) { gamma = pow ( 2.0 , pixel [ 3 ] - ( 128.0 + 8.0 ) ) ; SetPixelRed ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 0 ] ) ) ; SetPixelGreen ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 1 ] ) ) ; SetPixelBlue ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 2 ] ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * <S2SV_EndBug>"
3389,CWE-125,"static Sdb * store_versioninfo_gnu_verneed ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { ut8 * end , * need = NULL ; const char * section_name = """" ; Elf_ ( Shdr ) * link_shdr = NULL ; const char * link_section_name = """" ; Sdb * sdb_vernaux = NULL ; Sdb * sdb_version = NULL ; Sdb * sdb = NULL ; int i , cnt ; if ( ! bin || ! bin -> dynstr ) { return NULL ; } if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return NULL ; } if ( shdr -> sh_size < 1 ) { return NULL ; } sdb = sdb_new0 ( ) ; if ( ! sdb ) { return NULL ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! ( need = ( ut8 * ) calloc ( R_MAX ( 1 , shdr -> sh_size ) , sizeof ( ut8 ) ) ) ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Elf_(Verneed)\\n"" ) ; goto beach ; } end = need + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""num_entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) { goto beach ; } if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) { goto beach ; } i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ; if ( i < 0 ) goto beach ; for ( i = 0 , cnt = 0 ; cnt < shdr -> sh_info ; ++ cnt ) { int j , isum ; ut8 * vstart = need + i ; Elf_ ( Verneed ) vvn = { 0 } ; if ( vstart + sizeof ( Elf_ ( Verneed ) ) > end ) { goto beach ; } Elf_ ( Verneed ) * entry = & vvn ; char key [ 32 ] = { 0 } ; sdb_version = sdb_new0 ( ) ; if ( ! sdb_version ) { goto beach ; } j = 0 ; vvn . vn_version = READ16 ( vstart , j ) vvn . vn_cnt = READ16 ( vstart , j ) vvn . vn_file = READ32 ( vstart , j ) vvn . vn_aux = READ32 ( vstart , j ) vvn . vn_next = READ32 ( vstart , j ) sdb_num_set ( sdb_version , ""vn_version"" , entry -> vn_version , 0 ) ; sdb_num_set ( sdb_version , ""idx"" , i , 0 ) ; if ( entry -> vn_file > bin -> dynstr_size ) { goto beach ; } { char * s = r_str_ndup ( & bin -> dynstr [ entry -> vn_file ] , 16 ) ; sdb_set ( sdb_version , ""file_name"" , s , 0 ) ; free ( s ) ; } sdb_num_set ( sdb_version , ""cnt"" , entry -> vn_cnt , 0 ) ; <S2SV_StartBug> vstart += entry -> vn_aux ; <S2SV_EndBug> for ( j = 0 , isum = i + entry -> vn_aux ; j < entry -> vn_cnt && vstart + sizeof ( Elf_ ( Vernaux ) ) <= end ; ++ j ) { int k ; Elf_ ( Vernaux ) * aux = NULL ; Elf_ ( Vernaux ) vaux = { 0 } ; sdb_vernaux = sdb_new0 ( ) ; if ( ! sdb_vernaux ) { goto beach ; } aux = ( Elf_ ( Vernaux ) * ) & vaux ; k = 0 ; vaux . vna_hash = READ32 ( vstart , k ) vaux . vna_flags = READ16 ( vstart , k ) vaux . vna_other = READ16 ( vstart , k ) vaux . vna_name = READ32 ( vstart , k ) vaux . vna_next = READ32 ( vstart , k ) if ( aux -> vna_name > bin -> dynstr_size ) { goto beach ; } sdb_num_set ( sdb_vernaux , ""idx"" , isum , 0 ) ; if ( aux -> vna_name > 0 && aux -> vna_name + 8 < bin -> dynstr_size ) { char name [ 16 ] ; strncpy ( name , & bin -> dynstr [ aux -> vna_name ] , sizeof ( name ) - 1 ) ; name [ sizeof ( name ) - 1 ] = 0 ; sdb_set ( sdb_vernaux , ""name"" , name , 0 ) ; } sdb_set ( sdb_vernaux , ""flags"" , get_ver_flags ( aux -> vna_flags ) , 0 ) ; sdb_num_set ( sdb_vernaux , ""version"" , aux -> vna_other , 0 ) ; isum += aux -> vna_next ; vstart += aux -> vna_next ; snprintf ( key , sizeof ( key ) , ""vernaux%d"" , j ) ; sdb_ns_set ( sdb_version , key , sdb_vernaux ) ; } if ( ( int ) entry -> vn_next < 0 ) { bprintf ( ""Invalid<S2SV_blank>vn_next\\n"" ) ; break ; } i += entry -> vn_next ; snprintf ( key , sizeof ( key ) , ""version%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_version ) ; if ( ! entry -> vn_next ) { break ; } } free ( need ) ; return sdb ; beach : free ( need ) ; sdb_free ( sdb_vernaux ) ; sdb_free ( sdb_version ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> 0 ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux <S2SV_ModEnd> ; for (
",radare@radare2/c6d0076c924891ad9948a62d89d0bcdaf965f0cd,CVE-2017-15931,https://github.com/radare/radare2/commit/c6d0076c924891ad9948a62d89d0bcdaf965f0cd,2017-10-27T18:29Z,<S2SV_StartBug> vstart += entry -> vn_aux ; <S2SV_EndBug>
777,CWE-189,"static int cdf_check_stream_offset ( const cdf_stream_t * sst , const cdf_header_t * h , const void * p , size_t tail , int line ) { const char * b = ( const char * ) sst -> sst_tab ; const char * e = ( ( const char * ) p ) + tail ; <S2SV_StartBug> ( void ) & line ; <S2SV_EndBug> <S2SV_StartBug> if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len ) <S2SV_EndBug> return 0 ; DPRINTF ( ( ""%d:<S2SV_blank>offset<S2SV_blank>begin<S2SV_blank>%p<S2SV_blank><<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>||<S2SV_blank>%"" SIZE_T_FORMAT ""u"" ""<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>[%"" SIZE_T_FORMAT ""u<S2SV_blank>%"" SIZE_T_FORMAT ""u]\\n"" , line , b , e , ( size_t ) ( e - b ) , <S2SV_StartBug> CDF_SEC_SIZE ( h ) * sst -> sst_len , CDF_SEC_SIZE ( h ) , sst -> sst_len ) ) ; <S2SV_EndBug> errno = EFTYPE ; return - 1 ; }
","<S2SV_ModStart> + tail ; size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ; <S2SV_ModStart> b ) <= ss <S2SV_ModEnd> * sst -> <S2SV_ModStart> b ) , ss <S2SV_ModEnd> * sst -> <S2SV_ModStart> -> sst_len , ss <S2SV_ModEnd> , sst ->
",file@file/36fadd29849b8087af9f4586f89dbf74ea45be67,CVE-2014-3479,https://github.com/file/file/commit/36fadd29849b8087af9f4586f89dbf74ea45be67,2014-07-09T11:07Z,"<S2SV_StartBug> ( void ) & line ; <S2SV_EndBug> <S2SV_StartBug> if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len ) <S2SV_EndBug> <S2SV_StartBug> CDF_SEC_SIZE ( h ) * sst -> sst_len , CDF_SEC_SIZE ( h ) , sst -> sst_len ) ) ; <S2SV_EndBug>"
1392,CWE-119,"int vp8_decode_frame ( VP8D_COMP * pbi ) { vp8_reader * const bc = & pbi -> mbc [ 8 ] ; VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; const unsigned char * data = pbi -> fragments . ptrs [ 0 ] ; const unsigned char * data_end = data + pbi -> fragments . sizes [ 0 ] ; ptrdiff_t first_partition_length_in_bytes ; int i , j , k , l ; const int * const mb_feature_data_bits = vp8_mb_feature_data_bits ; int corrupt_tokens = 0 ; int prev_independent_partitions = pbi -> independent_partitions ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; xd -> corrupted = 0 ; yv12_fb_new -> corrupted = 0 ; if ( data_end - data < 3 ) { if ( ! pbi -> ec_active ) { vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , ""Truncated<S2SV_blank>packet"" ) ; } pc -> frame_type = INTER_FRAME ; pc -> version = 0 ; pc -> show_frame = 1 ; first_partition_length_in_bytes = 0 ; } else { unsigned char clear_buffer [ 10 ] ; const unsigned char * clear = data ; if ( pbi -> decrypt_cb ) { <S2SV_StartBug> int n = ( int ) ( data_end - data ) ; <S2SV_EndBug> if ( n > 10 ) n = 10 ; pbi -> decrypt_cb ( pbi -> decrypt_state , data , clear_buffer , n ) ; clear = clear_buffer ; } pc -> frame_type = ( FRAME_TYPE ) ( clear [ 0 ] & 1 ) ; pc -> version = ( clear [ 0 ] >> 1 ) & 7 ; pc -> show_frame = ( clear [ 0 ] >> 4 ) & 1 ; first_partition_length_in_bytes = ( clear [ 0 ] | ( clear [ 1 ] << 8 ) | ( clear [ 2 ] << 16 ) ) >> 5 ; if ( ! pbi -> ec_active && ( data + first_partition_length_in_bytes > data_end || data + first_partition_length_in_bytes < data ) ) vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , ""Truncated<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>corrupt<S2SV_blank>partition<S2SV_blank>0<S2SV_blank>length"" ) ; data += 3 ; clear += 3 ; vp8_setup_version ( pc ) ; if ( pc -> frame_type == KEY_FRAME ) { if ( ! pbi -> ec_active || data + 3 < data_end ) { if ( clear [ 0 ] != 0x9d || clear [ 1 ] != 0x01 || clear [ 2 ] != 0x2a ) vpx_internal_error ( & pc -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code"" ) ; } if ( ! pbi -> ec_active || data + 6 < data_end ) { pc -> Width = ( clear [ 3 ] | ( clear [ 4 ] << 8 ) ) & 0x3fff ; pc -> horiz_scale = clear [ 4 ] >> 6 ; pc -> Height = ( clear [ 5 ] | ( clear [ 6 ] << 8 ) ) & 0x3fff ; pc -> vert_scale = clear [ 6 ] >> 6 ; } data += 7 ; <S2SV_StartBug> clear += 7 ; <S2SV_EndBug> } else { <S2SV_StartBug> vpx_memcpy ( & xd -> pre , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & xd -> dst , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> } } if ( ( ! pbi -> decoded_key_frame && pc -> frame_type != KEY_FRAME ) ) { return - 1 ; } init_frame ( pbi ) ; if ( vp8dx_start_decode ( bc , data , ( unsigned int ) ( data_end - data ) , pbi -> decrypt_cb , pbi -> decrypt_state ) ) vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0"" ) ; if ( pc -> frame_type == KEY_FRAME ) { ( void ) vp8_read_bit ( bc ) ; pc -> clamp_type = ( CLAMP_TYPE ) vp8_read_bit ( bc ) ; } xd -> segmentation_enabled = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> segmentation_enabled ) { xd -> update_mb_segmentation_map = ( unsigned char ) vp8_read_bit ( bc ) ; xd -> update_mb_segmentation_data = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> update_mb_segmentation_data ) { xd -> mb_segement_abs_delta = ( unsigned char ) vp8_read_bit ( bc ) ; <S2SV_StartBug> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> for ( i = 0 ; i < MB_LVL_MAX ; i ++ ) { for ( j = 0 ; j < MAX_MB_SEGMENTS ; j ++ ) { if ( vp8_read_bit ( bc ) ) { xd -> segment_feature_data [ i ] [ j ] = ( signed char ) vp8_read_literal ( bc , mb_feature_data_bits [ i ] ) ; if ( vp8_read_bit ( bc ) ) xd -> segment_feature_data [ i ] [ j ] = - xd -> segment_feature_data [ i ] [ j ] ; } else xd -> segment_feature_data [ i ] [ j ] = 0 ; } } } if ( xd -> update_mb_segmentation_map ) { <S2SV_StartBug> vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; <S2SV_EndBug> for ( i = 0 ; i < MB_FEATURE_TREE_PROBS ; i ++ ) { if ( vp8_read_bit ( bc ) ) xd -> mb_segment_tree_probs [ i ] = ( vp8_prob ) vp8_read_literal ( bc , 8 ) ; } } } else { xd -> update_mb_segmentation_map = 0 ; xd -> update_mb_segmentation_data = 0 ; } pc -> filter_type = ( LOOPFILTERTYPE ) vp8_read_bit ( bc ) ; pc -> filter_level = vp8_read_literal ( bc , 6 ) ; pc -> sharpness_level = vp8_read_literal ( bc , 3 ) ; xd -> mode_ref_lf_delta_update = 0 ; xd -> mode_ref_lf_delta_enabled = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> mode_ref_lf_delta_enabled ) { xd -> mode_ref_lf_delta_update = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> mode_ref_lf_delta_update ) { for ( i = 0 ; i < MAX_REF_LF_DELTAS ; i ++ ) { if ( vp8_read_bit ( bc ) ) { xd -> ref_lf_deltas [ i ] = ( signed char ) vp8_read_literal ( bc , 6 ) ; if ( vp8_read_bit ( bc ) ) xd -> ref_lf_deltas [ i ] = xd -> ref_lf_deltas [ i ] * - 1 ; } } for ( i = 0 ; i < MAX_MODE_LF_DELTAS ; i ++ ) { if ( vp8_read_bit ( bc ) ) { xd -> mode_lf_deltas [ i ] = ( signed char ) vp8_read_literal ( bc , 6 ) ; if ( vp8_read_bit ( bc ) ) xd -> mode_lf_deltas [ i ] = xd -> mode_lf_deltas [ i ] * - 1 ; } } } } setup_token_decoder ( pbi , data + first_partition_length_in_bytes ) ; xd -> current_bc = & pbi -> mbc [ 0 ] ; { int Q , q_update ; Q = vp8_read_literal ( bc , 7 ) ; pc -> base_qindex = Q ; q_update = 0 ; pc -> y1dc_delta_q = get_delta_q ( bc , pc -> y1dc_delta_q , & q_update ) ; pc -> y2dc_delta_q = get_delta_q ( bc , pc -> y2dc_delta_q , & q_update ) ; pc -> y2ac_delta_q = get_delta_q ( bc , pc -> y2ac_delta_q , & q_update ) ; pc -> uvdc_delta_q = get_delta_q ( bc , pc -> uvdc_delta_q , & q_update ) ; pc -> uvac_delta_q = get_delta_q ( bc , pc -> uvac_delta_q , & q_update ) ; if ( q_update ) vp8cx_init_de_quantizer ( pbi ) ; vp8_mb_init_dequantizer ( pbi , & pbi -> mb ) ; } if ( pc -> frame_type != KEY_FRAME ) { pc -> refresh_golden_frame = vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_golden_frame = 0 ; # endif pc -> refresh_alt_ref_frame = vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_alt_ref_frame = 0 ; # endif pc -> copy_buffer_to_gf = 0 ; if ( ! pc -> refresh_golden_frame ) pc -> copy_buffer_to_gf = vp8_read_literal ( bc , 2 ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> copy_buffer_to_gf = 0 ; # endif pc -> copy_buffer_to_arf = 0 ; if ( ! pc -> refresh_alt_ref_frame ) pc -> copy_buffer_to_arf = vp8_read_literal ( bc , 2 ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> copy_buffer_to_arf = 0 ; # endif pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] = vp8_read_bit ( bc ) ; pc -> ref_frame_sign_bias [ ALTREF_FRAME ] = vp8_read_bit ( bc ) ; } pc -> refresh_entropy_probs = vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_entropy_probs = 0 ; # endif if ( pc -> refresh_entropy_probs == 0 ) { <S2SV_StartBug> vpx_memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug> } pc -> refresh_last_frame = pc -> frame_type == KEY_FRAME || vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_last_frame = 1 ; # endif if ( 0 ) { FILE * z = fopen ( ""decodestats.stt"" , ""a"" ) ; fprintf ( z , ""%6d<S2SV_blank>F:%d,G:%d,A:%d,L:%d,Q:%d\\n"" , pc -> current_video_frame , pc -> frame_type , pc -> refresh_golden_frame , pc -> refresh_alt_ref_frame , pc -> refresh_last_frame , pc -> base_qindex ) ; fclose ( z ) ; } { pbi -> independent_partitions = 1 ; for ( i = 0 ; i < BLOCK_TYPES ; i ++ ) for ( j = 0 ; j < COEF_BANDS ; j ++ ) for ( k = 0 ; k < PREV_COEF_CONTEXTS ; k ++ ) for ( l = 0 ; l < ENTROPY_NODES ; l ++ ) { vp8_prob * const p = pc -> fc . coef_probs [ i ] [ j ] [ k ] + l ; if ( vp8_read ( bc , vp8_coef_update_probs [ i ] [ j ] [ k ] [ l ] ) ) { * p = ( vp8_prob ) vp8_read_literal ( bc , 8 ) ; } if ( k > 0 && * p != pc -> fc . coef_probs [ i ] [ j ] [ k - 1 ] [ l ] ) pbi -> independent_partitions = 0 ; } } <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> vp8_decode_mode_mvs ( pbi ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active && pbi -> mvs_corrupt_from_mb < ( unsigned int ) pc -> mb_cols * pc -> mb_rows ) { vp8_estimate_missing_mvs ( pbi ) ; } # endif <S2SV_StartBug> vpx_memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ; <S2SV_EndBug> pbi -> frame_corrupt_residual = 0 ; # if CONFIG_MULTITHREAD if ( pbi -> b_multithreaded_rd && pc -> multi_token_partition != ONE_PARTITION ) { unsigned int thread ; vp8mt_decode_mb_rows ( pbi , xd ) ; vp8_yv12_extend_frame_borders ( yv12_fb_new ) ; for ( thread = 0 ; thread < pbi -> decoding_thread_count ; ++ thread ) corrupt_tokens |= pbi -> mb_row_di [ thread ] . mbd . corrupted ; } else # endif { decode_mb_rows ( pbi ) ; corrupt_tokens |= xd -> corrupted ; } yv12_fb_new -> corrupted = vp8dx_bool_error ( bc ) ; yv12_fb_new -> corrupted |= corrupt_tokens ; if ( ! pbi -> decoded_key_frame ) { if ( pc -> frame_type == KEY_FRAME && ! yv12_fb_new -> corrupted ) pbi -> decoded_key_frame = 1 ; else vpx_internal_error ( & pbi -> common . error , VPX_CODEC_CORRUPT_FRAME , ""A<S2SV_blank>stream<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>key<S2SV_blank>frame"" ) ; } if ( pc -> refresh_entropy_probs == 0 ) { <S2SV_StartBug> vpx_memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug> pbi -> independent_partitions = prev_independent_partitions ; } # ifdef PACKET_TESTING { FILE * f = fopen ( ""decompressor.VP8"" , ""ab"" ) ; unsigned int size = pbi -> bc2 . pos + pbi -> bc . pos + 8 ; fwrite ( ( void * ) & size , 4 , 1 , f ) ; fwrite ( ( void * ) pbi -> Source , size , 1 , f ) ; fclose ( f ) ; } # endif return 0 ; }
","<S2SV_ModStart> ( int ) MIN ( sizeof ( clear_buffer ) , <S2SV_ModEnd> data_end - data <S2SV_ModStart> - data ) <S2SV_ModEnd> ; pbi -> <S2SV_ModStart> += 7 ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { memcpy <S2SV_ModEnd> ( & xd <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & xd <S2SV_ModStart> bc ) ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> update_mb_segmentation_map ) { memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & pc <S2SV_ModStart> ; } } memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> } # endif memset <S2SV_ModEnd> ( pc -> <S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & pc
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int n = ( int ) ( data_end - data ) ; <S2SV_EndBug> <S2SV_StartBug> clear += 7 ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & xd -> pre , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & xd -> dst , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug>"
103,CWE-200,"int ext4_map_blocks ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , int flags ) { struct extent_status es ; int retval ; int ret = 0 ; # ifdef ES_AGGRESSIVE_TEST struct ext4_map_blocks orig_map ; memcpy ( & orig_map , map , sizeof ( * map ) ) ; # endif map -> m_flags = 0 ; ext_debug ( ""ext4_map_blocks():<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>flag<S2SV_blank>%d,<S2SV_blank>max_blocks<S2SV_blank>%u,"" ""logical<S2SV_blank>block<S2SV_blank>%lu\\n"" , inode -> i_ino , flags , map -> m_len , ( unsigned long ) map -> m_lblk ) ; if ( unlikely ( map -> m_len > INT_MAX ) ) map -> m_len = INT_MAX ; if ( unlikely ( map -> m_lblk >= EXT_MAX_BLOCKS ) ) return - EFSCORRUPTED ; if ( ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) || ext4_es_is_unwritten ( & es ) ) { map -> m_pblk = ext4_es_pblock ( & es ) + map -> m_lblk - es . es_lblk ; map -> m_flags |= ext4_es_is_written ( & es ) ? EXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; } else if ( ext4_es_is_delayed ( & es ) || ext4_es_is_hole ( & es ) ) { map -> m_pblk = 0 ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; retval = 0 ; } else { BUG_ON ( 1 ) ; } # ifdef ES_AGGRESSIVE_TEST ext4_map_blocks_es_recheck ( handle , inode , map , & orig_map , flags ) ; # endif goto found ; } down_read ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags & EXT4_GET_BLOCKS_KEEP_SIZE ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags & EXT4_GET_BLOCKS_KEEP_SIZE ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ; WARN_ON ( 1 ) ; } status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) retval = ret ; } up_read ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; found : if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; } if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) return retval ; if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) if ( ! ( flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN ) ) return retval ; map -> m_flags &= ~ EXT4_MAP_FLAGS ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags ) ; if ( retval > 0 && map -> m_flags & EXT4_MAP_NEW ) { ext4_clear_inode_state ( inode , EXT4_STATE_EXT_MIGRATE ) ; } if ( ( retval > 0 ) && ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ) ext4_da_update_reserve_space ( inode , retval , 1 ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ; WARN_ON ( 1 ) ; } if ( flags & EXT4_GET_BLOCKS_ZERO && map -> m_flags & EXT4_MAP_MAPPED && map -> m_flags & EXT4_MAP_NEW ) { ret = ext4_issue_zeroout ( inode , map -> m_lblk , map -> m_pblk , map -> m_len ) ; if ( ret ) { retval = ret ; goto out_sem ; } } if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) && ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) ) goto out_sem ; } status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) { retval = ret ; goto out_sem ; } } out_sem : up_write ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; <S2SV_StartBug> } <S2SV_EndBug> return retval ; }
","<S2SV_ModStart> return ret ; if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> retval ; }
",torvalds@linux/06bd3c36a733ac27962fea7d6f47168841376824,CVE-2017-7495,https://github.com/torvalds/linux/commit/06bd3c36a733ac27962fea7d6f47168841376824,2017-05-15T18:29Z,<S2SV_StartBug> } <S2SV_EndBug>
6255,CWE-863,"static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg , struct bpf_reg_state * dst_reg , struct bpf_insn_aux_data * tmp_aux , const bool commit_window ) { struct bpf_insn_aux_data * aux = commit_window ? cur_aux ( env ) : tmp_aux ; struct bpf_verifier_state * vstate = env -> cur_state ; <S2SV_StartBug> bool off_is_neg = off_reg -> smin_value < 0 ; <S2SV_EndBug> bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; int err ; if ( can_skip_alu_sanitation ( env , insn ) ) return 0 ; if ( vstate -> speculative ) goto do_sim ; err = retrieve_ptr_limit ( ptr_reg , off_reg , & alu_limit , opcode ) ; if ( err < 0 ) return err ; if ( commit_window ) { alu_state = tmp_aux -> alu_state ; alu_limit = abs ( tmp_aux -> alu_limit - alu_limit ) ; } else { <S2SV_StartBug> alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; <S2SV_EndBug> alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; } err = update_alu_sanitation_state ( aux , alu_state , alu_limit ) ; if ( err < 0 ) return err ; do_sim : if ( commit_window ) return 0 ; if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg && ret ) * dst_reg = tmp ; return ! ret ? REASON_STACK : 0 ; }
","<S2SV_ModStart> cur_state ; bool off_is_imm = tnum_is_const ( off_reg -> var_off ) ; bool <S2SV_ModStart> off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE
",torvalds@linux/801c6058d14a82179a7ee17a4b532cac6fad067f,CVE-2021-31829,https://github.com/torvalds/linux/commit/801c6058d14a82179a7ee17a4b532cac6fad067f,2021-05-06T16:15Z,<S2SV_StartBug> bool off_is_neg = off_reg -> smin_value < 0 ; <S2SV_EndBug> <S2SV_StartBug> alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; <S2SV_EndBug>
2242,CWE-119,"static int fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; <S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> if ( ( cc % ( bps * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ; return 0 ; } <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> return 0 ; _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) return 1 ; }
","<S2SV_ModStart> uint8 * tmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
",vadz@libtiff/6a984bf7905c6621281588431f384e79d11a2e33,CVE-2016-9535,https://github.com/vadz/libtiff/commit/6a984bf7905c6621281588431f384e79d11a2e33,2016-11-22T19:59Z,<S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug>
385,CWE-119,"int cdf_read_short_sector_chain ( const cdf_header_t * h , const cdf_sat_t * ssat , const cdf_stream_t * sst , cdf_secid_t sid , size_t len , cdf_stream_t * scn ) { <S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) , i , j ; <S2SV_EndBug> scn -> sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ; scn -> sst_dirlen = len ; if ( sst -> sst_tab == NULL || scn -> sst_len == ( size_t ) - 1 ) return - 1 ; scn -> sst_tab = calloc ( scn -> sst_len , ss ) ; if ( scn -> sst_tab == NULL ) return - 1 ; for ( j = i = 0 ; sid >= 0 ; i ++ , j ++ ) { if ( j >= CDF_LOOP_LIMIT ) { DPRINTF ( ( ""Read<S2SV_blank>short<S2SV_blank>sector<S2SV_blank>chain<S2SV_blank>loop<S2SV_blank>limit"" ) ) ; errno = EFTYPE ; goto out ; } if ( i >= scn -> sst_len ) { DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>reading<S2SV_blank>short<S2SV_blank>sector<S2SV_blank>chain<S2SV_blank>"" ""%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , i , scn -> sst_len ) ) ; errno = EFTYPE ; goto out ; } if ( cdf_read_short_sector ( sst , scn -> sst_tab , i * ss , ss , h , sid ) != ( ssize_t ) ss ) { DPRINTF ( ( ""Reading<S2SV_blank>short<S2SV_blank>sector<S2SV_blank>chain<S2SV_blank>%d"" , sid ) ) ; goto out ; } sid = CDF_TOLE4 ( ( uint32_t ) ssat -> sat_tab [ sid ] ) ; } return 0 ; out : free ( scn -> sst_tab ) ; return - 1 ; }
","<S2SV_ModStart> size_t ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h )
",glensc@file/1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b,CVE-2012-1571,https://github.com/glensc/file/commit/1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b,2012-07-17T21:55Z,"<S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) , i , j ; <S2SV_EndBug>"
2109,CWE-200,"static void set_orig_addr ( struct msghdr * m , struct tipc_msg * msg ) { struct sockaddr_tipc * addr = ( struct sockaddr_tipc * ) m -> msg_name ; if ( addr ) { addr -> family = AF_TIPC ; <S2SV_StartBug> addr -> addrtype = TIPC_ADDR_ID ; <S2SV_EndBug> addr -> addr . id . ref = msg_origport ( msg ) ; addr -> addr . id . node = msg_orignode ( msg ) ; addr -> addr . name . domain = 0 ; addr -> scope = 0 ; m -> msg_namelen = sizeof ( struct sockaddr_tipc ) ; } }
","<S2SV_ModStart> addrtype = TIPC_ADDR_ID ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) )
",torvalds@linux/60085c3d009b0df252547adb336d1ccca5ce52ec,CVE-2013-3235,https://github.com/torvalds/linux/commit/60085c3d009b0df252547adb336d1ccca5ce52ec,2013-04-22T11:41Z,<S2SV_StartBug> addr -> addrtype = TIPC_ADDR_ID ; <S2SV_EndBug>
3373,CWE-119,"void ih264d_rest_of_residual_cav_chroma_dc_block ( UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD16 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 4 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = u4_lev_prefix - 3 ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( u4_lev_prefix , 15 ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) ; } } if ( u4_total_coeff < 4 ) { UWORD32 u4_max_ldz = ( 4 - u4_total_coeff ) ; FIND_ONE_IN_STREAM_LEN ( u4_total_zeroes , u4_bitstream_offset , pu4_bitstrm_buf , u4_max_ldz ) ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; UWORD32 u4_scan_pos = ( u4_total_coeff + u4_total_zeroes - 1 ) ; UWORD32 u4_zeroes_left = u4_total_zeroes ; i = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( u4_zeroes_left && i ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } while ( i >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; }
","<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t
",external@libavc/c57fc3703ae2e0d41b1f6580c50015937f2d23c1,CVE-2016-0840,https://android.googlesource.com/platform/external/libavc/+/c57fc3703ae2e0d41b1f6580c50015937f2d23c1,2016-04-18T00:59Z,<S2SV_StartBug> WORD16 i2_level_arr [ 4 ] ; <S2SV_EndBug>
5987,CWE-119,"static inline void header_put_byte ( SF_PRIVATE * psf , char x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 1 ) <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> }
","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] =
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 1 ) <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug>
111,CWE-189,"static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , size_t count , loff_t * offp ) { struct f_hidg * hidg = file -> private_data ; struct usb_request * req ; unsigned long flags ; ssize_t status = - ENOMEM ; if ( ! access_ok ( buffer , count ) ) return - EFAULT ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; # define WRITE_COND ( ! hidg -> write_pending ) try_again : while ( ! WRITE_COND ) { spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; if ( file -> f_flags & O_NONBLOCK ) return - EAGAIN ; if ( wait_event_interruptible_exclusive ( hidg -> write_queue , WRITE_COND ) ) return - ERESTARTSYS ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; } hidg -> write_pending = 1 ; req = hidg -> req ; count = min_t ( unsigned , count , hidg -> report_length ) ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; status = copy_from_user ( req -> buf , buffer , count ) ; if ( status != 0 ) { ERROR ( hidg -> func . config -> cdev , ""copy_from_user<S2SV_blank>error\\n"" ) ; status = - EINVAL ; goto release_write_pending ; } spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; if ( ! hidg -> req ) { free_ep_req ( hidg -> in_ep , req ) ; goto try_again ; } req -> status = 0 ; req -> zero = 0 ; req -> length = count ; req -> complete = f_hidg_req_complete ; req -> context = hidg ; <S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> if ( status < 0 ) { ERROR ( hidg -> func . config -> cdev , ""usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n"" , status ) ; <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> } else { status = count ; } <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> return status ; release_write_pending : spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> hidg -> write_pending = 0 ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; wake_up ( & hidg -> write_queue ) ; return status ; }
","<S2SV_ModStart> = hidg ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> ) ; goto release_write_pending <S2SV_ModEnd> ; } else <S2SV_ModStart> count ; } <S2SV_ModEnd> return status ; <S2SV_ModStart> flags ) ; <S2SV_ModEnd> hidg -> write_pending
",torvalds@linux/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036,CVE-2019-14763,https://github.com/torvalds/linux/commit/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036,2019-08-07T22:15Z,"<S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug>"
1695,CWE-119,"<S2SV_StartBug> static void duplicate_mode_info_in_sb ( VP9_COMMON * const cm , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd , <S2SV_EndBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { const int block_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int block_height = num_8x8_blocks_high_lookup [ bsize ] ; int i , j ; for ( j = 0 ; j < block_height ; ++ j ) for ( i = 0 ; i < block_width ; ++ i ) { if ( mi_row + j < cm -> mi_rows && mi_col + i < cm -> mi_cols ) xd -> mi [ j * xd -> mi_stride + i ] = xd -> mi [ 0 ] ; } }
","<S2SV_ModStart> ( VP9_COMMON * <S2SV_ModEnd> cm , MACROBLOCKD <S2SV_ModStart> , MACROBLOCKD * <S2SV_ModEnd> xd , int
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void duplicate_mode_info_in_sb ( VP9_COMMON * const cm , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd , <S2SV_EndBug>"
6699,CWE-476,"static void ov518_mode_init_regs ( struct sd * sd ) { struct gspca_dev * gspca_dev = ( struct gspca_dev * ) sd ; int hsegs , vsegs , packet_size ; struct usb_host_interface * alt ; struct usb_interface * intf ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , ""Couldn\'t<S2SV_blank>get<S2SV_blank>altsetting\\n"" ) ; sd -> gspca_dev . usb_err = - EIO ; return ; } <S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> ov518_reg_w32 ( sd , R51x_FIFO_PSIZE , packet_size & ~ 7 , 2 ) ; reg_w ( sd , 0x2b , 0 ) ; reg_w ( sd , 0x2c , 0 ) ; reg_w ( sd , 0x2d , 0 ) ; reg_w ( sd , 0x2e , 0 ) ; reg_w ( sd , 0x3b , 0 ) ; reg_w ( sd , 0x3c , 0 ) ; reg_w ( sd , 0x3d , 0 ) ; reg_w ( sd , 0x3e , 0 ) ; if ( sd -> bridge == BRIDGE_OV518 ) { reg_w_mask ( sd , 0x20 , 0x08 , 0x08 ) ; reg_w_mask ( sd , 0x28 , 0x80 , 0xf0 ) ; reg_w_mask ( sd , 0x38 , 0x80 , 0xf0 ) ; } else { reg_w ( sd , 0x28 , 0x80 ) ; reg_w ( sd , 0x38 , 0x80 ) ; } hsegs = sd -> gspca_dev . pixfmt . width / 16 ; vsegs = sd -> gspca_dev . pixfmt . height / 4 ; reg_w ( sd , 0x29 , hsegs ) ; reg_w ( sd , 0x2a , vsegs ) ; reg_w ( sd , 0x39 , hsegs ) ; reg_w ( sd , 0x3a , vsegs ) ; reg_w ( sd , 0x2f , 0x80 ) ; if ( sd -> bridge == BRIDGE_OV518PLUS && sd -> revision == 0 && sd -> sensor == SEN_OV7620AE ) sd -> clockdiv = 0 ; else sd -> clockdiv = 1 ; reg_w ( sd , 0x51 , 0x04 ) ; reg_w ( sd , 0x22 , 0x18 ) ; reg_w ( sd , 0x23 , 0xff ) ; if ( sd -> bridge == BRIDGE_OV518PLUS ) { switch ( sd -> sensor ) { case SEN_OV7620AE : if ( sd -> revision > 0 && sd -> gspca_dev . pixfmt . width == 640 ) { reg_w ( sd , 0x20 , 0x60 ) ; reg_w ( sd , 0x21 , 0x1f ) ; } else { reg_w ( sd , 0x20 , 0x00 ) ; reg_w ( sd , 0x21 , 0x19 ) ; } break ; case SEN_OV7620 : reg_w ( sd , 0x20 , 0x00 ) ; reg_w ( sd , 0x21 , 0x19 ) ; break ; default : reg_w ( sd , 0x21 , 0x19 ) ; } } else reg_w ( sd , 0x71 , 0x17 ) ; i2c_w ( sd , 0x54 , 0x23 ) ; reg_w ( sd , 0x2f , 0x80 ) ; if ( sd -> bridge == BRIDGE_OV518PLUS ) { reg_w ( sd , 0x24 , 0x94 ) ; reg_w ( sd , 0x25 , 0x90 ) ; ov518_reg_w32 ( sd , 0xc4 , 400 , 2 ) ; ov518_reg_w32 ( sd , 0xc6 , 540 , 2 ) ; ov518_reg_w32 ( sd , 0xc7 , 540 , 2 ) ; ov518_reg_w32 ( sd , 0xc8 , 108 , 2 ) ; ov518_reg_w32 ( sd , 0xca , 131098 , 3 ) ; ov518_reg_w32 ( sd , 0xcb , 532 , 2 ) ; ov518_reg_w32 ( sd , 0xcc , 2400 , 2 ) ; ov518_reg_w32 ( sd , 0xcd , 32 , 2 ) ; ov518_reg_w32 ( sd , 0xce , 608 , 2 ) ; } else { reg_w ( sd , 0x24 , 0x9f ) ; reg_w ( sd , 0x25 , 0x90 ) ; ov518_reg_w32 ( sd , 0xc4 , 400 , 2 ) ; ov518_reg_w32 ( sd , 0xc6 , 381 , 2 ) ; ov518_reg_w32 ( sd , 0xc7 , 381 , 2 ) ; ov518_reg_w32 ( sd , 0xc8 , 128 , 2 ) ; ov518_reg_w32 ( sd , 0xca , 183331 , 3 ) ; ov518_reg_w32 ( sd , 0xcb , 746 , 2 ) ; ov518_reg_w32 ( sd , 0xcc , 1750 , 2 ) ; ov518_reg_w32 ( sd , 0xcd , 45 , 2 ) ; ov518_reg_w32 ( sd , 0xce , 851 , 2 ) ; } reg_w ( sd , 0x2f , 0x80 ) ; }
","<S2SV_ModStart> return ; } if ( alt -> desc . bNumEndpoints < 1 ) { sd -> gspca_dev . usb_err = - ENODEV ; return ; }
",torvalds@linux/998912346c0da53a6dbb71fab3a138586b596b30,CVE-2020-11608,https://github.com/torvalds/linux/commit/998912346c0da53a6dbb71fab3a138586b596b30,2020-04-07T14:15Z,<S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug>
6768,CWE-295,"static int ssl_verify_cert ( struct tunnel * tunnel ) { int ret = - 1 ; int cert_valid = 0 ; unsigned char digest [ SHA256LEN ] ; unsigned int len ; struct x509_digest * elem ; char digest_str [ SHA256STRLEN ] , * subject , * issuer ; char * line ; int i ; X509_NAME * subj ; <S2SV_StartBug> char common_name [ FIELD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; <S2SV_EndBug> X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gateway<S2SV_blank>certificate.\\n"" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , common_name , FIELD_SIZE , 0 , NULL ) == 1 ) cert_valid = 1 ; # else if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , FIELD_SIZE ) == 0 ) cert_valid = 1 ; # endif if ( cert_valid && SSL_get_verify_result ( tunnel -> ssl_handle ) == X509_V_OK ) { log_debug ( ""Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>succeeded.\\n"" ) ; ret = 0 ; goto free_cert ; } log_debug ( ""Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>failed.\\n"" ) ; if ( X509_digest ( cert , EVP_sha256 ( ) , digest , & len ) <= 0 || len != SHA256LEN ) { log_error ( ""Could<S2SV_blank>not<S2SV_blank>compute<S2SV_blank>certificate<S2SV_blank>sha256<S2SV_blank>digest.\\n"" ) ; goto free_cert ; } for ( i = 0 ; i < SHA256LEN ; i ++ ) sprintf ( & digest_str [ 2 * i ] , ""%02x"" , digest [ i ] ) ; digest_str [ SHA256STRLEN - 1 ] = '\\0' ; for ( elem = tunnel -> config -> cert_whitelist ; elem != NULL ; elem = elem -> next ) if ( memcmp ( digest_str , elem -> data , SHA256STRLEN - 1 ) == 0 ) break ; if ( elem != NULL ) { log_debug ( ""Gateway<S2SV_blank>certificate<S2SV_blank>digest<S2SV_blank>found<S2SV_blank>in<S2SV_blank>white<S2SV_blank>list.\\n"" ) ; ret = 0 ; goto free_cert ; } subject = X509_NAME_oneline ( subj , NULL , 0 ) ; issuer = X509_NAME_oneline ( X509_get_issuer_name ( cert ) , NULL , 0 ) ; log_error ( ""Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>failed,<S2SV_blank>and<S2SV_blank>the<S2SV_blank>certificate<S2SV_blank>digest<S2SV_blank>in<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>local<S2SV_blank>whitelist.<S2SV_blank>If<S2SV_blank>you<S2SV_blank>trust<S2SV_blank>it,<S2SV_blank>rerun<S2SV_blank>with:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--trusted-cert<S2SV_blank>%s\\n"" , digest_str ) ; log_error ( ""or<S2SV_blank>add<S2SV_blank>this<S2SV_blank>line<S2SV_blank>to<S2SV_blank>your<S2SV_blank>config<S2SV_blank>file:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>trusted-cert<S2SV_blank>=<S2SV_blank>%s\\n"" , digest_str ) ; log_error ( ""Gateway<S2SV_blank>certificate:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>subject:\\n"" ) ; for ( line = strtok ( subject , ""/"" ) ; line != NULL ; line = strtok ( NULL , ""/"" ) ) log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" , line ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>issuer:\\n"" ) ; for ( line = strtok ( issuer , ""/"" ) ; line != NULL ; line = strtok ( NULL , ""/"" ) ) log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" , line ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>sha256<S2SV_blank>digest:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" , digest_str ) ; free_cert : X509_free ( cert ) ; return ret ; }
","<S2SV_ModStart> * subj ; SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gateway<S2SV_blank>certificate.\\n"" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , NULL ) == 1 ) cert_valid = 1 ; # else <S2SV_ModStart> 1 ] ; <S2SV_ModEnd> if ( subj
",adrienverge@openfortivpn/9eee997d599a89492281fc7ffdd79d88cd61afc3,CVE-2020-7042,https://github.com/adrienverge/openfortivpn/commit/9eee997d599a89492281fc7ffdd79d88cd61afc3,2020-02-27T18:15Z,"<S2SV_StartBug> char common_name [ FIELD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; <S2SV_EndBug>"
480,CWE-20,"static int __ip6_append_data ( struct sock * sk , struct flowi6 * fl6 , struct sk_buff_head * queue , struct inet_cork * cork , struct inet6_cork * v6_cork , struct page_frag * pfrag , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , unsigned int flags , struct ipcm6_cookie * ipc6 , const struct sockcm_cookie * sockc ) { struct sk_buff * skb , * skb_prev = NULL ; unsigned int maxfraglen , fragheaderlen , mtu , orig_mtu ; int exthdrlen = 0 ; int dst_exthdrlen = 0 ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; u32 tskey = 0 ; struct rt6_info * rt = ( struct rt6_info * ) cork -> dst ; struct ipv6_txoptions * opt = v6_cork -> opt ; int csummode = CHECKSUM_NONE ; unsigned int maxnonfragsize , headersize ; skb = skb_peek_tail ( queue ) ; if ( ! skb ) { exthdrlen = opt ? opt -> opt_flen : 0 ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } mtu = cork -> fragsize ; orig_mtu = mtu ; hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; headersize = sizeof ( struct ipv6hdr ) + ( opt ? opt -> opt_flen + opt -> opt_nflen : 0 ) + ( dst_allfrag ( & rt -> dst ) ? sizeof ( struct frag_hdr ) : 0 ) + rt -> rt6i_nfheader_len ; if ( cork -> length + length > mtu - headersize && ipc6 -> dontfrag && ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_RAW ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; goto emsgsize ; } if ( ip6_sk_ignore_df ( sk ) ) maxnonfragsize = sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ; else maxnonfragsize = mtu ; if ( cork -> length + length > maxnonfragsize - headersize ) { emsgsize : ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; return - EMSGSIZE ; } if ( transhdrlen && sk -> sk_protocol == IPPROTO_UDP && headersize == sizeof ( struct ipv6hdr ) && length <= mtu - headersize && ! ( flags & MSG_MORE ) && rt -> dst . dev -> features & ( NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM ) ) csummode = CHECKSUM_PARTIAL ; if ( sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { sock_tx_timestamp ( sk , sockc -> tsflags , & tx_flags ) ; if ( tx_flags & SKBTX_ANY_SW_TSTAMP && sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) tskey = sk -> sk_tskey ++ ; } cork -> length += length ; if ( ( ( ( length + fragheaderlen ) > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) && ! dst_xfrm ( & rt -> dst ) && ( sk -> sk_type == SOCK_DGRAM ) && ! udp_get_no_check6_tx ( sk ) ) { err = ip6_ufo_append_data ( sk , queue , getfrag , from , length , hh_len , fragheaderlen , exthdrlen , transhdrlen , mtu , flags , fl6 ) ; if ( err ) goto error ; return 0 ; } if ( ! skb ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( ! skb || ! skb_prev ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , orig_mtu ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ; <S2SV_StartBug> if ( transhdrlen ) { <S2SV_EndBug> skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( ! skb ) ) err = - ENOBUFS ; } if ( ! skb ) goto error ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = csummode ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; skb_shinfo ( skb ) -> tx_flags = tx_flags ; tx_flags = 0 ; skb_shinfo ( skb ) -> tskey = tskey ; tskey = 0 ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } <S2SV_StartBug> copy = datalen - transhdrlen - fraggap ; <S2SV_EndBug> if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; if ( ( flags & MSG_CONFIRM ) && ! skb_prev ) skb_set_dst_pending_confirm ( skb , 1 ) ; __skb_queue_tail ( queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }
","<S2SV_ModStart> frag_hdr ) ; copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> ) ; } if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> , offset ,
",torvalds@linux/232cd35d0804cc241eb887bb8d4d9b3b9881c64a,CVE-2017-9242,https://github.com/torvalds/linux/commit/232cd35d0804cc241eb887bb8d4d9b3b9881c64a,2017-05-27T01:29Z,<S2SV_StartBug> if ( transhdrlen ) { <S2SV_EndBug> <S2SV_StartBug> copy = datalen - transhdrlen - fraggap ; <S2SV_EndBug>
2689,CWE-20,"static struct block_device * ext3_blkdev_get ( dev_t dev , struct super_block * sb ) { struct block_device * bdev ; char b [ BDEVNAME_SIZE ] ; bdev = blkdev_get_by_dev ( dev , FMODE_READ | FMODE_WRITE | FMODE_EXCL , sb ) ; if ( IS_ERR ( bdev ) ) goto fail ; return bdev ; fail : <S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , <S2SV_EndBug> __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ; return NULL ; }
","<S2SV_ModStart> ( sb , KERN_ERR ,
",torvalds@linux/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,CVE-2013-1848,https://github.com/torvalds/linux/commit/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,2013-03-22T11:59Z,"<S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , <S2SV_EndBug>"
1460,CWE-119,"struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) { int i ; VP8_COMP * cpi ; VP8_COMMON * cm ; cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; if ( ! cpi ) return 0 ; cm = & cpi -> common ; <S2SV_StartBug> vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ; <S2SV_EndBug> if ( setjmp ( cm -> error . jmp ) ) { cpi -> common . error . setjmp = 0 ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi -> common . error . setjmp = 1 ; CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; init_config ( cpi , oxcf ) ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> common . current_video_frame = 0 ; cpi -> temporal_pattern_counter = 0 ; <S2SV_StartBug> cpi -> kf_overspend_bits = 0 ; <S2SV_EndBug> cpi -> kf_bitrate_adjustment = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> gf_overspend_bits = 0 ; cpi -> non_gf_bitrate_adjustment = 0 ; cpi -> prob_last_coded = 128 ; cpi -> prob_gf_coded = 128 ; cpi -> prob_intra_coded = 63 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ; cpi -> twopass . gf_decay_rate = 0 ; cpi -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; cpi -> gold_is_last = 0 ; cpi -> alt_is_last = 0 ; cpi -> gold_is_alt = 0 ; cpi -> active_map_enabled = 0 ; # if 0 if ( cpi -> pass == 0 ) { cpi -> one_pass_frame_index = 0 ; for ( i = 0 ; i < MAX_LAG_BUFFERS ; i ++ ) { cpi -> one_pass_frame_stats [ i ] . frames_so_far = 0 ; cpi -> one_pass_frame_stats [ i ] . frame_intra_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_coded_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_inter = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_motion = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr_abs = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc_abs = 0.0 ; } } # endif <S2SV_StartBug> cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ; <S2SV_EndBug> <S2SV_StartBug> cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ; <S2SV_EndBug> cpi -> cyclic_refresh_mode_index = 0 ; cpi -> cyclic_refresh_q = 32 ; if ( cpi -> cyclic_refresh_mode_enabled ) { CHECK_MEM_ERROR ( cpi -> cyclic_refresh_map , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; } else cpi -> cyclic_refresh_map = ( signed char * ) NULL ; <S2SV_StartBug> # ifdef VP8_ENTROPY_STATS <S2SV_EndBug> init_context_counters ( ) ; # endif cpi -> activity_avg = 90 << 12 ; cpi -> frames_since_key = 8 ; cpi -> key_frame_frequency = cpi -> oxcf . key_freq ; cpi -> this_key_frame_forced = 0 ; cpi -> next_key_frame_forced = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 0 ; cpi -> common . refresh_alt_ref_frame = 0 ; <S2SV_StartBug> cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ; <S2SV_EndBug> # if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ; cpi -> count = 0 ; cpi -> bytes = 0 ; if ( cpi -> b_calculate_psnr ) { cpi -> total_sq_error = 0.0 ; cpi -> total_sq_error2 = 0.0 ; cpi -> total_y = 0.0 ; cpi -> total_u = 0.0 ; cpi -> total_v = 0.0 ; cpi -> total = 0.0 ; cpi -> totalp_y = 0.0 ; cpi -> totalp_u = 0.0 ; cpi -> totalp_v = 0.0 ; cpi -> totalp = 0.0 ; cpi -> tot_recode_hits = 0 ; cpi -> summed_quality = 0 ; cpi -> summed_weights = 0 ; } if ( cpi -> b_calculate_ssimg ) { cpi -> total_ssimg_y = 0 ; cpi -> total_ssimg_u = 0 ; cpi -> total_ssimg_v = 0 ; cpi -> total_ssimg_all = 0 ; } # endif cpi -> first_time_stamp_ever = 0x7FFFFFFF ; cpi -> frames_till_gf_update_due = 0 ; cpi -> key_frame_count = 1 ; cpi -> ni_av_qi = cpi -> oxcf . worst_allowed_q ; cpi -> ni_tot_qi = 0 ; cpi -> ni_frames = 0 ; cpi -> total_byte_count = 0 ; cpi -> drop_frame = 0 ; cpi -> rate_correction_factor = 1.0 ; cpi -> key_frame_rate_correction_factor = 1.0 ; cpi -> gf_rate_correction_factor = 1.0 ; cpi -> twopass . est_max_qcorrection_factor = 1.0 ; for ( i = 0 ; i < KEY_FRAME_CONTEXT ; i ++ ) { cpi -> prior_key_frame_distance [ i ] = ( int ) cpi -> output_framerate ; } # ifdef OUTPUT_YUV_SRC yuv_file = fopen ( ""bd.yuv"" , ""ab"" ) ; # endif <S2SV_StartBug> # if 0 <S2SV_EndBug> framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ; kf_list = fopen ( ""kf_list.stt"" , ""w"" ) ; # endif cpi -> output_pkt_list = oxcf -> output_pkt_list ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { vp8_init_first_pass ( cpi ) ; } else if ( cpi -> pass == 2 ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int packets = ( int ) ( oxcf -> two_pass_stats_in . sz / packet_sz ) ; cpi -> twopass . stats_in_start = oxcf -> two_pass_stats_in . buf ; cpi -> twopass . stats_in = cpi -> twopass . stats_in_start ; cpi -> twopass . stats_in_end = ( void * ) ( ( char * ) cpi -> twopass . stats_in + ( packets - 1 ) * packet_sz ) ; vp8_init_second_pass ( cpi ) ; } # endif if ( cpi -> compressor_speed == 2 ) { cpi -> avg_encode_time = 0 ; cpi -> avg_pick_mode_time = 0 ; } vp8_set_speed_features ( cpi ) ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mb . rd_thresh_mult [ i ] = 128 ; } # ifdef VP8_ENTROPY_STATS init_mv_ref_counts ( ) ; # endif # if CONFIG_MULTITHREAD if ( vp8cx_create_encoder_threads ( cpi ) ) { vp8_remove_compressor ( & cpi ) ; return 0 ; } # endif <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ; <S2SV_EndBug> cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_hv = NULL ; <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ; <S2SV_EndBug> cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_hv = NULL ; <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ; <S2SV_EndBug> cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_hv = NULL ; <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ; <S2SV_EndBug> cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_hv = NULL ; <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ; <S2SV_EndBug> # if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_16X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_4X4 ] . copymem = vp8_copy32xn ; # endif cpi -> full_search_sad = vp8_full_search_sad ; cpi -> diamond_search_sad = vp8_diamond_search_sad ; cpi -> refining_search_sad = vp8_refining_search_sad ; cpi -> mb . error_bins [ 0 ] = cpi -> common . MBs ; vp8cx_init_quantizer ( cpi ) ; vp8_loop_filter_init ( cm ) ; cpi -> common . error . setjmp = 0 ; # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id > 0 ) vp8_cal_low_res_mb_cols ( cpi ) ; # endif cpi -> mb . mvcost [ 0 ] = & cpi -> rd_costs . mvcosts [ 0 ] [ mv_max + 1 ] ; cpi -> mb . mvcost [ 1 ] = & cpi -> rd_costs . mvcosts [ 1 ] [ mv_max + 1 ] ; cpi -> mb . mvsadcost [ 0 ] = & cpi -> rd_costs . mvsadcosts [ 0 ] [ mvfp_max + 1 ] ; cpi -> mb . mvsadcost [ 1 ] = & cpi -> rd_costs . mvsadcosts [ 1 ] [ mvfp_max + 1 ] ; cal_mvsadcosts ( cpi -> mb . mvsadcost ) ; cpi -> mb . mbmode_cost = cpi -> rd_costs . mbmode_cost ; cpi -> mb . intra_uv_mode_cost = cpi -> rd_costs . intra_uv_mode_cost ; cpi -> mb . bmode_costs = cpi -> rd_costs . bmode_costs ; cpi -> mb . inter_bmode_costs = cpi -> rd_costs . inter_bmode_costs ; cpi -> mb . token_costs = cpi -> rd_costs . token_costs ; vp8_setup_block_ptrs ( & cpi -> mb ) ; vp8_setup_block_dptrs ( & cpi -> mb . e_mbd ) ; return cpi ; }
","<S2SV_ModStart> -> common ; memset <S2SV_ModEnd> ( cpi , <S2SV_ModStart> ; cpi -> temporal_layer_id = - 1 ; cpi -> <S2SV_ModStart> endif cpi -> mse_source_denoised = 0 ; cpi -> <S2SV_ModStart> / 5 ; if ( cpi -> oxcf . number_of_layers == 1 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } else if ( cpi -> oxcf . number_of_layers == 2 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } <S2SV_ModStart> ) NULL ; CHECK_MEM_ERROR ( cpi -> consec_zero_last , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , 1 ) ) ; CHECK_MEM_ERROR ( cpi -> consec_zero_last_mvbias , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; <S2SV_ModStart> ; cpi -> force_maxqp = 0 ; cpi -> <S2SV_ModStart> # endif # ifdef OUTPUT_YUV_DENOISED yuv_denoised_file = fopen ( ""denoised.yuv"" , ""ab"" ) ; # endif # <S2SV_ModStart> . sdf = vpx_sad16x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . vf = vpx_variance16x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf = vpx_sub_pixel_variance16x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf_halfpix_h = vpx_variance_halfpixvar16x16_h <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf_halfpix_v = vpx_variance_halfpixvar16x16_v <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf_halfpix_hv = vpx_variance_halfpixvar16x16_hv <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx3f = vpx_sad16x16x3 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx8f = vpx_sad16x16x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx4df = vpx_sad16x16x4d <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdf = vpx_sad16x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . vf = vpx_variance16x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf = vpx_sub_pixel_variance16x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx3f = vpx_sad16x8x3 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx8f = vpx_sad16x8x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx4df = vpx_sad16x8x4d <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdf = vpx_sad8x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . vf = vpx_variance8x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf = vpx_sub_pixel_variance8x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx3f = vpx_sad8x16x3 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx8f = vpx_sad8x16x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx4df = vpx_sad8x16x4d <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdf = vpx_sad8x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . vf = vpx_variance8x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf = vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx3f = vpx_sad8x8x3 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx8f = vpx_sad8x8x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx4df = vpx_sad8x8x4d <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdf = vpx_sad4x4 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . vf = vpx_variance4x4 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf = vpx_sub_pixel_variance4x4 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx3f = vpx_sad4x4x3 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx8f = vpx_sad4x4x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx4df = vpx_sad4x4x4d <S2SV_ModEnd> ; # if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> kf_overspend_bits = 0 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ; <S2SV_EndBug> <S2SV_StartBug> cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ; <S2SV_EndBug> <S2SV_StartBug> # ifdef VP8_ENTROPY_STATS <S2SV_EndBug> <S2SV_StartBug> cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ; <S2SV_EndBug> <S2SV_StartBug> # if 0 <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ; <S2SV_EndBug>"
783,CWE-269,"void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) { <S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""...\\n"" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = ""."" ; Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""<S2SV_blank>from<S2SV_blank>\\""%s\\""...\\n"" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( ""fs_basepath"" ) ; if ( ! basePath || ! * basePath ) basePath = ""."" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""<S2SV_blank>from<S2SV_blank>\\""%s\\""...\\n"" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( ""Loading<S2SV_blank>\\""%s\\""<S2SV_blank>failed\\n"" , name ) ; } } return dllhandle ; }
","<S2SV_ModStart> * dllhandle ; if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; }
",ioquake@ioq3/376267d534476a875d8b9228149c4ee18b74a4fd,CVE-2017-6903,https://github.com/ioquake/ioq3/commit/376267d534476a875d8b9228149c4ee18b74a4fd,2017-03-14T22:59Z,<S2SV_StartBug> void * dllhandle ; <S2SV_EndBug>
340,CWE-20,"static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if (
",ImageMagick@ImageMagick/16916c8979c32765c542e216b31cee2671b7afe7,CVE-2018-16644,https://github.com/ImageMagick/ImageMagick/commit/16916c8979c32765c542e216b31cee2671b7afe7,2018-09-06T22:29Z,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug>"
625,CWE-476,"static gint dissect_ac_if_hdr_body ( tvbuff_t * tvb , gint offset , packet_info * pinfo _U_ , proto_tree * tree , usb_conv_info_t * usb_conv_info ) { gint offset_start ; guint16 bcdADC ; guint8 ver_major ; double ver ; guint8 if_in_collection , i ; audio_conv_info_t * audio_conv_info ; offset_start = offset ; bcdADC = tvb_get_letohs ( tvb , offset ) ; ver_major = USB_AUDIO_BCD44_TO_DEC ( bcdADC >> 8 ) ; ver = ver_major + USB_AUDIO_BCD44_TO_DEC ( bcdADC & 0xFF ) / 100.0 ; proto_tree_add_double_format_value ( tree , hf_ac_if_hdr_ver , tvb , offset , 2 , ver , ""%2.2f"" , ver ) ; audio_conv_info = ( audio_conv_info_t * ) usb_conv_info -> class_data ; if ( ! audio_conv_info ) { audio_conv_info = wmem_new ( wmem_file_scope ( ) , audio_conv_info_t ) ; usb_conv_info -> class_data = audio_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> audio_conv_info -> ver_major = ver_major ; offset += 2 ; if ( ver_major == 1 ) { proto_tree_add_item ( tree , hf_ac_if_hdr_total_len , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; offset += 2 ; if_in_collection = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( tree , hf_ac_if_hdr_bInCollection , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; for ( i = 0 ; i < if_in_collection ; i ++ ) { proto_tree_add_item ( tree , hf_ac_if_hdr_if_num , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; } } return offset - offset_start ; }
","<S2SV_ModStart> = audio_conv_info ; usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ;
",wireshark@wireshark/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,CVE-2016-5354,https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,2016-08-07T16:59Z,<S2SV_StartBug> } <S2SV_EndBug>
3437,CWE-476,"void build_ntlmssp_negotiate_blob ( unsigned char * pbuffer , struct cifs_ses * ses ) { NEGOTIATE_MESSAGE * sec_blob = ( NEGOTIATE_MESSAGE * ) pbuffer ; __u32 flags ; memset ( pbuffer , 0 , sizeof ( NEGOTIATE_MESSAGE ) ) ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmNegotiate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | <S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_StartBug> } <S2SV_EndBug> sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> WorkstationName . BufferOffset = 0 ; sec_blob -> WorkstationName . Length = 0 ; sec_blob -> WorkstationName . MaximumLength = 0 ; sec_blob -> DomainName . BufferOffset = 0 ; sec_blob -> DomainName . Length = 0 ; sec_blob -> DomainName . MaximumLength = 0 ; }
","<S2SV_ModStart> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN <S2SV_ModStart> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> sec_blob -> NegotiateFlags
",torvalds@linux/cabfb3680f78981d26c078a26e5c748531257ebb,CVE-2018-1066,https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb,2018-03-02T08:29Z,<S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
4133,CWE-17,"static void f_parser ( lua_State * L , void * ud ) { int i ; Proto * tf ; Closure * cl ; struct SParser * p = cast ( struct SParser * , ud ) ; int c = luaZ_lookahead ( p -> z ) ; luaC_checkGC ( L ) ; <S2SV_StartBug> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , <S2SV_EndBug> & p -> buff , p -> name ) ; cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ; cl -> l . p = tf ; for ( i = 0 ; i < tf -> nups ; i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ; setclvalue ( L , L -> top , cl ) ; incr_top ( L ) ; }
","<S2SV_ModStart> tf = ( <S2SV_ModEnd> luaY_parser ) (
",antirez@redis/fdf9d455098f54f7666c702ae464e6ea21e25411,CVE-2015-4335,https://github.com/antirez/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411,2015-06-09T14:59Z,"<S2SV_StartBug> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , <S2SV_EndBug>"
2723,CWE-125,"static void send_ssi_file ( struct mg_connection * conn , const char * path , struct mg_file * filep , int include_level ) { char buf [ MG_BUF_LEN ] ; int ch , offset , len , in_tag , in_ssi_tag ; if ( include_level > 10 ) { mg_cry_internal ( conn , ""SSI<S2SV_blank>#include<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>deep<S2SV_blank>(%s)"" , path ) ; return ; } in_tag = in_ssi_tag = len = offset = 0 ; while ( ( ch = mg_fgetc ( filep , offset ++ ) ) != EOF ) { if ( in_tag ) { if ( ch == '>' ) { buf [ len ++ ] = '>' ; if ( in_ssi_tag ) { buf [ len ] = 0 ; <S2SV_StartBug> if ( ! memcmp ( buf + 5 , ""include"" , 7 ) ) { <S2SV_EndBug> do_ssi_include ( conn , path , buf + 12 , include_level + 1 ) ; # if ! defined ( NO_POPEN ) <S2SV_StartBug> } else if ( ! memcmp ( buf + 5 , ""exec"" , 4 ) ) { <S2SV_EndBug> do_ssi_exec ( conn , buf + 9 ) ; # endif } else { mg_cry_internal ( conn , ""%s:<S2SV_blank>unknown<S2SV_blank>SSI<S2SV_blank>"" ""command:<S2SV_blank>\\""%s\\"""" , path , buf ) ; } len = 0 ; in_ssi_tag = in_tag = 0 ; } else { ( void ) mg_write ( conn , buf , ( size_t ) len ) ; len = 0 ; in_tag = 0 ; } } else { buf [ len ++ ] = ( char ) ( ch & 0xff ) ; if ( ( len == 5 ) && ! memcmp ( buf , ""<!--#"" , 5 ) ) { in_ssi_tag = 1 ; } if ( ( len + 2 ) > ( int ) sizeof ( buf ) ) { mg_cry_internal ( conn , ""%s:<S2SV_blank>tag<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" , path ) ; return ; } } } else { if ( ch == '<' ) { in_tag = 1 ; if ( len > 0 ) { ( void ) mg_write ( conn , buf , ( size_t ) len ) ; } len = 1 ; buf [ 0 ] = '<' ; } else { buf [ len ++ ] = ( char ) ( ch & 0xff ) ; if ( len == ( int ) sizeof ( buf ) ) { mg_write ( conn , buf , ( size_t ) len ) ; len = 0 ; } } } } if ( len > 0 ) { mg_write ( conn , buf , ( size_t ) len ) ; } }
","<S2SV_ModStart> ; if ( ( len > 12 ) && <S2SV_ModStart> else if ( ( len > 9 ) &&
",civetweb@civetweb/8fd069f6dedb064339f1091069ac96f3f8bdb552,CVE-2018-12684,https://github.com/civetweb/civetweb/commit/8fd069f6dedb064339f1091069ac96f3f8bdb552,2018-06-22T19:29Z,"<S2SV_StartBug> if ( ! memcmp ( buf + 5 , ""include"" , 7 ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( ! memcmp ( buf + 5 , ""exec"" , 4 ) ) { <S2SV_EndBug>"
85,CWE-190,"static long vfio_pci_ioctl ( void * device_data , unsigned int cmd , unsigned long arg ) { struct vfio_pci_device * vdev = device_data ; unsigned long minsz ; if ( cmd == VFIO_DEVICE_GET_INFO ) { struct vfio_device_info info ; minsz = offsetofend ( struct vfio_device_info , num_irqs ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; info . flags = VFIO_DEVICE_FLAGS_PCI ; if ( vdev -> reset_works ) info . flags |= VFIO_DEVICE_FLAGS_RESET ; info . num_regions = VFIO_PCI_NUM_REGIONS + vdev -> num_regions ; info . num_irqs = VFIO_PCI_NUM_IRQS ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_GET_REGION_INFO ) { struct pci_dev * pdev = vdev -> pdev ; struct vfio_region_info info ; struct vfio_info_cap caps = { . buf = NULL , . size = 0 } ; int i , ret ; minsz = offsetofend ( struct vfio_region_info , offset ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; switch ( info . index ) { case VFIO_PCI_CONFIG_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = pdev -> cfg_size ; info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; break ; case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = pci_resource_len ( pdev , info . index ) ; if ( ! info . size ) { info . flags = 0 ; break ; } info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; if ( vdev -> bar_mmap_supported [ info . index ] ) { info . flags |= VFIO_REGION_INFO_FLAG_MMAP ; if ( info . index == vdev -> msix_bar ) { ret = msix_sparse_mmap_cap ( vdev , & caps ) ; if ( ret ) return ret ; } } break ; case VFIO_PCI_ROM_REGION_INDEX : { void __iomem * io ; size_t size ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . flags = 0 ; info . size = pci_resource_len ( pdev , info . index ) ; if ( ! info . size ) { if ( pdev -> resource [ PCI_ROM_RESOURCE ] . flags & IORESOURCE_ROM_SHADOW ) info . size = 0x20000 ; else break ; } io = pci_map_rom ( pdev , & size ) ; if ( ! io || ! size ) { info . size = 0 ; break ; } pci_unmap_rom ( pdev , io ) ; info . flags = VFIO_REGION_INFO_FLAG_READ ; break ; } case VFIO_PCI_VGA_REGION_INDEX : if ( ! vdev -> has_vga ) return - EINVAL ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = 0xc0000 ; info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; break ; default : if ( info . index >= VFIO_PCI_NUM_REGIONS + vdev -> num_regions ) return - EINVAL ; i = info . index - VFIO_PCI_NUM_REGIONS ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = vdev -> region [ i ] . size ; info . flags = vdev -> region [ i ] . flags ; ret = region_type_cap ( vdev , & caps , vdev -> region [ i ] . type , vdev -> region [ i ] . subtype ) ; if ( ret ) return ret ; } if ( caps . size ) { info . flags |= VFIO_REGION_INFO_FLAG_CAPS ; if ( info . argsz < sizeof ( info ) + caps . size ) { info . argsz = sizeof ( info ) + caps . size ; info . cap_offset = 0 ; } else { vfio_info_cap_shift ( & caps , sizeof ( info ) ) ; if ( copy_to_user ( ( void __user * ) arg + sizeof ( info ) , caps . buf , caps . size ) ) { kfree ( caps . buf ) ; return - EFAULT ; } info . cap_offset = sizeof ( info ) ; } kfree ( caps . buf ) ; } return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_GET_IRQ_INFO ) { struct vfio_irq_info info ; minsz = offsetofend ( struct vfio_irq_info , count ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz || info . index >= VFIO_PCI_NUM_IRQS ) return - EINVAL ; switch ( info . index ) { case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX : case VFIO_PCI_REQ_IRQ_INDEX : break ; case VFIO_PCI_ERR_IRQ_INDEX : if ( pci_is_pcie ( vdev -> pdev ) ) break ; default : return - EINVAL ; } info . flags = VFIO_IRQ_INFO_EVENTFD ; info . count = vfio_pci_get_irq_count ( vdev , info . index ) ; if ( info . index == VFIO_PCI_INTX_IRQ_INDEX ) info . flags |= ( VFIO_IRQ_INFO_MASKABLE | VFIO_IRQ_INFO_AUTOMASKED ) ; else info . flags |= VFIO_IRQ_INFO_NORESIZE ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_SET_IRQS ) { struct vfio_irq_set hdr ; <S2SV_StartBug> u8 * data = NULL ; <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> minsz = offsetofend ( struct vfio_irq_set , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz || hdr . index >= VFIO_PCI_NUM_IRQS || <S2SV_StartBug> hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK | <S2SV_EndBug> VFIO_IRQ_SET_ACTION_TYPE_MASK ) ) return - EINVAL ; <S2SV_StartBug> if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) { <S2SV_EndBug> size_t size ; int max = vfio_pci_get_irq_count ( vdev , hdr . index ) ; <S2SV_StartBug> if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL ) <S2SV_EndBug> size = sizeof ( uint8_t ) ; else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ; else return - EINVAL ; if ( hdr . argsz - minsz < hdr . count * size || <S2SV_StartBug> hdr . start >= max || hdr . start + hdr . count > max ) <S2SV_EndBug> return - EINVAL ; data = memdup_user ( ( void __user * ) ( arg + minsz ) , hdr . count * size ) ; if ( IS_ERR ( data ) ) return PTR_ERR ( data ) ; } mutex_lock ( & vdev -> igate ) ; ret = vfio_pci_set_irqs_ioctl ( vdev , hdr . flags , hdr . index , hdr . start , hdr . count , data ) ; mutex_unlock ( & vdev -> igate ) ; kfree ( data ) ; return ret ; } else if ( cmd == VFIO_DEVICE_RESET ) { return vdev -> reset_works ? pci_try_reset_function ( vdev -> pdev ) : - EINVAL ; } else if ( cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO ) { struct vfio_pci_hot_reset_info hdr ; struct vfio_pci_fill_info fill = { 0 } ; struct vfio_pci_dependent_device * devices = NULL ; bool slot = false ; int ret = 0 ; minsz = offsetofend ( struct vfio_pci_hot_reset_info , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz ) return - EINVAL ; hdr . flags = 0 ; if ( ! pci_probe_reset_slot ( vdev -> pdev -> slot ) ) slot = true ; else if ( pci_probe_reset_bus ( vdev -> pdev -> bus ) ) return - ENODEV ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_count_devs , & fill . max , slot ) ; if ( ret ) return ret ; WARN_ON ( ! fill . max ) ; if ( hdr . argsz < sizeof ( hdr ) + ( fill . max * sizeof ( * devices ) ) ) { ret = - ENOSPC ; hdr . count = fill . max ; goto reset_info_exit ; } devices = kcalloc ( fill . max , sizeof ( * devices ) , GFP_KERNEL ) ; if ( ! devices ) return - ENOMEM ; fill . devices = devices ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_fill_devs , & fill , slot ) ; if ( ! ret ) hdr . count = fill . cur ; reset_info_exit : if ( copy_to_user ( ( void __user * ) arg , & hdr , minsz ) ) ret = - EFAULT ; if ( ! ret ) { if ( copy_to_user ( ( void __user * ) ( arg + minsz ) , devices , hdr . count * sizeof ( * devices ) ) ) ret = - EFAULT ; } kfree ( devices ) ; return ret ; } else if ( cmd == VFIO_DEVICE_PCI_HOT_RESET ) { struct vfio_pci_hot_reset hdr ; int32_t * group_fds ; struct vfio_pci_group_entry * groups ; struct vfio_pci_group_info info ; bool slot = false ; int i , count = 0 , ret = 0 ; minsz = offsetofend ( struct vfio_pci_hot_reset , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz || hdr . flags ) return - EINVAL ; if ( ! pci_probe_reset_slot ( vdev -> pdev -> slot ) ) slot = true ; else if ( pci_probe_reset_bus ( vdev -> pdev -> bus ) ) return - ENODEV ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_count_devs , & count , slot ) ; if ( ret ) return ret ; if ( ! hdr . count || hdr . count > count ) return - EINVAL ; group_fds = kcalloc ( hdr . count , sizeof ( * group_fds ) , GFP_KERNEL ) ; groups = kcalloc ( hdr . count , sizeof ( * groups ) , GFP_KERNEL ) ; if ( ! group_fds || ! groups ) { kfree ( group_fds ) ; kfree ( groups ) ; return - ENOMEM ; } if ( copy_from_user ( group_fds , ( void __user * ) ( arg + minsz ) , hdr . count * sizeof ( * group_fds ) ) ) { kfree ( group_fds ) ; kfree ( groups ) ; return - EFAULT ; } for ( i = 0 ; i < hdr . count ; i ++ ) { struct vfio_group * group ; struct fd f = fdget ( group_fds [ i ] ) ; if ( ! f . file ) { ret = - EBADF ; break ; } group = vfio_group_get_external_user ( f . file ) ; fdput ( f ) ; if ( IS_ERR ( group ) ) { ret = PTR_ERR ( group ) ; break ; } groups [ i ] . group = group ; groups [ i ] . id = vfio_external_user_iommu_id ( group ) ; } kfree ( group_fds ) ; if ( ret ) goto hot_reset_release ; info . count = hdr . count ; info . groups = groups ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_validate_devs , & info , slot ) ; if ( ! ret ) ret = slot ? pci_try_reset_slot ( vdev -> pdev -> slot ) : pci_try_reset_bus ( vdev -> pdev -> bus ) ; hot_reset_release : for ( i -- ; i >= 0 ; i -- ) vfio_group_put_external_user ( groups [ i ] . group ) ; kfree ( groups ) ; return ret ; } return - ENOTTY ; }
","<S2SV_ModStart> vfio_irq_set hdr ; size_t size ; <S2SV_ModStart> NULL ; int max , <S2SV_ModStart> || hdr . count >= ( U32_MAX - hdr . start ) || hdr . <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> max = vfio_pci_get_irq_count <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdr . start <S2SV_ModStart> count > max ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size
",torvalds@linux/05692d7005a364add85c6e25a6c4447ce08f913a,CVE-2016-9084,https://github.com/torvalds/linux/commit/05692d7005a364add85c6e25a6c4447ce08f913a,2016-11-28T03:59Z,<S2SV_StartBug> u8 * data = NULL ; <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK | <S2SV_EndBug> <S2SV_StartBug> if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL ) <S2SV_EndBug> <S2SV_StartBug> hdr . start >= max || hdr . start + hdr . count > max ) <S2SV_EndBug>
6055,CWE-000,"static void dump_completed_IO ( struct inode * inode ) { # ifdef EXT4_DEBUG struct list_head * cur , * before , * after ; ext4_io_end_t * io , * io0 , * io1 ; <S2SV_StartBug> if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) { <S2SV_EndBug> ext4_debug ( ""inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>is<S2SV_blank>empty\\n"" , inode -> i_ino ) ; return ; } <S2SV_StartBug> ext4_debug ( ""Dump<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>\\n"" , inode -> i_ino ) ; <S2SV_EndBug> list_for_each_entry ( io , & EXT4_I ( inode ) -> i_completed_io_list , list ) { cur = & io -> list ; before = cur -> prev ; io0 = container_of ( before , ext4_io_end_t , list ) ; after = cur -> next ; io1 = container_of ( after , ext4_io_end_t , list ) ; ext4_debug ( ""io<S2SV_blank>0x%p<S2SV_blank>from<S2SV_blank>inode<S2SV_blank>%lu,prev<S2SV_blank>0x%p,next<S2SV_blank>0x%p\\n"" , io , inode -> i_ino , io0 , io1 ) ; } <S2SV_StartBug> # endif <S2SV_EndBug> }
","<S2SV_ModStart> * io1 ; unsigned long flags ; <S2SV_ModStart> inode -> i_ino ) ; spin_lock_irqsave ( & EXT4_I ( inode ) -> i_completed_io_lock , flags <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & EXT4_I ( inode ) -> i_completed_io_lock , flags ) ;
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,"<S2SV_StartBug> if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) { <S2SV_EndBug> <S2SV_StartBug> ext4_debug ( ""Dump<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>\\n"" , inode -> i_ino ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug>"
4793,CWE-327,"int wc_SignatureGenerate ( enum wc_HashType hash_type , enum wc_SignatureType sig_type , const byte * data , word32 data_len , byte * sig , word32 * sig_len , const void * key , word32 key_len , WC_RNG * rng ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> word32 hash_len , hash_enc_len ; # ifdef WOLFSSL_SMALL_STACK byte * hash_data ; # else byte hash_data [ MAX_DER_DIGEST_SZ ] ; # endif if ( data == NULL || data_len <= 0 || sig == NULL || sig_len == NULL || * sig_len <= 0 || key == NULL || key_len <= 0 ) { return BAD_FUNC_ARG ; } if ( ( int ) * sig_len < wc_SignatureGetSize ( sig_type , key , key_len ) ) { WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>sig<S2SV_blank>type/len"" ) ; return BAD_FUNC_ARG ; } ret = wc_HashGetDigestSize ( hash_type ) ; if ( ret < 0 ) { WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>hash<S2SV_blank>type/len"" ) ; return ret ; } hash_enc_len = hash_len = ret ; # if ! defined ( NO_RSA ) && ! defined ( WOLFSSL_RSA_PUBLIC_ONLY ) if ( sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC ) { hash_enc_len += MAX_DER_DIGEST_ASN_SZ ; } # endif # ifdef WOLFSSL_SMALL_STACK hash_data = ( byte * ) XMALLOC ( hash_enc_len , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ; if ( hash_data == NULL ) { return MEMORY_E ; } # endif <S2SV_StartBug> ret = wc_Hash ( hash_type , data , data_len , hash_data , hash_len ) ; <S2SV_EndBug> if ( ret == 0 ) { if ( sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC ) { # if defined ( NO_RSA ) || defined ( NO_ASN ) || defined ( WOLFSSL_RSA_PUBLIC_ONLY ) ret = SIG_TYPE_E ; # else ret = wc_SignatureDerEncode ( hash_type , hash_data , hash_len , & hash_enc_len ) ; # endif } if ( ret == 0 ) { ret = wc_SignatureGenerateHash ( hash_type , sig_type , <S2SV_StartBug> hash_data , hash_enc_len , sig , sig_len , key , key_len , rng ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug> # ifdef WOLFSSL_SMALL_STACK XFREE ( hash_data , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ; # endif return ret ; }
","<S2SV_ModStart> rng ) { return wc_SignatureGenerate_ex ( hash_type , sig_type <S2SV_ModEnd> , data , <S2SV_ModStart> , data_len , sig , <S2SV_ModEnd> sig_len , key <S2SV_ModStart> key_len , rng , 1 <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",wolfSSL@wolfssl/23878512c65834d12811b1107d19a001478eca5d,CVE-2019-19962,https://github.com/wolfSSL/wolfssl/commit/23878512c65834d12811b1107d19a001478eca5d,2019-12-25T00:15Z,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = wc_Hash ( hash_type , data , data_len , hash_data , hash_len ) ; <S2SV_EndBug> <S2SV_StartBug> hash_data , hash_enc_len , sig , sig_len , key , key_len , rng ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
8189,CWE-17,"static void parseFirstLine ( Webs * wp ) { char * op , * protoVer , * url , * host , * query , * path , * port , * ext , * buf ; int listenPort ; assert ( wp ) ; assert ( websValid ( wp ) ) ; op = getToken ( wp , 0 ) ; if ( op == NULL || * op == '\\0' ) { websError ( wp , HTTP_CODE_NOT_FOUND | WEBS_CLOSE , ""Bad<S2SV_blank>HTTP<S2SV_blank>request"" ) ; return ; } wp -> method = supper ( sclone ( op ) ) ; url = getToken ( wp , 0 ) ; if ( url == NULL || * url == '\\0' ) { websError ( wp , HTTP_CODE_BAD_REQUEST | WEBS_CLOSE , ""Bad<S2SV_blank>HTTP<S2SV_blank>request"" ) ; return ; } if ( strlen ( url ) > ME_GOAHEAD_LIMIT_URI ) { websError ( wp , HTTP_CODE_REQUEST_URL_TOO_LARGE | WEBS_CLOSE , ""URI<S2SV_blank>too<S2SV_blank>big"" ) ; return ; } protoVer = getToken ( wp , ""\\r\\n"" ) ; if ( websGetLogLevel ( ) == 2 ) { trace ( 2 , ""%s<S2SV_blank>%s<S2SV_blank>%s"" , wp -> method , url , protoVer ) ; } host = path = port = query = ext = NULL ; if ( websUrlParse ( url , & buf , NULL , & host , & port , & path , & ext , NULL , & query ) < 0 ) { error ( ""Cannot<S2SV_blank>parse<S2SV_blank>URL:<S2SV_blank>%s"" , url ) ; websError ( wp , HTTP_CODE_BAD_REQUEST | WEBS_CLOSE | WEBS_NOLOG , ""Bad<S2SV_blank>URL"" ) ; return ; } <S2SV_StartBug> if ( ( wp -> path = websNormalizeUriPath ( path ) ) == 0 ) { <S2SV_EndBug> error ( ""Cannot<S2SV_blank>normalize<S2SV_blank>URL:<S2SV_blank>%s"" , url ) ; websError ( wp , HTTP_CODE_BAD_REQUEST | WEBS_CLOSE | WEBS_NOLOG , ""Bad<S2SV_blank>URL"" ) ; wfree ( buf ) ; return ; } wp -> url = sclone ( url ) ; if ( ext ) { wp -> ext = sclone ( slower ( ext ) ) ; } wp -> filename = sfmt ( ""%s%s"" , websGetDocuments ( ) , wp -> path ) ; wp -> query = sclone ( query ) ; wp -> host = sclone ( host ) ; wp -> protocol = wp -> flags & WEBS_SECURE ? ""https"" : ""http"" ; if ( smatch ( protoVer , ""HTTP/1.1"" ) ) { wp -> flags |= WEBS_KEEP_ALIVE | WEBS_HTTP11 ; } else if ( smatch ( protoVer , ""HTTP/1.0"" ) ) { wp -> flags &= ~ ( WEBS_HTTP11 ) ; } else { protoVer = sclone ( ""HTTP/1.1"" ) ; websError ( wp , WEBS_CLOSE | HTTP_CODE_NOT_ACCEPTABLE , ""Unsupported<S2SV_blank>HTTP<S2SV_blank>protocol"" ) ; } wp -> protoVersion = sclone ( protoVer ) ; if ( ( listenPort = socketGetPort ( wp -> listenSid ) ) >= 0 ) { wp -> port = listenPort ; } else { wp -> port = atoi ( port ) ; } wfree ( buf ) ; }
","<S2SV_ModStart> -> path = websValidateUriPath <S2SV_ModEnd> ( path )
",embedthis@goahead/eed4a7d177bf94a54c7b06ccce88507fbd76fb77,CVE-2014-9707,https://github.com/embedthis/goahead/commit/eed4a7d177bf94a54c7b06ccce88507fbd76fb77,2015-03-31T14:59Z,<S2SV_StartBug> if ( ( wp -> path = websNormalizeUriPath ( path ) ) == 0 ) { <S2SV_EndBug>
3362,CWE-119,"static int magicmouse_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * data , int size ) { struct magicmouse_sc * msc = hid_get_drvdata ( hdev ) ; struct input_dev * input = msc -> input ; int x = 0 , y = 0 , ii , clicks = 0 , npoints ; switch ( data [ 0 ] ) { case TRACKPAD_REPORT_ID : if ( size < 4 || ( ( size - 4 ) % 9 ) != 0 ) return 0 ; npoints = ( size - 4 ) / 9 ; <S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 9 + 4 ) ; clicks = data [ 1 ] ; break ; case MOUSE_REPORT_ID : if ( size < 6 || ( ( size - 6 ) % 8 ) != 0 ) return 0 ; <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug> msc -> ntouches = 0 ; for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 8 + 6 ) ; x = ( int ) ( ( ( data [ 3 ] & 0x0c ) << 28 ) | ( data [ 1 ] << 22 ) ) >> 22 ; y = ( int ) ( ( ( data [ 3 ] & 0x30 ) << 26 ) | ( data [ 2 ] << 22 ) ) >> 22 ; clicks = data [ 3 ] ; break ; case DOUBLE_REPORT_ID : magicmouse_raw_event ( hdev , report , data + 2 , data [ 1 ] ) ; magicmouse_raw_event ( hdev , report , data + 2 + data [ 1 ] , size - 2 - data [ 1 ] ) ; break ; default : return 0 ; } if ( input -> id . product == USB_DEVICE_ID_APPLE_MAGICMOUSE ) { magicmouse_emit_buttons ( msc , clicks & 3 ) ; input_report_rel ( input , REL_X , x ) ; input_report_rel ( input , REL_Y , y ) ; } else { input_report_key ( input , BTN_MOUSE , clicks & 1 ) ; input_mt_report_pointer_emulation ( input , true ) ; } input_sync ( input ) ; return 1 ; }
","<S2SV_ModStart> / 9 ; if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n"" , size ) ; return 0 ; } <S2SV_ModStart> / 8 ; if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n"" , size ) ; return 0 ; }
",torvalds@linux/c54def7bd64d7c0b6993336abcffb8444795bf38,CVE-2014-3181,https://github.com/torvalds/linux/commit/c54def7bd64d7c0b6993336abcffb8444795bf38,2014-09-28T10:55Z,<S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug>
1887,CWE-119,"<S2SV_StartBug> static INLINE int write_bit_gte ( vp9_writer * w , int word , int test ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word >= test , 1 ) ; <S2SV_EndBug> return word >= test ; }
","<S2SV_ModStart> int write_bit_gte ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> test ) { vpx_write_literal <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static INLINE int write_bit_gte ( vp9_writer * w , int word , int test ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word >= test , 1 ) ; <S2SV_EndBug>"
2296,CWE-000,"unsigned int get_random_int ( void ) { <S2SV_StartBug> struct keydata * keyptr ; <S2SV_EndBug> __u32 * hash = get_cpu_var ( get_random_int_hash ) ; <S2SV_StartBug> int ret ; <S2SV_EndBug> keyptr = get_keyptr ( ) ; hash [ 0 ] += current -> pid + jiffies + get_cycles ( ) ; <S2SV_StartBug> ret = half_md4_transform ( hash , keyptr -> secret ) ; <S2SV_EndBug> put_cpu_var ( get_random_int_hash ) ; return ret ; }
","<S2SV_ModStart> void ) { <S2SV_ModEnd> __u32 * hash <S2SV_ModStart> get_random_int_hash ) ; unsigned int ret <S2SV_ModEnd> ; hash [ <S2SV_ModStart> ( ) ; md5_transform <S2SV_ModEnd> ( hash , <S2SV_ModStart> ( hash , random_int_secret ) ; ret = hash [ 0 ] <S2SV_ModEnd> ; put_cpu_var (
",torvalds@linux/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec,CVE-2011-3188,https://github.com/torvalds/linux/commit/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec,2012-05-24T23:55Z,"<S2SV_StartBug> struct keydata * keyptr ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = half_md4_transform ( hash , keyptr -> secret ) ; <S2SV_EndBug>"
1811,CWE-119,"static int rc_pick_q_and_bounds_two_pass ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { const VP9_COMMON * const cm = & cpi -> common ; const RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int active_best_quality ; <S2SV_EndBug> int active_worst_quality = cpi -> twopass . active_worst_quality ; int q ; <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> # if ! CONFIG_MULTIPLE_ARF <S2SV_StartBug> if ( rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> int qindex = rc -> last_boosted_qindex ; <S2SV_EndBug> <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , <S2SV_StartBug> last_boosted_q * 0.75 ) ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ; <S2SV_EndBug> } else { double q_adj_factor = 1.0 ; double q_val ; <S2SV_StartBug> active_best_quality = get_active_quality ( active_worst_quality , <S2SV_EndBug> rc -> kf_boost , kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ; if ( ( cm -> width * cm -> height ) <= ( 352 * 288 ) ) { q_adj_factor -= 0.25 ; } q_adj_factor += 0.05 - ( 0.001 * ( double ) cpi -> twopass . kf_zeromotion_pct ) ; <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> active_best_quality += vp9_compute_qdelta ( rc , q_val , <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> } # else double current_q ; current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ; active_best_quality = active_worst_quality + vp9_compute_qdelta ( rc , current_q , current_q * 0.3 ) ; # endif } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) { q = rc -> avg_frame_qindex [ INTER_FRAME ] ; } else { q = active_worst_quality ; } <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( q < cpi -> cq_target_quality ) <S2SV_EndBug> q = cpi -> cq_target_quality ; if ( rc -> frames_since_key > 1 ) { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , afq_low_motion_minq , afq_high_motion_minq ) ; } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } active_best_quality = active_best_quality * 15 / 16 ; <S2SV_StartBug> } else if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> if ( ! cpi -> refresh_alt_ref_frame ) { <S2SV_StartBug> active_best_quality = cpi -> cq_target_quality ; <S2SV_EndBug> } else { if ( rc -> frames_since_key > 1 ) { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , afq_low_motion_minq , afq_high_motion_minq ) ; } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } } } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } } else { <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> active_best_quality = cpi -> cq_target_quality ; } else { active_best_quality = inter_minq [ active_worst_quality ] ; <S2SV_StartBug> if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) && <S2SV_EndBug> <S2SV_StartBug> ( active_best_quality < cpi -> cq_target_quality ) ) { <S2SV_EndBug> if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) active_best_quality = oxcf -> cq_level ; else active_best_quality = cpi -> cq_target_quality ; } } } active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ; active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ; * top_index = active_worst_quality ; * bottom_index = active_best_quality ; # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> } else if ( ! rc -> is_src_frame_alt_ref && ( oxcf -> end_usage != USAGE_STREAM_FROM_SERVER ) && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { * top_index = ( active_worst_quality + active_best_quality ) / 2 ; } # endif if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { q = active_best_quality ; } else if ( ( cm -> frame_type == KEY_FRAME ) && rc -> this_key_frame_forced ) { <S2SV_StartBug> q = rc -> last_boosted_qindex ; <S2SV_EndBug> } else { q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , active_best_quality , active_worst_quality ) ; <S2SV_StartBug> if ( q > * top_index ) { <S2SV_EndBug> if ( rc -> this_frame_target >= rc -> max_frame_bandwidth ) <S2SV_StartBug> * top_index = q ; <S2SV_EndBug> else q = * top_index ; } } # if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled && ( cm -> frame_type != KEY_FRAME ) && cpi -> oxcf . end_usage != USAGE_CONSTANT_QUALITY ) { double new_q ; double current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ; int level = cpi -> this_frame_weight ; assert ( level >= 0 ) ; new_q = current_q * ( 1.0 - ( 0.2 * ( cpi -> max_arf_level - level ) ) ) ; q = active_worst_quality + vp9_compute_qdelta ( rc , current_q , new_q ) ; <S2SV_StartBug> * bottom_index = q ; <S2SV_EndBug> * top_index = q ; printf ( ""frame:%d<S2SV_blank>q:%d\\n"" , cm -> current_video_frame , q ) ; } # endif assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ; assert ( * bottom_index <= rc -> worst_quality && * bottom_index >= rc -> best_quality ) ; assert ( q <= rc -> worst_quality && q >= rc -> best_quality ) ; return q ; }
","<S2SV_ModStart> rc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> -> oxcf ; const GF_GROUP * gf_group = & cpi -> twopass . gf_group ; const int cq_level = get_active_cq_level ( rc , oxcf ) ; int active_best_quality ; int active_worst_quality = cpi -> twopass . active_worst_quality ; int q ; int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) { <S2SV_ModEnd> if ( rc <S2SV_ModStart> this_key_frame_forced ) { double last_boosted_q ; int delta_qindex ; int qindex ; if ( cpi -> twopass . last_kfgroup_zeromotion_pct >= STATIC_MOTION_THRESH ) { qindex = MIN ( rc -> last_kf_qindex , <S2SV_ModEnd> rc -> last_boosted_qindex <S2SV_ModStart> rc -> last_boosted_qindex ) ; active_best_quality = qindex ; <S2SV_ModEnd> last_boosted_q = vp9_convert_qindex_to_q <S2SV_ModStart> vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ; <S2SV_ModEnd> delta_qindex = vp9_compute_qdelta <S2SV_ModStart> , last_boosted_q * 1.25 , cm -> bit_depth ) ; active_worst_quality = MIN <S2SV_ModEnd> ( qindex + <S2SV_ModStart> + delta_qindex , active_worst_quality ) ; } else { qindex = rc -> last_boosted_qindex ; last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ; delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 0.75 , cm -> bit_depth ) ; active_best_quality = MAX ( qindex + delta_qindex , <S2SV_ModStart> best_quality ) ; } <S2SV_ModStart> ; active_best_quality = get_kf_active_quality ( rc , active_worst_quality , cm -> bit_depth <S2SV_ModEnd> ) ; if <S2SV_ModStart> vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth <S2SV_ModStart> q_val * q_adj_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> } else if <S2SV_ModStart> ( oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) { if <S2SV_ModStart> ( q < cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> active_best_quality = active_best_quality <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { if <S2SV_ModStart> { active_best_quality = cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; if ( gf_group -> rf_level [ gf_group -> index ] == GF_ARF_LOW ) active_best_quality = ( active_best_quality + cq_level + 1 ) / 2 ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> ; } else <S2SV_ModStart> ( oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) && ( <S2SV_ModStart> ( active_best_quality < cq_level ) ) { active_best_quality = cq_level ; } } } if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) ) { if ( frame_is_intra_only ( cm ) || ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ) { active_best_quality -= ( cpi -> twopass . extend_minq + cpi -> twopass . extend_minq_fast ) ; active_worst_quality += ( cpi -> twopass . extend_maxq / 2 ) ; } else { active_best_quality -= ( cpi -> twopass . extend_minq + cpi -> twopass . extend_minq_fast ) / 2 ; active_worst_quality += cpi -> twopass . extend_maxq ; } } <S2SV_ModEnd> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY <S2SV_ModStart> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY vpx_clear_system_state ( ) ; if ( ! ( ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) ) || ! rc -> this_key_frame_forced || ( cpi -> twopass . last_kfgroup_zeromotion_pct < STATIC_MOTION_THRESH ) ) { int qdelta = vp9_frame_type_qdelta ( cpi , gf_group -> rf_level [ gf_group -> index ] , active_worst_quality ) ; active_worst_quality = MAX ( active_worst_quality + qdelta , active_best_quality ) ; } # endif if ( rc -> frame_size_selector != UNSCALED && ! frame_is_kf_gf_arf ( cpi ) ) { int qdelta = vp9_compute_qdelta_by_rate ( rc , cm -> frame_type , active_best_quality , 2.0 , cm -> bit_depth ) ; active_best_quality = MAX ( active_best_quality + qdelta , rc -> best_quality ) ; } active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ; active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ; if ( oxcf -> rc_mode == VPX_Q ) { q = active_best_quality ; } else if ( ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) && <S2SV_ModEnd> rc -> this_key_frame_forced <S2SV_ModStart> this_key_frame_forced ) { if ( cpi -> twopass . last_kfgroup_zeromotion_pct >= STATIC_MOTION_THRESH ) { q = MIN ( rc -> last_kf_qindex , <S2SV_ModEnd> rc -> last_boosted_qindex <S2SV_ModStart> rc -> last_boosted_qindex ) ; } else { q = rc -> last_boosted_qindex ; } <S2SV_ModEnd> } else { <S2SV_ModStart> ( q > active_worst_quality <S2SV_ModEnd> ) { if <S2SV_ModStart> -> max_frame_bandwidth ) active_worst_quality = q ; else q = active_worst_quality ; } } clamp ( q , active_best_quality , active_worst_quality ) ; <S2SV_ModStart> * top_index = active_worst_quality <S2SV_ModEnd> ; * bottom_index <S2SV_ModStart> * bottom_index = active_best_quality ; <S2SV_ModEnd> assert ( *
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int active_best_quality ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> int qindex = rc -> last_boosted_qindex ; <S2SV_EndBug> <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> <S2SV_StartBug> last_boosted_q * 0.75 ) ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = get_active_quality ( active_worst_quality , <S2SV_EndBug> <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( q < cpi -> cq_target_quality ) <S2SV_EndBug> <S2SV_StartBug> } else if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> active_best_quality = cpi -> cq_target_quality ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) && <S2SV_EndBug> <S2SV_StartBug> ( active_best_quality < cpi -> cq_target_quality ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> q = rc -> last_boosted_qindex ; <S2SV_EndBug> <S2SV_StartBug> if ( q > * top_index ) { <S2SV_EndBug> <S2SV_StartBug> * top_index = q ; <S2SV_EndBug> <S2SV_StartBug> * bottom_index = q ; <S2SV_EndBug>"
2973,CWE-20,"static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { char * command , * args = value ; size_t arg_size ; int error ; if ( size == 0 ) return - EINVAL ; if ( args [ size - 1 ] != '\\0' ) { if ( size == PAGE_SIZE ) return - EINVAL ; args [ size ] = '\\0' ; } if ( current != task ) return - EACCES ; args = value ; args = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) return - EINVAL ; args = skip_spaces ( args ) ; if ( ! * args ) return - EINVAL ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else if ( strcmp ( command , ""permipc"" ) == 0 ) { error = aa_setprocattr_permipc ( args ) ; } else { struct common_audit_data sa ; COMMON_AUDIT_DATA_INIT ( & sa , NONE ) ; sa . aad . op = OP_SETPROCATTR ; sa . aad . info = name ; sa . aad . error = - EINVAL ; <S2SV_StartBug> return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL , <S2SV_EndBug> & sa , NULL ) ; } } else if ( strcmp ( name , ""exec"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ; } else { return - EINVAL ; } if ( ! error ) error = size ; return error ; }
","<S2SV_ModStart> ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> ) ; }
",torvalds@linux/a5b2c5b2ad5853591a6cac6134cd0f599a720865,CVE-2011-3619,https://github.com/torvalds/linux/commit/a5b2c5b2ad5853591a6cac6134cd0f599a720865,2013-06-08T13:05Z,"<S2SV_StartBug> return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL , <S2SV_EndBug>"
8379,CWE-362,"static struct sock * tcp_v6_syn_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * treq ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; struct ipv6_txoptions * opt ; # ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key * key ; # endif if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; # ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; # endif newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } treq = inet6_rsk ( req ) ; opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , req ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; newsk -> sk_gso_type = SKB_GSO_TCPV6 ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & treq -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & treq -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & treq -> loc_addr ) ; newsk -> sk_bound_dev_if = treq -> iif ; <S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> newnp -> ipv6_fl_list = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( treq -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( treq -> pktopts , GFP_ATOMIC ) ; kfree_skb ( treq -> pktopts ) ; treq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; tcp_mtup_init ( newsk ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = dst_metric_advmss ( dst ) ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; # ifdef CONFIG_TCP_MD5SIG if ( ( key = tcp_v6_md5_do_lookup ( sk , & newnp -> daddr ) ) != NULL ) { char * newkey = kmemdup ( key -> key , key -> keylen , GFP_ATOMIC ) ; if ( newkey != NULL ) tcp_v6_md5_do_add ( newsk , & newnp -> daddr , newkey , key -> keylen ) ; } # endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : if ( opt && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
","<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug>
3652,CWE-399,"static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; <S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; # ifdef CONFIG_X86_64 vmcs_write16 ( HOST_DS_SELECTOR , 0 ) ; vmcs_write16 ( HOST_ES_SELECTOR , 0 ) ; # else vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; # endif vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_TR_SELECTOR , GDT_ENTRY_TSS * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( HOST_IDTR_BASE , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( HOST_RIP , vmx_return ) ; rdmsr ( MSR_IA32_SYSENTER_CS , low32 , high32 ) ; vmcs_write32 ( HOST_IA32_SYSENTER_CS , low32 ) ; rdmsrl ( MSR_IA32_SYSENTER_EIP , tmpl ) ; vmcs_writel ( HOST_IA32_SYSENTER_EIP , tmpl ) ; if ( vmcs_config . vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT ) { rdmsr ( MSR_IA32_CR_PAT , low32 , high32 ) ; vmcs_write64 ( HOST_IA32_PAT , low32 | ( ( u64 ) high32 << 32 ) ) ; } }
","<S2SV_ModStart> desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 (
",torvalds@linux/d974baa398f34393db76be45f7d4d04fbdbb4a0a,CVE-2014-3690,https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a,2014-11-10T11:55Z,"<S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug>"
665,CWE-119,"char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) { int length ; length = strlen ( filename ) ; <S2SV_StartBug> if ( length > 0 ) <S2SV_EndBug> { if ( ( filename [ 0 ] == \'\\""\' ) && ( filename [ length - 1 ] == \'\\""\' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ; } return strdup ( filename ) ; }
","<S2SV_ModStart> ( length > 1 <S2SV_ModEnd> ) { if
",weechat@weechat/2fb346f25f79e412cf0ed314fdf791763c19b70b,CVE-2017-8073,https://github.com/weechat/weechat/commit/2fb346f25f79e412cf0ed314fdf791763c19b70b,2017-04-23T15:59Z,<S2SV_StartBug> if ( length > 0 ) <S2SV_EndBug>
3983,CWE-119,"CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) { CURLcode result ; char * plainauth ; size_t ulen ; size_t plen ; size_t plainlen ; * outlen = 0 ; * outptr = NULL ; ulen = strlen ( userp ) ; plen = strlen ( passwdp ) ; <S2SV_StartBug> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; plainlen = 2 * ulen + plen + 2 ; plainauth = malloc ( plainlen ) ; if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ; memcpy ( plainauth , userp , ulen ) ; plainauth [ ulen ] = '\\0' ; memcpy ( plainauth + ulen + 1 , userp , ulen ) ; plainauth [ 2 * ulen + 1 ] = '\\0' ; memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ; result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ; free ( plainauth ) ; return result ; }
","<S2SV_ModStart> > SIZE_T_MAX / 4 <S2SV_ModEnd> ) || (
",curl@curl/f3a24d7916b9173c69a3e0ee790102993833d6c5,CVE-2018-16839,https://github.com/curl/curl/commit/f3a24d7916b9173c69a3e0ee790102993833d6c5,2018-10-31T18:29Z,<S2SV_StartBug> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <S2SV_EndBug>
3796,CWE-119,"static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; BoxBlurContext * s = ctx -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; int plane ; int cw = FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) , ch = FF_CEIL_RSHIFT ( in -> height , s -> vsub ) ; int w [ 4 ] = { inlink -> w , cw , cw , inlink -> w } ; int h [ 4 ] = { in -> height , ch , ch , in -> height } ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; <S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> hblur ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ; <S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> vblur ( out -> data [ plane ] , out -> linesize [ plane ] , out -> data [ plane ] , out -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ; av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && in -> data [ plane ] && in -> linesize [ plane ]
",FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,CVE-2013-4263,https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,2013-11-23T17:55Z,<S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug>
8361,CWE-362,"struct dst_entry * inet_csk_route_req ( struct sock * sk , const struct request_sock * req ) { struct rtable * rt ; const struct inet_request_sock * ireq = inet_rsk ( req ) ; <S2SV_StartBug> struct ip_options * opt = inet_rsk ( req ) -> opt ; <S2SV_EndBug> struct net * net = sock_net ( sk ) ; struct flowi4 fl4 ; flowi4_init_output ( & fl4 , sk -> sk_bound_dev_if , sk -> sk_mark , RT_CONN_FLAGS ( sk ) , RT_SCOPE_UNIVERSE , sk -> sk_protocol , inet_sk_flowi_flags ( sk ) , <S2SV_StartBug> ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , <S2SV_EndBug> ireq -> loc_addr , ireq -> rmt_port , inet_sk ( sk ) -> inet_sport ) ; security_req_classify_flow ( req , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) goto no_route ; <S2SV_StartBug> if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway ) <S2SV_EndBug> goto route_err ; return & rt -> dst ; route_err : ip_rt_put ( rt ) ; no_route : IP_INC_STATS_BH ( net , IPSTATS_MIB_OUTNOROUTES ) ; return NULL ; }
","<S2SV_ModStart> ) ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> && opt -> opt . <S2SV_ModStart> ? opt -> opt . <S2SV_ModStart> && opt -> opt .
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,"<S2SV_StartBug> struct ip_options * opt = inet_rsk ( req ) -> opt ; <S2SV_EndBug> <S2SV_StartBug> ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway ) <S2SV_EndBug>"
6240,CWE-000,"PUBLIC void mprDefaultLogHandler ( cchar * tags , int level , cchar * msg ) { MprFile * file ; char tbuf [ 128 ] ; static int check = 0 ; if ( ( file = MPR -> logFile ) == 0 ) { return ; } if ( MPR -> logBackup && MPR -> logSize && ( check ++ % 1000 ) == 0 ) { backupLog ( ) ; } if ( tags && * tags ) { if ( MPR -> flags & MPR_LOG_DETAILED ) { fmt ( tbuf , sizeof ( tbuf ) , ""%s<S2SV_blank>%d<S2SV_blank>%s,<S2SV_blank>"" , mprGetDate ( MPR_LOG_DATE ) , level , tags ) ; mprWriteFileString ( file , tbuf ) ; } else if ( MPR -> flags & MPR_LOG_TAGGED ) { if ( schr ( tags , '<S2SV_blank>' ) ) { <S2SV_StartBug> tags = stok ( sclone ( tags ) , ""<S2SV_blank>"" , NULL ) ; <S2SV_EndBug> } if ( ! isupper ( ( uchar ) * tags ) ) { tags = stitle ( tags ) ; } mprWriteFileFmt ( file , ""%12s<S2SV_blank>"" , sfmt ( ""[%s]"" , tags ) ) ; } } mprWriteFileString ( file , msg ) ; mprWriteFileString ( file , ""\\n"" ) ; # if ME_MPR_OSLOG if ( level == 0 ) { mprWriteToOsLog ( sfmt ( ""%s:<S2SV_blank>%d<S2SV_blank>%s:<S2SV_blank>%s"" , MPR -> name , level , tags , msg ) , level ) ; } # endif }
","<S2SV_ModStart> { tags = ssplit <S2SV_ModEnd> ( sclone (
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,"<S2SV_StartBug> tags = stok ( sclone ( tags ) , ""<S2SV_blank>"" , NULL ) ; <S2SV_EndBug>"
2095,CWE-617,"static krb5_error_code s4u_identify_user ( krb5_context context , krb5_creds * in_creds , krb5_data * subject_cert , krb5_principal * canon_user ) { krb5_error_code code ; krb5_preauthtype ptypes [ 1 ] = { KRB5_PADATA_S4U_X509_USER } ; krb5_creds creds ; int use_master = 0 ; krb5_get_init_creds_opt * opts = NULL ; krb5_principal_data client ; krb5_s4u_userid userid ; * canon_user = NULL ; if ( in_creds -> client == NULL && subject_cert == NULL ) { return EINVAL ; } if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) { int anonymous ; anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ; return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ; } memset ( & creds , 0 , sizeof ( creds ) ) ; memset ( & userid , 0 , sizeof ( userid ) ) ; if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ; code = krb5_get_init_creds_opt_alloc ( context , & opts ) ; if ( code != 0 ) goto cleanup ; krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ; krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ; krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ; krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ; krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ; krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ; if ( in_creds -> client != NULL ) { client = * in_creds -> client ; client . realm = in_creds -> server -> realm ; } else { client . magic = KV5M_PRINCIPAL ; client . realm = in_creds -> server -> realm ; client . data = NULL ; client . length = 0 ; client . type = KRB5_NT_ENTERPRISE_PRINCIPAL ; } code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , opts , krb5_get_as_key_noop , & userid , & use_master , NULL ) ; <S2SV_StartBug> if ( code == 0 || code == KRB5_PREAUTH_FAILED ) { <S2SV_EndBug> * canon_user = userid . user ; userid . user = NULL ; code = 0 ; } cleanup : krb5_free_cred_contents ( context , & creds ) ; if ( opts != NULL ) krb5_get_init_creds_opt_free ( context , opts ) ; if ( userid . user != NULL ) krb5_free_principal ( context , userid . user ) ; return code ; }
","<S2SV_ModStart> ; if ( ! code <S2SV_ModEnd> || code == <S2SV_ModStart> code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP
",krb5@krb5/5e6d1796106df8ba6bc1973ee0917c170d929086,CVE-2018-20217,https://github.com/krb5/krb5/commit/5e6d1796106df8ba6bc1973ee0917c170d929086,2018-12-26T21:29Z,<S2SV_StartBug> if ( code == 0 || code == KRB5_PREAUTH_FAILED ) { <S2SV_EndBug>
3827,CWE-264,"static struct task_struct * copy_process ( unsigned long clone_flags , unsigned long stack_start , unsigned long stack_size , int __user * child_tidptr , struct pid * pid , int trace ) { int retval ; struct task_struct * p ; if ( ( clone_flags & ( CLONE_NEWNS | CLONE_FS ) ) == ( CLONE_NEWNS | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) <S2SV_EndBug> return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_SIGHAND ) && ! ( clone_flags & CLONE_VM ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_PARENT ) && current -> signal -> flags & SIGNAL_UNKILLABLE ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & ( CLONE_VM | CLONE_NEWPID ) ) && ( task_active_pid_ns ( current ) != current -> nsproxy -> pid_ns ) ) return ERR_PTR ( - EINVAL ) ; retval = security_task_create ( clone_flags ) ; if ( retval ) goto fork_out ; retval = - ENOMEM ; p = dup_task_struct ( current ) ; if ( ! p ) goto fork_out ; ftrace_graph_init_task ( p ) ; get_seccomp_filter ( p ) ; rt_mutex_init_task ( p ) ; # ifdef CONFIG_PROVE_LOCKING DEBUG_LOCKS_WARN_ON ( ! p -> hardirqs_enabled ) ; DEBUG_LOCKS_WARN_ON ( ! p -> softirqs_enabled ) ; # endif retval = - EAGAIN ; if ( atomic_read ( & p -> real_cred -> user -> processes ) >= task_rlimit ( p , RLIMIT_NPROC ) ) { if ( ! capable ( CAP_SYS_ADMIN ) && ! capable ( CAP_SYS_RESOURCE ) && p -> real_cred -> user != INIT_USER ) goto bad_fork_free ; } current -> flags &= ~ PF_NPROC_EXCEEDED ; retval = copy_creds ( p , clone_flags ) ; if ( retval < 0 ) goto bad_fork_free ; retval = - EAGAIN ; if ( nr_threads >= max_threads ) goto bad_fork_cleanup_count ; if ( ! try_module_get ( task_thread_info ( p ) -> exec_domain -> module ) ) goto bad_fork_cleanup_count ; p -> did_exec = 0 ; delayacct_tsk_init ( p ) ; copy_flags ( clone_flags , p ) ; INIT_LIST_HEAD ( & p -> children ) ; INIT_LIST_HEAD ( & p -> sibling ) ; rcu_copy_process ( p ) ; p -> vfork_done = NULL ; spin_lock_init ( & p -> alloc_lock ) ; init_sigpending ( & p -> pending ) ; p -> utime = p -> stime = p -> gtime = 0 ; p -> utimescaled = p -> stimescaled = 0 ; # ifndef CONFIG_VIRT_CPU_ACCOUNTING p -> prev_cputime . utime = p -> prev_cputime . stime = 0 ; # endif # ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN seqlock_init ( & p -> vtime_seqlock ) ; p -> vtime_snap = 0 ; p -> vtime_snap_whence = VTIME_SLEEPING ; # endif # if defined ( SPLIT_RSS_COUNTING ) memset ( & p -> rss_stat , 0 , sizeof ( p -> rss_stat ) ) ; # endif p -> default_timer_slack_ns = current -> timer_slack_ns ; task_io_accounting_init ( & p -> ioac ) ; acct_clear_integrals ( p ) ; posix_cpu_timers_init ( p ) ; do_posix_clock_monotonic_gettime ( & p -> start_time ) ; p -> real_start_time = p -> start_time ; monotonic_to_bootbased ( & p -> real_start_time ) ; p -> io_context = NULL ; p -> audit_context = NULL ; if ( clone_flags & CLONE_THREAD ) threadgroup_change_begin ( current ) ; cgroup_fork ( p ) ; # ifdef CONFIG_NUMA p -> mempolicy = mpol_dup ( p -> mempolicy ) ; if ( IS_ERR ( p -> mempolicy ) ) { retval = PTR_ERR ( p -> mempolicy ) ; p -> mempolicy = NULL ; goto bad_fork_cleanup_cgroup ; } mpol_fix_fork_child_flag ( p ) ; # endif # ifdef CONFIG_CPUSETS p -> cpuset_mem_spread_rotor = NUMA_NO_NODE ; p -> cpuset_slab_spread_rotor = NUMA_NO_NODE ; seqcount_init ( & p -> mems_allowed_seq ) ; # endif # ifdef CONFIG_TRACE_IRQFLAGS p -> irq_events = 0 ; p -> hardirqs_enabled = 0 ; p -> hardirq_enable_ip = 0 ; p -> hardirq_enable_event = 0 ; p -> hardirq_disable_ip = _THIS_IP_ ; p -> hardirq_disable_event = 0 ; p -> softirqs_enabled = 1 ; p -> softirq_enable_ip = _THIS_IP_ ; p -> softirq_enable_event = 0 ; p -> softirq_disable_ip = 0 ; p -> softirq_disable_event = 0 ; p -> hardirq_context = 0 ; p -> softirq_context = 0 ; # endif # ifdef CONFIG_LOCKDEP p -> lockdep_depth = 0 ; p -> curr_chain_key = 0 ; p -> lockdep_recursion = 0 ; # endif # ifdef CONFIG_DEBUG_MUTEXES p -> blocked_on = NULL ; # endif # ifdef CONFIG_MEMCG p -> memcg_batch . do_batch = 0 ; p -> memcg_batch . memcg = NULL ; # endif sched_fork ( p ) ; retval = perf_event_init_task ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = audit_alloc ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = copy_semundo ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_audit ; retval = copy_files ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_semundo ; retval = copy_fs ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_files ; retval = copy_sighand ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_fs ; retval = copy_signal ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_sighand ; retval = copy_mm ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_signal ; retval = copy_namespaces ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_mm ; retval = copy_io ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_namespaces ; retval = copy_thread ( clone_flags , stack_start , stack_size , p ) ; if ( retval ) goto bad_fork_cleanup_io ; if ( pid != & init_struct_pid ) { retval = - ENOMEM ; pid = alloc_pid ( p -> nsproxy -> pid_ns ) ; if ( ! pid ) goto bad_fork_cleanup_io ; } p -> pid = pid_nr ( pid ) ; p -> tgid = p -> pid ; if ( clone_flags & CLONE_THREAD ) p -> tgid = current -> tgid ; p -> set_child_tid = ( clone_flags & CLONE_CHILD_SETTID ) ? child_tidptr : NULL ; p -> clear_child_tid = ( clone_flags & CLONE_CHILD_CLEARTID ) ? child_tidptr : NULL ; # ifdef CONFIG_BLOCK p -> plug = NULL ; # endif # ifdef CONFIG_FUTEX p -> robust_list = NULL ; # ifdef CONFIG_COMPAT p -> compat_robust_list = NULL ; # endif INIT_LIST_HEAD ( & p -> pi_state_list ) ; p -> pi_state_cache = NULL ; # endif uprobe_copy_process ( p ) ; if ( ( clone_flags & ( CLONE_VM | CLONE_VFORK ) ) == CLONE_VM ) p -> sas_ss_sp = p -> sas_ss_size = 0 ; user_disable_single_step ( p ) ; clear_tsk_thread_flag ( p , TIF_SYSCALL_TRACE ) ; # ifdef TIF_SYSCALL_EMU clear_tsk_thread_flag ( p , TIF_SYSCALL_EMU ) ; # endif clear_all_latency_tracing ( p ) ; if ( clone_flags & CLONE_THREAD ) p -> exit_signal = - 1 ; else if ( clone_flags & CLONE_PARENT ) p -> exit_signal = current -> group_leader -> exit_signal ; else p -> exit_signal = ( clone_flags & CSIGNAL ) ; p -> pdeath_signal = 0 ; p -> exit_state = 0 ; p -> nr_dirtied = 0 ; p -> nr_dirtied_pause = 128 >> ( PAGE_SHIFT - 10 ) ; p -> dirty_paused_when = 0 ; p -> group_leader = p ; INIT_LIST_HEAD ( & p -> thread_group ) ; p -> task_works = NULL ; write_lock_irq ( & tasklist_lock ) ; if ( clone_flags & ( CLONE_PARENT | CLONE_THREAD ) ) { p -> real_parent = current -> real_parent ; p -> parent_exec_id = current -> parent_exec_id ; } else { p -> real_parent = current ; p -> parent_exec_id = current -> self_exec_id ; } spin_lock ( & current -> sighand -> siglock ) ; recalc_sigpending ( ) ; if ( signal_pending ( current ) ) { spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; retval = - ERESTARTNOINTR ; goto bad_fork_free_pid ; } if ( clone_flags & CLONE_THREAD ) { current -> signal -> nr_threads ++ ; atomic_inc ( & current -> signal -> live ) ; atomic_inc ( & current -> signal -> sigcnt ) ; p -> group_leader = current -> group_leader ; list_add_tail_rcu ( & p -> thread_group , & p -> group_leader -> thread_group ) ; } if ( likely ( p -> pid ) ) { ptrace_init_task ( p , ( clone_flags & CLONE_PTRACE ) || trace ) ; if ( thread_group_leader ( p ) ) { if ( is_child_reaper ( pid ) ) { ns_of_pid ( pid ) -> child_reaper = p ; p -> signal -> flags |= SIGNAL_UNKILLABLE ; } p -> signal -> leader_pid = pid ; p -> signal -> tty = tty_kref_get ( current -> signal -> tty ) ; attach_pid ( p , PIDTYPE_PGID , task_pgrp ( current ) ) ; attach_pid ( p , PIDTYPE_SID , task_session ( current ) ) ; list_add_tail ( & p -> sibling , & p -> real_parent -> children ) ; list_add_tail_rcu ( & p -> tasks , & init_task . tasks ) ; __this_cpu_inc ( process_counts ) ; } attach_pid ( p , PIDTYPE_PID , pid ) ; nr_threads ++ ; } total_forks ++ ; spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; proc_fork_connector ( p ) ; cgroup_post_fork ( p ) ; if ( clone_flags & CLONE_THREAD ) threadgroup_change_end ( current ) ; perf_event_fork ( p ) ; trace_task_newtask ( p , clone_flags ) ; return p ; bad_fork_free_pid : if ( pid != & init_struct_pid ) free_pid ( pid ) ; bad_fork_cleanup_io : if ( p -> io_context ) exit_io_context ( p ) ; bad_fork_cleanup_namespaces : exit_task_namespaces ( p ) ; bad_fork_cleanup_mm : if ( p -> mm ) mmput ( p -> mm ) ; bad_fork_cleanup_signal : if ( ! ( clone_flags & CLONE_THREAD ) ) free_signal_struct ( p -> signal ) ; bad_fork_cleanup_sighand : __cleanup_sighand ( p -> sighand ) ; bad_fork_cleanup_fs : exit_fs ( p ) ; bad_fork_cleanup_files : exit_files ( p ) ; bad_fork_cleanup_semundo : exit_sem ( p ) ; bad_fork_cleanup_audit : audit_free ( p ) ; bad_fork_cleanup_policy : perf_event_free_task ( p ) ; # ifdef CONFIG_NUMA mpol_put ( p -> mempolicy ) ; bad_fork_cleanup_cgroup : # endif if ( clone_flags & CLONE_THREAD ) threadgroup_change_end ( current ) ; cgroup_exit ( p , 0 ) ; delayacct_tsk_free ( p ) ; module_put ( task_thread_info ( p ) -> exec_domain -> module ) ; bad_fork_cleanup_count : atomic_dec ( & p -> cred -> user -> processes ) ; exit_creds ( p ) ; bad_fork_free : free_task ( p ) ; fork_out : return ERR_PTR ( retval ) ; }
","<S2SV_ModStart> ( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags &
",torvalds@linux/e66eded8309ebf679d3d3c1f5820d1f2ca332c71,CVE-2013-1858,https://github.com/torvalds/linux/commit/e66eded8309ebf679d3d3c1f5820d1f2ca332c71,2013-04-05T21:55Z,<S2SV_StartBug> if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) <S2SV_EndBug>
2304,CWE-119,"static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; * ( strend ( t1_buf_array ) - 1 ) = '<S2SV_blank>' ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
","<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
",TeX-Live@texlive-source/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,CVE-2018-17407,https://github.com/TeX-Live/texlive-source/commit/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,2018-09-23T21:29Z,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug>"
552,CWE-125,"static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4"" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%lu"" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>Object<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%s"" , ident , tok2str ( rsvp_obj_values , ""Unknown"" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? ""ignore"" : ""reject"" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? ""and<S2SV_blank>forward"" : ""silently"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>if<S2SV_blank>unknown],<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( rsvp_ctype_values , ""Unknown"" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>objects<S2SV_blank>TLV"" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u"" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u"" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Generalized<S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Waveband<S2SV_blank>ID:<S2SV_blank>%u%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>Label:<S2SV_blank>%u,<S2SV_blank>Stop<S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Reservation<S2SV_blank>Style:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]"" , ident , tok2str ( rsvp_resstyle_values , ""Unknown"" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "",%s<S2SV_blank>merge<S2SV_blank>capability"" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? ""no"" : """" ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Minimum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Maximum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Minimum/Maximum<S2SV_blank>DLCI:<S2SV_blank>%u/%u,<S2SV_blank>%s%s<S2SV_blank>bit<S2SV_blank>DLCI"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? ""10"" : """" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? ""23"" : """" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>LSP<S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , tok2str ( gmpls_encoding_values , ""Unknown"" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Payload<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_xro_values , ""Unknown<S2SV_blank>%u"" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>ERROR:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>ERO<S2SV_blank>subtype"" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>Prefix<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>32"" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , "",<S2SV_blank>%s,<S2SV_blank>%s/%u,<S2SV_blank>Flags:<S2SV_blank>[%s]"" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? ""Loose"" : ""Strict"" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , ""none"" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%u"" , bittok2str ( rsvp_obj_rro_label_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , ""Unknown"" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Instance:<S2SV_blank>0x%08x,<S2SV_blank>Destination<S2SV_blank>Instance:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Restart<S2SV_blank><S2SV_blank>Time:<S2SV_blank>%ums,<S2SV_blank>Recovery<S2SV_blank>Time:<S2SV_blank>%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Session<S2SV_blank>Name:<S2SV_blank>"" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x)"" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) { <S2SV_StartBug> subobj_len = EXTRACT_16BITS ( obj_tptr ) ; <S2SV_EndBug> subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>AF:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_generalized_uni_values , ""Unknown"" , subobj_type ) , subobj_type , tok2str ( af_values , ""Unknown"" , af ) , af , subobj_len ) ) ; <S2SV_StartBug> if ( subobj_len == 0 ) <S2SV_EndBug> goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv4<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv6<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U-bit:<S2SV_blank>%x,<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u,<S2SV_blank>Logical<S2SV_blank>port<S2SV_blank>id:<S2SV_blank>%u,<S2SV_blank>Label:<S2SV_blank>%u"" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Service<S2SV_blank>level:<S2SV_blank>%u"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Refresh<S2SV_blank>Period:<S2SV_blank>%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Msg-Version:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Service<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>break<S2SV_blank>bit<S2SV_blank>%s<S2SV_blank>set,<S2SV_blank>Service<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_intserv_service_type_values , ""unknown"" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? """" : ""not"" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flow<S2SV_blank>Label:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Include-any:<S2SV_blank>0x%08x,<S2SV_blank>Exclude-any:<S2SV_blank>0x%08x,<S2SV_blank>Include-all:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Include<S2SV_blank>Colors:<S2SV_blank>0x%08x,<S2SV_blank>Exclude<S2SV_blank>Colors:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>PLR-ID:<S2SV_blank>%s,<S2SV_blank>Avoid-Node-ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_diffserv_te_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>Unknown<S2SV_blank>Error<S2SV_blank>Value<S2SV_blank>(%u)"" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>TLV<S2SV_blank>count:<S2SV_blank>%u,<S2SV_blank>padding<S2SV_blank>bytes:<S2SV_blank>%u"" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%02x),<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_prop_tlv_values , ""unknown"" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , ""\\n\\t\\t"" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[0x%02x],<S2SV_blank>epoch:<S2SV_blank>%u"" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message-ID<S2SV_blank>0x%08x<S2SV_blank>(%u)"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Key-ID<S2SV_blank>0x%04x%08x,<S2SV_blank>Sequence<S2SV_blank>0x%08x%08x,<S2SV_blank>Flags<S2SV_blank>[%s]"" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , ""none"" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>MD5-sum<S2SV_blank>0x%08x%08x%08x%08x<S2SV_blank>"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , tok2str ( signature_check_values , ""Unknown"" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[%s]"" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Action:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_label_set_action_values , ""Unknown"" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>range:<S2SV_blank>%u,<S2SV_blank>End<S2SV_blank>range:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subchannel<S2SV_blank>#%u:<S2SV_blank>%u"" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return - 1 ; }
","<S2SV_ModStart> 0 ) { if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> if ( subobj_len < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> ) goto invalid
",the-tcpdump-group@tcpdump/289c672020280529fd382f3502efab7100d638ec,CVE-2017-13051,https://github.com/the-tcpdump-group/tcpdump/commit/289c672020280529fd382f3502efab7100d638ec,2017-09-14T06:29Z,<S2SV_StartBug> subobj_len = EXTRACT_16BITS ( obj_tptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( subobj_len == 0 ) <S2SV_EndBug>
2369,CWE-59,"int main ( int argc , char * argv [ ] ) { int ret ; struct lxc_lock * lock ; lock = lxc_newlock ( NULL , NULL ) ; if ( ! lock ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>unnamed<S2SV_blank>lock\\n"" , __LINE__ ) ; exit ( 1 ) ; } ret = lxclock ( lock , 0 ) ; if ( ret ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>take<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n"" , __LINE__ , ret ) ; exit ( 1 ) ; } ret = lxcunlock ( lock ) ; if ( ret ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n"" , __LINE__ , ret ) ; exit ( 1 ) ; } lxc_putlock ( lock ) ; lock = lxc_newlock ( ""/var/lib/lxc"" , mycontainername ) ; if ( ! lock ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>lock\\n"" , __LINE__ ) ; exit ( 1 ) ; } struct stat sb ; <S2SV_StartBug> char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ; <S2SV_EndBug> ret = stat ( pathname , & sb ) ; if ( ret != 0 ) { fprintf ( stderr , ""%d:<S2SV_blank>filename<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>created\\n"" , __LINE__ , pathname ) ; exit ( 1 ) ; } lxc_putlock ( lock ) ; test_two_locks ( ) ; fprintf ( stderr , ""all<S2SV_blank>tests<S2SV_blank>passed\\n"" ) ; exit ( ret ) ; }
","<S2SV_ModStart> pathname = RUNTIME_PATH ""/lxc/lock/var/lib/lxc/"" <S2SV_ModEnd> ; ret =
",lxc@lxc/72cf81f6a3404e35028567db2c99a90406e9c6e6,CVE-2015-1331,https://github.com/lxc/lxc/commit/72cf81f6a3404e35028567db2c99a90406e9c6e6,2015-08-12T14:59Z,"<S2SV_StartBug> char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ; <S2SV_EndBug>"
3989,CWE-20,"static int atalk_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { <S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> struct sockaddr_at * sat = ( struct sockaddr_at * ) msg -> msg_name ; struct ddpehdr * ddp ; int copied = 0 ; int offset = 0 ; int err = 0 ; struct sk_buff * skb ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; lock_sock ( sk ) ; if ( ! skb ) goto out ; ddp = ddp_hdr ( skb ) ; copied = ntohs ( ddp -> deh_len_hops ) & 1023 ; if ( sk -> sk_type != SOCK_RAW ) { offset = sizeof ( * ddp ) ; copied -= offset ; } if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> if ( sat ) { sat -> sat_family = AF_APPLETALK ; sat -> sat_port = ddp -> deh_sport ; sat -> sat_addr . s_node = ddp -> deh_snode ; sat -> sat_addr . s_net = ddp -> deh_snet ; <S2SV_StartBug> } <S2SV_EndBug> msg -> msg_namelen = sizeof ( * sat ) ; } skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return err ? : copied ; }
","<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
4663,CWE-255,"static int unix_getpw ( UNUSED void * instance , REQUEST * request , VALUE_PAIR * * vp_list ) { const char * name ; const char * encrypted_pass ; # ifdef HAVE_GETSPNAM struct spwd * spwd = NULL ; # endif # ifdef OSFC2 struct pr_passwd * pr_pw ; # else struct passwd * pwd ; # endif # ifdef HAVE_GETUSERSHELL char * shell ; # endif VALUE_PAIR * vp ; if ( ! request -> username ) { return RLM_MODULE_NOOP ; } name = ( char * ) request -> username -> vp_strvalue ; encrypted_pass = NULL ; # ifdef OSFC2 if ( ( pr_pw = getprpwnam ( name ) ) == NULL ) return RLM_MODULE_NOTFOUND ; encrypted_pass = pr_pw -> ufld . fd_encrypt ; if ( pr_pw -> uflg . fg_lock != 1 ) { radlog ( L_AUTH , ""rlm_unix:<S2SV_blank>[%s]:<S2SV_blank>account<S2SV_blank>locked"" , name ) ; return RLM_MODULE_USERLOCK ; } # else if ( ( pwd = getpwnam ( name ) ) == NULL ) { return RLM_MODULE_NOTFOUND ; } encrypted_pass = pwd -> pw_passwd ; # endif # ifdef HAVE_GETSPNAM if ( ( encrypted_pass == NULL ) || ( strlen ( encrypted_pass ) < 10 ) ) { if ( ( spwd = getspnam ( name ) ) == NULL ) { return RLM_MODULE_NOTFOUND ; } encrypted_pass = spwd -> sp_pwdp ; } # endif # ifndef OSFC2 # ifdef DENY_SHELL if ( strcmp ( pwd -> pw_shell , DENY_SHELL ) == 0 ) { radlog_request ( L_AUTH , 0 , request , ""rlm_unix:<S2SV_blank>[%s]:<S2SV_blank>invalid<S2SV_blank>shell"" , name ) ; return RLM_MODULE_REJECT ; } # endif # ifdef HAVE_GETUSERSHELL while ( ( shell = getusershell ( ) ) != NULL ) { if ( strcmp ( shell , pwd -> pw_shell ) == 0 || strcmp ( shell , ""/RADIUSD/ANY/SHELL"" ) == 0 ) { break ; } } endusershell ( ) ; if ( shell == NULL ) { radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>invalid<S2SV_blank>shell<S2SV_blank>[%s]"" , name , pwd -> pw_shell ) ; return RLM_MODULE_REJECT ; } # endif # endif # if defined ( HAVE_GETSPNAM ) && ! defined ( M_UNIX ) <S2SV_StartBug> if ( spwd && spwd -> sp_expire > 0 && <S2SV_EndBug> <S2SV_StartBug> ( request -> timestamp / 86400 ) > spwd -> sp_expire ) { <S2SV_EndBug> <S2SV_StartBug> radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; <S2SV_EndBug> return RLM_MODULE_REJECT ; } # endif # if defined ( __FreeBSD__ ) || defined ( bsdi ) || defined ( _PWF_EXPIRE ) if ( ( pwd -> pw_expire > 0 ) && ( request -> timestamp > pwd -> pw_expire ) ) { radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; return RLM_MODULE_REJECT ; } # endif if ( encrypted_pass [ 0 ] == 0 ) return RLM_MODULE_NOOP ; vp = pairmake ( ""Crypt-Password"" , encrypted_pass , T_OP_SET ) ; if ( ! vp ) return RLM_MODULE_FAIL ; pairmove ( vp_list , & vp ) ; pairfree ( & vp ) ; return RLM_MODULE_UPDATED ; }
","<S2SV_ModStart> && spwd -> sp_lstchg > 0 && spwd -> sp_max >= <S2SV_ModEnd> 0 && ( <S2SV_ModStart> 86400 ) > ( spwd -> sp_lstchg + spwd -> sp_max ) ) { radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; return RLM_MODULE_REJECT ; } if ( spwd && <S2SV_ModStart> spwd -> sp_expire > 0 && ( request -> timestamp / 86400 ) > spwd -> sp_expire <S2SV_ModStart> , request , ""[%s]:<S2SV_blank>account<S2SV_blank>has<S2SV_blank>expired"" <S2SV_ModEnd> , name )
",alandekok@freeradius-server/1b1ec5ce75e224bd1755650c18ccdaa6dc53e605,CVE-2011-4966,https://github.com/alandekok/freeradius-server/commit/1b1ec5ce75e224bd1755650c18ccdaa6dc53e605,2013-03-12T23:55Z,"<S2SV_StartBug> if ( spwd && spwd -> sp_expire > 0 && <S2SV_EndBug> <S2SV_StartBug> ( request -> timestamp / 86400 ) > spwd -> sp_expire ) { <S2SV_EndBug> <S2SV_StartBug> radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; <S2SV_EndBug>"
6235,CWE-000,"static int sessionCookieDirective ( MaState * state , cchar * key , cchar * value ) { char * options , * option , * ovalue , * tok ; if ( ! maTokenize ( state , value , ""%*"" , & options ) ) { return MPR_ERR_BAD_SYNTAX ; } if ( smatch ( options , ""disable"" ) ) { httpSetAuthSession ( state -> route -> auth , 0 ) ; return 0 ; } else if ( smatch ( options , ""enable"" ) ) { httpSetAuthSession ( state -> route -> auth , 1 ) ; return 0 ; } for ( option = maGetNextArg ( options , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { <S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( ! ovalue || * ovalue == '\\0' ) continue ; if ( smatch ( option , ""visible"" ) ) { httpSetRouteSessionVisibility ( state -> route , scaselessmatch ( ovalue , ""visible"" ) ) ; } else if ( smatch ( option , ""name"" ) ) { httpSetRouteCookie ( state -> route , ovalue ) ; } else { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Unknown<S2SV_blank>SessionCookie<S2SV_blank>option<S2SV_blank>%s"" , option ) ; return MPR_ERR_BAD_SYNTAX ; } } return 0 ; }
","<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug>"
1405,CWE-119,"static void setup_decoding_thread_data ( VP8D_COMP * pbi , MACROBLOCKD * xd , MB_ROW_DEC * mbrd , int count ) { VP8_COMMON * const pc = & pbi -> common ; int i ; for ( i = 0 ; i < count ; i ++ ) { MACROBLOCKD * mbd = & mbrd [ i ] . mbd ; mbd -> subpixel_predict = xd -> subpixel_predict ; mbd -> subpixel_predict8x4 = xd -> subpixel_predict8x4 ; mbd -> subpixel_predict8x8 = xd -> subpixel_predict8x8 ; mbd -> subpixel_predict16x16 = xd -> subpixel_predict16x16 ; mbd -> mode_info_context = pc -> mi + pc -> mode_info_stride * ( i + 1 ) ; mbd -> mode_info_stride = pc -> mode_info_stride ; mbd -> frame_type = pc -> frame_type ; mbd -> pre = xd -> pre ; mbd -> dst = xd -> dst ; mbd -> segmentation_enabled = xd -> segmentation_enabled ; mbd -> mb_segement_abs_delta = xd -> mb_segement_abs_delta ; <S2SV_StartBug> vpx_memcpy ( mbd -> segment_feature_data , xd -> segment_feature_data , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> ref_lf_deltas , xd -> ref_lf_deltas , sizeof ( xd -> ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> mode_lf_deltas , xd -> mode_lf_deltas , sizeof ( xd -> mode_lf_deltas ) ) ; <S2SV_EndBug> mbd -> mode_ref_lf_delta_enabled = xd -> mode_ref_lf_delta_enabled ; mbd -> mode_ref_lf_delta_update = xd -> mode_ref_lf_delta_update ; mbd -> current_bc = & pbi -> mbc [ 0 ] ; <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1_dc , xd -> dequant_y1_dc , sizeof ( xd -> dequant_y1_dc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1 , xd -> dequant_y1 , sizeof ( xd -> dequant_y1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y2 , xd -> dequant_y2 , sizeof ( xd -> dequant_y2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_uv , xd -> dequant_uv , sizeof ( xd -> dequant_uv ) ) ; <S2SV_EndBug> mbd -> fullpixel_mask = 0xffffffff ; if ( pc -> full_pixel ) mbd -> fullpixel_mask = 0xfffffff8 ; } for ( i = 0 ; i < pc -> mb_rows ; i ++ ) pbi -> mt_current_mb_col [ i ] = - 1 ; }
","<S2SV_ModStart> -> mb_segement_abs_delta ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> 0 ] ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( mbd -> segment_feature_data , xd -> segment_feature_data , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> ref_lf_deltas , xd -> ref_lf_deltas , sizeof ( xd -> ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> mode_lf_deltas , xd -> mode_lf_deltas , sizeof ( xd -> mode_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1_dc , xd -> dequant_y1_dc , sizeof ( xd -> dequant_y1_dc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1 , xd -> dequant_y1 , sizeof ( xd -> dequant_y1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y2 , xd -> dequant_y2 , sizeof ( xd -> dequant_y2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_uv , xd -> dequant_uv , sizeof ( xd -> dequant_uv ) ) ; <S2SV_EndBug>"
5525,CWE-000,"static rfbBool rfbSetClientColourMapBGR233 ( rfbClientPtr cl ) { <S2SV_StartBug> char buf [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetColourMapEntriesMsg * scme = ( rfbSetColourMapEntriesMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint16_t * rgb = ( uint16_t * ) ( & buf [ sz_rfbSetColourMapEntriesMsg ] ) ; <S2SV_EndBug> int i , len ; int r , g , b ; if ( cl -> format . bitsPerPixel != 8 ) { rfbErr ( ""%s:<S2SV_blank>client<S2SV_blank>not<S2SV_blank>8<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel\\n"" , ""rfbSetClientColourMapBGR233"" ) ; rfbCloseClient ( cl ) ; return FALSE ; } scme -> type = rfbSetColourMapEntries ; scme -> firstColour = Swap16IfLE ( 0 ) ; scme -> nColours = Swap16IfLE ( 256 ) ; len = sz_rfbSetColourMapEntriesMsg ; i = 0 ; for ( b = 0 ; b < 4 ; b ++ ) { for ( g = 0 ; g < 8 ; g ++ ) { for ( r = 0 ; r < 8 ; r ++ ) { rgb [ i ++ ] = Swap16IfLE ( r * 65535 / 7 ) ; rgb [ i ++ ] = Swap16IfLE ( g * 65535 / 7 ) ; rgb [ i ++ ] = Swap16IfLE ( b * 65535 / 3 ) ; } } } len += 256 * 3 * 2 ; <S2SV_StartBug> if ( rfbWriteExact ( cl , buf , len ) < 0 ) { <S2SV_EndBug> rfbLogPerror ( ""rfbSetClientColourMapBGR233:<S2SV_blank>write"" ) ; rfbCloseClient ( cl ) ; return FALSE ; } return TRUE ; }
","<S2SV_ModStart> cl ) { union { char bytes <S2SV_ModEnd> [ sz_rfbSetColourMapEntriesMsg + <S2SV_ModStart> ] ; rfbSetColourMapEntriesMsg msg ; } buf ; rfbSetColourMapEntriesMsg * scme = & buf . msg <S2SV_ModEnd> ; uint16_t * <S2SV_ModStart> ( & buf . bytes <S2SV_ModStart> cl , buf . bytes
",LibVNC@libvncserver/53073c8d7e232151ea2ecd8a1243124121e10e2d,CVE-2020-14400,https://github.com/LibVNC/libvncserver/commit/53073c8d7e232151ea2ecd8a1243124121e10e2d,2020-06-17T16:15Z,"<S2SV_StartBug> char buf [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetColourMapEntriesMsg * scme = ( rfbSetColourMapEntriesMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint16_t * rgb = ( uint16_t * ) ( & buf [ sz_rfbSetColourMapEntriesMsg ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rfbWriteExact ( cl , buf , len ) < 0 ) { <S2SV_EndBug>"
7773,CWE-125,"stmt_ty <S2SV_StartBug> AsyncWith ( asdl_seq * items , asdl_seq * body , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncWith_kind ; p -> v . AsyncWith . items = items ; p -> v . AsyncWith . body = body ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
","<S2SV_ModStart> * body , string type_comment , <S2SV_ModStart> ; p -> v . AsyncWith . type_comment = type_comment ; p ->
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> AsyncWith ( asdl_seq * items , asdl_seq * body , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug>"
2083,CWE-269,"void bandwidth_pid ( pid_t pid , const char * command , const char * dev , int down , int up ) { EUID_ASSERT ( ) ; EUID_ROOT ( ) ; char * comm = pid_proc_comm ( pid ) ; EUID_USER ( ) ; if ( ! comm ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>sandbox\\n"" ) ; exit ( 1 ) ; } if ( strcmp ( comm , ""firejail"" ) != 0 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>sandbox\\n"" ) ; exit ( 1 ) ; } free ( comm ) ; char * name ; if ( asprintf ( & name , ""/run/firejail/network/%d-netmap"" , pid ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( name , & s ) == - 1 ) { fprintf ( stderr , ""Error:<S2SV_blank>the<S2SV_blank>sandbox<S2SV_blank>doesn\'t<S2SV_blank>use<S2SV_blank>a<S2SV_blank>new<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } pid_t child ; if ( find_child ( pid , & child ) == - 1 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>join<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } EUID_ROOT ( ) ; if ( join_namespace ( child , ""net"" ) ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>join<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } if ( strcmp ( command , ""set"" ) == 0 ) bandwidth_set ( pid , dev , down , up ) ; else if ( strcmp ( command , ""clear"" ) == 0 ) bandwidth_remove ( pid , dev ) ; char * devname = NULL ; if ( dev ) { char * fname ; if ( asprintf ( & fname , ""%s/%d-netmap"" , RUN_FIREJAIL_NETWORK_DIR , ( int ) pid ) == - 1 ) errExit ( ""asprintf"" ) ; FILE * fp = fopen ( fname , ""r"" ) ; if ( ! fp ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>network<S2SV_blank>map<S2SV_blank>file<S2SV_blank>%s\\n"" , fname ) ; exit ( 1 ) ; } char buf [ 1024 ] ; int len = strlen ( dev ) ; while ( fgets ( buf , 1024 , fp ) ) { char * ptr = strchr ( buf , '\\n' ) ; if ( ptr ) * ptr = '\\0' ; if ( * buf == '\\0' ) break ; if ( strncmp ( buf , dev , len ) == 0 && buf [ len ] == ':' ) { devname = strdup ( buf + len + 1 ) ; if ( ! devname ) errExit ( ""strdup"" ) ; if ( if_nametoindex ( devname ) == 0 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>network<S2SV_blank>device<S2SV_blank>%s\\n"" , devname ) ; exit ( 1 ) ; } break ; } } free ( fname ) ; fclose ( fp ) ; } char * cmd = NULL ; if ( devname ) { if ( strcmp ( command , ""set"" ) == 0 ) { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%d"" , LIBDIR , command , devname , down , up ) == - 1 ) errExit ( ""asprintf"" ) ; } else { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s<S2SV_blank>%s"" , LIBDIR , command , devname ) == - 1 ) errExit ( ""asprintf"" ) ; } } else { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s"" , LIBDIR , command ) == - 1 ) errExit ( ""asprintf"" ) ; } assert ( cmd ) ; environ = NULL ; if ( setreuid ( 0 , 0 ) ) errExit ( ""setreuid"" ) ; if ( setregid ( 0 , 0 ) ) errExit ( ""setregid"" ) ; <S2SV_StartBug> if ( ! cfg . shell ) <S2SV_EndBug> cfg . shell = guess_shell ( ) ; if ( ! cfg . shell ) { fprintf ( stderr , ""Error:<S2SV_blank>no<S2SV_blank>POSIX<S2SV_blank>shell<S2SV_blank>found,<S2SV_blank>please<S2SV_blank>use<S2SV_blank>--shell<S2SV_blank>command<S2SV_blank>line<S2SV_blank>option\\n"" ) ; exit ( 1 ) ; } char * arg [ 4 ] ; <S2SV_StartBug> arg [ 0 ] = cfg . shell ; <S2SV_EndBug> arg [ 1 ] = ""-c"" ; arg [ 2 ] = cmd ; arg [ 3 ] = NULL ; clearenv ( ) ; execvp ( arg [ 0 ] , arg ) ; errExit ( ""execvp"" ) ; }
","<S2SV_ModStart> ""setregid"" ) ; <S2SV_ModEnd> char * arg <S2SV_ModStart> 0 ] = ""/bin/sh"" <S2SV_ModEnd> ; arg [
",netblue30@firejail/5d43fdcd215203868d440ffc42036f5f5ffc89fc,CVE-2017-5207,https://github.com/netblue30/firejail/commit/5d43fdcd215203868d440ffc42036f5f5ffc89fc,2017-03-23T16:59Z,<S2SV_StartBug> if ( ! cfg . shell ) <S2SV_EndBug> <S2SV_StartBug> arg [ 0 ] = cfg . shell ; <S2SV_EndBug>
7001,CWE-476,"<S2SV_StartBug> static int changedline ( const Proto * p , int oldpc , int newpc ) { <S2SV_EndBug> while ( oldpc ++ < newpc ) { if ( p -> lineinfo [ oldpc ] != 0 ) return ( luaG_getfuncline ( p , oldpc - 1 ) != luaG_getfuncline ( p , newpc ) ) ; } return 0 ; }
","<S2SV_ModStart> newpc ) { if ( p -> lineinfo == NULL ) return 0 ;
",lua@lua/ae5b5ba529753c7a653901ffc29b5ea24c3fdf3a,CVE-2020-24369,https://github.com/lua/lua/commit/ae5b5ba529753c7a653901ffc29b5ea24c3fdf3a,2020-08-17T17:15Z,"<S2SV_StartBug> static int changedline ( const Proto * p , int oldpc , int newpc ) { <S2SV_EndBug>"
3908,CWE-119,"l_int32 gplotGenCommandFile ( GPLOT * gplot ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char * cmdstr , * plottitle , * dataname ; l_int32 i , plotstyle , nplots ; FILE * fp ; PROCNAME ( ""gplotGenCommandFile"" ) ; if ( ! gplot ) return ERROR_INT ( ""gplot<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; sarrayClear ( gplot -> cmddata ) ; if ( gplot -> title ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>title<S2SV_blank>\'%s\'"" , gplot -> title ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> xlabel ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\'%s\'"" , gplot -> xlabel ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> ylabel ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\'%s\'"" , gplot -> ylabel ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> outformat == GPLOT_PNG ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> gplot -> outname ) ; } else if ( gplot -> outformat == GPLOT_PS ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> gplot -> outname ) ; } else if ( gplot -> outformat == GPLOT_EPS ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , gplot -> outname ) ; } else if ( gplot -> outformat == GPLOT_LATEX ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> gplot -> outname ) ; } sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; if ( gplot -> scaling == GPLOT_LOG_SCALE_X || gplot -> scaling == GPLOT_LOG_SCALE_X_Y ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> scaling == GPLOT_LOG_SCALE_Y || gplot -> scaling == GPLOT_LOG_SCALE_X_Y ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } nplots = sarrayGetCount ( gplot -> datanames ) ; for ( i = 0 ; i < nplots ; i ++ ) { plottitle = sarrayGetString ( gplot -> plottitles , i , L_NOCOPY ) ; dataname = sarrayGetString ( gplot -> datanames , i , L_NOCOPY ) ; numaGetIValue ( gplot -> plotstyles , i , & plotstyle ) ; if ( nplots == 1 ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; } else { if ( i == 0 ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; else if ( i < nplots - 1 ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; else <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; } sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } cmdstr = sarrayToString ( gplot -> cmddata , 1 ) ; if ( ( fp = fopenWriteStream ( gplot -> cmdname , ""w"" ) ) == NULL ) { LEPT_FREE ( cmdstr ) ; return ERROR_INT ( ""cmd<S2SV_blank>stream<S2SV_blank>not<S2SV_blank>opened"" , procName , 1 ) ; } fwrite ( cmdstr , 1 , strlen ( cmdstr ) , fp ) ; fclose ( fp ) ; LEPT_FREE ( cmdstr ) ; return 0 ; }
","<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>title<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>xlabel<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>ylabel<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" ,
",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>title<S2SV_blank>\'%s\'"" , gplot -> title ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\'%s\'"" , gplot -> xlabel ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\'%s\'"" , gplot -> ylabel ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug>"
2687,CWE-362,"static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put ( loop_trans ) ; conn -> c_loopback = 1 ; if ( is_outgoing && trans -> t_prefer_loopback ) { trans = & rds_loop_transport ; } <S2SV_StartBug> } <S2SV_EndBug> if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; } conn -> c_trans = trans ; ret = trans -> conn_alloc ( conn , gfp ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } atomic_set ( & conn -> c_state , RDS_CONN_DOWN ) ; conn -> c_send_gen = 0 ; conn -> c_outgoing = ( is_outgoing ? 1 : 0 ) ; conn -> c_reconnect_jiffies = 0 ; INIT_DELAYED_WORK ( & conn -> c_send_w , rds_send_worker ) ; INIT_DELAYED_WORK ( & conn -> c_recv_w , rds_recv_worker ) ; INIT_DELAYED_WORK ( & conn -> c_conn_w , rds_connect_worker ) ; INIT_WORK ( & conn -> c_down_w , rds_shutdown_worker ) ; mutex_init ( & conn -> c_cm_lock ) ; conn -> c_flags = 0 ; rdsdebug ( ""allocated<S2SV_blank>conn<S2SV_blank>%p<S2SV_blank>for<S2SV_blank>%pI4<S2SV_blank>-><S2SV_blank>%pI4<S2SV_blank>over<S2SV_blank>%s<S2SV_blank>%s\\n"" , conn , & laddr , & faddr , trans -> t_name ? trans -> t_name : ""[unknown]"" , is_outgoing ? ""(outgoing)"" : """" ) ; spin_lock_irqsave ( & rds_conn_lock , flags ) ; if ( parent ) { if ( parent -> c_passive ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = parent -> c_passive ; } else { parent -> c_passive = conn ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } else { struct rds_connection * found ; found = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( found ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = found ; } else { hlist_add_head_rcu ( & conn -> c_hash_node , head ) ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } spin_unlock_irqrestore ( & rds_conn_lock , flags ) ; out : return conn ; }
","<S2SV_ModStart> rds_loop_transport ; } <S2SV_ModEnd> } conn ->
",torvalds@linux/8c7188b23474cca017b3ef354c4a58456f68303a,CVE-2015-7990,https://github.com/torvalds/linux/commit/8c7188b23474cca017b3ef354c4a58456f68303a,2015-12-28T11:59Z,<S2SV_StartBug> } <S2SV_EndBug>
8292,CWE-20,"static int ___sys_recvmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned int flags , int nosec ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct iovec iovstack [ UIO_FASTIOV ] ; struct iovec * iov = iovstack ; unsigned long cmsg_ptr ; int err , total_len , len ; struct sockaddr_storage addr ; struct sockaddr __user * uaddr ; int __user * uaddr_len ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else { err = copy_msghdr_from_user ( msg_sys , msg ) ; if ( err ) return err ; } if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , GFP_KERNEL ) ; if ( ! iov ) goto out ; } uaddr = ( __force void __user * ) msg_sys -> msg_name ; uaddr_len = COMPAT_NAMELEN ( msg ) ; <S2SV_StartBug> if ( MSG_CMSG_COMPAT & flags ) { <S2SV_EndBug> err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; <S2SV_StartBug> } else <S2SV_EndBug> err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; cmsg_ptr = ( unsigned long ) msg_sys -> msg_control ; <S2SV_StartBug> msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; <S2SV_EndBug> if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = ( nosec ? sock_recvmsg_nosec : sock_recvmsg ) ( sock , msg_sys , total_len , flags ) ; if ( err < 0 ) goto out_freeiov ; len = err ; if ( uaddr != NULL ) { err = move_addr_to_user ( & addr , msg_sys -> msg_namelen , uaddr , uaddr_len ) ; if ( err < 0 ) goto out_freeiov ; } err = __put_user ( ( msg_sys -> msg_flags & ~ MSG_CMSG_COMPAT ) , COMPAT_FLAGS ( msg ) ) ; if ( err ) goto out_freeiov ; if ( MSG_CMSG_COMPAT & flags ) err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg_compat -> msg_controllen ) ; else err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg -> msg_controllen ) ; if ( err ) goto out_freeiov ; err = len ; out_freeiov : if ( iov != iovstack ) kfree ( iov ) ; out : return err ; }
","<S2SV_ModStart> & flags ) <S2SV_ModEnd> err = verify_compat_iovec <S2SV_ModStart> VERIFY_WRITE ) ; <S2SV_ModEnd> else err = <S2SV_ModStart> | MSG_CMSG_COMPAT ) ; msg_sys -> msg_namelen = 0
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> if ( MSG_CMSG_COMPAT & flags ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; <S2SV_EndBug>
2394,CWE-399,"void free_pipe_info ( struct pipe_inode_info * pipe ) { <S2SV_StartBug> int i ; <S2SV_EndBug> for ( i = 0 ; i < pipe -> buffers ; i ++ ) { struct pipe_buffer * buf = pipe -> bufs + i ; if ( buf -> ops ) buf -> ops -> release ( pipe , buf ) ; } if ( pipe -> tmp_page ) __free_page ( pipe -> tmp_page ) ; kfree ( pipe -> bufs ) ; kfree ( pipe ) ; }
","<S2SV_ModStart> { int i ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user )
",torvalds@linux/759c01142a5d0f364a462346168a56de28a80f52,CVE-2016-2847,https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52,2016-04-27T17:59Z,<S2SV_StartBug> int i ; <S2SV_EndBug>
2382,CWE-119,"char * suhosin_encrypt_single_cookie ( char * name , int name_len , char * value , int value_len , char * key TSRMLS_DC ) { <S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> char buffer2 [ 4096 ] ; char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; int l ; <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> buf = estrndup ( name , name_len ) ; <S2SV_StartBug> } else { <S2SV_EndBug> memcpy ( buf , name , name_len ) ; buf [ name_len ] = 0 ; } name_len = php_url_decode ( buf , name_len ) ; normalize_varname ( buf ) ; name_len = strlen ( buf ) ; if ( SUHOSIN_G ( cookie_plainlist ) ) { if ( zend_hash_exists ( SUHOSIN_G ( cookie_plainlist ) , buf , name_len + 1 ) ) { encrypt_return_plain : <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> efree ( buf ) ; } return estrndup ( value , value_len ) ; } } else if ( SUHOSIN_G ( cookie_cryptlist ) ) { if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) { goto encrypt_return_plain ; } } <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> memcpy ( buf2 , value , value_len ) ; buf2 [ value_len ] = 0 ; } else { buf2 = estrndup ( value , value_len ) ; } value_len = php_url_decode ( buf2 , value_len ) ; d = suhosin_encrypt_string ( buf2 , value_len , buf , name_len , key TSRMLS_CC ) ; d_url = php_url_encode ( d , strlen ( d ) , & l ) ; efree ( d ) ; <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> efree ( buf ) ; } if ( buf2 != buffer2 ) { efree ( buf2 ) ; } return d_url ; }
","<S2SV_ModStart> ) { char * buf , * buf2 <S2SV_ModEnd> , * d <S2SV_ModStart> int l ; <S2SV_ModEnd> buf = estrndup <S2SV_ModStart> name_len ) ; <S2SV_ModEnd> name_len = php_url_decode <S2SV_ModStart> { encrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> return estrndup ( <S2SV_ModStart> ; } } buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> value_len = php_url_decode <S2SV_ModStart> d ) ; efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return d_url ;
",stefanesser@suhosin/73b1968ee30f6d9d2dae497544b910e68e114bfa,CVE-2012-0807,https://github.com/stefanesser/suhosin/commit/73b1968ee30f6d9d2dae497544b910e68e114bfa,2012-01-27T00:55Z,<S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug>
2383,CWE-119,"static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , <S2SV_StartBug> offset , <S2SV_EndBug> pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; <S2SV_StartBug> p = pixels + offset ; <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , one , pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> , y ; <S2SV_ModStart> ; if ( ( offset < 0 ) || ( <S2SV_ModStart> ) > pixel_info_length ) <S2SV_ModStart> + plane ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } <S2SV_ModStart> + offset ; <S2SV_ModEnd> for ( i
",ImageMagick@ImageMagick/73fb0aac5b958521e1511e179ecc0ad49f70ebaf,CVE-2016-10050,https://github.com/ImageMagick/ImageMagick/commit/73fb0aac5b958521e1511e179ecc0ad49f70ebaf,2017-03-23T17:59Z,"<S2SV_StartBug> offset , <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> <S2SV_StartBug> p = pixels + offset ; <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug>"
1016,CWE-284,"static int tap_if_down ( const char * devname ) { struct ifreq ifr ; int sk ; sk = socket ( AF_INET , SOCK_DGRAM , 0 ) ; if ( sk < 0 ) return - 1 ; memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , devname , IF_NAMESIZE - 1 ) ; ifr . ifr_flags &= ~ IFF_UP ; <S2SV_StartBug> ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <S2SV_EndBug> close ( sk ) ; return 0 ; }
","<S2SV_ModStart> ~ IFF_UP ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) & ifr )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <S2SV_EndBug>"
4982,CWE-476,"static void tw5864_handle_frame ( struct tw5864_h264_frame * frame ) { # define SKIP_VLCBUF_BYTES 3 struct tw5864_input * input = frame -> input ; struct tw5864_dev * dev = input -> root ; struct tw5864_buf * vb ; struct vb2_v4l2_buffer * v4l2_buf ; int frame_len = frame -> vlc_len - SKIP_VLCBUF_BYTES ; u8 * dst = input -> buf_cur_ptr ; u8 tail_mask , vlc_mask = 0 ; int i ; u8 vlc_first_byte = ( ( u8 * ) ( frame -> vlc . addr + SKIP_VLCBUF_BYTES ) ) [ 0 ] ; unsigned long flags ; int zero_run ; u8 * src ; u8 * src_end ; # ifdef DEBUG if ( frame -> checksum != tw5864_vlc_checksum ( ( u32 * ) frame -> vlc . addr , frame_len ) ) dev_err ( & dev -> pci -> dev , ""Checksum<S2SV_blank>of<S2SV_blank>encoded<S2SV_blank>frame<S2SV_blank>doesn\'t<S2SV_blank>match!\\n"" ) ; # endif spin_lock_irqsave ( & input -> slock , flags ) ; vb = input -> vb ; input -> vb = NULL ; spin_unlock_irqrestore ( & input -> slock , flags ) ; <S2SV_StartBug> v4l2_buf = to_vb2_v4l2_buffer ( & vb -> vb . vb2_buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vb ) { <S2SV_EndBug> dev_dbg ( & dev -> pci -> dev , ""vb<S2SV_blank>is<S2SV_blank>empty,<S2SV_blank>dropping<S2SV_blank>frame\\n"" ) ; return ; } if ( input -> buf_cur_space_left < frame_len * 5 / 4 ) { dev_err_once ( & dev -> pci -> dev , ""Left<S2SV_blank>space<S2SV_blank>in<S2SV_blank>vb2<S2SV_blank>buffer,<S2SV_blank>%d<S2SV_blank>bytes,<S2SV_blank>is<S2SV_blank>less<S2SV_blank>than<S2SV_blank>considered<S2SV_blank>safely<S2SV_blank>enough<S2SV_blank>to<S2SV_blank>put<S2SV_blank>frame<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d.<S2SV_blank>Dropping<S2SV_blank>this<S2SV_blank>frame.\\n"" , input -> buf_cur_space_left , frame_len ) ; return ; } for ( i = 0 ; i < 8 - input -> tail_nb_bits ; i ++ ) vlc_mask |= 1 << i ; tail_mask = ( ~ vlc_mask ) & 0xff ; dst [ 0 ] = ( input -> tail & tail_mask ) | ( vlc_first_byte & vlc_mask ) ; frame_len -- ; dst ++ ; src = frame -> vlc . addr + SKIP_VLCBUF_BYTES + 1 ; src_end = src + frame_len ; zero_run = 0 ; for ( ; src < src_end ; src ++ ) { if ( zero_run < 2 ) { if ( * src == 0 ) ++ zero_run ; else zero_run = 0 ; } else { if ( ( * src & ~ 0x03 ) == 0 ) * dst ++ = 0x03 ; zero_run = * src == 0 ; } * dst ++ = * src ; } vb2_set_plane_payload ( & vb -> vb . vb2_buf , 0 , dst - ( u8 * ) vb2_plane_vaddr ( & vb -> vb . vb2_buf , 0 ) ) ; vb -> vb . vb2_buf . timestamp = frame -> timestamp ; v4l2_buf -> field = V4L2_FIELD_INTERLACED ; v4l2_buf -> sequence = frame -> seqno ; if ( frame -> gop_seqno && tw5864_is_motion_triggered ( frame ) ) { struct v4l2_event ev = { . type = V4L2_EVENT_MOTION_DET , . u . motion_det = { . flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ , . frame_sequence = v4l2_buf -> sequence , } , } ; v4l2_event_queue ( & input -> vdev , & ev ) ; } vb2_buffer_done ( & vb -> vb . vb2_buf , VB2_BUF_STATE_DONE ) ; }
","<S2SV_ModStart> flags ) ; if ( ! vb ) { dev_dbg ( & dev -> pci -> dev , ""vb<S2SV_blank>is<S2SV_blank>empty,<S2SV_blank>dropping<S2SV_blank>frame\\n"" ) ; return ; } <S2SV_ModStart> vb2_buf ) ; <S2SV_ModEnd> if ( input
",torvalds@linux/2e7682ebfc750177a4944eeb56e97a3f05734528,CVE-2019-20806,https://github.com/torvalds/linux/commit/2e7682ebfc750177a4944eeb56e97a3f05734528,2020-05-27T12:15Z,<S2SV_StartBug> v4l2_buf = to_vb2_v4l2_buffer ( & vb -> vb . vb2_buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vb ) { <S2SV_EndBug>
8039,CWE-347,"void pointZZ_pAdd ( PointZZ_p * rop , const PointZZ_p * op1 , const PointZZ_p * op2 , const CurveZZ_p * curve ) { <S2SV_StartBug> mpz_t xdiff , ydiff , lambda ; <S2SV_EndBug> mpz_inits ( xdiff , ydiff , lambda , NULL ) ; mpz_sub ( ydiff , op2 -> y , op1 -> y ) ; mpz_sub ( xdiff , op2 -> x , op1 -> x ) ; mpz_invert ( xdiff , xdiff , curve -> p ) ; mpz_mul ( lambda , ydiff , xdiff ) ; mpz_mod ( lambda , lambda , curve -> p ) ; mpz_mul ( rop -> x , lambda , lambda ) ; mpz_sub ( rop -> x , rop -> x , op1 -> x ) ; mpz_sub ( rop -> x , rop -> x , op2 -> x ) ; mpz_mod ( rop -> x , rop -> x , curve -> p ) ; mpz_sub ( rop -> y , op1 -> x , rop -> x ) ; mpz_mul ( rop -> y , lambda , rop -> y ) ; mpz_sub ( rop -> y , rop -> y , op1 -> y ) ; mpz_mod ( rop -> y , rop -> y , curve -> p ) ; <S2SV_StartBug> mpz_clears ( xdiff , ydiff , lambda , NULL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> curve ) { if ( pointZZ_pIsIdentityElement ( op1 ) && pointZZ_pIsIdentityElement ( op2 ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; } else if ( pointZZ_pIsIdentityElement ( op1 ) ) { mpz_set ( rop -> x , op2 -> x ) ; mpz_set ( rop -> y , op2 -> y ) ; return ; } else if ( pointZZ_pIsIdentityElement ( op2 ) ) { mpz_set ( rop -> x , op1 -> x ) ; mpz_set ( rop -> y , op1 -> y ) ; return ; } if ( pointZZ_pEqual ( op1 , op2 ) ) { pointZZ_pDouble ( rop , op1 , curve ) ; return ; } mpz_t negy ; mpz_init ( negy ) ; mpz_sub ( negy , curve -> p , op2 -> y ) ; if ( mpz_cmp ( op1 -> x , op2 -> x ) == 0 && mpz_cmp ( op1 -> y , negy ) == 0 ) { mpz_clear ( negy ) ; return pointZZ_pSetToIdentityElement ( rop ) ; } mpz_t <S2SV_ModEnd> xdiff , ydiff <S2SV_ModStart> ; mpz_clears ( negy ,
",AntonKueltz@fastecdsa/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,CVE-2020-12607,https://github.com/AntonKueltz/fastecdsa/commit/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,2020-06-02T21:15Z,"<S2SV_StartBug> mpz_t xdiff , ydiff , lambda ; <S2SV_EndBug> <S2SV_StartBug> mpz_clears ( xdiff , ydiff , lambda , NULL ) ; <S2SV_EndBug>"
2257,CWE-617,"static int flv_write_packet ( AVFormatContext * s , AVPacket * pkt ) { AVIOContext * pb = s -> pb ; AVCodecParameters * par = s -> streams [ pkt -> stream_index ] -> codecpar ; FLVContext * flv = s -> priv_data ; FLVStreamContext * sc = s -> streams [ pkt -> stream_index ] -> priv_data ; unsigned ts ; int size = pkt -> size ; uint8_t * data = NULL ; int flags = - 1 , flags_size , ret ; <S2SV_StartBug> int64_t cur_offset = avio_tell ( pb ) ; <S2SV_EndBug> if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A || par -> codec_id == AV_CODEC_ID_VP6 || par -> codec_id == AV_CODEC_ID_AAC ) flags_size = 2 ; else if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) flags_size = 5 ; else flags_size = 1 ; if ( par -> codec_id == AV_CODEC_ID_AAC || par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { int side_size = 0 ; uint8_t * side = av_packet_get_side_data ( pkt , AV_PKT_DATA_NEW_EXTRADATA , & side_size ) ; if ( side && side_size > 0 && ( side_size != par -> extradata_size || memcmp ( side , par -> extradata , side_size ) ) ) { av_free ( par -> extradata ) ; par -> extradata = av_mallocz ( side_size + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! par -> extradata ) { par -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memcpy ( par -> extradata , side , side_size ) ; par -> extradata_size = side_size ; flv_write_codec_header ( s , par , pkt -> dts ) ; } } if ( flv -> delay == AV_NOPTS_VALUE ) flv -> delay = - pkt -> dts ; if ( pkt -> dts < - flv -> delay ) { av_log ( s , AV_LOG_WARNING , ""Packets<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>proper<S2SV_blank>order<S2SV_blank>with<S2SV_blank>respect<S2SV_blank>to<S2SV_blank>DTS\\n"" ) ; return AVERROR ( EINVAL ) ; } ts = pkt -> dts ; if ( s -> event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED ) { write_metadata ( s , ts ) ; s -> event_flags &= ~ AVSTREAM_EVENT_FLAG_METADATA_UPDATED ; } avio_write_marker ( pb , av_rescale ( ts , AV_TIME_BASE , 1000 ) , pkt -> flags & AV_PKT_FLAG_KEY && ( flv -> video_par ? par -> codec_type == AVMEDIA_TYPE_VIDEO : 1 ) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT ) ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : avio_w8 ( pb , FLV_TAG_TYPE_VIDEO ) ; flags = ff_codec_get_tag ( flv_video_codec_ids , par -> codec_id ) ; flags |= pkt -> flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER ; break ; case AVMEDIA_TYPE_AUDIO : flags = get_audio_flags ( s , par ) ; av_assert0 ( size ) ; avio_w8 ( pb , FLV_TAG_TYPE_AUDIO ) ; break ; case AVMEDIA_TYPE_SUBTITLE : case AVMEDIA_TYPE_DATA : avio_w8 ( pb , FLV_TAG_TYPE_META ) ; break ; default : return AVERROR ( EINVAL ) ; } if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( par -> extradata_size > 0 && * ( uint8_t * ) par -> extradata != 1 ) if ( ( ret = ff_avc_parse_nal_units_buf ( pkt -> data , & data , & size ) ) < 0 ) return ret ; } else if ( par -> codec_id == AV_CODEC_ID_AAC && pkt -> size > 2 && ( AV_RB16 ( pkt -> data ) & 0xfff0 ) == 0xfff0 ) { if ( ! s -> streams [ pkt -> stream_index ] -> nb_frames ) { av_log ( s , AV_LOG_ERROR , ""Malformed<S2SV_blank>AAC<S2SV_blank>bitstream<S2SV_blank>detected:<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>audio<S2SV_blank>bitstream<S2SV_blank>filter<S2SV_blank>\'aac_adtstoasc\'<S2SV_blank>to<S2SV_blank>fix<S2SV_blank>it<S2SV_blank>"" ""(\'-bsf:a<S2SV_blank>aac_adtstoasc\'<S2SV_blank>option<S2SV_blank>with<S2SV_blank>ffmpeg)\\n"" ) ; return AVERROR_INVALIDDATA ; } av_log ( s , AV_LOG_WARNING , ""aac<S2SV_blank>bitstream<S2SV_blank>error\\n"" ) ; } if ( par -> codec_id == AV_CODEC_ID_SPEEX && ts - sc -> last_ts > 160 ) av_log ( s , AV_LOG_WARNING , ""Warning:<S2SV_blank>Speex<S2SV_blank>stream<S2SV_blank>has<S2SV_blank>more<S2SV_blank>than<S2SV_blank>"" ""8<S2SV_blank>frames<S2SV_blank>per<S2SV_blank>packet.<S2SV_blank>Adobe<S2SV_blank>Flash<S2SV_blank>"" ""Player<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>this!\\n"" ) ; if ( sc -> last_ts < ts ) sc -> last_ts = ts ; if ( size + flags_size >= 1 << 24 ) { av_log ( s , AV_LOG_ERROR , ""Too<S2SV_blank>large<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>>=<S2SV_blank>%u\\n"" , size + flags_size , 1 << 24 ) ; return AVERROR ( EINVAL ) ; } avio_wb24 ( pb , size + flags_size ) ; put_timestamp ( pb , ts ) ; avio_wb24 ( pb , flv -> reserved ) ; if ( par -> codec_type == AVMEDIA_TYPE_DATA || par -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { int data_size ; int64_t metadata_size_pos = avio_tell ( pb ) ; if ( par -> codec_id == AV_CODEC_ID_TEXT ) { avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , ""onTextData"" ) ; avio_w8 ( pb , AMF_DATA_TYPE_MIXEDARRAY ) ; avio_wb32 ( pb , 2 ) ; put_amf_string ( pb , ""type"" ) ; avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , ""Text"" ) ; put_amf_string ( pb , ""text"" ) ; avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , pkt -> data ) ; put_amf_string ( pb , """" ) ; avio_w8 ( pb , AMF_END_OF_OBJECT ) ; } else { avio_write ( pb , data ? data : pkt -> data , size ) ; } data_size = avio_tell ( pb ) - metadata_size_pos ; avio_seek ( pb , metadata_size_pos - 10 , SEEK_SET ) ; avio_wb24 ( pb , data_size ) ; avio_seek ( pb , data_size + 10 - 3 , SEEK_CUR ) ; avio_wb32 ( pb , data_size + 11 ) ; } else { av_assert1 ( flags >= 0 ) ; avio_w8 ( pb , flags ) ; if ( par -> codec_id == AV_CODEC_ID_VP6 ) avio_w8 ( pb , 0 ) ; if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A ) { if ( par -> extradata_size ) avio_w8 ( pb , par -> extradata [ 0 ] ) ; else avio_w8 ( pb , ( ( FFALIGN ( par -> width , 16 ) - par -> width ) << 4 ) | ( FFALIGN ( par -> height , 16 ) - par -> height ) ) ; } else if ( par -> codec_id == AV_CODEC_ID_AAC ) avio_w8 ( pb , 1 ) ; else if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { avio_w8 ( pb , 1 ) ; avio_wb24 ( pb , pkt -> pts - pkt -> dts ) ; } avio_write ( pb , data ? data : pkt -> data , size ) ; avio_wb32 ( pb , size + flags_size + 11 ) ; flv -> duration = FFMAX ( flv -> duration , pkt -> pts + flv -> delay + pkt -> duration ) ; } if ( flv -> flags & FLV_ADD_KEYFRAME_INDEX ) { switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : flv -> videosize += ( avio_tell ( pb ) - cur_offset ) ; flv -> lasttimestamp = flv -> acurframeindex / flv -> framerate ; if ( pkt -> flags & AV_PKT_FLAG_KEY ) { double ts = flv -> acurframeindex / flv -> framerate ; int64_t pos = cur_offset ; flv -> lastkeyframetimestamp = flv -> acurframeindex / flv -> framerate ; flv -> lastkeyframelocation = pos ; flv_append_keyframe_info ( s , flv , ts , pos ) ; } flv -> acurframeindex ++ ; break ; case AVMEDIA_TYPE_AUDIO : flv -> audiosize += ( avio_tell ( pb ) - cur_offset ) ; break ; default : av_log ( s , AV_LOG_WARNING , ""par->codec_type<S2SV_blank>is<S2SV_blank>type<S2SV_blank>=<S2SV_blank>[%d]\\n"" , par -> codec_type ) ; break ; } } av_free ( data ) ; return pb -> error ; }
","<S2SV_ModStart> pb ) ; if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , ""Empty<S2SV_blank>audio<S2SV_blank>Packet\\n"" ) ; return AVERROR ( EINVAL ) ; }
",FFmpeg@FFmpeg/6b67d7f05918f7a1ee8fc6ff21355d7e8736aa10,CVE-2018-15822,https://github.com/FFmpeg/FFmpeg/commit/6b67d7f05918f7a1ee8fc6ff21355d7e8736aa10,2018-08-23T23:29Z,<S2SV_StartBug> int64_t cur_offset = avio_tell ( pb ) ; <S2SV_EndBug>
232,CWE-17,"<S2SV_StartBug> static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName , <S2SV_EndBug> <S2SV_StartBug> int udfLen , uint8_t * fidName , <S2SV_EndBug> int fidNameLen ) { int index , newIndex = 0 , needsCRC = 0 ; int extIndex = 0 , newExtIndex = 0 , hasExt = 0 ; unsigned short valueCRC ; uint8_t curr ; if ( udfName [ 0 ] == '.' && ( udfLen == 1 || ( udfLen == 2 && udfName [ 1 ] == '.' ) ) ) { needsCRC = 1 ; newIndex = udfLen ; memcpy ( newName , udfName , udfLen ) ; } else { for ( index = 0 ; index < udfLen ; index ++ ) { curr = udfName [ index ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( index + 1 < udfLen && ( udfName [ index + 1 ] == '/' || udfName [ index + 1 ] == 0 ) ) index ++ ; } if ( curr == EXT_MARK && ( udfLen - index - 1 ) <= EXT_SIZE ) { if ( udfLen == index + 1 ) hasExt = 0 ; else { hasExt = 1 ; extIndex = index ; newExtIndex = newIndex ; } } <S2SV_StartBug> if ( newIndex < 256 ) <S2SV_EndBug> newName [ newIndex ++ ] = curr ; else needsCRC = 1 ; } } if ( needsCRC ) { uint8_t ext [ EXT_SIZE ] ; int localExtIndex = 0 ; if ( hasExt ) { int maxFilenameLen ; for ( index = 0 ; index < EXT_SIZE && extIndex + index + 1 < udfLen ; index ++ ) { curr = udfName [ extIndex + index + 1 ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( extIndex + index + 2 < udfLen && ( index + 1 < EXT_SIZE && ( udfName [ extIndex + index + 2 ] == '/' || udfName [ extIndex + index + 2 ] == 0 ) ) ) index ++ ; } ext [ localExtIndex ++ ] = curr ; } <S2SV_StartBug> maxFilenameLen = 250 - localExtIndex ; <S2SV_EndBug> if ( newIndex > maxFilenameLen ) newIndex = maxFilenameLen ; else newIndex = newExtIndex ; <S2SV_StartBug> } else if ( newIndex > 250 ) <S2SV_EndBug> newIndex = 250 ; newName [ newIndex ++ ] = CRC_MARK ; valueCRC = crc_itu_t ( 0 , fidName , fidNameLen ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC ) ; if ( hasExt ) { newName [ newIndex ++ ] = EXT_MARK ; for ( index = 0 ; index < localExtIndex ; index ++ ) newName [ newIndex ++ ] = ext [ index ] ; } } return newIndex ; }
","<S2SV_ModStart> * newName , int newLen , <S2SV_ModStart> * udfName , int udfLen , <S2SV_ModEnd> uint8_t * fidName <S2SV_ModStart> ( newIndex < newLen <S2SV_ModEnd> ) newName [ <S2SV_ModStart> } maxFilenameLen = newLen - CRC_LEN <S2SV_ModEnd> - localExtIndex ; <S2SV_ModStart> ( newIndex > newLen - CRC_LEN ) newIndex = newLen - CRC_LEN <S2SV_ModEnd> ; newName [
",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z,"<S2SV_StartBug> static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName , <S2SV_EndBug> <S2SV_StartBug> int udfLen , uint8_t * fidName , <S2SV_EndBug> <S2SV_StartBug> if ( newIndex < 256 ) <S2SV_EndBug> <S2SV_StartBug> maxFilenameLen = 250 - localExtIndex ; <S2SV_EndBug> <S2SV_StartBug> } else if ( newIndex > 250 ) <S2SV_EndBug>"
3740,CWE-125,"static int ospf6_print_lshdr ( netdissect_options * ndo , register const struct lsa6_hdr * lshp , const u_char * dataend ) { if ( ( const u_char * ) ( lshp + 1 ) > dataend ) goto trunc ; <S2SV_StartBug> ND_TCHECK ( lshp -> ls_type ) ; <S2SV_EndBug> ND_TCHECK ( lshp -> ls_seq ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s,<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>age<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u"" , ipaddr_string ( ndo , & lshp -> ls_router ) , EXTRACT_32BITS ( & lshp -> ls_seq ) , EXTRACT_16BITS ( & lshp -> ls_age ) , EXTRACT_16BITS ( & lshp -> ls_length ) - ( u_int ) sizeof ( struct lsa6_hdr ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lshp -> ls_type ) , & lshp -> ls_stateid ) ; return ( 0 ) ; trunc : return ( 1 ) ; }
","<S2SV_ModStart> ( lshp -> ls_length <S2SV_ModEnd> ) ; ND_PRINT
",the-tcpdump-group@tcpdump/e01c9bf76740802025c9328901b55ee4a0c49ed6,CVE-2018-14880,https://github.com/the-tcpdump-group/tcpdump/commit/e01c9bf76740802025c9328901b55ee4a0c49ed6,2019-10-03T16:15Z,<S2SV_StartBug> ND_TCHECK ( lshp -> ls_type ) ; <S2SV_EndBug>
2643,CWE-000,"static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , <S2SV_StartBug> int transhdrlen , int mtu , unsigned int flags ) <S2SV_EndBug> { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return - ENOMEM ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> ip_summed = CHECKSUM_PARTIAL ; skb -> csum = 0 ; } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; <S2SV_StartBug> ipv6_select_ident ( & fhdr ) ; <S2SV_EndBug> skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; return 0 ; } kfree_skb ( skb ) ; return err ; }
","<S2SV_ModStart> unsigned int flags , struct rt6_info * rt <S2SV_ModStart> ( & fhdr , rt
",torvalds@linux/87c48fa3b4630905f98268dde838ee43626a060c,CVE-2011-2699,https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c,2012-05-24T23:55Z,"<S2SV_StartBug> int transhdrlen , int mtu , unsigned int flags ) <S2SV_EndBug> <S2SV_StartBug> ipv6_select_ident ( & fhdr ) ; <S2SV_EndBug>"
1739,CWE-119,"static INLINE void fdct32x32 ( int rd_transform , <S2SV_StartBug> const int16_t * src , int16_t * dst , int src_stride ) { <S2SV_EndBug> if ( rd_transform ) <S2SV_StartBug> vp9_fdct32x32_rd ( src , dst , src_stride ) ; <S2SV_EndBug> else <S2SV_StartBug> vp9_fdct32x32 ( src , dst , src_stride ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * src , tran_low_t <S2SV_ModEnd> * dst , <S2SV_ModStart> ( rd_transform ) vpx_fdct32x32_rd <S2SV_ModEnd> ( src , <S2SV_ModStart> ) ; else vpx_fdct32x32 <S2SV_ModEnd> ( src ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> const int16_t * src , int16_t * dst , int src_stride ) { <S2SV_EndBug> <S2SV_StartBug> vp9_fdct32x32_rd ( src , dst , src_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_fdct32x32 ( src , dst , src_stride ) ; <S2SV_EndBug>"
1230,CWE-125,"static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , ""(pad1)"" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(padn:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(padn)"" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , ""(altcoa:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; <S2SV_EndBug> break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ; ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , ""(auth:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(auth)"" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)"" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(type-0x%02x:<S2SV_blank>len=%u)"" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }
","<S2SV_ModStart> trunc ; } ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;
",the-tcpdump-group@tcpdump/5338aac7b8b880b0c5e0c15e27dadc44c5559284,CVE-2017-13025,https://github.com/the-tcpdump-group/tcpdump/commit/5338aac7b8b880b0c5e0c15e27dadc44c5559284,2017-09-14T06:29Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; <S2SV_EndBug>"
1407,CWE-119,"<S2SV_StartBug> int vp8_denoiser_filter_neon ( YV12_BUFFER_CONFIG * mc_running_avg , <S2SV_EndBug> YV12_BUFFER_CONFIG * running_avg , MACROBLOCK * signal , unsigned int motion_magnitude , int y_offset , int uv_offset ) { const uint8x16_t v_level1_adjustment = vdupq_n_u8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 4 : 3 ) ; const uint8x16_t v_delta_level_1_and_2 = vdupq_n_u8 ( 1 ) ; const uint8x16_t v_delta_level_2_and_3 = vdupq_n_u8 ( 2 ) ; const uint8x16_t v_level1_threshold = vdupq_n_u8 ( 4 ) ; const uint8x16_t v_level2_threshold = vdupq_n_u8 ( 8 ) ; const uint8x16_t v_level3_threshold = vdupq_n_u8 ( 16 ) ; <S2SV_StartBug> unsigned char * sig = signal -> thismb ; <S2SV_EndBug> int sig_stride = 16 ; unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ; int mc_running_avg_y_stride = mc_running_avg -> y_stride ; unsigned char * running_avg_y = running_avg -> y_buffer + y_offset ; int running_avg_y_stride = running_avg -> y_stride ; int i ; int sum_diff = 0 ; <S2SV_StartBug> for ( i = 0 ; i < 16 ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> int8x16_t v_sum_diff = vdupq_n_s8 ( 0 ) ; <S2SV_EndBug> uint8x16_t v_running_avg_y ; const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_level1_mask = vcleq_u8 ( v_level1_threshold , v_abs_diff ) ; const uint8x16_t v_level2_mask = vcleq_u8 ( v_level2_threshold , v_abs_diff ) ; const uint8x16_t v_level3_mask = vcleq_u8 ( v_level3_threshold , v_abs_diff ) ; const uint8x16_t v_level2_adjustment = vandq_u8 ( v_level2_mask , v_delta_level_1_and_2 ) ; const uint8x16_t v_level3_adjustment = vandq_u8 ( v_level3_mask , v_delta_level_2_and_3 ) ; const uint8x16_t v_level1and2_adjustment = vaddq_u8 ( v_level1_adjustment , v_level2_adjustment ) ; const uint8x16_t v_level1and2and3_adjustment = vaddq_u8 ( v_level1and2_adjustment , v_level3_adjustment ) ; const uint8x16_t v_abs_adjustment = vbslq_u8 ( v_level1_mask , v_level1and2and3_adjustment , v_abs_diff ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; v_running_avg_y = vqaddq_u8 ( v_sig , v_pos_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_neg_adjustment ) ; v_sum_diff = vqaddq_s8 ( v_sum_diff , vreinterpretq_s8_u8 ( v_pos_adjustment ) ) ; v_sum_diff = vqsubq_s8 ( v_sum_diff , vreinterpretq_s8_u8 ( v_neg_adjustment ) ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { int s0 = vgetq_lane_s8 ( v_sum_diff , 0 ) + vgetq_lane_s8 ( v_sum_diff , 1 ) + vgetq_lane_s8 ( v_sum_diff , 2 ) + vgetq_lane_s8 ( v_sum_diff , 3 ) ; int s1 = vgetq_lane_s8 ( v_sum_diff , 4 ) + vgetq_lane_s8 ( v_sum_diff , 5 ) + vgetq_lane_s8 ( v_sum_diff , 6 ) + vgetq_lane_s8 ( v_sum_diff , 7 ) ; int s2 = vgetq_lane_s8 ( v_sum_diff , 8 ) + vgetq_lane_s8 ( v_sum_diff , 9 ) + vgetq_lane_s8 ( v_sum_diff , 10 ) + vgetq_lane_s8 ( v_sum_diff , 11 ) ; int s3 = vgetq_lane_s8 ( v_sum_diff , 12 ) + vgetq_lane_s8 ( v_sum_diff , 13 ) + vgetq_lane_s8 ( v_sum_diff , 14 ) + vgetq_lane_s8 ( v_sum_diff , 15 ) ; sum_diff += s0 + s1 + s2 + s3 ; } sig += sig_stride ; mc_running_avg_y += mc_running_avg_y_stride ; running_avg_y += running_avg_y_stride ; } <S2SV_StartBug> if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) <S2SV_EndBug> return COPY_BLOCK ; <S2SV_StartBug> vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , running_avg_y_stride , <S2SV_EndBug> <S2SV_StartBug> signal -> thismb , sig_stride ) ; <S2SV_EndBug> return FILTER_BLOCK ; }
","<S2SV_ModStart> int vp8_denoiser_filter_neon ( unsigned char * mc_running_avg_y , int mc_running_avg_y_stride , unsigned char * running_avg_y , int running_avg_y_stride , <S2SV_ModEnd> unsigned char * <S2SV_ModStart> char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { int shift_inc = ( increase_denoising && motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 1 : 0 ; const uint8x16_t v_level1_adjustment = vmovq_n_u8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 4 + shift_inc : 3 ) ; const uint8x16_t v_delta_level_1_and_2 = vdupq_n_u8 ( 1 ) ; const uint8x16_t v_delta_level_2_and_3 = vdupq_n_u8 ( 2 ) ; const uint8x16_t v_level1_threshold = vmovq_n_u8 ( 4 + shift_inc ) ; const uint8x16_t v_level2_threshold = vdupq_n_u8 ( 8 ) ; const uint8x16_t v_level3_threshold = vdupq_n_u8 ( 16 ) ; int64x2_t v_sum_diff_total = vdupq_n_s64 ( 0 ) ; int r <S2SV_ModEnd> ; for ( <S2SV_ModStart> ; for ( r <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; r <S2SV_ModEnd> < 16 ; <S2SV_ModStart> 16 ; ++ r ) { const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_level1_mask = vcleq_u8 ( v_level1_threshold , v_abs_diff ) ; const uint8x16_t v_level2_mask = vcleq_u8 ( v_level2_threshold , v_abs_diff ) ; const uint8x16_t v_level3_mask = vcleq_u8 ( v_level3_threshold , v_abs_diff ) ; const uint8x16_t v_level2_adjustment = vandq_u8 ( v_level2_mask , v_delta_level_1_and_2 ) ; const uint8x16_t v_level3_adjustment = vandq_u8 ( v_level3_mask , v_delta_level_2_and_3 ) ; const uint8x16_t v_level1and2_adjustment = vaddq_u8 ( v_level1_adjustment , v_level2_adjustment ) ; const uint8x16_t v_level1and2and3_adjustment = vaddq_u8 ( v_level1and2_adjustment , v_level3_adjustment ) ; const uint8x16_t v_abs_adjustment = vbslq_u8 ( v_level1_mask , v_level1and2and3_adjustment , v_abs_diff ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; uint8x16_t v_running_avg_y = vqaddq_u8 ( v_sig , v_pos_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_neg_adjustment ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { const <S2SV_ModEnd> int8x16_t v_sum_diff = <S2SV_ModStart> int8x16_t v_sum_diff = vqsubq_s8 ( vreinterpretq_s8_u8 ( v_pos_adjustment ) , vreinterpretq_s8_u8 ( v_neg_adjustment ) ) ; const int16x8_t fe_dc_ba_98_76_54_32_10 = vpaddlq_s8 ( v_sum_diff ) ; const int32x4_t fedc_ba98_7654_3210 = vpaddlq_s16 ( fe_dc_ba_98_76_54_32_10 ) ; const int64x2_t fedcba98_76543210 = vpaddlq_s32 ( fedc_ba98_7654_3210 ) ; v_sum_diff_total = vqaddq_s64 ( v_sum_diff_total , fedcba98_76543210 ) <S2SV_ModEnd> ; } sig <S2SV_ModStart> running_avg_y_stride ; } { int64x1_t x = vqadd_s64 ( vget_high_s64 ( v_sum_diff_total ) , vget_low_s64 ( v_sum_diff_total ) ) ; int sum_diff = vget_lane_s32 ( vabs_s32 ( vreinterpret_s32_s64 ( x ) ) , 0 ) ; int sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( sum_diff > sum_diff_thresh ) { int delta = ( ( sum_diff - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { const uint8x16_t k_delta = vmovq_n_u8 ( delta ) ; sig -= sig_stride * 16 ; mc_running_avg_y -= mc_running_avg_y_stride * 16 ; running_avg_y -= running_avg_y_stride * 16 ; for ( r = 0 ; r < 16 ; ++ r ) { uint8x16_t v_running_avg_y = vld1q_u8 ( running_avg_y ) ; const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_abs_adjustment = vminq_u8 ( v_abs_diff , ( k_delta ) ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_pos_adjustment ) ; v_running_avg_y = vqaddq_u8 ( v_running_avg_y , v_neg_adjustment ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { const int8x16_t v_sum_diff = vqsubq_s8 ( vreinterpretq_s8_u8 ( v_neg_adjustment ) , vreinterpretq_s8_u8 ( v_pos_adjustment ) ) ; const int16x8_t fe_dc_ba_98_76_54_32_10 = vpaddlq_s8 ( v_sum_diff ) ; const int32x4_t fedc_ba98_7654_3210 = vpaddlq_s16 ( fe_dc_ba_98_76_54_32_10 ) ; const int64x2_t fedcba98_76543210 = vpaddlq_s32 ( fedc_ba98_7654_3210 ) ; v_sum_diff_total = vqaddq_s64 ( v_sum_diff_total , fedcba98_76543210 ) ; } sig += sig_stride ; mc_running_avg_y += mc_running_avg_y_stride ; running_avg_y += running_avg_y_stride ; } { x = vqadd_s64 ( vget_high_s64 ( v_sum_diff_total ) , vget_low_s64 ( v_sum_diff_total ) ) ; sum_diff = vget_lane_s32 ( vabs_s32 ( vreinterpret_s32_s64 ( x ) ) , 0 ) ; if ( sum_diff > sum_diff_thresh ) { <S2SV_ModEnd> return COPY_BLOCK ; <S2SV_ModStart> return COPY_BLOCK ; } } } else { return COPY_BLOCK ; } } } running_avg_y -= running_avg_y_stride * 16 ; sig -= sig_stride * 16 ; vp8_copy_mem16x16 ( running_avg_y <S2SV_ModEnd> , running_avg_y_stride , <S2SV_ModStart> , running_avg_y_stride , sig <S2SV_ModEnd> , sig_stride )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int vp8_denoiser_filter_neon ( YV12_BUFFER_CONFIG * mc_running_avg , <S2SV_EndBug> <S2SV_StartBug> unsigned char * sig = signal -> thismb ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 16 ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> int8x16_t v_sum_diff = vdupq_n_s8 ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) <S2SV_EndBug> <S2SV_StartBug> vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , running_avg_y_stride , <S2SV_EndBug> <S2SV_StartBug> signal -> thismb , sig_stride ) ; <S2SV_EndBug>"
7757,CWE-000,"<S2SV_StartBug> static void encode_share_access ( struct xdr_stream * xdr , int open_flags ) <S2SV_EndBug> { __be32 * p ; RESERVE_SPACE ( 8 ) ; <S2SV_StartBug> switch ( open_flags & ( FMODE_READ | FMODE_WRITE ) ) { <S2SV_EndBug> case FMODE_READ : WRITE32 ( NFS4_SHARE_ACCESS_READ ) ; break ; case FMODE_WRITE : WRITE32 ( NFS4_SHARE_ACCESS_WRITE ) ; break ; case FMODE_READ | FMODE_WRITE : WRITE32 ( NFS4_SHARE_ACCESS_BOTH ) ; break ; default : <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } WRITE32 ( 0 ) ; }
","<S2SV_ModStart> * xdr , fmode_t fmode <S2SV_ModEnd> ) { __be32 <S2SV_ModStart> ; switch ( fmode <S2SV_ModEnd> & ( FMODE_READ <S2SV_ModStart> ; default : WRITE32 ( 0 <S2SV_ModEnd> ) ; }
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static void encode_share_access ( struct xdr_stream * xdr , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> switch ( open_flags & ( FMODE_READ | FMODE_WRITE ) ) { <S2SV_EndBug> <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug>"
1762,CWE-119,"static void define_gf_group ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame ) { <S2SV_StartBug> RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_EndBug> <S2SV_StartBug> VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> struct twopass_rc * const twopass = & cpi -> twopass ; <S2SV_EndBug> <S2SV_StartBug> FIRSTPASS_STATS next_frame = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> const FIRSTPASS_STATS * start_pos ; <S2SV_EndBug> int i ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double gf_group_err = 0.0 ; <S2SV_StartBug> double gf_first_frame_err = 0.0 ; <S2SV_EndBug> double mod_frame_err = 0.0 ; double mv_ratio_accumulator = 0.0 ; double decay_accumulator = 1.0 ; double zero_motion_accumulator = 1.0 ; double loop_decay_rate = 1.00 ; double last_loop_decay_rate = 1.00 ; double this_frame_mv_in_out = 0.0 ; double mv_in_out_accumulator = 0.0 ; double abs_mv_in_out_accumulator = 0.0 ; double mv_ratio_accumulator_thresh ; <S2SV_StartBug> const int max_bits = frame_max_bits ( rc , oxcf ) ; <S2SV_EndBug> unsigned int allow_alt_ref = oxcf -> play_alternate && oxcf -> lag_in_frames ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; int active_max_gf_interval ; twopass -> gf_group_bits = 0 ; vp9_clear_system_state ( ) ; start_pos = twopass -> stats_in ; mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active ) gf_group_err -= gf_first_frame_err ; <S2SV_StartBug> mv_ratio_accumulator_thresh = ( cpi -> common . width + cpi -> common . height ) / 10.0 ; <S2SV_EndBug> active_max_gf_interval = 12 + ( ( int ) vp9_convert_qindex_to_q ( rc -> last_q [ INTER_FRAME ] ) >> 5 ) ; if ( active_max_gf_interval > rc -> max_gf_interval ) <S2SV_StartBug> active_max_gf_interval = rc -> max_gf_interval ; <S2SV_EndBug> i = 0 ; while ( i < rc -> static_scene_max_gf_interval && i < rc -> frames_to_key ) { ++ i ; <S2SV_StartBug> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; <S2SV_EndBug> gf_group_err += mod_frame_err ; <S2SV_StartBug> if ( EOF == input_stats ( twopass , & next_frame ) ) <S2SV_EndBug> break ; flash_detected = detect_flash ( twopass , 0 ) ; accumulate_frame_motion_stats ( & next_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ; if ( ! flash_detected ) { last_loop_decay_rate = loop_decay_rate ; <S2SV_StartBug> loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ; <S2SV_EndBug> decay_accumulator = decay_accumulator * loop_decay_rate ; <S2SV_StartBug> if ( ( next_frame . pcnt_inter - next_frame . pcnt_motion ) < <S2SV_EndBug> zero_motion_accumulator ) { zero_motion_accumulator = next_frame . pcnt_inter - next_frame . pcnt_motion ; } <S2SV_StartBug> if ( detect_transition_to_still ( twopass , i , 5 , loop_decay_rate , <S2SV_EndBug> last_loop_decay_rate ) ) { allow_alt_ref = 0 ; break ; } } <S2SV_StartBug> boost_score += ( decay_accumulator * <S2SV_EndBug> <S2SV_StartBug> calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ) ; <S2SV_EndBug> if ( <S2SV_StartBug> ( i >= active_max_gf_interval && ( zero_motion_accumulator < 0.995 ) ) || <S2SV_EndBug> ( <S2SV_StartBug> ( i > MIN_GF_INTERVAL ) && <S2SV_EndBug> ( ( boost_score > 125.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > mv_ratio_accumulator_thresh ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) || <S2SV_StartBug> ( ( boost_score - old_boost_score ) < IIFACTOR ) ) ) ) { <S2SV_EndBug> boost_score = old_boost_score ; break ; } * this_frame = next_frame ; old_boost_score = boost_score ; } twopass -> gf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 1000.0 ) ; <S2SV_StartBug> if ( ( rc -> frames_to_key - i ) < MIN_GF_INTERVAL ) { <S2SV_EndBug> <S2SV_StartBug> while ( i < ( rc -> frames_to_key + ! rc -> next_key_frame_forced ) ) { <S2SV_EndBug> ++ i ; if ( EOF == input_stats ( twopass , this_frame ) ) break ; <S2SV_StartBug> if ( i < rc -> frames_to_key ) { <S2SV_EndBug> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; } } } # if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) { cpi -> new_frame_coding_order_period = 0 ; cpi -> next_frame_in_order = 0 ; cpi -> arf_buffered = 0 ; vp9_zero ( cpi -> frame_coding_order ) ; vp9_zero ( cpi -> arf_buffer_idx ) ; vpx_memset ( cpi -> arf_weight , - 1 , sizeof ( cpi -> arf_weight ) ) ; } # endif if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active ) <S2SV_StartBug> rc -> baseline_gf_interval = i - 1 ; <S2SV_EndBug> else <S2SV_StartBug> rc -> baseline_gf_interval = i ; <S2SV_EndBug> if ( allow_alt_ref && <S2SV_StartBug> ( i < cpi -> oxcf . lag_in_frames ) && <S2SV_EndBug> ( i >= MIN_GF_INTERVAL ) && ( rc -> next_key_frame_forced || ( i <= ( rc -> frames_to_key - MIN_GF_INTERVAL ) ) ) ) { rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; rc -> source_alt_ref_pending = 1 ; # if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) { schedule_frames ( cpi , 0 , - ( rc -> baseline_gf_interval - 1 ) , 2 , 1 , 0 ) ; } # endif <S2SV_StartBug> } else { <S2SV_EndBug> rc -> gfu_boost = ( int ) boost_score ; rc -> source_alt_ref_pending = 0 ; # if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) { schedule_frames ( cpi , 0 , rc -> baseline_gf_interval - 1 , 2 , 0 , 0 ) ; assert ( cpi -> new_frame_coding_order_period == rc -> baseline_gf_interval ) ; } # endif } # if CONFIG_MULTIPLE_ARF <S2SV_StartBug> if ( cpi -> multi_arf_enabled && ( cpi -> common . frame_type != KEY_FRAME ) ) { <S2SV_EndBug> int max_level = INT_MIN ; for ( i = 0 ; i < cpi -> frame_coding_order_period ; ++ i ) { if ( cpi -> arf_weight [ i ] > max_level ) { max_level = cpi -> arf_weight [ i ] ; } } ++ max_level ; for ( i = 0 ; i < cpi -> frame_coding_order_period ; ++ i ) { if ( cpi -> arf_weight [ i ] == - 1 ) { cpi -> arf_weight [ i ] = max_level ; } } cpi -> max_arf_level = max_level ; } # if 0 if ( cpi -> multi_arf_enabled ) { printf ( ""\\nSchedule:<S2SV_blank>"" ) ; for ( i = 0 ; i < cpi -> new_frame_coding_order_period ; ++ i ) { printf ( ""%4d<S2SV_blank>"" , cpi -> frame_coding_order [ i ] ) ; } printf ( ""\\n"" ) ; printf ( ""ARFref:<S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; for ( i = 0 ; i < cpi -> new_frame_coding_order_period ; ++ i ) { printf ( ""%4d<S2SV_blank>"" , cpi -> arf_buffer_idx [ i ] ) ; } printf ( ""\\n"" ) ; printf ( ""Weight:<S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; for ( i = 0 ; i < cpi -> new_frame_coding_order_period ; ++ i ) { printf ( ""%4d<S2SV_blank>"" , cpi -> arf_weight [ i ] ) ; } printf ( ""\\n"" ) ; } # endif # endif if ( twopass -> kf_group_bits > 0 && twopass -> kf_group_error_left > 0 ) { twopass -> gf_group_bits = ( int64_t ) ( twopass -> kf_group_bits * ( gf_group_err / twopass -> kf_group_error_left ) ) ; } else { twopass -> gf_group_bits = 0 ; } twopass -> gf_group_bits = ( twopass -> gf_group_bits < 0 ) ? 0 : ( twopass -> gf_group_bits > twopass -> kf_group_bits ) ? twopass -> kf_group_bits : twopass -> gf_group_bits ; if ( twopass -> gf_group_bits > ( int64_t ) max_bits * rc -> baseline_gf_interval ) twopass -> gf_group_bits = ( int64_t ) max_bits * rc -> baseline_gf_interval ; reset_fpf_position ( twopass , start_pos ) ; for ( i = 0 ; i <= ( rc -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) ; ++ i ) { int allocation_chunks ; int q = rc -> last_q [ INTER_FRAME ] ; int gf_bits ; int boost = ( rc -> gfu_boost * gfboost_qadjust ( q ) ) / 100 ; boost = clamp ( boost , 125 , ( rc -> baseline_gf_interval + 1 ) * 200 ) ; if ( rc -> source_alt_ref_pending && i == 0 ) allocation_chunks = ( ( rc -> baseline_gf_interval + 1 ) * 100 ) + boost ; else allocation_chunks = ( rc -> baseline_gf_interval * 100 ) + ( boost - 100 ) ; if ( boost > 1023 ) { int divisor = boost >> 10 ; boost /= divisor ; allocation_chunks /= divisor ; } gf_bits = ( int ) ( ( double ) boost * ( twopass -> gf_group_bits / ( double ) allocation_chunks ) ) ; if ( rc -> baseline_gf_interval < 1 || mod_frame_err < gf_group_err / ( double ) rc -> baseline_gf_interval ) { double alt_gf_grp_bits = ( double ) twopass -> kf_group_bits * ( mod_frame_err * ( double ) rc -> baseline_gf_interval ) / DOUBLE_DIVIDE_CHECK ( twopass -> kf_group_error_left ) ; int alt_gf_bits = ( int ) ( ( double ) boost * ( alt_gf_grp_bits / ( double ) allocation_chunks ) ) ; if ( gf_bits > alt_gf_bits ) gf_bits = alt_gf_bits ; } else { int alt_gf_bits = ( int ) ( ( double ) twopass -> kf_group_bits * mod_frame_err / DOUBLE_DIVIDE_CHECK ( twopass -> kf_group_error_left ) ) ; if ( alt_gf_bits > gf_bits ) gf_bits = alt_gf_bits ; } if ( gf_bits < 0 ) gf_bits = 0 ; if ( i == 0 ) { twopass -> gf_bits = gf_bits ; } if ( i == 1 || ( ! rc -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) ) { vp9_rc_set_frame_target ( cpi , gf_bits ) ; } } { twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ; if ( rc -> source_alt_ref_pending ) { twopass -> gf_group_error_left = ( int64_t ) ( gf_group_err - mod_frame_err ) ; } else if ( cpi -> common . frame_type != KEY_FRAME ) { twopass -> gf_group_error_left = ( int64_t ) ( gf_group_err - gf_first_frame_err ) ; } else { twopass -> gf_group_error_left = ( int64_t ) gf_group_err ; } if ( rc -> baseline_gf_interval >= 3 ) { const int boost = rc -> source_alt_ref_pending ? b_boost : rc -> gfu_boost ; if ( boost >= 150 ) { const int pct_extra = MIN ( 20 , ( boost - 100 ) / 50 ) ; const int alt_extra_bits = ( int ) ( ( MAX ( twopass -> gf_group_bits - twopass -> gf_bits , 0 ) * pct_extra ) / 100 ) ; twopass -> gf_group_bits -= alt_extra_bits ; } } } if ( cpi -> common . frame_type != KEY_FRAME ) { FIRSTPASS_STATS sectionstats ; zero_stats ( & sectionstats ) ; reset_fpf_position ( twopass , start_pos ) ; for ( i = 0 ; i < rc -> baseline_gf_interval ; ++ i ) { input_stats ( twopass , & next_frame ) ; accumulate_stats ( & sectionstats , & next_frame ) ; } avg_stats ( & sectionstats ) ; twopass -> section_intra_rating = ( int ) ( sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; reset_fpf_position ( twopass , start_pos ) ; } }
","<S2SV_ModStart> this_frame ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModStart> -> rc ; VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> -> oxcf ; TWO_PASS <S2SV_ModEnd> * const twopass <S2SV_ModStart> ; FIRSTPASS_STATS next_frame <S2SV_ModEnd> ; const FIRSTPASS_STATS <S2SV_ModStart> const FIRSTPASS_STATS * const start_pos = twopass -> stats_in <S2SV_ModEnd> ; int i <S2SV_ModStart> = 0.0 ; # if GROUP_ADAPTIVE_MAXQ double gf_group_raw_error = 0.0 ; # endif double gf_group_skip_pct = 0.0 ; double gf_group_inactive_zone_rows = 0.0 ; <S2SV_ModStart> double mv_ratio_accumulator_thresh ; unsigned int allow_alt_ref = is_altref_enabled ( cpi ) ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; int active_max_gf_interval ; int active_min_gf_interval ; int64_t gf_group_bits ; double gf_group_error_left ; int gf_arf_bits ; const int is_key_frame = frame_is_intra_only ( cm ) ; const int arf_active_or_kf = is_key_frame || rc -> source_alt_ref_active ; if ( is_key_frame == 0 ) { vp9_zero ( twopass -> gf_group ) ; } vpx_clear_system_state ( ) ; vp9_zero ( next_frame ) ; mod_frame_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( arf_active_or_kf ) { <S2SV_ModEnd> gf_group_err -= gf_first_frame_err <S2SV_ModStart> -= gf_first_frame_err ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error -= this_frame -> coded_error ; # endif gf_group_skip_pct -= this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows -= this_frame -> inactive_zone_rows ; } mv_ratio_accumulator_thresh = ( cpi -> initial_height + cpi -> initial_width ) / 4.0 ; { int int_max_q = ( int ) ( vp9_convert_qindex_to_q ( twopass -> active_worst_quality , <S2SV_ModEnd> cpi -> common <S2SV_ModStart> -> common . bit_depth ) ) ; int int_lbq = ( int ) ( vp9_convert_qindex_to_q ( rc -> last_boosted_qindex , <S2SV_ModEnd> cpi -> common <S2SV_ModStart> -> common . bit_depth ) ) ; active_min_gf_interval = rc -> min_gf_interval + MIN ( 2 , int_max_q / 200 ) ; if ( active_min_gf_interval > rc -> max_gf_interval ) active_min_gf_interval = rc -> max_gf_interval ; if ( cpi -> multi_arf_allowed ) { active_max_gf_interval = rc -> max_gf_interval ; } else { active_max_gf_interval = 12 + MIN ( 4 , ( int_lbq / 6 ) ) ; if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> max_gf_interval ; if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval ; } } <S2SV_ModStart> ( cpi , twopass , oxcf , <S2SV_ModStart> += mod_frame_err ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; <S2SV_ModStart> = get_prediction_decay_rate ( cpi <S2SV_ModEnd> , & next_frame <S2SV_ModStart> * loop_decay_rate ; zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ; <S2SV_ModEnd> if ( detect_transition_to_still <S2SV_ModStart> ( detect_transition_to_still ( cpi <S2SV_ModEnd> , i , <S2SV_ModStart> } boost_score += <S2SV_ModEnd> decay_accumulator * calc_frame_boost <S2SV_ModStart> next_frame , this_frame_mv_in_out , GF_MAX_BOOST <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( i >= ( active_max_gf_interval + arf_active_or_kf ) && <S2SV_ModEnd> zero_motion_accumulator < 0.995 <S2SV_ModStart> < 0.995 ) <S2SV_ModEnd> || ( ( <S2SV_ModStart> ( ( i >= active_min_gf_interval + arf_active_or_kf <S2SV_ModEnd> ) && ( <S2SV_ModStart> old_boost_score ) < BOOST_BREAKOUT <S2SV_ModEnd> ) ) ) <S2SV_ModStart> 1000.0 ) ; rc -> constrained_gf_group = ( i >= <S2SV_ModEnd> rc -> frames_to_key <S2SV_ModStart> rc -> frames_to_key ) ? 1 : 0 ; if ( allow_alt_ref && <S2SV_ModEnd> ( i < <S2SV_ModStart> ( i < cpi -> oxcf . lag_in_frames ) && ( i >= rc -> min_gf_interval ) ) { rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; rc -> source_alt_ref_pending = 1 ; cpi -> multi_arf_enabled = ( cpi -> multi_arf_allowed && ( rc -> baseline_gf_interval >= 6 ) && ( zero_motion_accumulator < 0.995 ) ) ? 1 : 0 ; } else { rc -> gfu_boost = MAX ( ( int ) boost_score , MIN_ARF_GF_BOOST ) ; rc -> source_alt_ref_pending = 0 ; } rc -> baseline_gf_interval = i - ( is_key_frame || rc -> source_alt_ref_pending ) ; if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; int new_gf_interval = ( rc -> baseline_gf_interval + count ) & ( ~ count ) ; int j ; for ( j = 0 ; j < new_gf_interval - rc -> baseline_gf_interval ; ++ j ) { <S2SV_ModEnd> if ( EOF <S2SV_ModStart> ) break ; gf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; } <S2SV_ModEnd> rc -> baseline_gf_interval <S2SV_ModStart> -> baseline_gf_interval = new_gf_interval ; } rc -> frames_till_gf_update_due = <S2SV_ModEnd> rc -> baseline_gf_interval <S2SV_ModStart> rc -> baseline_gf_interval ; reset_fpf_position ( twopass , start_pos ) ; gf_group_bits = calculate_total_gf_group_bits ( cpi , gf_group_err ) ; # if GROUP_ADAPTIVE_MAXQ if ( ( <S2SV_ModEnd> cpi -> oxcf <S2SV_ModStart> -> oxcf . rc_mode != VPX_Q ) && ( rc -> baseline_gf_interval > 1 ) ) { const int vbr_group_bits_per_frame = ( int ) ( gf_group_bits / rc -> baseline_gf_interval ) ; const double group_av_err = gf_group_raw_error / rc -> baseline_gf_interval ; const double group_av_skip_pct = gf_group_skip_pct / rc -> baseline_gf_interval ; const double group_av_inactive_zone = ( ( gf_group_inactive_zone_rows * 2 ) / ( rc -> baseline_gf_interval * ( double ) cm -> mb_rows ) ) ; int tmp_q ; double rc_factor = 1.0 ; if ( rc -> rate_error_estimate > 0 ) { rc_factor = MAX ( RC_FACTOR_MIN , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } else { rc_factor = MIN ( RC_FACTOR_MAX , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } tmp_q = get_twopass_worst_quality ( cpi , group_av_err , ( group_av_skip_pct + group_av_inactive_zone ) , vbr_group_bits_per_frame , twopass -> kfgroup_inter_fraction * rc_factor ) ; twopass -> active_worst_quality = MAX ( tmp_q , twopass -> active_worst_quality >> 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> } # endif gf_arf_bits = calculate_boost_bits ( rc -> baseline_gf_interval , rc -> gfu_boost , gf_group_bits ) ; twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ; if ( rc -> source_alt_ref_pending ) { gf_group_error_left = gf_group_err - mod_frame_err ; } else if ( is_key_frame == 0 ) { gf_group_error_left = gf_group_err - gf_first_frame_err ; } else { gf_group_error_left = gf_group_err ; } allocate_gf_group_bits ( cpi , gf_group_bits , gf_group_error_left , gf_arf_bits ) ; reset_fpf_position ( twopass , start_pos ) ; if <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> != KEY_FRAME ) { twopass -> section_intra_rating = calculate_section_intra_ratio ( start_pos , twopass -> stats_in_end , rc -> baseline_gf_interval ) ; } if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { cpi -> rc . next_frame_size_selector = UNSCALED <S2SV_ModEnd> ; } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_EndBug> <S2SV_StartBug> VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> struct twopass_rc * const twopass = & cpi -> twopass ; <S2SV_EndBug> <S2SV_StartBug> FIRSTPASS_STATS next_frame = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> const FIRSTPASS_STATS * start_pos ; <S2SV_EndBug> <S2SV_StartBug> double gf_first_frame_err = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> const int max_bits = frame_max_bits ( rc , oxcf ) ; <S2SV_EndBug> <S2SV_StartBug> mv_ratio_accumulator_thresh = ( cpi -> common . width + cpi -> common . height ) / 10.0 ; <S2SV_EndBug> <S2SV_StartBug> active_max_gf_interval = rc -> max_gf_interval ; <S2SV_EndBug> <S2SV_StartBug> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( EOF == input_stats ( twopass , & next_frame ) ) <S2SV_EndBug> <S2SV_StartBug> loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( next_frame . pcnt_inter - next_frame . pcnt_motion ) < <S2SV_EndBug> <S2SV_StartBug> if ( detect_transition_to_still ( twopass , i , 5 , loop_decay_rate , <S2SV_EndBug> <S2SV_StartBug> boost_score += ( decay_accumulator * <S2SV_EndBug> <S2SV_StartBug> calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( i >= active_max_gf_interval && ( zero_motion_accumulator < 0.995 ) ) || <S2SV_EndBug> <S2SV_StartBug> ( i > MIN_GF_INTERVAL ) && <S2SV_EndBug> <S2SV_StartBug> ( ( boost_score - old_boost_score ) < IIFACTOR ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( rc -> frames_to_key - i ) < MIN_GF_INTERVAL ) { <S2SV_EndBug> <S2SV_StartBug> while ( i < ( rc -> frames_to_key + ! rc -> next_key_frame_forced ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( i < rc -> frames_to_key ) { <S2SV_EndBug> <S2SV_StartBug> rc -> baseline_gf_interval = i - 1 ; <S2SV_EndBug> <S2SV_StartBug> rc -> baseline_gf_interval = i ; <S2SV_EndBug> <S2SV_StartBug> ( i < cpi -> oxcf . lag_in_frames ) && <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> multi_arf_enabled && ( cpi -> common . frame_type != KEY_FRAME ) ) { <S2SV_EndBug>"
7733,CWE-000,"int nfs4_do_close ( struct path * path , struct nfs4_state * state , int wait ) { struct nfs_server * server = NFS_SERVER ( state -> inode ) ; struct nfs4_closedata * calldata ; struct nfs4_state_owner * sp = state -> owner ; struct rpc_task * task ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_CLOSE ] , . rpc_cred = state -> owner -> so_cred , } ; struct rpc_task_setup task_setup_data = { . rpc_client = server -> client , . rpc_message = & msg , . callback_ops = & nfs4_close_ops , . workqueue = nfsiod_workqueue , . flags = RPC_TASK_ASYNC , } ; int status = - ENOMEM ; calldata = kmalloc ( sizeof ( * calldata ) , GFP_KERNEL ) ; if ( calldata == NULL ) goto out ; calldata -> inode = state -> inode ; calldata -> state = state ; calldata -> arg . fh = NFS_FH ( state -> inode ) ; calldata -> arg . stateid = & state -> open_stateid ; calldata -> arg . seqid = nfs_alloc_seqid ( & state -> owner -> so_seqid ) ; if ( calldata -> arg . seqid == NULL ) goto out_free_calldata ; <S2SV_StartBug> calldata -> arg . open_flags = 0 ; <S2SV_EndBug> calldata -> arg . bitmask = server -> attr_bitmask ; calldata -> res . fattr = & calldata -> fattr ; calldata -> res . seqid = calldata -> arg . seqid ; calldata -> res . server = server ; calldata -> path . mnt = mntget ( path -> mnt ) ; calldata -> path . dentry = dget ( path -> dentry ) ; msg . rpc_argp = & calldata -> arg , msg . rpc_resp = & calldata -> res , task_setup_data . callback_data = calldata ; task = rpc_run_task ( & task_setup_data ) ; if ( IS_ERR ( task ) ) return PTR_ERR ( task ) ; status = 0 ; if ( wait ) status = rpc_wait_for_completion_task ( task ) ; rpc_put_task ( task ) ; return status ; out_free_calldata : kfree ( calldata ) ; out : nfs4_put_open_state ( state ) ; nfs4_put_state_owner ( sp ) ; return status ; }
","<S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> = 0 ;
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,<S2SV_StartBug> calldata -> arg . open_flags = 0 ; <S2SV_EndBug>
2772,CWE-20,"static MagickBooleanType ConcatenateImages ( int argc , char * * argv , ExceptionInfo * exception ) { FILE * input , * output ; <S2SV_StartBug> int <S2SV_EndBug> c ; register ssize_t i ; if ( ExpandFilenames ( & argc , & argv ) == MagickFalse ) ThrowFileException ( exception , ResourceLimitError , ""MemoryAllocationFailed"" , GetExceptionMessage ( errno ) ) ; output = fopen_utf8 ( argv [ argc - 1 ] , ""wb"" ) ; if ( output == ( FILE * ) NULL ) { ThrowFileException ( exception , FileOpenError , ""UnableToOpenFile"" , argv [ argc - 1 ] ) ; return ( MagickFalse ) ; } <S2SV_StartBug> for ( i = 2 ; i < ( ssize_t ) ( argc - 1 ) ; i ++ ) { <S2SV_EndBug> # if 0 fprintf ( stderr , ""DEBUG:<S2SV_blank>Concatenate<S2SV_blank>Image:<S2SV_blank>\\""%s\\""\\n"" , argv [ i ] ) ; # endif input = fopen_utf8 ( argv [ i ] , ""rb"" ) ; if ( input == ( FILE * ) NULL ) { ThrowFileException ( exception , FileOpenError , ""UnableToOpenFile"" , argv [ i ] ) ; continue ; } for ( c = fgetc ( input ) ; c != EOF ; c = fgetc ( input ) ) <S2SV_StartBug> ( void ) fputc ( ( char ) c , output ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) fclose ( input ) ; <S2SV_EndBug> ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( output ) ; <S2SV_StartBug> return ( MagickTrue ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * output ; MagickBooleanType status ; <S2SV_ModStart> ) ; } status = MagickTrue ; <S2SV_ModStart> i ++ ) { <S2SV_ModEnd> input = fopen_utf8 <S2SV_ModStart> input ) ) if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; <S2SV_ModStart> ( void ) fclose ( input <S2SV_ModEnd> ) ; ( <S2SV_ModStart> ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( <S2SV_ModEnd> output ) ; <S2SV_ModStart> ; return ( status <S2SV_ModEnd> ) ; }
",ImageMagick@ImageMagick/933e96f01a8c889c7bf5ffd30020e86a02a046e7,CVE-2016-10060,https://github.com/ImageMagick/ImageMagick/commit/933e96f01a8c889c7bf5ffd30020e86a02a046e7,2017-03-02T21:59Z,"<S2SV_StartBug> int <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( ssize_t ) ( argc - 1 ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( ( char ) c , output ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) fclose ( input ) ; <S2SV_EndBug> <S2SV_StartBug> return ( MagickTrue ) ; <S2SV_EndBug>"
2816,CWE-125,"static void print_trans ( netdissect_options * ndo , const u_char * words , const u_char * data1 , const u_char * buf , const u_char * maxbuf ) { u_int bcc ; const char * f1 , * f2 , * f3 , * f4 ; const u_char * data , * param ; const u_char * w = words + 1 ; int datalen , paramlen ; if ( request ) { ND_TCHECK2 ( w [ 12 * 2 ] , 2 ) ; paramlen = EXTRACT_LE_16BITS ( w + 9 * 2 ) ; param = buf + EXTRACT_LE_16BITS ( w + 10 * 2 ) ; datalen = EXTRACT_LE_16BITS ( w + 11 * 2 ) ; data = buf + EXTRACT_LE_16BITS ( w + 12 * 2 ) ; f1 = ""TotParamCnt=[d]<S2SV_blank>\\nTotDataCnt=[d]<S2SV_blank>\\nMaxParmCnt=[d]<S2SV_blank>\\nMaxDataCnt=[d]\\nMaxSCnt=[d]<S2SV_blank>\\nTransFlags=[w]<S2SV_blank>\\nRes1=[w]<S2SV_blank>\\nRes2=[w]<S2SV_blank>\\nRes3=[w]\\nParamCnt=[d]<S2SV_blank>\\nParamOff=[d]<S2SV_blank>\\nDataCnt=[d]<S2SV_blank>\\nDataOff=[d]<S2SV_blank>\\nSUCnt=[d]\\n"" ; f2 = ""|Name=[S]\\n"" ; f3 = ""|Param<S2SV_blank>"" ; f4 = ""|Data<S2SV_blank>"" ; } else { ND_TCHECK2 ( w [ 7 * 2 ] , 2 ) ; paramlen = EXTRACT_LE_16BITS ( w + 3 * 2 ) ; param = buf + EXTRACT_LE_16BITS ( w + 4 * 2 ) ; datalen = EXTRACT_LE_16BITS ( w + 6 * 2 ) ; data = buf + EXTRACT_LE_16BITS ( w + 7 * 2 ) ; f1 = ""TotParamCnt=[d]<S2SV_blank>\\nTotDataCnt=[d]<S2SV_blank>\\nRes1=[d]\\nParamCnt=[d]<S2SV_blank>\\nParamOff=[d]<S2SV_blank>\\nRes2=[d]<S2SV_blank>\\nDataCnt=[d]<S2SV_blank>\\nDataOff=[d]<S2SV_blank>\\nRes3=[d]\\nLsetup=[d]\\n"" ; f2 = ""|Unknown<S2SV_blank>"" ; f3 = ""|Param<S2SV_blank>"" ; f4 = ""|Data<S2SV_blank>"" ; } smb_fdata ( ndo , words + 1 , f1 , min ( words + 1 + 2 * words [ 0 ] , maxbuf ) , unicodestr ) ; ND_TCHECK2 ( * data1 , 2 ) ; bcc = EXTRACT_LE_16BITS ( data1 ) ; ND_PRINT ( ( ndo , ""smb_bcc=%u\\n"" , bcc ) ) ; if ( bcc > 0 ) { smb_fdata ( ndo , data1 + 2 , f2 , maxbuf - ( paramlen + datalen ) , unicodestr ) ; <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , ""\\\\MAILSLOT\\\\BROWSE"" ) == 0 ) { <S2SV_EndBug> print_browse ( ndo , param , paramlen , data , datalen ) ; return ; } <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , ""\\\\PIPE\\\\LANMAN"" ) == 0 ) { <S2SV_EndBug> print_ipc ( ndo , param , paramlen , data , datalen ) ; return ; } <S2SV_StartBug> if ( paramlen ) <S2SV_EndBug> smb_fdata ( ndo , param , f3 , min ( param + paramlen , maxbuf ) , unicodestr ) ; if ( datalen ) smb_fdata ( ndo , data , f4 , min ( data + datalen , maxbuf ) , unicodestr ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> unicodestr ) ; # define MAILSLOT_BROWSE_STR ""\\\\MAILSLOT\\\\BROWSE"" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( MAILSLOT_BROWSE_STR ) + 1 ) ; <S2SV_ModStart> 2 ) , MAILSLOT_BROWSE_STR <S2SV_ModEnd> ) == 0 <S2SV_ModStart> return ; } # undef MAILSLOT_BROWSE_STR # define PIPE_LANMAN_STR ""\\\\PIPE\\\\LANMAN"" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( PIPE_LANMAN_STR ) + 1 ) ; <S2SV_ModStart> 2 ) , PIPE_LANMAN_STR <S2SV_ModEnd> ) == 0 <S2SV_ModStart> return ; } # undef PIPE_LANMAN_STR
",the-tcpdump-group@tcpdump/96480ab95308cd9234b4f09b175ebf60e17792c6,CVE-2018-16451,https://github.com/the-tcpdump-group/tcpdump/commit/96480ab95308cd9234b4f09b175ebf60e17792c6,2019-10-03T16:15Z,"<S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , ""\\\\MAILSLOT\\\\BROWSE"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , ""\\\\PIPE\\\\LANMAN"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( paramlen ) <S2SV_EndBug>"
6920,CWE-400,"void handle_ld_nf ( u32 insn , struct pt_regs * regs ) { int rd = ( ( insn >> 25 ) & 0x1f ) ; int from_kernel = ( regs -> tstate & TSTATE_PRIV ) != 0 ; unsigned long * reg ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; reg = fetch_reg_addr ( rd , regs ) ; if ( from_kernel || rd < 16 ) { reg [ 0 ] = 0 ; if ( ( insn & 0x780000 ) == 0x180000 ) reg [ 1 ] = 0 ; } else if ( test_thread_flag ( TIF_32BIT ) ) { put_user ( 0 , ( int __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( ( int __user * ) reg ) + 1 ) ; } else { put_user ( 0 , ( unsigned long __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( unsigned long __user * ) reg + 1 ) ; } advance ( regs ) ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug>"
2303,CWE-399,"int dev_forward_skb ( struct net_device * dev , struct sk_buff * skb ) { skb_orphan ( skb ) ; <S2SV_StartBug> if ( ! ( dev -> flags & IFF_UP ) ) <S2SV_EndBug> return NET_RX_DROP ; <S2SV_StartBug> if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) <S2SV_EndBug> <S2SV_StartBug> return NET_RX_DROP ; <S2SV_EndBug> skb_set_dev ( skb , dev ) ; skb -> tstamp . tv64 = 0 ; skb -> pkt_type = PACKET_HOST ; skb -> protocol = eth_type_trans ( skb , dev ) ; return netif_rx ( skb ) ; }
","<S2SV_ModStart> & IFF_UP ) || <S2SV_ModEnd> ( skb -> <S2SV_ModStart> hard_header_len ) ) ) { kfree_skb ( skb ) ; <S2SV_ModStart> return NET_RX_DROP ; }
",torvalds@linux/6ec82562ffc6f297d0de36d65776cff8e5704867,CVE-2013-2017,https://github.com/torvalds/linux/commit/6ec82562ffc6f297d0de36d65776cff8e5704867,2013-05-03T11:57Z,<S2SV_StartBug> if ( ! ( dev -> flags & IFF_UP ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) <S2SV_EndBug> <S2SV_StartBug> return NET_RX_DROP ; <S2SV_EndBug>
7368,CWE-352,"char * Util_monitId ( char * idfile ) { <S2SV_StartBug> FILE * file = NULL ; <S2SV_EndBug> ASSERT ( idfile ) ; if ( ! File_exist ( idfile ) ) { <S2SV_StartBug> md5_context_t ctx ; <S2SV_EndBug> char buf [ STRLEN ] ; MD_T digest ; file = fopen ( idfile , ""w"" ) ; if ( ! file ) { LogError ( ""Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } <S2SV_StartBug> snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ; <S2SV_EndBug> md5_init ( & ctx ) ; md5_append ( & ctx , ( const md5_byte_t * ) buf , STRLEN - 1 ) ; md5_finish ( & ctx , ( md5_byte_t * ) digest ) ; Util_digest2Bytes ( ( unsigned char * ) digest , 16 , Run . id ) ; <S2SV_StartBug> fprintf ( file , ""%s"" , Run . id ) ; <S2SV_EndBug> LogInfo ( ""<S2SV_blank>New<S2SV_blank>Monit<S2SV_blank>id:<S2SV_blank>%s\\n<S2SV_blank>Stored<S2SV_blank>in<S2SV_blank>\'%s\'\\n"" , Run . id , idfile ) ; } else { if ( ! File_isFile ( idfile ) ) { LogError ( ""idfile<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file\\n"" , idfile ) ; return NULL ; } if ( ( file = fopen ( idfile , ""r"" ) ) == ( FILE * ) NULL ) { LogError ( ""Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } if ( fscanf ( file , ""%64s"" , Run . id ) != 1 ) { LogError ( ""Error<S2SV_blank>reading<S2SV_blank>id<S2SV_blank>from<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , idfile ) ; if ( fclose ( file ) ) LogError ( ""Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } } if ( fclose ( file ) ) LogError ( ""Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return Run . id ; }
","<S2SV_ModStart> idfile ) { ASSERT ( idfile ) ; <S2SV_ModStart> file = NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { <S2SV_ModEnd> file = fopen <S2SV_ModStart> NULL ; } <S2SV_ModEnd> fprintf ( file <S2SV_ModStart> , ""%s"" , Util_getToken ( Run . id ) <S2SV_ModEnd> ) ; LogInfo
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,"<S2SV_StartBug> FILE * file = NULL ; <S2SV_EndBug> <S2SV_StartBug> md5_context_t ctx ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( file , ""%s"" , Run . id ) ; <S2SV_EndBug>"
1829,CWE-119,"<S2SV_StartBug> void vp9_rc_init_minq_luts ( ) { <S2SV_EndBug> int i ; for ( i = 0 ; i < QINDEX_RANGE ; i ++ ) { const double maxq = vp9_convert_qindex_to_q ( i ) ; kf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.000001 , - 0.0004 , 0.15 ) ; kf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.000002 , - 0.0012 , 0.50 ) ; gf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.32 ) ; gf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.50 ) ; afq_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.33 ) ; afq_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.55 ) ; inter_minq [ i ] = get_minq_index ( maxq , 0.00000271 , - 0.00113 , 0.75 ) ; } }
","<S2SV_ModStart> void vp9_rc_init_minq_luts ( void ) { init_minq_luts ( kf_low_motion_minq_8 , kf_high_motion_minq_8 , arfgf_low_motion_minq_8 , arfgf_high_motion_minq_8 , inter_minq_8 , rtc_minq_8 , VPX_BITS_8 ) ; # if CONFIG_VP9_HIGHBITDEPTH init_minq_luts ( kf_low_motion_minq_10 , kf_high_motion_minq_10 , arfgf_low_motion_minq_10 , arfgf_high_motion_minq_10 , inter_minq_10 , rtc_minq_10 , VPX_BITS_10 ) ; init_minq_luts ( kf_low_motion_minq_12 , kf_high_motion_minq_12 , arfgf_low_motion_minq_12 , arfgf_high_motion_minq_12 , inter_minq_12 , rtc_minq_12 , VPX_BITS_12 ) ; # endif <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> void vp9_rc_init_minq_luts ( ) { <S2SV_EndBug>
4142,CWE-119,"bool initiate_stratum ( struct pool * pool ) { char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; bool ret = false , recvd = false ; json_error_t err ; int n2size ; if ( ! setup_stratum_curl ( pool ) ) goto out ; resend : if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , true ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = json_array_string ( json_array_get ( res_val , 0 ) , 1 ) ; if ( ! sessionid ) { applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } mutex_lock ( & pool -> pool_lock ) ; pool -> sessionid = sessionid ; free ( pool -> nonce1 ) ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; pool -> n2size = n2size ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( val ) json_decref ( val ) ; if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && pool -> sessionid ) { mutex_lock ( & pool -> pool_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiate<S2SV_blank>stratum<S2SV_blank>failed"" ) ; if ( pool -> sock != INVSOCK ) { shutdown ( pool -> sock , SHUT_RDWR ) ; pool -> sock = INVSOCK ; } } return ret ; }
","<S2SV_ModStart> ; if ( n2size < 1 ) <S2SV_ModEnd> { applog (
",luke-jr@bfgminer/ff7f30129f15f7a2213f8ced0cd65c9a331493d9,CVE-2014-4502,https://github.com/luke-jr/bfgminer/commit/ff7f30129f15f7a2213f8ced0cd65c9a331493d9,2014-07-23T14:55Z,<S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug>
995,CWE-284,"static ssize_t out_write ( struct audio_stream_out * stream , const void * buffer , size_t bytes ) { struct a2dp_stream_out * out = ( struct a2dp_stream_out * ) stream ; int sent ; DEBUG ( ""write<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>(fd<S2SV_blank>%d)"" , bytes , out -> common . audio_fd ) ; pthread_mutex_lock ( & out -> common . lock ) ; if ( out -> common . state == AUDIO_A2DP_STATE_SUSPENDED ) { DEBUG ( ""stream<S2SV_blank>suspended"" ) ; pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } if ( ( out -> common . state == AUDIO_A2DP_STATE_STOPPED ) || ( out -> common . state == AUDIO_A2DP_STATE_STANDBY ) ) { if ( start_audio_datapath ( & out -> common ) < 0 ) { int us_delay = calc_audiotime ( out -> common . cfg , bytes ) ; DEBUG ( ""emulate<S2SV_blank>a2dp<S2SV_blank>write<S2SV_blank>delay<S2SV_blank>(%d<S2SV_blank>us)"" , us_delay ) ; <S2SV_StartBug> usleep ( us_delay ) ; <S2SV_EndBug> pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } } else if ( out -> common . state != AUDIO_A2DP_STATE_STARTED ) { ERROR ( ""stream<S2SV_blank>not<S2SV_blank>in<S2SV_blank>stopped<S2SV_blank>or<S2SV_blank>standby"" ) ; pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } pthread_mutex_unlock ( & out -> common . lock ) ; sent = skt_write ( out -> common . audio_fd , buffer , bytes ) ; if ( sent == - 1 ) { skt_disconnect ( out -> common . audio_fd ) ; out -> common . audio_fd = AUDIO_SKT_DISCONNECTED ; if ( out -> common . state != AUDIO_A2DP_STATE_SUSPENDED ) out -> common . state = AUDIO_A2DP_STATE_STOPPED ; else ERROR ( ""write<S2SV_blank>failed<S2SV_blank>:<S2SV_blank>stream<S2SV_blank>suspended,<S2SV_blank>avoid<S2SV_blank>resetting<S2SV_blank>state"" ) ; } else { const size_t frames = bytes / audio_stream_out_frame_size ( stream ) ; out -> frames_rendered += frames ; out -> frames_presented += frames ; } DEBUG ( ""wrote<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>%zu<S2SV_blank>bytes"" , sent , bytes ) ; return sent ; }
","<S2SV_ModStart> us_delay ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( us_delay )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,<S2SV_StartBug> usleep ( us_delay ) ; <S2SV_EndBug>
3711,CWE-119,"void show_object_with_name ( FILE * out , struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * component ) <S2SV_EndBug> { char * name = path_name ( path , component ) ; char * p ; fprintf ( out , ""%s<S2SV_blank>"" , oid_to_hex ( & obj -> oid ) ) ; for ( p = name ; * p && * p != '\\n' ; p ++ ) fputc ( * p , out ) ; fputc ( '\\n' , out ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name ) { const <S2SV_ModEnd> char * p <S2SV_ModStart> out ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2315,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z,"<S2SV_StartBug> struct strbuf * path , const char * component ) <S2SV_EndBug> <S2SV_StartBug> free ( name ) ; <S2SV_EndBug>"
2389,CWE-476,"static bool handle_client_startup ( PgSocket * client , PktHdr * pkt ) { const char * passwd ; const uint8_t * key ; bool ok ; SBuf * sbuf = & client -> sbuf ; if ( incomplete_pkt ( pkt ) ) { disconnect_client ( client , true , ""client<S2SV_blank>sent<S2SV_blank>partial<S2SV_blank>pkt<S2SV_blank>in<S2SV_blank>startup<S2SV_blank>phase"" ) ; return false ; } if ( client -> wait_for_welcome ) { if ( finish_client_login ( client ) ) { sbuf_prepare_skip ( sbuf , pkt -> len ) ; return true ; } else return false ; } switch ( pkt -> type ) { case PKT_SSLREQ : slog_noise ( client , ""C:<S2SV_blank>req<S2SV_blank>SSL"" ) ; slog_noise ( client , ""P:<S2SV_blank>nak"" ) ; if ( ! sbuf_answer ( & client -> sbuf , ""N"" , 1 ) ) { disconnect_client ( client , false , ""failed<S2SV_blank>to<S2SV_blank>nak<S2SV_blank>SSL"" ) ; return false ; } break ; case PKT_STARTUP_V2 : disconnect_client ( client , true , ""Old<S2SV_blank>V2<S2SV_blank>protocol<S2SV_blank>not<S2SV_blank>supported"" ) ; return false ; case PKT_STARTUP : if ( client -> pool ) { disconnect_client ( client , true , ""client<S2SV_blank>re-sent<S2SV_blank>startup<S2SV_blank>pkt"" ) ; return false ; } if ( ! decide_startup_pool ( client , pkt ) ) return false ; if ( client -> pool -> db -> admin ) { if ( ! admin_pre_login ( client ) ) return false ; } if ( cf_auth_type <= AUTH_TRUST || client -> own_user ) { if ( ! finish_client_login ( client ) ) return false ; } else { if ( ! send_client_authreq ( client ) ) { disconnect_client ( client , false , ""failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>auth<S2SV_blank>req"" ) ; return false ; } } break ; case 'p' : <S2SV_StartBug> if ( cf_auth_type <= AUTH_TRUST ) { <S2SV_EndBug> disconnect_client ( client , true , ""unrequested<S2SV_blank>passwd<S2SV_blank>pkt"" ) ; return false ; } ok = mbuf_get_string ( & pkt -> data , & passwd ) ; if ( ok && check_client_passwd ( client , passwd ) ) { if ( ! finish_client_login ( client ) ) return false ; } else { disconnect_client ( client , true , ""Auth<S2SV_blank>failed"" ) ; return false ; } break ; case PKT_CANCEL : if ( mbuf_avail_for_read ( & pkt -> data ) == BACKENDKEY_LEN && mbuf_get_bytes ( & pkt -> data , BACKENDKEY_LEN , & key ) ) { memcpy ( client -> cancel_key , key , BACKENDKEY_LEN ) ; accept_cancel_request ( client ) ; } else disconnect_client ( client , false , ""bad<S2SV_blank>cancel<S2SV_blank>request"" ) ; return false ; default : disconnect_client ( client , false , ""bad<S2SV_blank>packet"" ) ; return false ; } sbuf_prepare_skip ( sbuf , pkt -> len ) ; client -> request_time = get_cached_time ( ) ; return true ; }
","<S2SV_ModStart> : if ( ! client -> auth_user ) { disconnect_client ( client , true , ""client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet"" ) ; return false ; } if (
",pgbouncer@pgbouncer/74d6e5f7de5ec736f71204b7b422af7380c19ac5,CVE-2015-4054,https://github.com/pgbouncer/pgbouncer/commit/74d6e5f7de5ec736f71204b7b422af7380c19ac5,2017-05-23T04:29Z,<S2SV_StartBug> if ( cf_auth_type <= AUTH_TRUST ) { <S2SV_EndBug>
6376,CWE-401,"static int nfp_flower_spawn_phy_reprs ( struct nfp_app * app , struct nfp_flower_priv * priv ) { struct nfp_eth_table * eth_tbl = app -> pf -> eth_tbl ; atomic_t * replies = & priv -> reify_replies ; struct nfp_flower_repr_priv * repr_priv ; struct nfp_repr * nfp_repr ; struct sk_buff * ctrl_skb ; struct nfp_reprs * reprs ; int err , reify_cnt ; unsigned int i ; ctrl_skb = nfp_flower_cmsg_mac_repr_start ( app , eth_tbl -> count ) ; if ( ! ctrl_skb ) return - ENOMEM ; reprs = nfp_reprs_alloc ( eth_tbl -> max_index + 1 ) ; if ( ! reprs ) { err = - ENOMEM ; goto err_free_ctrl_skb ; } for ( i = 0 ; i < eth_tbl -> count ; i ++ ) { unsigned int phys_port = eth_tbl -> ports [ i ] . index ; struct net_device * repr ; struct nfp_port * port ; u32 cmsg_port_id ; repr = nfp_repr_alloc ( app ) ; if ( ! repr ) { err = - ENOMEM ; goto err_reprs_clean ; } repr_priv = kzalloc ( sizeof ( * repr_priv ) , GFP_KERNEL ) ; if ( ! repr_priv ) { err = - ENOMEM ; <S2SV_StartBug> goto err_reprs_clean ; <S2SV_EndBug> } nfp_repr = netdev_priv ( repr ) ; nfp_repr -> app_priv = repr_priv ; repr_priv -> nfp_repr = nfp_repr ; port = nfp_port_alloc ( app , NFP_PORT_PHYS_PORT , repr ) ; if ( IS_ERR ( port ) ) { err = PTR_ERR ( port ) ; <S2SV_StartBug> nfp_repr_free ( repr ) ; <S2SV_EndBug> goto err_reprs_clean ; } err = nfp_port_init_phy_port ( app -> pf , app , port , i ) ; <S2SV_StartBug> if ( err ) { <S2SV_EndBug> nfp_port_free ( port ) ; nfp_repr_free ( repr ) ; goto err_reprs_clean ; } SET_NETDEV_DEV ( repr , & priv -> nn -> pdev -> dev ) ; nfp_net_get_mac_addr ( app -> pf , repr , port ) ; cmsg_port_id = nfp_flower_cmsg_phys_port ( phys_port ) ; err = nfp_repr_init ( app , repr , cmsg_port_id , port , priv -> nn -> dp . netdev ) ; if ( err ) { <S2SV_StartBug> nfp_port_free ( port ) ; <S2SV_EndBug> nfp_repr_free ( repr ) ; goto err_reprs_clean ; } nfp_flower_cmsg_mac_repr_add ( ctrl_skb , i , eth_tbl -> ports [ i ] . nbi , eth_tbl -> ports [ i ] . base , phys_port ) ; RCU_INIT_POINTER ( reprs -> reprs [ phys_port ] , repr ) ; nfp_info ( app -> cpp , ""Phys<S2SV_blank>Port<S2SV_blank>%d<S2SV_blank>Representor(%s)<S2SV_blank>created\\n"" , phys_port , repr -> name ) ; } nfp_app_reprs_set ( app , NFP_REPR_TYPE_PHYS_PORT , reprs ) ; atomic_set ( replies , 0 ) ; reify_cnt = nfp_flower_reprs_reify ( app , NFP_REPR_TYPE_PHYS_PORT , true ) ; if ( reify_cnt < 0 ) { err = reify_cnt ; nfp_warn ( app -> cpp , ""Failed<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>firmware<S2SV_blank>about<S2SV_blank>repr<S2SV_blank>creation\\n"" ) ; goto err_reprs_remove ; } err = nfp_flower_wait_repr_reify ( app , replies , reify_cnt ) ; if ( err ) goto err_reprs_remove ; nfp_ctrl_tx ( app -> ctrl , ctrl_skb ) ; return 0 ; err_reprs_remove : reprs = nfp_app_reprs_set ( app , NFP_REPR_TYPE_PHYS_PORT , NULL ) ; err_reprs_clean : nfp_reprs_clean_and_free ( app , reprs ) ; err_free_ctrl_skb : kfree_skb ( ctrl_skb ) ; return err ; }
","<S2SV_ModStart> - ENOMEM ; nfp_repr_free ( repr ) ; <S2SV_ModStart> port ) ; kfree ( repr_priv ) ; <S2SV_ModStart> err ) { kfree ( repr_priv ) ; <S2SV_ModStart> err ) { kfree ( repr_priv ) ;
",torvalds@linux/8572cea1461a006bce1d06c0c4b0575869125fa4,CVE-2019-19080,https://github.com/torvalds/linux/commit/8572cea1461a006bce1d06c0c4b0575869125fa4,2019-11-18T06:15Z,<S2SV_StartBug> goto err_reprs_clean ; <S2SV_EndBug> <S2SV_StartBug> nfp_repr_free ( repr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> <S2SV_StartBug> nfp_port_free ( port ) ; <S2SV_EndBug>
17,CWE-400,"int regexec ( Reprog * prog , const char * sp , Resub * sub , int eflags ) { Resub scratch ; int i ; if ( ! sub ) sub = & scratch ; sub -> nsub = prog -> nsub ; for ( i = 0 ; i < MAXSUB ; ++ i ) sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; <S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> }
","<S2SV_ModStart> NULL ; return <S2SV_ModEnd> match ( prog <S2SV_ModStart> eflags , sub , 0
",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z,"<S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug>"
3267,CWE-19,"static void ext2_put_super ( struct super_block * sb ) { int db_count ; int i ; struct ext2_sb_info * sbi = EXT2_SB ( sb ) ; dquot_disable ( sb , - 1 , DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED ) ; <S2SV_StartBug> ext2_xattr_put_super ( sb ) ; <S2SV_EndBug> if ( ! ( sb -> s_flags & MS_RDONLY ) ) { struct ext2_super_block * es = sbi -> s_es ; spin_lock ( & sbi -> s_lock ) ; es -> s_state = cpu_to_le16 ( sbi -> s_mount_state ) ; spin_unlock ( & sbi -> s_lock ) ; ext2_sync_super ( sb , es , 1 ) ; } db_count = sbi -> s_gdb_count ; for ( i = 0 ; i < db_count ; i ++ ) if ( sbi -> s_group_desc [ i ] ) brelse ( sbi -> s_group_desc [ i ] ) ; kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; brelse ( sbi -> s_sbh ) ; sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; }
","<S2SV_ModStart> DQUOT_LIMITS_ENABLED ) ; if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> if ( !
",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z,<S2SV_StartBug> ext2_xattr_put_super ( sb ) ; <S2SV_EndBug>
185,CWE-20,"static int lmp_print_data_link_subobjs ( netdissect_options * ndo , const u_char * obj_tptr , int total_subobj_len , int offset ) { int hexdump = FALSE ; int subobj_type , subobj_len ; union { float f ; uint32_t i ; } bw ; while ( total_subobj_len > 0 && hexdump == FALSE ) { <S2SV_StartBug> subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; <S2SV_EndBug> subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Subobject,<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Length:<S2SV_blank>%u"" , tok2str ( lmp_data_link_subobj , ""Unknown"" , subobj_type ) , subobj_type , subobj_len ) ) ; if ( subobj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; break ; } if ( ( subobj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; break ; } if ( total_subobj_len < subobj_len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>object)"" ) ) ; break ; } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> tok2str ( gmpls_switch_cap_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) , <S2SV_StartBug> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( gmpls_encoding_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Min<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Max<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , <S2SV_EndBug> EXTRACT_32BITS ( obj_tptr + offset + 4 ) ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; offset += subobj_len ; } return ( hexdump ) ; trunc : return - 1 ; }
","<S2SV_ModStart> FALSE ) { ND_TCHECK_16BITS ( obj_tptr + offset ) ; <S2SV_ModStart> case INT_SWITCHING_TYPE_SUBOBJ : ND_TCHECK_8BITS ( obj_tptr + offset + 2 ) ; <S2SV_ModStart> 2 ) ) ) ; ND_TCHECK_8BITS ( obj_tptr + offset + 3 <S2SV_ModStart> ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_ModStart> case WAVELENGTH_SUBOBJ : ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ;
",the-tcpdump-group@tcpdump/0b661e0aa61850234b64394585cf577aac570bf4,CVE-2019-15166,https://github.com/the-tcpdump-group/tcpdump/commit/0b661e0aa61850234b64394585cf577aac570bf4,2019-10-03T17:15Z,"<S2SV_StartBug> subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> <S2SV_StartBug> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , <S2SV_EndBug>"
3599,CWE-264,"int cap_bprm_set_creds ( struct linux_binprm * bprm ) { const struct cred * old = current_cred ( ) ; struct cred * new = bprm -> cred ; bool effective , has_cap = false ; int ret ; effective = false ; ret = get_file_caps ( bprm , & effective , & has_cap ) ; if ( ret < 0 ) return ret ; if ( ! issecure ( SECURE_NOROOT ) ) { if ( has_cap && new -> uid != 0 && new -> euid == 0 ) { warn_setuid_and_fcaps_mixed ( bprm -> filename ) ; goto skip ; } if ( new -> euid == 0 || new -> uid == 0 ) { new -> cap_permitted = cap_combine ( old -> cap_bset , old -> cap_inheritable ) ; } if ( new -> euid == 0 ) effective = true ; } skip : <S2SV_StartBug> if ( ( new -> euid != old -> uid || <S2SV_EndBug> new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) { if ( ! capable ( CAP_SETUID ) ) { new -> euid = new -> uid ; new -> egid = new -> gid ; } new -> cap_permitted = cap_intersect ( new -> cap_permitted , old -> cap_permitted ) ; } new -> suid = new -> fsuid = new -> euid ; new -> sgid = new -> fsgid = new -> egid ; if ( effective ) new -> cap_effective = new -> cap_permitted ; else cap_clear ( new -> cap_effective ) ; bprm -> cap_effective = effective ; if ( ! cap_isclear ( new -> cap_effective ) ) { if ( ! cap_issubset ( CAP_FULL_SET , new -> cap_effective ) || new -> euid != 0 || new -> uid != 0 || issecure ( SECURE_NOROOT ) ) { ret = audit_log_bprm_fcaps ( bprm , new , old ) ; if ( ret < 0 ) return ret ; } } new -> securebits &= ~ issecure_mask ( SECURE_KEEP_CAPS ) ; return 0 ; }
","<S2SV_ModStart> : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if (
",torvalds@linux/d52fc5dde171f030170a6cb78034d166b13c9445,CVE-2012-2123,https://github.com/torvalds/linux/commit/d52fc5dde171f030170a6cb78034d166b13c9445,2012-05-17T11:00Z,<S2SV_StartBug> if ( ( new -> euid != old -> uid || <S2SV_EndBug>
2744,CWE-399,"static int unmap_ref_private ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * page , unsigned long address ) { struct hstate * h = hstate_vma ( vma ) ; struct vm_area_struct * iter_vma ; struct address_space * mapping ; struct prio_tree_iter iter ; pgoff_t pgoff ; address = address & huge_page_mask ( h ) ; pgoff = vma_hugecache_offset ( h , vma , address ) ; <S2SV_StartBug> mapping = ( struct address_space * ) page_private ( page ) ; <S2SV_EndBug> mutex_lock ( & mapping -> i_mmap_mutex ) ; vma_prio_tree_foreach ( iter_vma , & iter , & mapping -> i_mmap , pgoff , pgoff ) { if ( iter_vma == vma ) continue ; if ( ! is_vma_resv_set ( iter_vma , HPAGE_RESV_OWNER ) ) __unmap_hugepage_range ( iter_vma , address , address + huge_page_size ( h ) , page ) ; } mutex_unlock ( & mapping -> i_mmap_mutex ) ; return 1 ; }
","<S2SV_ModStart> ; mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> ; mutex_lock (
",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z,<S2SV_StartBug> mapping = ( struct address_space * ) page_private ( page ) ; <S2SV_EndBug>
2919,CWE-347,"err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return ""2"" ""exponentiation<S2SV_blank>failed;<S2SV_blank>too<S2SV_blank>many<S2SV_blank>octets"" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( ""verify_sh<S2SV_blank>decrypted<S2SV_blank>SIG1:"" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( ""pad_len<S2SV_blank>calculated:<S2SV_blank>%d<S2SV_blank>hash_len:<S2SV_blank>%d"" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return ""3"" ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } <S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } ( * psig ) = s + <S2SV_ModEnd> padlen + 3 <S2SV_ModStart> + 3 ; { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ; } <S2SV_ModEnd> return NULL ;
",xelerance@Openswan/9eaa6c2a823c1d2b58913506a15f9474bf857a3d,CVE-2018-15836,https://github.com/xelerance/Openswan/commit/9eaa6c2a823c1d2b58913506a15f9474bf857a3d,2018-09-26T21:29Z,<S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug>
741,CWE-119,"void set_cfg_option ( char * opt_string ) { char * sep , * sep2 , szSec [ 1024 ] , szKey [ 1024 ] , szVal [ 1024 ] ; sep = strchr ( opt_string , ':' ) ; if ( ! sep ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\n"" , opt_string ) ; return ; } { const size_t sepIdx = sep - opt_string ; <S2SV_StartBug> strncpy ( szSec , opt_string , sepIdx ) ; <S2SV_EndBug> szSec [ sepIdx ] = 0 ; } sep ++ ; sep2 = strchr ( sep , '=' ) ; if ( ! sep2 ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\n"" , opt_string ) ; return ; } { const size_t sepIdx = sep2 - sep ; <S2SV_StartBug> strncpy ( szKey , sep , sepIdx ) ; <S2SV_EndBug> szKey [ sepIdx ] = 0 ; <S2SV_StartBug> strcpy ( szVal , sep2 + 1 ) ; <S2SV_EndBug> } if ( ! stricmp ( szKey , ""*"" ) ) { if ( stricmp ( szVal , ""null"" ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:*=null\\n"" , opt_string ) ; return ; } gf_cfg_del_section ( cfg_file , szSec ) ; return ; } if ( ! stricmp ( szVal , ""null"" ) ) { szVal [ 0 ] = 0 ; } gf_cfg_set_key ( cfg_file , szSec , szKey , szVal [ 0 ] ? szVal : NULL ) ; }
","<S2SV_ModStart> - opt_string ; if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> - sep ; if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>key<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> = 0 ; if ( strlen ( <S2SV_ModEnd> sep2 + 1 <S2SV_ModStart> + 1 ) >= sizeof ( szVal ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 )
",gpac@gpac/35ab4475a7df9b2a4bcab235e379c0c3ec543658,CVE-2018-20762,https://github.com/gpac/gpac/commit/35ab4475a7df9b2a4bcab235e379c0c3ec543658,2019-02-06T23:29Z,"<S2SV_StartBug> strncpy ( szSec , opt_string , sepIdx ) ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( szKey , sep , sepIdx ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( szVal , sep2 + 1 ) ; <S2SV_EndBug>"
4651,CWE-190,"<S2SV_StartBug> static mongo_message * mongo_message_create ( int len , int id , int responseTo , int op ) { <S2SV_EndBug> mongo_message * mm = ( mongo_message * ) bson_malloc ( len ) ; if ( ! id ) id = rand ( ) ; <S2SV_StartBug> mm -> head . len = len ; <S2SV_EndBug> mm -> head . id = id ; mm -> head . responseTo = responseTo ; mm -> head . op = op ; return mm ; }
","<S2SV_ModStart> * mongo_message_create ( size_t <S2SV_ModEnd> len , int <S2SV_ModStart> . len = ( int )
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,"<S2SV_StartBug> static mongo_message * mongo_message_create ( int len , int id , int responseTo , int op ) { <S2SV_EndBug> <S2SV_StartBug> mm -> head . len = len ; <S2SV_EndBug>"
477,CWE-189,"static ssize_t _archive_write_data ( struct archive * _a , const void * buff , size_t s ) { struct archive_write * a = ( struct archive_write * ) _a ; <S2SV_StartBug> archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , <S2SV_EndBug> <S2SV_StartBug> ARCHIVE_STATE_DATA , ""archive_write_data"" ) ; <S2SV_EndBug> archive_clear_error ( & a -> archive ) ; return ( ( a -> format_write_data ) ( a , buff , s ) ) ; }
","<S2SV_ModStart> ) _a ; const size_t max_write = INT_MAX ; <S2SV_ModStart> , ""archive_write_data"" ) ; if ( s > max_write ) s = max_write
",libarchive@libarchive/22531545514043e04633e1c015c7540b9de9dbe4,CVE-2013-0211,https://github.com/libarchive/libarchive/commit/22531545514043e04633e1c015c7540b9de9dbe4,2013-09-30T22:55Z,"<S2SV_StartBug> archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , <S2SV_EndBug> <S2SV_StartBug> ARCHIVE_STATE_DATA , ""archive_write_data"" ) ; <S2SV_EndBug>"
705,CWE-476,"static int dnxhd_find_frame_end ( DNXHDParserContext * dctx , const uint8_t * buf , int buf_size ) { ParseContext * pc = & dctx -> pc ; uint64_t state = pc -> state64 ; int pic_found = pc -> frame_start_found ; int i = 0 ; int interlaced = dctx -> interlaced ; int cur_field = dctx -> cur_field ; if ( ! pic_found ) { for ( i = 0 ; i < buf_size ; i ++ ) { state = ( state << 8 ) | buf [ i ] ; if ( ff_dnxhd_check_header_prefix ( state & 0xffffffffff00LL ) != 0 ) { i ++ ; pic_found = 1 ; interlaced = ( state & 2 ) >> 1 ; cur_field = state & 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; break ; } } } if ( pic_found && ! dctx -> remaining ) { if ( ! buf_size ) return 0 ; for ( ; i < buf_size ; i ++ ) { dctx -> cur_byte ++ ; state = ( state << 8 ) | buf [ i ] ; if ( dctx -> cur_byte == 24 ) { dctx -> h = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 26 ) { dctx -> w = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 42 ) { int cid = ( state >> 32 ) & 0xFFFFFFFF ; <S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> continue ; <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> } if ( buf_size - i >= dctx -> remaining && ( ! dctx -> interlaced || dctx -> cur_field ) ) { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> interlaced = interlaced ; dctx -> cur_field = 0 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } else { dctx -> remaining -= buf_size ; } } } } else if ( pic_found ) { if ( dctx -> remaining > buf_size ) { dctx -> remaining -= buf_size ; } else { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> interlaced = interlaced ; dctx -> cur_field = 0 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } } pc -> frame_start_found = pic_found ; pc -> state64 = state ; dctx -> interlaced = interlaced ; dctx -> cur_field = cur_field ; return END_NOT_FOUND ; }
","<S2SV_ModStart> & 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> remaining = dnxhd_get_hr_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size
",FFmpeg@FFmpeg/31c1c0b46a7021802c3d1d18039fca30dba5a14e,CVE-2017-9608,https://github.com/FFmpeg/FFmpeg/commit/31c1c0b46a7021802c3d1d18039fca30dba5a14e,2017-12-27T19:29Z,"<S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug>"
6423,CWE-120,"void M_LoadDefaults ( void ) { int i ; int len ; FILE * f ; char def [ 80 ] ; char strparm [ 100 ] ; char * newstring ; int parm ; boolean isstring ; numdefaults = sizeof ( defaults ) / sizeof ( defaults [ 0 ] ) ; for ( i = 0 ; i < numdefaults ; i ++ ) * defaults [ i ] . location = defaults [ i ] . defaultvalue ; i = M_CheckParm ( ""-config"" ) ; if ( i && i < myargc - 1 ) { defaultfile = myargv [ i + 1 ] ; printf ( ""\tdefault<S2SV_blank>file:<S2SV_blank>%s\\n"" , defaultfile ) ; } else defaultfile = basedefault ; f = fopen ( defaultfile , ""r"" ) ; if ( f ) { while ( ! feof ( f ) ) { isstring = false ; <S2SV_StartBug> if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\n]\\n"" , def , strparm ) == 2 ) <S2SV_EndBug> { if ( strparm [ 0 ] == \'""\' ) { isstring = true ; len = strlen ( strparm ) ; newstring = ( char * ) malloc ( len ) ; strparm [ len - 1 ] = 0 ; strcpy ( newstring , strparm + 1 ) ; } else if ( strparm [ 0 ] == '0' && strparm [ 1 ] == 'x' ) sscanf ( strparm + 2 , ""%x"" , & parm ) ; else sscanf ( strparm , ""%i"" , & parm ) ; for ( i = 0 ; i < numdefaults ; i ++ ) if ( ! strcmp ( def , defaults [ i ] . name ) ) { if ( ! isstring ) * defaults [ i ] . location = parm ; else * defaults [ i ] . location = ( int ) newstring ; break ; } } } fclose ( f ) ; } for ( i = 0 ; i < numdefaults ; i ++ ) { if ( defaults [ i ] . scantranslate ) { parm = * defaults [ i ] . location ; defaults [ i ] . untranslated = parm ; * defaults [ i ] . location = scantokey [ parm ] ; } } }
","<S2SV_ModStart> ( f , ""%79s<S2SV_blank>%99[^\\n]\\n"" <S2SV_ModEnd> , def ,
",AXDOOMER@doom-vanille/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec,CVE-2020-15007,https://github.com/AXDOOMER/doom-vanille/commit/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec,2020-06-24T11:15Z,"<S2SV_StartBug> if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\n]\\n"" , def , strparm ) == 2 ) <S2SV_EndBug>"
1367,CWE-119,"static void copy_and_extend_plane ( unsigned char * s , int sp , unsigned char * d , int dp , int h , int w , int et , int el , int eb , int er ) { int i ; unsigned char * src_ptr1 , * src_ptr2 ; unsigned char * dest_ptr1 , * dest_ptr2 ; int linesize ; src_ptr1 = s ; src_ptr2 = s + w - 1 ; dest_ptr1 = d - el ; dest_ptr2 = d + w ; for ( i = 0 ; i < h ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , el ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , er ) ; src_ptr1 += sp ; src_ptr2 += sp ; dest_ptr1 += dp ; dest_ptr2 += dp ; } src_ptr1 = d - el ; src_ptr2 = d + dp * ( h - 1 ) - el ; dest_ptr1 = d + dp * ( - et ) - el ; dest_ptr2 = d + dp * ( h ) - el ; linesize = el + er + w ; for ( i = 0 ; i < et ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> dest_ptr1 += dp ; } for ( i = 0 ; i < eb ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug> dest_ptr2 += dp ; } }
","<S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( dest_ptr1 , <S2SV_ModStart> el ) ; memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; memset <S2SV_ModEnd> ( dest_ptr2 , <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr1 , <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr2 ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , el ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug>"
1387,CWE-119,"void vp8dx_bool_decoder_fill ( BOOL_DECODER * br ) { const unsigned char * bufptr = br -> user_buffer ; VP8_BD_VALUE value = br -> value ; int count = br -> count ; <S2SV_StartBug> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <S2SV_EndBug> size_t bytes_left = br -> user_buffer_end - bufptr ; size_t bits_left = bytes_left * CHAR_BIT ; int x = ( int ) ( shift + CHAR_BIT - bits_left ) ; int loop_end = 0 ; unsigned char decrypted [ sizeof ( VP8_BD_VALUE ) + 1 ] ; if ( br -> decrypt_cb ) { <S2SV_StartBug> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <S2SV_EndBug> br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ; bufptr = decrypted ; } if ( x >= 0 ) { count += VP8_LOTS_OF_BITS ; loop_end = x ; } if ( x < 0 || bits_left ) { while ( shift >= loop_end ) { count += CHAR_BIT ; value |= ( VP8_BD_VALUE ) * bufptr << shift ; ++ bufptr ; ++ br -> user_buffer ; shift -= CHAR_BIT ; } } br -> value = value ; br -> count = count ; }
","<S2SV_ModStart> = VP8_BD_VALUE_SIZE - CHAR_BIT <S2SV_ModEnd> - ( count <S2SV_ModStart> ( count + CHAR_BIT <S2SV_ModEnd> ) ; size_t <S2SV_ModStart> size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) <S2SV_ModEnd> ; br ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <S2SV_EndBug>
540,CWE-416,"static netdev_tx_t hns_nic_net_xmit ( struct sk_buff * skb , struct net_device * ndev ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; <S2SV_StartBug> int ret ; <S2SV_EndBug> assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ; <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> & tx_ring_data ( priv , skb -> queue_mapping ) ) ; <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug> netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; } return ( netdev_tx_t ) ret ; }
","<S2SV_ModStart> ndev ) ; <S2SV_ModEnd> assert ( skb <S2SV_ModStart> q_num ) ; return <S2SV_ModEnd> hns_nic_net_xmit_hw ( ndev <S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,CVE-2017-18218,https://github.com/torvalds/linux/commit/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,2018-03-05T20:29Z,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug>"
2790,CWE-000,"static void bgp_packet_mpattr_tea ( struct bgp * bgp , struct peer * peer , struct stream * s , struct attr * attr , uint8_t attrtype ) { unsigned int attrlenfield = 0 ; unsigned int attrhdrlen = 0 ; struct bgp_attr_encap_subtlv * subtlvs ; struct bgp_attr_encap_subtlv * st ; const char * attrname ; if ( ! attr || ( attrtype == BGP_ATTR_ENCAP && ( ! attr -> encap_tunneltype || attr -> encap_tunneltype == BGP_ENCAP_TYPE_MPLS ) ) ) return ; switch ( attrtype ) { case BGP_ATTR_ENCAP : attrname = ""Tunnel<S2SV_blank>Encap"" ; subtlvs = attr -> encap_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 2 + 2 ; attrhdrlen = 1 + 1 ; break ; <S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> case BGP_ATTR_VNC : attrname = ""VNC"" ; subtlvs = attr -> vnc_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 0 ; attrhdrlen = 2 + 2 ; break ; # endif default : assert ( 0 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { attrlenfield += ( attrhdrlen + st -> length ) ; } if ( attrlenfield > 0xffff ) { zlog_info ( ""%s<S2SV_blank>attribute<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(length=%d),<S2SV_blank>can\'t<S2SV_blank>send<S2SV_blank>it"" , attrname , attrlenfield ) ; return ; } if ( attrlenfield > 0xff ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , attrtype ) ; stream_putw ( s , attrlenfield & 0xffff ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , attrtype ) ; stream_putc ( s , attrlenfield & 0xff ) ; } if ( attrtype == BGP_ATTR_ENCAP ) { stream_putw ( s , attr -> encap_tunneltype ) ; stream_putw ( s , attrlenfield - 4 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { if ( attrtype == BGP_ATTR_ENCAP ) { stream_putc ( s , st -> type ) ; stream_putc ( s , st -> length ) ; # if ENABLE_BGP_VNC } else { stream_putw ( s , st -> type ) ; stream_putw ( s , st -> length ) ; # endif } stream_put ( s , st -> value , st -> length ) ; } }
","<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC :
",FRRouting@frr/943d595a018e69b550db08cccba1d0778a86705a,CVE-2019-5892,https://github.com/FRRouting/frr/commit/943d595a018e69b550db08cccba1d0778a86705a,2019-01-10T17:29Z,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug>
1562,CWE-119,"static void filter_selectively_vert ( uint8_t * s , int pitch , unsigned int mask_16x16 , unsigned int mask_8x8 , unsigned int mask_4x4 , unsigned int mask_4x4_int , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) { unsigned int mask ; for ( mask = mask_16x16 | mask_8x8 | mask_4x4 | mask_4x4_int ; mask ; mask >>= 1 ) { const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ; if ( mask & 1 ) { if ( mask_16x16 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ; <S2SV_EndBug> } else if ( mask_8x8 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> } else if ( mask_4x4 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> } } if ( mask_4x4_int & 1 ) vp9_lpf_vertical_4 ( s + 4 , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; s += 8 ; lfl += 1 ; mask_16x16 >>= 1 ; mask_8x8 >>= 1 ; mask_4x4 >>= 1 ; mask_4x4_int >>= 1 ; } }
","<S2SV_ModStart> 1 ) { vpx_lpf_vertical_16 <S2SV_ModEnd> ( s , <S2SV_ModStart> 1 ) { vpx_lpf_vertical_8 <S2SV_ModEnd> ( s , <S2SV_ModStart> 1 ) { vpx_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } if ( mask_4x4_int & 1 ) vpx_lpf_vertical_4 <S2SV_ModEnd> ( s +
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vp9_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug>"
7623,CWE-190,"jas_matrix_t * jas_seq2d_input ( FILE * in ) { jas_matrix_t * matrix ; <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; long x ; <S2SV_StartBug> int numrows ; <S2SV_EndBug> int numcols ; int xoff ; int yoff ; <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & xoff , & yoff ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & numcols , & numrows ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( ! ( matrix = jas_seq2d_create ( xoff , yoff , xoff + numcols , yoff + numrows ) ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( jas_matrix_numrows ( matrix ) != numrows || jas_matrix_numcols ( matrix ) != numcols ) { abort ( ) ; } for ( i = 0 ; i < jas_matrix_numrows ( matrix ) ; i ++ ) { for ( j = 0 ; j < jas_matrix_numcols ( matrix ) ; j ++ ) { if ( fscanf ( in , ""%ld"" , & x ) != 1 ) { jas_matrix_destroy ( matrix ) ; return 0 ; } jas_matrix_set ( matrix , i , j , JAS_CAST ( jas_seqent_t , x ) ) ; } } return matrix ; }
","<S2SV_ModStart> * matrix ; jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; long <S2SV_ModStart> long x ; jas_matind_t numrows ; jas_matind_t numcols ; jas_matind_t xoff ; jas_matind_t yoff ; long tmp_xoff ; long tmp_yoff ; long tmp_numrows ; long tmp_numcols <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( in , ""%ld<S2SV_blank>%ld"" , & tmp_xoff , & tmp_yoff <S2SV_ModEnd> ) != 2 <S2SV_ModStart> != 2 ) { return 0 ; } xoff = tmp_xoff ; yoff = tmp_yoff <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( in , ""%ld<S2SV_blank>%ld"" , & tmp_numcols , & tmp_numrows <S2SV_ModEnd> ) != 2 <S2SV_ModStart> != 2 ) { return 0 ; } numrows = tmp_numrows ; numcols = tmp_numcols <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ) { return 0 ; } <S2SV_ModEnd> if ( jas_matrix_numrows
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int numrows ; <S2SV_EndBug> <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & xoff , & yoff ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & numcols , & numrows ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>"
8353,CWE-362,"void cipso_v4_req_delattr ( struct request_sock * req ) { <S2SV_StartBug> struct ip_options * opt ; <S2SV_EndBug> struct inet_request_sock * req_inet ; req_inet = inet_rsk ( req ) ; opt = req_inet -> opt ; <S2SV_StartBug> if ( opt == NULL || opt -> cipso == 0 ) <S2SV_EndBug> return ; cipso_v4_delopt ( & req_inet -> opt ) ; }
","<S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> || opt -> opt .
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> struct ip_options * opt ; <S2SV_EndBug> <S2SV_StartBug> if ( opt == NULL || opt -> cipso == 0 ) <S2SV_EndBug>
8376,CWE-362,"<S2SV_StartBug> static struct ip_options * tcp_v4_save_options ( struct sock * sk , <S2SV_EndBug> struct sk_buff * skb ) { <S2SV_StartBug> struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> struct ip_options * dopt = NULL ; <S2SV_EndBug> if ( opt && opt -> optlen ) { <S2SV_StartBug> int opt_size = optlength ( opt ) ; <S2SV_EndBug> dopt = kmalloc ( opt_size , GFP_ATOMIC ) ; if ( dopt ) { <S2SV_StartBug> if ( ip_options_echo ( dopt , skb ) ) { <S2SV_EndBug> kfree ( dopt ) ; dopt = NULL ; } } } return dopt ; }
","<S2SV_ModStart> <S2SV_null> static struct ip_options_rcu <S2SV_ModEnd> * tcp_v4_save_options ( <S2SV_ModStart> skb ) { const <S2SV_ModStart> ) ; struct ip_options_rcu <S2SV_ModEnd> * dopt = <S2SV_ModStart> int opt_size = sizeof ( * dopt ) + opt -> optlen <S2SV_ModEnd> ; dopt = <S2SV_ModStart> ( ip_options_echo ( & dopt -> opt <S2SV_ModEnd> , skb )
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,"<S2SV_StartBug> static struct ip_options * tcp_v4_save_options ( struct sock * sk , <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> struct ip_options * dopt = NULL ; <S2SV_EndBug> <S2SV_StartBug> int opt_size = optlength ( opt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ip_options_echo ( dopt , skb ) ) { <S2SV_EndBug>"
60,CWE-59,"void vrrp_print_stats ( void ) { <S2SV_StartBug> FILE * file ; <S2SV_EndBug> <S2SV_StartBug> file = fopen ( stats_file , ""w"" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ; return ; } list l = vrrp_data -> vrrp ; element e ; vrrp_t * vrrp ; <S2SV_StartBug> for ( e = LIST_HEAD ( l ) ; e ; ELEMENT_NEXT ( e ) ) { <S2SV_EndBug> vrrp = ELEMENT_DATA ( e ) ; fprintf ( file , ""VRRP<S2SV_blank>Instance:<S2SV_blank>%s\\n"" , vrrp -> iname ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Advertisements:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> advert_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%d\\n"" , vrrp -> stats -> advert_sent ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Became<S2SV_blank>master:<S2SV_blank>%d\\n"" , vrrp -> stats -> become_master ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Released<S2SV_blank>master:<S2SV_blank>%d\\n"" , vrrp -> stats -> release_master ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Packet<S2SV_blank>Errors:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Length:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> packet_len_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TTL:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> ip_ttl_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> invalid_type_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Advertisement<S2SV_blank>Interval:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> advert_interval_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Address<S2SV_blank>List:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> addr_list_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Authentication<S2SV_blank>Errors:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%d\\n"" , vrrp -> stats -> invalid_authtype ) ; # ifdef _WITH_VRRP_AUTH_ fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Mismatch:<S2SV_blank>%d\\n"" , vrrp -> stats -> authtype_mismatch ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Failure:<S2SV_blank>%d\\n"" , vrrp -> stats -> auth_failure ) ; # endif fprintf ( file , ""<S2SV_blank><S2SV_blank>Priority<S2SV_blank>Zero:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> pri_zero_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> pri_zero_sent ) ; } fclose ( file ) ; }
","<S2SV_ModStart> FILE * file = fopen_safe <S2SV_ModEnd> ( stats_file , <S2SV_ModStart> , ""w"" ) <S2SV_ModEnd> ; element e <S2SV_ModStart> * vrrp ; if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ; return ; } LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) { <S2SV_ModEnd> fprintf ( file
",acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306,CVE-2018-19044,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,2018-11-08T20:29Z,"<S2SV_StartBug> FILE * file ; <S2SV_EndBug> <S2SV_StartBug> file = fopen ( stats_file , ""w"" ) ; <S2SV_EndBug> <S2SV_StartBug> for ( e = LIST_HEAD ( l ) ; e ; ELEMENT_NEXT ( e ) ) { <S2SV_EndBug>"
7175,CWE-552,"static ssize_t _epoll_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; epoll_t * file = _cast_epoll ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <S2SV_StartBug> if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }
","<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,"<S2SV_StartBug> if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug>"
4543,CWE-125,"int obj2ast_comprehension ( PyObject * obj , comprehension_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty target ; expr_ty iter ; asdl_seq * ifs ; int is_async ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_ifs ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_ifs ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; ifs = _Ta3_asdl_seq_new ( len , arena ) ; if ( ifs == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( ifs , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_is_async ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_int ( tmp , & is_async , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } * out = comprehension ( target , iter , ifs , is_async , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_iter , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_is_async , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } *
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( ifs , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug>"
5333,CWE-22,"char * compose_path ( ctrl_t * ctrl , char * path ) { struct stat st ; static char rpath [ PATH_MAX ] ; char * name , * ptr ; char dir [ PATH_MAX ] = { 0 } ; strlcpy ( dir , ctrl -> cwd , sizeof ( dir ) ) ; DBG ( ""Compose<S2SV_blank>path<S2SV_blank>from<S2SV_blank>cwd:<S2SV_blank>%s,<S2SV_blank>arg:<S2SV_blank>%s"" , ctrl -> cwd , path ? : """" ) ; if ( ! path || ! strlen ( path ) ) goto check ; if ( path ) { if ( path [ 0 ] != '/' ) { if ( dir [ strlen ( dir ) - 1 ] != '/' ) strlcat ( dir , ""/"" , sizeof ( dir ) ) ; } strlcat ( dir , path , sizeof ( dir ) ) ; } check : while ( ( ptr = strstr ( dir , ""//"" ) ) ) memmove ( ptr , & ptr [ 1 ] , strlen ( & ptr [ 1 ] ) + 1 ) ; if ( ! chrooted ) { size_t len = strlen ( home ) ; DBG ( ""Server<S2SV_blank>path<S2SV_blank>from<S2SV_blank>CWD:<S2SV_blank>%s"" , dir ) ; if ( len > 0 && home [ len - 1 ] == '/' ) len -- ; memmove ( dir + len , dir , strlen ( dir ) + 1 ) ; memcpy ( dir , home , len ) ; DBG ( ""Resulting<S2SV_blank>non-chroot<S2SV_blank>path:<S2SV_blank>%s"" , dir ) ; } if ( ! stat ( dir , & st ) && S_ISDIR ( st . st_mode ) ) { if ( ! realpath ( dir , rpath ) ) return NULL ; } else { name = basename ( path ) ; ptr = dirname ( dir ) ; memset ( rpath , 0 , sizeof ( rpath ) ) ; if ( ! realpath ( ptr , rpath ) ) { INFO ( ""Failed<S2SV_blank>realpath(%s):<S2SV_blank>%m"" , ptr ) ; return NULL ; } if ( rpath [ 1 ] != 0 ) strlcat ( rpath , ""/"" , sizeof ( rpath ) ) ; strlcat ( rpath , name , sizeof ( rpath ) ) ; } <S2SV_StartBug> if ( ! chrooted && strncmp ( dir , home , strlen ( home ) ) ) { <S2SV_EndBug> DBG ( ""Failed<S2SV_blank>non-chroot<S2SV_blank>dir:%s<S2SV_blank>vs<S2SV_blank>home:%s"" , dir , home ) ; return NULL ; } return rpath ; }
","<S2SV_ModStart> && strncmp ( rpath <S2SV_ModEnd> , home ,
",troglobit@uftpd/455b47d3756aed162d2d0ef7f40b549f3b5b30fe,CVE-2020-5221,https://github.com/troglobit/uftpd/commit/455b47d3756aed162d2d0ef7f40b549f3b5b30fe,2020-01-22T19:15Z,"<S2SV_StartBug> if ( ! chrooted && strncmp ( dir , home , strlen ( home ) ) ) { <S2SV_EndBug>"
3943,CWE-264,"static int raw_cmd_copyin ( int cmd , void __user * param , struct floppy_raw_cmd * * rcmd ) { struct floppy_raw_cmd * ptr ; int ret ; int i ; * rcmd = NULL ; loop : ptr = kmalloc ( sizeof ( struct floppy_raw_cmd ) , GFP_USER ) ; if ( ! ptr ) return - ENOMEM ; * rcmd = ptr ; ret = copy_from_user ( ptr , param , sizeof ( * ptr ) ) ; <S2SV_StartBug> if ( ret ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ptr -> next = NULL ; ptr -> buffer_length = 0 ; param += sizeof ( struct floppy_raw_cmd ) ; if ( ptr -> cmd_count > 33 ) return - EINVAL ; for ( i = 0 ; i < 16 ; i ++ ) ptr -> reply [ i ] = 0 ; ptr -> resultcode = 0 ; <S2SV_StartBug> ptr -> kernel_data = NULL ; <S2SV_EndBug> if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) { if ( ptr -> length <= 0 ) return - EINVAL ; ptr -> kernel_data = ( char * ) fd_dma_mem_alloc ( ptr -> length ) ; fallback_on_nodma_alloc ( & ptr -> kernel_data , ptr -> length ) ; if ( ! ptr -> kernel_data ) return - ENOMEM ; ptr -> buffer_length = ptr -> length ; } if ( ptr -> flags & FD_RAW_WRITE ) { ret = fd_copyin ( ptr -> data , ptr -> kernel_data , ptr -> length ) ; if ( ret ) return ret ; } if ( ptr -> flags & FD_RAW_MORE ) { rcmd = & ( ptr -> next ) ; ptr -> rate &= 0x43 ; goto loop ; } return 0 ; }
","<S2SV_ModStart> ) ) ; ptr -> next = NULL ; ptr -> buffer_length = 0 ; ptr -> kernel_data = NULL ; <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; param += <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ptr
",torvalds@linux/ef87dbe7614341c2e7bfe8d32fcb7028cc97442c,CVE-2014-1737,https://github.com/torvalds/linux/commit/ef87dbe7614341c2e7bfe8d32fcb7028cc97442c,2014-05-11T21:55Z,<S2SV_StartBug> if ( ret ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> ptr -> kernel_data = NULL ; <S2SV_EndBug>
920,CWE-476,"void migrate_page_copy ( struct page * newpage , struct page * page ) { int cpupid ; if ( PageHuge ( page ) || PageTransHuge ( page ) ) copy_huge_page ( newpage , page ) ; else copy_highpage ( newpage , page ) ; if ( PageError ( page ) ) SetPageError ( newpage ) ; if ( PageReferenced ( page ) ) SetPageReferenced ( newpage ) ; if ( PageUptodate ( page ) ) SetPageUptodate ( newpage ) ; if ( TestClearPageActive ( page ) ) { VM_BUG_ON_PAGE ( PageUnevictable ( page ) , page ) ; SetPageActive ( newpage ) ; } else if ( TestClearPageUnevictable ( page ) ) SetPageUnevictable ( newpage ) ; if ( PageChecked ( page ) ) SetPageChecked ( newpage ) ; if ( PageMappedToDisk ( page ) ) SetPageMappedToDisk ( newpage ) ; <S2SV_StartBug> if ( PageDirty ( page ) ) { <S2SV_EndBug> clear_page_dirty_for_io ( page ) ; if ( PageSwapBacked ( page ) ) SetPageDirty ( newpage ) ; <S2SV_StartBug> else <S2SV_EndBug> __set_page_dirty_nobuffers ( newpage ) ; } if ( page_is_young ( page ) ) set_page_young ( newpage ) ; if ( page_is_idle ( page ) ) set_page_idle ( newpage ) ; cpupid = page_cpupid_xchg_last ( page , - 1 ) ; page_cpupid_xchg_last ( newpage , cpupid ) ; ksm_migrate_page ( newpage , page ) ; if ( PageSwapCache ( page ) ) ClearPageSwapCache ( page ) ; ClearPagePrivate ( page ) ; set_page_private ( page , 0 ) ; if ( PageWriteback ( newpage ) ) end_page_writeback ( newpage ) ; }
","<S2SV_ModStart> page ) ) <S2SV_ModEnd> SetPageDirty ( newpage <S2SV_ModStart> newpage ) ; <S2SV_ModEnd> if ( page_is_young
",torvalds@linux/42cb14b110a5698ccf26ce59c4441722605a3743,CVE-2016-3070,https://github.com/torvalds/linux/commit/42cb14b110a5698ccf26ce59c4441722605a3743,2016-08-06T20:59Z,<S2SV_StartBug> if ( PageDirty ( page ) ) { <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug>
3060,CWE-320,"int sshkey_load_file ( int fd , struct sshbuf * blob ) { u_char buf [ 1024 ] ; size_t len ; struct stat st ; <S2SV_StartBug> int r ; <S2SV_EndBug> if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ; if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size > MAX_KEY_FILE_SIZE ) return SSH_ERR_INVALID_FORMAT ; <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) { if ( errno == EPIPE ) break ; r = SSH_ERR_SYSTEM_ERROR ; goto out ; } if ( ( r = sshbuf_put ( blob , buf , len ) ) != 0 ) goto out ; if ( sshbuf_len ( blob ) > MAX_KEY_FILE_SIZE ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } } if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size != ( off_t ) sshbuf_len ( blob ) ) { r = SSH_ERR_FILE_CHANGED ; goto out ; } r = 0 ; out : explicit_bzero ( buf , sizeof ( buf ) ) ; if ( r != 0 ) sshbuf_reset ( blob ) ; return r ; }
","<S2SV_ModStart> ; int r , dontmax = 0 <S2SV_ModStart> return SSH_ERR_INVALID_FORMAT ; if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;
",openbsd@src/ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9,CVE-2016-10011,https://github.com/openbsd/src/commit/ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9,2017-01-05T02:59Z,<S2SV_StartBug> int r ; <S2SV_EndBug> <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug>
5925,CWE-125,"static Image * ReadPDBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { unsigned char attributes , tag [ 3 ] ; Image * image ; MagickBooleanType status ; PDBImage pdb_image ; PDBInfo pdb_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; size_t bits_per_pixel , num_pad_bytes , one , packets ; ssize_t count , img_offset , comment_offset = 0 , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , sizeof ( pdb_info . name ) , ( unsigned char * ) pdb_info . name ) ; if ( count != sizeof ( pdb_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_info . attributes = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . version = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . create_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_time = ReadBlobMSBLong ( image ) ; pdb_info . archive_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_number = ReadBlobMSBLong ( image ) ; pdb_info . application_info = ReadBlobMSBLong ( image ) ; pdb_info . sort_info = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . type ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . id ) ; pdb_info . seed = ReadBlobMSBLong ( image ) ; pdb_info . next_record = ReadBlobMSBLong ( image ) ; pdb_info . number_records = ( short ) ReadBlobMSBShort ( image ) ; if ( ( memcmp ( pdb_info . type , ""vIMG"" , 4 ) != 0 ) || ( memcmp ( pdb_info . id , ""View"" , 4 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( pdb_info . next_record != 0 ) ThrowReaderException ( CoderError , ""MultipleRecordListNotSupported"" ) ; img_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) attributes ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x00"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; if ( pdb_info . number_records > 1 ) { comment_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x01"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } num_pad_bytes = ( size_t ) ( img_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- != 0 ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } count = ReadBlob ( image , sizeof ( pdb_image . name ) , ( unsigned char * ) pdb_image . name ) ; if ( count != sizeof ( pdb_image . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_image . version = ReadBlobByte ( image ) ; pdb_image . type = ( unsigned char ) ( ( int ) ReadBlobByte ( image ) ) ; pdb_image . reserved_1 = ReadBlobMSBLong ( image ) ; pdb_image . note = ReadBlobMSBLong ( image ) ; pdb_image . x_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . y_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . reserved_2 = ReadBlobMSBLong ( image ) ; pdb_image . x_anchor = ReadBlobMSBShort ( image ) ; pdb_image . y_anchor = ReadBlobMSBShort ( image ) ; pdb_image . width = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . height = ( short ) ReadBlobMSBShort ( image ) ; image -> columns = ( size_t ) pdb_image . width ; image -> rows = ( size_t ) pdb_image . height ; image -> depth = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; image -> storage_class = PseudoClass ; bits_per_pixel = pdb_image . type == 0 ? 2UL : pdb_image . type == 2 ? 4UL : 1UL ; one = 1 ; if ( AcquireImageColormap ( image , one << bits_per_pixel , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } packets = ( bits_per_pixel * image -> columns + 7 ) / 8 ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; switch ( pdb_image . version & 0x07 ) { case 0 : { image -> compression = NoCompression ; count = ( ssize_t ) ReadBlob ( image , packets * image -> rows , pixels ) ; break ; } case 1 : { image -> compression = RLECompression ; if ( ! DecodeImage ( image , pixels , packets * image -> rows ) ) ThrowReaderException ( CorruptImageError , ""RLEDecoderError"" ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompressionType"" ) ; } p = pixels ; switch ( bits_per_pixel ) { case 1 : { int bit ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( * p & ( 0x80 >> bit ) ? 0x00 : 0x01 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 2 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 3 ; x += 4 ) { index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 6 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 4 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 2 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 1 ; x += 2 ) { index = ConstrainColormapIndex ( image , 15UL - ( ( * p >> 4 ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 15UL - ( ( * p ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; if ( pdb_info . number_records > 1 ) { char * comment ; int c ; register char * p ; size_t length ; num_pad_bytes = ( size_t ) ( comment_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- ) ReadBlobByte ( image ) ; c = ReadBlobByte ( image ) ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; c != EOF ; p ++ ) { if ( ( size_t ) ( p - comment + MagickPathExtent ) >= length ) { * p = '\\0' ; length <<= 1 ; length += MagickPathExtent ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ( packets + 257UL <S2SV_ModEnd> , image ->
",ImageMagick@ImageMagick/6d202a0514fb6a406456b8b728cde776becb25f8,CVE-2016-7537,https://github.com/ImageMagick/ImageMagick/commit/6d202a0514fb6a406456b8b728cde776becb25f8,2017-04-19T14:59Z,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug>"
1992,CWE-119,"vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , <S2SV_StartBug> vpx_codec_enc_cfg_t * cfg , <S2SV_EndBug> vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; } <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ctx -> priv -> iface = ctx -> iface ; } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> * iface , const <S2SV_ModStart> ( flags & <S2SV_ModEnd> VPX_CODEC_USE_PSNR ) && <S2SV_ModStart> ) ; } <S2SV_ModEnd> } return SAVE_STATUS
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_codec_enc_cfg_t * cfg , <S2SV_EndBug> <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug>"
1678,CWE-119,"<S2SV_StartBug> static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> int min_log2_tile_cols , max_log2_tile_cols , ones ; vp9_get_tile_n_bits ( cm -> mi_cols , & min_log2_tile_cols , & max_log2_tile_cols ) ; ones = cm -> log2_tile_cols - min_log2_tile_cols ; while ( ones -- ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> if ( cm -> log2_tile_cols < max_log2_tile_cols ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ; <S2SV_EndBug> if ( cm -> log2_tile_rows != 0 ) <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> void write_tile_info ( const VP9_COMMON * const <S2SV_ModEnd> cm , struct <S2SV_ModStart> cm , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> ones -- ) vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> < max_log2_tile_cols ) vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> 0 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> != 0 ) vpx_wb_write_bit <S2SV_ModEnd> ( wb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ; <S2SV_EndBug>"
4311,CWE-476,"static apr_status_t modsecurity_request_body_store_memory ( modsec_rec * msr , const char * data , apr_size_t length , char * * error_msg ) { * error_msg = NULL ; <S2SV_StartBug> if ( ( msr -> msc_reqbody_spilltodisk ) <S2SV_EndBug> && ( msr -> msc_reqbody_length + length > ( apr_size_t ) msr -> txcfg -> reqbody_inmemory_limit ) ) { msc_data_chunk * * chunks ; unsigned int disklen = 0 ; int i ; msr_log ( msr , 4 , ""Input<S2SV_blank>filter:<S2SV_blank>Request<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>store<S2SV_blank>in<S2SV_blank>memory,<S2SV_blank>switching<S2SV_blank>to<S2SV_blank>disk."" ) ; msr -> msc_reqbody_storage = MSC_REQBODY_DISK ; if ( modsecurity_request_body_start_init ( msr , error_msg ) < 0 ) return - 1 ; chunks = ( msc_data_chunk * * ) msr -> msc_reqbody_chunks -> elts ; for ( i = 0 ; i < msr -> msc_reqbody_chunks -> nelts ; i ++ ) { disklen += chunks [ i ] -> length ; if ( modsecurity_request_body_store_disk ( msr , chunks [ i ] -> data , chunks [ i ] -> length , error_msg ) < 0 ) { return - 1 ; } free ( chunks [ i ] -> data ) ; chunks [ i ] -> data = NULL ; } msr -> msc_reqbody_chunks = NULL ; apr_pool_clear ( msr -> msc_reqbody_mp ) ; msr_log ( msr , 4 , ""Input<S2SV_blank>filter:<S2SV_blank>Wrote<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>disk."" , disklen ) ; return modsecurity_request_body_store_disk ( msr , data , length , error_msg ) ; } { unsigned long int bucket_offset , bucket_left ; bucket_offset = 0 ; bucket_left = length ; while ( bucket_left > 0 ) { if ( msr -> msc_reqbody_chunk_current == NULL ) { msr -> msc_reqbody_chunk_current = ( msc_data_chunk * ) apr_pcalloc ( msr -> msc_reqbody_mp , sizeof ( msc_data_chunk ) ) ; if ( msr -> msc_reqbody_chunk_current == NULL ) { * error_msg = apr_psprintf ( msr -> mp , ""Input<S2SV_blank>filter:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>"" ""for<S2SV_blank>request<S2SV_blank>body<S2SV_blank>chunk."" , ( unsigned long ) sizeof ( msc_data_chunk ) ) ; return - 1 ; } msr -> msc_reqbody_chunk_current -> data = malloc ( CHUNK_CAPACITY ) ; if ( msr -> msc_reqbody_chunk_current -> data == NULL ) { * error_msg = apr_psprintf ( msr -> mp , ""Input<S2SV_blank>filter:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>"" ""for<S2SV_blank>request<S2SV_blank>body<S2SV_blank>chunk<S2SV_blank>data."" , CHUNK_CAPACITY ) ; return - 1 ; } msr -> msc_reqbody_chunk_current -> length = 0 ; msr -> msc_reqbody_chunk_current -> is_permanent = 1 ; * ( const msc_data_chunk * * ) apr_array_push ( msr -> msc_reqbody_chunks ) = msr -> msc_reqbody_chunk_current ; } if ( bucket_left < ( CHUNK_CAPACITY - msr -> msc_reqbody_chunk_current -> length ) ) { memcpy ( msr -> msc_reqbody_chunk_current -> data + msr -> msc_reqbody_chunk_current -> length , data + bucket_offset , bucket_left ) ; msr -> msc_reqbody_chunk_current -> length += bucket_left ; bucket_left = 0 ; } else { unsigned long int copy_length = CHUNK_CAPACITY - msr -> msc_reqbody_chunk_current -> length ; memcpy ( msr -> msc_reqbody_chunk_current -> data + msr -> msc_reqbody_chunk_current -> length , data + bucket_offset , copy_length ) ; bucket_offset += copy_length ; bucket_left -= copy_length ; msr -> msc_reqbody_chunk_current -> length += copy_length ; msr -> msc_reqbody_chunk_current = NULL ; } } msr -> msc_reqbody_length += length ; } return 1 ; }
","<S2SV_ModStart> msr -> msc_reqbody_spilltodisk ) && ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_ON
",SpiderLabs@ModSecurity/0840b13612a0b7ef1ce7441cf811dcfc6b463fba,CVE-2013-2765,https://github.com/SpiderLabs/ModSecurity/commit/0840b13612a0b7ef1ce7441cf811dcfc6b463fba,2013-07-15T15:55Z,<S2SV_StartBug> if ( ( msr -> msc_reqbody_spilltodisk ) <S2SV_EndBug>
1826,CWE-119,"void vp9_rc_get_one_pass_vbr_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; int target ; if ( ! cpi -> refresh_alt_ref_frame && ( cm -> current_video_frame == 0 || <S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> rc -> frames_to_key == 0 || <S2SV_StartBug> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <S2SV_EndBug> cm -> frame_type = KEY_FRAME ; rc -> this_key_frame_forced = cm -> current_video_frame != 0 && rc -> frames_to_key == 0 ; <S2SV_StartBug> rc -> frames_to_key = cpi -> key_frame_frequency ; <S2SV_EndBug> rc -> kf_boost = DEFAULT_KF_BOOST ; rc -> source_alt_ref_active = 0 ; } else { cm -> frame_type = INTER_FRAME ; } if ( rc -> frames_till_gf_update_due == 0 ) { <S2SV_StartBug> rc -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; <S2SV_EndBug> rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) <S2SV_StartBug> rc -> frames_till_gf_update_due = rc -> frames_to_key ; <S2SV_EndBug> cpi -> refresh_golden_frame = 1 ; rc -> source_alt_ref_pending = USE_ALTREF_FOR_ONE_PASS ; rc -> gfu_boost = DEFAULT_GF_BOOST ; } if ( cm -> frame_type == KEY_FRAME ) target = calc_iframe_target_size_one_pass_vbr ( cpi ) ; else target = calc_pframe_target_size_one_pass_vbr ( cpi ) ; vp9_rc_set_frame_target ( cpi , target ) ; }
","<S2SV_ModStart> 0 || ( cpi <S2SV_ModEnd> -> frame_flags & <S2SV_ModStart> . auto_key && 0 <S2SV_ModEnd> ) ) ) <S2SV_ModStart> = cpi -> oxcf . key_freq <S2SV_ModEnd> ; rc -> <S2SV_ModStart> -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 <S2SV_ModEnd> ; rc -> <S2SV_ModStart> -> frames_to_key ) { rc -> frames_till_gf_update_due = rc -> frames_to_key ; rc -> constrained_gf_group = 1 ; } else { rc -> constrained_gf_group = 0 ; } <S2SV_ModEnd> cpi -> refresh_golden_frame
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> <S2SV_StartBug> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> rc -> frames_to_key = cpi -> key_frame_frequency ; <S2SV_EndBug> <S2SV_StartBug> rc -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; <S2SV_EndBug> <S2SV_StartBug> rc -> frames_till_gf_update_due = rc -> frames_to_key ; <S2SV_EndBug>
1216,CWE-200,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug> MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;
",ImageMagick@ImageMagick/51b0ae01709adc1e4a9245e158ef17b85a110960,CVE-2017-13143,https://github.com/ImageMagick/ImageMagick/commit/51b0ae01709adc1e4a9245e158ef17b85a110960,2017-08-23T06:29Z,<S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug>
2734,CWE-269,"static int store_asoundrc ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_ASOUNDRC_FILE ; FILE * fp = fopen ( dest , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0644 ) ; fclose ( fp ) ; } if ( asprintf ( & src , ""%s/.asoundrc"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { <S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.asoundrc<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> exit ( 1 ) ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest ) ; if ( rv ) <S2SV_StartBug> fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; <S2SV_EndBug> else { <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) errExit ( ""fchown"" ) ; if ( chmod ( dest , 0644 ) == - 1 ) errExit ( ""fchmod"" ) ; return 1 ; } return 0 ; }
","<S2SV_ModStart> ) ) { char * rp = realpath ( src , NULL ) ; if ( ! rp ) { <S2SV_ModStart> ( stderr , ""Error:<S2SV_blank>Cannot<S2SV_blank>access<S2SV_blank>%s\\n"" , src <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ) ; } if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != 0 ) { <S2SV_ModEnd> fprintf ( stderr <S2SV_ModStart> ( stderr , ""Error:<S2SV_blank>.asoundrc<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file<S2SV_blank>outside<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; exit ( 1 ) ; } free ( rp ) ; } copy_file_as_user ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ; <S2SV_ModEnd> fs_logger2 ( ""clone"" <S2SV_ModStart> ""clone"" , dest <S2SV_ModEnd> ) ; return
",netblue30@firejail/903fd8a0789ca3cc3c21d84cd0282481515592ef,CVE-2017-5940,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,2017-02-09T18:59Z,"<S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.asoundrc<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug>"
539,CWE-125,"int fpm_log_write ( char * log_format ) { char * s , * b ; char buffer [ FPM_LOG_BUFFER + 1 ] ; int token , test ; size_t len , len2 ; struct fpm_scoreboard_proc_s proc , * proc_p ; struct fpm_scoreboard_s * scoreboard ; char tmp [ 129 ] ; char format [ 129 ] ; time_t now_epoch ; # ifdef HAVE_TIMES clock_t tms_total ; # endif if ( ! log_format && ( ! fpm_log_format || fpm_log_fd == - 1 ) ) { return - 1 ; } if ( ! log_format ) { log_format = fpm_log_format ; test = 0 ; } else { test = 1 ; } now_epoch = time ( NULL ) ; if ( ! test ) { scoreboard = fpm_scoreboard_get ( ) ; if ( ! scoreboard ) { zlog ( ZLOG_WARNING , ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>scoreboard<S2SV_blank>while<S2SV_blank>preparing<S2SV_blank>the<S2SV_blank>access<S2SV_blank>log"" ) ; return - 1 ; } proc_p = fpm_scoreboard_proc_acquire ( NULL , - 1 , 0 ) ; if ( ! proc_p ) { zlog ( ZLOG_WARNING , ""[pool<S2SV_blank>%s]<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>acquire<S2SV_blank>shm<S2SV_blank>slot<S2SV_blank>while<S2SV_blank>preparing<S2SV_blank>the<S2SV_blank>access<S2SV_blank>log"" , scoreboard -> pool ) ; return - 1 ; } proc = * proc_p ; fpm_scoreboard_proc_release ( proc_p ) ; } token = 0 ; memset ( buffer , '\\0' , sizeof ( buffer ) ) ; b = buffer ; len = 0 ; s = log_format ; while ( * s != '\\0' ) { if ( len >= FPM_LOG_BUFFER ) { zlog ( ZLOG_NOTICE , ""the<S2SV_blank>log<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>full<S2SV_blank>(%d).<S2SV_blank>The<S2SV_blank>access<S2SV_blank>log<S2SV_blank>request<S2SV_blank>has<S2SV_blank>been<S2SV_blank>truncated."" , FPM_LOG_BUFFER ) ; len = FPM_LOG_BUFFER ; break ; } if ( ! token && * s == '%' ) { token = 1 ; memset ( format , '\\0' , sizeof ( format ) ) ; s ++ ; continue ; } if ( token ) { token = 0 ; len2 = 0 ; switch ( * s ) { case '%' : * b = '%' ; len2 = 1 ; break ; # ifdef HAVE_TIMES case 'C' : if ( format [ 0 ] == '\\0' || ! strcasecmp ( format , ""total"" ) ) { if ( ! test ) { tms_total = proc . last_request_cpu . tms_utime + proc . last_request_cpu . tms_stime + proc . last_request_cpu . tms_cutime + proc . last_request_cpu . tms_cstime ; } } else if ( ! strcasecmp ( format , ""user"" ) ) { if ( ! test ) { tms_total = proc . last_request_cpu . tms_utime + proc . last_request_cpu . tms_cutime ; } } else if ( ! strcasecmp ( format , ""system"" ) ) { if ( ! test ) { tms_total = proc . last_request_cpu . tms_stime + proc . last_request_cpu . tms_cstime ; } } else { zlog ( ZLOG_WARNING , ""only<S2SV_blank>\'total\',<S2SV_blank>\'user\'<S2SV_blank>or<S2SV_blank>\'system\'<S2SV_blank>are<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>a<S2SV_blank>modifier<S2SV_blank>for<S2SV_blank>%%%c<S2SV_blank>(\'%s\')"" , * s , format ) ; return - 1 ; } format [ 0 ] = '\\0' ; if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%.2f"" , tms_total / fpm_scoreboard_get_tick ( ) / ( proc . cpu_duration . tv_sec + proc . cpu_duration . tv_usec / 1000000. ) * 100. ) ; } break ; # endif case 'd' : if ( format [ 0 ] == '\\0' || ! strcasecmp ( format , ""seconds"" ) ) { if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%.3f"" , proc . duration . tv_sec + proc . duration . tv_usec / 1000000. ) ; } } else if ( ! strcasecmp ( format , ""miliseconds"" ) || ! strcasecmp ( format , ""mili"" ) ) { if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%.3f"" , proc . duration . tv_sec * 1000. + proc . duration . tv_usec / 1000. ) ; } } else if ( ! strcasecmp ( format , ""microseconds"" ) || ! strcasecmp ( format , ""micro"" ) ) { if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%lu"" , proc . duration . tv_sec * 1000000UL + proc . duration . tv_usec ) ; } } else { zlog ( ZLOG_WARNING , ""only<S2SV_blank>\'seconds\',<S2SV_blank>\'mili\',<S2SV_blank>\'miliseconds\',<S2SV_blank>\'micro\'<S2SV_blank>or<S2SV_blank>\'microseconds\'<S2SV_blank>are<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>a<S2SV_blank>modifier<S2SV_blank>for<S2SV_blank>%%%c<S2SV_blank>(\'%s\')"" , * s , format ) ; return - 1 ; } format [ 0 ] = '\\0' ; break ; case 'e' : if ( format [ 0 ] == '\\0' ) { zlog ( ZLOG_WARNING , ""the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>environment<S2SV_blank>variable<S2SV_blank>must<S2SV_blank>be<S2SV_blank>set<S2SV_blank>between<S2SV_blank>embraces<S2SV_blank>for<S2SV_blank>%%%c"" , * s ) ; return - 1 ; } if ( ! test ) { char * env = fcgi_getenv ( ( fcgi_request * ) SG ( server_context ) , format , strlen ( format ) ) ; len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%s"" , env ? env : ""-"" ) ; } format [ 0 ] = '\\0' ; break ; case 'f' : if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%s"" , * proc . script_filename ? proc . script_filename : ""-"" ) ; } break ; case 'l' : if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%zu"" , proc . content_length ) ; } break ; case 'm' : if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%s"" , * proc . request_method ? proc . request_method : ""-"" ) ; } break ; case 'M' : if ( format [ 0 ] == '\\0' || ! strcasecmp ( format , ""bytes"" ) ) { if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%zu"" , proc . memory ) ; } } else if ( ! strcasecmp ( format , ""kilobytes"" ) || ! strcasecmp ( format , ""kilo"" ) ) { if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%lu"" , proc . memory / 1024 ) ; } } else if ( ! strcasecmp ( format , ""megabytes"" ) || ! strcasecmp ( format , ""mega"" ) ) { if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%lu"" , proc . memory / 1024 / 1024 ) ; } } else { zlog ( ZLOG_WARNING , ""only<S2SV_blank>\'bytes\',<S2SV_blank>\'kilo\',<S2SV_blank>\'kilobytes\',<S2SV_blank>\'mega\'<S2SV_blank>or<S2SV_blank>\'megabytes\'<S2SV_blank>are<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>a<S2SV_blank>modifier<S2SV_blank>for<S2SV_blank>%%%c<S2SV_blank>(\'%s\')"" , * s , format ) ; return - 1 ; } format [ 0 ] = '\\0' ; break ; case 'n' : if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%s"" , scoreboard -> pool [ 0 ] ? scoreboard -> pool : ""-"" ) ; } break ; case 'o' : if ( format [ 0 ] == '\\0' ) { zlog ( ZLOG_WARNING , ""the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>header<S2SV_blank>must<S2SV_blank>be<S2SV_blank>set<S2SV_blank>between<S2SV_blank>embraces<S2SV_blank>for<S2SV_blank>%%%c"" , * s ) ; return - 1 ; } if ( ! test ) { sapi_header_struct * h ; zend_llist_position pos ; sapi_headers_struct * sapi_headers = & SG ( sapi_headers ) ; size_t format_len = strlen ( format ) ; h = ( sapi_header_struct * ) zend_llist_get_first_ex ( & sapi_headers -> headers , & pos ) ; while ( h ) { char * header ; if ( ! h -> header_len ) { h = ( sapi_header_struct * ) zend_llist_get_next_ex ( & sapi_headers -> headers , & pos ) ; continue ; } if ( ! strstr ( h -> header , format ) ) { h = ( sapi_header_struct * ) zend_llist_get_next_ex ( & sapi_headers -> headers , & pos ) ; continue ; } if ( h -> header_len <= format_len + 2 ) { h = ( sapi_header_struct * ) zend_llist_get_next_ex ( & sapi_headers -> headers , & pos ) ; continue ; } if ( h -> header [ format_len ] != ':' || h -> header [ format_len + 1 ] != '<S2SV_blank>' ) { h = ( sapi_header_struct * ) zend_llist_get_next_ex ( & sapi_headers -> headers , & pos ) ; continue ; } header = h -> header + format_len + 2 ; len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%s"" , header && * header ? header : ""-"" ) ; break ; } if ( ! len2 ) { len2 = 1 ; * b = '-' ; } } format [ 0 ] = '\\0' ; break ; case 'p' : if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%ld"" , ( long ) getpid ( ) ) ; } break ; case 'P' : if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%ld"" , ( long ) getppid ( ) ) ; } break ; case 'q' : if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%s"" , proc . query_string ) ; } break ; case 'Q' : if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%s"" , * proc . query_string ? ""?"" : """" ) ; } break ; case 'r' : if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%s"" , proc . request_uri ) ; } break ; case 'R' : if ( ! test ) { const char * tmp = fcgi_get_last_client_ip ( ) ; len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%s"" , tmp ? tmp : ""-"" ) ; } break ; case 's' : if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%d"" , SG ( sapi_headers ) . http_response_code ) ; } break ; case 'T' : case 't' : if ( ! test ) { time_t * t ; if ( * s == 't' ) { t = & proc . accepted_epoch ; } else { t = & now_epoch ; } if ( format [ 0 ] == '\\0' ) { strftime ( tmp , sizeof ( tmp ) - 1 , ""%d/%b/%Y:%H:%M:%S<S2SV_blank>%z"" , localtime ( t ) ) ; } else { strftime ( tmp , sizeof ( tmp ) - 1 , format , localtime ( t ) ) ; } len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%s"" , tmp ) ; } format [ 0 ] = '\\0' ; break ; case 'u' : if ( ! test ) { len2 = snprintf ( b , FPM_LOG_BUFFER - len , ""%s"" , proc . auth_user ) ; } break ; case '{' : token = 1 ; { char * start ; size_t l ; start = ++ s ; while ( * s != '\\0' ) { if ( * s == '}' ) { l = s - start ; if ( l >= sizeof ( format ) - 1 ) { l = sizeof ( format ) - 1 ; } memcpy ( format , start , l ) ; format [ l ] = '\\0' ; break ; } s ++ ; } if ( s [ 1 ] == '\\0' ) { zlog ( ZLOG_WARNING , ""missing<S2SV_blank>closing<S2SV_blank>embrace<S2SV_blank>in<S2SV_blank>the<S2SV_blank>access.format"" ) ; return - 1 ; } } break ; default : zlog ( ZLOG_WARNING , ""Invalid<S2SV_blank>token<S2SV_blank>in<S2SV_blank>the<S2SV_blank>access.format<S2SV_blank>(%%%c)"" , * s ) ; return - 1 ; } if ( * s != '}' && format [ 0 ] != '\\0' ) { zlog ( ZLOG_WARNING , ""embrace<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>modifier<S2SV_blank>%%%c"" , * s ) ; return - 1 ; } s ++ ; if ( ! test ) { b += len2 ; len += len2 ; } <S2SV_StartBug> continue ; <S2SV_EndBug> } if ( ! test ) { * b = * s ; b ++ ; len ++ ; } s ++ ; } if ( ! test && strlen ( buffer ) > 0 ) { buffer [ len ] = '\\n' ; write ( fpm_log_fd , buffer , len + 1 ) ; } return 0 ; }
","<S2SV_ModStart> len2 ; } if ( len >= FPM_LOG_BUFFER ) { zlog ( ZLOG_NOTICE , ""the<S2SV_blank>log<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>full<S2SV_blank>(%d).<S2SV_blank>The<S2SV_blank>access<S2SV_blank>log<S2SV_blank>request<S2SV_blank>has<S2SV_blank>been<S2SV_blank>truncated."" , FPM_LOG_BUFFER ) ; len = FPM_LOG_BUFFER ; break ; }
",php@php-src/2721a0148649e07ed74468f097a28899741eb58f,CVE-2016-5114,https://github.com/php/php-src/commit/2721a0148649e07ed74468f097a28899741eb58f?w=1,2016-08-07T10:59Z,<S2SV_StartBug> continue ; <S2SV_EndBug>
1715,CWE-119,"static void nonrd_use_partition ( VP9_COMP * cpi , <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled , <S2SV_StartBug> int * totrate , int64_t * totdist ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> const int mis = cm -> mi_stride ; PARTITION_TYPE partition ; BLOCK_SIZE subsize ; <S2SV_StartBug> int rate = INT_MAX ; <S2SV_EndBug> int64_t dist = INT64_MAX ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_StartBug> subsize = ( bsize >= BLOCK_8X8 ) ? mi_8x8 [ 0 ] -> mbmi . sb_type : BLOCK_4X4 ; <S2SV_EndBug> partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_StartBug> switch ( partition ) { <S2SV_EndBug> case PARTITION_NONE : <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> break ; case PARTITION_VERT : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + hbs , <S2SV_EndBug> & rate , & dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> if ( rate != INT_MAX && dist != INT64_MAX && <S2SV_EndBug> * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } } break ; case PARTITION_HORZ : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row + hbs , mi_col , <S2SV_EndBug> & rate , & dist , subsize ) ; <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = mi_8x8 [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( rate != INT_MAX && dist != INT64_MAX && <S2SV_EndBug> * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } } break ; case PARTITION_SPLIT : subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> subsize , output_enabled , totrate , totdist ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs , tp , <S2SV_EndBug> mi_row , mi_col + hbs , subsize , output_enabled , <S2SV_StartBug> & rate , & dist ) ; <S2SV_EndBug> if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } * get_sb_index ( x , subsize ) = 2 ; <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis , tp , <S2SV_EndBug> <S2SV_StartBug> mi_row + hbs , mi_col , subsize , output_enabled , <S2SV_EndBug> <S2SV_StartBug> & rate , & dist ) ; <S2SV_EndBug> if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } * get_sb_index ( x , subsize ) = 3 ; nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis + hbs , tp , mi_row + hbs , mi_col + hbs , subsize , output_enabled , & rate , & dist ) ; if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } break ; default : <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_64X64 && output_enabled ) { <S2SV_EndBug> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , * totrate , * totdist ) ; encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , 1 , bsize ) ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> * cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , MODE_INFO * <S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> , TOKENEXTRA * <S2SV_ModStart> int output_enabled , RD_COST * dummy_cost , PC_TREE * pc_tree <S2SV_ModEnd> ) { VP9_COMMON <S2SV_ModStart> -> common ; TileInfo * tile_info = & tile_data -> tile_info ; <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = <S2SV_ModStart> BLOCK_SIZE subsize ; <S2SV_ModEnd> if ( mi_row <S2SV_ModStart> BLOCK_8X8 ) ? mi <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) { int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; td -> counts -> partition [ ctx ] [ partition ] ++ ; } <S2SV_ModStart> case PARTITION_NONE : pc_tree -> none . pred_pixel_ready = 1 ; <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> none ) ; pc_tree -> none . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> ] -> mbmi ; pc_tree -> none . mbmi_ext = * x -> mbmi_ext ; pc_tree -> none . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> none . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) <S2SV_ModStart> case PARTITION_VERT : pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 <S2SV_ModEnd> ; nonrd_pick_sb_modes ( <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> ] -> mbmi ; pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModStart> cm -> mi_cols && bsize > BLOCK_8X8 ) { pc_tree -> vertical [ 1 ] . pred_pixel_ready <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col + hbs , dummy_cost , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> -> mbmi ; pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ; <S2SV_ModEnd> } break ; <S2SV_ModStart> case PARTITION_HORZ : pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 <S2SV_ModEnd> ; nonrd_pick_sb_modes ( <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> ] -> mbmi ; pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] ) <S2SV_ModStart> cm -> mi_rows && bsize > BLOCK_8X8 ) { pc_tree -> horizontal [ 1 ] . pred_pixel_ready <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ( cpi , tile_data , x , mi_row + hbs , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> . mbmi = xd -> mi <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> -> mbmi ; pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ; <S2SV_ModEnd> } break ; <S2SV_ModStart> PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , pc_tree -> leaf_split [ 0 ] ) ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> nonrd_use_partition ( cpi <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , <S2SV_ModStart> , output_enabled , dummy_cost , pc_tree -> split [ 0 ] ) <S2SV_ModEnd> ; nonrd_use_partition ( <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> + hbs , <S2SV_ModStart> , output_enabled , dummy_cost , pc_tree -> split [ 1 ] ) ; nonrd_use_partition ( cpi , td , tile_data , mi + hbs * mis , tp , mi_row + hbs , mi_col , subsize , output_enabled , dummy_cost , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; nonrd_use_partition ( <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> + hbs * <S2SV_ModStart> hbs * mis + hbs <S2SV_ModStart> hbs , mi_col + hbs <S2SV_ModStart> , output_enabled , dummy_cost , pc_tree -> split [ 3 ] ) <S2SV_ModEnd> ; } break <S2SV_ModStart> : assert ( 0 && <S2SV_ModStart> ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break ; <S2SV_ModStart> } if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize <S2SV_ModEnd> , bsize ) <S2SV_ModStart> bsize ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> int * totrate , int64_t * totdist ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> int rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> subsize = ( bsize >= BLOCK_8X8 ) ? mi_8x8 [ 0 ] -> mbmi . sb_type : BLOCK_4X4 ; <S2SV_EndBug> <S2SV_StartBug> switch ( partition ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + hbs , <S2SV_EndBug> <S2SV_StartBug> if ( rate != INT_MAX && dist != INT64_MAX && <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row + hbs , mi_col , <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = mi_8x8 [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( rate != INT_MAX && dist != INT64_MAX && <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> subsize , output_enabled , totrate , totdist ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs , tp , <S2SV_EndBug> <S2SV_StartBug> & rate , & dist ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis , tp , <S2SV_EndBug> <S2SV_StartBug> mi_row + hbs , mi_col , subsize , output_enabled , <S2SV_EndBug> <S2SV_StartBug> & rate , & dist ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_64X64 && output_enabled ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
3690,CWE-476,"static int skcipher_accept_parent ( void * private , struct sock * sk ) { struct skcipher_ctx * ctx ; struct alg_sock * ask = alg_sk ( sk ) ; <S2SV_StartBug> unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ; <S2SV_EndBug> ctx = sock_kmalloc ( sk , len , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; <S2SV_StartBug> ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) , <S2SV_EndBug> GFP_KERNEL ) ; if ( ! ctx -> iv ) { sock_kfree_s ( sk , ctx , len ) ; return - ENOMEM ; } <S2SV_StartBug> memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private = ctx ; <S2SV_StartBug> skcipher_request_set_tfm ( & ctx -> req , private ) ; <S2SV_EndBug> skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx -> completion ) ; sk -> sk_destruct = skcipher_sock_destruct ; return 0 ; }
","<S2SV_ModStart> sk ) ; struct skcipher_tfm * tfm = private ; struct crypto_skcipher * skcipher = tfm -> skcipher ; <S2SV_ModStart> + crypto_skcipher_reqsize ( skcipher ) ; if ( ! tfm -> has_key ) return - ENOKEY <S2SV_ModEnd> ; ctx = <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher <S2SV_ModEnd> ) , GFP_KERNEL <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher ) ) ; INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private <S2SV_ModEnd> = ctx ; <S2SV_ModStart> -> req , skcipher <S2SV_ModEnd> ) ; skcipher_request_set_callback
",torvalds@linux/dd504589577d8e8e70f51f997ad487a4cb6c026f,CVE-2015-8970,https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f,2016-11-28T03:59Z,"<S2SV_StartBug> unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ; <S2SV_EndBug> <S2SV_StartBug> ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) , <S2SV_EndBug> <S2SV_StartBug> memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ; <S2SV_EndBug> <S2SV_StartBug> skcipher_request_set_tfm ( & ctx -> req , private ) ; <S2SV_EndBug>"
3790,CWE-400,"static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MagickPathExtent ] ; CINInfo cin ; const unsigned char * pixels ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register Quantum * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , ""\\200\\052\\137\\327"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; memset ( & cin , 0 , sizeof ( cin ) ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.version"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.filename"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_date"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_time"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , ""dpx:image.orientation"" , ""%d"" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , ""dpx:image.label"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ReadBlobSignedLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.x_offset"" , ""%.20g"" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.y_offset"" , ""%.20g"" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.filename"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_date"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_time"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.device"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.model"" , property , exception ) ; ( void ) memset ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.serial"" , property , exception ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.id"" , ""%d"" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.type"" , ""%d"" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.offset"" , ""%d"" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.prefix"" , ""%.20g"" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.format"" , property , exception ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_position"" , ""%.20g"" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_rate"" , ""%g"" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.frame_id"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.slate_info"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; if ( cin . file . user_length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; profile = BlobToStringInfo ( ( const unsigned char * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , ""dpx:user.data"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } <S2SV_StartBug> for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) <S2SV_EndBug> { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } if ( offset < ( MagickOffsetType ) cin . file . image_offset ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_info -> quantum = 32 ; quantum_info -> pack = MagickFalse ; quantum_type = RGBQuantum ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( ( size_t ) count != length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , LogColorspace , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;
",ImageMagick@ImageMagick/e3cdce6fe12193f235b8c0ae5efe6880a25eb957,CVE-2019-11470,https://github.com/ImageMagick/ImageMagick/commit/e3cdce6fe12193f235b8c0ae5efe6880a25eb957,2019-04-23T14:29Z,<S2SV_StartBug> for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) <S2SV_EndBug>
3538,CWE-416,"static int init_items ( struct MACH0_ ( obj_t ) * bin ) { struct load_command lc = { 0 , 0 } ; ut8 loadc [ sizeof ( struct load_command ) ] = { 0 } ; bool is_first_thread = true ; ut64 off = 0LL ; int i , len ; bin -> uuidn = 0 ; bin -> os = 0 ; bin -> has_crypto = 0 ; if ( bin -> hdr . sizeofcmds > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>chopping<S2SV_blank>hdr.sizeofcmds\\n"" ) ; bin -> hdr . sizeofcmds = bin -> size - 128 ; } for ( i = 0 , off = sizeof ( struct MACH0_ ( mach_header ) ) ; i < bin -> hdr . ncmds ; i ++ , off += lc . cmdsize ) { if ( off > bin -> size || off + sizeof ( struct load_command ) > bin -> size ) { bprintf ( ""mach0:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>command\\n"" ) ; return false ; } len = r_buf_read_at ( bin -> b , off , loadc , sizeof ( struct load_command ) ) ; if ( len < 1 ) { bprintf ( ""Error:<S2SV_blank>read<S2SV_blank>(lc)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; return false ; } lc . cmd = r_read_ble32 ( & loadc [ 0 ] , bin -> big_endian ) ; lc . cmdsize = r_read_ble32 ( & loadc [ 4 ] , bin -> big_endian ) ; if ( lc . cmdsize < 1 || off + lc . cmdsize > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>mach0_header<S2SV_blank>%d<S2SV_blank>=<S2SV_blank>cmdsize<1.\\n"" , i ) ; break ; } sdb_num_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.offset"" , i ) , off , 0 ) ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.format"" , i ) , ""xd<S2SV_blank>cmd<S2SV_blank>size"" , 0 ) ; switch ( lc . cmd ) { case LC_DATA_IN_CODE : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""data_in_code"" , 0 ) ; break ; case LC_RPATH : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""rpath"" , 0 ) ; break ; case LC_SEGMENT_64 : case LC_SEGMENT : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""segment"" , 0 ) ; bin -> nsegs ++ ; if ( ! parse_segments ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>segment\\n"" ) ; bin -> nsegs -- ; return false ; } break ; case LC_SYMTAB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""symtab"" , 0 ) ; if ( ! parse_symtab ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>symtab\\n"" ) ; return false ; } break ; case LC_DYSYMTAB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dysymtab"" , 0 ) ; if ( ! parse_dysymtab ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>dysymtab\\n"" ) ; return false ; } break ; case LC_DYLIB_CODE_SIGN_DRS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylib_code_sign_drs"" , 0 ) ; break ; case LC_VERSION_MIN_MACOSX : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_macosx"" , 0 ) ; bin -> os = 1 ; break ; case LC_VERSION_MIN_IPHONEOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_iphoneos"" , 0 ) ; bin -> os = 2 ; break ; case LC_VERSION_MIN_TVOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_tvos"" , 0 ) ; bin -> os = 4 ; break ; case LC_VERSION_MIN_WATCHOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_watchos"" , 0 ) ; bin -> os = 3 ; break ; case LC_UUID : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""uuid"" , 0 ) ; { struct uuid_command uc = { 0 } ; if ( off + sizeof ( struct uuid_command ) > bin -> size ) { bprintf ( ""UUID<S2SV_blank>out<S2SV_blank>of<S2SV_blank>obunds\\n"" ) ; return false ; } if ( r_buf_fread_at ( bin -> b , off , ( ut8 * ) & uc , ""24c"" , 1 ) != - 1 ) { char key [ 128 ] ; char val [ 128 ] ; snprintf ( key , sizeof ( key ) - 1 , ""uuid.%d"" , bin -> uuidn ++ ) ; r_hex_bin2str ( ( ut8 * ) & uc . uuid , 16 , val ) ; sdb_set ( bin -> kv , key , val , 0 ) ; } } break ; case LC_ENCRYPTION_INFO_64 : case LC_ENCRYPTION_INFO : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""encryption_info"" , 0 ) ; { struct MACH0_ ( encryption_info_command ) eic = { 0 } ; ut8 seic [ sizeof ( struct MACH0_ ( encryption_info_command ) ) ] = { 0 } ; if ( off + sizeof ( struct MACH0_ ( encryption_info_command ) ) > bin -> size ) { bprintf ( ""encryption<S2SV_blank>info<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return false ; } if ( r_buf_read_at ( bin -> b , off , seic , sizeof ( struct MACH0_ ( encryption_info_command ) ) ) != - 1 ) { eic . cmd = r_read_ble32 ( & seic [ 0 ] , bin -> big_endian ) ; eic . cmdsize = r_read_ble32 ( & seic [ 4 ] , bin -> big_endian ) ; eic . cryptoff = r_read_ble32 ( & seic [ 8 ] , bin -> big_endian ) ; eic . cryptsize = r_read_ble32 ( & seic [ 12 ] , bin -> big_endian ) ; eic . cryptid = r_read_ble32 ( & seic [ 16 ] , bin -> big_endian ) ; bin -> has_crypto = eic . cryptid ; sdb_set ( bin -> kv , ""crypto"" , ""true"" , 0 ) ; sdb_num_set ( bin -> kv , ""cryptid"" , eic . cryptid , 0 ) ; sdb_num_set ( bin -> kv , ""cryptoff"" , eic . cryptoff , 0 ) ; sdb_num_set ( bin -> kv , ""cryptsize"" , eic . cryptsize , 0 ) ; sdb_num_set ( bin -> kv , ""cryptheader"" , off , 0 ) ; } } break ; case LC_LOAD_DYLINKER : { sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylinker"" , 0 ) ; free ( bin -> intrp ) ; bin -> intrp = NULL ; struct dylinker_command dy = { 0 } ; ut8 sdy [ sizeof ( struct dylinker_command ) ] = { 0 } ; if ( off + sizeof ( struct dylinker_command ) > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>parse<S2SV_blank>dylinker<S2SV_blank>command\\n"" ) ; return false ; } if ( r_buf_read_at ( bin -> b , off , sdy , sizeof ( struct dylinker_command ) ) == - 1 ) { bprintf ( ""Warning:<S2SV_blank>read<S2SV_blank>(LC_DYLD_INFO)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; } else { dy . cmd = r_read_ble32 ( & sdy [ 0 ] , bin -> big_endian ) ; dy . cmdsize = r_read_ble32 ( & sdy [ 4 ] , bin -> big_endian ) ; dy . name = r_read_ble32 ( & sdy [ 8 ] , bin -> big_endian ) ; int len = dy . cmdsize ; char * buf = malloc ( len + 1 ) ; if ( buf ) { r_buf_read_at ( bin -> b , off + 0xc , ( ut8 * ) buf , len ) ; buf [ len ] = 0 ; free ( bin -> intrp ) ; bin -> intrp = buf ; } } } break ; case LC_MAIN : { struct { ut64 eo ; ut64 ss ; } ep = { 0 } ; ut8 sep [ 2 * sizeof ( ut64 ) ] = { 0 } ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""main"" , 0 ) ; if ( ! is_first_thread ) { bprintf ( ""Error:<S2SV_blank>LC_MAIN<S2SV_blank>with<S2SV_blank>other<S2SV_blank>threads\\n"" ) ; return false ; } if ( off + 8 > bin -> size || off + sizeof ( ep ) > bin -> size ) { bprintf ( ""invalid<S2SV_blank>command<S2SV_blank>size<S2SV_blank>for<S2SV_blank>main\\n"" ) ; return false ; } r_buf_read_at ( bin -> b , off + 8 , sep , 2 * sizeof ( ut64 ) ) ; ep . eo = r_read_ble64 ( & sep [ 0 ] , bin -> big_endian ) ; ep . ss = r_read_ble64 ( & sep [ 8 ] , bin -> big_endian ) ; bin -> entry = ep . eo ; bin -> main_cmd = lc ; sdb_num_set ( bin -> kv , ""mach0.entry.offset"" , off + 8 , 0 ) ; sdb_num_set ( bin -> kv , ""stacksize"" , ep . ss , 0 ) ; is_first_thread = false ; } break ; case LC_UNIXTHREAD : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""unixthread"" , 0 ) ; if ( ! is_first_thread ) { bprintf ( ""Error:<S2SV_blank>LC_UNIXTHREAD<S2SV_blank>with<S2SV_blank>other<S2SV_blank>threads\\n"" ) ; return false ; } case LC_THREAD : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""thread"" , 0 ) ; if ( ! parse_thread ( bin , & lc , off , is_first_thread ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>thread\\n"" ) ; return false ; } is_first_thread = false ; break ; case LC_LOAD_DYLIB : case LC_LOAD_WEAK_DYLIB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""load_dylib"" , 0 ) ; bin -> nlibs ++ ; if ( ! parse_dylib ( bin , off ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dylib\\n"" ) ; bin -> nlibs -- ; return false ; } break ; case LC_DYLD_INFO : case LC_DYLD_INFO_ONLY : { ut8 dyldi [ sizeof ( struct dyld_info_command ) ] = { 0 } ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dyld_info"" , 0 ) ; <S2SV_StartBug> bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) { <S2SV_EndBug> bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\n"" ) ; <S2SV_StartBug> free ( bin -> dyld_info ) ; <S2SV_EndBug> return false ; } if ( r_buf_read_at ( bin -> b , off , dyldi , sizeof ( struct dyld_info_command ) ) == - 1 ) { free ( bin -> dyld_info ) ; bin -> dyld_info = NULL ; bprintf ( ""Error:<S2SV_blank>read<S2SV_blank>(LC_DYLD_INFO)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; } else { bin -> dyld_info -> cmd = r_read_ble32 ( & dyldi [ 0 ] , bin -> big_endian ) ; bin -> dyld_info -> cmdsize = r_read_ble32 ( & dyldi [ 4 ] , bin -> big_endian ) ; bin -> dyld_info -> rebase_off = r_read_ble32 ( & dyldi [ 8 ] , bin -> big_endian ) ; bin -> dyld_info -> rebase_size = r_read_ble32 ( & dyldi [ 12 ] , bin -> big_endian ) ; bin -> dyld_info -> bind_off = r_read_ble32 ( & dyldi [ 16 ] , bin -> big_endian ) ; bin -> dyld_info -> bind_size = r_read_ble32 ( & dyldi [ 20 ] , bin -> big_endian ) ; bin -> dyld_info -> weak_bind_off = r_read_ble32 ( & dyldi [ 24 ] , bin -> big_endian ) ; bin -> dyld_info -> weak_bind_size = r_read_ble32 ( & dyldi [ 28 ] , bin -> big_endian ) ; bin -> dyld_info -> lazy_bind_off = r_read_ble32 ( & dyldi [ 32 ] , bin -> big_endian ) ; bin -> dyld_info -> lazy_bind_size = r_read_ble32 ( & dyldi [ 36 ] , bin -> big_endian ) ; bin -> dyld_info -> export_off = r_read_ble32 ( & dyldi [ 40 ] , bin -> big_endian ) ; bin -> dyld_info -> export_size = r_read_ble32 ( & dyldi [ 44 ] , bin -> big_endian ) ; } } <S2SV_StartBug> break ; <S2SV_EndBug> case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""signature"" , 0 ) ; break ; case LC_SOURCE_VERSION : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version"" , 0 ) ; break ; case LC_SEGMENT_SPLIT_INFO : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""split_info"" , 0 ) ; break ; case LC_FUNCTION_STARTS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""function_starts"" , 0 ) ; if ( ! parse_function_starts ( bin , off ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>LC_FUNCTION_STARTS\\n"" ) ; } break ; case LC_REEXPORT_DYLIB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylib"" , 0 ) ; break ; default : break ; } } return true ; }
","<S2SV_ModStart> -> dyld_info = calloc ( 1 , <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> ; if ( bin -> dyld_info ) { if ( <S2SV_ModStart> ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\n"" ) ; R_FREE <S2SV_ModEnd> ( bin -> <S2SV_ModStart> ; } } }
",radare@radare2/d1e8ac62c6d978d4662f69116e30230d43033c92,CVE-2017-7946,https://github.com/radare/radare2/commit/d1e8ac62c6d978d4662f69116e30230d43033c92,2017-04-18T20:59Z,<S2SV_StartBug> bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) { <S2SV_EndBug> <S2SV_StartBug> free ( bin -> dyld_info ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug>
3506,CWE-125,"<S2SV_StartBug> INST_HANDLER ( sts ) { <S2SV_EndBug> int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; ESIL_A ( ""r%d,"" , r ) ; __generic_ld_st ( op , ""ram"" , 0 , 1 , 0 , k , 1 ) ; op -> cycles = 2 ; }
","<S2SV_ModStart> sts ) { if ( len < 4 ) { return ; }
",radare@radare2/d04c78773f6959bcb427453f8e5b9824d5ba9eff,CVE-2018-11382,https://github.com/radare/radare2/commit/d04c78773f6959bcb427453f8e5b9824d5ba9eff,2018-05-22T19:29Z,<S2SV_StartBug> INST_HANDLER ( sts ) { <S2SV_EndBug>
3364,CWE-000,"static int cypress_open ( struct tty_struct * tty , struct usb_serial_port * port ) { struct cypress_private * priv = usb_get_serial_port_data ( port ) ; struct usb_serial * serial = port -> serial ; unsigned long flags ; int result = 0 ; if ( ! priv -> comm_is_ok ) return - EIO ; usb_clear_halt ( serial -> dev , 0x81 ) ; usb_clear_halt ( serial -> dev , 0x02 ) ; spin_lock_irqsave ( & priv -> lock , flags ) ; priv -> bytes_in = 0 ; priv -> bytes_out = 0 ; priv -> cmd_count = 0 ; priv -> rx_flags = 0 ; spin_unlock_irqrestore ( & priv -> lock , flags ) ; cypress_send ( port ) ; if ( tty ) cypress_set_termios ( tty , port , & priv -> tmp_termios ) ; <S2SV_StartBug> if ( ! port -> interrupt_in_urb ) { <S2SV_EndBug> dev_err ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>interrupt_in_urb<S2SV_blank>is<S2SV_blank>empty!\\n"" , __func__ ) ; return - 1 ; } usb_fill_int_urb ( port -> interrupt_in_urb , serial -> dev , usb_rcvintpipe ( serial -> dev , port -> interrupt_in_endpointAddress ) , port -> interrupt_in_urb -> transfer_buffer , port -> interrupt_in_urb -> transfer_buffer_length , cypress_read_int_callback , port , priv -> read_urb_interval ) ; result = usb_submit_urb ( port -> interrupt_in_urb , GFP_KERNEL ) ; if ( result ) { dev_err ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>submitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\n"" , __func__ , result ) ; cypress_set_dead ( port ) ; } return result ; }
","<S2SV_ModStart> tmp_termios ) ; <S2SV_ModEnd> usb_fill_int_urb ( port
",torvalds@linux/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,CVE-2016-3137,https://github.com/torvalds/linux/commit/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,2016-05-02T10:59Z,<S2SV_StartBug> if ( ! port -> interrupt_in_urb ) { <S2SV_EndBug>
3825,CWE-20,"WORD32 ih264d_start_of_pic ( dec_struct_t * ps_dec , WORD32 i4_poc , pocstruct_t * ps_temp_poc , UWORD16 u2_frame_num , dec_pic_params_t * ps_pps ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_cur_pic_poc ; pocstruct_t * ps_cur_poc = ps_temp_poc ; pic_buffer_t * pic_buf ; ivd_video_decode_op_t * ps_dec_output = ( ivd_video_decode_op_t * ) ps_dec -> pv_dec_out ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_seq_params_t * ps_seq = ps_pps -> ps_sps ; UWORD8 u1_bottom_field_flag = ps_cur_slice -> u1_bottom_field_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; high_profile_tools_t s_high_profile ; WORD32 ret ; H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_dec -> ps_cur_slice -> u1_bottom_field_flag ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = u2_frame_num ; ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> i1_next_ctxt_idx = 0 ; ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ; if ( ps_seq -> u1_mb_aff_flag == 1 ) { ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ; } ps_dec -> u4_use_intrapred_line_copy = 0 ; if ( ps_seq -> u1_mb_aff_flag == 0 ) { ps_dec -> u4_use_intrapred_line_copy = 1 ; } ps_dec -> u4_app_disable_deblk_frm = 0 ; if ( ps_dec -> i4_degrade_type && ps_dec -> i4_degrade_pics ) { WORD32 degrade_pic ; ps_dec -> i4_degrade_pic_cnt ++ ; degrade_pic = 0 ; switch ( ps_dec -> i4_degrade_pics ) { case 4 : { degrade_pic = 1 ; break ; } case 3 : { if ( ps_cur_slice -> u1_slice_type != I_SLICE ) degrade_pic = 1 ; break ; } case 2 : { if ( ( ps_cur_slice -> u1_slice_type != I_SLICE ) && ( ps_dec -> i4_degrade_pic_cnt != ps_dec -> i4_nondegrade_interval ) ) degrade_pic = 1 ; break ; } case 1 : { if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { degrade_pic = 1 ; } break ; } } if ( degrade_pic ) { if ( ps_dec -> i4_degrade_type & 0x2 ) ps_dec -> u4_app_disable_deblk_frm = 1 ; if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { if ( ps_dec -> i4_degrade_type & 0x4 ) ps_dec -> i4_mv_frac_mask = 0 ; if ( ps_dec -> i4_degrade_type & 0x8 ) ps_dec -> i4_mv_frac_mask = 0 ; } } else ps_dec -> i4_degrade_pic_cnt = 0 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_dec -> u1_sl_typ_5_9 && ( ( ps_cur_slice -> u1_slice_type == I_SLICE ) || ( ps_cur_slice -> u1_slice_type == SI_SLICE ) ) ) ps_err -> u1_cur_pic_type = PIC_TYPE_I ; else ps_err -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; if ( ps_err -> u1_pic_aud_i == PIC_TYPE_I ) { ps_err -> u1_cur_pic_type = PIC_TYPE_I ; ps_err -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; } if ( ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { if ( ps_err -> u1_err_flag ) ih264d_reset_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } if ( ps_dec -> u1_init_dec_flag && ps_dec -> s_prev_seq_params . u1_eoseq_pending ) { WORD32 j ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> u1_second_field = 0 ; ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; } ret = ih264d_init_pic ( ps_dec , u2_frame_num , i4_poc , ps_pps ) ; if ( ret != OK ) return ret ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> ps_nmb_info = ps_dec -> ps_frm_mb_info ; if ( ps_dec -> u1_separate_parse ) { UWORD16 pic_wd ; UWORD16 pic_ht ; UWORD32 num_mbs ; pic_wd = ps_dec -> u2_pic_wd ; pic_ht = ps_dec -> u2_pic_ht ; num_mbs = ( pic_wd * pic_ht ) >> 8 ; if ( ps_dec -> pu1_dec_mb_map ) { memset ( ( void * ) ps_dec -> pu1_dec_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu1_recon_mb_map ) { memset ( ( void * ) ps_dec -> pu1_recon_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu2_slice_num_map ) { memset ( ( void * ) ps_dec -> pu2_slice_num_map , 0 , ( num_mbs * sizeof ( UWORD16 ) ) ) ; } } ps_dec -> ps_parse_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_decode_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_computebs_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> s_high_profile . u1_scaling_present = 0 ; ps_dec -> s_high_profile . u1_transform8x8_present = 0 ; if ( 1 == ps_dec -> u4_share_disp_buf ) { UWORD32 i ; for ( i = 0 ; i < MAX_DISP_BUFS_NEW ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) continue ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , i , BUF_MGR_IO ) ; ps_dec -> u4_disp_buf_to_be_freed [ i ] = 0 ; ps_dec -> u4_disp_buf_mapping [ i ] = 0 ; } } if ( ! ( u1_field_pic_flag && 0 != ps_dec -> u1_top_bottom_decoded ) ) { pic_buffer_t * ps_cur_pic ; WORD32 cur_pic_buf_id , cur_mv_buf_id ; col_mv_buf_t * ps_col_mv ; while ( 1 ) { ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } if ( 0 == ps_dec -> u4_disp_buf_mapping [ cur_pic_buf_id ] ) { break ; } } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; if ( ps_dec -> u1_first_slice_in_stream ) { ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; * ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ 0 ] ) = * ps_cur_pic ; } if ( ! ps_dec -> ps_cur_pic ) { WORD32 j ; H264_DEC_DEBUG_PRINT ( ""-------<S2SV_blank>Display<S2SV_blank>Buffers<S2SV_blank>Reset<S2SV_blank>--------\\n"" ) ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> i4_max_poc = 0 ; ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_dec -> apv_buf_id_pic_buf_map [ cur_pic_buf_id ] = ( void * ) ps_cur_pic ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; } ps_dec -> ps_cur_pic -> u1_picturetype = u1_field_pic_flag ; ps_dec -> ps_cur_pic -> u4_pack_slc_typ = SKIP_NONE ; H264_DEC_DEBUG_PRINT ( ""got<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } else { H264_DEC_DEBUG_PRINT ( ""did<S2SV_blank>not<S2SV_blank>get<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } ps_dec -> u4_pic_buf_got = 1 ; ps_dec -> ps_cur_pic -> i4_poc = i4_poc ; ps_dec -> ps_cur_pic -> i4_frame_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_pic_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = ps_pps -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = ps_pps -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_avg_poc = ps_pps -> i4_avg_poc ; ps_dec -> ps_cur_pic -> u4_time_stamp = ps_dec -> u4_pts ; ps_dec -> s_cur_pic = * ( ps_dec -> ps_cur_pic ) ; if ( u1_field_pic_flag && u1_bottom_field_flag ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; ps_dec -> s_cur_pic . pu1_buf1 += ps_dec -> s_cur_pic . u2_frm_wd_y ; ps_dec -> s_cur_pic . pu1_buf2 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . pu1_buf3 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . ps_mv += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> s_cur_pic . pu1_col_zero_flag += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= BOT_FLD ; i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= ( ps_cur_slice -> u1_mbaff_frame_flag << 2 ) ; ps_dec -> ps_cur_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_cur_mb_row += 2 ; ps_dec -> ps_top_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_top_mb_row += ( ( ps_dec -> u2_frm_wd_in_mbs + 2 ) << ( 1 - ps_dec -> ps_cur_sps -> u1_frame_mbs_only_flag ) ) ; ps_dec -> ps_top_mb_row += 2 ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_top = ps_dec -> ps_mv_top_p [ 0 ] ; ps_dec -> u1_mv_top_p = 0 ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> ps_mv_left = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> i4_submb_ofst = - ( SUB_BLK_SIZE ) ; ps_dec -> u4_pred_info_idx = 0 ; ps_dec -> u4_pred_info_pkd_idx = 0 ; ps_dec -> u4_dma_buf_idx = 0 ; ps_dec -> ps_mv = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_bank_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> pu1_col_zero_flag = ps_dec -> s_cur_pic . pu1_col_zero_flag ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> i2_prev_slice_mbx = - 1 ; ps_dec -> i2_prev_slice_mby = 0 ; ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> u2_cur_slice_num_dec_thread = 0 ; ps_dec -> u2_cur_slice_num_bs = 0 ; ps_dec -> u4_intra_pred_line_ofst = 0 ; ps_dec -> pu1_cur_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_cur_y_intra_pred_line_base = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line_base = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line_base = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_prev_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line + ( ps_dec -> u2_frm_wd_in_mbs * MB_SIZE ) ; ps_dec -> pu1_prev_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR ; ps_dec -> pu1_prev_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; { if ( ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_compute_bs = ih264d_compute_bs_mbaff ; ps_dec -> pf_mvpred = ih264d_mvpred_mbaff ; } else { ps_dec -> pf_compute_bs = ih264d_compute_bs_non_mbaff ; ps_dec -> u1_cur_mb_fld_dec_flag = ps_cur_slice -> u1_field_pic_flag ; } } { UWORD8 u1_field_pic_flag = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; UWORD8 u1_mbaff = ps_cur_slice -> u1_mbaff_frame_flag ; UWORD8 uc_lastmbs = ( ( ( ps_dec -> u2_pic_wd ) >> 4 ) % ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) ) ; UWORD16 ui16_lastmbs_widthY = ( uc_lastmbs ? ( uc_lastmbs << 4 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 4 ) ) ; UWORD16 ui16_lastmbs_widthUV = uc_lastmbs ? ( uc_lastmbs << 3 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 3 ) ; ps_dec -> s_tran_addrecon . pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_dec -> s_tran_addrecon . pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_dec -> s_tran_addrecon . pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_dec -> s_tran_addrecon . u2_frm_wd_y = ps_dec -> u2_frm_wd_y << u1_field_pic_flag ; ps_dec -> s_tran_addrecon . u2_frm_wd_uv = ps_dec -> u2_frm_wd_uv << u1_field_pic_flag ; if ( u1_field_pic_flag ) { ui16_lastmbs_widthY += ps_dec -> u2_frm_wd_y ; ui16_lastmbs_widthUV += ps_dec -> u2_frm_wd_uv ; } ps_dec -> s_tran_addrecon . u4_inc_y [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_y [ 1 ] = ( ui16_lastmbs_widthY + ( PAD_LEN_Y_H << 1 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_y * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 1 ] = ( ui16_lastmbs_widthUV + ( PAD_LEN_UV_H << 2 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_uv * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ih264d_assign_pic_num ( ps_dec ) ; ps_dec -> s_tran_addrecon . u2_mv_top_left_inc = ( ps_dec -> u1_recon_mb_grp << 2 ) - 1 - ( u1_mbaff << 2 ) ; ps_dec -> s_tran_addrecon . u2_mv_left_inc = ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) - 1 ) << ( 4 + u1_mbaff ) ; } if ( ps_seq -> u1_profile_idc == HIGH_PROFILE_IDC ) { if ( ( ps_seq -> i4_seq_scaling_matrix_present_flag ) || ( ps_pps -> i4_pic_scaling_matrix_present_flag ) ) { ih264d_form_scaling_matrix_picture ( ps_seq , ps_pps , ps_dec ) ; ps_dec -> s_high_profile . u1_scaling_present = 1 ; } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } if ( ps_pps -> i4_transform_8x8_mode_flag ) { ps_dec -> s_high_profile . u1_transform8x8_present = 1 ; } } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } ps_dec -> s_high_profile . u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; ps_dec -> s_high_profile . s_cavlc_ctxt = ps_dec -> s_cavlc_ctxt ; ps_dec -> i1_recon_in_thread3_flag = 1 ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_addrecon ; if ( ps_dec -> u1_separate_parse ) { memcpy ( & ps_dec -> s_tran_addrecon_parse , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; if ( ps_dec -> u4_num_cores >= 3 && ps_dec -> i1_recon_in_thread3_flag ) { memcpy ( & ps_dec -> s_tran_iprecon , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_iprecon ; } } ih264d_init_deblk_tfr_ctxt ( ps_dec , & ( ps_dec -> s_pad_mgr ) , & ( ps_dec -> s_tran_addrecon ) , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; ps_dec -> ps_cur_deblk_mb = ps_dec -> ps_deblk_pic ; ps_dec -> u4_cur_deblk_mb_num = 0 ; ps_dec -> u4_deblk_mb_x = 0 ; ps_dec -> u4_deblk_mb_y = 0 ; <S2SV_StartBug> H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; <S2SV_EndBug> return OK ; }
","<S2SV_ModStart> = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ;
",external@libavc/e629194c62a9a129ce378e08cb1059a8a53f1795,CVE-2016-3741,https://android.googlesource.com/platform/external/libavc/+/e629194c62a9a129ce378e08cb1059a8a53f1795,2016-07-11T01:59Z,<S2SV_StartBug> H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; <S2SV_EndBug>
1247,CWE-119,"<S2SV_StartBug> static inline bool unconditional ( const struct arpt_arp * arp ) <S2SV_EndBug> { static const struct arpt_arp uncond ; <S2SV_StartBug> return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> ( const struct arpt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> <S2SV_ModEnd> arp , &
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z,"<S2SV_StartBug> static inline bool unconditional ( const struct arpt_arp * arp ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug>"
2847,CWE-190,"void * jas_malloc ( size_t size ) { void * result ; <S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_malloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%zu\\n"" , size ) ) ; <S2SV_EndBug> result = malloc ( size ) ; JAS_DBGLOG ( 100 , ( ""jas_malloc(%zu)<S2SV_blank>-><S2SV_blank>%p\\n"" , size , result ) ) ; return result ; }
","<S2SV_ModStart> 101 , ( ""jas_malloc(%zu)\\n"" <S2SV_ModEnd> , size )
",mdadams@jasper/988f8365f7d8ad8073b6786e433d34c553ecf568,CVE-2016-10249,https://github.com/mdadams/jasper/commit/988f8365f7d8ad8073b6786e433d34c553ecf568,2017-03-15T14:59Z,"<S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_malloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%zu\\n"" , size ) ) ; <S2SV_EndBug>"
1655,CWE-119,"<S2SV_StartBug> static void update_coef_probs_common ( vp9_writer * const bc , VP9_COMP * cpi , <S2SV_EndBug> TX_SIZE tx_size , <S2SV_StartBug> vp9_coeff_stats * frame_branch_ct ) { <S2SV_EndBug> vp9_coeff_probs_model * new_frame_coef_probs = cpi -> frame_coef_probs [ tx_size ] ; vp9_coeff_probs_model * old_frame_coef_probs = <S2SV_StartBug> cpi -> common . fc . coef_probs [ tx_size ] ; <S2SV_EndBug> const vp9_prob upd = DIFF_UPDATE_PROB ; const int entropy_nodes_update = UNCONSTRAINED_NODES ; int i , j , k , l , t ; switch ( cpi -> sf . use_fast_coef_updates ) { case TWO_LOOP : { int savings = 0 ; int update [ 2 ] = { 0 , 0 } ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> int s ; int u = 0 ; if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , oldp , & newp , upd ) ; if ( s > 0 && newp != oldp ) u = 1 ; if ( u ) savings += s - ( int ) ( vp9_cost_zero ( upd ) ) ; else savings -= ( int ) ( vp9_cost_zero ( upd ) ) ; update [ u ] ++ ; } } } } } if ( update [ 1 ] == 0 || savings < 0 ) { <S2SV_StartBug> vp9_write_bit ( bc , 0 ) ; <S2SV_EndBug> return ; } <S2SV_StartBug> vp9_write_bit ( bc , 1 ) ; <S2SV_EndBug> for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ; <S2SV_StartBug> const vp9_prob upd = DIFF_UPDATE_PROB ; <S2SV_EndBug> int s ; int u = 0 ; if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ; if ( s > 0 && newp != * oldp ) u = 1 ; <S2SV_StartBug> vp9_write ( bc , u , upd ) ; <S2SV_EndBug> if ( u ) { vp9_write_prob_diff_update ( bc , newp , * oldp ) ; * oldp = newp ; } } } } } } return ; } <S2SV_StartBug> case ONE_LOOP : <S2SV_EndBug> case ONE_LOOP_REDUCED : { <S2SV_StartBug> const int prev_coef_contexts_to_update = <S2SV_EndBug> cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEFF_CONTEXTS >> 1 : COEFF_CONTEXTS ; const int coef_band_to_update = cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEF_BANDS >> 1 : COEF_BANDS ; int updates = 0 ; int noupdates_before_first = 0 ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ; int s ; int u = 0 ; <S2SV_StartBug> if ( l >= prev_coef_contexts_to_update || <S2SV_EndBug> k >= coef_band_to_update ) { u = 0 ; } else { <S2SV_StartBug> if ( t == PIVOT_NODE ) <S2SV_EndBug> s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ; <S2SV_StartBug> if ( s > 0 && newp != * oldp ) <S2SV_EndBug> u = 1 ; <S2SV_StartBug> } <S2SV_EndBug> updates += u ; if ( u == 0 && updates == 0 ) { noupdates_before_first ++ ; continue ; } if ( u == 1 && updates == 1 ) { int v ; <S2SV_StartBug> vp9_write_bit ( bc , 1 ) ; <S2SV_EndBug> for ( v = 0 ; v < noupdates_before_first ; ++ v ) <S2SV_StartBug> vp9_write ( bc , 0 , upd ) ; <S2SV_EndBug> } <S2SV_StartBug> vp9_write ( bc , u , upd ) ; <S2SV_EndBug> if ( u ) { vp9_write_prob_diff_update ( bc , newp , * oldp ) ; * oldp = newp ; } } } } } } if ( updates == 0 ) { <S2SV_StartBug> vp9_write_bit ( bc , 0 ) ; <S2SV_EndBug> } return ; } default : assert ( 0 ) ; } }
","<S2SV_ModStart> void update_coef_probs_common ( vpx_writer <S2SV_ModEnd> * const bc <S2SV_ModStart> vp9_coeff_stats * frame_branch_ct , vp9_coeff_probs_model * new_coef_probs ) { vp9_coeff_probs_model * old_coef_probs = <S2SV_ModEnd> cpi -> common <S2SV_ModStart> common . fc -> coef_probs [ tx_size ] ; const vpx_prob upd = DIFF_UPDATE_PROB ; const int entropy_nodes_update = UNCONSTRAINED_NODES ; int i , j , k , l , t ; int stepsize = cpi -> sf . coeff_prob_appx_step <S2SV_ModEnd> ; switch ( <S2SV_ModStart> t ) { vpx_prob newp = new_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> ] ; const vpx_prob oldp = old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> 0 ] , old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> newp , upd , stepsize <S2SV_ModStart> 0 ) { vpx_write_bit <S2SV_ModEnd> ( bc , <S2SV_ModStart> return ; } vpx_write_bit <S2SV_ModEnd> ( bc , <S2SV_ModStart> t ) { vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> t ; const vpx_prob <S2SV_ModEnd> upd = DIFF_UPDATE_PROB <S2SV_ModStart> 0 ] , old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> newp , upd , stepsize <S2SV_ModStart> = 1 ; vpx_write <S2SV_ModEnd> ( bc , <S2SV_ModStart> return ; } <S2SV_ModEnd> case ONE_LOOP_REDUCED : <S2SV_ModStart> ONE_LOOP_REDUCED : { int updates = 0 ; int noupdates_before_first = 0 ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS <S2SV_ModEnd> ; ++ k <S2SV_ModStart> t ) { vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( t <S2SV_ModStart> == PIVOT_NODE ) { <S2SV_ModStart> 0 ] , old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> newp , upd , stepsize ) ; } else { <S2SV_ModEnd> s = vp9_prob_diff_update_savings_search <S2SV_ModStart> upd ) ; } <S2SV_ModStart> = 1 ; <S2SV_ModEnd> updates += u <S2SV_ModStart> int v ; vpx_write_bit <S2SV_ModEnd> ( bc , <S2SV_ModStart> ++ v ) vpx_write <S2SV_ModEnd> ( bc , <S2SV_ModStart> ) ; } vpx_write <S2SV_ModEnd> ( bc , <S2SV_ModStart> 0 ) { vpx_write_bit <S2SV_ModEnd> ( bc ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void update_coef_probs_common ( vp9_writer * const bc , VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> vp9_coeff_stats * frame_branch_ct ) { <S2SV_EndBug> <S2SV_StartBug> cpi -> common . fc . coef_probs [ tx_size ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob upd = DIFF_UPDATE_PROB ; <S2SV_EndBug> <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( bc , u , upd ) ; <S2SV_EndBug> <S2SV_StartBug> case ONE_LOOP : <S2SV_EndBug> <S2SV_StartBug> const int prev_coef_contexts_to_update = <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> if ( l >= prev_coef_contexts_to_update || <S2SV_EndBug> <S2SV_StartBug> if ( t == PIVOT_NODE ) <S2SV_EndBug> <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> <S2SV_StartBug> if ( s > 0 && newp != * oldp ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( bc , 0 , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( bc , u , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 0 ) ; <S2SV_EndBug>"
1401,CWE-119,"int vp8dx_get_raw_frame ( VP8D_COMP * pbi , YV12_BUFFER_CONFIG * sd , int64_t * time_stamp , int64_t * time_end_stamp , vp8_ppflags_t * flags ) { int ret = - 1 ; if ( pbi -> ready_for_new_data == 1 ) return ret ; if ( pbi -> common . show_frame == 0 ) return ret ; pbi -> ready_for_new_data = 1 ; * time_stamp = pbi -> last_time_stamp ; * time_end_stamp = 0 ; # if CONFIG_POSTPROC ret = vp8_post_proc_frame ( & pbi -> common , sd , flags ) ; # else <S2SV_StartBug> if ( pbi -> common . frame_to_show ) <S2SV_EndBug> { * sd = * pbi -> common . frame_to_show ; sd -> y_width = pbi -> common . Width ; sd -> y_height = pbi -> common . Height ; sd -> uv_height = pbi -> common . Height / 2 ; ret = 0 ; } else { ret = - 1 ; } # endif vp8_clear_system_state ( ) ; return ret ; }
","<S2SV_ModStart> ; # else ( void ) flags ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> if ( pbi -> common . frame_to_show ) <S2SV_EndBug>
3103,CWE-295,"static krb5_error_code tgs_build_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ * req , KDC_REQ_BODY * b , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , const krb5_keyblock * replykey , int rk_is_subkey , krb5_ticket * ticket , krb5_data * reply , const char * from , const char * * e_text , AuthorizationData * * auth_data , const struct sockaddr * from_addr ) { krb5_error_code ret ; krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; krb5_principal krbtgt_out_principal = NULL ; char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; HDB * clientdb , * s4u2self_impersonated_clientdb ; krb5_realm ref_realm = NULL ; EncTicketPart * tgt = & ticket -> ticket ; krb5_principals spp = NULL ; const EncryptionKey * ekey ; krb5_keyblock sessionkey ; krb5_kvno kvno ; <S2SV_StartBug> krb5_data rspac ; <S2SV_EndBug> const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; char * * capath = NULL ; size_t num_capath = 0 ; hdb_entry_ex * krbtgt_out = NULL ; METHOD_DATA enc_pa_data ; PrincipalName * s ; Realm r ; EncTicketPart adtkt ; char opt_str [ 128 ] ; int signedpath = 0 ; Key * tkey_check ; Key * tkey_sign ; int flags = HDB_F_FOR_TGS_REQ ; memset ( & sessionkey , 0 , sizeof ( sessionkey ) ) ; memset ( & adtkt , 0 , sizeof ( adtkt ) ) ; krb5_data_zero ( & rspac ) ; memset ( & enc_pa_data , 0 , sizeof ( enc_pa_data ) ) ; s = b -> sname ; r = b -> realm ; flags |= HDB_F_CANON ; if ( b -> kdc_options . enc_tkt_in_skey ) { Ticket * t ; hdb_entry_ex * uu ; krb5_principal p ; Key * uukey ; krb5uint32 second_kvno = 0 ; krb5uint32 * kvno_ptr = NULL ; if ( b -> additional_tickets == NULL || b -> additional_tickets -> len == 0 ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""No<S2SV_blank>second<S2SV_blank>ticket<S2SV_blank>present<S2SV_blank>in<S2SV_blank>request"" ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; if ( ! get_krbtgt_realm ( & t -> sname ) ) { kdc_log ( context , config , 0 , ""Additional<S2SV_blank>ticket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>ticket-granting<S2SV_blank>ticket"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } _krb5_principalname2krb5_principal ( context , & p , t -> sname , t -> realm ) ; if ( t -> enc_part . kvno ) { second_kvno = * t -> enc_part . kvno ; kvno_ptr = & second_kvno ; } ret = _kdc_db_fetch ( context , config , p , HDB_F_GET_KRBTGT , kvno_ptr , NULL , & uu ) ; krb5_free_principal ( context , p ) ; if ( ret ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } ret = hdb_enctype2key ( context , & uu -> entry , NULL , t -> enc_part . etype , & uukey ) ; if ( ret ) { _kdc_free_ent ( context , uu ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & uukey -> key , & adtkt , 0 ) ; _kdc_free_ent ( context , uu ) ; if ( ret ) goto out ; ret = verify_flags ( context , config , & adtkt , spn ) ; if ( ret ) goto out ; s = & adtkt . cname ; r = adtkt . crealm ; } _krb5_principalname2krb5_principal ( context , & sp , * s , r ) ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; _krb5_principalname2krb5_principal ( context , & cp , tgt -> cname , tgt -> crealm ) ; ret = krb5_unparse_name ( context , cp , & cpn ) ; if ( ret ) goto out ; unparse_flags ( KDCOptions2int ( b -> kdc_options ) , asn1_KDCOptions_units ( ) , opt_str , sizeof ( opt_str ) ) ; if ( * opt_str ) kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>[%s]"" , cpn , from , spn , opt_str ) ; else kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , cpn , from , spn ) ; server_lookup : ret = _kdc_db_fetch ( context , config , sp , HDB_F_GET_SERVER | flags , NULL , NULL , & server ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , sp ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { free ( ref_realm ) ; ref_realm = strdup ( server -> entry . principal -> realm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s."" , ref_realm , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; ret = krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; if ( ret ) goto out ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } else if ( ret ) { const char * new_rlm , * msg ; Realm req_rlm ; krb5_realm * realms ; if ( ( req_rlm = get_krbtgt_realm ( & sp -> name ) ) != NULL ) { if ( capath == NULL ) { ret = _krb5_find_capath ( context , tgt -> crealm , our_realm , req_rlm , TRUE , & capath , & num_capath ) ; if ( ret ) goto out ; } new_rlm = num_capath > 0 ? capath [ -- num_capath ] : NULL ; if ( new_rlm ) { kdc_log ( context , config , 5 , ""krbtgt<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""realm<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>trying<S2SV_blank>%s"" , tgt -> crealm , our_realm , req_rlm , new_rlm ) ; free ( ref_realm ) ; ref_realm = strdup ( new_rlm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } } else if ( need_referral ( context , config , & b -> kdc_options , sp , & realms ) ) { if ( strcmp ( realms [ 0 ] , sp -> realm ) != 0 ) { kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s<S2SV_blank>that<S2SV_blank>was<S2SV_blank>not<S2SV_blank>found"" , realms [ 0 ] , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , realms [ 0 ] , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) { krb5_free_host_realm ( context , realms ) ; goto out ; } free ( ref_realm ) ; ref_realm = strdup ( realms [ 0 ] ) ; krb5_free_host_realm ( context , realms ) ; goto server_lookup ; } krb5_free_host_realm ( context , realms ) ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Server<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s:<S2SV_blank>%s"" , spn , msg ) ; krb5_free_error_message ( context , msg ) ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } if ( b -> kdc_options . canonicalize ) rsp = server -> entry . principal ; else rsp = sp ; { krb5_enctype etype ; if ( b -> kdc_options . enc_tkt_in_skey ) { size_t i ; ekey = & adtkt . key ; for ( i = 0 ; i < b -> etype . len ; i ++ ) if ( b -> etype . val [ i ] == adtkt . key . keytype ) break ; if ( i == b -> etype . len ) { kdc_log ( context , config , 0 , ""Addition<S2SV_blank>ticket<S2SV_blank>have<S2SV_blank>not<S2SV_blank>matching<S2SV_blank>etypes"" ) ; krb5_clear_error_message ( context ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } etype = b -> etype . val [ i ] ; kvno = 0 ; } else { Key * skey ; ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , sp ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , server , b -> etype . val , b -> etype . len , & etype , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>support<S2SV_blank>for<S2SV_blank>etypes"" , spn ) ; goto out ; } ret = _kdc_get_preferred_key ( context , config , server , spn , NULL , & skey ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>supported<S2SV_blank>etypes"" , spn ) ; goto out ; } ekey = & skey -> key ; kvno = server -> entry . kvno ; } ret = krb5_generate_random_keyblock ( context , etype , & sessionkey ) ; if ( ret ) goto out ; } ret = hdb_enctype2key ( context , & krbtgt -> entry , NULL , krbtgt_etype , & tkey_check ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>check"" ) ; goto out ; } ret = krb5_make_principal ( context , & krbtgt_out_principal , our_realm , KRB5_TGS_NAME , our_realm , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = krb5_unparse_name ( context , krbtgt_out_principal , & krbtgt_out_n ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , krbtgt_out_principal , HDB_F_GET_KRBTGT , NULL , NULL , & krbtgt_out ) ; if ( ret ) { char * ktpn = NULL ; ret = krb5_unparse_name ( context , krbtgt -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""No<S2SV_blank>such<S2SV_blank>principal<S2SV_blank>%s<S2SV_blank>(needed<S2SV_blank>for<S2SV_blank>authz-data<S2SV_blank>signature<S2SV_blank>keys)<S2SV_blank>"" ""while<S2SV_blank>processing<S2SV_blank>TGS-REQ<S2SV_blank>for<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>krbtg<S2SV_blank>%s"" , krbtgt_out_n , spn , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } if ( strcmp ( krb5_principal_get_realm ( context , server -> entry . principal ) , krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ) != 0 ) { char * ktpn ; ret = krb5_unparse_name ( context , krbtgt_out -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>with<S2SV_blank>wrong<S2SV_blank>krbtgt:<S2SV_blank>%s"" , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; if ( ret == 0 ) free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } ret = _kdc_get_preferred_key ( context , config , krbtgt_out , krbtgt_out_n , NULL , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = hdb_enctype2key ( context , & krbtgt_out -> entry , NULL , tkey_sign -> key . keytype , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , cp , HDB_F_GET_CLIENT | flags , NULL , & clientdb , & client ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { } else if ( ret ) { const char * krbtgt_realm , * msg ; krbtgt_realm = krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ; if ( strcmp ( krb5_principal_get_realm ( context , cp ) , krbtgt_realm ) == 0 ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , cpn ) ; goto out ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; } ret = check_PAC ( context , config , cp , NULL , client , server , krbtgt , & tkey_check -> key , ekey , & tkey_sign -> key , tgt , & rspac , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , tgt , & spp , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } tp = cp ; tpn = cpn ; if ( client ) { const PA_DATA * sdata ; int i = 0 ; sdata = _kdc_find_padata ( req , & i , KRB5_PADATA_FOR_USER ) ; if ( sdata ) { krb5_crypto crypto ; krb5_data datack ; PA_S4U2Self self ; const char * str ; ret = decode_PA_S4U2Self ( sdata -> padata_value . data , sdata -> padata_value . length , & self , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PA-S4U2Self"" ) ; goto out ; } ret = _krb5_s4u2self_to_checksumdata ( context , & self , & datack ) ; if ( ret ) goto out ; ret = krb5_crypto_init ( context , & tgt -> key , 0 , & crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; krb5_data_free ( & datack ) ; kdc_log ( context , config , 0 , ""krb5_crypto_init<S2SV_blank>failed:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = krb5_verify_checksum ( context , crypto , KRB5_KU_OTHER_CKSUM , datack . data , datack . length , & self . cksum ) ; krb5_data_free ( & datack ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; kdc_log ( context , config , 0 , ""krb5_verify_checksum<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>S4U2Self:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , self . name , self . realm ) ; free_PA_S4U2Self ( & self ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; if ( rspac . data ) { krb5_pac p = NULL ; krb5_data_free ( & rspac ) ; ret = _kdc_db_fetch ( context , config , tp , HDB_F_GET_CLIENT | flags , NULL , & s4u2self_impersonated_clientdb , & s4u2self_impersonated_client ) ; if ( ret ) { const char * msg ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""S2U4Self<S2SV_blank>principal<S2SV_blank>to<S2SV_blank>impersonate<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , tpn , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _kdc_pac_generate ( context , s4u2self_impersonated_client , & p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>generation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } if ( p != NULL ) { ret = _krb5_pac_sign ( context , p , ticket -> ticket . authtime , s4u2self_impersonated_client -> entry . principal , ekey , & tkey_sign -> key , & rspac ) ; krb5_pac_free ( context , p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>signing<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } } } ret = check_s4u2self ( context , config , clientdb , client , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""S4U2Self:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>"" ""to<S2SV_blank>impersonate<S2SV_blank>to<S2SV_blank>service<S2SV_blank>"" ""(tried<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>service<S2SV_blank>%s)"" , cpn , tpn , spn ) ; goto out ; } if ( client -> entry . flags . trusted_for_delegation ) { str = ""[forwardable]"" ; } else { b -> kdc_options . forwardable = 0 ; str = """" ; } kdc_log ( context , config , 0 , ""s4u2self<S2SV_blank>%s<S2SV_blank>impersonating<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>"" ""service<S2SV_blank>%s<S2SV_blank>%s"" , cpn , tpn , spn , str ) ; } } if ( client != NULL && b -> additional_tickets != NULL && b -> additional_tickets -> len != 0 && b -> kdc_options . enc_tkt_in_skey == 0 ) { int ad_signedpath = 0 ; Key * clientkey ; Ticket * t ; if ( ! signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Constrained<S2SV_blank>delegation<S2SV_blank>done<S2SV_blank>on<S2SV_blank>service<S2SV_blank>ticket<S2SV_blank>%s/%s"" , cpn , spn ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; ret = hdb_enctype2key ( context , & client -> entry , hdb_kvno2keys ( context , & client -> entry , t -> enc_part . kvno ? * t -> enc_part . kvno : 0 ) , t -> enc_part . etype , & clientkey ) ; if ( ret ) { ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & clientkey -> key , & adtkt , 0 ) ; if ( ret ) { kdc_log ( context , config , 0 , ""failed<S2SV_blank>to<S2SV_blank>decrypt<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , spn ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , adtkt . cname , adtkt . crealm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; ret = _krb5_principalname2krb5_principal ( context , & dp , t -> sname , t -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , dp , & dpn ) ; if ( ret ) goto out ; if ( adtkt . flags . forwardable == 0 ) { kdc_log ( context , config , 0 , ""Missing<S2SV_blank>forwardable<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , dpn , tpn , spn ) ; ret = KRB5KDC_ERR_BADOPTION ; goto out ; } ret = check_constrained_delegation ( context , config , clientdb , client , server , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>allowed"" , cpn , dpn , tpn , spn ) ; goto out ; } ret = verify_flags ( context , config , & adtkt , tpn ) ; if ( ret ) { goto out ; } krb5_data_free ( & rspac ) ; ret = check_PAC ( context , config , tp , dp , client , server , krbtgt , & clientkey -> key , ekey , & tkey_sign -> key , & adtkt , & rspac , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>delegated<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client"" ""%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , dpn , tpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , & adtkt , NULL , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>from<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } if ( ! ad_signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Ticket<S2SV_blank>not<S2SV_blank>signed<S2SV_blank>with<S2SV_blank>PAC<S2SV_blank>nor<S2SV_blank>SignedPath<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from ) ; goto out ; } kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>"" ""from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s"" , tpn , cpn , dpn , spn ) ; } ret = kdc_check_flags ( context , config , client , cpn , server , spn , FALSE ) ; if ( ret ) goto out ; if ( ( b -> kdc_options . validate || b -> kdc_options . renew ) && ! krb5_principal_compare ( context , krbtgt -> entry . principal , server -> entry . principal ) ) { kdc_log ( context , config , 0 , ""Inconsistent<S2SV_blank>request."" ) ; ret = KRB5KDC_ERR_SERVER_NOMATCH ; goto out ; } if ( ! _kdc_check_addresses ( context , config , tgt -> caddr , from_addr ) ) { ret = KRB5KRB_AP_ERR_BADADDR ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>from<S2SV_blank>wrong<S2SV_blank>address"" ) ; goto out ; } if ( ref_realm ) { PA_DATA pa ; krb5_crypto crypto ; kdc_log ( context , config , 0 , ""Adding<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>%s"" , ref_realm ) ; ret = krb5_crypto_init ( context , & sessionkey , 0 , & crypto ) ; if ( ret ) goto out ; ret = build_server_referral ( context , config , crypto , ref_realm , NULL , s , & pa . padata_value ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>building<S2SV_blank>server<S2SV_blank>referral"" ) ; goto out ; } pa . padata_type = KRB5_PADATA_SERVER_REFERRAL ; ret = add_METHOD_DATA ( & enc_pa_data , & pa ) ; krb5_data_free ( & pa . padata_value ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Add<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>METHOD-DATA<S2SV_blank>failed"" ) ; goto out ; } } ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp , <S2SV_StartBug> krbtgt_out , <S2SV_EndBug> tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ; out : if ( tpn != cpn ) free ( tpn ) ; free ( spn ) ; free ( cpn ) ; free ( dpn ) ; free ( krbtgt_out_n ) ; _krb5_free_capath ( context , capath ) ; krb5_data_free ( & rspac ) ; krb5_free_keyblock_contents ( context , & sessionkey ) ; if ( krbtgt_out ) _kdc_free_ent ( context , krbtgt_out ) ; if ( server ) _kdc_free_ent ( context , server ) ; if ( client ) _kdc_free_ent ( context , client ) ; if ( s4u2self_impersonated_client ) _kdc_free_ent ( context , s4u2self_impersonated_client ) ; if ( tp && tp != cp ) krb5_free_principal ( context , tp ) ; krb5_free_principal ( context , cp ) ; krb5_free_principal ( context , dp ) ; krb5_free_principal ( context , sp ) ; krb5_free_principal ( context , krbtgt_out_principal ) ; free ( ref_realm ) ; free_METHOD_DATA ( & enc_pa_data ) ; free_EncTicketPart ( & adtkt ) ; return ret ; }
","<S2SV_ModStart> ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> , cp , tgt_realm ,
",heimdal@heimdal/b1e699103f08d6a0ca46a122193c9da65f6cf837,CVE-2017-6594,https://github.com/heimdal/heimdal/commit/b1e699103f08d6a0ca46a122193c9da65f6cf837,2017-08-28T19:29Z,"<S2SV_StartBug> krb5_data rspac ; <S2SV_EndBug> <S2SV_StartBug> krbtgt_out , <S2SV_EndBug>"
997,CWE-284,"static int skt_write ( int fd , const void * p , size_t len ) { int sent ; struct pollfd pfd ; FNLOG ( ) ; pfd . fd = fd ; pfd . events = POLLOUT ; <S2SV_StartBug> if ( poll ( & pfd , 1 , 500 ) == 0 ) <S2SV_EndBug> return 0 ; ts_log ( ""skt_write"" , len , NULL ) ; <S2SV_StartBug> if ( ( sent = send ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 ) <S2SV_EndBug> { ERROR ( ""write<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>errno=%d\\n"" , errno ) ; return - 1 ; } return sent ; }
","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1 , 500 ) <S2SV_ModStart> ( sent = TEMP_FAILURE_RETRY ( <S2SV_ModStart> len , MSG_NOSIGNAL )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> if ( poll ( & pfd , 1 , 500 ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( sent = send ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 ) <S2SV_EndBug>"
3551,CWE-125,"static RList * r_bin_wasm_get_global_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmGlobalEntry * ptr = NULL ; <S2SV_StartBug> int buflen = bin -> buf -> length ; <S2SV_EndBug> if ( sec -> payload_data + 32 > buflen ) { return NULL ; } if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; ut32 len = sec -> payload_len ; ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; while ( i < len && len < buflen && r < count ) { if ( ! ( ptr = R_NEW0 ( RBinWasmGlobalEntry ) ) ) { return ret ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , ( ut8 * ) & ptr -> content_type , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , & ptr -> mutability , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { goto beach ; } r_list_append ( ret , ptr ) ; r ++ ; } return ret ; beach : free ( ptr ) ; return ret ; }
","<S2SV_ModStart> = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_ModStart> buf -> length - <S2SV_ModEnd> ( ut32 )
",radare@radare2/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,CVE-2017-7854,https://github.com/radare/radare2/commit/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,2017-04-13T16:59Z,<S2SV_StartBug> int buflen = bin -> buf -> length ; <S2SV_EndBug>
5090,CWE-787,"size_t OpenMP4Source ( char * filename , uint32_t traktype , uint32_t traksubtype ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == NULL ) return 0 ; <S2SV_StartBug> memset ( mp4 , 0 , sizeof ( mp4object ) ) ; <S2SV_EndBug> # ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ; # else mp4 -> mediafp = fopen ( filename , ""rb"" ) ; # endif if ( mp4 -> mediafp ) { uint32_t qttag , qtsize32 , skip , type = 0 , subtype = 0 , num ; size_t len ; int32_t nest = 0 ; uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; <S2SV_StartBug> if ( len == 8 ) <S2SV_EndBug> { if ( ! VALID_FOURCC ( qttag ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( lastsize - 8 ) ; continue ; } qtsize32 = BYTESWAP32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { <S2SV_StartBug> fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; <S2SV_EndBug> qtsize = BYTESWAP64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= MAX_NEST_LEVEL ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; # if PRINT_MP4_STRUCTURE for ( int i = 1 ; i < nest ; i ++ ) printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; printf ( ""%c%c%c%c<S2SV_blank>(%lld)\\n"" , ( qttag & 0xff ) , ( ( qttag >> 8 ) & 0xff ) , ( ( qttag >> 16 ) & 0xff ) , ( ( qttag >> 24 ) & 0xff ) , qtsize ) ; if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) || <S2SV_StartBug> qttag == MAKEID ( 'u' , 'd' , 't' , 'a' ) ) <S2SV_EndBug> { <S2SV_StartBug> LONGSEEK ( mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; continue ; } # else if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'm' , 'v' , 'h' , 'd' ) && qttag != MAKEID ( 't' , 'r' , 'a' , 'k' ) && qttag != MAKEID ( 'm' , 'd' , 'i' , 'a' ) && qttag != MAKEID ( 'm' , 'd' , 'h' , 'd' ) && qttag != MAKEID ( 'm' , 'i' , 'n' , 'f' ) && qttag != MAKEID ( 'g' , 'm' , 'i' , 'n' ) && qttag != MAKEID ( 'd' , 'i' , 'n' , 'f' ) && qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && qttag != MAKEID ( 's' , 't' , 's' , 'd' ) && <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'b' , 'l' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 't' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'c' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'z' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'c' , 'o' ) && <S2SV_EndBug> qttag != MAKEID ( 'c' , 'o' , '6' , '4' ) && qttag != MAKEID ( 'h' , 'd' , 'l' , 'r' ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else # endif if ( qttag == MAKEID ( 'm' , 'v' , 'h' , 'd' ) ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & mp4 -> clockdemon , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockdemon = BYTESWAP32 ( mp4 -> clockdemon ) ; len += fread ( & mp4 -> clockcount , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockcount = BYTESWAP32 ( mp4 -> clockcount ) ; <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'm' , 'd' , 'h' , 'd' ) ) { media_header md ; len = fread ( & md , 1 , sizeof ( md ) , mp4 -> mediafp ) ; if ( len == sizeof ( md ) ) { md . creation_time = BYTESWAP32 ( md . creation_time ) ; md . modification_time = BYTESWAP32 ( md . modification_time ) ; md . time_scale = BYTESWAP32 ( md . time_scale ) ; md . duration = BYTESWAP32 ( md . duration ) ; mp4 -> trak_clockdemon = md . time_scale ; mp4 -> trak_clockcount = md . duration ; if ( mp4 -> videolength == 0.0 ) { mp4 -> videolength = ( float ) ( ( double ) mp4 -> trak_clockcount / ( double ) mp4 -> trak_clockdemon ) ; } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'h' , 'd' , 'l' , 'r' ) ) { uint32_t temp ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & temp , 1 , 4 , mp4 -> mediafp ) ; <S2SV_StartBug> if ( temp != MAKEID ( 'a' , 'l' , 'i' , 's' ) ) <S2SV_EndBug> type = temp ; <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'd' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & subtype , 1 , 4 , mp4 -> mediafp ) ; if ( len == 16 ) { if ( subtype != traksubtype ) { type = 0 ; } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'c' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 12 <= qtsize - 8 - len ) { mp4 -> metastsc_count = num ; if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; <S2SV_StartBug> mp4 -> metastsc = ( SampleToChunk * ) malloc ( num * 12 ) ; <S2SV_EndBug> if ( mp4 -> metastsc ) { <S2SV_StartBug> uint32_t total_stsc = num ; <S2SV_EndBug> len += fread ( mp4 -> metastsc , 1 , num * sizeof ( SampleToChunk ) , mp4 -> mediafp ) ; do { num -- ; mp4 -> metastsc [ num ] . chunk_num = BYTESWAP32 ( mp4 -> metastsc [ num ] . chunk_num ) ; mp4 -> metastsc [ num ] . samples = BYTESWAP32 ( mp4 -> metastsc [ num ] . samples ) ; mp4 -> metastsc [ num ] . id = BYTESWAP32 ( mp4 -> metastsc [ num ] . id ) ; } while ( num > 0 ) ; } <S2SV_StartBug> if ( mp4 -> metastsc_count == 1 && mp4 -> metastsc [ 0 ] . samples == 1 ) <S2SV_EndBug> { if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; <S2SV_StartBug> mp4 -> metastsc_count = 0 ; <S2SV_EndBug> } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'z' ) ) { if ( type == traktype ) { uint32_t equalsamplesize ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & equalsamplesize , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 4 <= qtsize - 8 - len ) { mp4 -> metasize_count = num ; if ( mp4 -> metasizes ) free ( mp4 -> metasizes ) ; <S2SV_StartBug> mp4 -> metasizes = ( uint32_t * ) malloc ( num * 4 ) ; <S2SV_EndBug> if ( mp4 -> metasizes ) { if ( equalsamplesize == 0 ) { len += fread ( mp4 -> metasizes , 1 , num * 4 , mp4 -> mediafp ) ; do { num -- ; mp4 -> metasizes [ num ] = BYTESWAP32 ( mp4 -> metasizes [ num ] ) ; } while ( num > 0 ) ; } else { equalsamplesize = BYTESWAP32 ( equalsamplesize ) ; do { num -- ; mp4 -> metasizes [ num ] = equalsamplesize ; } while ( num > 0 ) ; } } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 'c' , 'o' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 4 <= qtsize - 8 - len ) { <S2SV_StartBug> if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) <S2SV_EndBug> { <S2SV_StartBug> mp4 -> indexcount = mp4 -> metasize_count ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; <S2SV_EndBug> if ( mp4 -> metaoffsets ) { uint32_t * metaoffsets32 = NULL ; metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ; if ( metaoffsets32 ) { uint64_t fileoffset = 0 ; int stsc_pos = 0 ; int stco_pos = 0 ; int repeat = 1 ; len += fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ; do { num -- ; metaoffsets32 [ num ] = BYTESWAP32 ( metaoffsets32 [ num ] ) ; } while ( num > 0 ) ; mp4 -> metaoffsets [ 0 ] = fileoffset = metaoffsets32 [ stco_pos ] ; num = 1 ; <S2SV_StartBug> while ( num < mp4 -> metasize_count ) <S2SV_EndBug> { if ( stsc_pos + 1 < ( int ) mp4 -> metastsc_count && num == stsc_pos ) { stco_pos ++ ; stsc_pos ++ ; fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ; repeat = 1 ; } else if ( repeat == mp4 -> metastsc [ stsc_pos ] . samples ) { <S2SV_StartBug> stco_pos ++ ; <S2SV_EndBug> fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ; <S2SV_StartBug> repeat = 1 ; <S2SV_EndBug> } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; <S2SV_StartBug> repeat ++ ; <S2SV_EndBug> } mp4 -> metaoffsets [ num ] = fileoffset ; num ++ ; } if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; mp4 -> metastsc_count = 0 ; free ( metaoffsets32 ) ; } } } else { <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( num * 8 ) ; if ( mp4 -> metaoffsets ) { uint32_t * metaoffsets32 = NULL ; metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ; if ( metaoffsets32 ) { size_t readlen = fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ; len += readlen ; do { num -- ; mp4 -> metaoffsets [ num ] = BYTESWAP32 ( metaoffsets32 [ num ] ) ; } while ( num > 0 ) ; free ( metaoffsets32 ) ; } } } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'c' , 'o' , '6' , '4' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; <S2SV_StartBug> if ( num * 8 <= qtsize - 8 - len ) <S2SV_EndBug> { if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) { mp4 -> indexcount = mp4 -> metasize_count ; <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; if ( mp4 -> metaoffsets ) { uint64_t * metaoffsets64 = NULL ; metaoffsets64 = ( uint64_t * ) malloc ( num * 8 ) ; if ( metaoffsets64 ) { uint64_t fileoffset = 0 ; int stsc_pos = 0 ; int stco_pos = 0 ; len += fread ( metaoffsets64 , 1 , num * 8 , mp4 -> mediafp ) ; do { num -- ; metaoffsets64 [ num ] = BYTESWAP64 ( metaoffsets64 [ num ] ) ; } while ( num > 0 ) ; fileoffset = metaoffsets64 [ 0 ] ; mp4 -> metaoffsets [ 0 ] = fileoffset ; num = 1 ; while ( num < mp4 -> metasize_count ) { if ( num != mp4 -> metastsc [ stsc_pos ] . chunk_num - 1 && 0 == ( num - ( mp4 -> metastsc [ stsc_pos ] . chunk_num - 1 ) ) % mp4 -> metastsc [ stsc_pos ] . samples ) { stco_pos ++ ; fileoffset = ( uint64_t ) metaoffsets64 [ stco_pos ] ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; } mp4 -> metaoffsets [ num ] = fileoffset ; num ++ ; } if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; mp4 -> metastsc_count = 0 ; free ( metaoffsets64 ) ; } } } else { <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( num * 8 ) ; if ( mp4 -> metaoffsets ) { len += fread ( mp4 -> metaoffsets , 1 , num * 8 , mp4 -> mediafp ) ; do { num -- ; mp4 -> metaoffsets [ num ] = BYTESWAP64 ( mp4 -> metaoffsets [ num ] ) ; } while ( num > 0 ) ; } } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 't' , 's' ) ) { if ( type == traktype ) { uint32_t totaldur = 0 , samples = 0 ; int32_t entries = 0 ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 8 <= qtsize - 8 - len ) { entries = num ; mp4 -> meta_clockdemon = mp4 -> trak_clockdemon ; mp4 -> meta_clockcount = mp4 -> trak_clockcount ; while ( entries > 0 ) { int32_t samplecount ; int32_t duration ; len += fread ( & samplecount , 1 , 4 , mp4 -> mediafp ) ; samplecount = BYTESWAP32 ( samplecount ) ; len += fread ( & duration , 1 , 4 , mp4 -> mediafp ) ; duration = BYTESWAP32 ( duration ) ; samples += samplecount ; entries -- ; totaldur += duration ; mp4 -> metadatalength += ( double ) ( ( double ) samplecount * ( double ) duration / ( double ) mp4 -> meta_clockdemon ) ; } mp4 -> basemetadataduration = mp4 -> metadatalength * ( double ) mp4 -> meta_clockdemon / ( double ) samples ; } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else { NESTSIZE ( 8 ) ; } } else { break ; } } while ( len > 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> else { free ( mp4 ) ; mp4 = NULL ; } return ( size_t ) mp4 ; }
","<S2SV_ModStart> mp4object ) ) ; struct stat64 mp4stat ; stat64 ( filename , & mp4stat ) ; mp4 -> filesize = mp4stat . st_size ; if ( mp4 -> filesize < 64 ) return 0 <S2SV_ModStart> mediafp ) ; mp4 -> filepos += len ; <S2SV_ModStart> len == 8 && mp4 -> filepos < mp4 -> filesize <S2SV_ModStart> ) ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break <S2SV_ModEnd> ; } qtsize32 <S2SV_ModStart> 1 ) { len = <S2SV_ModStart> -> mediafp ) ; mp4 -> filepos += len <S2SV_ModStart> , 'a' ) || qttag == MAKEID ( 'f' , 'r' , 'e' , 'e' ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> != MAKEID ( 's' , 't' , 'b' , 'l' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 's' , 't' , 't' <S2SV_ModEnd> , 's' ) <S2SV_ModStart> , 't' , 's' , 'c' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 's' , 'z' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 'c' , 'o' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 'c' , 'o' , '6' , '4' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( <S2SV_ModEnd> 'h' , 'd' <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> clockcount ) ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> , 's' ) && temp != MAKEID ( 'u' , 'r' , 'l' , '<S2SV_blank>' ) <S2SV_ModStart> = temp ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metastsc ) ; if ( num > 0 ) { <S2SV_ModStart> ( num * sizeof ( SampleToChunk ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> metastsc ) { <S2SV_ModEnd> len += fread <S2SV_ModStart> ) ; } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metasizes ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> len ) { uint32_t metastco_count = num ; <S2SV_ModStart> -> indexcount = num <S2SV_ModEnd> ; if ( <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> ) malloc ( num <S2SV_ModEnd> * 8 ) <S2SV_ModStart> < mp4 -> indexcount ) { if ( ( uint32_t ) <S2SV_ModEnd> repeat == mp4 <S2SV_ModStart> samples ) { if ( ( uint32_t ) stco_pos + 1 < metastco_count ) { <S2SV_ModStart> stco_pos ] ; <S2SV_ModEnd> } else { <S2SV_ModStart> 1 ] ; } if ( ( uint32_t ) stsc_pos + 1 < mp4 -> metastsc_count ) if ( mp4 -> metastsc [ stsc_pos + 1 ] . chunk_num == ( uint32_t ) stco_pos + 1 ) stsc_pos ++ ; repeat = 1 ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> if ( num == 0 ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } if ( num <S2SV_ModStart> metaoffsets ) ; if ( mp4 -> metasize_count ) { <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> samples ; } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> 0 ) ; if ( mp4 ) { if ( mp4 -> metasizes == NULL || mp4 -> metaoffsets == NULL ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; } }
",gopro@gpmf-parser/341f12cd5b97ab419e53853ca00176457c9f1681,CVE-2019-15148,https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681,2019-08-18T19:15Z,"<S2SV_StartBug> memset ( mp4 , 0 , sizeof ( mp4object ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len == 8 ) <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; <S2SV_EndBug> <S2SV_StartBug> qttag == MAKEID ( 'u' , 'd' , 't' , 'a' ) ) <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'b' , 'l' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 't' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'c' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'z' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'c' , 'o' ) && <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( temp != MAKEID ( 'a' , 'l' , 'i' , 's' ) ) <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metastsc = ( SampleToChunk * ) malloc ( num * 12 ) ; <S2SV_EndBug> <S2SV_StartBug> uint32_t total_stsc = num ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metastsc_count == 1 && mp4 -> metastsc [ 0 ] . samples == 1 ) <S2SV_EndBug> <S2SV_StartBug> mp4 -> metastsc_count = 0 ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metasizes = ( uint32_t * ) malloc ( num * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) <S2SV_EndBug> <S2SV_StartBug> mp4 -> indexcount = mp4 -> metasize_count ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; <S2SV_EndBug> <S2SV_StartBug> while ( num < mp4 -> metasize_count ) <S2SV_EndBug> <S2SV_StartBug> stco_pos ++ ; <S2SV_EndBug> <S2SV_StartBug> repeat = 1 ; <S2SV_EndBug> <S2SV_StartBug> repeat ++ ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( num * 8 <= qtsize - 8 - len ) <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
7064,CWE-401,"static struct scatterlist * alloc_sgtable ( int size ) { int alloc_size , nents , i ; struct page * new_page ; struct scatterlist * iter ; struct scatterlist * table ; nents = DIV_ROUND_UP ( size , PAGE_SIZE ) ; table = kcalloc ( nents , sizeof ( * table ) , GFP_KERNEL ) ; if ( ! table ) return NULL ; sg_init_table ( table , nents ) ; iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = alloc_page ( GFP_KERNEL ) ; if ( ! new_page ) { iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = sg_page ( iter ) ; if ( new_page ) __free_page ( new_page ) ; } <S2SV_StartBug> return NULL ; <S2SV_EndBug> } alloc_size = min_t ( int , size , PAGE_SIZE ) ; size -= PAGE_SIZE ; sg_set_page ( iter , new_page , alloc_size , 0 ) ; } return table ; }
","<S2SV_ModStart> ) ; } kfree ( table ) ;
",torvalds@linux/b4b814fec1a5a849383f7b3886b654a13abbda7d,CVE-2019-19058,https://github.com/torvalds/linux/commit/b4b814fec1a5a849383f7b3886b654a13abbda7d,2019-11-18T06:15Z,<S2SV_StartBug> return NULL ; <S2SV_EndBug>
2900,CWE-310,"static int btrfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry ) { struct btrfs_trans_handle * trans ; struct btrfs_root * root = BTRFS_I ( old_dir ) -> root ; struct btrfs_root * dest = BTRFS_I ( new_dir ) -> root ; struct inode * new_inode = new_dentry -> d_inode ; struct inode * old_inode = old_dentry -> d_inode ; struct timespec ctime = CURRENT_TIME ; u64 index = 0 ; u64 root_objectid ; int ret ; u64 old_ino = btrfs_ino ( old_inode ) ; if ( btrfs_ino ( new_dir ) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) return - EPERM ; if ( old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest ) return - EXDEV ; if ( old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID || ( new_inode && btrfs_ino ( new_inode ) == BTRFS_FIRST_FREE_OBJECTID ) ) return - ENOTEMPTY ; if ( S_ISDIR ( old_inode -> i_mode ) && new_inode && new_inode -> i_size > BTRFS_EMPTY_DIR_SIZE ) return - ENOTEMPTY ; <S2SV_StartBug> if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && <S2SV_EndBug> old_inode -> i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT ) filemap_flush ( old_inode -> i_mapping ) ; if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) down_read ( & root -> fs_info -> subvol_sem ) ; trans = btrfs_start_transaction ( root , 20 ) ; if ( IS_ERR ( trans ) ) { ret = PTR_ERR ( trans ) ; goto out_notrans ; } if ( dest != root ) btrfs_record_root_in_trans ( trans , dest ) ; ret = btrfs_set_inode_index ( new_dir , & index ) ; if ( ret ) goto out_fail ; if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { root -> fs_info -> last_trans_log_full_commit = trans -> transid ; } else { ret = btrfs_insert_inode_ref ( trans , dest , new_dentry -> d_name . name , new_dentry -> d_name . len , old_ino , btrfs_ino ( new_dir ) , index ) ; if ( ret ) goto out_fail ; btrfs_pin_log_trans ( root ) ; } if ( new_inode && new_inode -> i_size && S_ISREG ( old_inode -> i_mode ) ) btrfs_add_ordered_operation ( trans , root , old_inode ) ; inode_inc_iversion ( old_dir ) ; inode_inc_iversion ( new_dir ) ; inode_inc_iversion ( old_inode ) ; old_dir -> i_ctime = old_dir -> i_mtime = ctime ; new_dir -> i_ctime = new_dir -> i_mtime = ctime ; old_inode -> i_ctime = ctime ; if ( old_dentry -> d_parent != new_dentry -> d_parent ) btrfs_record_unlink_dir ( trans , old_dir , old_inode , 1 ) ; if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { root_objectid = BTRFS_I ( old_inode ) -> root -> root_key . objectid ; ret = btrfs_unlink_subvol ( trans , root , old_dir , root_objectid , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; } else { ret = __btrfs_unlink_inode ( trans , root , old_dir , old_dentry -> d_inode , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; if ( ! ret ) ret = btrfs_update_inode ( trans , root , old_inode ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( new_inode ) { inode_inc_iversion ( new_inode ) ; new_inode -> i_ctime = CURRENT_TIME ; if ( unlikely ( btrfs_ino ( new_inode ) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) ) { root_objectid = BTRFS_I ( new_inode ) -> location . objectid ; ret = btrfs_unlink_subvol ( trans , dest , new_dir , root_objectid , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; BUG_ON ( new_inode -> i_nlink == 0 ) ; } else { ret = btrfs_unlink_inode ( trans , dest , new_dir , new_dentry -> d_inode , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; } if ( ! ret && new_inode -> i_nlink == 0 ) { ret = btrfs_orphan_add ( trans , new_dentry -> d_inode ) ; BUG_ON ( ret ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } } fixup_inode_flags ( new_dir , old_inode ) ; ret = btrfs_add_link ( trans , new_dir , old_inode , new_dentry -> d_name . name , new_dentry -> d_name . len , 0 , index ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( old_ino != BTRFS_FIRST_FREE_OBJECTID ) { struct dentry * parent = new_dentry -> d_parent ; btrfs_log_new_name ( trans , old_inode , old_dir , parent ) ; btrfs_end_log_trans ( root ) ; } out_fail : btrfs_end_transaction ( trans , root ) ; out_notrans : if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) up_read ( & root -> fs_info -> subvol_sem ) ; return ret ; }
","<S2SV_ModStart> - ENOTEMPTY ; ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; if ( ret ) { if ( ret == - EEXIST ) { if ( ! new_inode ) { WARN_ON ( 1 ) ; return ret ; } } else { return ret ; } } ret = 0 ;
",torvalds@linux/9c52057c698fb96f8f07e7a4bcf4801a092bda89,CVE-2012-5375,https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89,2013-02-18T11:56Z,<S2SV_StartBug> if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && <S2SV_EndBug>
2097,CWE-000,"static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( IS_MNT_NEW ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = CL_MAKE_SHARED ; } else { <S2SV_StartBug> struct mount * n , * p ; <S2SV_EndBug> for ( n = m ; ; n = p ) { p = n -> mnt_master ; <S2SV_StartBug> if ( p == dest_master || IS_MNT_MARKED ( p ) ) { <S2SV_EndBug> while ( last_dest -> mnt_master != p ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } if ( ! peers ( n , last_dest ) ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } break ; } } type = CL_SLAVE ; if ( IS_MNT_SHARED ( m ) ) type |= CL_MAKE_SHARED ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) return PTR_ERR ( child ) ; child -> mnt . mnt_flags &= ~ MNT_LOCKED ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; SET_MNT_MARK ( m -> mnt_master ) ; read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ; return 0 ; }
","<S2SV_ModStart> , * p ; bool done <S2SV_ModStart> p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <S2SV_ModEnd> type = CL_SLAVE
",torvalds@linux/5ec0811d30378ae104f250bfc9b3640242d81e3f,CVE-2016-4581,https://github.com/torvalds/linux/commit/5ec0811d30378ae104f250bfc9b3640242d81e3f,2016-05-23T10:59Z,"<S2SV_StartBug> struct mount * n , * p ; <S2SV_EndBug> <S2SV_StartBug> if ( p == dest_master || IS_MNT_MARKED ( p ) ) { <S2SV_EndBug>"
2220,CWE-000,"static void setup_token_decoder ( VP8D_COMP * pbi , const unsigned char * token_part_sizes ) { vp8_reader * bool_decoder = & pbi -> mbc [ 0 ] ; unsigned int partition_idx ; unsigned int fragment_idx ; unsigned int num_token_partitions ; const unsigned char * first_fragment_end = pbi -> fragments . ptrs [ 0 ] + pbi -> fragments . sizes [ 0 ] ; TOKEN_PARTITION multi_token_partition = ( TOKEN_PARTITION ) vp8_read_literal ( & pbi -> mbc [ 8 ] , 2 ) ; if ( ! vp8dx_bool_error ( & pbi -> mbc [ 8 ] ) ) pbi -> common . multi_token_partition = multi_token_partition ; num_token_partitions = 1 << pbi -> common . multi_token_partition ; for ( fragment_idx = 0 ; fragment_idx < pbi -> fragments . count ; ++ fragment_idx ) { unsigned int fragment_size = pbi -> fragments . sizes [ fragment_idx ] ; const unsigned char * fragment_end = pbi -> fragments . ptrs [ fragment_idx ] + fragment_size ; if ( fragment_idx == 0 ) { ptrdiff_t ext_first_part_size = token_part_sizes - pbi -> fragments . ptrs [ 0 ] + 3 * ( num_token_partitions - 1 ) ; fragment_size -= ( unsigned int ) ext_first_part_size ; if ( fragment_size > 0 ) { pbi -> fragments . sizes [ 0 ] = ( unsigned int ) ext_first_part_size ; fragment_idx ++ ; pbi -> fragments . ptrs [ fragment_idx ] = pbi -> fragments . ptrs [ 0 ] + pbi -> fragments . sizes [ 0 ] ; } } while ( fragment_size > 0 ) { ptrdiff_t partition_size = read_available_partition_size ( pbi , token_part_sizes , pbi -> fragments . ptrs [ fragment_idx ] , first_fragment_end , fragment_end , fragment_idx - 1 , num_token_partitions ) ; pbi -> fragments . sizes [ fragment_idx ] = ( unsigned int ) partition_size ; fragment_size -= ( unsigned int ) partition_size ; assert ( fragment_idx <= num_token_partitions ) ; if ( fragment_size > 0 ) { fragment_idx ++ ; pbi -> fragments . ptrs [ fragment_idx ] = pbi -> fragments . ptrs [ fragment_idx - 1 ] + partition_size ; } } } pbi -> fragments . count = num_token_partitions + 1 ; for ( partition_idx = 1 ; partition_idx < pbi -> fragments . count ; ++ partition_idx ) { if ( vp8dx_start_decode ( bool_decoder , pbi -> fragments . ptrs [ partition_idx ] , pbi -> fragments . sizes [ partition_idx ] , pbi -> decrypt_cb , pbi -> decrypt_state ) ) vpx_internal_error ( & pbi -> common . error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>%d"" , partition_idx ) ; bool_decoder ++ ; } # if CONFIG_MULTITHREAD <S2SV_StartBug> if ( pbi -> decoding_thread_count > num_token_partitions - 1 ) <S2SV_EndBug> <S2SV_StartBug> pbi -> decoding_thread_count = num_token_partitions - 1 ; <S2SV_EndBug> # endif }
","<S2SV_ModStart> - 1 ) { <S2SV_ModStart> - 1 ; } if ( pbi -> decoding_thread_count > pbi -> common . mb_rows - 1 ) { pbi -> decoding_thread_count = pbi -> common . mb_rows - 1 ; }
",external@libvpx/6886e8e0a9db2dbad723dc37a548233e004b33bc,CVE-2017-0393,https://android.googlesource.com/platform/external/libvpx/+/6886e8e0a9db2dbad723dc37a548233e004b33bc,2017-01-12T20:59Z,<S2SV_StartBug> if ( pbi -> decoding_thread_count > num_token_partitions - 1 ) <S2SV_EndBug> <S2SV_StartBug> pbi -> decoding_thread_count = num_token_partitions - 1 ; <S2SV_EndBug>
2832,CWE-189,"static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode > BPF_JSLE ) { verbose ( env , ""invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\n"" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , insn -> src_reg ) ; return - EACCES ; } } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } } <S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( dst_reg -> type == SCALAR_VALUE && regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }
","<S2SV_ModStart> , * insn_idx , false
",torvalds@linux/979d63d50c0c0f7bc537bf821e056cc9fe5abd38,CVE-2019-7308,https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38,2019-02-01T22:29Z,"<S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug>"
766,CWE-20,"long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> ret = - ENOKEY ; goto error2 ; } ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }
","<S2SV_ModStart> key_ref ) ; ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> ret = key_permission
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug>"
4186,CWE-732,"char * * <S2SV_StartBug> prepenv ( const struct rule * rule ) <S2SV_EndBug> { static const char * safeset [ ] = { ""DISPLAY"" , ""HOME"" , ""LOGNAME"" , ""MAIL"" , ""PATH"" , ""TERM"" , ""USER"" , ""USERNAME"" , NULL } ; struct env * env ; <S2SV_StartBug> env = createenv ( rule ) ; <S2SV_EndBug> if ( ! ( rule -> options & KEEPENV ) ) fillenv ( env , safeset ) ; if ( rule -> envlist ) fillenv ( env , rule -> envlist ) ; return flattenenv ( env ) ; }
","<S2SV_ModStart> rule * rule , const struct passwd * mypw , const struct passwd * targpw ) { <S2SV_ModEnd> struct env * <S2SV_ModStart> createenv ( rule , mypw , targpw <S2SV_ModEnd> ) ; if
",Duncaen@OpenDoas/01c658f8c45cb92a343be5f32aa6da70b2032168,CVE-2019-25016,https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168,2021-01-28T20:15Z,<S2SV_StartBug> prepenv ( const struct rule * rule ) <S2SV_EndBug> <S2SV_StartBug> env = createenv ( rule ) ; <S2SV_EndBug>
2970,CWE-200,"static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , CB_TRGCLS_LEN , CB_TRGCLS ( skb ) ) ; if ( err ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { WARN_ON ( 1 ) ; iucv_sock_close ( sk ) ; return - EFAULT ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; if ( err ) { sk -> sk_state = IUCV_DISCONN ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
","<S2SV_ModStart> ; int err = 0 ; msg -> msg_namelen
",torvalds@linux/a5598bd9c087dc0efc250a5221e5d0e6f584ee88,CVE-2013-3229,https://github.com/torvalds/linux/commit/a5598bd9c087dc0efc250a5221e5d0e6f584ee88,2013-04-22T11:41Z,<S2SV_StartBug> int err = 0 ; <S2SV_EndBug>
3955,CWE-476,"static void pcd_init_units ( void ) { struct pcd_unit * cd ; int unit ; pcd_drive_count = 0 ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { struct gendisk * disk = alloc_disk ( 1 ) ; if ( ! disk ) continue ; disk -> queue = blk_mq_init_sq_queue ( & cd -> tag_set , & pcd_mq_ops , 1 , BLK_MQ_F_SHOULD_MERGE ) ; if ( IS_ERR ( disk -> queue ) ) { <S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug> continue ; } INIT_LIST_HEAD ( & cd -> rq_list ) ; disk -> queue -> queuedata = cd ; blk_queue_bounce_limit ( disk -> queue , BLK_BOUNCE_HIGH ) ; cd -> disk = disk ; cd -> pi = & cd -> pia ; cd -> present = 0 ; cd -> last_sense = 0 ; cd -> changed = 1 ; cd -> drive = ( * drives [ unit ] ) [ D_SLV ] ; if ( ( * drives [ unit ] ) [ D_PRT ] ) pcd_drive_count ++ ; cd -> name = & cd -> info . name [ 0 ] ; snprintf ( cd -> name , sizeof ( cd -> info . name ) , ""%s%d"" , name , unit ) ; cd -> info . ops = & pcd_dops ; cd -> info . handle = cd ; cd -> info . speed = 0 ; cd -> info . capacity = 1 ; cd -> info . mask = 0 ; disk -> major = major ; disk -> first_minor = unit ; strcpy ( disk -> disk_name , cd -> name ) ; disk -> fops = & pcd_bdops ; disk -> flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE ; } }
","<S2SV_ModStart> ) ) { put_disk ( disk ) ;
",torvalds@linux/f0d1762554014ce0ae347b9f0d088f2c157c8c72,CVE-2019-15923,https://github.com/torvalds/linux/commit/f0d1762554014ce0ae347b9f0d088f2c157c8c72,2019-09-04T19:15Z,<S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug>
410,CWE-125,"static void gre_print_0 ( netdissect_options * ndo , const u_char * bp , u_int length ) { u_int len = length ; uint16_t flags , prot ; flags = EXTRACT_16BITS ( bp ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( gre_flag_values , ""none"" , flags ) ) ) ; len -= 2 ; bp += 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; prot = EXTRACT_16BITS ( bp ) ; len -= 2 ; bp += 2 ; if ( ( flags & GRE_CP ) | ( flags & GRE_RP ) ) { ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>sum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>off<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; } if ( flags & GRE_KP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>key=0x%x"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_RP ) { for ( ; ; ) { uint16_t af ; uint8_t sreoff ; uint8_t srelen ; ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; af = EXTRACT_16BITS ( bp ) ; sreoff = * ( bp + 2 ) ; srelen = * ( bp + 3 ) ; bp += 4 ; len -= 4 ; if ( af == 0 && srelen == 0 ) break ; if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ; if ( len < srelen ) goto trunc ; bp += srelen ; len -= srelen ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>proto<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , tok2str ( ethertype_values , ""unknown"" , prot ) , prot ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag < 1 ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; switch ( prot ) { case ETHERTYPE_IP : ip_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , bp , len ) ; break ; case ETHERTYPE_MPLS : mpls_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPX : ipx_print ( ndo , bp , len ) ; break ; case ETHERTYPE_ATALK : atalk_print ( ndo , bp , len ) ; break ; case ETHERTYPE_GRE_ISO : <S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ; break ; default : ND_PRINT ( ( ndo , ""gre-proto-0x%x"" , prot ) ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> bp , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart> ndo_snapend - bp <S2SV_ModEnd> , NULL ,
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,"<S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug>"
26,CWE-119,"UWORD32 ihevcd_cabac_decode_bypass_bins_egk ( cab_ctxt_t * ps_cabac , bitstrm_t * ps_bitstrm , WORD32 k ) { UWORD32 u4_sym ; WORD32 numones ; WORD32 bin ; ASSERT ( ( k >= 0 ) ) ; numones = k ; bin = 1 ; u4_sym = 0 ; <S2SV_StartBug> while ( bin ) <S2SV_EndBug> { IHEVCD_CABAC_DECODE_BYPASS_BIN ( bin , ps_cabac , ps_bitstrm ) ; u4_sym += bin << numones ++ ; } <S2SV_StartBug> numones -= 1 ; <S2SV_EndBug> numones = CLIP3 ( numones , 0 , 16 ) ; if ( numones ) { UWORD32 u4_suffix ; IHEVCD_CABAC_DECODE_BYPASS_BINS ( u4_suffix , ps_cabac , ps_bitstrm , numones ) ; u4_sym += u4_suffix ; } return ( u4_sym ) ; }
","<S2SV_ModStart> while ( bin && ( numones <= 16 ) <S2SV_ModStart> numones -= 1 <S2SV_ModEnd> ; if (
",external@libhevc/01ca88bb6c5bdd44e071f8effebe12f1d7da9853,CVE-2017-0540,https://android.googlesource.com/platform/external/libhevc/+/01ca88bb6c5bdd44e071f8effebe12f1d7da9853,2017-04-07T22:59Z,<S2SV_StartBug> while ( bin ) <S2SV_EndBug> <S2SV_StartBug> numones -= 1 ; <S2SV_EndBug>
734,CWE-125,"int saa7164_bus_get ( struct saa7164_dev * dev , struct tmComResInfo * msg , void * buf , int peekonly ) { struct tmComResBusInfo * bus = & dev -> bus ; u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ; struct tmComResInfo msg_tmp ; int ret = SAA_ERR_BAD_PARAMETER ; saa7164_bus_verify ( dev ) ; if ( msg == NULL ) return ret ; if ( msg -> size > dev -> bus . m_wMaxReqSize ) { printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\n"" , __func__ ) ; return ret ; } if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\n"" , __func__ , msg -> size ) ; return ret ; } mutex_lock ( & bus -> lock ) ; curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ; curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ; if ( curr_gwp == curr_grp ) { ret = SAA_ERR_EMPTY ; goto out ; } bytes_to_read = sizeof ( * msg ) ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ; memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } else { memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ; } msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ; msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ; msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ; <S2SV_StartBug> if ( peekonly ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_EndBug> goto peekout ; } if ( ( msg_tmp . id != msg -> id ) || ( msg_tmp . command != msg -> command ) || ( msg_tmp . controlselector != msg -> controlselector ) || ( msg_tmp . seqno != msg -> seqno ) || ( msg_tmp . size != msg -> size ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Unexpected<S2SV_blank>msg<S2SV_blank>miss-match\\n"" , __func__ ) ; saa7164_bus_dumpmsg ( dev , msg , buf ) ; saa7164_bus_dumpmsg ( dev , & msg_tmp , NULL ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } buf_size = msg -> size ; bytes_to_read = sizeof ( * msg ) + msg -> size ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>Invalid<S2SV_blank>bus<S2SV_blank>state,<S2SV_blank>missing<S2SV_blank>msg<S2SV_blank>or<S2SV_blank>mangled<S2SV_blank>ring,<S2SV_blank>faulty<S2SV_blank>H/W<S2SV_blank>/<S2SV_blank>bad<S2SV_blank>code?\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; if ( space_rem < sizeof ( * msg ) ) { <S2SV_StartBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ; <S2SV_EndBug> memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing , <S2SV_StartBug> sizeof ( * msg ) - space_rem ) ; <S2SV_EndBug> if ( buf ) <S2SV_StartBug> memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - <S2SV_EndBug> space_rem , buf_size ) ; <S2SV_StartBug> } else if ( space_rem == sizeof ( * msg ) ) { <S2SV_EndBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing , buf_size ) ; } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) { memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ; } msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ; msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ; msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ; saa7164_writel ( bus -> m_dwGetReadPos , new_grp ) ; peekout : ret = SAA_OK ; out : mutex_unlock ( & bus -> lock ) ; saa7164_bus_verify ( dev ) ; return ret ; }
","<S2SV_ModStart> controlselector ) ; memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_ModStart> peekonly ) { <S2SV_ModEnd> goto peekout ; <S2SV_ModStart> ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing , buf_size ) ; } else { if ( buf ) { <S2SV_ModEnd> memcpy_fromio ( buf <S2SV_ModStart> -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , <S2SV_ModEnd> buf_size ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> saa7164_writel ( bus
",stoth68000@media-tree/354dd3924a2e43806774953de536257548b5002c,CVE-2017-8831,https://github.com/stoth68000/media-tree/commit/354dd3924a2e43806774953de536257548b5002c,2017-05-08T06:29Z,"<S2SV_StartBug> if ( peekonly ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ; <S2SV_EndBug> <S2SV_StartBug> sizeof ( * msg ) - space_rem ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - <S2SV_EndBug> <S2SV_StartBug> } else if ( space_rem == sizeof ( * msg ) ) { <S2SV_EndBug>"
1293,CWE-476,"unsigned int ip6t_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; unsigned int verdict = NF_DROP ; const char * indev , * outdev ; const void * table_base ; struct ip6t_entry * e , * * jumpstack ; unsigned int stackidx , cpu ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; stackidx = 0 ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; acpar . hotdrop = false ; acpar . state = state ; WARN_ON ( ! ( table -> valid_hooks & ( 1 << hook ) ) ) ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct ip6t_entry * * ) private -> jumpstack [ cpu ] ; if ( static_key_false ( & xt_tee_enabled ) ) jumpstack += private -> stacksize * __this_cpu_read ( nf_skb_duplicated ) ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; do { const struct xt_entry_target * t ; const struct xt_entry_match * ematch ; struct xt_counters * counter ; WARN_ON ( ! e ) ; acpar . thoff = 0 ; if ( ! ip6_packet_match ( skb , indev , outdev , & e -> ipv6 , & acpar . thoff , & acpar . fragoff , & acpar . hotdrop ) ) { no_match : e = ip6t_next_entry ( e ) ; continue ; } xt_ematch_foreach ( ematch , e ) { acpar . match = ematch -> u . kernel . match ; acpar . matchinfo = ematch -> data ; if ( ! acpar . match -> match ( skb , & acpar ) ) goto no_match ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , skb -> len , 1 ) ; t = ip6t_get_target_c ( e ) ; WARN_ON ( ! t -> u . kernel . target ) ; # if IS_ENABLED ( CONFIG_NETFILTER_XT_TARGET_TRACE ) if ( unlikely ( skb -> nf_trace ) ) trace_packet ( state -> net , skb , hook , state -> in , state -> out , table -> name , private , e ) ; # endif if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) e = get_entry ( table_base , private -> underflow [ hook ] ) ; else e = ip6t_next_entry ( jumpstack [ -- stackidx ] ) ; continue ; } if ( table_base + v != ip6t_next_entry ( e ) && ! ( e -> ipv6 . flags & IP6T_F_GOTO ) ) { <S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> } e = get_entry ( table_base , v ) ; continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) e = ip6t_next_entry ( e ) ; else break ; } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }
","<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }
",torvalds@linux/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,CVE-2018-1065,https://github.com/torvalds/linux/commit/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,2018-03-02T08:29Z,<S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug>
3476,CWE-284,"void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( ! mp ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; <S2SV_StartBug> umount_tree ( mnt , 0 ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }
","<S2SV_ModStart> mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } else
",torvalds@linux/ce07d891a0891d3c0d0c2d73d577490486b809e1,CVE-2014-9717,https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1,2016-05-02T10:59Z,"<S2SV_StartBug> umount_tree ( mnt , 0 ) ; <S2SV_EndBug>"
1523,CWE-119,"static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , <S2SV_StartBug> vp8_decrypt_cb * decrypt_cb , <S2SV_EndBug> void * decrypt_state ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( data + data_sz <= data ) { res = VPX_CODEC_INVALID_PARAM ; } else { uint8_t clear_buffer [ 10 ] ; const uint8_t * clear = data ; if ( decrypt_cb ) { <S2SV_StartBug> int n = data_sz > 10 ? 10 : data_sz ; <S2SV_EndBug> decrypt_cb ( decrypt_state , data , clear_buffer , n ) ; clear = clear_buffer ; } si -> is_kf = 0 ; if ( data_sz >= 10 && ! ( clear [ 0 ] & 0x01 ) ) { si -> is_kf = 1 ; if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a ) <S2SV_StartBug> res = VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_EndBug> si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ; si -> h = ( clear [ 8 ] | ( clear [ 9 ] << 8 ) ) & 0x3fff ; if ( ! ( si -> h | si -> w ) ) res = VPX_CODEC_UNSUP_BITSTREAM ; } else { res = VPX_CODEC_UNSUP_BITSTREAM ; } } return res ; }
","<S2SV_ModStart> * si , vpx_decrypt_cb <S2SV_ModEnd> decrypt_cb , void <S2SV_ModStart> int n = MIN ( sizeof ( clear_buffer ) , data_sz ) <S2SV_ModEnd> ; decrypt_cb ( <S2SV_ModStart> != 0x2a ) return <S2SV_ModEnd> VPX_CODEC_UNSUP_BITSTREAM ; si
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vp8_decrypt_cb * decrypt_cb , <S2SV_EndBug> <S2SV_StartBug> int n = data_sz > 10 ? 10 : data_sz ; <S2SV_EndBug> <S2SV_StartBug> res = VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_EndBug>"
2040,CWE-119,"static void show_stream_config ( struct stream_state * stream , struct VpxEncoderConfig * global , struct VpxInputContext * input ) { # define SHOW ( field ) fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-28s<S2SV_blank>=<S2SV_blank>%d\\n"" , # field , stream -> config . cfg . field ) if ( stream -> index == 0 ) { fprintf ( stderr , ""Codec:<S2SV_blank>%s\\n"" , <S2SV_StartBug> vpx_codec_iface_name ( global -> codec -> interface ( ) ) ) ; <S2SV_EndBug> fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n"" , input -> filename , <S2SV_StartBug> input -> use_i420 ? ""I420"" : ""YV12"" ) ; <S2SV_EndBug> } if ( stream -> next || stream -> index ) fprintf ( stderr , ""\\nStream<S2SV_blank>Index:<S2SV_blank>%d\\n"" , stream -> index ) ; fprintf ( stderr , ""Destination<S2SV_blank>file:<S2SV_blank>%s\\n"" , stream -> config . out_fn ) ; fprintf ( stderr , ""Encoder<S2SV_blank>parameters:\\n"" ) ; SHOW ( g_usage ) ; SHOW ( g_threads ) ; SHOW ( g_profile ) ; SHOW ( g_w ) ; SHOW ( g_h ) ; <S2SV_StartBug> SHOW ( g_timebase . num ) ; <S2SV_EndBug> SHOW ( g_timebase . den ) ; SHOW ( g_error_resilient ) ; SHOW ( g_pass ) ; SHOW ( g_lag_in_frames ) ; SHOW ( rc_dropframe_thresh ) ; <S2SV_StartBug> SHOW ( rc_resize_allowed ) ; <S2SV_EndBug> SHOW ( rc_resize_up_thresh ) ; SHOW ( rc_resize_down_thresh ) ; SHOW ( rc_end_usage ) ; SHOW ( rc_target_bitrate ) ; SHOW ( rc_min_quantizer ) ; SHOW ( rc_max_quantizer ) ; SHOW ( rc_undershoot_pct ) ; SHOW ( rc_overshoot_pct ) ; SHOW ( rc_buf_sz ) ; SHOW ( rc_buf_initial_sz ) ; SHOW ( rc_buf_optimal_sz ) ; SHOW ( rc_2pass_vbr_bias_pct ) ; SHOW ( rc_2pass_vbr_minsection_pct ) ; SHOW ( rc_2pass_vbr_maxsection_pct ) ; SHOW ( kf_mode ) ; SHOW ( kf_min_dist ) ; SHOW ( kf_max_dist ) ; }
","<S2SV_ModStart> -> codec -> codec_interface ( ) ) ) ; fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>File<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n"" , <S2SV_ModEnd> input -> filename <S2SV_ModStart> -> filename , file_type_to_string ( input -> file_type ) , image_format_to_string ( input -> fmt ) <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; SHOW ( g_bit_depth ) ; SHOW ( g_input_bit_depth ) ; SHOW ( <S2SV_ModStart> SHOW ( rc_resize_allowed ) ; SHOW ( rc_scaled_width ) ; SHOW ( rc_scaled_height
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_codec_iface_name ( global -> codec -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> input -> use_i420 ? ""I420"" : ""YV12"" ) ; <S2SV_EndBug> <S2SV_StartBug> SHOW ( g_timebase . num ) ; <S2SV_EndBug> <S2SV_StartBug> SHOW ( rc_resize_allowed ) ; <S2SV_EndBug>"
1265,CWE-264,"void vlan_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags |= IFF_802_1Q_VLAN ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> dev -> tx_queue_len = 0 ; dev -> netdev_ops = & vlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> ethtool_ops = & vlan_ethtool_ops ; memset ( dev -> broadcast , 0 , ETH_ALEN ) ; }
","<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,<S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug>
434,CWE-77,"int <S2SV_StartBug> run_cmd ( int fd , ... ) <S2SV_EndBug> { pid_t pid ; sigset_t sigm , sigm_old ; sigemptyset ( & sigm ) ; sigaddset ( & sigm , SIGTERM ) ; sigprocmask ( SIG_BLOCK , & sigm , & sigm_old ) ; pid = fork ( ) ; if ( pid < 0 ) { sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; fd_printf ( STO , ""***<S2SV_blank>cannot<S2SV_blank>fork:<S2SV_blank>%s<S2SV_blank>***\\r\\n"" , strerror ( errno ) ) ; return - 1 ; } else if ( pid ) { int status , r ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; do { r = waitpid ( pid , & status , 0 ) ; } while ( r < 0 && errno == EINTR ) ; term_apply ( STI ) ; if ( WIFEXITED ( status ) ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>exit<S2SV_blank>status:<S2SV_blank>%d<S2SV_blank>***\\r\\n"" , WEXITSTATUS ( status ) ) ; return WEXITSTATUS ( status ) ; } else if ( WIFSIGNALED ( status ) ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>signal:<S2SV_blank>%d<S2SV_blank>***\\r\\n"" , WTERMSIG ( status ) ) ; return - 1 ; } else { fd_printf ( STO , ""\\r\\n***<S2SV_blank>abnormal<S2SV_blank>termination:<S2SV_blank>0x%x<S2SV_blank>***\\r\\n"" , r ) ; return - 1 ; } } else { long fl ; <S2SV_StartBug> char cmd [ 512 ] ; <S2SV_EndBug> term_remove ( STI ) ; term_erase ( fd ) ; fl = fcntl ( fd , F_GETFL ) ; fl &= ~ O_NONBLOCK ; fcntl ( fd , F_SETFL , fl ) ; close ( STI ) ; close ( STO ) ; dup2 ( fd , STI ) ; dup2 ( fd , STO ) ; <S2SV_StartBug> { <S2SV_EndBug> char * c , * ce ; const char * s ; int n ; va_list vls ; <S2SV_StartBug> strcpy ( cmd , EXEC ) ; <S2SV_EndBug> c = & cmd [ sizeof ( EXEC ) - 1 ] ; ce = cmd + sizeof ( cmd ) - 1 ; va_start ( vls , fd ) ; while ( ( s = va_arg ( vls , const char * ) ) ) { n = strlen ( s ) ; if ( c + n + 1 >= ce ) break ; memcpy ( c , s , n ) ; c += n ; * c ++ = '<S2SV_blank>' ; } va_end ( vls ) ; * c = '\\0' ; } <S2SV_StartBug> fd_printf ( STDERR_FILENO , ""%s\\n"" , & cmd [ sizeof ( EXEC ) - 1 ] ) ; <S2SV_EndBug> establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execl ( ""/bin/sh"" , ""sh"" , ""-c"" , cmd , NULL ) ; <S2SV_StartBug> exit ( 42 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> int fd , const char * cmd , const char * args_extra <S2SV_ModEnd> ) { pid_t <S2SV_ModStart> long fl ; int argc ; char * argv [ RUNCMD_ARGS_MAX + 1 ] ; int r <S2SV_ModEnd> ; term_remove ( <S2SV_ModStart> STO ) ; argc = 0 ; r = split_quoted <S2SV_ModEnd> ( cmd , <S2SV_ModStart> ( cmd , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , ""Cannot<S2SV_blank>parse<S2SV_blank>command\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } r = split_quoted ( args_extra , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , ""Cannot<S2SV_blank>parse<S2SV_blank>extra<S2SV_blank>args\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } if ( argc < 1 ) { fd_printf ( STDERR_FILENO , ""No<S2SV_blank>command<S2SV_blank>given\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } argv [ argc ] = NULL ; fd_printf ( STDERR_FILENO , ""$<S2SV_blank>%s<S2SV_blank>%s\\n"" , cmd , args_extra ) ; establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execvp ( argv [ 0 ] , argv ) ; <S2SV_ModEnd> fd_printf ( STDERR_FILENO <S2SV_ModStart> ( STDERR_FILENO , ""exec:<S2SV_blank>%s\\n"" , strerror ( errno ) <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ; exit ( RUNCMD_EXEC_FAIL <S2SV_ModEnd> ) ; }
",npat-efault@picocom/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,CVE-2015-9059,https://github.com/npat-efault/picocom/commit/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,2017-05-28T00:29Z,"<S2SV_StartBug> run_cmd ( int fd , ... ) <S2SV_EndBug> <S2SV_StartBug> char cmd [ 512 ] ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> strcpy ( cmd , EXEC ) ; <S2SV_EndBug> <S2SV_StartBug> fd_printf ( STDERR_FILENO , ""%s\\n"" , & cmd [ sizeof ( EXEC ) - 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( 42 ) ; <S2SV_EndBug>"
602,CWE-119,"static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ; <S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }
","<S2SV_ModStart> size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE
",FFmpeg@FFmpeg/2b46ebdbff1d8dec7a3d8ea280a612b91a582869,CVE-2018-1999011,https://github.com/FFmpeg/FFmpeg/commit/2b46ebdbff1d8dec7a3d8ea280a612b91a582869,2018-07-23T15:29Z,<S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug>
1191,CWE-20,"static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; for ( n = 0 ; n < num_images ; n ++ ) { if ( n != 0 ) { <S2SV_StartBug> AcquireNextImage ( image_info , image ) ; <S2SV_EndBug> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> 0 ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;
",ImageMagick@ImageMagick/504ada82b6fa38a30c846c1c29116af7290decb2,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/504ada82b6fa38a30c846c1c29116af7290decb2,2017-04-19T14:59Z,"<S2SV_StartBug> AcquireNextImage ( image_info , image ) ; <S2SV_EndBug>"
1931,CWE-119,"static vpx_codec_err_t ctrl_set_previewpp ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> # if CONFIG_VP9_POSTPROC <S2SV_StartBug> vp8_postproc_cfg_t * config = va_arg ( args , vp8_postproc_cfg_t * ) ; <S2SV_EndBug> ( void ) ctr_id ; if ( config != NULL ) { ctx -> preview_ppcfg = * config ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } # else ( void ) ctx ; <S2SV_StartBug> ( void ) ctr_id ; <S2SV_EndBug> ( void ) args ; return VPX_CODEC_INCAPABLE ; # endif }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> vp8_postproc_cfg_t * ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( void ) <S2SV_ModEnd> args ; return
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vp8_postproc_cfg_t * config = va_arg ( args , vp8_postproc_cfg_t * ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ctr_id ; <S2SV_EndBug>"
1155,CWE-119,"static void cliprdr_process ( STREAM s ) { uint16 type , status ; uint32 length , format ; uint8 * data ; <S2SV_StartBug> in_uint16_le ( s , type ) ; <S2SV_EndBug> in_uint16_le ( s , status ) ; in_uint32_le ( s , length ) ; data = s -> p ; logger ( Clipboard , Debug , ""cliprdr_process(),<S2SV_blank>type=%d,<S2SV_blank>status=%d,<S2SV_blank>length=%d"" , type , status , length ) ; <S2SV_StartBug> if ( status == CLIPRDR_ERROR ) <S2SV_EndBug> { switch ( type ) { case CLIPRDR_FORMAT_ACK : cliprdr_send_native_format_announce ( last_formats , last_formats_length ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_request_failed ( ) ; break ; default : logger ( Clipboard , Warning , ""cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>error<S2SV_blank>(type=%d)"" , type ) ; } return ; } switch ( type ) { case CLIPRDR_CONNECT : ui_clip_sync ( ) ; break ; case CLIPRDR_FORMAT_ANNOUNCE : ui_clip_format_announce ( data , length ) ; cliprdr_send_packet ( CLIPRDR_FORMAT_ACK , CLIPRDR_RESPONSE , NULL , 0 ) ; return ; case CLIPRDR_FORMAT_ACK : break ; case CLIPRDR_DATA_REQUEST : in_uint32_le ( s , format ) ; ui_clip_request_data ( format ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_handle_data ( data , length ) ; break ; case 7 : break ; default : logger ( Clipboard , Warning , ""cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>packet<S2SV_blank>type<S2SV_blank>%d"" , type ) ; } }
","<S2SV_ModStart> * data ; struct stream packet = * s ; <S2SV_ModStart> ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } if (
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-20182,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-03-15T18:29Z,"<S2SV_StartBug> in_uint16_le ( s , type ) ; <S2SV_EndBug> <S2SV_StartBug> if ( status == CLIPRDR_ERROR ) <S2SV_EndBug>"
3805,CWE-119,"static AVFrame * get_video_buffer ( AVFilterLink * inlink , int w , int h ) { PadContext * s = inlink -> dst -> priv ; AVFrame * frame = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , w + ( s -> w - s -> in_w ) , h + ( s -> h - s -> in_h ) ) ; int plane ; if ( ! frame ) return NULL ; frame -> width = w ; frame -> height = h ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int hsub = s -> draw . hsub [ plane ] ; int vsub = s -> draw . vsub [ plane ] ; frame -> data [ plane ] += ( s -> x >> hsub ) * s -> draw . pixelstep [ plane ] + ( s -> y >> vsub ) * frame -> linesize [ plane ] ; } return frame ; }
","<S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
",FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,CVE-2013-4263,https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,2013-11-23T17:55Z,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug>
3563,CWE-400,"static struct mnt_namespace * create_mnt_ns ( struct vfsmount * m ) { struct mnt_namespace * new_ns = alloc_mnt_ns ( & init_user_ns ) ; if ( ! IS_ERR ( new_ns ) ) { struct mount * mnt = real_mount ( m ) ; mnt -> mnt_ns = new_ns ; new_ns -> root = mnt ; <S2SV_StartBug> list_add ( & mnt -> mnt_list , & new_ns -> list ) ; <S2SV_EndBug> } else { mntput ( m ) ; } return new_ns ; }
","<S2SV_ModStart> = mnt ; new_ns -> mounts ++ ;
",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z,"<S2SV_StartBug> list_add ( & mnt -> mnt_list , & new_ns -> list ) ; <S2SV_EndBug>"
2420,CWE-416,"static void free_user ( struct kref * ref ) { struct ipmi_user * user = container_of ( ref , struct ipmi_user , refcount ) ; <S2SV_StartBug> kfree ( user ) ; <S2SV_EndBug> }
","<S2SV_ModStart> refcount ) ; cleanup_srcu_struct ( & user -> release_barrier ) ;
",torvalds@linux/77f8269606bf95fcb232ee86f6da80886f1dfae8,CVE-2019-9003,https://github.com/torvalds/linux/commit/77f8269606bf95fcb232ee86f6da80886f1dfae8,2019-02-22T15:29Z,<S2SV_StartBug> kfree ( user ) ; <S2SV_EndBug>
3592,CWE-119,"void Strgrow ( Str x ) { char * old = x -> ptr ; int newlen ; <S2SV_StartBug> newlen = x -> length * 6 / 5 ; <S2SV_EndBug> <S2SV_StartBug> if ( newlen == x -> length ) <S2SV_EndBug> newlen += 2 ; x -> ptr = GC_MALLOC_ATOMIC ( newlen ) ; x -> area_size = newlen ; bcopy ( ( void * ) old , ( void * ) x -> ptr , x -> length ) ; GC_free ( old ) ; }
","<S2SV_ModStart> = x -> area_size <S2SV_ModEnd> * 6 / <S2SV_ModStart> == x -> area_size <S2SV_ModEnd> ) newlen +=
",tats@w3m/d43527cfa0dbb3ccefec4a6f7b32c1434739aa29,CVE-2016-9442,https://github.com/tats/w3m/commit/d43527cfa0dbb3ccefec4a6f7b32c1434739aa29,2016-12-12T02:59Z,<S2SV_StartBug> newlen = x -> length * 6 / 5 ; <S2SV_EndBug> <S2SV_StartBug> if ( newlen == x -> length ) <S2SV_EndBug>
6560,CWE-119,"static const char * skip ( const char * in ) { while ( in && * in && ( unsigned char ) * in <= 32 ) in ++ ; return in ; }
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,
2042,CWE-119,"<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><options><S2SV_blank>-o<S2SV_blank>dst_filename<S2SV_blank>src_filename<S2SV_blank>\\n"" , exec_name ) ; fprintf ( stderr , ""\\nOptions:\\n"" ) ; arg_show_usage ( stderr , main_args ) ; fprintf ( stderr , ""\\nEncoder<S2SV_blank>Global<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , global_args ) ; fprintf ( stderr , ""\\nRate<S2SV_blank>Control<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , rc_args ) ; fprintf ( stderr , ""\\nTwopass<S2SV_blank>Rate<S2SV_blank>Control<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , rc_twopass_args ) ; fprintf ( stderr , ""\\nKeyframe<S2SV_blank>Placement<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , kf_args ) ; # if CONFIG_VP8_ENCODER fprintf ( stderr , ""\\nVP8<S2SV_blank>Specific<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , vp8_args ) ; # endif # if CONFIG_VP9_ENCODER fprintf ( stderr , ""\\nVP9<S2SV_blank>Specific<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , vp9_args ) ; # endif <S2SV_StartBug> fprintf ( stderr , ""\\nStream<S2SV_blank>timebase<S2SV_blank>(--timebase):\\n"" <S2SV_EndBug> ""<S2SV_blank><S2SV_blank>The<S2SV_blank>desired<S2SV_blank>precision<S2SV_blank>of<S2SV_blank>timestamps<S2SV_blank>in<S2SV_blank>the<S2SV_blank>output,<S2SV_blank>expressed\\n"" ""<S2SV_blank><S2SV_blank>in<S2SV_blank>fractional<S2SV_blank>seconds.<S2SV_blank>Default<S2SV_blank>is<S2SV_blank>1/1000.\\n"" ) ; fprintf ( stderr , ""\\nIncluded<S2SV_blank>encoders:\\n\\n"" ) ; <S2SV_StartBug> for ( i = 0 ; i < get_vpx_encoder_count ( ) ; ++ i ) { <S2SV_EndBug> const VpxInterface * const encoder = get_vpx_encoder_by_index ( i ) ; <S2SV_StartBug> fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> encoder -> name , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> exit ( EXIT_FAILURE ) ; }
","<S2SV_ModStart> void usage_exit ( void <S2SV_ModStart> { int i ; const int num_encoder = get_vpx_encoder_count ( ) <S2SV_ModStart> ; # endif # if CONFIG_VP10_ENCODER fprintf ( stderr , ""\\nVP10<S2SV_blank>Specific<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , vp10_args ) ; # endif <S2SV_ModStart> ; i < num_encoder <S2SV_ModEnd> ; ++ i <S2SV_ModStart> i ) ; const char * defstr = ( i == ( num_encoder - 1 ) ) ? ""(default)"" : """" ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>%s\\n"" <S2SV_ModEnd> , encoder -> <S2SV_ModStart> ( encoder -> codec_interface ( ) ) , defstr <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } fprintf ( stderr , ""\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; fprintf ( stderr , ""Use<S2SV_blank>--codec<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>a<S2SV_blank>non-default<S2SV_blank>encoder.\\n\\n"" ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""\\nStream<S2SV_blank>timebase<S2SV_blank>(--timebase):\\n"" <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < get_vpx_encoder_count ( ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> encoder -> name , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
110,CWE-119,"<S2SV_StartBug> int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) <S2SV_EndBug> { u16 * op ; int size ; unicode_t u ; op = pwcs ; <S2SV_StartBug> while ( * s && len > 0 ) { <S2SV_EndBug> if ( * s & 0x80 ) { size = utf8_to_utf32 ( s , len , & u ) ; if ( size < 0 ) return - EINVAL ; <S2SV_StartBug> if ( u >= PLANE_SIZE ) { <S2SV_EndBug> <S2SV_StartBug> u -= PLANE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | <S2SV_EndBug> <S2SV_StartBug> ( ( u >> 10 ) & SURROGATE_BITS ) ) ; <S2SV_EndBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW | <S2SV_StartBug> ( u & SURROGATE_BITS ) ) ; <S2SV_EndBug> } else { <S2SV_StartBug> * op ++ = ( wchar_t ) u ; <S2SV_EndBug> } s += size ; len -= size ; } else { <S2SV_StartBug> * op ++ = * s ++ ; <S2SV_EndBug> len -- ; } } return op - pwcs ; }
","<S2SV_ModStart> int len , enum utf16_endian endian , <S2SV_ModStart> wchar_t * pwcs , int maxlen <S2SV_ModStart> ; while ( <S2SV_ModEnd> len > 0 <S2SV_ModStart> len > 0 && maxlen > 0 && * s <S2SV_ModStart> - EINVAL ; s += size ; len -= size ; <S2SV_ModStart> PLANE_SIZE ) { if ( maxlen < 2 ) break ; <S2SV_ModStart> -= PLANE_SIZE ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | ( <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | SURROGATE_LOW <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; maxlen -= 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <S2SV_ModEnd> } else { <S2SV_ModStart> } else { put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <S2SV_ModEnd> -- ; }
",torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,CVE-2013-1773,https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,2013-02-28T19:55Z,"<S2SV_StartBug> int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) <S2SV_EndBug> <S2SV_StartBug> while ( * s && len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( u >= PLANE_SIZE ) { <S2SV_EndBug> <S2SV_StartBug> u -= PLANE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | <S2SV_EndBug> <S2SV_StartBug> ( ( u >> 10 ) & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( u & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) u ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = * s ++ ; <S2SV_EndBug>"
3020,CWE-399,"static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = VM_FAULT_BADCONTEXT ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ; retry : down_read ( & mm -> mmap_sem ) ; fault = VM_FAULT_BADMAP ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = VM_FAULT_BADACCESS ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= HPAGE_MASK ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) goto out_up ; if ( flags & FAULT_FLAG_ALLOW_RETRY ) { if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> regs , address ) ; } else { tsk -> min_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> regs , address ) ; } if ( fault & VM_FAULT_RETRY ) { flags &= ~ FAULT_FLAG_ALLOW_RETRY ; goto retry ; } } clear_tsk_thread_flag ( tsk , TIF_PER_TRAP ) ; fault = 0 ; out_up : up_read ( & mm -> mmap_sem ) ; out : return fault ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug>"
4806,CWE-444,"VALUE request_env ( agooReq req , VALUE self ) { if ( Qnil == ( VALUE ) req -> env ) { volatile VALUE env = rb_hash_new ( ) ; rb_hash_aset ( env , request_method_val , req_method ( req ) ) ; rb_hash_aset ( env , script_name_val , req_script_name ( req ) ) ; rb_hash_aset ( env , path_info_val , req_path_info ( req ) ) ; rb_hash_aset ( env , query_string_val , req_query_string ( req ) ) ; <S2SV_StartBug> rb_hash_aset ( env , server_name_val , req_server_name ( req ) ) ; <S2SV_EndBug> rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ; fill_headers ( req , env ) ; rb_hash_aset ( env , rack_version_val , rack_version_val_val ) ; rb_hash_aset ( env , rack_url_scheme_val , req_rack_url_scheme ( req ) ) ; rb_hash_aset ( env , rack_input_val , req_rack_input ( req ) ) ; rb_hash_aset ( env , rack_errors_val , req_rack_errors ( req ) ) ; rb_hash_aset ( env , rack_multithread_val , req_rack_multithread ( req ) ) ; rb_hash_aset ( env , rack_multiprocess_val , Qfalse ) ; rb_hash_aset ( env , rack_run_once_val , Qfalse ) ; rb_hash_aset ( env , rack_logger_val , req_rack_logger ( req ) ) ; rb_hash_aset ( env , rack_upgrade_val , req_rack_upgrade ( req ) ) ; rb_hash_aset ( env , rack_hijackq_val , Qtrue ) ; rb_hash_aset ( env , rack_hijack_val , self ) ; rb_hash_aset ( env , rack_hijack_io_val , Qnil ) ; if ( agoo_server . rack_early_hints ) { volatile VALUE eh = agoo_early_hints_new ( req ) ; rb_hash_aset ( env , early_hints_val , eh ) ; } req -> env = ( void * ) env ; } return ( VALUE ) req -> env ; }
","<S2SV_ModStart> ( env , remote_addr_val , req_remote_addr ( req ) ) ; rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ; rb_hash_aset ( env , <S2SV_ModStart> server_name_val , req_server_name <S2SV_ModEnd> ( req )
",ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130,CVE-2020-7670,https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130,2020-06-10T16:15Z,"<S2SV_StartBug> rb_hash_aset ( env , server_name_val , req_server_name ( req ) ) ; <S2SV_EndBug>"
3110,CWE-125,"void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; enum request_type type ; struct device * d = devlist ; unsigned char rbuf [ RESPONSE_BUFFER_SIZE ] ; unsigned char * rp ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ; goto error ; } if ( l == 0 && type != MINISSDPD_SEARCH_ALL && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0,<S2SV_blank>type=%d)"" , type ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case MINISSDPD_GET_VERSION : rp = rbuf ; CODELENGTH ( ( sizeof ( MINISSDPD_VERSION ) - 1 ) , rp ) ; memcpy ( rp , MINISSDPD_VERSION , sizeof ( MINISSDPD_VERSION ) - 1 ) ; rp += ( sizeof ( MINISSDPD_VERSION ) - 1 ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ; while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ; if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>already<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; sendNotifications ( NOTIF_NEW , NULL , newserv ) ; newserv = NULL ; break ; case MINISSDPD_NOTIF : rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } req -> is_notify = 1 ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }
","<S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p )
",miniupnp@miniupnp/b238cade9a173c6f751a34acf8ccff838a62aa47,CVE-2016-3178,https://github.com/miniupnp/miniupnp/commit/b238cade9a173c6f751a34acf8ccff838a62aa47,2017-03-24T15:59Z,<S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug>
4537,CWE-125,"static int ast_type_init ( PyObject * self , PyObject * args , PyObject * kw ) { <S2SV_StartBug> _Py_IDENTIFIER ( _fields ) ; <S2SV_EndBug> Py_ssize_t i , numfields = 0 ; int res = - 1 ; PyObject * key , * value , * fields ; <S2SV_StartBug> fields = _PyObject_GetAttrId ( ( PyObject * ) Py_TYPE ( self ) , & PyId__fields ) ; <S2SV_EndBug> if ( ! fields ) PyErr_Clear ( ) ; if ( fields ) { numfields = PySequence_Size ( fields ) ; if ( numfields == - 1 ) goto cleanup ; } res = 0 ; <S2SV_StartBug> if ( PyTuple_GET_SIZE ( args ) > 0 ) { <S2SV_EndBug> if ( numfields != PyTuple_GET_SIZE ( args ) ) { <S2SV_StartBug> PyErr_Format ( PyExc_TypeError , ""%.400s<S2SV_blank>constructor<S2SV_blank>takes<S2SV_blank>%s"" <S2SV_EndBug> ""%zd<S2SV_blank>positional<S2SV_blank>argument%s"" , <S2SV_StartBug> Py_TYPE ( self ) -> tp_name , <S2SV_EndBug> numfields == 0 ? """" : ""either<S2SV_blank>0<S2SV_blank>or<S2SV_blank>"" , numfields , numfields == 1 ? """" : ""s"" ) ; res = - 1 ; goto cleanup ; } for ( i = 0 ; i < PyTuple_GET_SIZE ( args ) ; i ++ ) { PyObject * name = PySequence_GetItem ( fields , i ) ; if ( ! name ) { res = - 1 ; goto cleanup ; } res = PyObject_SetAttr ( self , name , PyTuple_GET_ITEM ( args , i ) ) ; Py_DECREF ( name ) ; if ( res < 0 ) goto cleanup ; } <S2SV_StartBug> } <S2SV_EndBug> if ( kw ) { i = 0 ; while ( PyDict_Next ( kw , & i , & key , & value ) ) { res = PyObject_SetAttr ( self , key , value ) ; if ( res < 0 ) goto cleanup ; } } cleanup : Py_XDECREF ( fields ) ; return res ; }
","<S2SV_ModStart> kw ) { <S2SV_ModEnd> Py_ssize_t i , <S2SV_ModStart> * fields ; if ( lookup_attr_id <S2SV_ModEnd> ( ( PyObject <S2SV_ModStart> , & PyId__fields , & fields ) < 0 ) { goto cleanup ; } <S2SV_ModEnd> if ( fields <S2SV_ModStart> ; if ( numfields < <S2SV_ModStart> ( args ) <S2SV_ModEnd> ) { PyErr_Format <S2SV_ModStart> ( PyExc_TypeError , ""%.400s<S2SV_blank>constructor<S2SV_blank>takes<S2SV_blank>at<S2SV_blank>most<S2SV_blank>"" <S2SV_ModEnd> ""%zd<S2SV_blank>positional<S2SV_blank>argument%s"" , Py_TYPE <S2SV_ModStart> ) -> tp_name <S2SV_ModEnd> , numfields , <S2SV_ModStart> cleanup ; } <S2SV_ModEnd> if ( kw
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> _Py_IDENTIFIER ( _fields ) ; <S2SV_EndBug> <S2SV_StartBug> fields = _PyObject_GetAttrId ( ( PyObject * ) Py_TYPE ( self ) , & PyId__fields ) ; <S2SV_EndBug> <S2SV_StartBug> if ( PyTuple_GET_SIZE ( args ) > 0 ) { <S2SV_EndBug> <S2SV_StartBug> PyErr_Format ( PyExc_TypeError , ""%.400s<S2SV_blank>constructor<S2SV_blank>takes<S2SV_blank>%s"" <S2SV_EndBug> <S2SV_StartBug> Py_TYPE ( self ) -> tp_name , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
1066,CWE-125,"static u_int ieee802_11_print ( netdissect_options * ndo , const u_char * p , u_int length , u_int orig_caplen , int pad , u_int fcslen ) { uint16_t fc ; u_int caplen , hdrlen , meshdrlen ; struct lladdr_info src , dst ; int llc_hdrlen ; caplen = orig_caplen ; if ( length < fcslen ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return caplen ; } length -= fcslen ; if ( caplen > length ) { fcslen = caplen - length ; caplen -= fcslen ; ndo -> ndo_snapend -= fcslen ; } if ( caplen < IEEE802_11_FC_LEN ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return orig_caplen ; } fc = EXTRACT_LE_16BITS ( p ) ; hdrlen = extract_header_length ( ndo , fc ) ; if ( hdrlen == 0 ) { return ( 0 ) ; } if ( pad ) hdrlen = roundup2 ( hdrlen , 4 ) ; if ( ndo -> ndo_Hflag && FC_TYPE ( fc ) == T_DATA && DATA_FRAME_IS_QOS ( FC_SUBTYPE ( fc ) ) ) { <S2SV_StartBug> meshdrlen = extract_mesh_header_length ( p + hdrlen ) ; <S2SV_EndBug> hdrlen += meshdrlen ; } else meshdrlen = 0 ; if ( caplen < hdrlen ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } if ( ndo -> ndo_eflag ) ieee_802_11_hdr_print ( ndo , fc , p , hdrlen , meshdrlen ) ; length -= hdrlen ; caplen -= hdrlen ; p += hdrlen ; src . addr_string = etheraddr_string ; dst . addr_string = etheraddr_string ; switch ( FC_TYPE ( fc ) ) { case T_MGMT : get_mgmt_src_dst_mac ( p - hdrlen , & src . addr , & dst . addr ) ; if ( ! mgmt_body_print ( ndo , fc , src . addr , p , length ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } break ; case T_CTRL : if ( ! ctrl_body_print ( ndo , fc , p - hdrlen ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } break ; case T_DATA : if ( DATA_FRAME_IS_NULL ( FC_SUBTYPE ( fc ) ) ) return hdrlen ; if ( FC_PROTECTED ( fc ) ) { ND_PRINT ( ( ndo , ""Data"" ) ) ; if ( ! wep_print ( ndo , p ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } } else { get_data_src_dst_mac ( fc , p - hdrlen , & src . addr , & dst . addr ) ; llc_hdrlen = llc_print ( ndo , p , length , caplen , & src , & dst ) ; if ( llc_hdrlen < 0 ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; llc_hdrlen = - llc_hdrlen ; } hdrlen += llc_hdrlen ; } break ; default : break ; } return hdrlen ; }
","<S2SV_ModStart> ) ) { if ( caplen < hdrlen + 1 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; }
",the-tcpdump-group@tcpdump/4846b3c5d0a850e860baf4f07340495d29837d09,CVE-2018-16227,https://github.com/the-tcpdump-group/tcpdump/commit/4846b3c5d0a850e860baf4f07340495d29837d09,2019-10-03T16:15Z,<S2SV_StartBug> meshdrlen = extract_mesh_header_length ( p + hdrlen ) ; <S2SV_EndBug>
3107,CWE-20,"static int dccp_error ( struct net * net , struct nf_conn * tmpl , struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info * ctinfo , u_int8_t pf , unsigned int hooknum ) { struct dccp_hdr _dh , * dh ; unsigned int dccp_len = skb -> len - dataoff ; unsigned int cscov ; const char * msg ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> if ( dh == NULL ) { msg = ""nf_ct_dccp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>"" ; goto out_invalid ; } if ( dh -> dccph_doff * 4 < sizeof ( struct dccp_hdr ) || dh -> dccph_doff * 4 > dccp_len ) { msg = ""nf_ct_dccp:<S2SV_blank>truncated/malformed<S2SV_blank>packet<S2SV_blank>"" ; goto out_invalid ; } cscov = dccp_len ; if ( dh -> dccph_cscov ) { cscov = ( dh -> dccph_cscov - 1 ) * 4 ; if ( cscov > dccp_len ) { msg = ""nf_ct_dccp:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>coverage<S2SV_blank>"" ; goto out_invalid ; } } if ( net -> ct . sysctl_checksum && hooknum == NF_INET_PRE_ROUTING && nf_checksum_partial ( skb , hooknum , dataoff , cscov , IPPROTO_DCCP , pf ) ) { msg = ""nf_ct_dccp:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>"" ; goto out_invalid ; } if ( dh -> dccph_type >= DCCP_PKT_INVALID ) { msg = ""nf_ct_dccp:<S2SV_blank>reserved<S2SV_blank>packet<S2SV_blank>type<S2SV_blank>"" ; goto out_invalid ; } return NF_ACCEPT ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return - NF_ACCEPT ; }
","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; if
",torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug>"
4518,CWE-125,"static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ; <S2SV_StartBug> tok -> level = 0 ; <S2SV_EndBug> tok -> altwarning = 1 ; tok -> alterror = 1 ; tok -> alttabsize = 1 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; # ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; # endif tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ; <S2SV_StartBug> return tok ; <S2SV_EndBug> }
","<S2SV_ModStart> level = 0 <S2SV_ModEnd> ; tok -> <S2SV_ModStart> = 0 ; tok -> async_always = 0 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> tok -> level = 0 ; <S2SV_EndBug> <S2SV_StartBug> return tok ; <S2SV_EndBug>
1272,CWE-125,"static int read_header ( struct archive_read * a , struct archive_entry * entry , char head_type ) { const void * h ; const char * p , * endp ; struct rar * rar ; struct rar_header rar_header ; struct rar_file_header file_header ; int64_t header_size ; unsigned filename_size , end ; char * filename ; char * strp ; char packed_size [ 8 ] ; char unp_size [ 8 ] ; int ttime ; struct archive_string_conv * sconv , * fn_sconv ; unsigned long crc32_val ; int ret = ( ARCHIVE_OK ) , ret2 ; rar = ( struct rar * ) ( a -> format -> data ) ; sconv = rar -> opt_sconv ; if ( sconv == NULL ) { if ( ! rar -> init_default_conversion ) { rar -> sconv_default = archive_string_default_conversion_for_read ( & ( a -> archive ) ) ; rar -> init_default_conversion = 1 ; } sconv = rar -> sconv_default ; } if ( ( h = __archive_read_ahead ( a , 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; p = h ; memcpy ( & rar_header , p , sizeof ( rar_header ) ) ; rar -> file_flags = archive_le16dec ( rar_header . flags ) ; header_size = archive_le16dec ( rar_header . size ) ; if ( header_size < ( int64_t ) sizeof ( file_header ) + 7 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } crc32_val = crc32 ( 0 , ( const unsigned char * ) p + 2 , 7 - 2 ) ; __archive_read_consume ( a , 7 ) ; if ( ! ( rar -> file_flags & FHD_SOLID ) ) { rar -> compression_method = 0 ; rar -> packed_size = 0 ; rar -> unp_size = 0 ; rar -> mtime = 0 ; rar -> ctime = 0 ; rar -> atime = 0 ; rar -> arctime = 0 ; rar -> mode = 0 ; memset ( & rar -> salt , 0 , sizeof ( rar -> salt ) ) ; rar -> atime = 0 ; rar -> ansec = 0 ; rar -> ctime = 0 ; rar -> cnsec = 0 ; rar -> mtime = 0 ; rar -> mnsec = 0 ; rar -> arctime = 0 ; rar -> arcnsec = 0 ; } else { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""RAR<S2SV_blank>solid<S2SV_blank>archive<S2SV_blank>support<S2SV_blank>unavailable."" ) ; return ( ARCHIVE_FATAL ) ; } if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; crc32_val = crc32 ( crc32_val , h , ( unsigned ) ( header_size - 7 ) ) ; if ( ( crc32_val & 0xffff ) != archive_le16dec ( rar_header . crc ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Header<S2SV_blank>CRC<S2SV_blank>error"" ) ; return ( ARCHIVE_FATAL ) ; } p = h ; endp = p + header_size - 7 ; memcpy ( & file_header , p , sizeof ( file_header ) ) ; p += sizeof ( file_header ) ; rar -> compression_method = file_header . method ; ttime = archive_le32dec ( file_header . file_time ) ; rar -> mtime = get_time ( ttime ) ; rar -> file_crc = archive_le32dec ( file_header . file_crc ) ; if ( rar -> file_flags & FHD_PASSWORD ) { archive_entry_set_is_data_encrypted ( entry , 1 ) ; rar -> has_encrypted_entries = 1 ; archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""RAR<S2SV_blank>encryption<S2SV_blank>support<S2SV_blank>unavailable."" ) ; } if ( rar -> file_flags & FHD_LARGE ) { memcpy ( packed_size , file_header . pack_size , 4 ) ; memcpy ( packed_size + 4 , p , 4 ) ; p += 4 ; memcpy ( unp_size , file_header . unp_size , 4 ) ; memcpy ( unp_size + 4 , p , 4 ) ; p += 4 ; rar -> packed_size = archive_le64dec ( & packed_size ) ; rar -> unp_size = archive_le64dec ( & unp_size ) ; } else { rar -> packed_size = archive_le32dec ( file_header . pack_size ) ; rar -> unp_size = archive_le32dec ( file_header . unp_size ) ; } if ( rar -> packed_size < 0 || rar -> unp_size < 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>sizes<S2SV_blank>specified."" ) ; return ( ARCHIVE_FATAL ) ; } rar -> bytes_remaining = rar -> packed_size ; if ( head_type == NEWSUB_HEAD ) { size_t distance = p - ( const char * ) h ; header_size += rar -> packed_size ; if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; p = h ; endp = p + header_size - 7 ; p += distance ; } filename_size = archive_le16dec ( file_header . name_size ) ; if ( p + filename_size > endp ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>filename<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } if ( rar -> filename_allocated < filename_size * 2 + 2 ) { char * newptr ; size_t newsize = filename_size * 2 + 2 ; newptr = realloc ( rar -> filename , newsize ) ; if ( newptr == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory."" ) ; return ( ARCHIVE_FATAL ) ; } rar -> filename = newptr ; rar -> filename_allocated = newsize ; } filename = rar -> filename ; memcpy ( filename , p , filename_size ) ; filename [ filename_size ] = '\\0' ; if ( rar -> file_flags & FHD_UNICODE ) { if ( filename_size != strlen ( filename ) ) { unsigned char highbyte , flagbits , flagbyte ; unsigned fn_end , offset ; end = filename_size ; fn_end = filename_size * 2 ; filename_size = 0 ; offset = ( unsigned ) strlen ( filename ) + 1 ; highbyte = * ( p + offset ++ ) ; flagbits = 0 ; flagbyte = 0 ; while ( offset < end && filename_size < fn_end ) { if ( ! flagbits ) { flagbyte = * ( p + offset ++ ) ; flagbits = 8 ; } flagbits -= 2 ; switch ( ( flagbyte >> flagbits ) & 3 ) { case 0 : filename [ filename_size ++ ] = '\\0' ; filename [ filename_size ++ ] = * ( p + offset ++ ) ; break ; case 1 : filename [ filename_size ++ ] = highbyte ; filename [ filename_size ++ ] = * ( p + offset ++ ) ; break ; case 2 : filename [ filename_size ++ ] = * ( p + offset + 1 ) ; filename [ filename_size ++ ] = * ( p + offset ) ; offset += 2 ; break ; case 3 : { char extra , high ; uint8_t length = * ( p + offset ++ ) ; if ( length & 0x80 ) { extra = * ( p + offset ++ ) ; high = ( char ) highbyte ; } else extra = high = 0 ; length = ( length & 0x7f ) + 2 ; while ( length && filename_size < fn_end ) { unsigned cp = filename_size >> 1 ; filename [ filename_size ++ ] = high ; filename [ filename_size ++ ] = p [ cp ] + extra ; length -- ; } } break ; } } if ( filename_size > fn_end ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>filename"" ) ; return ( ARCHIVE_FATAL ) ; } filename [ filename_size ++ ] = '\\0' ; <S2SV_StartBug> filename [ filename_size ++ ] = '\\0' ; <S2SV_EndBug> if ( rar -> sconv_utf16be == NULL ) { rar -> sconv_utf16be = archive_string_conversion_from_charset ( & a -> archive , ""UTF-16BE"" , 1 ) ; if ( rar -> sconv_utf16be == NULL ) return ( ARCHIVE_FATAL ) ; } fn_sconv = rar -> sconv_utf16be ; strp = filename ; while ( memcmp ( strp , ""\\x00\\x00"" , 2 ) ) { if ( ! memcmp ( strp , ""\\x00\\\\"" , 2 ) ) * ( strp + 1 ) = '/' ; strp += 2 ; } p += offset ; } else { if ( rar -> sconv_utf8 == NULL ) { rar -> sconv_utf8 = archive_string_conversion_from_charset ( & a -> archive , ""UTF-8"" , 1 ) ; if ( rar -> sconv_utf8 == NULL ) return ( ARCHIVE_FATAL ) ; } fn_sconv = rar -> sconv_utf8 ; while ( ( strp = strchr ( filename , '\\\\' ) ) != NULL ) * strp = '/' ; p += filename_size ; } } else { fn_sconv = sconv ; while ( ( strp = strchr ( filename , '\\\\' ) ) != NULL ) * strp = '/' ; p += filename_size ; } if ( rar -> filename_save && filename_size == rar -> filename_save_size && ! memcmp ( rar -> filename , rar -> filename_save , filename_size + 1 ) ) { __archive_read_consume ( a , header_size - 7 ) ; rar -> cursor ++ ; if ( rar -> cursor >= rar -> nodes ) { rar -> nodes ++ ; if ( ( rar -> dbo = realloc ( rar -> dbo , sizeof ( * rar -> dbo ) * rar -> nodes ) ) == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory."" ) ; return ( ARCHIVE_FATAL ) ; } rar -> dbo [ rar -> cursor ] . header_size = header_size ; rar -> dbo [ rar -> cursor ] . start_offset = - 1 ; rar -> dbo [ rar -> cursor ] . end_offset = - 1 ; } if ( rar -> dbo [ rar -> cursor ] . start_offset < 0 ) { rar -> dbo [ rar -> cursor ] . start_offset = a -> filter -> position ; rar -> dbo [ rar -> cursor ] . end_offset = rar -> dbo [ rar -> cursor ] . start_offset + rar -> packed_size ; } return ret ; } rar -> filename_save = ( char * ) realloc ( rar -> filename_save , filename_size + 1 ) ; memcpy ( rar -> filename_save , rar -> filename , filename_size + 1 ) ; rar -> filename_save_size = filename_size ; free ( rar -> dbo ) ; if ( ( rar -> dbo = calloc ( 1 , sizeof ( * rar -> dbo ) ) ) == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory."" ) ; return ( ARCHIVE_FATAL ) ; } rar -> dbo [ 0 ] . header_size = header_size ; rar -> dbo [ 0 ] . start_offset = - 1 ; rar -> dbo [ 0 ] . end_offset = - 1 ; rar -> cursor = 0 ; rar -> nodes = 1 ; if ( rar -> file_flags & FHD_SALT ) { if ( p + 8 > endp ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } memcpy ( rar -> salt , p , 8 ) ; p += 8 ; } if ( rar -> file_flags & FHD_EXTTIME ) { if ( read_exttime ( p , rar , endp ) < 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } } __archive_read_consume ( a , header_size - 7 ) ; rar -> dbo [ 0 ] . start_offset = a -> filter -> position ; rar -> dbo [ 0 ] . end_offset = rar -> dbo [ 0 ] . start_offset + rar -> packed_size ; switch ( file_header . host_os ) { case OS_MSDOS : case OS_OS2 : case OS_WIN32 : rar -> mode = archive_le32dec ( file_header . file_attr ) ; if ( rar -> mode & FILE_ATTRIBUTE_DIRECTORY ) rar -> mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH ; else rar -> mode = AE_IFREG ; rar -> mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ; break ; case OS_UNIX : case OS_MAC_OS : case OS_BEOS : rar -> mode = archive_le32dec ( file_header . file_attr ) ; break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Unknown<S2SV_blank>file<S2SV_blank>attributes<S2SV_blank>from<S2SV_blank>RAR<S2SV_blank>file\'s<S2SV_blank>host<S2SV_blank>OS"" ) ; return ( ARCHIVE_FATAL ) ; } rar -> bytes_uncopied = rar -> bytes_unconsumed = 0 ; rar -> lzss . position = rar -> offset = 0 ; rar -> offset_seek = 0 ; rar -> dictionary_size = 0 ; rar -> offset_outgoing = 0 ; rar -> br . cache_avail = 0 ; rar -> br . avail_in = 0 ; rar -> crc_calculated = 0 ; rar -> entry_eof = 0 ; rar -> valid = 1 ; rar -> is_ppmd_block = 0 ; rar -> start_new_table = 1 ; free ( rar -> unp_buffer ) ; rar -> unp_buffer = NULL ; rar -> unp_offset = 0 ; rar -> unp_buffer_size = UNP_BUFFER_SIZE ; memset ( rar -> lengthtable , 0 , sizeof ( rar -> lengthtable ) ) ; __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context , & g_szalloc ) ; rar -> ppmd_valid = rar -> ppmd_eod = 0 ; if ( head_type == NEWSUB_HEAD ) return ret ; archive_entry_set_mtime ( entry , rar -> mtime , rar -> mnsec ) ; archive_entry_set_ctime ( entry , rar -> ctime , rar -> cnsec ) ; archive_entry_set_atime ( entry , rar -> atime , rar -> ansec ) ; archive_entry_set_size ( entry , rar -> unp_size ) ; archive_entry_set_mode ( entry , rar -> mode ) ; if ( archive_entry_copy_pathname_l ( entry , filename , filename_size , fn_sconv ) ) { if ( errno == ENOMEM ) { archive_set_error ( & a -> archive , ENOMEM , ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Pathname"" ) ; return ( ARCHIVE_FATAL ) ; } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Pathname<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>current<S2SV_blank>locale."" , archive_string_conversion_charset_name ( fn_sconv ) ) ; ret = ( ARCHIVE_WARN ) ; } if ( ( ( rar -> mode ) & AE_IFMT ) == AE_IFLNK ) { rar -> bytes_remaining = 0 ; archive_entry_set_size ( entry , 0 ) ; if ( ( ret2 = read_symlink_stored ( a , entry , sconv ) ) < ( ARCHIVE_WARN ) ) return ret2 ; if ( ret > ret2 ) ret = ret2 ; } if ( rar -> bytes_remaining == 0 ) rar -> entry_eof = 1 ; return ret ; }
","<S2SV_ModStart> filename [ filename_size <S2SV_ModEnd> ] = '\\0'
",libarchive@libarchive/5562545b5562f6d12a4ef991fae158bf4ccf92b6,CVE-2017-14502,https://github.com/libarchive/libarchive/commit/5562545b5562f6d12a4ef991fae158bf4ccf92b6,2017-09-17T18:29Z,<S2SV_StartBug> filename [ filename_size ++ ] = '\\0' ; <S2SV_EndBug>
1104,CWE-119,"WORD32 ih264d_parse_islice_data_cavlc ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; do { UWORD8 u1_mb_type ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; { UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; UWORD32 u4_word , u4_ldz , u4_temp ; NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_ldz = CLZ ( u4_word ) ; u4_bitstream_offset += ( u4_ldz + 1 ) ; u4_word = 0 ; if ( u4_ldz ) GETBITS ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf , u4_ldz ) ; * pu4_bitstrm_ofst = u4_bitstream_offset ; u4_temp = ( ( 1 << u4_ldz ) + u4_word - 1 ) ; if ( u4_temp > 25 ) return ERROR_MB_TYPE ; u1_mb_type = u4_temp ; } ps_cur_mb_info -> u1_mb_type = u1_mb_type ; COPYTHECONTEXT ( ""u1_mb_type"" , u1_mb_type ) ; if ( 25 == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = 0 ; } else { ret = ih264d_parse_imb_cavlc ( ps_dec , ps_cur_mb_info , u1_num_mbs , u1_mb_type ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; uc_more_data_flag = MORE_RBSP_DATA ( ps_bitstrm ) ; { mv_pred_t * ps_mv_nmb_start = ps_dec -> ps_mv_cur + ( u1_num_mbs << 4 ) ; mv_pred_t s_mvPred = { { 0 , 0 , 0 , 0 } , { - 1 , - 1 } , 0 , 0 } ; ih264d_rep_mv_colz ( ps_dec , & s_mvPred , ps_mv_nmb_start , 0 , ( UWORD8 ) ( ps_dec -> u1_cur_mb_fld_dec_flag << 1 ) , 4 , 4 ) ; } if ( ps_dec -> u4_num_cores < 3 ) { if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ps_dec -> pf_compute_bs ( ps_dec , ps_cur_mb_info , ( UWORD16 ) ( u1_num_mbs >> u1_mbaff ) ) ; } u1_num_mbs ++ ; <S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || ( ! uc_more_data_flag ) ; ps_cur_mb_info -> u1_end_of_slice = ( ! uc_more_data_flag ) ; if ( u1_tfr_n_mb || ( ! uc_more_data_flag ) ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } while ( uc_more_data_flag ) ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice << u1_mbaff ) ; return ret ; }
","<S2SV_ModStart> u1_num_mbs ++ ; <S2SV_ModEnd> u1_num_mbs_next = i2_pic_wdin_mbs <S2SV_ModStart> ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
",external@libavc/4a524d3a8ae9aa20c36430008e6bd429443f8f1d,CVE-2016-0816,https://android.googlesource.com/platform/external/libavc/+/4a524d3a8ae9aa20c36430008e6bd429443f8f1d,2016-03-12T21:59Z,<S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug>
1085,CWE-000,"int simple_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; if ( type == ACL_TYPE_ACCESS ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error < 0 ) <S2SV_EndBug> return 0 ; if ( error == 0 ) acl = NULL ; } inode -> i_ctime = current_time ( inode ) ; set_cached_acl ( inode , type , acl ) ; return 0 ; }
","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl <S2SV_ModStart> if ( error ) return error <S2SV_ModEnd> ; } inode
",torvalds@linux/497de07d89c1410d76a15bec2bb41f24a2a89f31,CVE-2017-5551,https://github.com/torvalds/linux/commit/497de07d89c1410d76a15bec2bb41f24a2a89f31,2017-02-06T06:59Z,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error < 0 ) <S2SV_EndBug>"
626,CWE-476,"static int dissect_usb_ms_bulk ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , void * data ) { usb_conv_info_t * usb_conv_info ; usb_ms_conv_info_t * usb_ms_conv_info ; proto_tree * tree ; proto_item * ti ; guint32 signature = 0 ; int offset = 0 ; gboolean is_request ; itl_nexus_t * itl ; itlq_nexus_t * itlq ; if ( data == NULL ) return 0 ; usb_conv_info = ( usb_conv_info_t * ) data ; usb_ms_conv_info = ( usb_ms_conv_info_t * ) usb_conv_info -> class_data ; if ( ! usb_ms_conv_info ) { usb_ms_conv_info = wmem_new ( wmem_file_scope ( ) , usb_ms_conv_info_t ) ; usb_ms_conv_info -> itl = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_ms_conv_info -> itlq = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = usb_ms_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> is_request = ( pinfo -> srcport == NO_ENDPOINT ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""USBMS"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; ti = proto_tree_add_protocol_format ( parent_tree , proto_usb_ms , tvb , 0 , - 1 , ""USB<S2SV_blank>Mass<S2SV_blank>Storage"" ) ; tree = proto_item_add_subtree ( ti , ett_usb_ms ) ; signature = tvb_get_letohl ( tvb , offset ) ; if ( is_request && ( signature == 0x43425355 ) && ( tvb_reported_length ( tvb ) == 31 ) ) { tvbuff_t * cdb_tvb ; int cdbrlen , cdblen ; guint8 lun , flags ; guint32 datalen ; proto_tree_add_item ( tree , hf_usb_ms_dCBWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWDataTransferLength , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; datalen = tvb_get_letohl ( tvb , offset ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWFlags , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; flags = tvb_get_guint8 ( tvb , offset ) ; offset += 1 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTarget , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_ms_dCBWLUN , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; lun = tvb_get_guint8 ( tvb , offset ) & 0x0f ; offset += 1 ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , lun ) ; if ( ! itl ) { itl = wmem_new ( wmem_file_scope ( ) , itl_nexus_t ) ; itl -> cmdset = 0xff ; itl -> conversation = NULL ; wmem_tree_insert32 ( usb_ms_conv_info -> itl , lun , itl ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { itlq = wmem_new ( wmem_file_scope ( ) , itlq_nexus_t ) ; itlq -> lun = lun ; itlq -> scsi_opcode = 0xffff ; itlq -> task_flags = 0 ; if ( datalen ) { if ( flags & 0x80 ) { itlq -> task_flags |= SCSI_DATA_READ ; } else { itlq -> task_flags |= SCSI_DATA_WRITE ; } } itlq -> data_length = datalen ; itlq -> bidir_data_length = 0 ; itlq -> fc_time = pinfo -> abs_ts ; itlq -> first_exchange_frame = pinfo -> num ; itlq -> last_exchange_frame = 0 ; itlq -> flags = 0 ; itlq -> alloc_len = 0 ; itlq -> extra_data = NULL ; wmem_tree_insert32 ( usb_ms_conv_info -> itlq , pinfo -> num , itlq ) ; } proto_tree_add_item ( tree , hf_usb_ms_dCBWCBLength , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; cdbrlen = tvb_get_guint8 ( tvb , offset ) & 0x1f ; offset += 1 ; cdblen = cdbrlen ; if ( cdblen > tvb_captured_length_remaining ( tvb , offset ) ) { cdblen = tvb_captured_length_remaining ( tvb , offset ) ; } if ( cdblen ) { cdb_tvb = tvb_new_subset ( tvb , offset , cdblen , cdbrlen ) ; dissect_scsi_cdb ( cdb_tvb , pinfo , parent_tree , SCSI_DEV_UNKNOWN , itlq , itl ) ; } return tvb_captured_length ( tvb ) ; } if ( ( ! is_request ) && ( signature == 0x53425355 ) && ( tvb_reported_length ( tvb ) == 13 ) ) { guint8 status ; proto_tree_add_item ( tree , hf_usb_ms_dCSWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCSWDataResidue , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCSWStatus , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; status = tvb_get_guint8 ( tvb , offset ) ; itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itlq -> last_exchange_frame = pinfo -> num ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } if ( ! status ) { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0 ) ; } else { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0x02 ) ; } return tvb_captured_length ( tvb ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } dissect_scsi_payload ( tvb , pinfo , parent_tree , is_request , itlq , itl , 0 ) ; return tvb_captured_length ( tvb ) ; }
","<S2SV_ModStart> = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;
",wireshark@wireshark/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,CVE-2016-5354,https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,2016-08-07T16:59Z,<S2SV_StartBug> } <S2SV_EndBug>
3655,CWE-787,"static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) { ExceptionInfo * exception ; int bit ; ssize_t x ; register PixelPacket * q ; IndexPacket index ; register IndexPacket * indexes ; exception = ( & image -> exception ) ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; <S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 4 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; <S2SV_StartBug> p ++ ; <S2SV_EndBug> q ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 1 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 2 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }
","<S2SV_ModStart> -> columns - 3 <S2SV_ModEnd> ) ; x <S2SV_ModStart> index ) ; q ++ ; p <S2SV_ModEnd> ++ ; } <S2SV_ModStart> % 4 ) > <S2SV_ModEnd> 1 ) { <S2SV_ModStart> % 4 ) > <S2SV_ModEnd> 2 ) {
",ImageMagick@ImageMagick/d9b2209a69ee90d8df81fb124eb66f593eb9f599,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/d9b2209a69ee90d8df81fb124eb66f593eb9f599,2017-04-20T18:59Z,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 4 ) <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 2 ) <S2SV_EndBug>
412,CWE-125,"int llc_print ( netdissect_options * ndo , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { uint8_t dsap_field , dsap , ssap_field , ssap ; uint16_t control ; int hdrlen ; int is_u ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( caplen ) ; } if ( length < 3 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( length ) ; } dsap_field = * p ; ssap_field = * ( p + 1 ) ; control = * ( p + 2 ) ; if ( ( control & LLC_U_FMT ) == LLC_U_FMT ) { is_u = 1 ; hdrlen = 3 ; } else { if ( caplen < 4 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( caplen ) ; } if ( length < 4 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( length ) ; } control = EXTRACT_LE_16BITS ( p + 2 ) ; is_u = 0 ; hdrlen = 4 ; } if ( ssap_field == LLCSAP_GLOBAL && dsap_field == LLCSAP_GLOBAL ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""IPX<S2SV_blank>802.3:<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 0 ) ; } dsap = dsap_field & ~ LLC_IG ; ssap = ssap_field & ~ LLC_GSAP ; if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""LLC,<S2SV_blank>dsap<S2SV_blank>%s<S2SV_blank>(0x%02x)<S2SV_blank>%s,<S2SV_blank>ssap<S2SV_blank>%s<S2SV_blank>(0x%02x)<S2SV_blank>%s"" , tok2str ( llc_values , ""Unknown"" , dsap ) , dsap , tok2str ( llc_ig_flag_values , ""Unknown"" , dsap_field & LLC_IG ) , tok2str ( llc_values , ""Unknown"" , ssap ) , ssap , tok2str ( llc_flag_values , ""Unknown"" , ssap_field & LLC_GSAP ) ) ) ; if ( is_u ) { ND_PRINT ( ( ndo , "",<S2SV_blank>ctrl<S2SV_blank>0x%02x:<S2SV_blank>"" , control ) ) ; } else { ND_PRINT ( ( ndo , "",<S2SV_blank>ctrl<S2SV_blank>0x%04x:<S2SV_blank>"" , control ) ) ; } } p += hdrlen ; length -= hdrlen ; caplen -= hdrlen ; if ( ssap == LLCSAP_SNAP && dsap == LLCSAP_SNAP && control == LLC_UI ) { if ( ! snap_print ( ndo , p , length , caplen , src , dst , 2 ) ) { return ( - ( hdrlen + 5 ) ) ; } else return ( hdrlen + 5 ) ; } if ( ssap == LLCSAP_8021D && dsap == LLCSAP_8021D && control == LLC_UI ) { stp_print ( ndo , p , length ) ; return ( hdrlen ) ; } if ( ssap == LLCSAP_IP && dsap == LLCSAP_IP && control == LLC_UI ) { ip_print ( ndo , p , length ) ; return ( hdrlen ) ; } if ( ssap == LLCSAP_IPX && dsap == LLCSAP_IPX && control == LLC_UI ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""IPX<S2SV_blank>802.2:<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( hdrlen ) ; } # ifdef ENABLE_SMB if ( ssap == LLCSAP_NETBEUI && dsap == LLCSAP_NETBEUI && ( ! ( control & LLC_S_FMT ) || control == LLC_U_FMT ) ) { netbeui_print ( ndo , control , p , length ) ; return ( hdrlen ) ; } # endif if ( ssap == LLCSAP_ISONS && dsap == LLCSAP_ISONS && control == LLC_UI ) { <S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> return ( hdrlen ) ; } if ( ! ndo -> ndo_eflag ) { if ( ssap == dsap ) { if ( src == NULL || dst == NULL ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; else ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>"" , ( src -> addr_string ) ( ndo , src -> addr ) , ( dst -> addr_string ) ( ndo , dst -> addr ) , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; } else { if ( src == NULL || dst == NULL ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>"" , tok2str ( llc_values , ""Unknown<S2SV_blank>SSAP<S2SV_blank>0x%02x"" , ssap ) , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; else ND_PRINT ( ( ndo , ""%s<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>"" , ( src -> addr_string ) ( ndo , src -> addr ) , tok2str ( llc_values , ""Unknown<S2SV_blank>SSAP<S2SV_blank>0x%02x"" , ssap ) , ( dst -> addr_string ) ( ndo , dst -> addr ) , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; } } if ( is_u ) { ND_PRINT ( ( ndo , ""Unnumbered,<S2SV_blank>%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( llc_cmd_values , ""%02x"" , LLC_U_CMD ( control ) ) , tok2str ( llc_flag_values , ""?"" , ( ssap_field & LLC_GSAP ) | ( control & LLC_U_POLL ) ) , length + hdrlen ) ) ; if ( ( control & ~ LLC_U_POLL ) == LLC_XID ) { if ( length == 0 ) { return ( hdrlen ) ; } if ( caplen < 1 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; if ( caplen > 0 ) ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( hdrlen ) ; } if ( * p == LLC_XID_FI ) { if ( caplen < 3 || length < 3 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; if ( caplen > 0 ) ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; } else ND_PRINT ( ( ndo , "":<S2SV_blank>%02x<S2SV_blank>%02x"" , p [ 1 ] , p [ 2 ] ) ) ; return ( hdrlen ) ; } } } else { if ( ( control & LLC_S_FMT ) == LLC_S_FMT ) { ND_PRINT ( ( ndo , ""Supervisory,<S2SV_blank>%s,<S2SV_blank>rcv<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( llc_supervisory_values , ""?"" , LLC_S_CMD ( control ) ) , LLC_IS_NR ( control ) , tok2str ( llc_flag_values , ""?"" , ( ssap_field & LLC_GSAP ) | ( control & LLC_IS_POLL ) ) , length + hdrlen ) ) ; return ( hdrlen ) ; } else { ND_PRINT ( ( ndo , ""Information,<S2SV_blank>send<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>rcv<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , LLC_I_NS ( control ) , LLC_IS_NR ( control ) , tok2str ( llc_flag_values , ""?"" , ( ssap_field & LLC_GSAP ) | ( control & LLC_IS_POLL ) ) , length + hdrlen ) ) ; } } return ( - hdrlen ) ; }
","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; return
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,"<S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug>"
347,CWE-119,"void receive_tcppacket ( connection_t * c , const char * buffer , int len ) { <S2SV_StartBug> vpn_packet_t outpkt ; <S2SV_EndBug> outpkt . len = len ; if ( c -> options & OPTION_TCPONLY ) outpkt . priority = 0 ; else outpkt . priority = - 1 ; memcpy ( outpkt . data , buffer , len ) ; receive_packet ( c -> node , & outpkt ) ; }
","<S2SV_ModStart> { vpn_packet_t outpkt ; if ( len > sizeof outpkt . data ) return
",gsliepen@tinc/17a33dfd95b1a29e90db76414eb9622df9632320,CVE-2013-1428,https://github.com/gsliepen/tinc/commit/17a33dfd95b1a29e90db76414eb9622df9632320,2013-04-26T16:55Z,<S2SV_StartBug> vpn_packet_t outpkt ; <S2SV_EndBug>
6946,CWE-400,"int perf_output_begin ( struct perf_output_handle * handle , struct perf_event * event , unsigned int size , <S2SV_StartBug> int nmi , int sample ) <S2SV_EndBug> { struct ring_buffer * rb ; unsigned long tail , offset , head ; int have_lost ; struct perf_sample_data sample_data ; struct { struct perf_event_header header ; u64 id ; u64 lost ; } lost_event ; rcu_read_lock ( ) ; if ( event -> parent ) event = event -> parent ; rb = rcu_dereference ( event -> rb ) ; if ( ! rb ) goto out ; handle -> rb = rb ; handle -> event = event ; <S2SV_StartBug> handle -> nmi = nmi ; <S2SV_EndBug> handle -> sample = sample ; if ( ! rb -> nr_pages ) goto out ; have_lost = local_read ( & rb -> lost ) ; if ( have_lost ) { lost_event . header . size = sizeof ( lost_event ) ; perf_event_header__init_id ( & lost_event . header , & sample_data , event ) ; size += lost_event . header . size ; } perf_output_get_handle ( handle ) ; do { tail = ACCESS_ONCE ( rb -> user_page -> data_tail ) ; smp_rmb ( ) ; offset = head = local_read ( & rb -> head ) ; head += size ; if ( unlikely ( ! perf_output_space ( rb , tail , offset , head ) ) ) goto fail ; } while ( local_cmpxchg ( & rb -> head , offset , head ) != offset ) ; if ( head - local_read ( & rb -> wakeup ) > rb -> watermark ) local_add ( rb -> watermark , & rb -> wakeup ) ; handle -> page = offset >> ( PAGE_SHIFT + page_order ( rb ) ) ; handle -> page &= rb -> nr_pages - 1 ; handle -> size = offset & ( ( PAGE_SIZE << page_order ( rb ) ) - 1 ) ; handle -> addr = rb -> data_pages [ handle -> page ] ; handle -> addr += handle -> size ; handle -> size = ( PAGE_SIZE << page_order ( rb ) ) - handle -> size ; if ( have_lost ) { lost_event . header . type = PERF_RECORD_LOST ; lost_event . header . misc = 0 ; lost_event . id = event -> id ; lost_event . lost = local_xchg ( & rb -> lost , 0 ) ; perf_output_put ( handle , lost_event ) ; perf_event__output_id_sample ( event , handle , & sample_data ) ; } return 0 ; fail : local_inc ( & rb -> lost ) ; perf_output_put_handle ( handle ) ; out : rcu_read_unlock ( ) ; return - ENOSPC ; }
","<S2SV_ModStart> size , int <S2SV_ModEnd> sample ) { <S2SV_ModStart> ; handle -> <S2SV_ModEnd> sample = sample
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> int nmi , int sample ) <S2SV_EndBug> <S2SV_StartBug> handle -> nmi = nmi ; <S2SV_EndBug>"
358,CWE-189,"int lzxd_decompress ( struct lzxd_stream * lzx , off_t out_bytes ) { register unsigned int bit_buffer ; register int bits_left , i = 0 ; unsigned char * i_ptr , * i_end ; register unsigned short sym ; int match_length , length_footer , extra , verbatim_bits , bytes_todo ; int this_run , main_element , aligned_bits , j ; unsigned char * window , * runsrc , * rundest , buf [ 12 ] ; unsigned int frame_size = 0 , end_frame , match_offset , window_posn ; unsigned int R0 , R1 , R2 ; if ( ! lzx || ( out_bytes < 0 ) ) return MSPACK_ERR_ARGS ; if ( lzx -> error ) return lzx -> error ; i = lzx -> o_end - lzx -> o_ptr ; if ( ( off_t ) i > out_bytes ) i = ( int ) out_bytes ; if ( i ) { if ( lzx -> sys -> write ( lzx -> output , lzx -> o_ptr , i ) != i ) { return lzx -> error = MSPACK_ERR_WRITE ; } lzx -> o_ptr += i ; lzx -> offset += i ; out_bytes -= i ; } if ( out_bytes == 0 ) return MSPACK_ERR_OK ; RESTORE_BITS ; window = lzx -> window ; window_posn = lzx -> window_posn ; R0 = lzx -> R0 ; R1 = lzx -> R1 ; R2 = lzx -> R2 ; end_frame = ( unsigned int ) ( ( lzx -> offset + out_bytes ) / LZX_FRAME_SIZE ) + 1 ; while ( lzx -> frame < end_frame ) { if ( lzx -> reset_interval && ( ( lzx -> frame % lzx -> reset_interval ) == 0 ) ) { if ( lzx -> block_remaining ) { D ( ( ""%d<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>at<S2SV_blank>reset<S2SV_blank>interval"" , lzx -> block_remaining ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } lzxd_reset_state ( lzx ) ; R0 = lzx -> R0 ; R1 = lzx -> R1 ; R2 = lzx -> R2 ; } if ( lzx -> is_delta ) { ENSURE_BITS ( 16 ) ; REMOVE_BITS ( 16 ) ; } if ( ! lzx -> header_read ) { j = 0 ; READ_BITS ( i , 1 ) ; if ( i ) { READ_BITS ( i , 16 ) ; READ_BITS ( j , 16 ) ; } lzx -> intel_filesize = ( i << 16 ) | j ; lzx -> header_read = 1 ; } frame_size = LZX_FRAME_SIZE ; if ( lzx -> length && ( lzx -> length - lzx -> offset ) < ( off_t ) frame_size ) { frame_size = lzx -> length - lzx -> offset ; } bytes_todo = lzx -> frame_posn + frame_size - window_posn ; while ( bytes_todo > 0 ) { if ( lzx -> block_remaining == 0 ) { if ( ( lzx -> block_type == LZX_BLOCKTYPE_UNCOMPRESSED ) && ( lzx -> block_length & 1 ) ) { READ_IF_NEEDED ; i_ptr ++ ; } READ_BITS ( lzx -> block_type , 3 ) ; READ_BITS ( i , 16 ) ; READ_BITS ( j , 8 ) ; lzx -> block_remaining = lzx -> block_length = ( i << 8 ) | j ; switch ( lzx -> block_type ) { case LZX_BLOCKTYPE_ALIGNED : for ( i = 0 ; i < 8 ; i ++ ) { READ_BITS ( j , 3 ) ; lzx -> ALIGNED_len [ i ] = j ; } BUILD_TABLE ( ALIGNED ) ; case LZX_BLOCKTYPE_VERBATIM : READ_LENGTHS ( MAINTREE , 0 , 256 ) ; READ_LENGTHS ( MAINTREE , 256 , LZX_NUM_CHARS + lzx -> num_offsets ) ; BUILD_TABLE ( MAINTREE ) ; if ( lzx -> MAINTREE_len [ 0xE8 ] != 0 ) lzx -> intel_started = 1 ; READ_LENGTHS ( LENGTH , 0 , LZX_NUM_SECONDARY_LENGTHS ) ; BUILD_TABLE_MAYBE_EMPTY ( LENGTH ) ; break ; case LZX_BLOCKTYPE_UNCOMPRESSED : lzx -> intel_started = 1 ; <S2SV_StartBug> ENSURE_BITS ( 16 ) ; <S2SV_EndBug> if ( bits_left > 16 ) i_ptr -= 2 ; bits_left = 0 ; bit_buffer = 0 ; for ( rundest = & buf [ 0 ] , i = 0 ; i < 12 ; i ++ ) { READ_IF_NEEDED ; * rundest ++ = * i_ptr ++ ; } R0 = buf [ 0 ] | ( buf [ 1 ] << 8 ) | ( buf [ 2 ] << 16 ) | ( buf [ 3 ] << 24 ) ; R1 = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; R2 = buf [ 8 ] | ( buf [ 9 ] << 8 ) | ( buf [ 10 ] << 16 ) | ( buf [ 11 ] << 24 ) ; break ; default : D ( ( ""bad<S2SV_blank>block<S2SV_blank>type"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } } this_run = lzx -> block_remaining ; if ( this_run > bytes_todo ) this_run = bytes_todo ; bytes_todo -= this_run ; lzx -> block_remaining -= this_run ; switch ( lzx -> block_type ) { case LZX_BLOCKTYPE_VERBATIM : while ( this_run > 0 ) { READ_HUFFSYM ( MAINTREE , main_element ) ; if ( main_element < LZX_NUM_CHARS ) { window [ window_posn ++ ] = main_element ; this_run -- ; } else { main_element -= LZX_NUM_CHARS ; match_length = main_element & LZX_NUM_PRIMARY_LENGTHS ; if ( match_length == LZX_NUM_PRIMARY_LENGTHS ) { if ( lzx -> LENGTH_empty ) { D ( ( ""LENGTH<S2SV_blank>symbol<S2SV_blank>needed<S2SV_blank>but<S2SV_blank>tree<S2SV_blank>is<S2SV_blank>empty"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } READ_HUFFSYM ( LENGTH , length_footer ) ; match_length += length_footer ; } match_length += LZX_MIN_MATCH ; switch ( ( match_offset = ( main_element >> 3 ) ) ) { case 0 : match_offset = R0 ; break ; case 1 : match_offset = R1 ; R1 = R0 ; R0 = match_offset ; break ; case 2 : match_offset = R2 ; R2 = R0 ; R0 = match_offset ; break ; case 3 : match_offset = 1 ; R2 = R1 ; R1 = R0 ; R0 = match_offset ; break ; default : extra = ( match_offset >= 36 ) ? 17 : extra_bits [ match_offset ] ; READ_BITS ( verbatim_bits , extra ) ; match_offset = position_base [ match_offset ] - 2 + verbatim_bits ; R2 = R1 ; R1 = R0 ; R0 = match_offset ; } if ( match_length == LZX_MAX_MATCH && lzx -> is_delta ) { int extra_len = 0 ; ENSURE_BITS ( 3 ) ; if ( PEEK_BITS ( 1 ) == 0 ) { REMOVE_BITS ( 1 ) ; READ_BITS ( extra_len , 8 ) ; } else if ( PEEK_BITS ( 2 ) == 2 ) { REMOVE_BITS ( 2 ) ; READ_BITS ( extra_len , 10 ) ; extra_len += 0x100 ; } else if ( PEEK_BITS ( 3 ) == 6 ) { REMOVE_BITS ( 3 ) ; READ_BITS ( extra_len , 12 ) ; extra_len += 0x500 ; } else { REMOVE_BITS ( 3 ) ; READ_BITS ( extra_len , 15 ) ; } match_length += extra_len ; } if ( ( window_posn + match_length ) > lzx -> window_size ) { D ( ( ""match<S2SV_blank>ran<S2SV_blank>over<S2SV_blank>window<S2SV_blank>wrap"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } rundest = & window [ window_posn ] ; i = match_length ; if ( match_offset > window_posn ) { if ( match_offset > lzx -> offset && ( match_offset - window_posn ) > lzx -> ref_data_size ) { D ( ( ""match<S2SV_blank>offset<S2SV_blank>beyond<S2SV_blank>LZX<S2SV_blank>stream"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } j = match_offset - window_posn ; if ( j > ( int ) lzx -> window_size ) { D ( ( ""match<S2SV_blank>offset<S2SV_blank>beyond<S2SV_blank>window<S2SV_blank>boundaries"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } runsrc = & window [ lzx -> window_size - j ] ; if ( j < i ) { i -= j ; while ( j -- > 0 ) * rundest ++ = * runsrc ++ ; runsrc = window ; } while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; } else { runsrc = rundest - match_offset ; while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; } this_run -= match_length ; window_posn += match_length ; } } break ; case LZX_BLOCKTYPE_ALIGNED : while ( this_run > 0 ) { READ_HUFFSYM ( MAINTREE , main_element ) ; if ( main_element < LZX_NUM_CHARS ) { window [ window_posn ++ ] = main_element ; this_run -- ; } else { main_element -= LZX_NUM_CHARS ; match_length = main_element & LZX_NUM_PRIMARY_LENGTHS ; if ( match_length == LZX_NUM_PRIMARY_LENGTHS ) { if ( lzx -> LENGTH_empty ) { D ( ( ""LENGTH<S2SV_blank>symbol<S2SV_blank>needed<S2SV_blank>but<S2SV_blank>tree<S2SV_blank>is<S2SV_blank>empty"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } READ_HUFFSYM ( LENGTH , length_footer ) ; match_length += length_footer ; } match_length += LZX_MIN_MATCH ; switch ( ( match_offset = ( main_element >> 3 ) ) ) { case 0 : match_offset = R0 ; break ; case 1 : match_offset = R1 ; R1 = R0 ; R0 = match_offset ; break ; case 2 : match_offset = R2 ; R2 = R0 ; R0 = match_offset ; break ; default : extra = ( match_offset >= 36 ) ? 17 : extra_bits [ match_offset ] ; match_offset = position_base [ match_offset ] - 2 ; if ( extra > 3 ) { extra -= 3 ; READ_BITS ( verbatim_bits , extra ) ; match_offset += ( verbatim_bits << 3 ) ; READ_HUFFSYM ( ALIGNED , aligned_bits ) ; match_offset += aligned_bits ; } else if ( extra == 3 ) { READ_HUFFSYM ( ALIGNED , aligned_bits ) ; match_offset += aligned_bits ; } else if ( extra > 0 ) { READ_BITS ( verbatim_bits , extra ) ; match_offset += verbatim_bits ; } else { match_offset = 1 ; } R2 = R1 ; R1 = R0 ; R0 = match_offset ; } if ( match_length == LZX_MAX_MATCH && lzx -> is_delta ) { int extra_len = 0 ; ENSURE_BITS ( 3 ) ; if ( PEEK_BITS ( 1 ) == 0 ) { REMOVE_BITS ( 1 ) ; READ_BITS ( extra_len , 8 ) ; } else if ( PEEK_BITS ( 2 ) == 2 ) { REMOVE_BITS ( 2 ) ; READ_BITS ( extra_len , 10 ) ; extra_len += 0x100 ; } else if ( PEEK_BITS ( 3 ) == 6 ) { REMOVE_BITS ( 3 ) ; READ_BITS ( extra_len , 12 ) ; extra_len += 0x500 ; } else { REMOVE_BITS ( 3 ) ; READ_BITS ( extra_len , 15 ) ; } match_length += extra_len ; } if ( ( window_posn + match_length ) > lzx -> window_size ) { D ( ( ""match<S2SV_blank>ran<S2SV_blank>over<S2SV_blank>window<S2SV_blank>wrap"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } rundest = & window [ window_posn ] ; i = match_length ; if ( match_offset > window_posn ) { if ( match_offset > lzx -> offset && ( match_offset - window_posn ) > lzx -> ref_data_size ) { D ( ( ""match<S2SV_blank>offset<S2SV_blank>beyond<S2SV_blank>LZX<S2SV_blank>stream"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } j = match_offset - window_posn ; if ( j > ( int ) lzx -> window_size ) { D ( ( ""match<S2SV_blank>offset<S2SV_blank>beyond<S2SV_blank>window<S2SV_blank>boundaries"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } runsrc = & window [ lzx -> window_size - j ] ; if ( j < i ) { i -= j ; while ( j -- > 0 ) * rundest ++ = * runsrc ++ ; runsrc = window ; } while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; } else { runsrc = rundest - match_offset ; while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; } this_run -= match_length ; window_posn += match_length ; } } break ; case LZX_BLOCKTYPE_UNCOMPRESSED : rundest = & window [ window_posn ] ; window_posn += this_run ; while ( this_run > 0 ) { if ( ( i = i_end - i_ptr ) == 0 ) { READ_IF_NEEDED ; } else { if ( i > this_run ) i = this_run ; lzx -> sys -> copy ( i_ptr , rundest , ( size_t ) i ) ; rundest += i ; i_ptr += i ; this_run -= i ; } } break ; default : return lzx -> error = MSPACK_ERR_DECRUNCH ; } if ( this_run < 0 ) { if ( ( unsigned int ) ( - this_run ) > lzx -> block_remaining ) { D ( ( ""overrun<S2SV_blank>went<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>block<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>(%d<S2SV_blank>remaining)"" , - this_run , lzx -> block_remaining ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } lzx -> block_remaining -= - this_run ; } } if ( ( window_posn - lzx -> frame_posn ) != frame_size ) { D ( ( ""decode<S2SV_blank>beyond<S2SV_blank>output<S2SV_blank>frame<S2SV_blank>limits!<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d"" , window_posn - lzx -> frame_posn , frame_size ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } if ( bits_left > 0 ) ENSURE_BITS ( 16 ) ; if ( bits_left & 15 ) REMOVE_BITS ( bits_left & 15 ) ; if ( lzx -> o_ptr != lzx -> o_end ) { D ( ( ""%ld<S2SV_blank>avail<S2SV_blank>bytes,<S2SV_blank>new<S2SV_blank>%d<S2SV_blank>frame"" , ( long ) ( lzx -> o_end - lzx -> o_ptr ) , frame_size ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } if ( lzx -> intel_started && lzx -> intel_filesize && ( lzx -> frame <= 32768 ) && ( frame_size > 10 ) ) { unsigned char * data = & lzx -> e8_buf [ 0 ] ; unsigned char * dataend = & lzx -> e8_buf [ frame_size - 10 ] ; signed int curpos = lzx -> intel_curpos ; signed int filesize = lzx -> intel_filesize ; signed int abs_off , rel_off ; lzx -> o_ptr = data ; lzx -> sys -> copy ( & lzx -> window [ lzx -> frame_posn ] , data , frame_size ) ; while ( data < dataend ) { if ( * data ++ != 0xE8 ) { curpos ++ ; continue ; } abs_off = data [ 0 ] | ( data [ 1 ] << 8 ) | ( data [ 2 ] << 16 ) | ( data [ 3 ] << 24 ) ; if ( ( abs_off >= - curpos ) && ( abs_off < filesize ) ) { rel_off = ( abs_off >= 0 ) ? abs_off - curpos : abs_off + filesize ; data [ 0 ] = ( unsigned char ) rel_off ; data [ 1 ] = ( unsigned char ) ( rel_off >> 8 ) ; data [ 2 ] = ( unsigned char ) ( rel_off >> 16 ) ; data [ 3 ] = ( unsigned char ) ( rel_off >> 24 ) ; } data += 4 ; curpos += 5 ; } lzx -> intel_curpos += frame_size ; } else { lzx -> o_ptr = & lzx -> window [ lzx -> frame_posn ] ; if ( lzx -> intel_filesize ) lzx -> intel_curpos += frame_size ; } lzx -> o_end = & lzx -> o_ptr [ frame_size ] ; i = ( out_bytes < ( off_t ) frame_size ) ? ( unsigned int ) out_bytes : frame_size ; if ( lzx -> sys -> write ( lzx -> output , lzx -> o_ptr , i ) != i ) { return lzx -> error = MSPACK_ERR_WRITE ; } lzx -> o_ptr += i ; lzx -> offset += i ; out_bytes -= i ; lzx -> frame_posn += frame_size ; lzx -> frame ++ ; if ( window_posn == lzx -> window_size ) window_posn = 0 ; if ( lzx -> frame_posn == lzx -> window_size ) lzx -> frame_posn = 0 ; } if ( out_bytes ) { D ( ( ""bytes<S2SV_blank>left<S2SV_blank>to<S2SV_blank>output"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } STORE_BITS ; lzx -> window_posn = window_posn ; lzx -> R0 = R0 ; lzx -> R1 = R1 ; lzx -> R2 = R2 ; return MSPACK_ERR_OK ; }
","<S2SV_ModStart> = 1 ; if ( bits_left == 0 ) <S2SV_ModStart> ( 16 ) <S2SV_ModEnd> ; bits_left =
",kyz@libmspack/18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3,CVE-2015-4471,https://github.com/kyz/libmspack/commit/18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3,2015-06-11T14:59Z,<S2SV_StartBug> ENSURE_BITS ( 16 ) ; <S2SV_EndBug>
238,CWE-17,"static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ; struct address_space * mapping = inode -> i_mapping ; unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; <S2SV_StartBug> flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT | <S2SV_EndBug> EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ; <S2SV_StartBug> if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_EndBug> flags |= EXT4_GET_BLOCKS_KEEP_SIZE ; <S2SV_StartBug> mutex_lock ( & inode -> i_mutex ) ; <S2SV_EndBug> if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; if ( partial_end ) max_blocks += 1 ; } <S2SV_StartBug> if ( max_blocks > 0 ) { <S2SV_EndBug> truncate_pagecache_range ( inode , start , end - 1 ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , flags , mode ) ; if ( ret ) goto out_dio ; ret = ext4_es_remove_extent ( inode , 0 , EXT_MAX_BLOCKS ) ; if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }
","<S2SV_ModStart> -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! <S2SV_ModEnd> ( mode & <S2SV_ModStart> & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_ModStart> |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex <S2SV_ModEnd> ; } if <S2SV_ModStart> 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;
",torvalds@linux/0f2af21aae11972fa924374ddcf52e88347cf5a8,CVE-2015-0275,https://github.com/torvalds/linux/commit/0f2af21aae11972fa924374ddcf52e88347cf5a8,2015-10-19T10:59Z,<S2SV_StartBug> flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT | <S2SV_EndBug> <S2SV_StartBug> if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & inode -> i_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( max_blocks > 0 ) { <S2SV_EndBug>
3170,CWE-125,"static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; <S2SV_StartBug> coerce_reg_to_size ( & src_reg , 4 ) ; <S2SV_EndBug> } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
","<S2SV_ModStart> : 32 ; if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } <S2SV_ModStart> 4 ) ; <S2SV_ModEnd> } __reg_deduce_bounds (
",torvalds@linux/b799207e1e1816b09e7a5920fbb2d5fcf6edd681,CVE-2018-18445,https://github.com/torvalds/linux/commit/b799207e1e1816b09e7a5920fbb2d5fcf6edd681,2018-10-17T19:29Z,"<S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_size ( & src_reg , 4 ) ; <S2SV_EndBug>"
7846,CWE-20,"error_t udpReceiveDatagram ( Socket * socket , SocketMsg * message , uint_t flags ) { error_t error ; SocketQueueItem * queueItem ; if ( ( flags & SOCKET_FLAG_DONT_WAIT ) == 0 ) { if ( socket -> receiveQueue == NULL ) { socket -> eventMask = SOCKET_EVENT_RX_READY ; osResetEvent ( & socket -> event ) ; osReleaseMutex ( & netMutex ) ; osWaitForEvent ( & socket -> event , socket -> timeout ) ; osAcquireMutex ( & netMutex ) ; } } if ( socket -> receiveQueue != NULL ) { queueItem = socket -> receiveQueue ; message -> length = netBufferRead ( message -> data , queueItem -> buffer , queueItem -> offset , message -> size ) ; <S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug> message -> srcPort = queueItem -> srcPort ; message -> destIpAddr = queueItem -> destIpAddr ; message -> ttl = queueItem -> ancillary . ttl ; # if ( ETH_SUPPORT == ENABLED ) message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ; message -> destMacAddr = queueItem -> ancillary . destMacAddr ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) message -> switchPort = queueItem -> ancillary . port ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) message -> timestamp = queueItem -> ancillary . timestamp ; # endif if ( ( flags & SOCKET_FLAG_PEEK ) == 0 ) { socket -> receiveQueue = queueItem -> next ; netBufferFree ( queueItem -> buffer ) ; } udpUpdateEvents ( socket ) ; error = NO_ERROR ; } else { message -> length = 0 ; error = ERROR_TIMEOUT ; } return error ; }
","<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug>
4134,CWE-399,"static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , profile_data , profile_size , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , ""BA"" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ; profile_data = 0 ; profile_size = 0 ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; if ( ( MagickSizeType ) bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } profile_data = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; profile_size = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ; case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ; default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( MagickSizeType ) ( length / 256 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( ( bmp_info . colorspace == 0x4D424544L ) && ( profile_data > 0 ) && ( profile_size > 0 ) ) { StringInfo * profile ; unsigned char * datum ; offset = start_position + 14 + profile_data ; if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) || ( GetBlobSize ( image ) < ( MagickSizeType ) ( offset + profile_size ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; profile = AcquireStringInfo ( ( size_t ) profile_size ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( CorruptImageError , ""MemoryAllocationFailed"" ) ; datum = GetStringInfoDatum ( profile ) ; if ( ReadBlob ( image , ( size_t ) profile_size , datum ) == ( ssize_t ) profile_size ) { MagickOffsetType profile_size_orig ; profile_size_orig = ( MagickOffsetType ) datum [ 0 ] << 24 ; profile_size_orig |= ( MagickOffsetType ) datum [ 1 ] << 16 ; profile_size_orig |= ( MagickOffsetType ) datum [ 2 ] << 8 ; profile_size_orig |= ( MagickOffsetType ) datum [ 3 ] ; if ( profile_size_orig < profile_size ) SetStringInfoLength ( profile , ( size_t ) profile_size_orig ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Profile:<S2SV_blank>ICC,<S2SV_blank>%u<S2SV_blank>bytes"" , ( unsigned int ) profile_size_orig ) ; ( void ) SetImageProfile ( image , ""icc"" , profile , exception ) ; } profile = DestroyStringInfo ( profile ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; offset = ( MagickOffsetType ) bmp_info . ba_offset ; if ( offset != 0 ) if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; * magick = '\\0' ; count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; <S2SV_StartBug> return ( ( Image * ) NULL ) ; <S2SV_EndBug> } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> = MagickFalse ; break <S2SV_ModEnd> ; } image
",ImageMagick@ImageMagick/fe3066122ef72c82415811d25e9e3fad622c0a99,CVE-2019-13134,https://github.com/ImageMagick/ImageMagick/commit/fe3066122ef72c82415811d25e9e3fad622c0a99,2019-07-01T20:15Z,<S2SV_StartBug> return ( ( Image * ) NULL ) ; <S2SV_EndBug>
2000,CWE-119,"void * vpx_calloc ( size_t num , size_t size ) { void * x ; x = vpx_memalign ( DEFAULT_ALIGNMENT , num * size ) ; if ( x ) <S2SV_StartBug> VPX_MEMSET_L ( x , 0 , num * size ) ; <S2SV_EndBug> return x ; }
","<S2SV_ModStart> ( x ) memset <S2SV_ModEnd> ( x ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> VPX_MEMSET_L ( x , 0 , num * size ) ; <S2SV_EndBug>"
7641,CWE-190,"int pnm_validate ( jas_stream_t * in ) { <S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug> int i ; int n ; assert ( JAS_STREAM_MAXPUTBACK >= 2 ) ; if ( ( n = jas_stream_read ( in , buf , 2 ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < 2 ) { return - 1 ; } if ( buf [ 0 ] == 'P' && isdigit ( buf [ 1 ] ) ) { return 0 ; } return - 1 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ 2
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug>
4027,CWE-119,"int encode_msg ( struct sip_msg * msg , char * payload , int len ) { int i , j , k , u , request ; unsigned short int h ; struct hdr_field * hf ; struct msg_start * ms ; struct sip_uri miuri ; char * myerror = NULL ; ptrdiff_t diff ; if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) return - 1 ; if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) { myerror = ""in<S2SV_blank>parse_headers"" ; goto error ; } memset ( payload , 0 , len ) ; ms = & msg -> first_line ; if ( ms -> type == SIP_REQUEST ) request = 1 ; else if ( ms -> type == SIP_REPLY ) request = 0 ; else { myerror = ""message<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>request<S2SV_blank>nor<S2SV_blank>response"" ; goto error ; } if ( request ) { for ( h = 0 ; h < 32 ; j = ( 0x01 << h ) , h ++ ) if ( j & ms -> u . request . method_value ) break ; } else { h = ( unsigned short ) ( ms -> u . reply . statuscode ) ; } if ( h == 32 ) { myerror = ""unknown<S2SV_blank>message<S2SV_blank>type\\n"" ; goto error ; } h = htons ( h ) ; memcpy ( payload , & h , 2 ) ; h = htons ( ( unsigned short int ) msg -> len ) ; memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ; if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) { myerror = ""body<S2SV_blank>starts<S2SV_blank>before<S2SV_blank>the<S2SV_blank>message<S2SV_blank>(uh<S2SV_blank>?)"" ; goto error ; } else h = htons ( ( unsigned short int ) diff ) ; memcpy ( payload + CONTENT_IDX , & h , 2 ) ; payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . method . s - msg -> buf ) : ( ms -> u . reply . status . s - msg -> buf ) ) ; payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . method . len ) : ( ms -> u . reply . status . len ) ) ; payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . s - msg -> buf ) : ( ms -> u . reply . reason . s - msg -> buf ) ) ; payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . len ) : ( ms -> u . reply . reason . len ) ) ; payload [ VERSION_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . version . s - msg -> buf ) : ( ms -> u . reply . version . s - msg -> buf ) ) ; if ( request ) { if ( parse_uri ( ms -> u . request . uri . s , ms -> u . request . uri . len , & miuri ) < 0 ) { LM_ERR ( ""<%.*s>\\n"" , ms -> u . request . uri . len , ms -> u . request . uri . s ) ; myerror = ""while<S2SV_blank>parsing<S2SV_blank>the<S2SV_blank>R-URI"" ; goto error ; } if ( 0 > ( j = encode_uri2 ( msg -> buf , ms -> u . request . method . s - msg -> buf + ms -> len , ms -> u . request . uri , & miuri , ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) { myerror = ""ENCODE_MSG:<S2SV_blank>ERROR<S2SV_blank>while<S2SV_blank>encoding<S2SV_blank>the<S2SV_blank>R-URI"" ; goto error ; } payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ; k = REQUEST_URI_IDX + 1 + j ; } else k = REQUEST_URI_IDX ; u = k ; k ++ ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , i ++ ) ; i ++ ; j = k + 3 * i ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , k += 3 ) { payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ; h = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & h , 2 ) ; if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) { LM_ERR ( ""encoding<S2SV_blank>header<S2SV_blank>%.*s\\n"" , hf -> name . len , hf -> name . s ) ; goto error ; k -= 3 ; continue ; } j += ( unsigned short int ) i ; } payload [ u ] = ( unsigned char ) ( ( k - u - 1 ) / 3 ) ; j = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & j , 2 ) ; k += 3 ; j = ntohs ( j ) ; <S2SV_StartBug> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ; <S2SV_EndBug> LM_DBG ( ""msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n"" , msg -> len , j ) ; j = htons ( j ) ; memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ; return GET_PAY_SIZE ( payload ) ; error : LM_ERR ( ""%s\\n"" , myerror ) ; return - 1 ; }
","<S2SV_ModStart> j ) ; if ( len < j + msg -> len + 1 ) { LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\n"" ) ; return - 1 ; }
",kamailio@kamailio/f50c9c853e7809810099c970780c30b0765b0643,CVE-2016-2385,https://github.com/kamailio/kamailio/commit/f50c9c853e7809810099c970780c30b0765b0643,2016-04-11T15:59Z,"<S2SV_StartBug> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ; <S2SV_EndBug>"
2642,CWE-000,"int ip6_fragment ( struct sk_buff * skb , int ( * output ) ( struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; __be32 frag_id = 0 ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( ! skb -> local_df && skb -> len > mtu ) { skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return - EMSGSIZE ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } mtu -= hlen + sizeof ( struct frag_hdr ) ; if ( skb_has_frag_list ( skb ) ) { int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < hlen ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; return - ENOMEM ; } __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; <S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; frag_id = fh -> identification ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next != NULL ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; dst_release ( & rt -> dst ) ; return 0 ; } while ( frag ) { skb = frag -> next ; kfree_skb ( frag ) ; frag = skb ; } IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; dst_release ( & rt -> dst ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; * prevhdr = NEXTHDR_FRAGMENT ; while ( left > 0 ) { len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } if ( ( frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + LL_ALLOCATED_SPACE ( rt -> dst . dev ) , GFP_ATOMIC ) ) == NULL ) { NETDEBUG ( KERN_INFO ""IPv6:<S2SV_blank>frag:<S2SV_blank>no<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>new<S2SV_blank>fragment!\\n"" ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , LL_RESERVED_SPACE ( rt -> dst . dev ) ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; if ( ! frag_id ) { <S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> frag_id = fh -> identification ; } else fh -> identification = frag_id ; if ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) BUG ( ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; kfree_skb ( skb ) ; return err ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }
","<S2SV_ModStart> ipv6_select_ident ( fh , rt <S2SV_ModStart> ipv6_select_ident ( fh , rt
",torvalds@linux/87c48fa3b4630905f98268dde838ee43626a060c,CVE-2011-2699,https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c,2012-05-24T23:55Z,<S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> <S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug>
2410,CWE-264,"asmlinkage long sys_oabi_fcntl64 ( unsigned int fd , unsigned int cmd , unsigned long arg ) { <S2SV_StartBug> struct oabi_flock64 user ; <S2SV_EndBug> struct flock64 kernel ; mm_segment_t fs = USER_DS ; unsigned long local_arg = arg ; int ret ; switch ( cmd ) { case F_OFD_GETLK : case F_OFD_SETLK : case F_OFD_SETLKW : case F_GETLK64 : case F_SETLK64 : case F_SETLKW64 : <S2SV_StartBug> if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , <S2SV_EndBug> sizeof ( user ) ) ) return - EFAULT ; kernel . l_type = user . l_type ; kernel . l_whence = user . l_whence ; kernel . l_start = user . l_start ; kernel . l_len = user . l_len ; kernel . l_pid = user . l_pid ; local_arg = ( unsigned long ) & kernel ; fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; } <S2SV_StartBug> ret = sys_fcntl64 ( fd , cmd , local_arg ) ; <S2SV_EndBug> switch ( cmd ) { case F_GETLK64 : if ( ! ret ) { user . l_type = kernel . l_type ; user . l_whence = kernel . l_whence ; user . l_start = kernel . l_start ; user . l_len = kernel . l_len ; user . l_pid = kernel . l_pid ; if ( copy_to_user ( ( struct oabi_flock64 __user * ) arg , & user , sizeof ( user ) ) ) ret = - EFAULT ; } case F_SETLK64 : case F_SETLKW64 : set_fs ( fs ) ; } <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> arg ) { <S2SV_ModEnd> switch ( cmd <S2SV_ModStart> case F_SETLKW64 : return do_locks ( fd , cmd , arg ) ; default : return <S2SV_ModEnd> sys_fcntl64 ( fd <S2SV_ModStart> , cmd , arg <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/76cc404bfdc0d419c720de4daaf2584542734f42,CVE-2015-8966,https://github.com/torvalds/linux/commit/76cc404bfdc0d419c720de4daaf2584542734f42,2016-12-08T21:59Z,"<S2SV_StartBug> struct oabi_flock64 user ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , <S2SV_EndBug> <S2SV_StartBug> ret = sys_fcntl64 ( fd , cmd , local_arg ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug>"
1859,CWE-119,"static void txfm_rd_in_plane ( MACROBLOCK * x , int * rate , int64_t * distortion , int * skippable , int64_t * sse , int64_t ref_best_rd , int plane , BLOCK_SIZE bsize , TX_SIZE tx_size , int use_fast_coef_casting ) { MACROBLOCKD * const xd = & x -> e_mbd ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> struct rdcost_block_args args = { 0 } ; <S2SV_EndBug> args . x = x ; args . best_rd = ref_best_rd ; <S2SV_StartBug> args . use_fast_coef_costing = use_fast_coef_casting ; <S2SV_EndBug> if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ; vp9_get_entropy_contexts ( bsize , tx_size , pd , args . t_above , args . t_left ) ; args . so = get_scan ( xd , tx_size , pd -> plane_type , 0 ) ; vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , block_rd_txfm , & args ) ; <S2SV_StartBug> if ( args . skip ) { <S2SV_EndBug> * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } else { * distortion = args . this_dist ; * rate = args . this_rate ; * sse = args . this_sse ; <S2SV_StartBug> * skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> struct rdcost_block_args args ; vp9_zero ( args ) <S2SV_ModEnd> ; args . <S2SV_ModStart> use_fast_coef_costing = use_fast_coef_casting ; args . skippable = 1 <S2SV_ModStart> ( args . exit_early <S2SV_ModEnd> ) { * <S2SV_ModStart> * skippable = args . skippable <S2SV_ModEnd> ; } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> struct rdcost_block_args args = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> args . use_fast_coef_costing = use_fast_coef_casting ; <S2SV_EndBug> <S2SV_StartBug> if ( args . skip ) { <S2SV_EndBug> <S2SV_StartBug> * skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ; <S2SV_EndBug>"
1609,CWE-119,"<S2SV_StartBug> static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <S2SV_EndBug> int mi_row , int mi_col , vp9_reader * r ) { <S2SV_StartBug> struct segmentation * const seg = & cm -> seg ; <S2SV_EndBug> const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; int segment_id ; if ( ! seg -> enabled ) return 0 ; <S2SV_StartBug> if ( ! seg -> update_map ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> segment_id = read_segment_id ( r , seg ) ; <S2SV_StartBug> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <S2SV_EndBug> return segment_id ; }
","<S2SV_ModStart> const cm , int mi_offset , int x_mis , int y_mis , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> cm -> seg <S2SV_ModEnd> ; int segment_id <S2SV_ModStart> -> update_map ) { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> ( cm , mi_offset , x_mis , y_mis <S2SV_ModEnd> , segment_id )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <S2SV_EndBug> <S2SV_StartBug> struct segmentation * const seg = & cm -> seg ; <S2SV_EndBug> <S2SV_StartBug> if ( ! seg -> update_map ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <S2SV_EndBug>"
2402,CWE-89,"static CURLcode pop3_parse_url_path ( struct connectdata * conn ) { struct pop3_conn * pop3c = & conn -> proto . pop3c ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <S2SV_StartBug> pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! pop3c -> mailbox ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }
","<S2SV_ModStart> . path ; return Curl_urldecode <S2SV_ModEnd> ( data , <S2SV_ModStart> , 0 , & <S2SV_ModEnd> pop3c -> mailbox <S2SV_ModStart> pop3c -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null>
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,"<S2SV_StartBug> pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! pop3c -> mailbox ) <S2SV_EndBug>"
2509,CWE-835,"static int read_data ( void * opaque , uint8_t * buf , int buf_size ) { struct playlist * v = opaque ; HLSContext * c = v -> parent -> priv_data ; int ret , i ; <S2SV_StartBug> int just_opened = 0 ; <S2SV_EndBug> restart : if ( ! v -> needed ) return AVERROR_EOF ; if ( ! v -> input ) { int64_t reload_interval ; struct segment * seg ; if ( v -> ctx && v -> ctx -> nb_streams ) { v -> needed = 0 ; for ( i = 0 ; i < v -> n_main_streams ; i ++ ) { if ( v -> main_streams [ i ] -> discard < AVDISCARD_ALL ) { v -> needed = 1 ; break ; } } } if ( ! v -> needed ) { av_log ( v -> parent , AV_LOG_INFO , ""No<S2SV_blank>longer<S2SV_blank>receiving<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; return AVERROR_EOF ; } reload_interval = default_reload_interval ( v ) ; reload : <S2SV_StartBug> if ( ! v -> finished && <S2SV_EndBug> av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) { if ( ( ret = parse_playlist ( c , v -> url , v , NULL ) ) < 0 ) { av_log ( v -> parent , AV_LOG_WARNING , ""Failed<S2SV_blank>to<S2SV_blank>reload<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; return ret ; } reload_interval = v -> target_duration / 2 ; } if ( v -> cur_seq_no < v -> start_seq_no ) { av_log ( NULL , AV_LOG_WARNING , ""skipping<S2SV_blank>%d<S2SV_blank>segments<S2SV_blank>ahead,<S2SV_blank>expired<S2SV_blank>from<S2SV_blank>playlists\\n"" , v -> start_seq_no - v -> cur_seq_no ) ; v -> cur_seq_no = v -> start_seq_no ; } if ( v -> cur_seq_no >= v -> start_seq_no + v -> n_segments ) { if ( v -> finished ) return AVERROR_EOF ; while ( av_gettime_relative ( ) - v -> last_load_time < reload_interval ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_usleep ( 100 * 1000 ) ; } goto reload ; } seg = current_segment ( v ) ; ret = update_init_section ( v , seg ) ; if ( ret ) return ret ; ret = open_input ( c , v , seg ) ; if ( ret < 0 ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_log ( v -> parent , AV_LOG_WARNING , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>segment<S2SV_blank>of<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; v -> cur_seq_no += 1 ; goto reload ; } just_opened = 1 ; } if ( v -> init_sec_buf_read_offset < v -> init_sec_data_len ) { int copy_size = FFMIN ( v -> init_sec_data_len - v -> init_sec_buf_read_offset , buf_size ) ; memcpy ( buf , v -> init_sec_buf , copy_size ) ; v -> init_sec_buf_read_offset += copy_size ; return copy_size ; } ret = read_from_url ( v , current_segment ( v ) , buf , buf_size , READ_NORMAL ) ; if ( ret > 0 ) { if ( just_opened && v -> is_id3_timestamped != 0 ) { intercept_id3 ( v , buf , buf_size , & ret ) ; } return ret ; } ff_format_io_close ( v -> parent , & v -> input ) ; v -> cur_seq_no ++ ; c -> cur_seq_no = v -> cur_seq_no ; goto restart ; }
","<S2SV_ModStart> ; int just_opened = 0 ; int reload_count <S2SV_ModStart> ; reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;
",FFmpeg@FFmpeg/7ec414892ddcad88313848494b6fc5f437c9ca4a,CVE-2017-14058,https://github.com/FFmpeg/FFmpeg/commit/7ec414892ddcad88313848494b6fc5f437c9ca4a,2017-08-31T15:29Z,<S2SV_StartBug> int just_opened = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! v -> finished && <S2SV_EndBug>
2322,CWE-119,"int qeth_snmp_command ( struct qeth_card * card , char __user * udata ) { struct qeth_cmd_buffer * iob ; struct qeth_ipa_cmd * cmd ; struct qeth_snmp_ureq * ureq ; <S2SV_StartBug> int req_len ; <S2SV_EndBug> struct qeth_arp_query_info qinfo = { 0 , } ; int rc = 0 ; QETH_CARD_TEXT ( card , 3 , ""snmpcmd"" ) ; if ( card -> info . guestlan ) return - EOPNOTSUPP ; if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) ) { return - EOPNOTSUPP ; } if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) ) <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ; if ( IS_ERR ( ureq ) ) { QETH_CARD_TEXT ( card , 2 , ""snmpnome"" ) ; return PTR_ERR ( ureq ) ; } qinfo . udata_len = ureq -> hdr . data_len ; qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ) ; if ( ! qinfo . udata ) { kfree ( ureq ) ; return - ENOMEM ; } qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ) ; iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ) ; cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ) ; memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ) ; rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ) ; if ( rc ) QETH_DBF_MESSAGE ( 2 , ""SNMP<S2SV_blank>command<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>(0x%x)\\n"" , QETH_CARD_IFNAME ( card ) , rc ) ; else { if ( copy_to_user ( udata , qinfo . udata , qinfo . udata_len ) ) rc = - EFAULT ; } kfree ( ureq ) ; kfree ( qinfo . udata ) ; return rc ; }
","<S2SV_ModStart> * ureq ; unsigned <S2SV_ModStart> return - EFAULT ; if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL
",torvalds@linux/6fb392b1a63ae36c31f62bc3fc8630b49d602b62,CVE-2013-6381,https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62,2013-11-27T04:43Z,<S2SV_StartBug> int req_len ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug>
1610,CWE-119,"<S2SV_StartBug> static INLINE void read_mv ( vp9_reader * r , MV * mv , const MV * ref , <S2SV_EndBug> const nmv_context * ctx , nmv_context_counts * counts , int allow_hp ) { const MV_JOINT_TYPE joint_type = <S2SV_StartBug> ( MV_JOINT_TYPE ) vp9_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ; <S2SV_EndBug> const int use_hp = allow_hp && vp9_use_mv_hp ( ref ) ; MV diff = { 0 , 0 } ; if ( mv_joint_vertical ( joint_type ) ) diff . row = read_mv_component ( r , & ctx -> comps [ 0 ] , use_hp ) ; if ( mv_joint_horizontal ( joint_type ) ) diff . col = read_mv_component ( r , & ctx -> comps [ 1 ] , use_hp ) ; vp9_inc_mv ( & diff , counts ) ; mv -> row = ref -> row + diff . row ; mv -> col = ref -> col + diff . col ; }
","<S2SV_ModStart> void read_mv ( vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> ( MV_JOINT_TYPE ) vpx_read_tree <S2SV_ModEnd> ( r ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static INLINE void read_mv ( vp9_reader * r , MV * mv , const MV * ref , <S2SV_EndBug> <S2SV_StartBug> ( MV_JOINT_TYPE ) vp9_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ; <S2SV_EndBug>"
3639,CWE-20,"static int get_rx_bufs ( struct vhost_virtqueue * vq , struct vring_used_elem * heads , int datalen , unsigned * iovcount , struct vhost_log * log , unsigned * log_num , unsigned int quota ) { unsigned int out , in ; int seg = 0 ; int headcount = 0 ; unsigned d ; int r , nlogs = 0 ; while ( datalen > 0 && headcount < quota ) { if ( unlikely ( seg >= UIO_MAXIOV ) ) { r = - ENOBUFS ; goto err ; } d = vhost_get_vq_desc ( vq -> dev , vq , vq -> iov + seg , ARRAY_SIZE ( vq -> iov ) - seg , & out , & in , log , log_num ) ; if ( d == vq -> num ) { r = 0 ; goto err ; } if ( unlikely ( out || in <= 0 ) ) { vq_err ( vq , ""unexpected<S2SV_blank>descriptor<S2SV_blank>format<S2SV_blank>for<S2SV_blank>RX:<S2SV_blank>"" ""out<S2SV_blank>%d,<S2SV_blank>in<S2SV_blank>%d\\n"" , out , in ) ; r = - EINVAL ; goto err ; } if ( unlikely ( log ) ) { nlogs += * log_num ; log += * log_num ; } heads [ headcount ] . id = d ; heads [ headcount ] . len = iov_length ( vq -> iov + seg , in ) ; datalen -= heads [ headcount ] . len ; ++ headcount ; seg += in ; } heads [ headcount - 1 ] . len += datalen ; * iovcount = seg ; if ( unlikely ( log ) ) * log_num = nlogs ; <S2SV_StartBug> return headcount ; <S2SV_EndBug> err : vhost_discard_vq_desc ( vq , headcount ) ; return r ; }
","<S2SV_ModStart> = nlogs ; if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; }
",torvalds@linux/d8316f3991d207fe32881a9ac20241be8fa2bad0,CVE-2014-0077,https://github.com/torvalds/linux/commit/d8316f3991d207fe32881a9ac20241be8fa2bad0,2014-04-14T23:55Z,<S2SV_StartBug> return headcount ; <S2SV_EndBug>
2416,CWE-416,"void fe_netjoin_deinit ( void ) { while ( joinservers != NULL ) netjoin_server_remove ( joinservers -> data ) ; if ( join_tag != - 1 ) { g_source_remove ( join_tag ) ; signal_remove ( ""print<S2SV_blank>starting"" , ( SIGNAL_FUNC ) sig_print_starting ) ; } signal_remove ( ""setup<S2SV_blank>changed"" , ( SIGNAL_FUNC ) read_settings ) ; <S2SV_StartBug> signal_remove ( ""message<S2SV_blank>quit"" , ( SIGNAL_FUNC ) msg_quit ) ; <S2SV_EndBug> signal_remove ( ""message<S2SV_blank>join"" , ( SIGNAL_FUNC ) msg_join ) ; signal_remove ( ""message<S2SV_blank>irc<S2SV_blank>mode"" , ( SIGNAL_FUNC ) msg_mode ) ; }
","<S2SV_ModStart> ; signal_remove ( ""server<S2SV_blank>disconnected"" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; signal_remove (
",irssi@irssi/77b2631c78461965bc9a7414aae206b5c514e1b3,CVE-2017-7191,https://github.com/irssi/irssi/commit/77b2631c78461965bc9a7414aae206b5c514e1b3,2017-03-27T17:59Z,"<S2SV_StartBug> signal_remove ( ""message<S2SV_blank>quit"" , ( SIGNAL_FUNC ) msg_quit ) ; <S2SV_EndBug>"
5494,CWE-668,"int main ( int argc , const char * argv [ ] ) { struct group * grent ; const char * cmd ; const char * path ; int i ; struct passwd * pw ; grent = getgrnam ( ABUILD_GROUP ) ; if ( grent == NULL ) errx ( 1 , ""%s:<S2SV_blank>Group<S2SV_blank>not<S2SV_blank>found"" , ABUILD_GROUP ) ; char * name = NULL ; pw = getpwuid ( getuid ( ) ) ; if ( pw ) name = pw -> pw_name ; if ( ! is_in_group ( grent -> gr_gid ) ) { errx ( 1 , ""User<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>member<S2SV_blank>of<S2SV_blank>group<S2SV_blank>%s\\n"" , name ? name : ""(unknown)"" , ABUILD_GROUP ) ; } if ( name == NULL ) warnx ( ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>username<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%d\\n"" , getuid ( ) ) ; setenv ( ""USER"" , name ? : """" , 1 ) ; cmd = strrchr ( argv [ 0 ] , '/' ) ; if ( cmd ) cmd ++ ; else cmd = argv [ 0 ] ; cmd = strchr ( cmd , '-' ) ; if ( cmd == NULL ) errx ( 1 , ""Calling<S2SV_blank>command<S2SV_blank>has<S2SV_blank>no<S2SV_blank>\'-\'"" ) ; cmd ++ ; path = get_command_path ( cmd ) ; if ( path == NULL ) errx ( 1 , ""%s:<S2SV_blank>Not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>subcommand"" , cmd ) ; for ( i = 1 ; i < argc ; i ++ ) <S2SV_StartBug> if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 ) <S2SV_EndBug> errx ( 1 , ""%s:<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>option"" , ""--allow-untrusted"" ) ; argv [ 0 ] = path ; setuid ( 0 ) ; setgid ( 0 ) ; execv ( path , ( char * const * ) argv ) ; perror ( path ) ; return 1 ; }
","<S2SV_ModStart> i ++ ) check_option ( argv [ i ] <S2SV_ModEnd> ) ; argv
",sroracle@abuild/4f90ce92778d0ee302e288def75591b96a397c8b,CVE-2019-12875,https://github.com/sroracle/abuild/commit/4f90ce92778d0ee302e288def75591b96a397c8b,2019-06-18T19:15Z,"<S2SV_StartBug> if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 ) <S2SV_EndBug>"
3660,CWE-000,"long do_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * info ) { if ( pid <= 0 || tgid <= 0 ) return - EINVAL ; <S2SV_StartBug> if ( info -> si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> info -> si_signo = sig ; return do_send_specific ( tgid , pid , sig , info ) ; }
","<S2SV_ModStart> info -> si_code != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
",torvalds@linux/da48524eb20662618854bb3df2db01fc65f3070c,CVE-2011-1182,https://github.com/torvalds/linux/commit/da48524eb20662618854bb3df2db01fc65f3070c,2013-03-01T12:37Z,<S2SV_StartBug> if ( info -> si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug>
2502,CWE-264,"int rpc_type_of_NPNVariable ( int variable ) { int type ; switch ( variable ) { case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool : <S2SV_StartBug> case NPNVSupportsWindowless : <S2SV_EndBug> type = RPC_TYPE_BOOLEAN ; break ; case NPNVToolkit : case NPNVnetscapeWindow : type = RPC_TYPE_UINT32 ; break ; case NPNVWindowNPObject : case NPNVPluginElementNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; }
","<S2SV_ModStart> : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling
",davidben@nspluginwrapper/7e4ab8e1189846041f955e6c83f72bc1624e7a98,CVE-2011-2486,https://github.com/davidben/nspluginwrapper/commit/7e4ab8e1189846041f955e6c83f72bc1624e7a98,2012-11-19T12:10Z,<S2SV_StartBug> case NPNVSupportsWindowless : <S2SV_EndBug>
4209,CWE-78,"R_API char * r_socket_http_get ( const char * url , int * code , int * rlen ) { <S2SV_StartBug> char * curl_env = r_sys_getenv ( ""R2_CURL"" ) ; <S2SV_EndBug> if ( curl_env && * curl_env ) { char * encoded_url = r_str_escape ( url ) ; char * res = r_sys_cmd_strf ( ""curl<S2SV_blank>\'%s\'"" , encoded_url ) ; free ( encoded_url ) ; if ( res ) { if ( code ) { * code = 200 ; } if ( rlen ) { * rlen = strlen ( res ) ; } <S2SV_StartBug> } <S2SV_EndBug> free ( curl_env ) ; return res ; } free ( curl_env ) ; RSocket * s ; int ssl = r_str_startswith ( url , ""https://"" ) ; char * response , * host , * path , * port = ""80"" ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } if ( code ) { * code = 0 ; } if ( rlen ) { * rlen = 0 ; } host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; eprintf ( ""r_socket_http_get:<S2SV_blank>Invalid<S2SV_blank>URI"" ) ; return NULL ; } host += 3 ; port = strchr ( host , ':' ) ; if ( ! port ) { port = ssl ? ""443"" : ""80"" ; path = host ; } else { * port ++ = 0 ; path = port ; } path = strchr ( path , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { eprintf ( ""r_socket_http_get:<S2SV_blank>Cannot<S2SV_blank>create<S2SV_blank>socket\\n"" ) ; free ( uri ) ; return NULL ; } if ( r_socket_connect_tcp ( s , host , port , 0 ) ) { r_socket_printf ( s , ""GET<S2SV_blank>/%s<S2SV_blank>HTTP/1.1\\r\\n"" ""User-Agent:<S2SV_blank>radare2<S2SV_blank>"" R2_VERSION ""\\r\\n"" ""Accept:<S2SV_blank>*/*\\r\\n"" ""Host:<S2SV_blank>%s:%s\\r\\n"" ""\\r\\n"" , path , host , port ) ; response = r_socket_http_answer ( s , code , rlen ) ; } else { eprintf ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\n"" , host , port ) ; response = NULL ; } free ( uri ) ; r_socket_free ( s ) ; return response ; }
","<S2SV_ModStart> rlen ) { return socket_http_get_recursive ( url , code , rlen , SOCKET_HTTP_MAX_REDIRECTS <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",radareorg@radare2/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,CVE-2020-15121,https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,2020-07-20T18:15Z,"<S2SV_StartBug> char * curl_env = r_sys_getenv ( ""R2_CURL"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
4511,CWE-125,"static node * parsetok ( struct tok_state * tok , grammar * g , int start , perrdetail * err_ret , int * flags ) { parser_state * ps ; node * n ; int started = 0 ; growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; Ta3Tokenizer_Free ( tok ) ; return NULL ; } if ( ( ps = Ta3Parser_New ( g , start ) ) == NULL ) { err_ret -> error = E_NOMEM ; Ta3Tokenizer_Free ( tok ) ; return NULL ; } # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; # endif for ( ; ; ) { char * a , * b ; int type ; size_t len ; char * str ; int col_offset ; type = Ta3Tokenizer_Get ( tok , & a , & b ) ; if ( type == ERRORTOKEN ) { err_ret -> error = tok -> done ; break ; } if ( type == ENDMARKER && started ) { type = NEWLINE ; started = 0 ; if ( tok -> indent && ! ( * flags & PyPARSE_DONT_IMPLY_DEDENT ) ) { tok -> pendin = - tok -> indent ; tok -> indent = 0 ; } } else started = 1 ; <S2SV_StartBug> len = b - a ; <S2SV_EndBug> str = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( str == NULL ) { err_ret -> error = E_NOMEM ; break ; } if ( len > 0 ) strncpy ( str , a , len ) ; str [ len ] = '\\0' ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( type == NOTEQUAL ) { if ( ! ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""!="" ) ) { PyObject_FREE ( str ) ; err_ret -> error = E_SYNTAX ; break ; } else if ( ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""<>"" ) ) { PyObject_FREE ( str ) ; <S2SV_StartBug> err_ret -> text = ""with<S2SV_blank>Barry<S2SV_blank>as<S2SV_blank>BDFL,<S2SV_blank>use<S2SV_blank>\'<>\'<S2SV_blank>"" <S2SV_EndBug> ""instead<S2SV_blank>of<S2SV_blank>\'!=\'"" ; err_ret -> error = E_SYNTAX ; break ; } } # endif <S2SV_StartBug> if ( a >= tok -> line_start ) <S2SV_EndBug> col_offset = Py_SAFE_DOWNCAST ( a - tok -> line_start , intptr_t , int ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> col_offset = - 1 ; <S2SV_EndBug> if ( type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( ( err_ret -> error = Ta3Parser_AddToken ( ps , ( int ) type , str , tok -> lineno , col_offset , & ( err_ret -> expected ) ) ) != E_OK ) { if ( err_ret -> error != E_DONE ) { PyObject_FREE ( str ) ; err_ret -> token = type ; } break ; } } if ( err_ret -> error == E_DONE ) { n = ps -> p_tree ; ps -> p_tree = NULL ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { Ta3Node_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores ) ; # ifndef PGEN if ( start == single_input ) { char * cur = tok -> cur ; char c = * tok -> cur ; for ( ; ; ) { while ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\014' ) c = * ++ cur ; if ( ! c ) break ; if ( c != '#' ) { err_ret -> error = E_BADSINGLE ; Ta3Node_Free ( n ) ; n = NULL ; break ; } while ( c && c != '\\n' ) c = * ++ cur ; } } # endif } else n = NULL ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD * flags = ps -> p_flags ; # endif Ta3Parser_Delete ( ps ) ; if ( n == NULL ) { if ( tok -> done == E_EOF ) err_ret -> error = E_EOF ; err_ret -> lineno = tok -> lineno ; if ( tok -> buf != NULL ) { size_t len ; assert ( tok -> cur - tok -> buf < INT_MAX ) ; err_ret -> offset = ( int ) ( tok -> cur - tok -> buf ) ; len = tok -> inp - tok -> buf ; err_ret -> text = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( err_ret -> text != NULL ) { if ( len > 0 ) strncpy ( err_ret -> text , tok -> buf , len ) ; err_ret -> text [ len ] = '\\0' ; } } } else if ( tok -> encoding != NULL ) { node * r = Ta3Node_New ( encoding_decl ) ; if ( r ) r -> n_str = PyObject_MALLOC ( strlen ( tok -> encoding ) + 1 ) ; if ( ! r || ! r -> n_str ) { err_ret -> error = E_NOMEM ; if ( r ) PyObject_FREE ( r ) ; n = NULL ; goto done ; } strcpy ( r -> n_str , tok -> encoding ) ; PyMem_FREE ( tok -> encoding ) ; tok -> encoding = NULL ; r -> n_nchildren = 1 ; r -> n_child = n ; n = r ; } done : Ta3Tokenizer_Free ( tok ) ; return n ; }
","<S2SV_ModStart> ; len = ( a != NULL && b != NULL ) ? <S2SV_ModStart> b - a : 0 <S2SV_ModStart> ; err_ret -> expected = NOTEQUAL <S2SV_ModEnd> ; err_ret -> <S2SV_ModStart> if ( a != NULL && a <S2SV_ModStart> -> line_start ) { <S2SV_ModStart> int ) ; } else { <S2SV_ModEnd> col_offset = - <S2SV_ModStart> - 1 ; }
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> len = b - a ; <S2SV_EndBug> <S2SV_StartBug> err_ret -> text = ""with<S2SV_blank>Barry<S2SV_blank>as<S2SV_blank>BDFL,<S2SV_blank>use<S2SV_blank>\'<>\'<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> if ( a >= tok -> line_start ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> col_offset = - 1 ; <S2SV_EndBug>"
7877,CWE-20,"void ksz8851EventHandler ( NetInterface * interface ) { uint16_t status ; uint_t frameCount ; <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> if ( ( status & ISR_LCIS ) != 0 ) { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_LCIS ) ; <S2SV_EndBug> <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_P1SR ) ; <S2SV_EndBug> if ( ( status & P1SR_LINK_GOOD ) != 0 ) { if ( ( status & P1SR_OPERATION_SPEED ) != 0 ) { interface -> linkSpeed = NIC_LINK_SPEED_100MBPS ; } else { interface -> linkSpeed = NIC_LINK_SPEED_10MBPS ; } <S2SV_StartBug> if ( ( status & P1SR_OPERATION_DUPLEX ) != 0 ) <S2SV_EndBug> { interface -> duplexMode = NIC_FULL_DUPLEX_MODE ; } else { interface -> duplexMode = NIC_HALF_DUPLEX_MODE ; } interface -> linkState = TRUE ; } else { interface -> linkState = FALSE ; } nicNotifyLinkChange ( interface ) ; } <S2SV_StartBug> if ( ( status & ISR_RXIS ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_RXIS ) ; <S2SV_EndBug> <S2SV_StartBug> frameCount = MSB ( ksz8851ReadReg ( interface , KSZ8851_REG_RXFCTR ) ) ; <S2SV_EndBug> while ( frameCount > 0 ) { ksz8851ReceivePacket ( interface ) ; frameCount -- ; } } <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_RXIE ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( interface , KSZ8851_ISR ) ; if ( ( status & KSZ8851_ISR_LCIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface , KSZ8851_P1SR ) ; if ( ( status & KSZ8851_P1SR_LINK_GOOD ) != 0 ) { if ( ( status & KSZ8851_P1SR_OPERATION_SPEED <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( status & KSZ8851_P1SR_OPERATION_DUPLEX <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( status & KSZ8851_ISR_RXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_RXIS <S2SV_ModEnd> ) ; frameCount <S2SV_ModStart> ( interface , KSZ8851_RXFCTR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_RXIE <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_LCIS ) ; <S2SV_EndBug> <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_P1SR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & P1SR_OPERATION_DUPLEX ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ISR_RXIS ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_RXIS ) ; <S2SV_EndBug> <S2SV_StartBug> frameCount = MSB ( ksz8851ReadReg ( interface , KSZ8851_REG_RXFCTR ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_RXIE ) ; <S2SV_EndBug>"
819,CWE-119,"void WT_Interpolate ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; const EAS_SAMPLE * loopEnd ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ; <S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> pOutputBuffer = pWTIntFrame -> pAudioBuffer ; loopEnd = ( const EAS_SAMPLE * ) pWTVoice -> loopEnd + 1 ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = pWTVoice -> phaseFrac ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; acc0 = ( EAS_I32 ) ( pSamples - loopEnd ) ; if ( acc0 >= 0 ) pSamples = ( const EAS_SAMPLE * ) pWTVoice -> loopStart + acc0 ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }
","<S2SV_ModStart> -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; }
",external@sonivox/3ac044334c3ff6a61cb4238ff3ddaf17c7efcf49,CVE-2016-0838,https://android.googlesource.com/platform/external/sonivox/+/3ac044334c3ff6a61cb4238ff3ddaf17c7efcf49,2016-04-18T00:59Z,<S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug>
2717,CWE-200,"static int cdrom_ioctl_drive_status ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , ""entering<S2SV_blank>CDROM_DRIVE_STATUS\\n"" ) ; if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ; <S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug> return - EINVAL ; return cdrom_slot_status ( cdi , arg ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi <S2SV_ModStart> cdi -> capacity <S2SV_ModEnd> ) return -
",torvalds@linux/8f3fafc9c2f0ece10832c25f7ffcb07c97a32ad4,CVE-2018-16658,https://github.com/torvalds/linux/commit/8f3fafc9c2f0ece10832c25f7ffcb07c97a32ad4,2018-09-07T14:29Z,<S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug>
367,CWE-264,"void eval_js ( WebKitWebView * web_view , gchar * script , GString * result ) { WebKitWebFrame * frame ; JSGlobalContextRef context ; <S2SV_StartBug> JSObjectRef globalobject ; <S2SV_EndBug> JSStringRef var_name ; JSStringRef js_script ; JSValueRef js_result ; JSStringRef js_result_string ; size_t js_result_size ; js_init ( ) ; frame = webkit_web_view_get_main_frame ( WEBKIT_WEB_VIEW ( web_view ) ) ; context = webkit_web_frame_get_global_context ( frame ) ; <S2SV_StartBug> globalobject = JSContextGetGlobalObject ( context ) ; <S2SV_EndBug> var_name = JSStringCreateWithUTF8CString ( ""Uzbl"" ) ; JSObjectSetProperty ( context , globalobject , var_name , JSObjectMake ( context , uzbl . js . classref , NULL ) , kJSClassAttributeNone , NULL ) ; js_script = JSStringCreateWithUTF8CString ( script ) ; js_result = JSEvaluateScript ( context , js_script , globalobject , NULL , 0 , NULL ) ; if ( js_result && ! JSValueIsUndefined ( context , js_result ) ) { js_result_string = JSValueToStringCopy ( context , js_result , NULL ) ; js_result_size = JSStringGetMaximumUTF8CStringSize ( js_result_string ) ; if ( js_result_size ) { char js_result_utf8 [ js_result_size ] ; JSStringGetUTF8CString ( js_result_string , js_result_utf8 , js_result_size ) ; g_string_assign ( result , js_result_utf8 ) ; } JSStringRelease ( js_result_string ) ; } <S2SV_StartBug> JSObjectDeleteProperty ( context , globalobject , var_name , NULL ) ; <S2SV_EndBug> JSStringRelease ( var_name ) ; JSStringRelease ( js_script ) ; }
","<S2SV_ModStart> ; JSObjectRef globalobject <S2SV_ModEnd> ; JSStringRef js_script <S2SV_ModStart> JSContextGetGlobalObject ( context <S2SV_ModEnd> ) ; js_script <S2SV_ModStart> ) ; } <S2SV_ModEnd> JSStringRelease ( js_script
",Dieterbe@uzbl/1958b52d41cba96956dc1995660de49525ed1047,CVE-2010-0011,https://github.com/Dieterbe/uzbl/commit/1958b52d41cba96956dc1995660de49525ed1047,2010-02-25T19:30Z,"<S2SV_StartBug> JSObjectRef globalobject ; <S2SV_EndBug> <S2SV_StartBug> globalobject = JSContextGetGlobalObject ( context ) ; <S2SV_EndBug> <S2SV_StartBug> JSObjectDeleteProperty ( context , globalobject , var_name , NULL ) ; <S2SV_EndBug>"
33,CWE-000,"krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) { int l = 0 , kerberos_principal_object_type = 0 ; unsigned int ntrees = 0 , tre = 0 ; krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; char * * subtreelist = NULL ; char * user = NULL , * subtree = NULL , * principal_dn = NULL ; char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; char * filtuser = NULL ; struct berval * * bersecretkey = NULL ; LDAPMod * * mods = NULL ; krb5_boolean create_standalone_prinicipal = FALSE ; krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; char * standalone_principal_dn = NULL ; krb5_tl_data * tl_data = NULL ; krb5_key_data * * keys = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; osa_princ_ent_rec princ_ent = { 0 } ; xargs_t xargs = { 0 } ; char * polname = NULL ; OPERATION optype ; krb5_boolean found_entry = FALSE ; krb5_clear_error_message ( context ) ; SETUP_CONTEXT ( ) ; if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ; GET_HANDLE ( ) ; if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm"" ) ) ; goto cleanup ; } if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ; filtuser = ldap_filter_correct ( user ) ; if ( filtuser == NULL ) { st = ENOMEM ; goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ; else optype = MODIFY_PRINCIPAL ; if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ; if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ; if ( entry -> mask & KADM5_LOAD ) { unsigned int tree = 0 ; int numlentries = 0 ; char * filter = NULL ; if ( asprintf ( & filter , FILTER ""%s))"" , filtuser ) < 0 ) { filter = NULL ; st = ENOMEM ; goto cleanup ; } if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ; found_entry = FALSE ; for ( tree = 0 ; found_entry == FALSE && tree < ntrees ; ++ tree ) { if ( principal_dn == NULL ) { LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ; } else { LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ; } if ( st == LDAP_SUCCESS ) { numlentries = ldap_count_entries ( ld , result ) ; if ( numlentries > 1 ) { free ( filter ) ; st = EINVAL ; k5_setmsg ( context , st , _ ( ""operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>"" ""entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\""%s\\""<S2SV_blank>found"" ) , user ) ; goto cleanup ; } else if ( numlentries == 1 ) { found_entry = TRUE ; if ( principal_dn == NULL ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) { ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ; st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } } } } } else if ( st != LDAP_NO_SUCH_OBJECT ) { st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } ldap_msgfree ( result ) ; result = NULL ; } free ( filter ) ; if ( found_entry == FALSE && principal_dn != NULL ) { create_standalone_prinicipal = TRUE ; standalone_principal_dn = strdup ( principal_dn ) ; CHECK_NULL ( standalone_principal_dn ) ; } } if ( principal_dn == NULL && xargs . dn == NULL ) { if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( ""krbtgt"" ) && strncmp ( entry -> princ -> data [ 0 ] . data , ""krbtgt"" , entry -> princ -> data [ 0 ] . length ) == 0 ) { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } else if ( xargs . containerdn ) { if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) { if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) { int ost = st ; st = EINVAL ; k5_prependmsg ( context , ost , st , _ ( ""\'%s\'<S2SV_blank>not<S2SV_blank>found"" ) , xargs . containerdn ) ; } goto cleanup ; } subtree = strdup ( xargs . containerdn ) ; } else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) { subtree = strdup ( ldap_context -> lrparams -> containerref ) ; } else { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } CHECK_NULL ( subtree ) ; if ( asprintf ( & standalone_principal_dn , ""krbprincipalname=%s,%s"" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ; CHECK_NULL ( standalone_principal_dn ) ; create_standalone_prinicipal = TRUE ; free ( subtree ) ; subtree = NULL ; } if ( xargs . dn_from_kbd == TRUE ) { int dnlen = 0 , subtreelen = 0 ; char * dn = NULL ; krb5_boolean outofsubtree = TRUE ; if ( xargs . dn != NULL ) { dn = xargs . dn ; } else if ( xargs . linkdn != NULL ) { dn = xargs . linkdn ; } else if ( standalone_principal_dn != NULL ) { dn = standalone_principal_dn ; } if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } for ( tre = 0 ; tre < ntrees ; ++ tre ) { if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) { outofsubtree = FALSE ; break ; } else { dnlen = strlen ( dn ) ; subtreelen = strlen ( subtreelist [ tre ] ) ; if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) { outofsubtree = FALSE ; break ; } } } if ( outofsubtree == TRUE ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree"" ) ) ; goto cleanup ; } if ( standalone_principal_dn == NULL ) { char * attributes [ ] = { ""krbticketpolicyreference"" , ""krbprincipalname"" , NULL } ; ldap_msgfree ( result ) ; result = NULL ; LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ; if ( st == LDAP_SUCCESS ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( values = ldap_get_values ( ld , ent , ""krbticketpolicyreference"" ) ) != NULL ) { ldap_value_free ( values ) ; } if ( ( values = ldap_get_values ( ld , ent , ""krbprincipalname"" ) ) != NULL ) { krb_identity_exists = TRUE ; ldap_value_free ( values ) ; } } } else { st = set_ldap_error ( context , st , OP_SEARCH ) ; goto cleanup ; } } } if ( xargs . dn != NULL && krb_identity_exists == TRUE ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( xargs . linkdn != NULL ) { if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>"" ""kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } { char * * linkdns = NULL ; int j = 0 ; if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( linkdns != NULL ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>"" ""object"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; for ( j = 0 ; linkdns [ j ] != NULL ; ++ j ) free ( linkdns [ j ] ) ; free ( linkdns ) ; goto cleanup ; } } establish_links = TRUE ; } if ( entry -> mask & KADM5_LAST_SUCCESS ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastSuccessfulAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_LAST_FAILED ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastFailedAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) { krb5_kvno fail_auth_count ; fail_auth_count = entry -> fail_auth_count ; if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ; st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_REPLACE , fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) { int attr_mask = 0 ; krb5_boolean has_fail_count ; st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ; if ( st != 0 ) goto cleanup ; has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ; # ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_INCREMENT , 1 ) ; if ( st != 0 ) goto cleanup ; } else { # endif if ( has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ; if ( st != 0 ) goto cleanup ; # ifdef LDAP_MOD_INCREMENT } # endif } else if ( optype == ADD_PRINCIPAL ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , 0 ) ; } if ( entry -> mask & KADM5_MAX_LIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxticketlife"" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_MAX_RLIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxrenewableage"" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_ATTRIBUTES ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbticketflags"" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = user ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalname"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_PW_EXPIRATION ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_POLICY ) { memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ; for ( tl_data = entry -> tl_data ; tl_data ; tl_data = tl_data -> tl_data_next ) { if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) { if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) { goto cleanup ; } break ; } } if ( princ_ent . aux_attributes & KADM5_POLICY ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ; strval [ 0 ] = polname ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { st = EINVAL ; k5_setmsg ( context , st , ""Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null"" ) ; goto cleanup ; } } else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_POLICY_CLR ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) { krb5_kvno mkvno ; if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ; bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ; <S2SV_StartBug> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , <S2SV_EndBug> <S2SV_StartBug> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) <S2SV_EndBug> goto cleanup ; if ( ! ( entry -> mask & KADM5_PRINCIPAL ) ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } { krb5_timestamp last_pw_changed ; if ( ( st = krb5_dbe_lookup_last_pwd_change ( context , entry , & last_pw_changed ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( last_pw_changed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastPwdChange"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( entry -> tl_data != NULL ) { int count = 0 ; struct berval * * ber_tl_data = NULL ; krb5_tl_data * ptr ; krb5_timestamp unlock_time ; for ( ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; count ++ ; } if ( count != 0 ) { int j ; ber_tl_data = ( struct berval * * ) calloc ( count + 1 , sizeof ( struct berval * ) ) ; if ( ber_tl_data == NULL ) { st = ENOMEM ; goto cleanup ; } for ( j = 0 , ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; if ( ( st = tl_data2berval ( ptr , & ber_tl_data [ j ] ) ) != 0 ) break ; j ++ ; } if ( st == 0 ) { ber_tl_data [ count ] = NULL ; st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbExtraData"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , ber_tl_data ) ; } for ( j = 0 ; ber_tl_data [ j ] != NULL ; j ++ ) { free ( ber_tl_data [ j ] -> bv_val ) ; free ( ber_tl_data [ j ] ) ; } free ( ber_tl_data ) ; if ( st != 0 ) goto cleanup ; } if ( ( st = krb5_dbe_lookup_last_admin_unlock ( context , entry , & unlock_time ) ) != 0 ) goto cleanup ; if ( unlock_time != 0 ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( unlock_time ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastAdminUnlock"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( xargs . tktpolicydn != NULL ) { int tmask = 0 ; if ( strlen ( xargs . tktpolicydn ) != 0 ) { st = checkattributevalue ( ld , xargs . tktpolicydn , ""objectclass"" , policyclass , & tmask ) ; CHECK_CLASS_VALIDITY ( st , tmask , _ ( ""ticket<S2SV_blank>policy<S2SV_blank>object<S2SV_blank>value:<S2SV_blank>"" ) ) ; strval [ 0 ] = xargs . tktpolicydn ; strval [ 1 ] = NULL ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbticketpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbticketpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } } if ( establish_links == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = xargs . linkdn ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbObjectReferences"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( mods == NULL ) goto cleanup ; if ( create_standalone_prinicipal == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = ""krbprincipal"" ; strval [ 1 ] = ""krbprincipalaux"" ; strval [ 2 ] = ""krbTicketPolicyAux"" ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""objectclass"" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; if ( st == LDAP_ALREADY_EXISTS && entry -> mask & KADM5_LOAD ) { st = ldap_delete_ext_s ( ld , standalone_principal_dn , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>"" ""entry):<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } else { st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; } } if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>add<S2SV_blank>failed:<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } } else { { char * attrvalues [ ] = { ""krbprincipalaux"" , ""krbTicketPolicyAux"" , NULL } ; int p , q , r = 0 , amask = 0 ; if ( ( st = checkattributevalue ( ld , ( xargs . dn ) ? xargs . dn : principal_dn , ""objectclass"" , attrvalues , & amask ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; for ( p = 1 , q = 0 ; p <= 2 ; p <<= 1 , ++ q ) { if ( ( p & amask ) == 0 ) strval [ r ++ ] = attrvalues [ q ] ; } if ( r != 0 ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""objectclass"" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; } } if ( xargs . dn != NULL ) st = ldap_modify_ext_s ( ld , xargs . dn , mods , NULL , NULL ) ; else st = ldap_modify_ext_s ( ld , principal_dn , mods , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""User<S2SV_blank>modification<S2SV_blank>failed:<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_MOD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) entry -> fail_auth_count ++ ; } cleanup : if ( user ) free ( user ) ; if ( filtuser ) free ( filtuser ) ; free_xargs ( xargs ) ; if ( standalone_principal_dn ) free ( standalone_principal_dn ) ; if ( principal_dn ) free ( principal_dn ) ; if ( polname != NULL ) free ( polname ) ; for ( tre = 0 ; tre < ntrees ; tre ++ ) free ( subtreelist [ tre ] ) ; free ( subtreelist ) ; if ( subtree ) free ( subtree ) ; if ( bersecretkey ) { for ( l = 0 ; bersecretkey [ l ] ; ++ l ) { if ( bersecretkey [ l ] -> bv_val ) free ( bersecretkey [ l ] -> bv_val ) ; free ( bersecretkey [ l ] ) ; } free ( bersecretkey ) ; } if ( keys ) free ( keys ) ; ldap_mods_free ( mods , 1 ) ; ldap_osa_free_princ_ent ( & princ_ent ) ; ldap_msgfree ( result ) ; krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return ( st ) ; }
","<S2SV_ModStart> ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> st = krb5_add_ber_mem_ldap_mod <S2SV_ModStart> , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> if ( !
",krb5@krb5/04038bf3633c4b909b5ded3072dc88c8c419bf16,CVE-2014-5354,https://github.com/krb5/krb5/commit/04038bf3633c4b909b5ded3072dc88c8c419bf16,2014-12-16T23:59Z,"<S2SV_StartBug> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , <S2SV_EndBug> <S2SV_StartBug> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) <S2SV_EndBug>"
1433,CWE-119,"void vp8_first_pass ( VP8_COMP * cpi ) { int mb_row , mb_col ; MACROBLOCK * const x = & cpi -> mb ; VP8_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; int recon_yoffset , recon_uvoffset ; YV12_BUFFER_CONFIG * lst_yv12 = & cm -> yv12_fb [ cm -> lst_fb_idx ] ; YV12_BUFFER_CONFIG * new_yv12 = & cm -> yv12_fb [ cm -> new_fb_idx ] ; YV12_BUFFER_CONFIG * gld_yv12 = & cm -> yv12_fb [ cm -> gld_fb_idx ] ; int recon_y_stride = lst_yv12 -> y_stride ; int recon_uv_stride = lst_yv12 -> uv_stride ; int64_t intra_error = 0 ; int64_t coded_error = 0 ; int sum_mvr = 0 , sum_mvc = 0 ; int sum_mvr_abs = 0 , sum_mvc_abs = 0 ; int sum_mvrs = 0 , sum_mvcs = 0 ; int mvcount = 0 ; int intercount = 0 ; int second_ref_count = 0 ; int intrapenalty = 256 ; int neutral_count = 0 ; int new_mv_count = 0 ; int sum_in_vectors = 0 ; uint32_t lastmv_as_int = 0 ; int_mv zero_ref_mv ; zero_ref_mv . as_int = 0 ; vp8_clear_system_state ( ) ; x -> src = * cpi -> Source ; xd -> pre = * lst_yv12 ; xd -> dst = * new_yv12 ; x -> partition_info = x -> pi ; xd -> mode_info_context = cm -> mi ; if ( ! cm -> use_bilinear_mc_filter ) { xd -> subpixel_predict = vp8_sixtap_predict4x4 ; xd -> subpixel_predict8x4 = vp8_sixtap_predict8x4 ; xd -> subpixel_predict8x8 = vp8_sixtap_predict8x8 ; xd -> subpixel_predict16x16 = vp8_sixtap_predict16x16 ; } else { xd -> subpixel_predict = vp8_bilinear_predict4x4 ; xd -> subpixel_predict8x4 = vp8_bilinear_predict8x4 ; xd -> subpixel_predict8x8 = vp8_bilinear_predict8x8 ; xd -> subpixel_predict16x16 = vp8_bilinear_predict16x16 ; } vp8_build_block_offsets ( x ) ; vp8_setup_intra_recon ( new_yv12 ) ; vp8cx_frame_init_quantizer ( cpi ) ; { int flag [ 2 ] = { 1 , 1 } ; vp8_initialize_rd_consts ( cpi , x , vp8_dc_quant ( cm -> base_qindex , cm -> y1dc_delta_q ) ) ; <S2SV_StartBug> vpx_memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cm -> fc . mvc , flag ) ; } for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { int_mv best_ref_mv ; best_ref_mv . as_int = 0 ; xd -> up_available = ( mb_row != 0 ) ; recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; recon_uvoffset = ( mb_row * recon_uv_stride * 8 ) ; x -> mv_row_min = - ( ( mb_row * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { int this_error ; int gf_motion_error = INT_MAX ; int use_dc_pred = ( mb_col || mb_row ) && ( ! mb_col || ! mb_row ) ; xd -> dst . y_buffer = new_yv12 -> y_buffer + recon_yoffset ; xd -> dst . u_buffer = new_yv12 -> u_buffer + recon_uvoffset ; xd -> dst . v_buffer = new_yv12 -> v_buffer + recon_uvoffset ; xd -> left_available = ( mb_col != 0 ) ; vp8_copy_mem16x16 ( x -> src . y_buffer , x -> src . y_stride , x -> thismb , 16 ) ; this_error = vp8_encode_intra ( cpi , x , use_dc_pred ) ; this_error += intrapenalty ; intra_error += ( int64_t ) this_error ; x -> mv_col_min = - ( ( mb_col * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; if ( cm -> current_video_frame > 0 ) { BLOCKD * d = & x -> e_mbd . block [ 0 ] ; MV tmp_mv = { 0 , 0 } ; int tmp_err ; int motion_error = INT_MAX ; int raw_motion_error = INT_MAX ; zz_motion_search ( cpi , x , cpi -> last_frame_unscaled_source , & raw_motion_error , lst_yv12 , & motion_error , recon_yoffset ) ; d -> bmi . mv . as_mv . row = 0 ; d -> bmi . mv . as_mv . col = 0 ; if ( raw_motion_error < cpi -> oxcf . encode_breakout ) goto skip_motion_search ; first_pass_motion_search ( cpi , x , & best_ref_mv , & d -> bmi . mv . as_mv , lst_yv12 , & motion_error , recon_yoffset ) ; if ( best_ref_mv . as_int ) { tmp_err = INT_MAX ; first_pass_motion_search ( cpi , x , & zero_ref_mv , & tmp_mv , lst_yv12 , & tmp_err , recon_yoffset ) ; if ( tmp_err < motion_error ) { motion_error = tmp_err ; d -> bmi . mv . as_mv . row = tmp_mv . row ; d -> bmi . mv . as_mv . col = tmp_mv . col ; } } if ( cm -> current_video_frame > 1 ) { first_pass_motion_search ( cpi , x , & zero_ref_mv , & tmp_mv , gld_yv12 , & gf_motion_error , recon_yoffset ) ; if ( ( gf_motion_error < motion_error ) && ( gf_motion_error < this_error ) ) { second_ref_count ++ ; } xd -> pre . y_buffer = lst_yv12 -> y_buffer + recon_yoffset ; xd -> pre . u_buffer = lst_yv12 -> u_buffer + recon_uvoffset ; xd -> pre . v_buffer = lst_yv12 -> v_buffer + recon_uvoffset ; } skip_motion_search : best_ref_mv . as_int = 0 ; if ( motion_error <= this_error ) { if ( ( ( ( this_error - intrapenalty ) * 9 ) <= ( motion_error * 10 ) ) && ( this_error < ( 2 * intrapenalty ) ) ) { neutral_count ++ ; } d -> bmi . mv . as_mv . row *= 8 ; d -> bmi . mv . as_mv . col *= 8 ; this_error = motion_error ; vp8_set_mbmode_and_mvs ( x , NEWMV , & d -> bmi . mv ) ; vp8_encode_inter16x16y ( x ) ; sum_mvr += d -> bmi . mv . as_mv . row ; sum_mvr_abs += abs ( d -> bmi . mv . as_mv . row ) ; sum_mvc += d -> bmi . mv . as_mv . col ; sum_mvc_abs += abs ( d -> bmi . mv . as_mv . col ) ; sum_mvrs += d -> bmi . mv . as_mv . row * d -> bmi . mv . as_mv . row ; sum_mvcs += d -> bmi . mv . as_mv . col * d -> bmi . mv . as_mv . col ; intercount ++ ; best_ref_mv . as_int = d -> bmi . mv . as_int ; if ( d -> bmi . mv . as_int ) { mvcount ++ ; if ( d -> bmi . mv . as_int != lastmv_as_int ) new_mv_count ++ ; lastmv_as_int = d -> bmi . mv . as_int ; if ( mb_row < cm -> mb_rows / 2 ) { if ( d -> bmi . mv . as_mv . row > 0 ) sum_in_vectors -- ; else if ( d -> bmi . mv . as_mv . row < 0 ) sum_in_vectors ++ ; } else if ( mb_row > cm -> mb_rows / 2 ) { if ( d -> bmi . mv . as_mv . row > 0 ) sum_in_vectors ++ ; else if ( d -> bmi . mv . as_mv . row < 0 ) sum_in_vectors -- ; } if ( mb_col < cm -> mb_cols / 2 ) { if ( d -> bmi . mv . as_mv . col > 0 ) sum_in_vectors -- ; else if ( d -> bmi . mv . as_mv . col < 0 ) sum_in_vectors ++ ; } else if ( mb_col > cm -> mb_cols / 2 ) { if ( d -> bmi . mv . as_mv . col > 0 ) sum_in_vectors ++ ; else if ( d -> bmi . mv . as_mv . col < 0 ) sum_in_vectors -- ; } } } } coded_error += ( int64_t ) this_error ; x -> src . y_buffer += 16 ; x -> src . u_buffer += 8 ; x -> src . v_buffer += 8 ; recon_yoffset += 16 ; recon_uvoffset += 8 ; } x -> src . y_buffer += 16 * x -> src . y_stride - 16 * cm -> mb_cols ; x -> src . u_buffer += 8 * x -> src . uv_stride - 8 * cm -> mb_cols ; x -> src . v_buffer += 8 * x -> src . uv_stride - 8 * cm -> mb_cols ; vp8_extend_mb_row ( new_yv12 , xd -> dst . y_buffer + 16 , xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; vp8_clear_system_state ( ) ; } vp8_clear_system_state ( ) ; { double weight = 0.0 ; FIRSTPASS_STATS fps ; fps . frame = cm -> current_video_frame ; fps . intra_error = ( double ) ( intra_error >> 8 ) ; fps . coded_error = ( double ) ( coded_error >> 8 ) ; weight = simple_weight ( cpi -> Source ) ; if ( weight < 0.1 ) weight = 0.1 ; fps . ssim_weighted_pred_err = fps . coded_error * weight ; fps . pcnt_inter = 0.0 ; fps . pcnt_motion = 0.0 ; fps . MVr = 0.0 ; fps . mvr_abs = 0.0 ; fps . MVc = 0.0 ; fps . mvc_abs = 0.0 ; fps . MVrv = 0.0 ; fps . MVcv = 0.0 ; fps . mv_in_out_count = 0.0 ; fps . new_mv_count = 0.0 ; fps . count = 1.0 ; fps . pcnt_inter = 1.0 * ( double ) intercount / cm -> MBs ; fps . pcnt_second_ref = 1.0 * ( double ) second_ref_count / cm -> MBs ; fps . pcnt_neutral = 1.0 * ( double ) neutral_count / cm -> MBs ; if ( mvcount > 0 ) { fps . MVr = ( double ) sum_mvr / ( double ) mvcount ; fps . mvr_abs = ( double ) sum_mvr_abs / ( double ) mvcount ; fps . MVc = ( double ) sum_mvc / ( double ) mvcount ; fps . mvc_abs = ( double ) sum_mvc_abs / ( double ) mvcount ; fps . MVrv = ( ( double ) sum_mvrs - ( fps . MVr * fps . MVr / ( double ) mvcount ) ) / ( double ) mvcount ; fps . MVcv = ( ( double ) sum_mvcs - ( fps . MVc * fps . MVc / ( double ) mvcount ) ) / ( double ) mvcount ; fps . mv_in_out_count = ( double ) sum_in_vectors / ( double ) ( mvcount * 2 ) ; fps . new_mv_count = new_mv_count ; fps . pcnt_motion = 1.0 * ( double ) mvcount / cpi -> common . MBs ; } fps . duration = ( double ) ( cpi -> source -> ts_end - cpi -> source -> ts_start ) ; memcpy ( & cpi -> twopass . this_frame_stats , & fps , sizeof ( FIRSTPASS_STATS ) ) ; output_stats ( cpi , cpi -> output_pkt_list , & cpi -> twopass . this_frame_stats ) ; accumulate_stats ( & cpi -> twopass . total_stats , & fps ) ; } if ( ( cm -> current_video_frame > 0 ) && ( cpi -> twopass . this_frame_stats . pcnt_inter > 0.20 ) && ( ( cpi -> twopass . this_frame_stats . intra_error / DOUBLE_DIVIDE_CHECK ( cpi -> twopass . this_frame_stats . coded_error ) ) > 2.0 ) ) { vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; } vp8_swap_yv12_buffer ( lst_yv12 , new_yv12 ) ; vp8_yv12_extend_frame_borders ( lst_yv12 ) ; if ( cm -> current_video_frame == 0 ) { vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; } if ( 0 ) { char filename [ 512 ] ; FILE * recon_file ; sprintf ( filename , ""enc%04d.yuv"" , ( int ) cm -> current_video_frame ) ; if ( cm -> current_video_frame == 0 ) recon_file = fopen ( filename , ""wb"" ) ; else recon_file = fopen ( filename , ""ab"" ) ; ( void ) fwrite ( lst_yv12 -> buffer_alloc , lst_yv12 -> frame_size , 1 , recon_file ) ; fclose ( recon_file ) ; } cm -> current_video_frame ++ ; }
","<S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( cm ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug>"
3478,CWE-284,"static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { <S2SV_StartBug> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; <S2SV_EndBug> list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; <S2SV_StartBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ; <S2SV_EndBug> if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; <S2SV_StartBug> umount_mnt ( p ) ; <S2SV_EndBug> } <S2SV_StartBug> change_mnt_propagation ( p , MS_PRIVATE ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ) ) { bool disconnect ; <S2SV_ModStart> |= MNT_SYNC_UMOUNT ; disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> -> mnt , disconnect ? & unmounted : NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { <S2SV_ModStart> ) ; } }
",torvalds@linux/ce07d891a0891d3c0d0c2d73d577490486b809e1,CVE-2014-9717,https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1,2016-05-02T10:59Z,"<S2SV_StartBug> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; <S2SV_EndBug> <S2SV_StartBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ; <S2SV_EndBug> <S2SV_StartBug> umount_mnt ( p ) ; <S2SV_EndBug> <S2SV_StartBug> change_mnt_propagation ( p , MS_PRIVATE ) ; <S2SV_EndBug>"
656,CWE-125,"<S2SV_StartBug> void ntlm_print_negotiate_flags ( UINT32 flags ) <S2SV_EndBug> { int i ; const char * str ; WLog_INFO ( TAG , ""negotiateFlags<S2SV_blank>\\""0x%08"" PRIX32 ""\\"""" , flags ) ; for ( i = 31 ; i >= 0 ; i -- ) { if ( ( flags >> i ) & 1 ) { str = NTLM_NEGOTIATE_STRINGS [ ( 31 - i ) ] ; WLog_INFO ( TAG , ""\\t%s<S2SV_blank>(%d),"" , str , ( 31 - i ) ) ; } } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z,<S2SV_StartBug> void ntlm_print_negotiate_flags ( UINT32 flags ) <S2SV_EndBug>
2434,CWE-399,"int hugepage_madvise ( struct vm_area_struct * vma , unsigned long * vm_flags , int advice ) { switch ( advice ) { case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE | <S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ; * vm_flags &= ~ VM_NOHUGEPAGE ; * vm_flags |= VM_HUGEPAGE ; if ( unlikely ( khugepaged_enter_vma_merge ( vma ) ) ) return - ENOMEM ; break ; case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE | <S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ; * vm_flags &= ~ VM_HUGEPAGE ; * vm_flags |= VM_NOHUGEPAGE ; break ; } return 0 ; }
","<S2SV_ModStart> ( VM_HUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( VM_NOHUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return
",torvalds@linux/78f11a255749d09025f54d4e2df4fbcb031530e2,CVE-2011-2479,https://github.com/torvalds/linux/commit/78f11a255749d09025f54d4e2df4fbcb031530e2,2013-03-01T12:37Z,<S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> <S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug>
6872,CWE-000,"static int selectExpander ( Walker * pWalker , Select * p ) { Parse * pParse = pWalker -> pParse ; int i , j , k ; SrcList * pTabList ; ExprList * pEList ; struct SrcList_item * pFrom ; sqlite3 * db = pParse -> db ; Expr * pE , * pRight , * pExpr ; u16 selFlags = p -> selFlags ; u32 elistFlags = 0 ; p -> selFlags |= SF_Expanded ; if ( db -> mallocFailed ) { return WRC_Abort ; } assert ( p -> pSrc != 0 ) ; if ( ( selFlags & SF_Expanded ) != 0 ) { return WRC_Prune ; } if ( pWalker -> eCode ) { p -> selId = ++ pParse -> nSelect ; } pTabList = p -> pSrc ; pEList = p -> pEList ; sqlite3WithPush ( pParse , p -> pWith , 0 ) ; sqlite3SrcListAssignCursors ( pParse , pTabList ) ; for ( i = 0 , pFrom = pTabList -> a ; i < pTabList -> nSrc ; i ++ , pFrom ++ ) { Table * pTab ; assert ( pFrom -> fg . isRecursive == 0 || pFrom -> pTab != 0 ) ; if ( pFrom -> fg . isRecursive ) continue ; assert ( pFrom -> pTab == 0 ) ; # ifndef SQLITE_OMIT_CTE if ( withExpand ( pWalker , pFrom ) ) return WRC_Abort ; if ( pFrom -> pTab ) { } else # endif if ( pFrom -> zName == 0 ) { # ifndef SQLITE_OMIT_SUBQUERY Select * pSel = pFrom -> pSelect ; assert ( pSel != 0 ) ; assert ( pFrom -> pTab == 0 ) ; if ( sqlite3WalkSelect ( pWalker , pSel ) ) return WRC_Abort ; if ( sqlite3ExpandSubquery ( pParse , pFrom ) ) return WRC_Abort ; # endif } else { assert ( pFrom -> pTab == 0 ) ; pFrom -> pTab = pTab = sqlite3LocateTableItem ( pParse , 0 , pFrom ) ; if ( pTab == 0 ) return WRC_Abort ; if ( pTab -> nTabRef >= 0xffff ) { sqlite3ErrorMsg ( pParse , ""too<S2SV_blank>many<S2SV_blank>references<S2SV_blank>to<S2SV_blank>\\""%s\\"":<S2SV_blank>max<S2SV_blank>65535"" , pTab -> zName ) ; pFrom -> pTab = 0 ; return WRC_Abort ; } pTab -> nTabRef ++ ; if ( ! IsVirtual ( pTab ) && cannotBeFunction ( pParse , pFrom ) ) { return WRC_Abort ; } # if ! defined ( SQLITE_OMIT_VIEW ) || ! defined ( SQLITE_OMIT_VIRTUALTABLE ) if ( IsVirtual ( pTab ) || pTab -> pSelect ) { i16 nCol ; u8 eCodeOrig = pWalker -> eCode ; if ( sqlite3ViewGetColumnNames ( pParse , pTab ) ) return WRC_Abort ; assert ( pFrom -> pSelect == 0 ) ; if ( pTab -> pSelect && ( db -> flags & SQLITE_EnableView ) == 0 ) { sqlite3ErrorMsg ( pParse , ""access<S2SV_blank>to<S2SV_blank>view<S2SV_blank>\\""%s\\""<S2SV_blank>prohibited"" , pTab -> zName ) ; } pFrom -> pSelect = sqlite3SelectDup ( db , pTab -> pSelect , 0 ) ; nCol = pTab -> nCol ; pTab -> nCol = - 1 ; pWalker -> eCode = 1 ; sqlite3WalkSelect ( pWalker , pFrom -> pSelect ) ; pWalker -> eCode = eCodeOrig ; pTab -> nCol = nCol ; } # endif } if ( sqlite3IndexedByLookup ( pParse , pFrom ) ) { return WRC_Abort ; } } <S2SV_StartBug> if ( db -> mallocFailed || sqliteProcessJoin ( pParse , p ) ) { <S2SV_EndBug> return WRC_Abort ; } for ( k = 0 ; k < pEList -> nExpr ; k ++ ) { pE = pEList -> a [ k ] . pExpr ; if ( pE -> op == TK_ASTERISK ) break ; assert ( pE -> op != TK_DOT || pE -> pRight != 0 ) ; assert ( pE -> op != TK_DOT || ( pE -> pLeft != 0 && pE -> pLeft -> op == TK_ID ) ) ; if ( pE -> op == TK_DOT && pE -> pRight -> op == TK_ASTERISK ) break ; elistFlags |= pE -> flags ; } if ( k < pEList -> nExpr ) { struct ExprList_item * a = pEList -> a ; ExprList * pNew = 0 ; int flags = pParse -> db -> flags ; int longNames = ( flags & SQLITE_FullColNames ) != 0 && ( flags & SQLITE_ShortColNames ) == 0 ; for ( k = 0 ; k < pEList -> nExpr ; k ++ ) { pE = a [ k ] . pExpr ; elistFlags |= pE -> flags ; pRight = pE -> pRight ; assert ( pE -> op != TK_DOT || pRight != 0 ) ; if ( pE -> op != TK_ASTERISK && ( pE -> op != TK_DOT || pRight -> op != TK_ASTERISK ) ) { pNew = sqlite3ExprListAppend ( pParse , pNew , a [ k ] . pExpr ) ; if ( pNew ) { pNew -> a [ pNew -> nExpr - 1 ] . zName = a [ k ] . zName ; pNew -> a [ pNew -> nExpr - 1 ] . zSpan = a [ k ] . zSpan ; a [ k ] . zName = 0 ; a [ k ] . zSpan = 0 ; } a [ k ] . pExpr = 0 ; } else { int tableSeen = 0 ; char * zTName = 0 ; if ( pE -> op == TK_DOT ) { assert ( pE -> pLeft != 0 ) ; assert ( ! ExprHasProperty ( pE -> pLeft , EP_IntValue ) ) ; zTName = pE -> pLeft -> u . zToken ; } for ( i = 0 , pFrom = pTabList -> a ; i < pTabList -> nSrc ; i ++ , pFrom ++ ) { Table * pTab = pFrom -> pTab ; Select * pSub = pFrom -> pSelect ; char * zTabName = pFrom -> zAlias ; const char * zSchemaName = 0 ; int iDb ; if ( zTabName == 0 ) { zTabName = pTab -> zName ; } if ( db -> mallocFailed ) break ; if ( pSub == 0 || ( pSub -> selFlags & SF_NestedFrom ) == 0 ) { pSub = 0 ; if ( zTName && sqlite3StrICmp ( zTName , zTabName ) != 0 ) { continue ; } iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; zSchemaName = iDb >= 0 ? db -> aDb [ iDb ] . zDbSName : ""*"" ; } for ( j = 0 ; j < pTab -> nCol ; j ++ ) { char * zName = pTab -> aCol [ j ] . zName ; char * zColname ; char * zToFree ; Token sColname ; assert ( zName ) ; if ( zTName && pSub && sqlite3MatchSpanName ( pSub -> pEList -> a [ j ] . zSpan , 0 , zTName , 0 ) == 0 ) { continue ; } if ( ( p -> selFlags & SF_IncludeHidden ) == 0 && IsHiddenColumn ( & pTab -> aCol [ j ] ) ) { continue ; } tableSeen = 1 ; if ( i > 0 && zTName == 0 ) { if ( ( pFrom -> fg . jointype & JT_NATURAL ) != 0 && tableAndColumnIndex ( pTabList , i , zName , 0 , 0 ) ) { continue ; } if ( sqlite3IdListIndex ( pFrom -> pUsing , zName ) >= 0 ) { continue ; } } pRight = sqlite3Expr ( db , TK_ID , zName ) ; zColname = zName ; zToFree = 0 ; if ( longNames || pTabList -> nSrc > 1 ) { Expr * pLeft ; pLeft = sqlite3Expr ( db , TK_ID , zTabName ) ; pExpr = sqlite3PExpr ( pParse , TK_DOT , pLeft , pRight ) ; if ( zSchemaName ) { pLeft = sqlite3Expr ( db , TK_ID , zSchemaName ) ; pExpr = sqlite3PExpr ( pParse , TK_DOT , pLeft , pExpr ) ; } if ( longNames ) { zColname = sqlite3MPrintf ( db , ""%s.%s"" , zTabName , zName ) ; zToFree = zColname ; } } else { pExpr = pRight ; } pNew = sqlite3ExprListAppend ( pParse , pNew , pExpr ) ; sqlite3TokenInit ( & sColname , zColname ) ; sqlite3ExprListSetName ( pParse , pNew , & sColname , 0 ) ; if ( pNew && ( p -> selFlags & SF_NestedFrom ) != 0 ) { struct ExprList_item * pX = & pNew -> a [ pNew -> nExpr - 1 ] ; if ( pSub ) { pX -> zSpan = sqlite3DbStrDup ( db , pSub -> pEList -> a [ j ] . zSpan ) ; testcase ( pX -> zSpan == 0 ) ; } else { pX -> zSpan = sqlite3MPrintf ( db , ""%s.%s.%s"" , zSchemaName , zTabName , zColname ) ; testcase ( pX -> zSpan == 0 ) ; } pX -> bSpanIsTab = 1 ; } sqlite3DbFree ( db , zToFree ) ; } } if ( ! tableSeen ) { if ( zTName ) { sqlite3ErrorMsg ( pParse , ""no<S2SV_blank>such<S2SV_blank>table:<S2SV_blank>%s"" , zTName ) ; } else { sqlite3ErrorMsg ( pParse , ""no<S2SV_blank>tables<S2SV_blank>specified"" ) ; } } } } sqlite3ExprListDelete ( db , pEList ) ; p -> pEList = pNew ; } if ( p -> pEList ) { if ( p -> pEList -> nExpr > db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { sqlite3ErrorMsg ( pParse , ""too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>in<S2SV_blank>result<S2SV_blank>set"" ) ; return WRC_Abort ; } if ( ( elistFlags & ( EP_HasFunc | EP_Subquery ) ) != 0 ) { p -> selFlags |= SF_ComplexResult ; } } return WRC_Continue ; }
","<S2SV_ModStart> } if ( pParse -> nErr ||
",sqlite@sqlite/a6c1a71cde082e09750465d5675699062922e387,CVE-2019-20218,https://github.com/sqlite/sqlite/commit/a6c1a71cde082e09750465d5675699062922e387,2020-01-02T14:16Z,"<S2SV_StartBug> if ( db -> mallocFailed || sqliteProcessJoin ( pParse , p ) ) { <S2SV_EndBug>"
4874,CWE-362,"static int <S2SV_StartBug> mptctl_gettargetinfo ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_targetinfo __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_targetinfo karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> VirtDevice * vdevice ; char * pmem ; <S2SV_StartBug> int * pdata ; <S2SV_EndBug> int iocnum ; int numDevices = 0 ; int lun ; int maxWordsLeft ; int numBytes ; u8 port ; struct scsi_device * sdev ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_targetinfo ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_gettargetinfo<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_targetinfo<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_gettargetinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_gettargetinfo<S2SV_blank>called.\\n"" , ioc -> name ) ) ; numBytes = karg . hdr . maxDataSize - sizeof ( mpt_ioctl_header ) ; maxWordsLeft = numBytes / sizeof ( int ) ; port = karg . hdr . port ; if ( maxWordsLeft <= 0 ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_gettargetinfo()<S2SV_blank>-<S2SV_blank>no<S2SV_blank>memory<S2SV_blank>available!\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; return - ENOMEM ; } pmem = kzalloc ( numBytes , GFP_KERNEL ) ; if ( ! pmem ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_gettargetinfo()<S2SV_blank>-<S2SV_blank>no<S2SV_blank>memory<S2SV_blank>available!\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; return - ENOMEM ; } pdata = ( int * ) pmem ; if ( ioc -> sh ) { shost_for_each_device ( sdev , ioc -> sh ) { if ( ! maxWordsLeft ) continue ; vdevice = sdev -> hostdata ; if ( vdevice == NULL || vdevice -> vtarget == NULL ) continue ; if ( vdevice -> vtarget -> tflags & MPT_TARGET_FLAGS_RAID_COMPONENT ) continue ; lun = ( vdevice -> vtarget -> raidVolume ) ? 0x80 : vdevice -> lun ; * pdata = ( ( ( u8 ) lun << 16 ) + ( vdevice -> vtarget -> channel << 8 ) + ( vdevice -> vtarget -> id ) ) ; pdata ++ ; numDevices ++ ; -- maxWordsLeft ; } } karg . numDevices = numDevices ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( struct mpt_ioctl_targetinfo ) ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_gettargetinfo<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_targetinfo<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; kfree ( pmem ) ; return - EFAULT ; } if ( copy_to_user ( uarg -> targetInfo , pmem , numBytes ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_gettargetinfo<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_targetinfo<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , pdata ) ; kfree ( pmem ) ; return - EFAULT ; } kfree ( pmem ) ; return 0 ; }
","<S2SV_ModStart> int mptctl_gettargetinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_targetinfo karg ; <S2SV_ModEnd> VirtDevice * vdevice <S2SV_ModStart> int * pdata <S2SV_ModEnd> ; int numDevices <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,<S2SV_StartBug> mptctl_gettargetinfo ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> int * pdata ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug>
650,CWE-119,"int exfat_mount ( struct exfat * ef , const char * spec , const char * options ) { int rc ; enum exfat_mode mode ; exfat_tzset ( ) ; memset ( ef , 0 , sizeof ( struct exfat ) ) ; parse_options ( ef , options ) ; if ( match_option ( options , ""ro"" ) ) mode = EXFAT_MODE_RO ; else if ( match_option ( options , ""ro_fallback"" ) ) mode = EXFAT_MODE_ANY ; else mode = EXFAT_MODE_RW ; ef -> dev = exfat_open ( spec , mode ) ; if ( ef -> dev == NULL ) return - EIO ; if ( exfat_get_mode ( ef -> dev ) == EXFAT_MODE_RO ) { if ( mode == EXFAT_MODE_ANY ) ef -> ro = - 1 ; else ef -> ro = 1 ; } ef -> sb = malloc ( sizeof ( struct exfat_super_block ) ) ; if ( ef -> sb == NULL ) { exfat_close ( ef -> dev ) ; exfat_error ( ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>super<S2SV_blank>block"" ) ; return - ENOMEM ; } memset ( ef -> sb , 0 , sizeof ( struct exfat_super_block ) ) ; if ( exfat_pread ( ef -> dev , ef -> sb , sizeof ( struct exfat_super_block ) , 0 ) < 0 ) { exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( ""failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>boot<S2SV_blank>sector"" ) ; return - EIO ; } if ( memcmp ( ef -> sb -> oem_name , ""EXFAT<S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) != 0 ) { exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; <S2SV_StartBug> exfat_error ( ""exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ; <S2SV_EndBug> return - EIO ; } ef -> zero_cluster = malloc ( CLUSTER_SIZE ( * ef -> sb ) ) ; if ( ef -> zero_cluster == NULL ) { exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>zero<S2SV_blank>sector"" ) ; return - ENOMEM ; } if ( ! verify_vbr_checksum ( ef -> dev , ef -> zero_cluster , SECTOR_SIZE ( * ef -> sb ) ) ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; return - EIO ; } memset ( ef -> zero_cluster , 0 , CLUSTER_SIZE ( * ef -> sb ) ) ; if ( ef -> sb -> version . major != 1 || ef -> sb -> version . minor != 0 ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; exfat_error ( ""unsupported<S2SV_blank>exFAT<S2SV_blank>version:<S2SV_blank>%hhu.%hhu"" , ef -> sb -> version . major , ef -> sb -> version . minor ) ; free ( ef -> sb ) ; return - EIO ; } if ( ef -> sb -> fat_count != 1 ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; exfat_error ( ""unsupported<S2SV_blank>FAT<S2SV_blank>count:<S2SV_blank>%hhu"" , ef -> sb -> fat_count ) ; free ( ef -> sb ) ; return - EIO ; } <S2SV_StartBug> if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) <S2SV_EndBug> { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; exfat_error ( ""too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^%d"" , ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( le64_to_cpu ( ef -> sb -> sector_count ) * SECTOR_SIZE ( * ef -> sb ) > exfat_get_size ( ef -> dev ) ) { exfat_warn ( ""file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>underlying<S2SV_blank>device:<S2SV_blank>"" ""%"" PRIu64 ""<S2SV_blank>><S2SV_blank>%"" PRIu64 , le64_to_cpu ( ef -> sb -> sector_count ) * SECTOR_SIZE ( * ef -> sb ) , exfat_get_size ( ef -> dev ) ) ; } ef -> root = malloc ( sizeof ( struct exfat_node ) ) ; if ( ef -> root == NULL ) { free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>root<S2SV_blank>node"" ) ; return - ENOMEM ; } memset ( ef -> root , 0 , sizeof ( struct exfat_node ) ) ; ef -> root -> flags = EXFAT_ATTRIB_DIR ; ef -> root -> start_cluster = le32_to_cpu ( ef -> sb -> rootdir_cluster ) ; ef -> root -> fptr_cluster = ef -> root -> start_cluster ; ef -> root -> name [ 0 ] = cpu_to_le16 ( '\\0' ) ; ef -> root -> size = rootdir_size ( ef ) ; if ( ef -> root -> size == 0 ) { free ( ef -> root ) ; free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; return - EIO ; } ef -> root -> mtime = 0 ; ef -> root -> atime = 0 ; exfat_get_node ( ef -> root ) ; rc = exfat_cache_directory ( ef , ef -> root ) ; if ( rc != 0 ) goto error ; if ( ef -> upcase == NULL ) { exfat_error ( ""upcase<S2SV_blank>table<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ; goto error ; } if ( ef -> cmap . chunk == NULL ) { exfat_error ( ""clusters<S2SV_blank>bitmap<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ; goto error ; } if ( prepare_super_block ( ef ) != 0 ) goto error ; return 0 ; error : exfat_put_node ( ef , ef -> root ) ; exfat_reset_cache ( ef ) ; free ( ef -> root ) ; free ( ef -> zero_cluster ) ; exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; return - EIO ; }
","<S2SV_ModStart> exfat_error ( ""exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ; return - EIO ; } if ( ef -> sb -> sector_bits < 9 ) { exfat_close ( ef -> dev ) ; exfat_error ( ""too<S2SV_blank>small<S2SV_blank>sector<S2SV_blank>size:<S2SV_blank>2^%hhd"" , ef -> sb -> sector_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) { exfat_close ( ef -> dev ) ; exfat_error ( ""too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^(%hhd+%hhd)"" , ef -> sb -> sector_bits , ef -> sb -> spc_bits ) ; free ( ef -> sb <S2SV_ModStart> } if ( <S2SV_ModEnd> le64_to_cpu ( ef
",relan@exfat/2e86ae5f81da11f11673d0546efb525af02b7786,CVE-2015-8026,https://github.com/relan/exfat/commit/2e86ae5f81da11f11673d0546efb525af02b7786,2017-03-27T15:59Z,"<S2SV_StartBug> exfat_error ( ""exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) <S2SV_EndBug>"
5994,CWE-119,"int psf_binheader_readf ( SF_PRIVATE * psf , char const * format , ... ) { va_list argptr ; sf_count_t * countptr , countdata ; unsigned char * ucptr , sixteen_bytes [ 16 ] ; unsigned int * intptr , intdata ; unsigned short * shortptr ; char * charptr ; float * floatptr ; double * doubleptr ; char c ; <S2SV_StartBug> int byte_count = 0 , count ; <S2SV_EndBug> if ( ! format ) return psf_ftell ( psf ) ; va_start ( argptr , format ) ; while ( ( c = * format ++ ) ) <S2SV_StartBug> { switch ( c ) <S2SV_EndBug> { case 'e' : psf -> rwf_endian = SF_ENDIAN_LITTLE ; break ; case 'E' : psf -> rwf_endian = SF_ENDIAN_BIG ; break ; case 'm' : intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_StartBug> ucptr = ( unsigned char * ) intptr ; <S2SV_EndBug> byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; * intptr = GET_MARKER ( ucptr ) ; break ; case 'h' : <S2SV_StartBug> intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_EndBug> ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , sixteen_bytes , sizeof ( sixteen_bytes ) ) ; { int k ; intdata = 0 ; for ( k = 0 ; k < 16 ; k ++ ) intdata ^= sixteen_bytes [ k ] << k ; } * intptr = intdata ; break ; case '1' : charptr = va_arg ( argptr , char * ) ; * charptr = 0 ; byte_count += header_read ( psf , charptr , sizeof ( char ) ) ; break ; case '2' : shortptr = va_arg ( argptr , unsigned short * ) ; * shortptr = 0 ; ucptr = ( unsigned char * ) shortptr ; byte_count += header_read ( psf , ucptr , sizeof ( short ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * shortptr = GET_BE_SHORT ( ucptr ) ; else * shortptr = GET_LE_SHORT ( ucptr ) ; break ; case '3' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 3 ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * intptr = GET_BE_3BYTE ( sixteen_bytes ) ; else * intptr = GET_LE_3BYTE ( sixteen_bytes ) ; break ; case '4' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * intptr = psf_get_be32 ( ucptr , 0 ) ; else * intptr = psf_get_le32 ( ucptr , 0 ) ; break ; case '8' : countptr = va_arg ( argptr , sf_count_t * ) ; * countptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 8 ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) countdata = psf_get_be64 ( sixteen_bytes , 0 ) ; else countdata = psf_get_le64 ( sixteen_bytes , 0 ) ; * countptr = countdata ; break ; case 'f' : floatptr = va_arg ( argptr , float * ) ; * floatptr = 0.0 ; byte_count += header_read ( psf , floatptr , sizeof ( float ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * floatptr = float32_be_read ( ( unsigned char * ) floatptr ) ; else * floatptr = float32_le_read ( ( unsigned char * ) floatptr ) ; break ; case 'd' : doubleptr = va_arg ( argptr , double * ) ; * doubleptr = 0.0 ; byte_count += header_read ( psf , doubleptr , sizeof ( double ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * doubleptr = double64_be_read ( ( unsigned char * ) doubleptr ) ; else * doubleptr = double64_le_read ( ( unsigned char * ) doubleptr ) ; break ; case 's' : psf_log_printf ( psf , ""Format<S2SV_blank>conversion<S2SV_blank>\'s\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\n"" ) ; break ; case 'b' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> byte_count += header_read ( psf , charptr , count ) ; break ; <S2SV_StartBug> case 'G' : <S2SV_EndBug> charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> byte_count += header_gets ( psf , charptr , count ) ; break ; case 'z' : psf_log_printf ( psf , ""Format<S2SV_blank>conversion<S2SV_blank>\'z\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\n"" ) ; break ; case 'p' : count = va_arg ( argptr , size_t ) ; <S2SV_StartBug> header_seek ( psf , count , SEEK_SET ) ; <S2SV_EndBug> byte_count = count ; break ; case 'j' : count = va_arg ( argptr , size_t ) ; if ( count ) { header_seek ( psf , count , SEEK_CUR ) ; <S2SV_StartBug> byte_count += count ; <S2SV_EndBug> } ; break ; default : psf_log_printf ( psf , ""***<S2SV_blank>Invalid<S2SV_blank>format<S2SV_blank>specifier<S2SV_blank>`%c\'\\n"" , c ) ; psf -> error = SFE_INTERNAL ; break ; } ; } ; va_end ( argptr ) ; return byte_count ; }
","<S2SV_ModStart> 0 , count = 0 <S2SV_ModStart> ) ) { if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> * ) ; * intptr = 0 ; <S2SV_ModStart> int * ) ; * intptr = 0 <S2SV_ModStart> size_t ) ; memset ( charptr , 0 , count ) ; byte_count += header_read ( psf , charptr , count ) ; break ; case 'G' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; memset ( charptr , 0 , count ) ; if ( psf -> header . indx + count >= psf -> header . len && psf_bump_header_allocation ( psf , count ) ) return 0 ; byte_count += header_gets <S2SV_ModEnd> ( psf , <S2SV_ModStart> break ; case 'z' : psf_log_printf ( psf , ""Format<S2SV_blank>conversion<S2SV_blank>\'z\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\n"" ) ; break ; case 'p' : <S2SV_ModEnd> count = va_arg <S2SV_ModStart> size_t ) ; header_seek ( psf , count , SEEK_SET ) ; byte_count = count ; break ; case 'j' <S2SV_ModEnd> : count = <S2SV_ModStart> , count , <S2SV_ModEnd> SEEK_CUR ) ; <S2SV_ModStart> byte_count += count <S2SV_ModEnd> ; break ;
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,"<S2SV_StartBug> int byte_count = 0 , count ; <S2SV_EndBug> <S2SV_StartBug> { switch ( c ) <S2SV_EndBug> <S2SV_StartBug> ucptr = ( unsigned char * ) intptr ; <S2SV_EndBug> <S2SV_StartBug> intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_EndBug> <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> <S2SV_StartBug> case 'G' : <S2SV_EndBug> <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> <S2SV_StartBug> header_seek ( psf , count , SEEK_SET ) ; <S2SV_EndBug> <S2SV_StartBug> byte_count += count ; <S2SV_EndBug>"
6362,CWE-134,"<S2SV_StartBug> static int bad_format_imginfo ( <S2SV_EndBug> char * fmt ) { <S2SV_StartBug> char * ptr ; <S2SV_EndBug> int n = 0 ; ptr = fmt ; while ( * ptr != '\\0' ) if ( * ptr ++ == '%' ) { if ( * ptr == '\\0' ) return 1 ; if ( * ptr == '%' ) ptr ++ ; else if ( * ptr == 's' || * ptr == 'S' ) { n = 1 ; ptr ++ ; } else { if ( * ptr == '<S2SV_blank>' ) ptr ++ ; while ( * ptr >= '0' && * ptr <= '9' ) ptr ++ ; if ( * ptr ++ != 'l' ) return 1 ; if ( * ptr == 'u' ) ptr ++ ; else return 1 ; n ++ ; } } return ( n != 3 ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int bad_format_imginfo ( <S2SV_ModStart> fmt ) { return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt <S2SV_ModEnd> ) ; }
",oetiker@rrdtool-1.x/85261a013112e278c90224033f5b0592ee387786,CVE-2014-6262,https://github.com/oetiker/rrdtool-1.x/commit/85261a013112e278c90224033f5b0592ee387786,2020-02-12T02:15Z,<S2SV_StartBug> static int bad_format_imginfo ( <S2SV_EndBug> <S2SV_StartBug> char * ptr ; <S2SV_EndBug>
6972,CWE-787,"static int webSocketsDecodeHybi ( rfbClientPtr cl , char * dst , int len ) { <S2SV_StartBug> char * buf , * payload ; <S2SV_EndBug> uint32_t * payload32 ; <S2SV_StartBug> int ret = - 1 , result = - 1 ; <S2SV_EndBug> <S2SV_StartBug> int total = 0 ; <S2SV_EndBug> ws_mask_t mask ; ws_header_t * header ; int i ; unsigned char opcode ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; int flength , fhlen ; if ( wsctx -> readbuflen ) { if ( wsctx -> readbuflen > len ) { memcpy ( dst , wsctx -> readbuf + wsctx -> readbufstart , len ) ; result = len ; wsctx -> readbuflen -= len ; wsctx -> readbufstart += len ; } else { memcpy ( dst , wsctx -> readbuf + wsctx -> readbufstart , wsctx -> readbuflen ) ; result = wsctx -> readbuflen ; wsctx -> readbuflen = 0 ; wsctx -> readbufstart = 0 ; } goto spor ; } buf = wsctx -> codeBufDecode ; header = ( ws_header_t * ) wsctx -> codeBufDecode ; ret = ws_peek ( cl , buf , B64LEN ( len ) + WSHLENMAX ) ; if ( ret < 2 ) { if ( - 1 == ret ) { int olderrno = errno ; rfbErr ( ""%s:<S2SV_blank>peek;<S2SV_blank>%m\\n"" , __func__ ) ; errno = olderrno ; <S2SV_StartBug> } else if ( 0 == ret ) { <S2SV_EndBug> result = 0 ; } else { errno = EAGAIN ; } goto spor ; } opcode = header -> b0 & 0x0f ; flength = header -> b1 & 0x7f ; if ( ! ( header -> b1 & 0x80 ) ) { rfbErr ( ""%s:<S2SV_blank>got<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>mask\\n"" , __func__ , ret ) ; errno = EIO ; goto spor ; } if ( flength < 126 ) { fhlen = 2 ; mask = header -> u . m ; } else if ( flength == 126 && 4 <= ret ) { flength = WS_NTOH16 ( header -> u . s16 . l16 ) ; fhlen = 4 ; mask = header -> u . s16 . m16 ; } else if ( flength == 127 && 10 <= ret ) { flength = WS_NTOH64 ( header -> u . s64 . l64 ) ; fhlen = 10 ; mask = header -> u . s64 . m64 ; } else { rfbErr ( ""%s:<S2SV_blank>incomplete<S2SV_blank>frame<S2SV_blank>header\\n"" , __func__ , ret ) ; errno = EIO ; goto spor ; } total = fhlen + flength + 4 ; payload = buf + fhlen + 4 ; if ( - 1 == ( ret = ws_read ( cl , buf , total ) ) ) { int olderrno = errno ; rfbErr ( ""%s:<S2SV_blank>read;<S2SV_blank>%m"" , __func__ ) ; errno = olderrno ; return ret ; } else if ( ret < total ) { rfbLog ( ""%s:<S2SV_blank>read;<S2SV_blank>got<S2SV_blank>partial<S2SV_blank>data\\n"" , __func__ ) ; } else { buf [ ret ] = '\\0' ; } payload32 = ( uint32_t * ) payload ; for ( i = 0 ; i < flength / 4 ; i ++ ) { payload32 [ i ] ^= mask . u ; } for ( i *= 4 ; i < flength ; i ++ ) { payload [ i ] ^= mask . c [ i % 4 ] ; } switch ( opcode ) { case WS_OPCODE_CLOSE : rfbLog ( ""got<S2SV_blank>closure,<S2SV_blank>reason<S2SV_blank>%d\\n"" , WS_NTOH16 ( ( ( uint16_t * ) payload ) [ 0 ] ) ) ; errno = ECONNRESET ; break ; case WS_OPCODE_TEXT_FRAME : if ( - 1 == ( flength = b64_pton ( payload , ( unsigned char * ) wsctx -> codeBufDecode , sizeof ( wsctx -> codeBufDecode ) ) ) ) { rfbErr ( ""%s:<S2SV_blank>Base64<S2SV_blank>decode<S2SV_blank>error;<S2SV_blank>%m\\n"" , __func__ ) ; break ; } payload = wsctx -> codeBufDecode ; case WS_OPCODE_BINARY_FRAME : if ( flength > len ) { memcpy ( wsctx -> readbuf , payload + len , flength - len ) ; wsctx -> readbufstart = 0 ; wsctx -> readbuflen = flength - len ; flength = len ; } memcpy ( dst , payload , flength ) ; result = flength ; break ; default : rfbErr ( ""%s:<S2SV_blank>unhandled<S2SV_blank>opcode<S2SV_blank>%d,<S2SV_blank>b0:<S2SV_blank>%02x,<S2SV_blank>b1:<S2SV_blank>%02x\\n"" , __func__ , ( int ) opcode , header -> b0 , header -> b1 ) ; } spor : return result ; }
","<S2SV_ModStart> len ) { int result <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; rfbLog ( ""%s_enter:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writeTo=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""<S2SV_blank>nReadRaw=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf ) ; switch ( wsctx -> hybiDecodeState ) { case WS_HYBI_STATE_HEADER_PENDING : wsctx -> hybiDecodeState = hybiReadHeader ( cl , & result ) ; if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { goto spor ; } if ( wsctx -> hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING ) { wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; } break ; case WS_HYBI_STATE_DATA_AVAILABLE : wsctx -> hybiDecodeState = hybiReturnData ( dst , len , wsctx , & result ) ; break ; case WS_HYBI_STATE_DATA_NEEDED : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; case WS_HYBI_STATE_CLOSE_REASON_PENDING : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; default : rfbErr ( ""%s:<S2SV_blank>called<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>%d\\n"" , wsctx -> hybiDecodeState ) ; <S2SV_ModEnd> result = - <S2SV_ModStart> - 1 ; errno = EIO ; wsctx -> hybiDecodeState = WS_HYBI_STATE_ERR ; } spor : if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE ) { rfbLog ( ""frame<S2SV_blank>received<S2SV_blank>successfully,<S2SV_blank>cleaning<S2SV_blank>up:<S2SV_blank>read=%d<S2SV_blank>hlen=%d<S2SV_blank>plen=%d\\n"" , wsctx -> header . nRead , wsctx -> header . headerLen , wsctx -> header . payloadLen ) ; hybiDecodeCleanup ( wsctx ) <S2SV_ModEnd> ; } else <S2SV_ModStart> else if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { hybiDecodeCleanup ( wsctx ) ; } rfbLog ( ""%s_exit:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writePos=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""nRead=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p<S2SV_blank>"" ""result=%d\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf , result ) ; return <S2SV_ModEnd> result ; }
",LibVNC@libvncserver/aac95a9dcf4bbba87b76c72706c3221a842ca433,CVE-2017-18922,https://github.com/LibVNC/libvncserver/commit/aac95a9dcf4bbba87b76c72706c3221a842ca433,2020-06-30T11:15Z,"<S2SV_StartBug> char * buf , * payload ; <S2SV_EndBug> <S2SV_StartBug> int ret = - 1 , result = - 1 ; <S2SV_EndBug> <S2SV_StartBug> int total = 0 ; <S2SV_EndBug> <S2SV_StartBug> } else if ( 0 == ret ) { <S2SV_EndBug>"
929,CWE-119,"timestamp PGTYPEStimestamp_from_asc ( char * str , char * * endptr ) { timestamp result ; # ifdef HAVE_INT64_TIMESTAMP int64 noresult = 0 ; # else double noresult = 0.0 ; # endif fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; <S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } <S2SV_StartBug> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || <S2SV_EndBug> DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } break ; case DTK_EPOCH : result = SetEpochTimestamp ( ) ; break ; case DTK_LATE : TIMESTAMP_NOEND ( result ) ; break ; case DTK_EARLY : TIMESTAMP_NOBEGIN ( result ) ; break ; case DTK_INVALID : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; default : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } errno = 0 ; return result ; }
","<S2SV_ModStart> ( str ) > MAXDATELEN ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ) != 0 <S2SV_ModEnd> ) { errno
",postgres@postgres/4318daecc959886d001a6e79c6ea853e8b1dfb4b,CVE-2014-0063,https://github.com/postgres/postgres/commit/4318daecc959886d001a6e79c6ea853e8b1dfb4b,2014-03-31T14:58Z,"<S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || <S2SV_EndBug>"
5124,CWE-119,"static BOOL rdp_read_font_capability_set ( wStream * s , UINT16 length , rdpSettings * settings ) { WINPR_UNUSED ( settings ) ; <S2SV_StartBug> if ( length > 4 ) <S2SV_EndBug> Stream_Seek_UINT16 ( s ) ; <S2SV_StartBug> if ( length > 6 ) <S2SV_EndBug> Stream_Seek_UINT16 ( s ) ; return TRUE ; }
","<S2SV_ModStart> ( length > 5 <S2SV_ModEnd> ) Stream_Seek_UINT16 ( <S2SV_ModStart> ( length > 7 <S2SV_ModEnd> ) Stream_Seek_UINT16 (
",FreeRDP@FreeRDP/3627aaf7d289315b614a584afb388f04abfb5bbf,CVE-2020-11058,https://github.com/FreeRDP/FreeRDP/commit/3627aaf7d289315b614a584afb388f04abfb5bbf,2020-05-12T21:15Z,<S2SV_StartBug> if ( length > 4 ) <S2SV_EndBug> <S2SV_StartBug> if ( length > 6 ) <S2SV_EndBug>
1187,CWE-415,"static Image * ReadTGAImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; PixelInfo pixel ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t base , flag , offset , real , skip ; ssize_t count , y ; TGAInfo tga_info ; unsigned char j , k , pixels [ 4 ] , runlength ; unsigned int alpha_bits ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & tga_info . id_length ) ; tga_info . colormap_type = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . image_type = ( TGAImageType ) ReadBlobByte ( image ) ; if ( ( count != 1 ) || ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARGB ) && ( tga_info . image_type != TGAMonochrome ) && ( tga_info . image_type != TGARLEColormap ) && ( tga_info . image_type != TGARLERGB ) && ( tga_info . image_type != TGARLEMonochrome ) ) || ( ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGARLEColormap ) ) && ( tga_info . colormap_type == 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; tga_info . colormap_index = ReadBlobLSBShort ( image ) ; tga_info . colormap_length = ReadBlobLSBShort ( image ) ; tga_info . colormap_size = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . x_origin = ReadBlobLSBShort ( image ) ; tga_info . y_origin = ReadBlobLSBShort ( image ) ; tga_info . width = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . height = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . attributes = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( ( ( ( tga_info . bits_per_pixel <= 1 ) || ( tga_info . bits_per_pixel >= 17 ) ) && ( tga_info . bits_per_pixel != 24 ) && ( tga_info . bits_per_pixel != 32 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = tga_info . width ; image -> rows = tga_info . height ; alpha_bits = ( tga_info . attributes & 0x0FU ) ; image -> alpha_trait = ( alpha_bits > 0 ) || ( tga_info . bits_per_pixel == 32 ) || ( tga_info . colormap_size == 32 ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARLEColormap ) ) image -> depth = ( size_t ) ( ( tga_info . bits_per_pixel <= 8 ) ? 8 : ( tga_info . bits_per_pixel <= 16 ) ? 5 : ( tga_info . bits_per_pixel == 24 ) ? 8 : ( tga_info . bits_per_pixel == 32 ) ? 8 : 8 ) ; else image -> depth = ( size_t ) ( ( tga_info . colormap_size <= 8 ) ? 8 : ( tga_info . colormap_size <= 16 ) ? 5 : ( tga_info . colormap_size == 24 ) ? 8 : ( tga_info . colormap_size == 32 ) ? 8 : 8 ) ; if ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGAMonochrome ) || ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) ) image -> storage_class = PseudoClass ; image -> compression = NoCompression ; if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) || ( tga_info . image_type == TGARLERGB ) ) image -> compression = RLECompression ; if ( image -> storage_class == PseudoClass ) { if ( tga_info . colormap_type != 0 ) image -> colors = tga_info . colormap_index + tga_info . colormap_length ; else { size_t one ; one = 1 ; image -> colors = one << tga_info . bits_per_pixel ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } } if ( tga_info . id_length != 0 ) { char * comment ; size_t length ; length = ( size_t ) tga_info . id_length ; comment = ( char * ) NULL ; if ( ~ length >= ( MagickPathExtent - 1 ) ) comment = ( char * ) AcquireQuantumMemory ( length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , tga_info . id_length , ( unsigned char * ) comment ) ; comment [ tga_info . id_length ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; pixel . alpha = ( MagickRealType ) OpaqueAlpha ; if ( tga_info . colormap_type != 0 ) <S2SV_StartBug> { <S2SV_EndBug> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) tga_info . colormap_index ; i ++ ) image -> colormap [ i ] = pixel ; for ( ; i < ( ssize_t ) image -> colors ; i ++ ) { switch ( tga_info . colormap_size ) { case 8 : default : { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = pixel . red ; pixel . blue = pixel . red ; break ; } case 15 : case 16 : { QuantumAny range ; j = ( unsigned char ) ReadBlobByte ( image ) ; k = ( unsigned char ) ReadBlobByte ( image ) ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; break ; } case 24 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } case 32 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } } image -> colormap [ i ] = pixel ; } } base = 0 ; flag = 0 ; skip = MagickFalse ; real = 0 ; index = 0 ; runlength = 0 ; offset = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { real = offset ; if ( ( ( unsigned char ) ( tga_info . attributes & 0x20 ) >> 5 ) == 0 ) real = image -> rows - real - 1 ; q = QueueAuthenticPixels ( image , 0 , ( ssize_t ) real , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLERGB ) || ( tga_info . image_type == TGARLEMonochrome ) ) { if ( runlength != 0 ) { runlength -- ; skip = flag != 0 ; } else { count = ReadBlob ( image , 1 , & runlength ) ; if ( count != 1 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; flag = runlength & 0x80 ; if ( flag != 0 ) runlength -= 128 ; skip = MagickFalse ; } } if ( skip == MagickFalse ) switch ( tga_info . bits_per_pixel ) { case 8 : default : { index = ( Quantum ) ReadBlobByte ( image ) ; if ( tga_info . colormap_type != 0 ) pixel = image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , ( ssize_t ) index , exception ) ] ; else { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; } break ; } case 15 : case 16 : { QuantumAny range ; if ( ReadBlob ( image , 2 , pixels ) != 2 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; j = pixels [ 0 ] ; k = pixels [ 1 ] ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) pixel . alpha = ( MagickRealType ) ( ( k & 0x80 ) == 0 ? ( Quantum ) TransparentAlpha : ( Quantum ) OpaqueAlpha ) ; if ( image -> storage_class == PseudoClass ) index = ( Quantum ) ConstrainColormapIndex ( image , ( ( ssize_t ) ( k << 8 ) ) + j , exception ) ; break ; } case 24 : { if ( ReadBlob ( image , 3 , pixels ) != 3 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; break ; } case 32 : { if ( ReadBlob ( image , 4 , pixels ) != 4 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 3 ] ) ; break ; } } if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , index , q ) ; SetPixelRed ( image , ClampToQuantum ( pixel . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( pixel . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( pixel . blue ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ClampToQuantum ( pixel . alpha ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ( ( unsigned char ) ( tga_info . attributes & 0xc0 ) >> 6 ) == 2 ) offset += 2 ; else offset ++ ; if ( offset >= image -> rows ) { base ++ ; offset = base ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> 0 ) { if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;
",ImageMagick@ImageMagick/4f68e9661518463fca523c9726bb5d940a2aa6d8,CVE-2015-8894,https://github.com/ImageMagick/ImageMagick/commit/4f68e9661518463fca523c9726bb5d940a2aa6d8,2017-03-15T19:59Z,<S2SV_StartBug> { <S2SV_EndBug>
4023,CWE-119,"int X509_cmp_time ( const ASN1_TIME * ctm , time_t * cmp_time ) { char * str ; ASN1_TIME atm ; long offset ; char buff1 [ 24 ] , buff2 [ 24 ] , * p ; <S2SV_StartBug> int i , j ; <S2SV_EndBug> p = buff1 ; <S2SV_StartBug> i = ctm -> length ; <S2SV_EndBug> str = ( char * ) ctm -> data ; if ( ctm -> type == V_ASN1_UTCTIME ) { <S2SV_StartBug> if ( ( i < 11 ) || ( i > 17 ) ) <S2SV_EndBug> return 0 ; memcpy ( p , str , 10 ) ; p += 10 ; str += 10 ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( i < 13 ) <S2SV_EndBug> return 0 ; memcpy ( p , str , 12 ) ; p += 12 ; str += 12 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ( * str == 'Z' ) || ( * str == '-' ) || ( * str == '+' ) ) { * ( p ++ ) = '0' ; * ( p ++ ) = '0' ; } else { <S2SV_StartBug> * ( p ++ ) = * ( str ++ ) ; <S2SV_EndBug> * ( p ++ ) = * ( str ++ ) ; if ( * str == '.' ) { str ++ ; <S2SV_StartBug> while ( ( * str >= '0' ) && ( * str <= '9' ) ) <S2SV_EndBug> str ++ ; } } * ( p ++ ) = 'Z' ; * ( p ++ ) = '\\0' ; <S2SV_StartBug> if ( * str == 'Z' ) <S2SV_EndBug> offset = 0 ; <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> if ( ( * str != '+' ) && ( * str != '-' ) ) <S2SV_EndBug> return 0 ; offset = ( ( str [ 1 ] - '0' ) * 10 + ( str [ 2 ] - '0' ) ) * 60 ; offset += ( str [ 3 ] - '0' ) * 10 + ( str [ 4 ] - '0' ) ; if ( * str == '-' ) offset = - offset ; } atm . type = ctm -> type ; atm . flags = 0 ; atm . length = sizeof ( buff2 ) ; atm . data = ( unsigned char * ) buff2 ; if ( X509_time_adj ( & atm , offset * 60 , cmp_time ) == NULL ) return 0 ; if ( ctm -> type == V_ASN1_UTCTIME ) { i = ( buff1 [ 0 ] - '0' ) * 10 + ( buff1 [ 1 ] - '0' ) ; if ( i < 50 ) i += 100 ; j = ( buff2 [ 0 ] - '0' ) * 10 + ( buff2 [ 1 ] - '0' ) ; if ( j < 50 ) j += 100 ; if ( i < j ) return - 1 ; if ( i > j ) return 1 ; } i = strcmp ( buff1 , buff2 ) ; if ( i == 0 ) return - 1 ; else return i ; }
","<S2SV_ModStart> i , j , remaining <S2SV_ModStart> = buff1 ; remaining <S2SV_ModEnd> = ctm -> <S2SV_ModStart> V_ASN1_UTCTIME ) { int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 10 ; remaining -= 10 ; <S2SV_ModStart> } else { int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 12 ; remaining -= 12 ; <S2SV_ModStart> } else { if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> * str == <S2SV_ModStart> str ++ ; remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> } } * <S2SV_ModStart> ; if ( ! remaining ) return 0 ; if ( <S2SV_ModStart> == 'Z' ) { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> = 0 ; } <S2SV_ModStart> != '-' ) ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9'
",openssl@openssl/f48b83b4fb7d6689584cf25f61ca63a4891f5b11,CVE-2015-1789,https://github.com/openssl/openssl/commit/f48b83b4fb7d6689584cf25f61ca63a4891f5b11,2015-06-12T19:59Z,"<S2SV_StartBug> int i , j ; <S2SV_EndBug> <S2SV_StartBug> i = ctm -> length ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i < 11 ) || ( i > 17 ) ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( i < 13 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> * ( p ++ ) = * ( str ++ ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( * str >= '0' ) && ( * str <= '9' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * str == 'Z' ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> if ( ( * str != '+' ) && ( * str != '-' ) ) <S2SV_EndBug>"
3996,CWE-20,"static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - EOPNOTSUPP ; if ( m -> msg_flags & MSG_OOB ) <S2SV_StartBug> goto read_error ; <S2SV_EndBug> m -> msg_namelen = 0 ; skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= MSG_TRUNC ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }
","<S2SV_ModStart> ) goto read_error <S2SV_ModEnd> ; skb =
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> goto read_error ; <S2SV_EndBug>
797,CWE-416,"static ssize_t userfaultfd_ctx_read ( struct userfaultfd_ctx * ctx , int no_wait , struct uffd_msg * msg ) { ssize_t ret ; DECLARE_WAITQUEUE ( wait , current ) ; struct userfaultfd_wait_queue * uwq ; LIST_HEAD ( fork_event ) ; struct userfaultfd_ctx * fork_nctx = NULL ; spin_lock ( & ctx -> fd_wqh . lock ) ; __add_wait_queue ( & ctx -> fd_wqh , & wait ) ; for ( ; ; ) { set_current_state ( TASK_INTERRUPTIBLE ) ; spin_lock ( & ctx -> fault_pending_wqh . lock ) ; uwq = find_userfault ( ctx ) ; if ( uwq ) { write_seqcount_begin ( & ctx -> refile_seq ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> fault_wqh , & uwq -> wq ) ; write_seqcount_end ( & ctx -> refile_seq ) ; * msg = uwq -> msg ; spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; spin_lock ( & ctx -> event_wqh . lock ) ; uwq = find_userfault_evt ( ctx ) ; if ( uwq ) { * msg = uwq -> msg ; if ( uwq -> msg . event == UFFD_EVENT_FORK ) { fork_nctx = ( struct userfaultfd_ctx * ) ( unsigned long ) uwq -> msg . arg . reserved . reserved1 ; list_move ( & uwq -> wq . entry , & fork_event ) ; <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> ret = 0 ; break ; } userfaultfd_event_complete ( ctx , uwq ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; if ( signal_pending ( current ) ) { ret = - ERESTARTSYS ; break ; } if ( no_wait ) { ret = - EAGAIN ; break ; } spin_unlock ( & ctx -> fd_wqh . lock ) ; schedule ( ) ; spin_lock ( & ctx -> fd_wqh . lock ) ; } __remove_wait_queue ( & ctx -> fd_wqh , & wait ) ; __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> fd_wqh . lock ) ; if ( ! ret && msg -> event == UFFD_EVENT_FORK ) { ret = resolve_userfault_fork ( ctx , fork_nctx , msg ) ; <S2SV_StartBug> if ( ! ret ) { <S2SV_EndBug> spin_lock ( & ctx -> event_wqh . lock ) ; if ( ! list_empty ( & fork_event ) ) { <S2SV_StartBug> uwq = list_first_entry ( & fork_event , <S2SV_EndBug> typeof ( * uwq ) , wq . entry ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> event_wqh , & uwq -> wq ) ; <S2SV_StartBug> userfaultfd_event_complete ( ctx , uwq ) ; <S2SV_EndBug> } <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> } } return ret ; }
","<S2SV_ModStart> fork_event ) ; userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart> msg ) ; <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ) { userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> wq ) ; if ( likely ( ! ret ) ) <S2SV_ModStart> ) ; } else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> } return ret
",torvalds@linux/384632e67e0829deb8015ee6ad916b180049d252,CVE-2017-15126,https://github.com/torvalds/linux/commit/384632e67e0829deb8015ee6ad916b180049d252,2018-01-14T06:29Z,"<S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ret ) { <S2SV_EndBug> <S2SV_StartBug> uwq = list_first_entry ( & fork_event , <S2SV_EndBug> <S2SV_StartBug> userfaultfd_event_complete ( ctx , uwq ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug>"
337,CWE-264,"int fscrypt_process_policy ( struct inode * inode , const struct fscrypt_policy * policy ) <S2SV_StartBug> { <S2SV_EndBug> if ( policy -> version != 0 ) return - EINVAL ; if ( ! inode_has_encryption_context ( inode ) ) { if ( ! inode -> i_sb -> s_cop -> empty_dir ) return - EOPNOTSUPP ; if ( ! inode -> i_sb -> s_cop -> empty_dir ( inode ) ) return - ENOTEMPTY ; return create_encryption_context_from_policy ( inode , policy ) ; } if ( is_encryption_context_consistent_with_policy ( inode , policy ) ) return 0 ; printk ( KERN_WARNING ""%s:<S2SV_blank>Policy<S2SV_blank>inconsistent<S2SV_blank>with<S2SV_blank>encryption<S2SV_blank>context\\n"" , __func__ ) ; return - EINVAL ; }
","<S2SV_ModStart> policy ) { if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ;
",torvalds@linux/163ae1c6ad6299b19e22b4a35d5ab24a89791a98,CVE-2016-10318,https://github.com/torvalds/linux/commit/163ae1c6ad6299b19e22b4a35d5ab24a89791a98,2017-04-04T16:59Z,<S2SV_StartBug> { <S2SV_EndBug>
2684,CWE-119,"static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ; ncomponents = bytestream2_get_be16u ( & s -> g ) ; if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n"" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components"" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n"" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; <S2SV_StartBug> if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) { <S2SV_EndBug> av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>seperation\\n"" ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>"" ""components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>"" ""cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n"" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } return 0 ; }
","<S2SV_ModStart> i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || <S2SV_ModStart> [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4
",FFmpeg@FFmpeg/8bb11c3ca77b52e05a9ed1496a65f8a76e6e2d8f,CVE-2013-7016,https://github.com/FFmpeg/FFmpeg/commit/8bb11c3ca77b52e05a9ed1496a65f8a76e6e2d8f,2013-12-09T16:36Z,<S2SV_StartBug> if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) { <S2SV_EndBug>
6045,CWE-125,"static int update_write_order_info ( rdpContext * context , wStream * s , ORDER_INFO * orderInfo , size_t offset ) { size_t position ; WINPR_UNUSED ( context ) ; position = Stream_GetPosition ( s ) ; Stream_SetPosition ( s , offset ) ; Stream_Write_UINT8 ( s , orderInfo -> controlFlags ) ; if ( orderInfo -> controlFlags & ORDER_TYPE_CHANGE ) Stream_Write_UINT8 ( s , orderInfo -> orderType ) ; update_write_field_flags ( s , orderInfo -> fieldFlags , orderInfo -> controlFlags , <S2SV_StartBug> PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ) ; <S2SV_EndBug> update_write_bounds ( s , orderInfo ) ; Stream_SetPosition ( s , position ) ; return 0 ; }
","<S2SV_ModStart> -> controlFlags , get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> orderInfo -> orderType <S2SV_ModStart> orderInfo -> orderType , NULL ) <S2SV_ModEnd> ) ; update_write_bounds
",FreeRDP@FreeRDP/733ee3208306b1ea32697b356c0215180fc3f049,CVE-2020-11095,https://github.com/FreeRDP/FreeRDP/commit/733ee3208306b1ea32697b356c0215180fc3f049,2020-06-22T22:15Z,<S2SV_StartBug> PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ) ; <S2SV_EndBug>
4440,CWE-401,"struct resource_pool * dce100_create_resource_pool ( uint8_t num_virtual_links , struct dc * dc ) { struct dce110_resource_pool * pool = kzalloc ( sizeof ( struct dce110_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( num_virtual_links , dc , pool ) ) return & pool -> base ; <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> -> base ; kfree ( pool ) ;
",torvalds@linux/104c307147ad379617472dd91a5bcb368d72bd6d,CVE-2019-19082,https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d,2019-11-18T06:15Z,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug>
2804,CWE-416,"void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> if ( ! valid_handle ) { WARN ( 1 , ""%s:<S2SV_blank>invalid<S2SV_blank>handle<S2SV_blank>passed<S2SV_blank>to<S2SV_blank>free.\\n"" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }
","<S2SV_ModStart> handle ) { <S2SV_ModEnd> BUG_ON ( client <S2SV_ModStart> lock ) ; ion_free_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> client , handle <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,CVE-2016-9120,https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,2016-12-08T21:59Z,"<S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug>"
8301,CWE-120,"void choose_windows ( s ) const char * s ; { <S2SV_StartBug> register int i ; <S2SV_EndBug> for ( i = 0 ; winchoices [ i ] . procs ; i ++ ) { if ( '+' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; if ( '-' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; if ( ! strcmpi ( s , winchoices [ i ] . procs -> name ) ) { windowprocs = * winchoices [ i ] . procs ; if ( last_winchoice && last_winchoice -> ini_routine ) ( * last_winchoice -> ini_routine ) ( WININIT_UNDO ) ; if ( winchoices [ i ] . ini_routine ) ( * winchoices [ i ] . ini_routine ) ( WININIT ) ; last_winchoice = & winchoices [ i ] ; return ; } } if ( ! windowprocs . win_raw_print ) windowprocs . win_raw_print = def_raw_print ; if ( ! windowprocs . win_wait_synch ) windowprocs . win_wait_synch = def_wait_synch ; if ( ! winchoices [ 0 ] . procs ) { <S2SV_StartBug> raw_printf ( ""No<S2SV_blank>window<S2SV_blank>types?"" ) ; <S2SV_EndBug> nh_terminate ( EXIT_FAILURE ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! winchoices [ 1 ] . procs ) { config_error_add ( ""Window<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>recognized.<S2SV_blank><S2SV_blank>The<S2SV_blank>only<S2SV_blank>choice<S2SV_blank>is:<S2SV_blank>%s"" , s , winchoices [ 0 ] . procs -> name ) ; } else { char buf [ BUFSZ ] ; boolean first = TRUE ; buf [ 0 ] = '\\0' ; for ( i = 0 ; winchoices [ i ] . procs ; i ++ ) { if ( '+' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; if ( '-' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; Sprintf ( eos ( buf ) , ""%s%s"" , first ? """" : "",<S2SV_blank>"" , winchoices [ i ] . procs -> name ) ; first = FALSE ; } config_error_add ( ""Window<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>recognized.<S2SV_blank><S2SV_blank>Choices<S2SV_blank>are:<S2SV_blank><S2SV_blank>%s"" , s , buf ) ; } <S2SV_StartBug> if ( windowprocs . win_raw_print == def_raw_print <S2SV_EndBug> || WINDOWPORT ( ""safe-startup"" ) ) nh_terminate ( EXIT_SUCCESS ) ; }
","<S2SV_ModStart> s ; { int i ; char * tmps = 0 <S2SV_ModEnd> ; for ( <S2SV_ModStart> { raw_printf ( ""No<S2SV_blank>window<S2SV_blank>types<S2SV_blank>supported?"" <S2SV_ModEnd> ) ; nh_terminate <S2SV_ModStart> ) ; } # define WINDOW_TYPE_MAXLEN 50 if ( strlen ( s ) >= WINDOW_TYPE_MAXLEN ) { tmps = ( char * ) alloc ( WINDOW_TYPE_MAXLEN ) ; ( void ) strncpy ( tmps , s , WINDOW_TYPE_MAXLEN - 1 ) ; tmps [ WINDOW_TYPE_MAXLEN - 1 ] = '\\0' ; s = tmps ; } # undef WINDOW_TYPE_MAXLEN <S2SV_ModStart> } if ( tmps ) free ( ( genericptr_t ) tmps ) ; if (
",NetHack@NetHack/f3def5c0b999478da2d0a8f0b6a7c370a2065f77,CVE-2020-5210,https://github.com/NetHack/NetHack/commit/f3def5c0b999478da2d0a8f0b6a7c370a2065f77,2020-01-28T18:15Z,"<S2SV_StartBug> register int i ; <S2SV_EndBug> <S2SV_StartBug> raw_printf ( ""No<S2SV_blank>window<S2SV_blank>types?"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( windowprocs . win_raw_print == def_raw_print <S2SV_EndBug>"
4564,CWE-125,"static expr_ty ast_for_decorator ( struct compiling * c , const node * n ) { expr_ty d = NULL ; expr_ty name_expr ; REQ ( n , decorator ) ; REQ ( CHILD ( n , 0 ) , AT ) ; REQ ( RCHILD ( n , - 1 ) , NEWLINE ) ; name_expr = ast_for_dotted_name ( c , CHILD ( n , 1 ) ) ; if ( ! name_expr ) return NULL ; if ( NCH ( n ) == 3 ) { d = name_expr ; name_expr = NULL ; } else if ( NCH ( n ) == 5 ) { d = Call ( name_expr , NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( ! d ) return NULL ; name_expr = NULL ; } else { <S2SV_StartBug> d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ; <S2SV_EndBug> if ( ! d ) return NULL ; name_expr = NULL ; } return d ; }
","<S2SV_ModStart> ) , name_expr , true
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ; <S2SV_EndBug>"
2015,CWE-119,"<S2SV_StartBug> void generate_filename ( const char * pattern , char * out , size_t q_len , <S2SV_EndBug> unsigned int d_w , unsigned int d_h , unsigned int frame_in ) { const char * p = pattern ; char * q = out ; do { char * next_pat = strchr ( p , '%' ) ; if ( p == next_pat ) { size_t pat_len ; q [ q_len - 1 ] = '\\0' ; switch ( p [ 1 ] ) { case 'w' : snprintf ( q , q_len - 1 , ""%d"" , d_w ) ; break ; case 'h' : snprintf ( q , q_len - 1 , ""%d"" , d_h ) ; break ; case '1' : snprintf ( q , q_len - 1 , ""%d"" , frame_in ) ; break ; case '2' : snprintf ( q , q_len - 1 , ""%02d"" , frame_in ) ; break ; case '3' : snprintf ( q , q_len - 1 , ""%03d"" , frame_in ) ; break ; case '4' : snprintf ( q , q_len - 1 , ""%04d"" , frame_in ) ; break ; case '5' : snprintf ( q , q_len - 1 , ""%05d"" , frame_in ) ; break ; case '6' : snprintf ( q , q_len - 1 , ""%06d"" , frame_in ) ; break ; case '7' : snprintf ( q , q_len - 1 , ""%07d"" , frame_in ) ; break ; case '8' : snprintf ( q , q_len - 1 , ""%08d"" , frame_in ) ; break ; case '9' : snprintf ( q , q_len - 1 , ""%09d"" , frame_in ) ; break ; default : die ( ""Unrecognized<S2SV_blank>pattern<S2SV_blank>%%%c\\n"" , p [ 1 ] ) ; <S2SV_StartBug> } <S2SV_EndBug> pat_len = strlen ( q ) ; if ( pat_len >= q_len - 1 ) die ( ""Output<S2SV_blank>filename<S2SV_blank>too<S2SV_blank>long.\\n"" ) ; q += pat_len ; p += 2 ; q_len -= pat_len ; } else { size_t copy_len ; if ( ! next_pat ) copy_len = strlen ( p ) ; else copy_len = next_pat - p ; if ( copy_len >= q_len - 1 ) die ( ""Output<S2SV_blank>filename<S2SV_blank>too<S2SV_blank>long.\\n"" ) ; memcpy ( q , p , copy_len ) ; q [ copy_len ] = '\\0' ; q += copy_len ; p += copy_len ; q_len -= copy_len ; } } while ( * p ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ] ) ; break ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> void generate_filename ( const char * pattern , char * out , size_t q_len , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
659,CWE-125,"<S2SV_StartBug> int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> { if ( Stream_GetRemainingLength ( s ) < 12 ) return - 1 ; Stream_Read ( s , header -> Signature , 8 ) ; Stream_Read_UINT32 ( s , header -> MessageType ) ; if ( strncmp ( ( char * ) header -> Signature , NTLM_SIGNATURE , 8 ) != 0 ) return - 1 ; return 1 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z,"<S2SV_StartBug> int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug>"
3369,CWE-362,"fm_mgr_config_errno_t fm_mgr_config_mgr_connect ( fm_config_conx_hdl * hdl , fm_mgr_type_t mgr ) { char s_path [ 256 ] ; char c_path [ 256 ] ; char * mgr_prefix ; p_hsm_com_client_hdl_t * mgr_hdl ; <S2SV_StartBug> pid_t pid ; <S2SV_EndBug> memset ( s_path , 0 , sizeof ( s_path ) ) ; <S2SV_StartBug> memset ( c_path , 0 , sizeof ( c_path ) ) ; <S2SV_EndBug> pid = getpid ( ) ; switch ( mgr ) { case FM_MGR_SM : mgr_prefix = HSM_FM_SCK_SM ; mgr_hdl = & hdl -> sm_hdl ; break ; case FM_MGR_PM : mgr_prefix = HSM_FM_SCK_PM ; mgr_hdl = & hdl -> pm_hdl ; break ; case FM_MGR_FE : mgr_prefix = HSM_FM_SCK_FE ; mgr_hdl = & hdl -> fe_hdl ; break ; default : return FM_CONF_INIT_ERR ; } sprintf ( s_path , ""%s%s%d"" , HSM_FM_SCK_PREFIX , mgr_prefix , hdl -> instance ) ; <S2SV_StartBug> sprintf ( c_path , ""%s%s%d_C_%lu"" , HSM_FM_SCK_PREFIX , mgr_prefix , <S2SV_EndBug> <S2SV_StartBug> hdl -> instance , ( long unsigned ) pid ) ; <S2SV_EndBug> if ( * mgr_hdl == NULL ) { if ( hcom_client_init ( mgr_hdl , s_path , c_path , 32768 ) != HSM_COM_OK ) { return FM_CONF_INIT_ERR ; } } if ( hcom_client_connect ( * mgr_hdl ) == HSM_COM_OK ) { hdl -> conx_mask |= mgr ; return FM_CONF_OK ; } return FM_CONF_CONX_ERR ; }
","<S2SV_ModStart> * mgr_hdl ; <S2SV_ModEnd> memset ( s_path <S2SV_ModStart> ( c_path ) <S2SV_ModEnd> ) ; switch <S2SV_ModStart> ( c_path , ""%s%s%d_C_XXXXXX"" <S2SV_ModEnd> , HSM_FM_SCK_PREFIX , <S2SV_ModStart> hdl -> instance <S2SV_ModEnd> ) ; if
",01org@opa-fm/c5759e7b76f5bf844be6c6641cc1b356bbc83869,CVE-2015-5232,https://github.com/01org/opa-fm/commit/c5759e7b76f5bf844be6c6641cc1b356bbc83869,2017-06-07T20:29Z,"<S2SV_StartBug> pid_t pid ; <S2SV_EndBug> <S2SV_StartBug> memset ( c_path , 0 , sizeof ( c_path ) ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( c_path , ""%s%s%d_C_%lu"" , HSM_FM_SCK_PREFIX , mgr_prefix , <S2SV_EndBug> <S2SV_StartBug> hdl -> instance , ( long unsigned ) pid ) ; <S2SV_EndBug>"
8354,CWE-362,"int cipso_v4_req_setattr ( struct request_sock * req , const struct cipso_v4_doi * doi_def , const struct netlbl_lsm_secattr * secattr ) { int ret_val = - EPERM ; unsigned char * buf = NULL ; u32 buf_len ; u32 opt_len ; <S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> struct inet_request_sock * req_inet ; buf_len = CIPSO_V4_OPT_LEN_MAX ; buf = kmalloc ( buf_len , GFP_ATOMIC ) ; if ( buf == NULL ) { ret_val = - ENOMEM ; goto req_setattr_failure ; } ret_val = cipso_v4_genopt ( buf , buf_len , doi_def , secattr ) ; if ( ret_val < 0 ) goto req_setattr_failure ; buf_len = ret_val ; opt_len = ( buf_len + 3 ) & ~ 3 ; opt = kzalloc ( sizeof ( * opt ) + opt_len , GFP_ATOMIC ) ; if ( opt == NULL ) { ret_val = - ENOMEM ; goto req_setattr_failure ; } <S2SV_StartBug> memcpy ( opt -> __data , buf , buf_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = opt_len ; <S2SV_EndBug> <S2SV_StartBug> opt -> cipso = sizeof ( struct iphdr ) ; <S2SV_EndBug> kfree ( buf ) ; buf = NULL ; req_inet = inet_rsk ( req ) ; opt = xchg ( & req_inet -> opt , opt ) ; <S2SV_StartBug> kfree ( opt ) ; <S2SV_EndBug> return 0 ; req_setattr_failure : kfree ( buf ) ; kfree ( opt ) ; return ret_val ; }
","<S2SV_ModStart> opt_len ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> opt ) ; if ( opt ) call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; return
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,"<S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( opt -> __data , buf , buf_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = opt_len ; <S2SV_EndBug> <S2SV_StartBug> opt -> cipso = sizeof ( struct iphdr ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( opt ) ; <S2SV_EndBug>"
2219,CWE-310,"int X509_verify ( X509 * a , EVP_PKEY * r ) <S2SV_StartBug> { <S2SV_EndBug> return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ; }
","<S2SV_ModStart> r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;
",openssl@openssl/684400ce192dac51df3d3e92b61830a6ef90be3e,CVE-2014-8275,https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e,2015-01-09T02:59Z,<S2SV_StartBug> { <S2SV_EndBug>
1533,CWE-119,"<S2SV_StartBug> MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , <S2SV_EndBug> const MODE_INFO * left_mi , int b ) { if ( b == 0 || b == 2 ) { if ( ! left_mi || is_inter_block ( & left_mi -> mbmi ) ) return DC_PRED ; return get_y_mode ( left_mi , b + 1 ) ; } else { assert ( b == 1 || b == 3 ) ; return cur_mi -> bmi [ b - 1 ] . as_mode ; } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_left_block_mode ( const
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , <S2SV_EndBug>"
2756,CWE-000,"static void * bpf_any_get ( void * raw , enum bpf_type type ) { switch ( type ) { case BPF_TYPE_PROG : <S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> break ; case BPF_TYPE_MAP : <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug> break ; default : WARN_ON_ONCE ( 1 ) ; break ; } return raw ; }
","<S2SV_ModStart> case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BPF_TYPE_MAP : raw =
",torvalds@linux/92117d8443bc5afacc8d5ba82e541946310f106e,CVE-2016-4558,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,2016-05-23T10:59Z,"<S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug>"
4144,CWE-254,"IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data ( dec_state_t * ps_dec ) { stream_t * ps_stream ; UWORD32 u4_start_code ; IMPEG2D_ERROR_CODES_T e_error ; e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && <S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug> { if ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_dec_user_data ( ps_dec ) ; } else { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , EXT_ID_LEN ) ; switch ( u4_start_code ) { case QUANT_MATRIX_EXT_ID : impeg2d_dec_quant_matrix_ext ( ps_dec ) ; break ; case COPYRIGHT_EXT_ID : impeg2d_dec_copyright_ext ( ps_dec ) ; break ; case PIC_DISPLAY_EXT_ID : impeg2d_dec_pic_disp_ext ( ps_dec ) ; break ; case CAMERA_PARAM_EXT_ID : impeg2d_dec_cam_param_ext ( ps_dec ) ; break ; case ITU_T_EXT_ID : impeg2d_dec_itu_t_ext ( ps_dec ) ; break ; case PIC_SPATIAL_SCALABLE_EXT_ID : case PIC_TEMPORAL_SCALABLE_EXT_ID : e_error = IMPEG2D_SCALABLITY_NOT_SUP ; break ; default : impeg2d_bit_stream_flush ( ps_stream , EXT_ID_LEN ) ; impeg2d_next_start_code ( ps_dec ) ; break ; } } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } return e_error ; }
","<S2SV_ModStart> IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
",external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3,CVE-2016-0824,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,2016-03-12T21:59Z,<S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug>
1039,CWE-284,"void GKI_delay ( UINT32 timeout_ms ) { struct timespec delay ; delay . tv_sec = timeout_ms / 1000 ; delay . tv_nsec = 1000 * 1000 * ( timeout_ms % 1000 ) ; int err ; do { <S2SV_StartBug> err = nanosleep ( & delay , & delay ) ; <S2SV_EndBug> } while ( err == - 1 && errno == EINTR ) ; }
","<S2SV_ModStart> { err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & delay )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> err = nanosleep ( & delay , & delay ) ; <S2SV_EndBug>"
3841,CWE-200,"WORD32 ih264d_parse_sei_message ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD32 ui4_payload_type , ui4_payload_size ; UWORD32 u4_bits ; WORD32 i4_status = 0 ; do { ui4_payload_type = 0 ; u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> { u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; ui4_payload_type += 255 ; } ui4_payload_type += u4_bits ; ui4_payload_size = 0 ; u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> { u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; ui4_payload_size += 255 ; } ui4_payload_size += u4_bits ; i4_status = ih264d_parse_sei_payload ( ps_bitstrm , ui4_payload_type , ui4_payload_size , ps_dec ) ; if ( i4_status == - 1 ) { i4_status = 0 ; break ; } if ( i4_status != OK ) return i4_status ; if ( ih264d_check_byte_aligned ( ps_bitstrm ) == 0 ) { u4_bits = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( 0 == u4_bits ) { H264_DEC_DEBUG_PRINT ( ""\\nError<S2SV_blank>in<S2SV_blank>parsing<S2SV_blank>SEI<S2SV_blank>message"" ) ; } <S2SV_StartBug> while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) ) <S2SV_EndBug> { u4_bits = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( u4_bits ) { H264_DEC_DEBUG_PRINT ( ""\\nError<S2SV_blank>in<S2SV_blank>parsing<S2SV_blank>SEI<S2SV_blank>message"" ) ; } } } } while ( ps_bitstrm -> u4_ofst < ps_bitstrm -> u4_max_ofst ) ; return ( i4_status ) ; }
","<S2SV_ModStart> 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> 0 == ih264d_check_byte_aligned ( ps_bitstrm ) && ! EXCEED_OFFSET
",external@libavc/e86d3cfd2bc28dac421092106751e5638d54a848,CVE-2017-13203,https://android.googlesource.com/platform/external/libavc/+/e86d3cfd2bc28dac421092106751e5638d54a848,2018-01-12T23:29Z,<S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> <S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> <S2SV_StartBug> while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) ) <S2SV_EndBug>
2488,CWE-000,"static unsigned int unix_dgram_poll ( struct file * file , struct socket * sock , poll_table * wait ) { struct sock * sk = sock -> sk , * other ; unsigned int mask , writable ; sock_poll_wait ( file , sk_sleep ( sk ) , wait ) ; mask = 0 ; if ( sk -> sk_err || ! skb_queue_empty ( & sk -> sk_error_queue ) ) mask |= POLLERR | ( sock_flag ( sk , SOCK_SELECT_ERR_QUEUE ) ? POLLPRI : 0 ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) mask |= POLLRDHUP | POLLIN | POLLRDNORM ; if ( sk -> sk_shutdown == SHUTDOWN_MASK ) mask |= POLLHUP ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) mask |= POLLIN | POLLRDNORM ; if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( sk -> sk_state == TCP_CLOSE ) mask |= POLLHUP ; if ( sk -> sk_state == TCP_SYN_SENT ) return mask ; } if ( ! ( poll_requested_events ( wait ) & ( POLLWRBAND | POLLWRNORM | POLLOUT ) ) ) return mask ; writable = unix_writable ( sk ) ; <S2SV_StartBug> other = unix_peer_get ( sk ) ; <S2SV_EndBug> if ( other ) { <S2SV_StartBug> if ( unix_peer ( other ) != sk ) { <S2SV_EndBug> sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ; <S2SV_StartBug> if ( unix_recvq_full ( other ) ) <S2SV_EndBug> writable = 0 ; <S2SV_StartBug> } <S2SV_EndBug> sock_put ( other ) ; } if ( writable ) mask |= POLLOUT | POLLWRNORM | POLLWRBAND ; else set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; return mask ; }
","<S2SV_ModStart> sk ) ; if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <S2SV_ModEnd> other ) != <S2SV_ModStart> ) != sk && <S2SV_ModEnd> unix_recvq_full ( other <S2SV_ModStart> ( other ) && unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModStart> = 0 ; unix_state_unlock ( sk <S2SV_ModEnd> ) ; }
",torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c,CVE-2013-7446,https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c,2015-12-28T11:59Z,<S2SV_StartBug> other = unix_peer_get ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unix_peer ( other ) != sk ) { <S2SV_EndBug> <S2SV_StartBug> if ( unix_recvq_full ( other ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
8374,CWE-362,"struct sock * cookie_v4_check ( struct sock * sk , struct sk_buff * skb , struct ip_options * opt ) { struct tcp_options_received tcp_opt ; u8 * hash_location ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct rtable * rt ; __u8 rcv_wscale ; bool ecn_ok ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) || ( mss = cookie_check ( skb , cookie ) ) == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , & hash_location , 0 ) ; if ( ! cookie_check_timestamp ( & tcp_opt , & ecn_ok ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp_request_sock_ops ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; req -> mss = mss ; ireq -> loc_port = th -> dest ; ireq -> rmt_port = th -> source ; ireq -> loc_addr = ip_hdr ( skb ) -> daddr ; ireq -> rmt_addr = ip_hdr ( skb ) -> saddr ; ireq -> ecn_ok = ecn_ok ; ireq -> snd_wscale = tcp_opt . snd_wscale ; ireq -> sack_ok = tcp_opt . sack_ok ; ireq -> wscale_ok = tcp_opt . wscale_ok ; ireq -> tstamp_ok = tcp_opt . saw_tstamp ; req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; if ( opt && opt -> optlen ) { <S2SV_StartBug> int opt_size = sizeof ( struct ip_options ) + opt -> optlen ; <S2SV_EndBug> ireq -> opt = kmalloc ( opt_size , GFP_ATOMIC ) ; <S2SV_StartBug> if ( ireq -> opt != NULL && ip_options_echo ( ireq -> opt , skb ) ) { <S2SV_EndBug> kfree ( ireq -> opt ) ; ireq -> opt = NULL ; } } if ( security_inet_conn_request ( sk , skb , req ) ) { reqsk_free ( req ) ; goto out ; } req -> expires = 0UL ; req -> retrans = 0 ; { struct flowi4 fl4 ; flowi4_init_output ( & fl4 , 0 , sk -> sk_mark , RT_CONN_FLAGS ( sk ) , RT_SCOPE_UNIVERSE , IPPROTO_TCP , inet_sk_flowi_flags ( sk ) , ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , ireq -> loc_addr , th -> source , th -> dest ) ; security_req_classify_flow ( req , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_key ( sock_net ( sk ) , & fl4 ) ; if ( IS_ERR ( rt ) ) { reqsk_free ( req ) ; goto out ; } } req -> window_clamp = tp -> window_clamp ? : dst_metric ( & rt -> dst , RTAX_WINDOW ) ; tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , & req -> rcv_wnd , & req -> window_clamp , ireq -> wscale_ok , & rcv_wscale , dst_metric ( & rt -> dst , RTAX_INITRWND ) ) ; ireq -> rcv_wscale = rcv_wscale ; ret = get_cookie_sock ( sk , skb , req , & rt -> dst ) ; out : return ret ; }
","<S2SV_ModStart> sizeof ( struct ip_options_rcu <S2SV_ModEnd> ) + opt <S2SV_ModStart> && ip_options_echo ( & ireq -> opt <S2SV_ModEnd> -> opt ,
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,"<S2SV_StartBug> int opt_size = sizeof ( struct ip_options ) + opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> if ( ireq -> opt != NULL && ip_options_echo ( ireq -> opt , skb ) ) { <S2SV_EndBug>"
3220,CWE-190,"static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u8 opcode = BPF_OP ( insn -> code ) ; u32 dst = insn -> dst_reg ; dst_reg = & regs [ dst ] ; if ( WARN_ON_ONCE ( known && ( smin_val != smax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>sbounds\\n"" ) ; return - EINVAL ; } if ( WARN_ON_ONCE ( known && ( umin_val != umax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>ubounds\\n"" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_MAP_VALUE_OR_NULL ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_MAP_VALUE_OR_NULL<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == CONST_PTR_TO_MAP ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>CONST_PTR_TO_MAP<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_PACKET_END ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_PACKET_END<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } dst_reg -> type = ptr_reg -> type ; <S2SV_StartBug> dst_reg -> id = ptr_reg -> id ; <S2SV_EndBug> switch ( opcode ) { case BPF_ADD : if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> range = 0 ; } break ; case BPF_SUB : if ( dst_reg == off_reg ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> range = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; } <S2SV_StartBug> __update_reg_bounds ( dst_reg ) ; <S2SV_EndBug> __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
","<S2SV_ModStart> ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;
",torvalds@linux/bb7f0f989ca7de1153bd128a40a71709e339fa03,CVE-2017-17854,https://github.com/torvalds/linux/commit/bb7f0f989ca7de1153bd128a40a71709e339fa03,2017-12-27T17:08Z,<S2SV_StartBug> dst_reg -> id = ptr_reg -> id ; <S2SV_EndBug> <S2SV_StartBug> __update_reg_bounds ( dst_reg ) ; <S2SV_EndBug>
7863,CWE-20,"void enc28j60SelectBank ( NetInterface * interface , uint16_t address ) { uint16_t bank ; Enc28j60Context * context ; context = ( Enc28j60Context * ) interface -> nicContext ; bank = address & REG_BANK_MASK ; if ( bank != context -> currentBank ) { <S2SV_StartBug> switch ( bank ) <S2SV_EndBug> { case BANK_0 : <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug> break ; case BANK_1 : <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> break ; case BANK_2 : <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> break ; case BANK_3 : <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug> break ; default : break ; } context -> currentBank = bank ; } }
","<S2SV_ModStart> currentBank ) { if ( bank == BANK_0 ) { <S2SV_ModEnd> enc28j60ClearBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) ; } else if ( bank == BANK_1 ) { <S2SV_ModEnd> enc28j60SetBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else if ( bank == BANK_2 ) { <S2SV_ModEnd> enc28j60ClearBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> ) ; enc28j60SetBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else { <S2SV_ModEnd> enc28j60SetBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) <S2SV_ModEnd> ; } context
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> switch ( bank ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug>"
779,CWE-119,"static const char * parse_scheme ( struct parse_state * state ) { size_t mb ; const char * tmp = state -> ptr ; do { switch ( * state -> ptr ) { case ':' : state -> url . scheme = & state -> buffer [ 0 ] ; state -> buffer [ state -> offset ++ ] = 0 ; return ++ state -> ptr ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case '+' : case '-' : case '.' : if ( state -> ptr == tmp ) { <S2SV_StartBug> return tmp ; <S2SV_EndBug> } case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'H' : case 'I' : case 'J' : case 'K' : case 'L' : case 'M' : case 'N' : case 'O' : case 'P' : case 'Q' : case 'R' : case 'S' : case 'T' : case 'U' : case 'V' : case 'W' : case 'X' : case 'Y' : case 'Z' : case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : case 'g' : case 'h' : case 'i' : case 'j' : case 'k' : case 'l' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'r' : case 's' : case 't' : case 'u' : case 'v' : case 'w' : case 'x' : case 'y' : case 'z' : state -> buffer [ state -> offset ++ ] = * state -> ptr ; break ; default : if ( ! ( mb = parse_mb ( state , PARSE_SCHEME , state -> ptr , state -> end , tmp , 1 ) ) ) { <S2SV_StartBug> return tmp ; <S2SV_EndBug> } state -> ptr += mb - 1 ; } } while ( ++ state -> ptr != state -> end ) ; <S2SV_StartBug> return state -> ptr = tmp ; <S2SV_EndBug> }
","<S2SV_ModStart> tmp ) { goto softfail <S2SV_ModEnd> ; } case <S2SV_ModStart> ) ) { goto softfail <S2SV_ModEnd> ; } state <S2SV_ModStart> end ) ; softfail : state -> offset = 0 ;
",m6w6@ext-http/3724cd76a28be1d6049b5537232e97ac567ae1f5,CVE-2016-5873,https://github.com/m6w6/ext-http/commit/3724cd76a28be1d6049b5537232e97ac,2017-01-23T21:59Z,<S2SV_StartBug> return tmp ; <S2SV_EndBug> <S2SV_StartBug> return tmp ; <S2SV_EndBug> <S2SV_StartBug> return state -> ptr = tmp ; <S2SV_EndBug>
2340,CWE-20,"static void __munlock_pagevec ( struct pagevec * pvec , struct zone * zone ) { int i ; int nr = pagevec_count ( pvec ) ; <S2SV_StartBug> int delta_munlocked ; <S2SV_EndBug> struct pagevec pvec_putback ; int pgrescued = 0 ; pagevec_init ( & pvec_putback , 0 ) ; spin_lock_irq ( zone_lru_lock ( zone ) ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( TestClearPageMlocked ( page ) ) { if ( __munlock_isolate_lru_page ( page , false ) ) continue ; else __munlock_isolation_failed ( page ) ; <S2SV_StartBug> } <S2SV_EndBug> pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ; pvec -> pages [ i ] = NULL ; } <S2SV_StartBug> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; <S2SV_EndBug> __mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ; spin_unlock_irq ( zone_lru_lock ( zone ) ) ; pagevec_release ( & pvec_putback ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( page ) { lock_page ( page ) ; if ( ! __putback_lru_fast_prepare ( page , & pvec_putback , & pgrescued ) ) { get_page ( page ) ; __munlock_isolated_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; } } } if ( pagevec_count ( & pvec_putback ) ) __putback_lru_fast ( & pvec_putback , pgrescued ) ; }
","<S2SV_ModStart> ; int delta_munlocked = - nr <S2SV_ModStart> ) ; } else { delta_munlocked ++ ; } <S2SV_ModStart> NULL ; } <S2SV_ModEnd> __mod_zone_page_state ( zone
",torvalds@linux/70feee0e1ef331b22cc51f383d532a0d043fbdcc,CVE-2017-18221,https://github.com/torvalds/linux/commit/70feee0e1ef331b22cc51f383d532a0d043fbdcc,2018-03-07T08:29Z,<S2SV_StartBug> int delta_munlocked ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; <S2SV_EndBug>
8336,CWE-264,"int perf_event_refresh ( struct perf_event * event , int refresh ) { <S2SV_StartBug> if ( event -> attr . inherit || ! is_sampling_event ( event ) ) <S2SV_EndBug> return - EINVAL ; atomic_add ( refresh , & event -> event_limit ) ; perf_event_enable ( event ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> refresh ) { struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; ret = _perf_event_refresh ( event , refresh ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b,CVE-2016-6787,https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b,2016-12-28T07:59Z,<S2SV_StartBug> if ( event -> attr . inherit || ! is_sampling_event ( event ) ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>
7045,CWE-772,"int button_open ( Button * b ) { char * p , name [ 256 ] ; int r ; assert ( b ) ; b -> fd = safe_close ( b -> fd ) ; p = strjoina ( ""/dev/input/"" , b -> name ) ; b -> fd = open ( p , O_RDWR | O_CLOEXEC | O_NOCTTY | O_NONBLOCK ) ; if ( b -> fd < 0 ) return log_warning_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%m"" , p ) ; r = button_suitable ( b ) ; if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>determine<S2SV_blank>whether<S2SV_blank>input<S2SV_blank>device<S2SV_blank>is<S2SV_blank>relevant<S2SV_blank>to<S2SV_blank>us:<S2SV_blank>%m"" ) ; if ( r == 0 ) return log_debug_errno ( SYNTHETIC_ERRNO ( EADDRNOTAVAIL ) , ""Device<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>expose<S2SV_blank>keys<S2SV_blank>or<S2SV_blank>switches<S2SV_blank>relevant<S2SV_blank>to<S2SV_blank>us,<S2SV_blank>ignoring."" , p ) ; if ( ioctl ( b -> fd , EVIOCGNAME ( sizeof ( name ) ) , name ) < 0 ) { r = log_error_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>input<S2SV_blank>name:<S2SV_blank>%m"" ) ; goto fail ; } ( void ) button_set_mask ( b ) ; <S2SV_StartBug> r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ; <S2SV_EndBug> if ( r < 0 ) { log_error_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>button<S2SV_blank>event:<S2SV_blank>%m"" ) ; goto fail ; } log_info ( ""Watching<S2SV_blank>system<S2SV_blank>buttons<S2SV_blank>on<S2SV_blank>/dev/input/%s<S2SV_blank>(%s)"" , b -> name , name ) ; return 0 ; fail : b -> fd = safe_close ( b -> fd ) ; return r ; }
","<S2SV_ModStart> b ) ; b -> io_event_source = sd_event_source_unref ( b -> io_event_source ) ;
",systemd@systemd/b2774a3ae692113e1f47a336a6c09bac9cfb49ad,CVE-2019-20386,https://github.com/systemd/systemd/commit/b2774a3ae692113e1f47a336a6c09bac9cfb49ad,2020-01-21T06:15Z,"<S2SV_StartBug> r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ; <S2SV_EndBug>"
2880,CWE-125,"static void ChopUpSingleUncompressedStrip ( TIFF * tif ) { register TIFFDirectory * td = & tif -> tif_dir ; uint64 bytecount ; uint64 offset ; uint32 rowblock ; uint64 rowblockbytes ; uint64 stripbytes ; uint32 strip ; <S2SV_StartBug> uint64 nstrips64 ; <S2SV_EndBug> uint32 nstrips32 ; uint32 rowsperstrip ; uint64 * newcounts ; uint64 * newoffsets ; bytecount = td -> td_stripbytecount [ 0 ] ; offset = td -> td_stripoffset [ 0 ] ; assert ( td -> td_planarconfig == PLANARCONFIG_CONTIG ) ; if ( ( td -> td_photometric == PHOTOMETRIC_YCBCR ) && ( ! isUpSampled ( tif ) ) ) rowblock = td -> td_ycbcrsubsampling [ 1 ] ; else rowblock = 1 ; rowblockbytes = TIFFVTileSize64 ( tif , rowblock ) ; if ( rowblockbytes > STRIP_SIZE_DEFAULT ) { stripbytes = rowblockbytes ; rowsperstrip = rowblock ; } else if ( rowblockbytes > 0 ) { uint32 rowblocksperstrip ; rowblocksperstrip = ( uint32 ) ( STRIP_SIZE_DEFAULT / rowblockbytes ) ; rowsperstrip = rowblocksperstrip * rowblock ; stripbytes = rowblocksperstrip * rowblockbytes ; } else return ; if ( rowsperstrip >= td -> td_rowsperstrip ) return ; <S2SV_StartBug> nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) <S2SV_EndBug> return ; nstrips32 = ( uint32 ) nstrips64 ; <S2SV_StartBug> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> ""for<S2SV_blank>chopped<S2SV_blank>\\""StripByteCounts\\""<S2SV_blank>array"" ) ; <S2SV_StartBug> newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> ""for<S2SV_blank>chopped<S2SV_blank>\\""StripOffsets\\""<S2SV_blank>array"" ) ; if ( newcounts == NULL || newoffsets == NULL ) { if ( newcounts != NULL ) _TIFFfree ( newcounts ) ; if ( newoffsets != NULL ) _TIFFfree ( newoffsets ) ; return ; } <S2SV_StartBug> for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { <S2SV_EndBug> if ( stripbytes > bytecount ) stripbytes = bytecount ; newcounts [ strip ] = stripbytes ; <S2SV_StartBug> newoffsets [ strip ] = offset ; <S2SV_EndBug> offset += stripbytes ; bytecount -= stripbytes ; } <S2SV_StartBug> td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; <S2SV_EndBug> TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; _TIFFfree ( td -> td_stripbytecount ) ; _TIFFfree ( td -> td_stripoffset ) ; td -> td_stripbytecount = newcounts ; td -> td_stripoffset = newoffsets ; td -> td_stripbytecountsorted = 1 ; }
","<S2SV_ModStart> uint32 strip ; uint32 nstrips <S2SV_ModEnd> ; uint32 rowsperstrip <S2SV_ModStart> ) return ; nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) return ; <S2SV_ModEnd> newcounts = ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ; strip < nstrips <S2SV_ModEnd> ; strip ++ <S2SV_ModStart> strip ] = stripbytes ? offset : 0 <S2SV_ModEnd> ; offset += <S2SV_ModStart> -> td_nstrips = nstrips <S2SV_ModEnd> ; TIFFSetField (
",vadz@libtiff/9a72a69e035ee70ff5c41541c8c61cd97990d018,CVE-2016-10270,https://github.com/vadz/libtiff/commit/9a72a69e035ee70ff5c41541c8c61cd97990d018,2017-03-24T19:59Z,"<S2SV_StartBug> uint64 nstrips64 ; <S2SV_EndBug> <S2SV_StartBug> nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) <S2SV_EndBug> <S2SV_StartBug> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> <S2SV_StartBug> newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> <S2SV_StartBug> for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { <S2SV_EndBug> <S2SV_StartBug> newoffsets [ strip ] = offset ; <S2SV_EndBug> <S2SV_StartBug> td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; <S2SV_EndBug>"
4428,CWE-120,"static void handle_PORT ( ctrl_t * ctrl , char * str ) { int a , b , c , d , e , f ; char addr [ INET_ADDRSTRLEN ] ; struct sockaddr_in sin ; if ( ctrl -> data_sd > 0 ) { uev_io_stop ( & ctrl -> data_watcher ) ; close ( ctrl -> data_sd ) ; ctrl -> data_sd = - 1 ; } sscanf ( str , ""%d,%d,%d,%d,%d,%d"" , & a , & b , & c , & d , & e , & f ) ; <S2SV_StartBug> sprintf ( addr , ""%d.%d.%d.%d"" , a , b , c , d ) ; <S2SV_EndBug> if ( ! inet_aton ( addr , & ( sin . sin_addr ) ) ) { ERR ( 0 , ""Invalid<S2SV_blank>address<S2SV_blank>\'%s\'<S2SV_blank>given<S2SV_blank>to<S2SV_blank>PORT<S2SV_blank>command"" , addr ) ; send_msg ( ctrl -> sd , ""500<S2SV_blank>Illegal<S2SV_blank>PORT<S2SV_blank>command.\\r\\n"" ) ; return ; } strlcpy ( ctrl -> data_address , addr , sizeof ( ctrl -> data_address ) ) ; ctrl -> data_port = e * 256 + f ; DBG ( ""Client<S2SV_blank>PORT<S2SV_blank>command<S2SV_blank>accepted<S2SV_blank>for<S2SV_blank>%s:%d"" , ctrl -> data_address , ctrl -> data_port ) ; send_msg ( ctrl -> sd , ""200<S2SV_blank>PORT<S2SV_blank>command<S2SV_blank>successful.\\r\\n"" ) ; }
","<S2SV_ModStart> f ) ; snprintf ( addr , sizeof ( addr ) <S2SV_ModEnd> , ""%d.%d.%d.%d"" ,
",troglobit@uftpd/0fb2c031ce0ace07cc19cd2cb2143c4b5a63c9dd,CVE-2020-5204,https://github.com/troglobit/uftpd/commit/0fb2c031ce0ace07cc19cd2cb2143c4b5a63c9dd,2020-01-06T20:15Z,"<S2SV_StartBug> sprintf ( addr , ""%d.%d.%d.%d"" , a , b , c , d ) ; <S2SV_EndBug>"
2774,CWE-119,"static noinline int hiddev_ioctl_usage ( struct hiddev * hiddev , unsigned int cmd , void __user * user_arg ) { struct hid_device * hid = hiddev -> hid ; struct hiddev_report_info rinfo ; struct hiddev_usage_ref_multi * uref_multi = NULL ; struct hiddev_usage_ref * uref ; struct hid_report * report ; struct hid_field * field ; int i ; uref_multi = kmalloc ( sizeof ( struct hiddev_usage_ref_multi ) , GFP_KERNEL ) ; if ( ! uref_multi ) return - ENOMEM ; uref = & uref_multi -> uref ; if ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) { if ( copy_from_user ( uref_multi , user_arg , sizeof ( * uref_multi ) ) ) goto fault ; } else { if ( copy_from_user ( uref , user_arg , sizeof ( * uref ) ) ) goto fault ; } switch ( cmd ) { case HIDIOCGUCODE : rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( uref -> usage_index >= field -> maxusage ) goto inval ; uref -> usage_code = field -> usage [ uref -> usage_index ] . hid ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; default : if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT ) goto inval ; if ( uref -> report_id == HID_REPORT_ID_UNKNOWN ) { field = hiddev_lookup_usage ( hid , uref ) ; if ( field == NULL ) goto inval ; } else { rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( cmd == HIDIOCGCOLLECTIONINDEX ) { if ( uref -> usage_index >= field -> maxusage ) goto inval ; } else if ( uref -> usage_index >= field -> report_count ) goto inval ; <S2SV_StartBug> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <S2SV_EndBug> ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ; <S2SV_StartBug> } <S2SV_EndBug> switch ( cmd ) { case HIDIOCGUSAGE : uref -> value = field -> value [ uref -> usage_index ] ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGE : field -> value [ uref -> usage_index ] = uref -> value ; goto goodreturn ; case HIDIOCGCOLLECTIONINDEX : i = field -> usage [ uref -> usage_index ] . collection_index ; kfree ( uref_multi ) ; return i ; case HIDIOCGUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) uref_multi -> values [ i ] = field -> value [ uref -> usage_index + i ] ; if ( copy_to_user ( user_arg , uref_multi , sizeof ( * uref_multi ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) field -> value [ uref -> usage_index + i ] = uref_multi -> values [ i ] ; goto goodreturn ; } goodreturn : kfree ( uref_multi ) ; return 0 ; fault : kfree ( uref_multi ) ; return - EFAULT ; inval : kfree ( uref_multi ) ; return - EINVAL ; } }
","<S2SV_ModStart> goto inval ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> goto inval ; <S2SV_ModEnd> switch ( cmd
",torvalds@linux/93a2001bdfd5376c3dc2158653034c20392d15c5,CVE-2016-5829,https://github.com/torvalds/linux/commit/93a2001bdfd5376c3dc2158653034c20392d15c5,2016-06-27T10:59Z,<S2SV_StartBug> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
2619,CWE-119,"static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb_out ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_type = SADB_X_SPDFLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; <S2SV_StartBug> hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_EndBug> pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; return 0 ; }
","<S2SV_ModStart> ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr ->
",torvalds@linux/85dfb745ee40232876663ae206cba35f24ab2a40,CVE-2013-2237,https://github.com/torvalds/linux/commit/85dfb745ee40232876663ae206cba35f24ab2a40,2013-07-04T21:55Z,<S2SV_StartBug> hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_EndBug>
7295,CWE-787,"rfbBool InitialiseRFBConnection ( rfbClient * client ) { rfbProtocolVersionMsg pv ; int major , minor ; uint32_t authScheme ; uint32_t subAuthScheme ; rfbClientInitMsg ci ; if ( client -> listenSpecified ) errorMessageOnReadFailure = FALSE ; if ( ! ReadFromRFBServer ( client , pv , sz_rfbProtocolVersionMsg ) ) return FALSE ; pv [ sz_rfbProtocolVersionMsg ] = 0 ; errorMessageOnReadFailure = TRUE ; pv [ sz_rfbProtocolVersionMsg ] = 0 ; if ( sscanf ( pv , rfbProtocolVersionFormat , & major , & minor ) != 2 ) { rfbClientLog ( ""Not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>VNC<S2SV_blank>server<S2SV_blank>(%s)\\n"" , pv ) ; return FALSE ; } DefaultSupportedMessages ( client ) ; client -> major = major ; client -> minor = minor ; if ( ( major == rfbProtocolMajorVersion ) && ( minor > rfbProtocolMinorVersion ) ) client -> minor = rfbProtocolMinorVersion ; if ( major == 3 && ( minor == 4 || minor == 6 ) ) { rfbClientLog ( ""UltraVNC<S2SV_blank>server<S2SV_blank>detected,<S2SV_blank>enabling<S2SV_blank>UltraVNC<S2SV_blank>specific<S2SV_blank>messages\\n"" , pv ) ; DefaultSupportedMessagesUltraVNC ( client ) ; } if ( major == 3 && ( minor == 14 || minor == 16 ) ) { minor = minor - 10 ; client -> minor = minor ; rfbClientLog ( ""UltraVNC<S2SV_blank>Single<S2SV_blank>Click<S2SV_blank>server<S2SV_blank>detected,<S2SV_blank>enabling<S2SV_blank>UltraVNC<S2SV_blank>specific<S2SV_blank>messages\\n"" , pv ) ; DefaultSupportedMessagesUltraVNC ( client ) ; } if ( major == 3 && minor == 5 ) { rfbClientLog ( ""TightVNC<S2SV_blank>server<S2SV_blank>detected,<S2SV_blank>enabling<S2SV_blank>TightVNC<S2SV_blank>specific<S2SV_blank>messages\\n"" , pv ) ; DefaultSupportedMessagesTightVNC ( client ) ; } if ( ( major == 3 && minor > 8 ) || major > 3 ) { client -> major = 3 ; client -> minor = 8 ; } rfbClientLog ( ""VNC<S2SV_blank>server<S2SV_blank>supports<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>%d.%d<S2SV_blank>(viewer<S2SV_blank>%d.%d)\\n"" , major , minor , rfbProtocolMajorVersion , rfbProtocolMinorVersion ) ; sprintf ( pv , rfbProtocolVersionFormat , client -> major , client -> minor ) ; if ( ! WriteToRFBServer ( client , pv , sz_rfbProtocolVersionMsg ) ) return FALSE ; if ( client -> major == 3 && client -> minor > 6 ) { if ( ! ReadSupportedSecurityType ( client , & authScheme , FALSE ) ) return FALSE ; } else { if ( ! ReadFromRFBServer ( client , ( char * ) & authScheme , 4 ) ) return FALSE ; authScheme = rfbClientSwap32IfLE ( authScheme ) ; } rfbClientLog ( ""Selected<S2SV_blank>Security<S2SV_blank>Scheme<S2SV_blank>%d\\n"" , authScheme ) ; client -> authScheme = authScheme ; switch ( authScheme ) { case rfbConnFailed : ReadReason ( client ) ; return FALSE ; case rfbNoAuth : rfbClientLog ( ""No<S2SV_blank>authentication<S2SV_blank>needed\\n"" ) ; if ( ( client -> major == 3 && client -> minor > 7 ) || client -> major > 3 ) if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; break ; case rfbVncAuth : if ( ! HandleVncAuth ( client ) ) return FALSE ; break ; # ifdef LIBVNCSERVER_HAVE_SASL case rfbSASL : if ( ! HandleSASLAuth ( client ) ) return FALSE ; break ; # endif case rfbMSLogon : if ( ! HandleMSLogonAuth ( client ) ) return FALSE ; break ; case rfbARD : # ifndef LIBVNCSERVER_WITH_CLIENT_GCRYPT rfbClientLog ( ""GCrypt<S2SV_blank>support<S2SV_blank>was<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>in\\n"" ) ; return FALSE ; # else if ( ! HandleARDAuth ( client ) ) return FALSE ; # endif break ; case rfbTLS : if ( ! HandleAnonTLSAuth ( client ) ) return FALSE ; if ( ! ReadSupportedSecurityType ( client , & subAuthScheme , TRUE ) ) return FALSE ; client -> subAuthScheme = subAuthScheme ; switch ( subAuthScheme ) { case rfbConnFailed : ReadReason ( client ) ; return FALSE ; case rfbNoAuth : rfbClientLog ( ""No<S2SV_blank>sub<S2SV_blank>authentication<S2SV_blank>needed\\n"" ) ; if ( ( client -> major == 3 && client -> minor > 7 ) || client -> major > 3 ) if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; break ; case rfbVncAuth : if ( ! HandleVncAuth ( client ) ) return FALSE ; break ; # ifdef LIBVNCSERVER_HAVE_SASL case rfbSASL : if ( ! HandleSASLAuth ( client ) ) return FALSE ; break ; # endif default : rfbClientLog ( ""Unknown<S2SV_blank>sub<S2SV_blank>authentication<S2SV_blank>scheme<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server:<S2SV_blank>%d\\n"" , ( int ) subAuthScheme ) ; return FALSE ; } break ; case rfbVeNCrypt : if ( ! HandleVeNCryptAuth ( client ) ) return FALSE ; switch ( client -> subAuthScheme ) { case rfbVeNCryptTLSNone : case rfbVeNCryptX509None : rfbClientLog ( ""No<S2SV_blank>sub<S2SV_blank>authentication<S2SV_blank>needed\\n"" ) ; if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; break ; case rfbVeNCryptTLSVNC : case rfbVeNCryptX509VNC : if ( ! HandleVncAuth ( client ) ) return FALSE ; break ; case rfbVeNCryptTLSPlain : case rfbVeNCryptX509Plain : if ( ! HandlePlainAuth ( client ) ) return FALSE ; break ; # ifdef LIBVNCSERVER_HAVE_SASL case rfbVeNCryptX509SASL : case rfbVeNCryptTLSSASL : if ( ! HandleSASLAuth ( client ) ) return FALSE ; break ; # endif default : rfbClientLog ( ""Unknown<S2SV_blank>sub<S2SV_blank>authentication<S2SV_blank>scheme<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server:<S2SV_blank>%d\\n"" , client -> subAuthScheme ) ; return FALSE ; } break ; default : { rfbBool authHandled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; e ; e = e -> next ) { uint32_t const * secType ; if ( ! e -> handleAuthentication ) continue ; for ( secType = e -> securityTypes ; secType && * secType ; secType ++ ) { if ( authScheme == * secType ) { if ( ! e -> handleAuthentication ( client , authScheme ) ) return FALSE ; if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; authHandled = TRUE ; } } } if ( authHandled ) break ; } rfbClientLog ( ""Unknown<S2SV_blank>authentication<S2SV_blank>scheme<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server:<S2SV_blank>%d\\n"" , ( int ) authScheme ) ; return FALSE ; } ci . shared = ( client -> appData . shareDesktop ? 1 : 0 ) ; if ( ! WriteToRFBServer ( client , ( char * ) & ci , sz_rfbClientInitMsg ) ) return FALSE ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> si , sz_rfbServerInitMsg ) ) return FALSE ; client -> si . framebufferWidth = rfbClientSwap16IfLE ( client -> si . framebufferWidth ) ; client -> si . framebufferHeight = rfbClientSwap16IfLE ( client -> si . framebufferHeight ) ; client -> si . format . redMax = rfbClientSwap16IfLE ( client -> si . format . redMax ) ; client -> si . format . greenMax = rfbClientSwap16IfLE ( client -> si . format . greenMax ) ; client -> si . format . blueMax = rfbClientSwap16IfLE ( client -> si . format . blueMax ) ; client -> si . nameLength = rfbClientSwap32IfLE ( client -> si . nameLength ) ; <S2SV_StartBug> client -> desktopName = malloc ( ( uint64_t ) client -> si . nameLength + 1 ) ; <S2SV_EndBug> if ( ! client -> desktopName ) { rfbClientLog ( ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>desktop<S2SV_blank>name,<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) client -> si . nameLength ) ; return FALSE ; } if ( ! ReadFromRFBServer ( client , client -> desktopName , client -> si . nameLength ) ) return FALSE ; client -> desktopName [ client -> si . nameLength ] = 0 ; rfbClientLog ( ""Desktop<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , client -> desktopName ) ; rfbClientLog ( ""Connected<S2SV_blank>to<S2SV_blank>VNC<S2SV_blank>server,<S2SV_blank>using<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>%d.%d\\n"" , client -> major , client -> minor ) ; rfbClientLog ( ""VNC<S2SV_blank>server<S2SV_blank>default<S2SV_blank>format:\\n"" ) ; PrintPixelFormat ( & client -> si . format ) ; return TRUE ; }
","<S2SV_ModStart> nameLength ) ; if ( client -> si . nameLength > 1 << 20 ) { rfbClientErr ( ""Too<S2SV_blank>big<S2SV_blank>desktop<S2SV_blank>name<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned int ) client -> si . nameLength ) ; return FALSE ; } <S2SV_ModStart> = malloc ( <S2SV_ModEnd> client -> si
",LibVNC@libvncserver/c2c4b81e6cb3b485fb1ec7ba9e7defeb889f6ba7,CVE-2018-20748,https://github.com/LibVNC/libvncserver/commit/c2c4b81e6cb3b485fb1ec7ba9e7defeb889f6ba7,2019-01-30T18:29Z,<S2SV_StartBug> client -> desktopName = malloc ( ( uint64_t ) client -> si . nameLength + 1 ) ; <S2SV_EndBug>
3614,CWE-20,"static MagickBooleanType ReadDXT3 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; ssize_t j , y ; PixelPacket * q ; register ssize_t i , x ; unsigned char alpha ; size_t a0 , a1 , bits , code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { <S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; a0 = ReadBlobLSBLong ( image ) ; a1 = ReadBlobLSBLong ( image ) ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickTrue ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( bits >> ( ( 4 * j + i ) * 2 ) ) & 0x3 ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; if ( j < 2 ) alpha = 17U * ( unsigned char ) ( ( a0 >> ( 4 * ( 4 * j + i ) ) ) & 0xf ) ; else alpha = 17U * ( unsigned char ) ( ( a1 >> ( 4 * ( 4 * ( j - 2 ) + i ) ) ) & 0xf ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) alpha ) ) ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } } <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 16 ) ; <S2SV_EndBug> return MagickTrue ; }
","<S2SV_ModStart> , y , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> x ) , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> ; } } return ( <S2SV_ModStart> dds_info , 16 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>
",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z,"<S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 16 ) ; <S2SV_EndBug>"
2280,CWE-119,"static ssize_t k90_show_macro_mode ( struct device * dev , struct device_attribute * attr , char * buf ) { int ret ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; const char * macro_mode ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_GET_MODE , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 2 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>mode<S2SV_blank>(error<S2SV_blank>%d).\\n"" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> switch ( data [ 0 ] ) { case K90_MACRO_MODE_HW : macro_mode = ""HW"" ; break ; case K90_MACRO_MODE_SW : macro_mode = ""SW"" ; break ; default : dev_warn ( dev , ""K90<S2SV_blank>in<S2SV_blank>unknown<S2SV_blank>mode:<S2SV_blank>%02hhx.\\n"" , data [ 0 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return snprintf ( buf , PAGE_SIZE , ""%s\\n"" , macro_mode ) ; }
","<S2SV_ModStart> macro_mode ; char * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%s\\n"" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/6d104af38b570d37aa32a5803b04c354f8ed513d,CVE-2017-5547,https://github.com/torvalds/linux/commit/6d104af38b570d37aa32a5803b04c354f8ed513d,2017-02-06T06:59Z,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
3307,CWE-119,"static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char charbuf [ 512 ] ; char htmlstring [ ] = ""<html>"" ; char framestring [ ] = ""</frameset></html>"" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( ""pixHtmlViewer"" ) ; if ( ! dirin ) return ERROR_INT ( ""dirin<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( ""dirout<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( ""thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( ""viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir<S2SV_blank>-p<S2SV_blank>%s"" , dirout ) ; ret = system ( charbuf ) ; # else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ; # endif if ( ret ) { L_ERROR ( ""output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\n"" , procName , dirout ) ; return 1 ; } if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( ""safiles<S2SV_blank>not<S2SV_blank>made"" , procName , 1 ) ; <S2SV_StartBug> sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ; <S2SV_EndBug> mainname = stringNew ( charbuf ) ; <S2SV_StartBug> sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ; <S2SV_EndBug> linkname = stringNew ( charbuf ) ; linknameshort = stringJoin ( rootname , ""-links.html"" ) ; sathumbs = sarrayCreate ( 0 ) ; saviews = sarrayCreate ( 0 ) ; nfiles = sarrayGetCount ( safiles ) ; index = 0 ; for ( i = 0 ; i < nfiles ; i ++ ) { fname = sarrayGetString ( safiles , i , L_NOCOPY ) ; fullname = genPathname ( dirin , fname ) ; fprintf ( stderr , ""name:<S2SV_blank>%s\\n"" , fullname ) ; if ( ( pix = pixRead ( fullname ) ) == NULL ) { fprintf ( stderr , ""file<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>a<S2SV_blank>readable<S2SV_blank>image\\n"" , fullname ) ; lept_free ( fullname ) ; continue ; } lept_free ( fullname ) ; pixGetDimensions ( pix , & w , NULL , & d ) ; factor = ( l_float32 ) thumbwidth / ( l_float32 ) w ; pixthumb = pixScale ( pix , factor , factor ) ; <S2SV_StartBug> sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ; <S2SV_EndBug> sarrayAddString ( sathumbs , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixthumb ) ; lept_free ( outname ) ; pixDestroy ( & pixthumb ) ; factor = ( l_float32 ) viewwidth / ( l_float32 ) w ; if ( factor >= 1.0 ) pixview = pixClone ( pix ) ; else pixview = pixScale ( pix , factor , factor ) ; snprintf ( charbuf , sizeof ( charbuf ) , ""%s_view_%03d"" , rootname , index ) ; sarrayAddString ( saviews , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixview ) ; lept_free ( outname ) ; pixDestroy ( & pixview ) ; pixDestroy ( & pix ) ; index ++ ; } sahtml = sarrayCreate ( 0 ) ; sarrayAddString ( sahtml , htmlstring , L_COPY ) ; sprintf ( charbuf , ""<frameset<S2SV_blank>cols=\\""%d,<S2SV_blank>*\\"">"" , thumbwidth + 30 ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""thumbs\\""<S2SV_blank>src=\\""%s\\"">"" , linknameshort ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""views\\""<S2SV_blank>src=\\""%s\\"">"" , sarrayGetString ( saviews , 0 , L_NOCOPY ) ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sarrayAddString ( sahtml , framestring , L_COPY ) ; shtml = sarrayToString ( sahtml , 1 ) ; l_binaryWrite ( mainname , ""w"" , shtml , strlen ( shtml ) ) ; fprintf ( stderr , ""******************************************\\n"" ""Writing<S2SV_blank>html<S2SV_blank>file:<S2SV_blank>%s\\n"" ""******************************************\\n"" , mainname ) ; lept_free ( shtml ) ; lept_free ( mainname ) ; nimages = sarrayGetCount ( saviews ) ; fprintf ( stderr , ""num.<S2SV_blank>images<S2SV_blank>=<S2SV_blank>%d\\n"" , nimages ) ; salink = sarrayCreate ( 0 ) ; for ( i = 0 ; i < nimages ; i ++ ) { viewfile = sarrayGetString ( saviews , i , L_NOCOPY ) ; thumbfile = sarrayGetString ( sathumbs , i , L_NOCOPY ) ; sprintf ( charbuf , ""<a<S2SV_blank>href=\\""%s\\""<S2SV_blank>TARGET=views><img<S2SV_blank>src=\\""%s\\""></a>"" , viewfile , thumbfile ) ; sarrayAddString ( salink , charbuf , L_COPY ) ; } slink = sarrayToString ( salink , 1 ) ; l_binaryWrite ( linkname , ""w"" , slink , strlen ( slink ) ) ; lept_free ( slink ) ; lept_free ( linkname ) ; lept_free ( linknameshort ) ; sarrayDestroy ( & safiles ) ; sarrayDestroy ( & sathumbs ) ; sarrayDestroy ( & saviews ) ; sarrayDestroy ( & sahtml ) ; sarrayDestroy ( & salink ) ; return 0 ; }
","<S2SV_ModStart> 1 ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , ""%s/%s.html"" , <S2SV_ModStart> charbuf ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , ""%s/%s-links.html"" , <S2SV_ModStart> factor ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , ""%s_thumb_%03d"" ,
",DanBloomberg@leptonica/c1079bb8e77cdd426759e466729917ca37a3ed9f,CVE-2018-7247,https://github.com/DanBloomberg/leptonica/commit/c1079bb8e77cdd426759e466729917ca37a3ed9f,2018-02-19T18:29Z,"<S2SV_StartBug> sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ; <S2SV_EndBug>"
2178,CWE-191,"static void edge_bulk_in_callback ( struct urb * urb ) { struct edgeport_port * edge_port = urb -> context ; struct device * dev = & edge_port -> port -> dev ; unsigned char * data = urb -> transfer_buffer ; int retval = 0 ; int port_number ; int status = urb -> status ; switch ( status ) { case 0 : break ; case - ECONNRESET : case - ENOENT : case - ESHUTDOWN : dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>urb<S2SV_blank>shutting<S2SV_blank>down<S2SV_blank>with<S2SV_blank>status:<S2SV_blank>%d\\n"" , __func__ , status ) ; return ; default : dev_err ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>read<S2SV_blank>bulk<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>%d\\n"" , __func__ , status ) ; } if ( status == - EPIPE ) goto exit ; if ( status ) { dev_err ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>stopping<S2SV_blank>read!\\n"" , __func__ ) ; return ; } port_number = edge_port -> port -> port_number ; <S2SV_StartBug> if ( edge_port -> lsr_event ) { <S2SV_EndBug> edge_port -> lsr_event = 0 ; dev_dbg ( dev , ""%s<S2SV_blank>=====<S2SV_blank>Port<S2SV_blank>%u<S2SV_blank>LSR<S2SV_blank>Status<S2SV_blank>=<S2SV_blank>%02x,<S2SV_blank>Data<S2SV_blank>=<S2SV_blank>%02x<S2SV_blank>======\\n"" , __func__ , port_number , edge_port -> lsr_mask , * data ) ; handle_new_lsr ( edge_port , 1 , edge_port -> lsr_mask , * data ) ; -- urb -> actual_length ; ++ data ; } if ( urb -> actual_length ) { usb_serial_debug_data ( dev , __func__ , urb -> actual_length , data ) ; if ( edge_port -> close_pending ) dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>close<S2SV_blank>pending,<S2SV_blank>dropping<S2SV_blank>data<S2SV_blank>on<S2SV_blank>the<S2SV_blank>floor\\n"" , __func__ ) ; else edge_tty_recv ( edge_port -> port , data , urb -> actual_length ) ; edge_port -> port -> icount . rx += urb -> actual_length ; } exit : spin_lock ( & edge_port -> ep_lock ) ; if ( edge_port -> ep_read_urb_state == EDGE_READ_URB_RUNNING ) retval = usb_submit_urb ( urb , GFP_ATOMIC ) ; else if ( edge_port -> ep_read_urb_state == EDGE_READ_URB_STOPPING ) edge_port -> ep_read_urb_state = EDGE_READ_URB_STOPPED ; spin_unlock ( & edge_port -> ep_lock ) ; if ( retval ) dev_err ( dev , ""%s<S2SV_blank>-<S2SV_blank>usb_submit_urb<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>result<S2SV_blank>%d\\n"" , __func__ , retval ) ; }
","<S2SV_ModStart> ; if ( urb -> actual_length > 0 &&
",torvalds@linux/654b404f2a222f918af9b0cd18ad469d0c941a8e,CVE-2017-8924,https://github.com/torvalds/linux/commit/654b404f2a222f918af9b0cd18ad469d0c941a8e,2017-05-12T21:29Z,<S2SV_StartBug> if ( edge_port -> lsr_event ) { <S2SV_EndBug>
2524,CWE-399,"<S2SV_StartBug> static void kiocb_batch_free ( struct kiocb_batch * batch ) <S2SV_EndBug> { <S2SV_StartBug> struct kiocb * req , * n ; <S2SV_EndBug> list_for_each_entry_safe ( req , n , & batch -> head , ki_batch ) { list_del ( & req -> ki_batch ) ; <S2SV_StartBug> kmem_cache_free ( kiocb_cachep , req ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> void kiocb_batch_free ( struct kioctx * ctx , <S2SV_ModStart> , * n ; if ( list_empty ( & batch -> head ) ) return ; spin_lock_irq ( & ctx -> ctx_lock ) <S2SV_ModStart> ki_batch ) ; list_del ( & req -> ki_list ) ; <S2SV_ModStart> req ) ; ctx -> reqs_active -- ; } spin_unlock_irq ( & ctx -> ctx_lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/802f43594d6e4d2ac61086d239153c17873a0428,CVE-2012-0058,https://github.com/torvalds/linux/commit/802f43594d6e4d2ac61086d239153c17873a0428,2012-05-17T11:00Z,"<S2SV_StartBug> static void kiocb_batch_free ( struct kiocb_batch * batch ) <S2SV_EndBug> <S2SV_StartBug> struct kiocb * req , * n ; <S2SV_EndBug> <S2SV_StartBug> kmem_cache_free ( kiocb_cachep , req ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
375,CWE-125,"static const uint32_t * parserep ( netdissect_options * ndo , register const struct sunrpc_msg * rp , register u_int length ) { register const uint32_t * dp ; u_int len ; enum sunrpc_accept_stat astat ; dp = ( ( const uint32_t * ) & rp -> rm_reply ) + 1 ; ND_TCHECK ( dp [ 1 ] ) ; len = EXTRACT_32BITS ( & dp [ 1 ] ) ; if ( len >= length ) return ( NULL ) ; dp += ( len + ( 2 * sizeof ( uint32_t ) + 3 ) ) / sizeof ( uint32_t ) ; <S2SV_StartBug> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <S2SV_EndBug> astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ; if ( astat != SUNRPC_SUCCESS ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( sunrpc_str , ""ar_stat<S2SV_blank>%d"" , astat ) ) ) ; nfserr = 1 ; return ( NULL ) ; } ND_TCHECK2 ( * dp , sizeof ( astat ) ) ; return ( ( const uint32_t * ) ( sizeof ( astat ) + ( ( const char * ) dp ) ) ) ; trunc : return ( 0 ) ; }
","<S2SV_ModStart> uint32_t ) ; ND_TCHECK <S2SV_ModEnd> ( dp [ <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ) ; astat
",the-tcpdump-group@tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,CVE-2017-12898,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,2017-09-14T06:29Z,"<S2SV_StartBug> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <S2SV_EndBug>"
545,CWE-119,"int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , struct rt6_info * rt , unsigned int flags , int dontfrag ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_cork * cork ; struct sk_buff * skb , * skb_prev = NULL ; unsigned int maxfraglen , fragheaderlen , mtu ; int exthdrlen ; int dst_exthdrlen ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; if ( flags & MSG_PROBE ) return 0 ; cork = & inet -> cork . base ; if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { if ( opt ) { if ( WARN_ON ( np -> cork . opt ) ) return - EINVAL ; np -> cork . opt = kzalloc ( opt -> tot_len , sk -> sk_allocation ) ; if ( unlikely ( np -> cork . opt == NULL ) ) return - ENOBUFS ; np -> cork . opt -> tot_len = opt -> tot_len ; np -> cork . opt -> opt_flen = opt -> opt_flen ; np -> cork . opt -> opt_nflen = opt -> opt_nflen ; np -> cork . opt -> dst0opt = ip6_opt_dup ( opt -> dst0opt , sk -> sk_allocation ) ; if ( opt -> dst0opt && ! np -> cork . opt -> dst0opt ) return - ENOBUFS ; np -> cork . opt -> dst1opt = ip6_opt_dup ( opt -> dst1opt , sk -> sk_allocation ) ; if ( opt -> dst1opt && ! np -> cork . opt -> dst1opt ) return - ENOBUFS ; np -> cork . opt -> hopopt = ip6_opt_dup ( opt -> hopopt , sk -> sk_allocation ) ; if ( opt -> hopopt && ! np -> cork . opt -> hopopt ) return - ENOBUFS ; np -> cork . opt -> srcrt = ip6_rthdr_dup ( opt -> srcrt , sk -> sk_allocation ) ; if ( opt -> srcrt && ! np -> cork . opt -> srcrt ) return - ENOBUFS ; } dst_hold ( & rt -> dst ) ; cork -> dst = & rt -> dst ; inet -> cork . fl . u . ip6 = * fl6 ; np -> cork . hop_limit = hlimit ; np -> cork . tclass = tclass ; if ( rt -> dst . flags & DST_XFRM_TUNNEL ) mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( & rt -> dst ) ; else mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; if ( np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } cork -> fragsize = mtu ; if ( dst_allfrag ( rt -> dst . path ) ) cork -> flags |= IPCORK_ALLFRAG ; cork -> length = 0 ; exthdrlen = ( opt ? opt -> opt_flen : 0 ) ; length += exthdrlen ; transhdrlen += exthdrlen ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } else { rt = ( struct rt6_info * ) cork -> dst ; fl6 = & inet -> cork . fl . u . ip6 ; opt = np -> cork . opt ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; mtu = cork -> fragsize ; } hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; if ( mtu <= sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ) { if ( cork -> length + length > sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN - fragheaderlen ) { ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } } if ( sk -> sk_type == SOCK_DGRAM ) sock_tx_timestamp ( sk , & tx_flags ) ; <S2SV_StartBug> cork -> length += length ; <S2SV_EndBug> <S2SV_StartBug> if ( length > mtu ) { <S2SV_EndBug> int proto = sk -> sk_protocol ; <S2SV_StartBug> if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { <S2SV_EndBug> ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } <S2SV_StartBug> if ( proto == IPPROTO_UDP && <S2SV_EndBug> ( rt -> dst . dev -> features & NETIF_F_UFO ) ) { err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , transhdrlen , mtu , flags , rt ) ; if ( err ) goto error ; return 0 ; } <S2SV_StartBug> } <S2SV_EndBug> if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( skb == NULL || skb_prev == NULL ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , np -> pmtudisc == IPV6_PMTUDISC_PROBE ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ; if ( transhdrlen ) { skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( skb == NULL ) ) err = - ENOBUFS ; else { tx_flags = 0 ; } } if ( skb == NULL ) goto error ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = CHECKSUM_NONE ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; if ( sk -> sk_type == SOCK_DGRAM ) skb_shinfo ( skb ) -> tx_flags = tx_flags ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; struct page_frag * pfrag = sk_page_frag ( sk ) ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }
","<S2SV_ModStart> tx_flags ) ; if ( <S2SV_ModEnd> ( length > <S2SV_ModStart> > mtu ) && <S2SV_ModEnd> dontfrag && ( <S2SV_ModStart> dontfrag && ( sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_UDP || <S2SV_ModStart> == IPPROTO_UDP || sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_RAW ) <S2SV_ModStart> EMSGSIZE ; } skb = skb_peek_tail ( & sk -> sk_write_queue ) ; cork -> length += length ; if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) <S2SV_ModEnd> && ( rt <S2SV_ModStart> 0 ; } if ( ! skb <S2SV_ModEnd> ) goto alloc_new_skb
",torvalds@linux/2811ebac2521ceac84f2bdae402455baa6a7fb47,CVE-2013-4387,https://github.com/torvalds/linux/commit/2811ebac2521ceac84f2bdae402455baa6a7fb47,2013-10-10T10:55Z,<S2SV_StartBug> cork -> length += length ; <S2SV_EndBug> <S2SV_StartBug> if ( length > mtu ) { <S2SV_EndBug> <S2SV_StartBug> if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( proto == IPPROTO_UDP && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
2188,CWE-125,"struct _mdi * _WM_ParseNewMidi ( uint8_t * midi_data , uint32_t midi_size ) { struct _mdi * mdi ; uint32_t tmp_val ; uint32_t midi_type ; <S2SV_StartBug> uint32_t track_size ; <S2SV_EndBug> uint8_t * * tracks ; uint32_t end_of_tracks = 0 ; uint32_t no_tracks ; uint32_t i ; uint32_t divisions = 96 ; uint32_t tempo = 500000 ; float samples_per_delta_f = 0.0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint8_t * sysex_store = NULL ; uint32_t * track_delta ; uint8_t * track_end ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint8_t * running_event ; uint32_t setup_ret = 0 ; if ( midi_size < 14 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; return ( NULL ) ; } if ( ! memcmp ( midi_data , ""RIFF"" , 4 ) ) { if ( midi_size < 34 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; return ( NULL ) ; } midi_data += 20 ; midi_size -= 20 ; } if ( memcmp ( midi_data , ""MThd"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MIDI , NULL , 0 ) ; return ( NULL ) ; } midi_data += 4 ; midi_size -= 4 ; tmp_val = * midi_data ++ << 24 ; tmp_val |= * midi_data ++ << 16 ; tmp_val |= * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 4 ; if ( tmp_val != 6 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , NULL , 0 ) ; return ( NULL ) ; } tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val > 2 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } midi_type = tmp_val ; tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val < 1 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(no<S2SV_blank>tracks)"" , 0 ) ; return ( NULL ) ; } no_tracks = tmp_val ; if ( ( midi_type == 0 ) && ( no_tracks > 1 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , ""(expected<S2SV_blank>1<S2SV_blank>track<S2SV_blank>for<S2SV_blank>type<S2SV_blank>0<S2SV_blank>midi<S2SV_blank>file,<S2SV_blank>found<S2SV_blank>more)"" , 0 ) ; return ( NULL ) ; } divisions = * midi_data ++ << 8 ; divisions |= * midi_data ++ ; midi_size -= 2 ; if ( divisions & 0x00008000 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( mdi , divisions ) ; tracks = malloc ( sizeof ( uint8_t * ) * no_tracks ) ; <S2SV_StartBug> track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_EndBug> track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ; running_event = malloc ( sizeof ( uint8_t ) * no_tracks ) ; smallest_delta = 0xffffffff ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( midi_size < 8 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } if ( memcmp ( midi_data , ""MTrk"" , 4 ) != 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>track<S2SV_blank>header)"" , 0 ) ; goto _end ; } midi_data += 4 ; midi_size -= 4 ; <S2SV_StartBug> track_size = * midi_data ++ << 24 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 16 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 8 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ ; <S2SV_EndBug> midi_size -= 4 ; <S2SV_StartBug> if ( midi_size < track_size ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_StartBug> if ( track_size < 3 ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(bad<S2SV_blank>track<S2SV_blank>size)"" , 0 ) ; goto _end ; } <S2SV_StartBug> if ( ( midi_data [ track_size - 3 ] != 0xFF ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 2 ] != 0x2F ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 1 ] != 0x00 ) ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>EOT)"" , 0 ) ; goto _end ; } tracks [ i ] = midi_data ; <S2SV_StartBug> midi_data += track_size ; <S2SV_EndBug> <S2SV_StartBug> midi_size -= track_size ; <S2SV_EndBug> track_end [ i ] = 0 ; running_event [ i ] = 0 ; track_delta [ i ] = 0 ; while ( * tracks [ i ] > 0x7F ) { track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; tracks [ i ] ++ ; <S2SV_StartBug> } <S2SV_EndBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> if ( midi_type == 1 ) { if ( track_delta [ i ] < smallest_delta ) { smallest_delta = track_delta [ i ] ; } } else { if ( i == 0 ) smallest_delta = track_delta [ i ] ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; if ( midi_type == 1 ) { while ( end_of_tracks != no_tracks ) { smallest_delta = 0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( track_end [ i ] ) continue ; if ( track_delta [ i ] ) { track_delta [ i ] -= subtract_delta ; if ( track_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } continue ; } } do { <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { end_of_tracks ++ ; track_end [ i ] = 1 ; tracks [ i ] += 3 ; <S2SV_StartBug> goto NEXT_TRACK ; <S2SV_EndBug> } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ; <S2SV_StartBug> if ( * tracks [ i ] > 0x7f ) { <S2SV_EndBug> do { <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> tracks [ i ] ++ ; <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> } <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> } while ( ! track_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } NEXT_TRACK : continue ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; } } else { if ( midi_type == 2 ) { mdi -> is_type2 = 1 ; } sample_remainder = 0.0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { running_event [ i ] = 0 ; do { <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { track_end [ i ] = 1 ; goto NEXT_TRACK2 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ; <S2SV_StartBug> track_delta [ i ] = 0 ; <S2SV_EndBug> if ( * tracks [ i ] > 0x7f ) { do { <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> tracks [ i ] ++ ; <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> } <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; NEXT_TRACK2 : smallest_delta = track_delta [ i ] ; UNUSED ( smallest_delta ) ; } while ( track_end [ i ] == 0 ) ; } } if ( ( mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _end ; } mdi -> extra_info . current_sample = 0 ; mdi -> current_event = & mdi -> events [ 0 ] ; mdi -> samples_to_mix = 0 ; mdi -> note = NULL ; _WM_ResetToStart ( mdi ) ; _end : free ( sysex_store ) ; free ( track_end ) ; free ( track_delta ) ; free ( running_event ) ; free ( tracks ) ; <S2SV_StartBug> if ( mdi -> reverb ) return ( mdi ) ; <S2SV_EndBug> _WM_freeMDI ( mdi ) ; return ( NULL ) ; }
","<S2SV_ModStart> uint32_t midi_type ; uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> ; uint32_t end_of_tracks <S2SV_ModStart> no_tracks ) ; track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> -= 4 ; tmp_val <S2SV_ModEnd> = * midi_data <S2SV_ModStart> << 24 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 16 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 8 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> ( midi_size < tmp_val <S2SV_ModEnd> ) { _WM_GLOBAL_ERROR <S2SV_ModStart> } if ( tmp_val <S2SV_ModEnd> < 3 ) <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 3 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 2 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 1 ] <S2SV_ModStart> = midi_data ; track_size [ i ] = tmp_val ; midi_data += tmp_val <S2SV_ModEnd> ; midi_size -= <S2SV_ModStart> ; midi_size -= tmp_val <S2SV_ModEnd> ; track_end [ <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += 3 ; track_size [ i ] -= 3 ; <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> tracks ) ; free ( track_size ) ;
",Mindwerks@wildmidi/660b513d99bced8783a4a5984ac2f742c74ebbdd,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/660b513d99bced8783a4a5984ac2f742c74ebbdd,2017-08-17T16:29Z,"<S2SV_StartBug> uint32_t track_size ; <S2SV_EndBug> <S2SV_StartBug> track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_EndBug> <S2SV_StartBug> track_size = * midi_data ++ << 24 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 16 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 8 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( midi_size < track_size ) { <S2SV_EndBug> <S2SV_StartBug> if ( track_size < 3 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( midi_data [ track_size - 3 ] != 0xFF ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 2 ] != 0x2F ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 1 ] != 0x00 ) ) { <S2SV_EndBug> <S2SV_StartBug> midi_data += track_size ; <S2SV_EndBug> <S2SV_StartBug> midi_size -= track_size ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> goto NEXT_TRACK ; <S2SV_EndBug> <S2SV_StartBug> if ( * tracks [ i ] > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( mdi -> reverb ) return ( mdi ) ; <S2SV_EndBug>"
79,CWE-000,"void sas_unregister_dev ( struct asd_sas_port * port , struct domain_device * dev ) { if ( ! test_bit ( SAS_DEV_DESTROY , & dev -> state ) && ! list_empty ( & dev -> disco_list_node ) ) { list_del_init ( & dev -> disco_list_node ) ; sas_rphy_free ( dev -> rphy ) ; sas_unregister_common_dev ( port , dev ) ; return ; } if ( ! test_and_set_bit ( SAS_DEV_DESTROY , & dev -> state ) ) { sas_rphy_unlink ( dev -> rphy ) ; list_move_tail ( & dev -> disco_list_node , & port -> destroy_list ) ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> destroy_list ) ; <S2SV_ModEnd> } } <S2SV_null>
",torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ; <S2SV_EndBug>"
1223,CWE-119,"php_stream * php_stream_url_wrap_http_ex ( php_stream_wrapper * wrapper , const char * path , const char * mode , int options , char * * opened_path , php_stream_context * context , int redirect_max , int flags STREAMS_DC TSRMLS_DC ) { php_stream * stream = NULL ; php_url * resource = NULL ; int use_ssl ; int use_proxy = 0 ; char * scratch = NULL ; char * tmp = NULL ; char * ua_str = NULL ; zval * * ua_zval = NULL , * * tmpzval = NULL , * ssl_proxy_peer_name = NULL ; int scratch_len = 0 ; int body = 0 ; char location [ HTTP_HEADER_BLOCK_SIZE ] ; zval * response_header = NULL ; int reqok = 0 ; char * http_header_line = NULL ; char tmp_line [ 128 ] ; size_t chunk_size = 0 , file_size = 0 ; int eol_detect = 0 ; char * transport_string , * errstr = NULL ; int transport_len , have_header = 0 , request_fulluri = 0 , ignore_errors = 0 ; char * protocol_version = NULL ; int protocol_version_len = 3 ; struct timeval timeout ; char * user_headers = NULL ; int header_init = ( ( flags & HTTP_WRAPPER_HEADER_INIT ) != 0 ) ; int redirected = ( ( flags & HTTP_WRAPPER_REDIRECTED ) != 0 ) ; int follow_location = 1 ; php_stream_filter * transfer_encoding = NULL ; int response_code ; tmp_line [ 0 ] = '\\0' ; if ( redirect_max < 1 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Redirection<S2SV_blank>limit<S2SV_blank>reached,<S2SV_blank>aborting"" ) ; return NULL ; } resource = php_url_parse ( path ) ; if ( resource == NULL ) { return NULL ; } if ( strncasecmp ( resource -> scheme , ""http"" , sizeof ( ""http"" ) ) && strncasecmp ( resource -> scheme , ""https"" , sizeof ( ""https"" ) ) ) { if ( ! context || php_stream_context_get_option ( context , wrapper -> wops -> label , ""proxy"" , & tmpzval ) == FAILURE || Z_TYPE_PP ( tmpzval ) != IS_STRING || Z_STRLEN_PP ( tmpzval ) <= 0 ) { php_url_free ( resource ) ; return php_stream_open_wrapper_ex ( path , mode , REPORT_ERRORS , NULL , context ) ; } request_fulluri = 1 ; use_ssl = 0 ; use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { if ( strpbrk ( mode , ""awx+"" ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>wrapper<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>writeable<S2SV_blank>connections"" ) ; php_url_free ( resource ) ; return NULL ; } use_ssl = resource -> scheme && ( strlen ( resource -> scheme ) > 4 ) && resource -> scheme [ 4 ] == 's' ; if ( use_ssl && resource -> port == 0 ) resource -> port = 443 ; else if ( resource -> port == 0 ) resource -> port = 80 ; if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""proxy"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { transport_len = spprintf ( & transport_string , 0 , ""%s://%s:%d"" , use_ssl ? ""ssl"" : ""tcp"" , resource -> host , resource -> port ) ; } } if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""timeout"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; timeout . tv_sec = ( time_t ) Z_DVAL_PP ( tmpzval ) ; timeout . tv_usec = ( size_t ) ( ( Z_DVAL_PP ( tmpzval ) - timeout . tv_sec ) * 1000000 ) ; } else { timeout . tv_sec = FG ( default_socket_timeout ) ; timeout . tv_usec = 0 ; } stream = php_stream_xport_create ( transport_string , transport_len , options , STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT , NULL , & timeout , context , & errstr , NULL ) ; if ( stream ) { php_stream_set_option ( stream , PHP_STREAM_OPTION_READ_TIMEOUT , 0 , & timeout ) ; } if ( errstr ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""%s"" , errstr ) ; efree ( errstr ) ; errstr = NULL ; } efree ( transport_string ) ; if ( stream && use_proxy && use_ssl ) { smart_str header = { 0 } ; if ( ! context || php_stream_context_get_option ( context , ""ssl"" , ""peer_name"" , & tmpzval ) == FAILURE ) { MAKE_STD_ZVAL ( ssl_proxy_peer_name ) ; ZVAL_STRING ( ssl_proxy_peer_name , resource -> host , 1 ) ; php_stream_context_set_option ( stream -> context , ""ssl"" , ""peer_name"" , ssl_proxy_peer_name ) ; } smart_str_appendl ( & header , ""CONNECT<S2SV_blank>"" , sizeof ( ""CONNECT<S2SV_blank>"" ) - 1 ) ; smart_str_appends ( & header , resource -> host ) ; smart_str_appendc ( & header , ':' ) ; smart_str_append_unsigned ( & header , resource -> port ) ; smart_str_appendl ( & header , ""<S2SV_blank>HTTP/1.0\\r\\n"" , sizeof ( ""<S2SV_blank>HTTP/1.0\\r\\n"" ) - 1 ) ; if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) { char * s , * p ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { s = Z_STRVAL_PP ( tmpheader ) ; do { while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } } else if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { s = Z_STRVAL_PP ( tmpzval ) ; do { while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } finish : smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; if ( php_stream_write ( stream , header . c , header . len ) != header . len ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ; php_stream_close ( stream ) ; stream = NULL ; } smart_str_free ( & header ) ; if ( stream ) { char header_line [ HTTP_HEADER_BLOCK_SIZE ] ; while ( php_stream_gets ( stream , header_line , HTTP_HEADER_BLOCK_SIZE - 1 ) != NULL ) { if ( header_line [ 0 ] == '\\n' || header_line [ 0 ] == '\\r' || header_line [ 0 ] == '\\0' ) { break ; } } } if ( stream ) { if ( php_stream_xport_crypto_setup ( stream , STREAM_CRYPTO_METHOD_SSLv23_CLIENT , NULL TSRMLS_CC ) < 0 || php_stream_xport_crypto_enable ( stream , 1 TSRMLS_CC ) < 0 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ; php_stream_close ( stream ) ; stream = NULL ; } } } if ( stream == NULL ) goto out ; if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ; eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; stream -> flags &= ~ ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; php_stream_context_set ( stream , context ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_CONNECT , NULL , 0 ) ; if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""max_redirects"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; redirect_max = Z_LVAL_PP ( tmpzval ) ; } if ( context && php_stream_context_get_option ( context , ""http"" , ""method"" , & tmpzval ) == SUCCESS ) { if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! redirected || ( Z_STRLEN_PP ( tmpzval ) == 3 && memcmp ( ""GET"" , Z_STRVAL_PP ( tmpzval ) , 3 ) == 0 ) || ( Z_STRLEN_PP ( tmpzval ) == 4 && memcmp ( ""HEAD"" , Z_STRVAL_PP ( tmpzval ) , 4 ) == 0 ) ) { scratch_len = strlen ( path ) + 29 + Z_STRLEN_PP ( tmpzval ) ; scratch = emalloc ( scratch_len ) ; strlcpy ( scratch , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) + 1 ) ; strncat ( scratch , ""<S2SV_blank>"" , 1 ) ; } } } if ( context && php_stream_context_get_option ( context , ""http"" , ""protocol_version"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; protocol_version_len = spprintf ( & protocol_version , 0 , ""%.1F"" , Z_DVAL_PP ( tmpzval ) ) ; } if ( ! scratch ) { scratch_len = strlen ( path ) + 29 + protocol_version_len ; scratch = emalloc ( scratch_len ) ; strncpy ( scratch , ""GET<S2SV_blank>"" , scratch_len ) ; } if ( ! request_fulluri && context && php_stream_context_get_option ( context , ""http"" , ""request_fulluri"" , & tmpzval ) == SUCCESS ) { zval ztmp = * * tmpzval ; zval_copy_ctor ( & ztmp ) ; convert_to_boolean ( & ztmp ) ; request_fulluri = Z_BVAL ( ztmp ) ? 1 : 0 ; zval_dtor ( & ztmp ) ; } if ( request_fulluri ) { strcat ( scratch , path ) ; } else { if ( resource -> path && * resource -> path ) { strlcat ( scratch , resource -> path , scratch_len ) ; } else { strlcat ( scratch , ""/"" , scratch_len ) ; } if ( resource -> query ) { strlcat ( scratch , ""?"" , scratch_len ) ; strlcat ( scratch , resource -> query , scratch_len ) ; } } if ( protocol_version ) { strlcat ( scratch , ""<S2SV_blank>HTTP/"" , scratch_len ) ; strlcat ( scratch , protocol_version , scratch_len ) ; strlcat ( scratch , ""\\r\\n"" , scratch_len ) ; } else { strlcat ( scratch , ""<S2SV_blank>HTTP/1.0\\r\\n"" , scratch_len ) ; } php_stream_write ( stream , scratch , strlen ( scratch ) ) ; if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) { tmp = NULL ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; smart_str tmpstr = { 0 } ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { smart_str_appendl ( & tmpstr , Z_STRVAL_PP ( tmpheader ) , Z_STRLEN_PP ( tmpheader ) ) ; smart_str_appendl ( & tmpstr , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; } } smart_str_0 ( & tmpstr ) ; if ( tmpstr . c ) { tmp = php_trim ( tmpstr . c , strlen ( tmpstr . c ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; smart_str_free ( & tmpstr ) ; } } if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { tmp = php_trim ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; } if ( tmp && strlen ( tmp ) > 0 ) { char * s ; user_headers = estrdup ( tmp ) ; php_strtolower ( tmp , strlen ( tmp ) ) ; if ( ! header_init ) { strip_header ( user_headers , tmp , ""content-length:"" ) ; strip_header ( user_headers , tmp , ""content-type:"" ) ; } if ( ( s = strstr ( tmp , ""user-agent:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_USER_AGENT ; } if ( ( s = strstr ( tmp , ""host:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_HOST ; } if ( ( s = strstr ( tmp , ""from:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_FROM ; } if ( ( s = strstr ( tmp , ""authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_AUTH ; } if ( ( s = strstr ( tmp , ""content-length:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_CONTENT_LENGTH ; } if ( ( s = strstr ( tmp , ""content-type:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_TYPE ; } if ( ( s = strstr ( tmp , ""connection:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_CONNECTION ; } if ( use_proxy && use_ssl && ( s = strstr ( tmp , ""proxy-authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { char * p = s + sizeof ( ""proxy-authorization:"" ) - 1 ; while ( s > tmp && ( * ( s - 1 ) == '<S2SV_blank>' || * ( s - 1 ) == '\\t' ) ) s -- ; while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; while ( * p == '\\r' || * p == '\\n' ) p ++ ; if ( * p == 0 ) { if ( s == tmp ) { efree ( user_headers ) ; user_headers = NULL ; } else { while ( s > tmp && ( * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' ) ) s -- ; user_headers [ s - tmp ] = 0 ; } } else { memmove ( user_headers + ( s - tmp ) , user_headers + ( p - tmp ) , strlen ( p ) + 1 ) ; } } } if ( tmp ) { efree ( tmp ) ; } } if ( ( ( have_header & HTTP_HEADER_AUTH ) == 0 ) && resource -> user ) { php_url_decode ( resource -> user , strlen ( resource -> user ) ) ; strcpy ( scratch , resource -> user ) ; strcat ( scratch , "":"" ) ; if ( resource -> pass ) { php_url_decode ( resource -> pass , strlen ( resource -> pass ) ) ; strcat ( scratch , resource -> pass ) ; } tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ; if ( snprintf ( scratch , scratch_len , ""Authorization:<S2SV_blank>Basic<S2SV_blank>%s\\r\\n"" , tmp ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ; } efree ( tmp ) ; tmp = NULL ; } if ( ( ( have_header & HTTP_HEADER_FROM ) == 0 ) && FG ( from_address ) ) { if ( snprintf ( scratch , scratch_len , ""From:<S2SV_blank>%s\\r\\n"" , FG ( from_address ) ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) { if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) { if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s:%i\\r\\n"" , resource -> host , resource -> port ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } else { if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s\\r\\n"" , resource -> host ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } } } if ( ( have_header & HTTP_HEADER_CONNECTION ) == 0 ) { php_stream_write_string ( stream , ""Connection:<S2SV_blank>close\\r\\n"" ) ; } if ( context && php_stream_context_get_option ( context , ""http"" , ""user_agent"" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) { ua_str = Z_STRVAL_PP ( ua_zval ) ; } else if ( FG ( user_agent ) ) { ua_str = FG ( user_agent ) ; } if ( ( ( have_header & HTTP_HEADER_USER_AGENT ) == 0 ) && ua_str ) { # define _UA_HEADER ""User-Agent:<S2SV_blank>%s\\r\\n"" char * ua ; size_t ua_len ; ua_len = sizeof ( _UA_HEADER ) + strlen ( ua_str ) ; if ( ua_len > sizeof ( _UA_HEADER ) ) { ua = emalloc ( ua_len + 1 ) ; if ( ( ua_len = slprintf ( ua , ua_len , _UA_HEADER , ua_str ) ) > 0 ) { ua [ ua_len ] = 0 ; php_stream_write ( stream , ua , ua_len ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Cannot<S2SV_blank>construct<S2SV_blank>User-agent<S2SV_blank>header"" ) ; } if ( ua ) { efree ( ua ) ; } } } if ( user_headers ) { if ( header_init && context && ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\r\\n"" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; have_header |= HTTP_HEADER_CONTENT_LENGTH ; } php_stream_write ( stream , user_headers , strlen ( user_headers ) ) ; php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; efree ( user_headers ) ; } if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) ) { scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\r\\n"" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; } if ( ! ( have_header & HTTP_HEADER_TYPE ) ) { php_stream_write ( stream , ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" , sizeof ( ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ) - 1 ) ; php_error_docref ( NULL TSRMLS_CC , E_NOTICE , ""Content-type<S2SV_blank>not<S2SV_blank>specified<S2SV_blank>assuming<S2SV_blank>application/x-www-form-urlencoded"" ) ; } php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; php_stream_write ( stream , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; } location [ 0 ] = '\\0' ; if ( ! EG ( active_symbol_table ) ) { zend_rebuild_symbol_table ( TSRMLS_C ) ; } if ( header_init ) { zval * ztmp ; MAKE_STD_ZVAL ( ztmp ) ; array_init ( ztmp ) ; ZEND_SET_SYMBOL ( EG ( active_symbol_table ) , ""http_response_header"" , ztmp ) ; } { zval * * rh ; if ( zend_hash_find ( EG ( active_symbol_table ) , ""http_response_header"" , sizeof ( ""http_response_header"" ) , ( void * * ) & rh ) != SUCCESS || Z_TYPE_PP ( rh ) != IS_ARRAY ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>http_response_header<S2SV_blank>overwritten"" ) ; goto out ; } response_header = * rh ; Z_ADDREF_P ( response_header ) ; } if ( ! php_stream_eof ( stream ) ) { size_t tmp_line_len ; if ( php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL ) { zval * http_response ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } if ( context && SUCCESS == php_stream_context_get_option ( context , ""http"" , ""ignore_errors"" , & tmpzval ) ) { ignore_errors = zend_is_true ( * tmpzval ) ; } if ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) { reqok = 1 ; } if ( response_code >= 100 && response_code < 200 ) { while ( ! php_stream_eof ( stream ) && php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL && ( tmp_line_len < sizeof ( ""HTTP/1"" ) - 1 || strncasecmp ( tmp_line , ""HTTP/1"" , sizeof ( ""HTTP/1"" ) - 1 ) ) ) ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } } if ( response_code >= 200 && response_code < 400 ) { reqok = 1 ; } else { switch ( response_code ) { case 403 : php_stream_notify_error ( context , PHP_STREAM_NOTIFY_AUTH_RESULT , tmp_line , response_code ) ; break ; default : if ( ! tmp_line_len ) { tmp_line [ 0 ] = '\\0' ; } php_stream_notify_error ( context , PHP_STREAM_NOTIFY_FAILURE , tmp_line , response_code ) ; } } <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) { <S2SV_EndBug> -- tmp_line_len ; <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) { <S2SV_EndBug> -- tmp_line_len ; } } MAKE_STD_ZVAL ( http_response ) ; ZVAL_STRINGL ( http_response , tmp_line , tmp_line_len , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_response , sizeof ( zval * ) , NULL ) ; } } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>socket!"" ) ; goto out ; } http_header_line = emalloc ( HTTP_HEADER_BLOCK_SIZE ) ; while ( ! body && ! php_stream_eof ( stream ) ) { size_t http_header_line_length ; if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) && * http_header_line != '\\n' && * http_header_line != '\\r' ) { char * e = http_header_line + http_header_line_length - 1 ; if ( * e != '\\n' ) { do { if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>HTTP<S2SV_blank>headers"" ) ; goto out ; } e = http_header_line + http_header_line_length - 1 ; } while ( * e != '\\n' ) ; continue ; } while ( * e == '\\n' || * e == '\\r' ) { e -- ; } http_header_line_length = e - http_header_line + 1 ; http_header_line [ http_header_line_length ] = '\\0' ; if ( ! strncasecmp ( http_header_line , ""Location:<S2SV_blank>"" , 10 ) ) { if ( context && php_stream_context_get_option ( context , ""http"" , ""follow_location"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; follow_location = Z_LVAL_PP ( tmpzval ) ; } else if ( ! ( response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code ) ) { follow_location = 0 ; } strlcpy ( location , http_header_line + 10 , sizeof ( location ) ) ; } else if ( ! strncasecmp ( http_header_line , ""Content-Type:<S2SV_blank>"" , 14 ) ) { php_stream_notify_info ( context , PHP_STREAM_NOTIFY_MIME_TYPE_IS , http_header_line + 14 , 0 ) ; } else if ( ! strncasecmp ( http_header_line , ""Content-Length:<S2SV_blank>"" , 16 ) ) { file_size = atoi ( http_header_line + 16 ) ; php_stream_notify_file_size ( context , file_size , http_header_line , 0 ) ; } else if ( ! strncasecmp ( http_header_line , ""Transfer-Encoding:<S2SV_blank>chunked"" , sizeof ( ""Transfer-Encoding:<S2SV_blank>chunked"" ) ) ) { if ( ! ( options & STREAM_ONLY_GET_HEADERS ) ) { long decode = 1 ; if ( context && php_stream_context_get_option ( context , ""http"" , ""auto_decode"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_boolean ( * tmpzval ) ; decode = Z_LVAL_PP ( tmpzval ) ; } if ( decode ) { transfer_encoding = php_stream_filter_create ( ""dechunk"" , NULL , php_stream_is_persistent ( stream ) TSRMLS_CC ) ; if ( transfer_encoding ) { continue ; } } } } if ( http_header_line [ 0 ] == '\\0' ) { body = 1 ; } else { zval * http_header ; MAKE_STD_ZVAL ( http_header ) ; ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ; } } else { break ; } } if ( ! reqok || ( location [ 0 ] != '\\0' && follow_location ) ) { if ( ! follow_location || ( ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) && redirect_max <= 1 ) ) { goto out ; } if ( location [ 0 ] != '\\0' ) php_stream_notify_info ( context , PHP_STREAM_NOTIFY_REDIRECTED , location , 0 ) ; php_stream_close ( stream ) ; stream = NULL ; if ( location [ 0 ] != '\\0' ) { char new_path [ HTTP_HEADER_BLOCK_SIZE ] ; char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ; * new_path = '\\0' ; if ( strlen ( location ) < 8 || ( strncasecmp ( location , ""http://"" , sizeof ( ""http://"" ) - 1 ) && strncasecmp ( location , ""https://"" , sizeof ( ""https://"" ) - 1 ) && strncasecmp ( location , ""ftp://"" , sizeof ( ""ftp://"" ) - 1 ) && strncasecmp ( location , ""ftps://"" , sizeof ( ""ftps://"" ) - 1 ) ) ) { if ( * location != '/' ) { if ( * ( location + 1 ) != '\\0' && resource -> path ) { char * s = strrchr ( resource -> path , '/' ) ; if ( ! s ) { s = resource -> path ; if ( ! s [ 0 ] ) { efree ( s ) ; s = resource -> path = estrdup ( ""/"" ) ; } else { * s = '/' ; } } s [ 1 ] = '\\0' ; if ( resource -> path && * ( resource -> path ) == '/' && * ( resource -> path + 1 ) == '\\0' ) { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s%s"" , resource -> path , location ) ; } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s/%s"" , resource -> path , location ) ; } } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""/%s"" , location ) ; } } else { strlcpy ( loc_path , location , sizeof ( loc_path ) ) ; } if ( ( use_ssl && resource -> port != 443 ) || ( ! use_ssl && resource -> port != 80 ) ) { snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s:%d%s"" , resource -> scheme , resource -> host , resource -> port , loc_path ) ; } else { snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s%s"" , resource -> scheme , resource -> host , loc_path ) ; } } else { strlcpy ( new_path , location , sizeof ( new_path ) ) ; } php_url_free ( resource ) ; if ( ( resource = php_url_parse ( new_path ) ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } <S2SV_StartBug> # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } s ++ ; } } } <S2SV_EndBug> if ( strncasecmp ( new_path , ""http://"" , sizeof ( ""http://"" ) - 1 ) || strncasecmp ( new_path , ""https://"" , sizeof ( ""https://"" ) - 1 ) ) { CHECK_FOR_CNTRL_CHARS ( resource -> user ) CHECK_FOR_CNTRL_CHARS ( resource -> pass ) CHECK_FOR_CNTRL_CHARS ( resource -> path ) } stream = php_stream_url_wrap_http_ex ( wrapper , new_path , mode , options , opened_path , context , -- redirect_max , HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC ) ; } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed!<S2SV_blank>%s"" , tmp_line ) ; } } out : if ( protocol_version ) { efree ( protocol_version ) ; } if ( http_header_line ) { efree ( http_header_line ) ; } if ( scratch ) { efree ( scratch ) ; } if ( resource ) { php_url_free ( resource ) ; } if ( stream ) { if ( header_init ) { stream -> wrapperdata = response_header ; } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } } php_stream_notify_progress_init ( context , 0 , file_size ) ; if ( options & STREAM_WILL_CAST ) php_stream_set_chunk_size ( stream , chunk_size ) ; stream -> flags |= eol_detect ; stream -> position = 0 ; strlcpy ( stream -> mode , mode , sizeof ( stream -> mode ) ) ; if ( transfer_encoding ) { php_stream_filter_append ( & stream -> readfilters , transfer_encoding ) ; } } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } if ( transfer_encoding ) { php_stream_filter_free ( transfer_encoding TSRMLS_CC ) ; } } return stream ; }
","<S2SV_ModStart> } if ( tmp_line_len >= 1 && <S2SV_ModStart> ; if ( tmp_line_len >= 1 && <S2SV_ModStart> ; } } \\\n} <S2SV_ModEnd> if ( strncasecmp
",php@php-src/523f230c831d7b33353203fa34aee4e92ac12bba,CVE-2018-7584,https://github.com/php/php-src/commit/523f230c831d7b33353203fa34aee4e92ac12bba,2018-03-01T19:29Z,"<S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) { <S2SV_EndBug> <S2SV_StartBug> # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } s ++ ; } } } <S2SV_EndBug>"
3664,CWE-190,"opj_image_t * bmptoimage ( const char * filename , opj_cparameters_t * parameters ) { opj_image_cmptparm_t cmptparm [ 4 ] ; OPJ_UINT8 lut_R [ 256 ] , lut_G [ 256 ] , lut_B [ 256 ] ; OPJ_UINT8 const * pLUT [ 3 ] ; opj_image_t * image = NULL ; FILE * IN ; OPJ_BITMAPFILEHEADER File_h ; OPJ_BITMAPINFOHEADER Info_h ; OPJ_UINT32 i , palette_len , numcmpts = 1U ; OPJ_BOOL l_result = OPJ_FALSE ; OPJ_UINT8 * pData = NULL ; OPJ_UINT32 stride ; pLUT [ 0 ] = lut_R ; pLUT [ 1 ] = lut_G ; pLUT [ 2 ] = lut_B ; IN = fopen ( filename , ""rb"" ) ; if ( ! IN ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>!!\\n"" , filename ) ; return NULL ; } if ( ! bmp_read_file_header ( IN , & File_h ) ) { fclose ( IN ) ; return NULL ; } if ( ! bmp_read_info_header ( IN , & Info_h ) ) { fclose ( IN ) ; return NULL ; } if ( Info_h . biBitCount <= 8U ) { memset ( & lut_R [ 0 ] , 0 , sizeof ( lut_R ) ) ; memset ( & lut_G [ 0 ] , 0 , sizeof ( lut_G ) ) ; memset ( & lut_B [ 0 ] , 0 , sizeof ( lut_B ) ) ; palette_len = Info_h . biClrUsed ; if ( ( palette_len == 0U ) && ( Info_h . biBitCount <= 8U ) ) { palette_len = ( 1U << Info_h . biBitCount ) ; } if ( palette_len > 256U ) { palette_len = 256U ; } if ( palette_len > 0U ) { OPJ_UINT8 has_color = 0U ; for ( i = 0U ; i < palette_len ; i ++ ) { lut_B [ i ] = ( OPJ_UINT8 ) getc ( IN ) ; lut_G [ i ] = ( OPJ_UINT8 ) getc ( IN ) ; lut_R [ i ] = ( OPJ_UINT8 ) getc ( IN ) ; ( void ) getc ( IN ) ; has_color |= ( lut_B [ i ] ^ lut_G [ i ] ) | ( lut_G [ i ] ^ lut_R [ i ] ) ; } if ( has_color ) { numcmpts = 3U ; } } } else { numcmpts = 3U ; if ( ( Info_h . biCompression == 3 ) && ( Info_h . biAlphaMask != 0U ) ) { numcmpts ++ ; } } <S2SV_StartBug> stride = ( ( Info_h . biWidth * Info_h . biBitCount + 31U ) / 32U ) * 4U ; <S2SV_EndBug> <S2SV_StartBug> if ( Info_h . biBitCount == 4 && Info_h . biCompression == 2 ) { <S2SV_EndBug> stride = ( ( Info_h . biWidth * 8U + 31U ) / 32U ) * 4U ; } <S2SV_StartBug> pData = ( OPJ_UINT8 * ) calloc ( 1 , stride * Info_h . biHeight * sizeof ( OPJ_UINT8 ) ) ; <S2SV_EndBug> if ( pData == NULL ) { fclose ( IN ) ; return NULL ; } fseek ( IN , 0 , SEEK_SET ) ; fseek ( IN , ( long ) File_h . bfOffBits , SEEK_SET ) ; switch ( Info_h . biCompression ) { case 0 : case 3 : l_result = bmp_read_raw_data ( IN , pData , stride , Info_h . biWidth , Info_h . biHeight ) ; break ; case 1 : l_result = bmp_read_rle8_data ( IN , pData , stride , Info_h . biWidth , Info_h . biHeight ) ; break ; case 2 : l_result = bmp_read_rle4_data ( IN , pData , stride , Info_h . biWidth , Info_h . biHeight ) ; break ; default : fprintf ( stderr , ""Unsupported<S2SV_blank>BMP<S2SV_blank>compression\\n"" ) ; l_result = OPJ_FALSE ; break ; } if ( ! l_result ) { free ( pData ) ; fclose ( IN ) ; return NULL ; } memset ( & cmptparm [ 0 ] , 0 , sizeof ( cmptparm ) ) ; for ( i = 0 ; i < 4U ; i ++ ) { cmptparm [ i ] . prec = 8 ; cmptparm [ i ] . bpp = 8 ; cmptparm [ i ] . sgnd = 0 ; cmptparm [ i ] . dx = ( OPJ_UINT32 ) parameters -> subsampling_dx ; cmptparm [ i ] . dy = ( OPJ_UINT32 ) parameters -> subsampling_dy ; cmptparm [ i ] . w = Info_h . biWidth ; cmptparm [ i ] . h = Info_h . biHeight ; } image = opj_image_create ( numcmpts , & cmptparm [ 0 ] , ( numcmpts == 1U ) ? OPJ_CLRSPC_GRAY : OPJ_CLRSPC_SRGB ) ; if ( ! image ) { fclose ( IN ) ; free ( pData ) ; return NULL ; } if ( numcmpts == 4U ) { image -> comps [ 3 ] . alpha = 1 ; } image -> x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; image -> y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; image -> x1 = image -> x0 + ( Info_h . biWidth - 1U ) * ( OPJ_UINT32 ) parameters -> subsampling_dx + 1U ; image -> y1 = image -> y0 + ( Info_h . biHeight - 1U ) * ( OPJ_UINT32 ) parameters -> subsampling_dy + 1U ; if ( Info_h . biBitCount == 24 && Info_h . biCompression == 0 ) { bmp24toimage ( pData , stride , image ) ; } else if ( Info_h . biBitCount == 8 && Info_h . biCompression == 0 ) { bmp8toimage ( pData , stride , image , pLUT ) ; } else if ( Info_h . biBitCount == 8 && Info_h . biCompression == 1 ) { bmp8toimage ( pData , stride , image , pLUT ) ; } else if ( Info_h . biBitCount == 4 && Info_h . biCompression == 2 ) { bmp8toimage ( pData , stride , image , pLUT ) ; } else if ( Info_h . biBitCount == 32 && Info_h . biCompression == 0 ) { bmpmask32toimage ( pData , stride , image , 0x00FF0000U , 0x0000FF00U , 0x000000FFU , 0x00000000U ) ; } else if ( Info_h . biBitCount == 32 && Info_h . biCompression == 3 ) { bmpmask32toimage ( pData , stride , image , Info_h . biRedMask , Info_h . biGreenMask , Info_h . biBlueMask , Info_h . biAlphaMask ) ; } else if ( Info_h . biBitCount == 16 && Info_h . biCompression == 0 ) { bmpmask16toimage ( pData , stride , image , 0x7C00U , 0x03E0U , 0x001FU , 0x0000U ) ; } else if ( Info_h . biBitCount == 16 && Info_h . biCompression == 3 ) { if ( ( Info_h . biRedMask == 0U ) && ( Info_h . biGreenMask == 0U ) && ( Info_h . biBlueMask == 0U ) ) { Info_h . biRedMask = 0xF800U ; Info_h . biGreenMask = 0x07E0U ; Info_h . biBlueMask = 0x001FU ; } bmpmask16toimage ( pData , stride , image , Info_h . biRedMask , Info_h . biGreenMask , Info_h . biBlueMask , Info_h . biAlphaMask ) ; } else { opj_image_destroy ( image ) ; image = NULL ; fprintf ( stderr , ""Other<S2SV_blank>system<S2SV_blank>than<S2SV_blank>24<S2SV_blank>bits/pixels<S2SV_blank>or<S2SV_blank>8<S2SV_blank>bits<S2SV_blank>(no<S2SV_blank>RLE<S2SV_blank>coding)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>implemented<S2SV_blank>[%d]\\n"" , Info_h . biBitCount ) ; } free ( pData ) ; fclose ( IN ) ; return image ; }
","<S2SV_ModStart> ; } } if ( Info_h . biWidth == 0 || Info_h . biHeight == 0 ) { fclose ( IN ) ; return NULL ; } if ( Info_h . biBitCount > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> 2 ) { if ( 8 > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> 4U ; } if ( stride > ( ( OPJ_UINT32 ) - 1 ) / sizeof ( OPJ_UINT8 ) / Info_h . biHeight ) { fclose ( IN ) ; return NULL ; }
",uclouvain@openjpeg/da940424816e11d624362ce080bc026adffa26e8,CVE-2016-10507,https://github.com/uclouvain/openjpeg/commit/da940424816e11d624362ce080bc026adffa26e8,2017-08-30T09:29Z,"<S2SV_StartBug> stride = ( ( Info_h . biWidth * Info_h . biBitCount + 31U ) / 32U ) * 4U ; <S2SV_EndBug> <S2SV_StartBug> if ( Info_h . biBitCount == 4 && Info_h . biCompression == 2 ) { <S2SV_EndBug> <S2SV_StartBug> pData = ( OPJ_UINT8 * ) calloc ( 1 , stride * Info_h . biHeight * sizeof ( OPJ_UINT8 ) ) ; <S2SV_EndBug>"
1898,CWE-119,"static void temporal_filter_iterate_c ( VP9_COMP * cpi , <S2SV_StartBug> int frame_count , <S2SV_EndBug> int alt_ref_index , int strength , struct scale_factors * scale ) { int byte ; int frame ; int mb_col , mb_row ; unsigned int filter_weight ; <S2SV_StartBug> int mb_cols = cpi -> common . mb_cols ; <S2SV_EndBug> <S2SV_StartBug> int mb_rows = cpi -> common . mb_rows ; <S2SV_EndBug> int mb_y_offset = 0 ; int mb_uv_offset = 0 ; <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned int , accumulator , 16 * 16 * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint16_t , count , 16 * 16 * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * mbd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> YV12_BUFFER_CONFIG * f = cpi -> frames [ alt_ref_index ] ; <S2SV_EndBug> uint8_t * dst1 , * dst2 ; <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , predictor , 16 * 16 * 3 ) ; <S2SV_EndBug> const int mb_uv_height = 16 >> mbd -> plane [ 1 ] . subsampling_y ; <S2SV_StartBug> uint8_t * input_buffer [ MAX_MB_PLANE ] ; <S2SV_EndBug> int i ; <S2SV_StartBug> assert ( mbd -> plane [ 1 ] . subsampling_x == mbd -> plane [ 1 ] . subsampling_y ) ; <S2SV_EndBug> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) input_buffer [ i ] = mbd -> plane [ i ] . pre [ 0 ] . buf ; for ( mb_row = 0 ; mb_row < mb_rows ; mb_row ++ ) { <S2SV_StartBug> # if ALT_REF_MC_ENABLED <S2SV_EndBug> cpi -> mb . mv_row_min = - ( ( mb_row * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ; <S2SV_StartBug> cpi -> mb . mv_row_max = ( ( cpi -> common . mb_rows - 1 - mb_row ) * 16 ) <S2SV_EndBug> + ( 17 - 2 * VP9_INTERP_EXTEND ) ; <S2SV_StartBug> # endif <S2SV_EndBug> for ( mb_col = 0 ; mb_col < mb_cols ; mb_col ++ ) { int i , j , k ; int stride ; <S2SV_StartBug> vpx_memset ( accumulator , 0 , 16 * 16 * 3 * sizeof ( accumulator [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( count , 0 , 16 * 16 * 3 * sizeof ( count [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> # if ALT_REF_MC_ENABLED <S2SV_EndBug> cpi -> mb . mv_col_min = - ( ( mb_col * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ; <S2SV_StartBug> cpi -> mb . mv_col_max = ( ( cpi -> common . mb_cols - 1 - mb_col ) * 16 ) <S2SV_EndBug> + ( 17 - 2 * VP9_INTERP_EXTEND ) ; <S2SV_StartBug> # endif <S2SV_EndBug> for ( frame = 0 ; frame < frame_count ; frame ++ ) { <S2SV_StartBug> if ( cpi -> frames [ frame ] == NULL ) <S2SV_EndBug> continue ; mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row = 0 ; mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col = 0 ; if ( frame == alt_ref_index ) { filter_weight = 2 ; } else { <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> # if ALT_REF_MC_ENABLED # define THRESH_LOW 10000 # define THRESH_HIGH 20000 err = temporal_filter_find_matching_mb_c ( cpi , <S2SV_StartBug> cpi -> frames [ alt_ref_index ] -> y_buffer + mb_y_offset , <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ frame ] -> y_buffer + mb_y_offset , <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ frame ] -> y_stride ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> filter_weight = err < THRESH_LOW <S2SV_EndBug> <S2SV_StartBug> ? 2 : err < THRESH_HIGH ? 1 : 0 ; <S2SV_EndBug> } if ( filter_weight != 0 ) { temporal_filter_predictors_mb_c ( mbd , <S2SV_StartBug> cpi -> frames [ frame ] -> y_buffer + mb_y_offset , <S2SV_EndBug> cpi -> frames [ frame ] -> u_buffer + mb_uv_offset , cpi -> frames [ frame ] -> v_buffer + mb_uv_offset , cpi -> frames [ frame ] -> y_stride , mb_uv_height , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col , predictor , scale , mb_col * 16 , mb_row * 16 ) ; vp9_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , strength , filter_weight , accumulator , count ) ; vp9_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_height , strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_height , strength , filter_weight , accumulator + 512 , count + 512 ) ; } } dst1 = cpi -> alt_ref_buffer . y_buffer ; stride = cpi -> alt_ref_buffer . y_stride ; byte = mb_y_offset ; for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ k ] ] ; <S2SV_EndBug> pval >>= 19 ; <S2SV_StartBug> dst1 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> byte ++ ; } byte += stride - 16 ; } dst1 = cpi -> alt_ref_buffer . u_buffer ; dst2 = cpi -> alt_ref_buffer . v_buffer ; <S2SV_StartBug> stride = cpi -> alt_ref_buffer . uv_stride ; <S2SV_EndBug> byte = mb_uv_offset ; for ( i = 0 , k = 256 ; i < mb_uv_height ; i ++ ) { <S2SV_StartBug> for ( j = 0 ; j < mb_uv_height ; j ++ , k ++ ) { <S2SV_EndBug> int m = k + 256 ; unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ k ] ] ; <S2SV_EndBug> pval >>= 19 ; <S2SV_StartBug> dst1 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> pval = accumulator [ m ] + ( count [ m ] >> 1 ) ; <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ m ] ] ; <S2SV_EndBug> pval >>= 19 ; <S2SV_StartBug> dst2 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> byte ++ ; } <S2SV_StartBug> byte += stride - mb_uv_height ; <S2SV_EndBug> } <S2SV_StartBug> mb_y_offset += 16 ; <S2SV_EndBug> <S2SV_StartBug> mb_uv_offset += mb_uv_height ; <S2SV_EndBug> } mb_y_offset += 16 * ( f -> y_stride - mb_cols ) ; <S2SV_StartBug> mb_uv_offset += mb_uv_height * ( f -> uv_stride - mb_cols ) ; <S2SV_EndBug> } for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) mbd -> plane [ i ] . pre [ 0 ] . buf = input_buffer [ i ] ; }
","<S2SV_ModStart> * cpi , YV12_BUFFER_CONFIG * * frames , <S2SV_ModStart> int mb_cols = ( frames [ alt_ref_index ] -> y_crop_width + 15 ) >> 4 <S2SV_ModEnd> ; int mb_rows <S2SV_ModStart> int mb_rows = ( frames [ alt_ref_index ] -> y_crop_height + 15 ) >> 4 <S2SV_ModEnd> ; int mb_y_offset <S2SV_ModStart> = 0 ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> int , accumulator [ <S2SV_ModEnd> 16 * 16 <S2SV_ModStart> 16 * 3 ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> uint16_t , count [ <S2SV_ModEnd> 16 * 16 <S2SV_ModStart> 16 * 3 ] <S2SV_ModStart> & cpi -> td . <S2SV_ModStart> * f = <S2SV_ModEnd> frames [ alt_ref_index <S2SV_ModStart> * dst2 ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , predictor16 [ 16 * 16 * 3 ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> , uint8_t , predictor8 [ 16 * 16 * 3 ] ) ; uint8_t * predictor ; # else DECLARE_ALIGNED ( 16 , uint8_t , predictor [ <S2SV_ModEnd> 16 * 16 <S2SV_ModStart> 16 * 3 ] ) ; # endif <S2SV_ModEnd> const int mb_uv_height <S2SV_ModStart> . subsampling_y ; const int mb_uv_width = 16 >> mbd -> plane [ 1 ] . subsampling_x ; <S2SV_ModStart> int i ; # if CONFIG_VP9_HIGHBITDEPTH if <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { predictor = CONVERT_TO_BYTEPTR ( predictor16 ) ; } else { predictor = predictor8 ; } # endif <S2SV_ModEnd> for ( i <S2SV_ModStart> ++ ) { cpi -> td . <S2SV_ModEnd> mb . mv_row_min <S2SV_ModStart> ; cpi -> td . <S2SV_ModStart> = ( ( <S2SV_ModEnd> mb_rows - 1 <S2SV_ModStart> VP9_INTERP_EXTEND ) ; <S2SV_ModEnd> for ( mb_col <S2SV_ModStart> int stride ; memset <S2SV_ModEnd> ( accumulator , <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( count , <S2SV_ModStart> ) ) ; cpi -> td . <S2SV_ModEnd> mb . mv_col_min <S2SV_ModStart> ; cpi -> td . <S2SV_ModStart> = ( ( <S2SV_ModEnd> mb_cols - 1 <S2SV_ModStart> VP9_INTERP_EXTEND ) ; <S2SV_ModEnd> for ( frame <S2SV_ModStart> ++ ) { const int thresh_low = 10000 ; const int thresh_high = 20000 ; if ( <S2SV_ModEnd> frames [ frame <S2SV_ModStart> int err = <S2SV_ModEnd> temporal_filter_find_matching_mb_c ( cpi <S2SV_ModStart> ( cpi , <S2SV_ModEnd> frames [ alt_ref_index <S2SV_ModStart> + mb_y_offset , <S2SV_ModEnd> frames [ frame <S2SV_ModStart> + mb_y_offset , <S2SV_ModEnd> frames [ frame <S2SV_ModStart> y_stride ) ; <S2SV_ModEnd> filter_weight = err <S2SV_ModStart> = err < thresh_low <S2SV_ModEnd> ? 2 : <S2SV_ModStart> : err < thresh_high <S2SV_ModEnd> ? 1 : <S2SV_ModStart> ( mbd , frames [ frame ] -> y_buffer + mb_y_offset , frames [ frame ] -> u_buffer + mb_uv_offset , frames [ frame ] -> v_buffer + mb_uv_offset , frames [ frame ] -> y_stride , mb_uv_width , mb_uv_height , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col , predictor , scale , mb_col * 16 , mb_row * 16 ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { int adj_strength = strength + 2 * ( mbd -> bd - 8 ) ; vp9_highbd_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , adj_strength , filter_weight , accumulator , count ) ; vp9_highbd_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , adj_strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_highbd_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , adj_strength , filter_weight , accumulator + 512 , count + 512 ) ; } else { vp9_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , strength , filter_weight , accumulator , count ) ; vp9_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 512 , count + 512 ) ; } # else vp9_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , strength , filter_weight , accumulator , count ) ; vp9_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 512 , count + 512 ) ; # endif } } # if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { uint16_t * dst1_16 ; uint16_t * dst2_16 ; dst1 = cpi -> alt_ref_buffer . y_buffer ; dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) <S2SV_ModEnd> ; stride = <S2SV_ModStart> ; pval *= <S2SV_ModEnd> fixed_divide [ count <S2SV_ModStart> >>= 19 ; dst1_16 [ byte ] = ( uint16_t <S2SV_ModEnd> ) pval ; <S2SV_ModStart> . v_buffer ; dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) ; dst2_16 = CONVERT_TO_SHORTPTR ( dst2 ) ; <S2SV_ModStart> ; j < mb_uv_width <S2SV_ModEnd> ; j ++ <S2SV_ModStart> ; pval *= <S2SV_ModEnd> fixed_divide [ count <S2SV_ModStart> >>= 19 ; dst1_16 [ byte ] = ( uint16_t <S2SV_ModEnd> ) pval ; <S2SV_ModStart> ; pval *= <S2SV_ModEnd> fixed_divide [ count <S2SV_ModStart> >>= 19 ; dst2_16 [ byte ] = ( uint16_t <S2SV_ModEnd> ) pval ; <S2SV_ModStart> += stride - mb_uv_width ; } } else { dst1 = cpi -> alt_ref_buffer . y_buffer ; stride = cpi -> alt_ref_buffer . y_stride ; byte = mb_y_offset ; for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - 16 ; } dst1 = cpi -> alt_ref_buffer . u_buffer ; dst2 = cpi -> alt_ref_buffer . v_buffer ; stride = cpi -> alt_ref_buffer . uv_stride ; byte = mb_uv_offset ; for ( i = 0 , k = 256 ; i < mb_uv_height ; i ++ ) { for ( j = 0 ; j < mb_uv_width ; j ++ , k ++ ) { int m = k + 256 ; unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; pval = accumulator [ m ] + ( count [ m ] >> 1 ) ; pval *= fixed_divide [ count [ m ] ] ; pval >>= 19 ; dst2 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - mb_uv_width ; } } # else dst1 = cpi -> alt_ref_buffer . y_buffer ; stride = cpi -> alt_ref_buffer . y_stride ; byte = mb_y_offset ; for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - 16 ; } dst1 = cpi -> alt_ref_buffer . u_buffer ; dst2 = cpi -> alt_ref_buffer . v_buffer ; stride = cpi -> alt_ref_buffer . uv_stride ; byte = mb_uv_offset ; for ( i = 0 , k = 256 ; i < mb_uv_height ; i ++ ) { for ( j = 0 ; j < mb_uv_width ; j ++ , k ++ ) { int m = k + 256 ; unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; pval = accumulator [ m ] + ( count [ m ] >> 1 ) ; pval *= fixed_divide [ count [ m ] ] ; pval >>= 19 ; dst2 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - mb_uv_width ; } # endif <S2SV_ModEnd> mb_y_offset += 16 <S2SV_ModStart> mb_y_offset += 16 ; mb_uv_offset += mb_uv_width ; } mb_y_offset += 16 * ( f -> y_stride - mb_cols ) <S2SV_ModStart> mb_uv_offset += mb_uv_height * <S2SV_ModEnd> f -> uv_stride <S2SV_ModStart> -> uv_stride - mb_uv_width * mb_cols <S2SV_ModEnd> ; } for
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int frame_count , <S2SV_EndBug> <S2SV_StartBug> int mb_cols = cpi -> common . mb_cols ; <S2SV_EndBug> <S2SV_StartBug> int mb_rows = cpi -> common . mb_rows ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned int , accumulator , 16 * 16 * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint16_t , count , 16 * 16 * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * mbd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> YV12_BUFFER_CONFIG * f = cpi -> frames [ alt_ref_index ] ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , predictor , 16 * 16 * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> uint8_t * input_buffer [ MAX_MB_PLANE ] ; <S2SV_EndBug> <S2SV_StartBug> assert ( mbd -> plane [ 1 ] . subsampling_x == mbd -> plane [ 1 ] . subsampling_y ) ; <S2SV_EndBug> <S2SV_StartBug> # if ALT_REF_MC_ENABLED <S2SV_EndBug> <S2SV_StartBug> cpi -> mb . mv_row_max = ( ( cpi -> common . mb_rows - 1 - mb_row ) * 16 ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( accumulator , 0 , 16 * 16 * 3 * sizeof ( accumulator [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( count , 0 , 16 * 16 * 3 * sizeof ( count [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> # if ALT_REF_MC_ENABLED <S2SV_EndBug> <S2SV_StartBug> cpi -> mb . mv_col_max = ( ( cpi -> common . mb_cols - 1 - mb_col ) * 16 ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> frames [ frame ] == NULL ) <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ alt_ref_index ] -> y_buffer + mb_y_offset , <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ frame ] -> y_buffer + mb_y_offset , <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ frame ] -> y_stride ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> filter_weight = err < THRESH_LOW <S2SV_EndBug> <S2SV_StartBug> ? 2 : err < THRESH_HIGH ? 1 : 0 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ frame ] -> y_buffer + mb_y_offset , <S2SV_EndBug> <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ k ] ] ; <S2SV_EndBug> <S2SV_StartBug> dst1 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> <S2SV_StartBug> stride = cpi -> alt_ref_buffer . uv_stride ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < mb_uv_height ; j ++ , k ++ ) { <S2SV_EndBug> <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ k ] ] ; <S2SV_EndBug> <S2SV_StartBug> dst1 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ m ] ] ; <S2SV_EndBug> <S2SV_StartBug> dst2 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> <S2SV_StartBug> byte += stride - mb_uv_height ; <S2SV_EndBug> <S2SV_StartBug> mb_y_offset += 16 ; <S2SV_EndBug> <S2SV_StartBug> mb_uv_offset += mb_uv_height ; <S2SV_EndBug> <S2SV_StartBug> mb_uv_offset += mb_uv_height * ( f -> uv_stride - mb_cols ) ; <S2SV_EndBug>"
1091,CWE-358,"static void DefragTrackerInit ( DefragTracker * dt , Packet * p ) { COPY_ADDRESS ( & p -> src , & dt -> src_addr ) ; COPY_ADDRESS ( & p -> dst , & dt -> dst_addr ) ; if ( PKT_IS_IPV4 ( p ) ) { dt -> id = ( int32_t ) IPV4_GET_IPID ( p ) ; dt -> af = AF_INET ; } else { dt -> id = ( int32_t ) IPV6_EXTHDR_GET_FH_ID ( p ) ; dt -> af = AF_INET6 ; } <S2SV_StartBug> dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ; <S2SV_EndBug> dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ; dt -> policy = DefragGetOsPolicy ( p ) ; dt -> host_timeout = DefragPolicyGetHostTimeout ( p ) ; dt -> remove = 0 ; dt -> seen_last = 0 ; TAILQ_INIT ( & dt -> frags ) ; ( void ) DefragTrackerIncrUsecnt ( dt ) ; }
","<S2SV_ModStart> } dt -> proto = IP_GET_IPPROTO ( p ) ; dt ->
",inliniac@suricata/4a04f814b15762eb446a5ead4d69d021512df6f8,CVE-2017-7177,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,2017-03-18T20:59Z,<S2SV_StartBug> dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ; <S2SV_EndBug>
3784,CWE-416,"void comps_objrtree_unite ( COMPS_ObjRTree * rt1 , COMPS_ObjRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data != NULL ) { comps_objrtree_set ( rt1 , pair -> key , ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
","<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair
",rpm-software-management@libcomps/e3a5d056633677959ad924a51758876d415e7046,CVE-2019-3817,https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046,2019-03-27T13:29Z,<S2SV_StartBug> char added ; <S2SV_EndBug>
2232,CWE-264,"static int ovl_fill_super ( struct super_block * sb , void * data , int silent ) { struct path lowerpath ; struct path upperpath ; struct path workpath ; struct inode * root_inode ; struct dentry * root_dentry ; struct ovl_entry * oe ; struct ovl_fs * ufs ; struct kstatfs statfs ; int err ; err = - ENOMEM ; ufs = kzalloc ( sizeof ( struct ovl_fs ) , GFP_KERNEL ) ; if ( ! ufs ) goto out ; err = ovl_parse_opt ( ( char * ) data , & ufs -> config ) ; if ( err ) goto out_free_config ; err = - EINVAL ; if ( ! ufs -> config . upperdir || ! ufs -> config . lowerdir || ! ufs -> config . workdir ) { pr_err ( ""overlayfs:<S2SV_blank>missing<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir\\n"" ) ; goto out_free_config ; } err = - ENOMEM ; oe = ovl_alloc_entry ( ) ; if ( oe == NULL ) goto out_free_config ; err = ovl_mount_dir ( ufs -> config . upperdir , & upperpath ) ; if ( err ) goto out_free_oe ; err = ovl_mount_dir ( ufs -> config . lowerdir , & lowerpath ) ; if ( err ) goto out_put_upperpath ; err = ovl_mount_dir ( ufs -> config . workdir , & workpath ) ; if ( err ) goto out_put_lowerpath ; err = - EINVAL ; if ( ! S_ISDIR ( upperpath . dentry -> d_inode -> i_mode ) || ! S_ISDIR ( lowerpath . dentry -> d_inode -> i_mode ) || ! S_ISDIR ( workpath . dentry -> d_inode -> i_mode ) ) { pr_err ( ""overlayfs:<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir<S2SV_blank>not<S2SV_blank>a<S2SV_blank>directory\\n"" ) ; goto out_put_workpath ; } if ( upperpath . mnt != workpath . mnt ) { pr_err ( ""overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>reside<S2SV_blank>under<S2SV_blank>the<S2SV_blank>same<S2SV_blank>mount\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_workdir_ok ( workpath . dentry , upperpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>be<S2SV_blank>separate<S2SV_blank>subtrees\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( upperpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>upperdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( lowerpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>lowerdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto out_put_workpath ; } err = vfs_statfs ( & lowerpath , & statfs ) ; if ( err ) { pr_err ( ""overlayfs:<S2SV_blank>statfs<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>lowerpath\\n"" ) ; goto out_put_workpath ; } ufs -> lower_namelen = statfs . f_namelen ; <S2SV_StartBug> ufs -> upper_mnt = clone_private_mount ( & upperpath ) ; <S2SV_EndBug> err = PTR_ERR ( ufs -> upper_mnt ) ; if ( IS_ERR ( ufs -> upper_mnt ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>upperpath\\n"" ) ; goto out_put_workpath ; } ufs -> lower_mnt = clone_private_mount ( & lowerpath ) ; err = PTR_ERR ( ufs -> lower_mnt ) ; if ( IS_ERR ( ufs -> lower_mnt ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>lowerpath\\n"" ) ; goto out_put_upper_mnt ; } ufs -> workdir = ovl_workdir_create ( ufs -> upper_mnt , workpath . dentry ) ; err = PTR_ERR ( ufs -> workdir ) ; if ( IS_ERR ( ufs -> workdir ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>directory<S2SV_blank>%s/%s\\n"" , ufs -> config . workdir , OVL_WORKDIR_NAME ) ; goto out_put_lower_mnt ; } ufs -> lower_mnt -> mnt_flags |= MNT_READONLY ; if ( ufs -> upper_mnt -> mnt_sb -> s_flags & MS_RDONLY ) sb -> s_flags |= MS_RDONLY ; sb -> s_d_op = & ovl_dentry_operations ; err = - ENOMEM ; root_inode = ovl_new_inode ( sb , S_IFDIR , oe ) ; if ( ! root_inode ) goto out_put_workdir ; root_dentry = d_make_root ( root_inode ) ; if ( ! root_dentry ) goto out_put_workdir ; mntput ( upperpath . mnt ) ; mntput ( lowerpath . mnt ) ; path_put ( & workpath ) ; oe -> __upperdentry = upperpath . dentry ; oe -> lowerdentry = lowerpath . dentry ; root_dentry -> d_fsdata = oe ; sb -> s_magic = OVERLAYFS_SUPER_MAGIC ; sb -> s_op = & ovl_super_operations ; sb -> s_root = root_dentry ; sb -> s_fs_info = ufs ; return 0 ; out_put_workdir : dput ( ufs -> workdir ) ; out_put_lower_mnt : mntput ( ufs -> lower_mnt ) ; out_put_upper_mnt : mntput ( ufs -> upper_mnt ) ; out_put_workpath : path_put ( & workpath ) ; out_put_lowerpath : path_put ( & lowerpath ) ; out_put_upperpath : path_put ( & upperpath ) ; out_free_oe : kfree ( oe ) ; out_free_config : kfree ( ufs -> config . lowerdir ) ; kfree ( ufs -> config . upperdir ) ; kfree ( ufs -> config . workdir ) ; kfree ( ufs ) ; out : return err ; }
","<S2SV_ModStart> . f_namelen ; sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_put_workpath ; }
",torvalds@linux/69c433ed2ecd2d3264efd7afec4439524b319121,CVE-2014-9922,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,2017-04-04T05:59Z,<S2SV_StartBug> ufs -> upper_mnt = clone_private_mount ( & upperpath ) ; <S2SV_EndBug>
1780,CWE-119,"void vp9_twopass_postencode_update ( VP9_COMP * cpi ) { <S2SV_StartBug> # ifdef DISABLE_RC_LONG_TERM_MEM <S2SV_EndBug> const uint64_t bits_used = cpi -> rc . this_frame_target ; # else const uint64_t bits_used = cpi -> rc . projected_frame_size ; # endif cpi -> twopass . bits_left -= bits_used ; cpi -> twopass . bits_left = MAX ( cpi -> twopass . bits_left , 0 ) ; <S2SV_StartBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_EndBug> cpi -> twopass . kf_group_bits += cpi -> rc . this_frame_target - bits_used ; } else { cpi -> twopass . kf_group_bits -= bits_used ; <S2SV_StartBug> cpi -> twopass . gf_group_bits -= bits_used ; <S2SV_EndBug> <S2SV_StartBug> cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> cpi -> twopass . kf_group_bits = MAX ( cpi -> twopass . kf_group_bits , 0 ) ; }
","<S2SV_ModStart> cpi ) { TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc ; const int bits_used = rc -> base_frame_target ; rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ; twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ; if ( rc -> total_actual_bits ) { rc -> rate_error_estimate = ( int ) ( ( rc -> vbr_bits_off_target * 100 ) / rc -> total_actual_bits ) ; rc -> rate_error_estimate = clamp ( rc -> rate_error_estimate , - 100 , 100 ) ; } else { rc -> rate_error_estimate = 0 ; } <S2SV_ModEnd> if ( cpi <S2SV_ModStart> common . frame_type != KEY_FRAME && ! vp9_is_upper_layer_key_frame ( cpi ) ) { twopass -> <S2SV_ModEnd> kf_group_bits -= bits_used <S2SV_ModStart> -= bits_used ; twopass -> last_kfgroup_zeromotion_pct = twopass -> kf_zeromotion_pct ; } twopass -> kf_group_bits <S2SV_ModEnd> = MAX ( <S2SV_ModStart> = MAX ( twopass -> kf_group_bits <S2SV_ModEnd> , 0 ) <S2SV_ModStart> 0 ) ; ++ twopass -> gf_group . index ; if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) && ! cpi -> rc . is_src_frame_alt_ref ) { const int maxq_adj_limit = rc -> worst_quality - twopass -> active_worst_quality ; const int minq_adj_limit = ( cpi -> oxcf . rc_mode == VPX_CQ ? MINQ_ADJ_LIMIT_CQ : MINQ_ADJ_LIMIT ) ; if ( rc -> rate_error_estimate > cpi -> oxcf . under_shoot_pct ) { -- twopass -> extend_maxq ; if ( rc -> rolling_target_bits >= rc -> rolling_actual_bits ) ++ twopass -> extend_minq ; } else if ( rc -> rate_error_estimate < - cpi -> oxcf . over_shoot_pct ) { -- twopass -> extend_minq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) ++ twopass -> extend_maxq ; } else { if ( rc -> projected_frame_size > ( 2 * rc -> base_frame_target ) && rc -> projected_frame_size > ( 2 * rc -> avg_frame_bandwidth ) ) ++ twopass -> extend_maxq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) -- twopass -> extend_minq ; else if ( rc -> rolling_target_bits > rc -> rolling_actual_bits ) -- twopass -> extend_maxq ; } twopass -> extend_minq = clamp ( twopass -> extend_minq , 0 , minq_adj_limit ) ; twopass -> extend_maxq = clamp ( twopass -> extend_maxq , 0 , maxq_adj_limit ) ; if ( ! frame_is_kf_gf_arf ( cpi ) && ! cpi -> rc . is_src_frame_alt_ref ) { int fast_extra_thresh = rc -> base_frame_target / HIGH_UNDERSHOOT_RATIO ; if ( rc -> projected_frame_size < fast_extra_thresh ) { rc -> vbr_bits_off_target_fast += fast_extra_thresh - rc -> projected_frame_size ; rc -> vbr_bits_off_target_fast = MIN ( rc -> vbr_bits_off_target_fast , ( 4 * rc -> avg_frame_bandwidth ) ) ; if ( rc -> avg_frame_bandwidth ) { twopass -> extend_minq_fast = ( int ) ( rc -> vbr_bits_off_target_fast * 8 / rc -> avg_frame_bandwidth ) ; } twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else if ( rc -> vbr_bits_off_target_fast ) { twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else { twopass -> extend_minq_fast = 0 ; } } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> # ifdef DISABLE_RC_LONG_TERM_MEM <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> cpi -> twopass . gf_group_bits -= bits_used ; <S2SV_EndBug> <S2SV_StartBug> cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
3737,CWE-415,"int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; int err = 0 ; if ( ! asoc ) <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
","<S2SV_ModStart> return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY
",torvalds@linux/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,CVE-2017-6353,https://github.com/torvalds/linux/commit/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,2017-03-01T20:59Z,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug>
7627,CWE-190,"int bmp_validate ( jas_stream_t * in ) { int n ; int i ; <S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug> assert ( JAS_STREAM_MAXPUTBACK >= 2 ) ; if ( ( n = jas_stream_read ( in , ( char * ) buf , 2 ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < 2 ) { return - 1 ; } if ( buf [ 0 ] == ( BMP_MAGIC & 0xff ) && buf [ 1 ] == ( BMP_MAGIC >> 8 ) ) { return 0 ; } return - 1 ; }
","<S2SV_ModStart> int i ; jas_uchar <S2SV_ModEnd> buf [ 2
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug>
3310,CWE-20,"static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; env -> cur_state = state ; init_reg_state ( env , state -> regs ) ; state -> parent = NULL ; insn_idx = 0 ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( env , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , prev_insn_idx , insn_idx ) ; else verbose ( env , ""%d:<S2SV_blank>safe\\n"" , insn_idx ) ; } goto process_bpf_exit ; } if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , ""%d:"" , insn_idx ) ; else verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , prev_insn_idx , insn_idx ) ; print_verifier_state ( env , state ) ; do_print_state = false ; } if ( env -> log . level ) { verbose ( env , ""%d:<S2SV_blank>"" , insn_idx ) ; print_bpf_insn ( verbose , env , insn , env -> allow_ptr_leaks ) ; } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; if ( err ) return err ; regs = cur_regs ( env ) ; <S2SV_StartBug> if ( class == BPF_ALU || class == BPF_ALU64 ) { <S2SV_EndBug> err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( src_reg_type != * prev_src_type && ( src_reg_type == PTR_TO_CTX || * prev_src_type == PTR_TO_CTX ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , insn_idx , insn ) ; if ( err ) return err ; insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( dst_reg_type != * prev_dst_type && ( dst_reg_type == PTR_TO_CTX || * prev_dst_type == PTR_TO_CTX ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_call ( env , insn -> imm , insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( env , ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - EACCES ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & prev_insn_idx , & insn_idx ) ; if ( err < 0 ) { if ( err != - ENOENT ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; <S2SV_StartBug> } else { <S2SV_EndBug> verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } } else { verbose ( env , ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , class ) ; return - EINVAL ; } insn_idx ++ ; } verbose ( env , ""processed<S2SV_blank>%d<S2SV_blank>insns,<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>%d\\n"" , insn_processed , env -> prog -> aux -> stack_depth ) ; return 0 ; }
","<S2SV_ModStart> env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;
",torvalds@linux/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,CVE-2017-17862,https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,2017-12-27T17:08Z,<S2SV_StartBug> if ( class == BPF_ALU || class == BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug>
7911,CWE-20,"error_t webSocketParseRequestLine ( WebSocket * webSocket , char_t * line ) { error_t error ; char_t * token ; char_t * p ; char_t * s ; TRACE_DEBUG ( ""%s"" , line ) ; token = osStrtok_r ( line , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; if ( osStrcasecmp ( token , ""GET"" ) ) return ERROR_INVALID_REQUEST ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; <S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug> if ( s != NULL ) { * s = '\\0' ; error = webSocketDecodePercentEncodedString ( token , webSocket -> uri , WEB_SOCKET_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; if ( osStrlen ( s + 1 ) > WEB_SOCKET_QUERY_STRING_MAX_LEN ) return ERROR_INVALID_REQUEST ; osStrcpy ( webSocket -> queryString , s + 1 ) ; } else { error = webSocketDecodePercentEncodedString ( token , webSocket -> uri , WEB_SOCKET_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; webSocket -> queryString [ 0 ] = '\\0' ; } token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) { webSocket -> handshakeContext . version = WS_HTTP_VERSION_0_9 ; webSocket -> handshakeContext . connectionClose = TRUE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.0"" ) ) { webSocket -> handshakeContext . version = WS_HTTP_VERSION_1_0 ; webSocket -> handshakeContext . connectionClose = TRUE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.1"" ) ) { webSocket -> handshakeContext . version = WS_HTTP_VERSION_1_1 ; webSocket -> handshakeContext . connectionClose = FALSE ; } else { return ERROR_INVALID_REQUEST ; } return NO_ERROR ; }
","<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug>"
2728,CWE-264,"static int <S2SV_StartBug> validate_event ( struct pmu_hw_events * hw_events , <S2SV_EndBug> struct perf_event * event ) { <S2SV_StartBug> struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_EndBug> struct hw_perf_event fake_event = event -> hw ; struct pmu * leader_pmu = event -> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1 ; <S2SV_StartBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) <S2SV_EndBug> return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ; <S2SV_StartBug> return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> int validate_event ( struct pmu * pmu , <S2SV_ModStart> arm_pmu * armpmu <S2SV_ModEnd> ; struct hw_perf_event <S2SV_ModStart> -> pmu != pmu ) return 0 ; if ( event -> pmu != <S2SV_ModStart> return 1 ; armpmu = to_arm_pmu ( event -> pmu ) ;
",torvalds@linux/8fff105e13041e49b82f92eef034f363a6b1c071,CVE-2015-8955,https://github.com/torvalds/linux/commit/8fff105e13041e49b82f92eef034f363a6b1c071,2016-10-10T10:59Z,"<S2SV_StartBug> validate_event ( struct pmu_hw_events * hw_events , <S2SV_EndBug> <S2SV_StartBug> struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) <S2SV_EndBug> <S2SV_StartBug> return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; <S2SV_EndBug>"
100,CWE-295,"static int int_x509_param_set_hosts ( X509_VERIFY_PARAM_ID * id , int mode , const char * name , size_t namelen ) { char * copy ; <S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug> return 0 ; if ( mode == SET_HOST && id -> hosts ) { string_stack_free ( id -> hosts ) ; id -> hosts = NULL ; } if ( name == NULL || namelen == 0 ) return 1 ; copy = strndup ( name , namelen ) ; if ( copy == NULL ) return 0 ; if ( id -> hosts == NULL && ( id -> hosts = sk_OPENSSL_STRING_new_null ( ) ) == NULL ) { free ( copy ) ; return 0 ; } if ( ! sk_OPENSSL_STRING_push ( id -> hosts , copy ) ) { free ( copy ) ; if ( sk_OPENSSL_STRING_num ( id -> hosts ) == 0 ) { sk_OPENSSL_STRING_free ( id -> hosts ) ; id -> hosts = NULL ; } return 0 ; } return 1 ; }
","<S2SV_ModStart> if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name
",libressl-portable@openbsd/0654414afcce51a16d35d05060190a3ec4618d42,CVE-2018-8970,https://github.com/libressl-portable/openbsd/commit/0654414afcce51a16d35d05060190a3ec4618d42,2018-03-24T21:29Z,"<S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug>"
1664,CWE-119,"<S2SV_StartBug> static void write_inter_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> assert ( is_inter_mode ( mode ) ) ; vp9_write_token ( w , vp9_inter_mode_tree , probs , & inter_mode_encodings [ INTER_OFFSET ( mode ) ] ) ; }
","<S2SV_ModStart> void write_inter_mode ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> * w , PREDICTION_MODE <S2SV_ModEnd> mode , const <S2SV_ModStart> mode , const vpx_prob <S2SV_ModEnd> * probs )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void write_inter_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug>"
3829,CWE-20,"int nfsd_dispatch ( struct svc_rqst * rqstp , __be32 * statp ) { struct svc_procedure * proc ; kxdrproc_t xdr ; __be32 nfserr ; __be32 * nfserrp ; dprintk ( ""nfsd_dispatch:<S2SV_blank>vers<S2SV_blank>%d<S2SV_blank>proc<S2SV_blank>%d\\n"" , rqstp -> rq_vers , rqstp -> rq_proc ) ; <S2SV_StartBug> proc = rqstp -> rq_procinfo ; <S2SV_EndBug> rqstp -> rq_cachetype = proc -> pc_cachetype ; xdr = proc -> pc_decode ; if ( xdr && ! xdr ( rqstp , ( __be32 * ) rqstp -> rq_arg . head [ 0 ] . iov_base , rqstp -> rq_argp ) ) { dprintk ( ""nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>arguments!\\n"" ) ; * statp = rpc_garbage_args ; return 1 ; } switch ( nfsd_cache_lookup ( rqstp ) ) { case RC_DROPIT : return 0 ; case RC_REPLY : return 1 ; case RC_DOIT : ; } nfserrp = rqstp -> rq_res . head [ 0 ] . iov_base + rqstp -> rq_res . head [ 0 ] . iov_len ; rqstp -> rq_res . head [ 0 ] . iov_len += sizeof ( __be32 ) ; nfserr = proc -> pc_func ( rqstp , rqstp -> rq_argp , rqstp -> rq_resp ) ; nfserr = map_new_errors ( rqstp -> rq_vers , nfserr ) ; if ( nfserr == nfserr_dropit || test_bit ( RQ_DROPME , & rqstp -> rq_flags ) ) { dprintk ( ""nfsd:<S2SV_blank>Dropping<S2SV_blank>request;<S2SV_blank>may<S2SV_blank>be<S2SV_blank>revisited<S2SV_blank>later\\n"" ) ; nfsd_cache_update ( rqstp , RC_NOCACHE , NULL ) ; return 0 ; } if ( rqstp -> rq_proc != 0 ) * nfserrp ++ = nfserr ; if ( ! ( nfserr && rqstp -> rq_vers == 2 ) ) { xdr = proc -> pc_encode ; if ( xdr && ! xdr ( rqstp , nfserrp , rqstp -> rq_resp ) ) { dprintk ( ""nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>result!\\n"" ) ; nfsd_cache_update ( rqstp , RC_NOCACHE , NULL ) ; * statp = rpc_system_err ; return 1 ; } } nfsd_cache_update ( rqstp , rqstp -> rq_cachetype , statp + 1 ) ; return 1 ; }
","<S2SV_ModStart> -> rq_procinfo ; if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( ""nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n"" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; }
",torvalds@linux/e6838a29ecb484c97e4efef9429643b9851fba6e,CVE-2017-7645,https://github.com/torvalds/linux/commit/e6838a29ecb484c97e4efef9429643b9851fba6e,2017-04-18T14:59Z,<S2SV_StartBug> proc = rqstp -> rq_procinfo ; <S2SV_EndBug>
1171,CWE-264,"<S2SV_StartBug> static unsigned int stack_maxrandom_size ( void ) <S2SV_EndBug> { <S2SV_StartBug> unsigned int max = 0 ; <S2SV_EndBug> if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) { <S2SV_StartBug> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <S2SV_EndBug> } return max ; }
","<S2SV_ModStart> <S2SV_null> static unsigned long <S2SV_ModEnd> stack_maxrandom_size ( void <S2SV_ModStart> ) { unsigned long <S2SV_ModEnd> max = 0 <S2SV_ModStart> ( ( - 1UL <S2SV_ModEnd> ) & STACK_RND_MASK
",torvalds@linux/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,CVE-2015-1593,https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,2015-03-16T10:59Z,<S2SV_StartBug> static unsigned int stack_maxrandom_size ( void ) <S2SV_EndBug> <S2SV_StartBug> unsigned int max = 0 ; <S2SV_EndBug> <S2SV_StartBug> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <S2SV_EndBug>
260,CWE-119,"static void scsi_write_data ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; uint32_t n ; assert ( r -> req . aiocb == NULL ) ; if ( r -> req . cmd . mode != SCSI_XFER_TO_DEV ) { DPRINTF ( ""Data<S2SV_blank>transfer<S2SV_blank>direction<S2SV_blank>invalid\\n"" ) ; scsi_write_complete ( r , - EINVAL ) ; return ; } <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> if ( n ) { if ( s -> tray_open ) { scsi_write_complete ( r , - ENOMEDIUM ) ; } <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ; r -> req . aiocb = bdrv_aio_writev ( s -> bs , r -> sector , & r -> qiov , n , scsi_write_complete , r ) ; if ( r -> req . aiocb == NULL ) { scsi_write_complete ( r , - ENOMEM ) ; } } else { scsi_write_complete ( r , 0 ) ; } }
","<S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> bdrv_acct_start ( s
",bonzini@qemu/103b40f51e4012b3b0ad20f615562a1806d7f49a,CVE-2011-3346,https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a,2014-04-01T06:35Z,"<S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug>"
2984,CWE-119,"static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; <S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = """" , direction [ 6 ] = """" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <S2SV_StartBug> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values"" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line , <S2SV_StartBug> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output"" ) ; return FALSE ; } <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , ""TEST:"" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; } else if ( strncmp ( if_name , ""PPoATM:"" , 7 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; } else if ( strncmp ( if_name , ""PPoFR:"" , 6 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; } else if ( strncmp ( if_name , ""ATM:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; } else if ( strncmp ( if_name , ""FR:"" , 3 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; } else if ( strncmp ( if_name , ""HDLC:"" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; } else if ( strncmp ( if_name , ""PPP:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; } else if ( strncmp ( if_name , ""ETH:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; } else { pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; } if ( strncmp ( direction , ""l2-tx"" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_TX ; } else if ( strncmp ( direction , ""l2-rx"" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_RX ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , COSINE_MAX_IF_NAME_LEN ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers"" ) ; return FALSE ; } caplen += n ; } phdr -> caplen = caplen ; return TRUE ; }
","<S2SV_ModStart> sec , csec , <S2SV_ModEnd> pkt_len ; int <S2SV_ModStart> ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> , & yy <S2SV_ModStart> ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> , direction , <S2SV_ModStart> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE
",wireshark@wireshark/a66628e425db725df1ac52a3c573a03357060ddd,CVE-2016-5356,https://github.com/wireshark/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd,2016-08-07T16:59Z,"<S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> <S2SV_StartBug> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug>"
6888,CWE-310,"int test_sqr ( BIO * bp , BN_CTX * ctx ) { <S2SV_StartBug> BIGNUM a , c , d , e ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> BN_init ( & a ) ; BN_init ( & c ) ; BN_init ( & d ) ; BN_init ( & e ) ; for ( i = 0 ; i < num0 ; i ++ ) { <S2SV_StartBug> BN_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> a . neg = rand_neg ( ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sqr ( & c , & a , ctx ) ; <S2SV_EndBug> if ( bp != NULL ) { if ( ! results ) { <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } <S2SV_StartBug> BN_print ( bp , & c ) ; <S2SV_EndBug> BIO_puts ( bp , ""\\n"" ) ; } <S2SV_StartBug> BN_div ( & d , & e , & c , & a , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sub ( & d , & d , & a ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) <S2SV_EndBug> { <S2SV_StartBug> fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> } } BN_free ( & a ) ; BN_free ( & c ) ; BN_free ( & d ) ; BN_free ( & e ) ; return ( 1 ) ; }
","<S2SV_ModStart> ) { BIGNUM * a , * c , * d , * <S2SV_ModEnd> e ; int <S2SV_ModStart> ; int i , ret = 0 ; a = BN_new ( ) ; c = BN_new ( ) ; d = BN_new ( ) ; e = BN_new ( ) ; if ( a == NULL || c == NULL || d == NULL || e == NULL ) { goto err ; } <S2SV_ModEnd> for ( i <S2SV_ModStart> { BN_bntest_rand ( <S2SV_ModEnd> a , 40 <S2SV_ModStart> ) ; a -> <S2SV_ModEnd> neg = rand_neg <S2SV_ModStart> ; BN_sqr ( c , <S2SV_ModEnd> a , ctx <S2SV_ModStart> ( bp , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ( bp , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ( bp , <S2SV_ModEnd> c ) ; <S2SV_ModStart> } BN_div ( d , e , c , <S2SV_ModEnd> a , ctx <S2SV_ModStart> ; BN_sub ( d , d , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ! BN_is_zero ( <S2SV_ModEnd> d ) || <S2SV_ModStart> ! BN_is_zero ( e ) ) { fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\n"" ) ; goto err ; } } BN_hex2bn ( & a , ""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000"" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , ""\\n"" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d <S2SV_ModEnd> ) ) { <S2SV_ModStart> ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\n"" ) ; goto err ; } BN_hex2bn ( & a , ""80000000000000000000000080000001FFFFFFFE000000000000000000000000"" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , ""\\n"" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d ) ) { fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\n"" ) ; goto err ; } ret = 1 ; err : if ( a != NULL ) BN_free ( a ) ; if ( c != NULL ) BN_free ( c ) ; if ( d != NULL ) BN_free ( d ) ; if ( e != NULL ) BN_free ( e <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",openssl@openssl/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,CVE-2014-3570,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,2015-01-09T02:59Z,"<S2SV_StartBug> BIGNUM a , c , d , e ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> BN_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> a . neg = rand_neg ( ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sqr ( & c , & a , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & c ) ; <S2SV_EndBug> <S2SV_StartBug> BN_div ( & d , & e , & c , & a , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sub ( & d , & d , & a ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>"
6917,CWE-400,"asmlinkage void do_page_fault ( struct pt_regs * regs , unsigned long writeaccess , unsigned long textaccess , unsigned long address ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; const struct exception_table_entry * fixup ; pte_t * pte ; int fault ; tsk = current ; mm = tsk -> mm ; local_irq_enable ( ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> if ( in_atomic ( ) || ! mm ) goto no_context ; down_read ( & mm -> mmap_sem ) ; vma = find_vma ( mm , address ) ; if ( ! vma ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%d<S2SV_blank>fault,<S2SV_blank>address<S2SV_blank>is<S2SV_blank>0x%08x<S2SV_blank>PC<S2SV_blank>%016Lx<S2SV_blank>textaccess<S2SV_blank>%d<S2SV_blank>writeaccess<S2SV_blank>%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; # endif goto bad_area ; } if ( vma -> vm_start <= address ) { goto good_area ; } if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%d<S2SV_blank>fault,<S2SV_blank>address<S2SV_blank>is<S2SV_blank>0x%08x<S2SV_blank>PC<S2SV_blank>%016Lx<S2SV_blank>textaccess<S2SV_blank>%d<S2SV_blank>writeaccess<S2SV_blank>%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; print_vma ( vma ) ; # endif goto bad_area ; } if ( expand_stack ( vma , address ) ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%d<S2SV_blank>fault,<S2SV_blank>address<S2SV_blank>is<S2SV_blank>0x%08x<S2SV_blank>PC<S2SV_blank>%016Lx<S2SV_blank>textaccess<S2SV_blank>%d<S2SV_blank>writeaccess<S2SV_blank>%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; # endif goto bad_area ; } good_area : if ( textaccess ) { if ( ! ( vma -> vm_flags & VM_EXEC ) ) goto bad_area ; } else { if ( writeaccess ) { if ( ! ( vma -> vm_flags & VM_WRITE ) ) goto bad_area ; } else { if ( ! ( vma -> vm_flags & VM_READ ) ) goto bad_area ; } } fault = handle_mm_fault ( mm , vma , address , writeaccess ? FAULT_FLAG_WRITE : 0 ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) { if ( fault & VM_FAULT_OOM ) goto out_of_memory ; else if ( fault & VM_FAULT_SIGBUS ) goto do_sigbus ; BUG ( ) ; } if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> regs , address ) ; } else { tsk -> min_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> regs , address ) ; } pte = lookup_pte ( mm , address ) ; if ( ! pte ) { goto no_pte ; } __do_tlb_refill ( address , textaccess , pte ) ; no_pte : up_read ( & mm -> mmap_sem ) ; return ; bad_area : # ifdef DEBUG_FAULT printk ( ""fault:bad<S2SV_blank>area\\n"" ) ; # endif up_read ( & mm -> mmap_sem ) ; if ( user_mode ( regs ) ) { static int count = 0 ; siginfo_t info ; if ( count < 4 ) { count ++ ; printk ( ""user<S2SV_blank>mode<S2SV_blank>bad_area<S2SV_blank>address=%08lx<S2SV_blank>pid=%d<S2SV_blank>(%s)<S2SV_blank>pc=%08lx\\n"" , address , task_pid_nr ( current ) , current -> comm , ( unsigned long ) regs -> pc ) ; # if 0 show_regs ( regs ) ; # endif } if ( is_global_init ( tsk ) ) { panic ( ""INIT<S2SV_blank>had<S2SV_blank>user<S2SV_blank>mode<S2SV_blank>bad_area\\n"" ) ; } tsk -> thread . address = address ; tsk -> thread . error_code = writeaccess ; info . si_signo = SIGSEGV ; info . si_errno = 0 ; info . si_addr = ( void * ) address ; force_sig_info ( SIGSEGV , & info , tsk ) ; return ; } no_context : # ifdef DEBUG_FAULT printk ( ""fault:No<S2SV_blank>context\\n"" ) ; # endif fixup = search_exception_tables ( regs -> pc ) ; if ( fixup ) { regs -> pc = fixup -> fixup ; return ; } if ( address < PAGE_SIZE ) printk ( KERN_ALERT ""Unable<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>kernel<S2SV_blank>NULL<S2SV_blank>pointer<S2SV_blank>dereference"" ) ; else printk ( KERN_ALERT ""Unable<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>kernel<S2SV_blank>paging<S2SV_blank>request"" ) ; printk ( ""<S2SV_blank>at<S2SV_blank>virtual<S2SV_blank>address<S2SV_blank>%08lx\\n"" , address ) ; printk ( KERN_ALERT ""pc<S2SV_blank>=<S2SV_blank>%08Lx%08Lx\\n"" , regs -> pc >> 32 , regs -> pc & 0xffffffff ) ; die ( ""Oops"" , regs , writeaccess ) ; do_exit ( SIGKILL ) ; out_of_memory : up_read ( & mm -> mmap_sem ) ; if ( ! user_mode ( regs ) ) goto no_context ; pagefault_out_of_memory ( ) ; return ; do_sigbus : printk ( ""fault:Do<S2SV_blank>sigbus\\n"" ) ; up_read ( & mm -> mmap_sem ) ; tsk -> thread . address = address ; tsk -> thread . error_code = writeaccess ; tsk -> thread . trap_no = 14 ; force_sig ( SIGBUS , tsk ) ; if ( ! user_mode ( regs ) ) goto no_context ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug>"
1290,CWE-264,"static int try_to_unmap_cluster ( unsigned long cursor , unsigned int * mapcount , struct vm_area_struct * vma , struct page * check_page ) { struct mm_struct * mm = vma -> vm_mm ; pmd_t * pmd ; pte_t * pte ; pte_t pteval ; spinlock_t * ptl ; struct page * page ; unsigned long address ; unsigned long mmun_start ; unsigned long mmun_end ; unsigned long end ; int ret = SWAP_AGAIN ; int locked_vma = 0 ; address = ( vma -> vm_start + cursor ) & CLUSTER_MASK ; end = address + CLUSTER_SIZE ; if ( address < vma -> vm_start ) address = vma -> vm_start ; if ( end > vma -> vm_end ) end = vma -> vm_end ; pmd = mm_find_pmd ( mm , address ) ; if ( ! pmd ) return ret ; mmun_start = address ; mmun_end = end ; mmu_notifier_invalidate_range_start ( mm , mmun_start , mmun_end ) ; if ( down_read_trylock ( & vma -> vm_mm -> mmap_sem ) ) { locked_vma = ( vma -> vm_flags & VM_LOCKED ) ; if ( ! locked_vma ) up_read ( & vma -> vm_mm -> mmap_sem ) ; } pte = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; update_hiwater_rss ( mm ) ; for ( ; address < end ; pte ++ , address += PAGE_SIZE ) { if ( ! pte_present ( * pte ) ) continue ; page = vm_normal_page ( vma , address , * pte ) ; BUG_ON ( ! page || PageAnon ( page ) ) ; if ( locked_vma ) { <S2SV_StartBug> mlock_vma_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> if ( page == check_page ) <S2SV_EndBug> <S2SV_StartBug> ret = SWAP_MLOCK ; <S2SV_EndBug> continue ; } if ( ptep_clear_flush_young_notify ( vma , address , pte ) ) continue ; flush_cache_page ( vma , address , pte_pfn ( * pte ) ) ; pteval = ptep_clear_flush ( vma , address , pte ) ; if ( page -> index != linear_page_index ( vma , address ) ) { pte_t ptfile = pgoff_to_pte ( page -> index ) ; if ( pte_soft_dirty ( pteval ) ) pte_file_mksoft_dirty ( ptfile ) ; set_pte_at ( mm , address , pte , ptfile ) ; } if ( pte_dirty ( pteval ) ) set_page_dirty ( page ) ; page_remove_rmap ( page ) ; page_cache_release ( page ) ; dec_mm_counter ( mm , MM_FILEPAGES ) ; ( * mapcount ) -- ; } pte_unmap_unlock ( pte - 1 , ptl ) ; mmu_notifier_invalidate_range_end ( mm , mmun_start , mmun_end ) ; if ( locked_vma ) up_read ( & vma -> vm_mm -> mmap_sem ) ; return ret ; }
","<S2SV_ModStart> locked_vma ) { <S2SV_ModEnd> if ( page <S2SV_ModStart> == check_page ) { mlock_vma_page ( page ) ; <S2SV_ModStart> = SWAP_MLOCK ; } else if ( trylock_page ( page ) ) { mlock_vma_page ( page ) ; unlock_page ( page ) ; }
",torvalds@linux/57e68e9cd65b4b8eb4045a1e0d0746458502554c,CVE-2014-3122,https://github.com/torvalds/linux/commit/57e68e9cd65b4b8eb4045a1e0d0746458502554c,2014-05-11T21:55Z,<S2SV_StartBug> mlock_vma_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> if ( page == check_page ) <S2SV_EndBug> <S2SV_StartBug> ret = SWAP_MLOCK ; <S2SV_EndBug>
5288,CWE-000,"void csync_daemon_session ( ) { static char line [ 4 * 4096 ] ; struct stat sb ; address_t peername = { . sa . sa_family = AF_UNSPEC , } ; socklen_t peerlen = sizeof ( peername ) ; char * peer = 0 , * tag [ 32 ] ; int i ; if ( fstat ( 0 , & sb ) ) csync_fatal ( ""Can\'t<S2SV_blank>run<S2SV_blank>fstat<S2SV_blank>on<S2SV_blank>fd<S2SV_blank>0:<S2SV_blank>%s"" , strerror ( errno ) ) ; switch ( sb . st_mode & S_IFMT ) { case S_IFSOCK : if ( getpeername ( 0 , & peername . sa , & peerlen ) == - 1 ) csync_fatal ( ""Can\'t<S2SV_blank>run<S2SV_blank>getpeername<S2SV_blank>on<S2SV_blank>fd<S2SV_blank>0:<S2SV_blank>%s"" , strerror ( errno ) ) ; break ; case S_IFIFO : set_peername_from_env ( & peername , ""SSH_CLIENT"" ) ; break ; default : csync_fatal ( ""I\'m<S2SV_blank>only<S2SV_blank>talking<S2SV_blank>to<S2SV_blank>sockets<S2SV_blank>or<S2SV_blank>pipes!<S2SV_blank>%x\\n"" , sb . st_mode & S_IFMT ) ; break ; } while ( conn_gets ( line , sizeof ( line ) ) ) { int cmdnr ; if ( ! setup_tag ( tag , line ) ) continue ; for ( cmdnr = 0 ; cmdtab [ cmdnr ] . text ; cmdnr ++ ) if ( ! strcasecmp ( cmdtab [ cmdnr ] . text , tag [ 0 ] ) ) break ; if ( ! cmdtab [ cmdnr ] . text ) { cmd_error = conn_response ( CR_ERR_UNKNOWN_COMMAND ) ; goto abort_cmd ; } cmd_error = 0 ; if ( cmdtab [ cmdnr ] . need_ident && ! peer ) { conn_printf ( ""Dear<S2SV_blank>%s,<S2SV_blank>please<S2SV_blank>identify<S2SV_blank>first.\\n"" , csync_inet_ntop ( & peername ) ? : ""stranger"" ) ; goto next_cmd ; } if ( cmdtab [ cmdnr ] . check_perm ) on_cygwin_lowercase ( tag [ 2 ] ) ; if ( cmdtab [ cmdnr ] . check_perm ) { if ( cmdtab [ cmdnr ] . check_perm == 2 ) csync_compare_mode = 1 ; int perm = csync_perm ( tag [ 2 ] , tag [ 1 ] , peer ) ; if ( cmdtab [ cmdnr ] . check_perm == 2 ) csync_compare_mode = 0 ; if ( perm ) { if ( perm == 2 ) { csync_mark ( tag [ 2 ] , peer , 0 ) ; cmd_error = conn_response ( CR_ERR_PERM_DENIED_FOR_SLAVE ) ; } else cmd_error = conn_response ( CR_ERR_PERM_DENIED ) ; goto abort_cmd ; } } if ( cmdtab [ cmdnr ] . check_dirty && csync_check_dirty ( tag [ 2 ] , peer , cmdtab [ cmdnr ] . action == A_FLUSH ) ) goto abort_cmd ; if ( cmdtab [ cmdnr ] . unlink ) csync_unlink ( tag [ 2 ] , cmdtab [ cmdnr ] . unlink ) ; switch ( cmdtab [ cmdnr ] . action ) { case A_SIG : { struct stat st ; if ( lstat_strict ( prefixsubst ( tag [ 2 ] ) , & st ) != 0 ) { if ( errno == ENOENT ) { struct stat sb ; char parent_dirname [ strlen ( tag [ 2 ] ) ] ; split_dirname_basename ( parent_dirname , NULL , tag [ 2 ] ) ; if ( lstat_strict ( prefixsubst ( parent_dirname ) , & sb ) != 0 ) cmd_error = conn_response ( CR_ERR_PARENT_DIR_MISSING ) ; else conn_resp_zero ( CR_OK_PATH_NOT_FOUND ) ; } else cmd_error = strerror ( errno ) ; break ; } else if ( csync_check_pure ( tag [ 2 ] ) ) { conn_resp_zero ( CR_OK_NOT_FOUND ) ; break ; } conn_resp ( CR_OK_DATA_FOLLOWS ) ; conn_printf ( ""%s\\n"" , csync_genchecktxt ( & st , tag [ 2 ] , 1 ) ) ; if ( S_ISREG ( st . st_mode ) ) csync_rs_sig ( tag [ 2 ] ) ; else conn_printf ( ""octet-stream<S2SV_blank>0\\n"" ) ; } break ; case A_MARK : csync_mark ( tag [ 2 ] , peer , 0 ) ; break ; case A_TYPE : { FILE * f = fopen ( prefixsubst ( tag [ 2 ] ) , ""rb"" ) ; if ( ! f && errno == ENOENT ) f = fopen ( ""/dev/null"" , ""rb"" ) ; if ( f ) { char buffer [ 512 ] ; size_t rc ; conn_resp ( CR_OK_DATA_FOLLOWS ) ; while ( ( rc = fread ( buffer , 1 , 512 , f ) ) > 0 ) if ( conn_write ( buffer , rc ) != rc ) { conn_printf ( ""[[<S2SV_blank>%s<S2SV_blank>]]"" , strerror ( errno ) ) ; break ; } fclose ( f ) ; return ; } cmd_error = strerror ( errno ) ; } break ; case A_GETTM : case A_GETSZ : { struct stat sbuf ; conn_resp ( CR_OK_DATA_FOLLOWS ) ; if ( ! lstat_strict ( prefixsubst ( tag [ 2 ] ) , & sbuf ) ) conn_printf ( ""%ld\\n"" , cmdtab [ cmdnr ] . action == A_GETTM ? ( long ) sbuf . st_mtime : ( long ) sbuf . st_size ) ; else conn_printf ( ""-1\\n"" ) ; goto next_cmd ; } break ; case A_FLUSH : SQL ( ""Flushing<S2SV_blank>dirty<S2SV_blank>entry<S2SV_blank>(if<S2SV_blank>any)<S2SV_blank>for<S2SV_blank>file"" , ""DELETE<S2SV_blank>FROM<S2SV_blank>dirty<S2SV_blank>WHERE<S2SV_blank>filename<S2SV_blank>=<S2SV_blank>\'%s\'"" , url_encode ( tag [ 2 ] ) ) ; break ; case A_DEL : if ( ! csync_file_backup ( tag [ 2 ] ) ) csync_unlink ( tag [ 2 ] , 0 ) ; break ; case A_PATCH : if ( ! csync_file_backup ( tag [ 2 ] ) ) { conn_resp ( CR_OK_SEND_DATA ) ; csync_rs_sig ( tag [ 2 ] ) ; if ( csync_rs_patch ( tag [ 2 ] ) ) cmd_error = strerror ( errno ) ; } break ; case A_MKDIR : # ifdef __CYGWIN__ { char winfilename [ MAX_PATH ] ; cygwin_conv_to_win32_path ( prefixsubst ( tag [ 2 ] ) , winfilename ) ; if ( ! CreateDirectory ( TEXT ( winfilename ) , NULL ) ) { struct stat st ; if ( lstat_strict ( prefixsubst ( tag [ 2 ] ) , & st ) != 0 || ! S_ISDIR ( st . st_mode ) ) { csync_debug ( 1 , ""Win32<S2SV_blank>I/O<S2SV_blank>Error<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>mkdir<S2SV_blank>command:<S2SV_blank>%s\\n"" , ( int ) GetLastError ( ) , winfilename ) ; cmd_error = conn_response ( CR_ERR_WIN32_EIO_CREATE_DIR ) ; } } } # else if ( mkdir ( prefixsubst ( tag [ 2 ] ) , 0700 ) ) { struct stat st ; if ( lstat_strict ( ( prefixsubst ( tag [ 2 ] ) ) , & st ) != 0 || ! S_ISDIR ( st . st_mode ) ) cmd_error = strerror ( errno ) ; } # endif break ; case A_MKCHR : if ( mknod ( prefixsubst ( tag [ 2 ] ) , 0700 | S_IFCHR , atoi ( tag [ 3 ] ) ) ) cmd_error = strerror ( errno ) ; break ; case A_MKBLK : if ( mknod ( prefixsubst ( tag [ 2 ] ) , 0700 | S_IFBLK , atoi ( tag [ 3 ] ) ) ) cmd_error = strerror ( errno ) ; break ; case A_MKFIFO : if ( mknod ( prefixsubst ( tag [ 2 ] ) , 0700 | S_IFIFO , 0 ) ) cmd_error = strerror ( errno ) ; break ; case A_MKLINK : if ( symlink ( tag [ 3 ] , prefixsubst ( tag [ 2 ] ) ) ) cmd_error = strerror ( errno ) ; break ; case A_MKSOCK : break ; case A_SETOWN : if ( ! csync_ignore_uid || ! csync_ignore_gid ) { int uid = csync_ignore_uid ? - 1 : atoi ( tag [ 3 ] ) ; int gid = csync_ignore_gid ? - 1 : atoi ( tag [ 4 ] ) ; if ( lchown ( prefixsubst ( tag [ 2 ] ) , uid , gid ) ) cmd_error = strerror ( errno ) ; } break ; case A_SETMOD : if ( ! csync_ignore_mod ) { if ( chmod ( prefixsubst ( tag [ 2 ] ) , atoi ( tag [ 3 ] ) ) ) cmd_error = strerror ( errno ) ; } break ; case A_SETIME : { struct utimbuf utb ; utb . actime = atoll ( tag [ 3 ] ) ; utb . modtime = atoll ( tag [ 3 ] ) ; if ( utime ( prefixsubst ( tag [ 2 ] ) , & utb ) ) cmd_error = strerror ( errno ) ; } break ; case A_LIST : SQL_BEGIN ( ""DB<S2SV_blank>Dump<S2SV_blank>-<S2SV_blank>Files<S2SV_blank>for<S2SV_blank>sync<S2SV_blank>pair"" , ""SELECT<S2SV_blank>checktxt,<S2SV_blank>filename<S2SV_blank>FROM<S2SV_blank>file<S2SV_blank>%s%s%s<S2SV_blank>ORDER<S2SV_blank>BY<S2SV_blank>filename"" , strcmp ( tag [ 2 ] , ""-"" ) ? ""WHERE<S2SV_blank>filename<S2SV_blank>=<S2SV_blank>\'"" : """" , strcmp ( tag [ 2 ] , ""-"" ) ? url_encode ( tag [ 2 ] ) : """" , strcmp ( tag [ 2 ] , ""-"" ) ? ""\'"" : """" ) { if ( csync_match_file_host ( url_decode ( SQL_V ( 1 ) ) , tag [ 1 ] , peer , ( const char * * ) & tag [ 3 ] ) ) conn_printf ( ""%s\\t%s\\n"" , SQL_V ( 0 ) , SQL_V ( 1 ) ) ; } SQL_END ; break ; case A_DEBUG : csync_debug_out = stdout ; if ( tag [ 1 ] [ 0 ] ) csync_debug_level = atoi ( tag [ 1 ] ) ; break ; case A_HELLO : if ( peer ) { free ( peer ) ; peer = NULL ; } if ( verify_peername ( tag [ 1 ] , & peername ) ) { peer = strdup ( tag [ 1 ] ) ; } else { peer = NULL ; cmd_error = conn_response ( CR_ERR_IDENTIFICATION_FAILED ) ; break ; } # ifdef HAVE_LIBGNUTLS if ( ! csync_conn_usessl ) { struct csync_nossl * t ; for ( t = csync_nossl ; t ; t = t -> next ) { if ( ! fnmatch ( t -> pattern_from , myhostname , 0 ) && ! fnmatch ( t -> pattern_to , peer , 0 ) ) goto conn_without_ssl_ok ; } cmd_error = conn_response ( CR_ERR_SSL_EXPECTED ) ; <S2SV_StartBug> } <S2SV_EndBug> conn_without_ssl_ok : ; # endif break ; case A_GROUP : if ( active_grouplist ) { cmd_error = conn_response ( CR_ERR_GROUP_LIST_ALREADY_SET ) ; } else { const struct csync_group * g ; int i , gnamelen ; active_grouplist = strdup ( tag [ 1 ] ) ; for ( g = csync_group ; g ; g = g -> next ) { if ( ! g -> myname ) continue ; i = 0 ; gnamelen = strlen ( csync_group -> gname ) ; while ( active_grouplist [ i ] ) { if ( ! strncmp ( active_grouplist + i , csync_group -> gname , gnamelen ) && ( active_grouplist [ i + gnamelen ] == ',' || ! active_grouplist [ i + gnamelen ] ) ) goto found_asactive ; while ( active_grouplist [ i ] ) if ( active_grouplist [ i ++ ] == ',' ) break ; } csync_group -> myname = 0 ; found_asactive : ; } } break ; case A_BYE : for ( i = 0 ; i < 32 ; i ++ ) free ( tag [ i ] ) ; conn_resp ( CR_OK_CU_LATER ) ; return ; } if ( cmdtab [ cmdnr ] . update ) csync_file_update ( tag [ 2 ] , peer ) ; if ( cmdtab [ cmdnr ] . update == 1 ) { csync_debug ( 1 , ""Updated<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s.\\n"" , tag [ 2 ] , peer ? peer : ""???"" ) ; csync_schedule_commands ( tag [ 2 ] , 0 ) ; } abort_cmd : if ( cmd_error ) conn_printf ( ""%s\\n"" , cmd_error ) ; else conn_resp ( CR_OK_CMD_FINISHED ) ; next_cmd : destroy_tag ( tag ) ; } }
","<S2SV_ModStart> CR_ERR_SSL_EXPECTED ) ; peer = NULL ;
",LINBIT@csync2/416f1de878ef97e27e27508914f7ba8599a0be22,CVE-2019-15522,https://github.com/LINBIT/csync2/commit/416f1de878ef97e27e27508914f7ba8599a0be22,2020-03-20T21:15Z,<S2SV_StartBug> } <S2SV_EndBug>
3906,CWE-119,"l_int32 gplotAddPlot ( GPLOT * gplot , NUMA * nax , NUMA * nay , l_int32 plotstyle , const char * plottitle ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char emptystring [ ] = """" ; char * datastr , * title ; l_int32 n , i ; l_float32 valx , valy , startx , delx ; SARRAY * sa ; PROCNAME ( ""gplotAddPlot"" ) ; if ( ! gplot ) return ERROR_INT ( ""gplot<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! nay ) return ERROR_INT ( ""nay<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES ) return ERROR_INT ( ""invalid<S2SV_blank>plotstyle"" , procName , 1 ) ; if ( ( n = numaGetCount ( nay ) ) == 0 ) return ERROR_INT ( ""no<S2SV_blank>points<S2SV_blank>to<S2SV_blank>plot"" , procName , 1 ) ; if ( nax && ( n != numaGetCount ( nax ) ) ) return ERROR_INT ( ""nax<S2SV_blank>and<S2SV_blank>nay<S2SV_blank>sizes<S2SV_blank>differ"" , procName , 1 ) ; if ( n == 1 && plotstyle == GPLOT_LINES ) { L_INFO ( ""only<S2SV_blank>1<S2SV_blank>pt;<S2SV_blank>changing<S2SV_blank>style<S2SV_blank>to<S2SV_blank>points\\n"" , procName ) ; plotstyle = GPLOT_POINTS ; } numaGetParameters ( nay , & startx , & delx ) ; numaAddNumber ( gplot -> plotstyles , plotstyle ) ; if ( plottitle ) { title = stringNew ( plottitle ) ; sarrayAddString ( gplot -> plottitles , title , L_INSERT ) ; } else { sarrayAddString ( gplot -> plottitles , emptystring , L_COPY ) ; } gplot -> nplots ++ ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.data.%d"" , gplot -> rootname , gplot -> nplots ) ; <S2SV_EndBug> sarrayAddString ( gplot -> datanames , buf , L_COPY ) ; sa = sarrayCreate ( n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( nax ) numaGetFValue ( nax , i , & valx ) ; else valx = startx + i * delx ; numaGetFValue ( nay , i , & valy ) ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%f<S2SV_blank>%f\\n"" , valx , valy ) ; <S2SV_EndBug> sarrayAddString ( sa , buf , L_COPY ) ; } datastr = sarrayToString ( sa , 0 ) ; sarrayAddString ( gplot -> plotdata , datastr , L_INSERT ) ; sarrayDestroy ( & sa ) ; return 0 ; }
","<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.data.%d"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%f<S2SV_blank>%f\\n"" ,
",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.data.%d"" , gplot -> rootname , gplot -> nplots ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%f<S2SV_blank>%f\\n"" , valx , valy ) ; <S2SV_EndBug>"
1546,CWE-119,"int vp9_get_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) { int i ; InternalFrameBufferList * const int_fb_list = ( InternalFrameBufferList * ) cb_priv ; if ( int_fb_list == NULL ) return - 1 ; for ( i = 0 ; i < int_fb_list -> num_internal_frame_buffers ; ++ i ) { if ( ! int_fb_list -> int_fb [ i ] . in_use ) break ; } if ( i == int_fb_list -> num_internal_frame_buffers ) return - 1 ; if ( int_fb_list -> int_fb [ i ] . size < min_size ) { int_fb_list -> int_fb [ i ] . data = ( uint8_t * ) vpx_realloc ( int_fb_list -> int_fb [ i ] . data , min_size ) ; if ( ! int_fb_list -> int_fb [ i ] . data ) return - 1 ; <S2SV_StartBug> int_fb_list -> int_fb [ i ] . size = min_size ; <S2SV_EndBug> } fb -> data = int_fb_list -> int_fb [ i ] . data ; fb -> size = int_fb_list -> int_fb [ i ] . size ; int_fb_list -> int_fb [ i ] . in_use = 1 ; fb -> priv = & int_fb_list -> int_fb [ i ] ; return 0 ; }
","<S2SV_ModStart> - 1 ; memset ( int_fb_list -> int_fb [ i ] . data , 0 , min_size ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> int_fb_list -> int_fb [ i ] . size = min_size ; <S2SV_EndBug>
1303,CWE-119,"u32 h264bsdInitDpb ( dpbStorage_t * dpb , u32 picSizeInMbs , u32 dpbSize , u32 maxRefFrames , u32 maxFrameNum , u32 noReordering ) { u32 i ; ASSERT ( picSizeInMbs ) ; ASSERT ( maxRefFrames <= MAX_NUM_REF_PICS ) ; ASSERT ( maxRefFrames <= dpbSize ) ; ASSERT ( maxFrameNum ) ; <S2SV_StartBug> ASSERT ( dpbSize ) ; <S2SV_EndBug> dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ; dpb -> maxRefFrames = MAX ( maxRefFrames , 1 ) ; if ( noReordering ) dpb -> dpbSize = dpb -> maxRefFrames ; else dpb -> dpbSize = dpbSize ; dpb -> maxFrameNum = maxFrameNum ; dpb -> noReordering = noReordering ; dpb -> fullness = 0 ; dpb -> numRefFrames = 0 ; dpb -> prevRefFrameNum = 0 ; ALLOCATE ( dpb -> buffer , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t ) ; if ( dpb -> buffer == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( dpb -> buffer , 0 , ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t ) ) ; for ( i = 0 ; i < dpb -> dpbSize + 1 ; i ++ ) { ALLOCATE ( dpb -> buffer [ i ] . pAllocatedData , ( picSizeInMbs * 384 + 32 + 15 ) , u8 ) ; if ( dpb -> buffer [ i ] . pAllocatedData == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; dpb -> buffer [ i ] . data = ALIGN ( dpb -> buffer [ i ] . pAllocatedData , 16 ) ; } ALLOCATE ( dpb -> list , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t * ) ; ALLOCATE ( dpb -> outBuf , dpb -> dpbSize + 1 , dpbOutPicture_t ) ; if ( dpb -> list == NULL || dpb -> outBuf == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( dpb -> list , 0 , ( ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t * ) ) ) ; dpb -> numOut = dpb -> outIndex = 0 ; return ( HANTRO_OK ) ; }
","<S2SV_ModStart> dpbSize ) ; if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) { ALOGE ( ""b/28533562"" ) ; android_errorWriteLog ( 0x534e4554 , ""28533562"" ) ; return ( MEMORY_ALLOCATION_ERROR ) ; }
",frameworks@av/590d1729883f700ab905cdc9ad850f3ddd7e1f56,CVE-2016-3819,https://android.googlesource.com/platform/frameworks/av/+/590d1729883f700ab905cdc9ad850f3ddd7e1f56,2016-08-05T20:59Z,<S2SV_StartBug> ASSERT ( dpbSize ) ; <S2SV_EndBug>
2256,CWE-119,"static av_always_inline int vp78_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt , int is_vp7 ) { VP8Context * s = avctx -> priv_data ; int ret , i , referenced , num_jobs ; enum AVDiscard skip_thresh ; <S2SV_StartBug> VP8Frame * av_uninit ( curframe ) , * prev_frame ; <S2SV_EndBug> if ( is_vp7 ) ret = vp7_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ; else ret = vp8_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ; if ( ret < 0 ) goto err ; prev_frame = s -> framep [ VP56_FRAME_CURRENT ] ; referenced = s -> update_last || s -> update_golden == VP56_FRAME_CURRENT || s -> update_altref == VP56_FRAME_CURRENT ; skip_thresh = ! referenced ? AVDISCARD_NONREF : ! s -> keyframe ? AVDISCARD_NONKEY : AVDISCARD_ALL ; if ( avctx -> skip_frame >= skip_thresh ) { s -> invisible = 1 ; memcpy ( & s -> next_framep [ 0 ] , & s -> framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; goto skip_decode ; } s -> deblock_filter = s -> filter . level && avctx -> skip_loop_filter < skip_thresh ; for ( i = 0 ; i < 5 ; i ++ ) if ( s -> frames [ i ] . tf . f -> data [ 0 ] && & s -> frames [ i ] != prev_frame && & s -> frames [ i ] != s -> framep [ VP56_FRAME_PREVIOUS ] && & s -> frames [ i ] != s -> framep [ VP56_FRAME_GOLDEN ] && & s -> frames [ i ] != s -> framep [ VP56_FRAME_GOLDEN2 ] ) vp8_release_frame ( s , & s -> frames [ i ] ) ; curframe = s -> framep [ VP56_FRAME_CURRENT ] = vp8_find_free_buffer ( s ) ; if ( ! s -> colorspace ) avctx -> colorspace = AVCOL_SPC_BT470BG ; if ( s -> fullrange ) avctx -> color_range = AVCOL_RANGE_JPEG ; else avctx -> color_range = AVCOL_RANGE_MPEG ; if ( ! s -> keyframe && ( ! s -> framep [ VP56_FRAME_PREVIOUS ] || ! s -> framep [ VP56_FRAME_GOLDEN ] || ! s -> framep [ VP56_FRAME_GOLDEN2 ] ) ) { av_log ( avctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>interframe<S2SV_blank>without<S2SV_blank>a<S2SV_blank>prior<S2SV_blank>keyframe!\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto err ; } curframe -> tf . f -> key_frame = s -> keyframe ; curframe -> tf . f -> pict_type = s -> keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ; if ( ( ret = vp8_alloc_frame ( s , curframe , referenced ) ) < 0 ) goto err ; if ( s -> update_altref != VP56_FRAME_NONE ) s -> next_framep [ VP56_FRAME_GOLDEN2 ] = s -> framep [ s -> update_altref ] ; else s -> next_framep [ VP56_FRAME_GOLDEN2 ] = s -> framep [ VP56_FRAME_GOLDEN2 ] ; if ( s -> update_golden != VP56_FRAME_NONE ) s -> next_framep [ VP56_FRAME_GOLDEN ] = s -> framep [ s -> update_golden ] ; else s -> next_framep [ VP56_FRAME_GOLDEN ] = s -> framep [ VP56_FRAME_GOLDEN ] ; if ( s -> update_last ) s -> next_framep [ VP56_FRAME_PREVIOUS ] = curframe ; else s -> next_framep [ VP56_FRAME_PREVIOUS ] = s -> framep [ VP56_FRAME_PREVIOUS ] ; s -> next_framep [ VP56_FRAME_CURRENT ] = curframe ; if ( avctx -> codec -> update_thread_context ) ff_thread_finish_setup ( avctx ) ; s -> linesize = curframe -> tf . f -> linesize [ 0 ] ; s -> uvlinesize = curframe -> tf . f -> linesize [ 1 ] ; memset ( s -> top_nnz , 0 , s -> mb_width * sizeof ( * s -> top_nnz ) ) ; if ( ! s -> mb_layout ) memset ( s -> macroblocks + s -> mb_height * 2 - 1 , 0 , ( s -> mb_width + 1 ) * sizeof ( * s -> macroblocks ) ) ; if ( ! s -> mb_layout && s -> keyframe ) memset ( s -> intra4x4_pred_mode_top , DC_PRED , s -> mb_width * 4 ) ; memset ( s -> ref_count , 0 , sizeof ( s -> ref_count ) ) ; if ( s -> mb_layout == 1 ) { if ( prev_frame && s -> segmentation . enabled && ! s -> segmentation . update_map ) ff_thread_await_progress ( & prev_frame -> tf , 1 , 0 ) ; if ( is_vp7 ) vp7_decode_mv_mb_modes ( avctx , curframe , prev_frame ) ; else vp8_decode_mv_mb_modes ( avctx , curframe , prev_frame ) ; } if ( avctx -> active_thread_type == FF_THREAD_FRAME ) num_jobs = 1 ; else num_jobs = FFMIN ( s -> num_coeff_partitions , avctx -> thread_count ) ; s -> num_jobs = num_jobs ; s -> curframe = curframe ; s -> prev_frame = prev_frame ; s -> mv_bounds . mv_min . y = - MARGIN ; s -> mv_bounds . mv_max . y = ( ( s -> mb_height - 1 ) << 6 ) + MARGIN ; for ( i = 0 ; i < MAX_THREADS ; i ++ ) { VP8ThreadData * td = & s -> thread_data [ i ] ; atomic_init ( & td -> thread_mb_pos , 0 ) ; atomic_init ( & td -> wait_mb_pos , INT_MAX ) ; } if ( is_vp7 ) avctx -> execute2 ( avctx , vp7_decode_mb_row_sliced , s -> thread_data , NULL , num_jobs ) ; else avctx -> execute2 ( avctx , vp8_decode_mb_row_sliced , s -> thread_data , NULL , num_jobs ) ; ff_thread_report_progress ( & curframe -> tf , INT_MAX , 0 ) ; memcpy ( & s -> framep [ 0 ] , & s -> next_framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; skip_decode : if ( ! s -> update_probabilities ) s -> prob [ 0 ] = s -> prob [ 1 ] ; if ( ! s -> invisible ) { if ( ( ret = av_frame_ref ( data , curframe -> tf . f ) ) < 0 ) return ret ; * got_frame = 1 ; } return avpkt -> size ; err : memcpy ( & s -> next_framep [ 0 ] , & s -> framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; return ret ; }
","<S2SV_ModStart> , * prev_frame ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P )
",FFmpeg@FFmpeg/6b5d3fb26fb4be48e4966e4b1d97c2165538d4ef,CVE-2017-9994,https://github.com/FFmpeg/FFmpeg/commit/6b5d3fb26fb4be48e4966e4b1d97c2165538d4ef,2017-06-28T06:29Z,"<S2SV_StartBug> VP8Frame * av_uninit ( curframe ) , * prev_frame ; <S2SV_EndBug>"
796,CWE-000,"int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) { struct assoc_array_edit * edit ; struct timespec now ; int ret , awaken , link_ret = 0 ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; if ( keyring ) { if ( keyring -> restrict_link ) return - EPERM ; link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; } mutex_lock ( & key_construction_mutex ) ; if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { atomic_inc ( & key -> user -> nikeys ) ; key -> reject_error = - error ; smp_wmb ( ) ; set_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; now = current_kernel_time ( ) ; key -> expiry = now . tv_sec + timeout ; key_schedule_gc ( key -> expiry + key_gc_delay ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; ret = 0 ; if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ; if ( authkey ) key_revoke ( authkey ) ; } mutex_unlock ( & key_construction_mutex ) ; <S2SV_StartBug> if ( keyring ) <S2SV_EndBug> __key_link_end ( keyring , & key -> index_key , edit ) ; if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; return ret == 0 ? link_ret : ret ; }
","<S2SV_ModStart> if ( keyring && link_ret == 0
",torvalds@linux/38327424b40bcebe2de92d07312c89360ac9229a,CVE-2016-4470,https://github.com/torvalds/linux/commit/38327424b40bcebe2de92d07312c89360ac9229a,2016-06-27T10:59Z,<S2SV_StartBug> if ( keyring ) <S2SV_EndBug>
464,CWE-200,"static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MagickPathExtent ] , name [ MagickPathExtent ] ; Image * image ; int c ; MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length , padding , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; * name = '\\0' ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%1024s<S2SV_blank>%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%1024s<S2SV_blank>%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( sscanf ( buffer , ""static<S2SV_blank>short<S2SV_blank>%1024s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , ""static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%1024s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , ""static<S2SV_blank>char<S2SV_blank>%1024s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) NULL ) p = ( unsigned char * ) name ; else p ++ ; if ( LocaleCompare ( ""bits[]"" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colormap [ 0 ] . red = ( MagickRealType ) QuantumRange ; image -> colormap [ 0 ] . green = ( MagickRealType ) QuantumRange ; image -> colormap [ 0 ] . blue = ( MagickRealType ) QuantumRange ; image -> colormap [ 1 ] . red = 0.0 ; image -> colormap [ 1 ] . green = 0.0 ; image -> colormap [ 1 ] . blue = 0.0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; for ( i = 0 ; i < ( ssize_t ) ( sizeof ( hex_digits ) / sizeof ( * hex_digits ) ) ; i ++ ) hex_digits [ i ] = ( - 1 ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) { c = XBMInteger ( image , hex_digits ) ; if ( c < 0 ) <S2SV_StartBug> break ; <S2SV_EndBug> * p ++ = ( unsigned char ) c ; if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) * p ++ = ( unsigned char ) ( c >> 8 ) ; } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { c = XBMInteger ( image , hex_digits ) ; if ( c < 0 ) <S2SV_StartBug> break ; <S2SV_EndBug> * p ++ = ( unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 ) byte = ( unsigned int ) ( * p ++ ) ; SetPixelIndex ( image , ( Quantum ) ( ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) , q ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ( void ) SyncImage ( image , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> < 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } <S2SV_ModEnd> * p ++ <S2SV_ModStart> < 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } <S2SV_ModEnd> * p ++
",ImageMagick@ImageMagick/216d117f05bff87b9dc4db55a1b1fadb38bcb786,CVE-2018-16323,https://github.com/ImageMagick/ImageMagick/commit/216d117f05bff87b9dc4db55a1b1fadb38bcb786,2018-09-01T18:29Z,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug>
1445,CWE-119,"static uint64_t calc_plane_error ( unsigned char * orig , int orig_stride , unsigned char * recon , int recon_stride , unsigned int cols , unsigned int rows ) { unsigned int row , col ; uint64_t total_sse = 0 ; int diff ; for ( row = 0 ; row + 16 <= rows ; row += 16 ) { for ( col = 0 ; col + 16 <= cols ; col += 16 ) { unsigned int sse ; <S2SV_StartBug> vp8_mse16x16 ( orig + col , orig_stride , <S2SV_EndBug> recon + col , recon_stride , & sse ) ; total_sse += sse ; } if ( col < cols ) { unsigned int border_row , border_col ; unsigned char * border_orig = orig ; unsigned char * border_recon = recon ; for ( border_row = 0 ; border_row < 16 ; border_row ++ ) { for ( border_col = col ; border_col < cols ; border_col ++ ) { diff = border_orig [ border_col ] - border_recon [ border_col ] ; total_sse += diff * diff ; } border_orig += orig_stride ; border_recon += recon_stride ; } } orig += orig_stride * 16 ; recon += recon_stride * 16 ; } for ( ; row < rows ; row ++ ) { for ( col = 0 ; col < cols ; col ++ ) { diff = orig [ col ] - recon [ col ] ; total_sse += diff * diff ; } orig += orig_stride ; recon += recon_stride ; } vp8_clear_system_state ( ) ; return total_sse ; }
","<S2SV_ModStart> int sse ; vpx_mse16x16 <S2SV_ModEnd> ( orig +
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vp8_mse16x16 ( orig + col , orig_stride , <S2SV_EndBug>"
7458,CWE-415,"void DDGifSlurp ( GifInfo * info , bool decode , bool exitAfterFrame ) { GifRecordType RecordType ; GifByteType * ExtData ; int ExtFunction ; GifFileType * gifFilePtr ; gifFilePtr = info -> gifFilePtr ; uint_fast32_t lastAllocatedGCBIndex = 0 ; do { if ( DGifGetRecordType ( gifFilePtr , & RecordType ) == GIF_ERROR ) { break ; } bool isInitialPass = ! decode && ! exitAfterFrame ; switch ( RecordType ) { case IMAGE_DESC_RECORD_TYPE : if ( DGifGetImageDesc ( gifFilePtr , isInitialPass ) == GIF_ERROR ) { break ; } if ( isInitialPass ) { int_fast32_t widthOverflow = gifFilePtr -> Image . Width - gifFilePtr -> SWidth ; int_fast32_t heightOverflow = gifFilePtr -> Image . Height - gifFilePtr -> SHeight ; if ( widthOverflow > 0 || heightOverflow > 0 ) { gifFilePtr -> SWidth += widthOverflow ; gifFilePtr -> SHeight += heightOverflow ; } SavedImage * sp = & gifFilePtr -> SavedImages [ gifFilePtr -> ImageCount - 1 ] ; int_fast32_t topOverflow = gifFilePtr -> Image . Top + gifFilePtr -> Image . Height - gifFilePtr -> SHeight ; if ( topOverflow > 0 ) { sp -> ImageDesc . Top -= topOverflow ; } int_fast32_t leftOverflow = gifFilePtr -> Image . Left + gifFilePtr -> Image . Width - gifFilePtr -> SWidth ; if ( leftOverflow > 0 ) { sp -> ImageDesc . Left -= leftOverflow ; } if ( ! updateGCB ( info , & lastAllocatedGCBIndex ) ) { break ; } } if ( decode ) { <S2SV_StartBug> int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; <S2SV_EndBug> int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight ; <S2SV_StartBug> const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; <S2SV_EndBug> if ( newRasterSize > info -> rasterSize || widthOverflow > 0 || heightOverflow > 0 ) { void * tmpRasterBits = reallocarray ( info -> rasterBits , newRasterSize , sizeof ( GifPixelType ) ) ; if ( tmpRasterBits == NULL ) { gifFilePtr -> Error = D_GIF_ERR_NOT_ENOUGH_MEM ; break ; } info -> rasterBits = tmpRasterBits ; info -> rasterSize = newRasterSize ; } if ( gifFilePtr -> Image . Interlace ) { uint_fast16_t i , j ; uint_fast8_t InterlacedOffset [ ] = { 0 , 4 , 2 , 1 } ; uint_fast8_t InterlacedJumps [ ] = { 8 , 8 , 4 , 2 } ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = InterlacedOffset [ i ] ; j < gifFilePtr -> Image . Height ; j += InterlacedJumps [ i ] ) { if ( DGifGetLine ( gifFilePtr , info -> rasterBits + j * gifFilePtr -> Image . Width , gifFilePtr -> Image . Width ) == GIF_ERROR ) break ; } } else { if ( DGifGetLine ( gifFilePtr , info -> rasterBits , gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ) == GIF_ERROR ) { break ; } } if ( info -> sampleSize > 1 ) { unsigned char * dst = info -> rasterBits ; unsigned char * src = info -> rasterBits ; unsigned char * const srcEndImage = info -> rasterBits + gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; do { unsigned char * srcNextLineStart = src + gifFilePtr -> Image . Width * info -> sampleSize ; unsigned char * const srcEndLine = src + gifFilePtr -> Image . Width ; unsigned char * dstEndLine = dst + gifFilePtr -> Image . Width / info -> sampleSize ; do { * dst = * src ; dst ++ ; src += info -> sampleSize ; } while ( src < srcEndLine ) ; dst = dstEndLine ; src = srcNextLineStart ; } while ( src < srcEndImage ) ; } return ; } else { do { if ( DGifGetCodeNext ( gifFilePtr , & ExtData ) == GIF_ERROR ) { break ; } } while ( ExtData != NULL ) ; if ( exitAfterFrame ) { return ; } } break ; case EXTENSION_RECORD_TYPE : if ( DGifGetExtension ( gifFilePtr , & ExtFunction , & ExtData ) == GIF_ERROR ) { break ; } if ( isInitialPass ) { updateGCB ( info , & lastAllocatedGCBIndex ) ; if ( readExtensions ( ExtFunction , ExtData , info ) == GIF_ERROR ) { break ; } } while ( ExtData != NULL ) { if ( DGifGetExtensionNext ( gifFilePtr , & ExtData ) == GIF_ERROR ) { break ; } if ( isInitialPass && readExtensions ( ExtFunction , ExtData , info ) == GIF_ERROR ) { break ; } } break ; case TERMINATE_RECORD_TYPE : break ; default : break ; } } while ( RecordType != TERMINATE_RECORD_TYPE ) ; info -> rewindFunction ( info ) ; }
","<S2SV_ModStart> decode ) { <S2SV_ModEnd> const uint_fast32_t newRasterSize <S2SV_ModStart> Image . Height ; if ( newRasterSize == 0 ) { free ( info -> rasterBits ) ; info -> rasterBits = NULL ; info -> rasterSize = newRasterSize ; return ; } const int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; const int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight
",koral--@android-gif-drawable/cc5b4f8e43463995a84efd594f89a21f906c2d20,CVE-2019-11932,https://github.com/koral--/android-gif-drawable/commit/cc5b4f8e43463995a84efd594f89a21f906c2d20,2019-10-03T22:15Z,<S2SV_StartBug> int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; <S2SV_EndBug> <S2SV_StartBug> const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; <S2SV_EndBug>
179,CWE-200,"WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SLICE_HDR_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ; <S2SV_StartBug> if ( ! ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) ) <S2SV_EndBug> { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } ps_dec -> u2_total_mbs_coded = 0 ; } if ( ! ps_seq -> u1_frame_mbs_only_flag ) { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 1 ; ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic != 2 ) <S2SV_EndBug> { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; if ( i1_is_end_of_poc ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } } u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } <S2SV_StartBug> else if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; } } else { <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic ) <S2SV_EndBug> { prev_slice_err = 1 ; <S2SV_StartBug> num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; <S2SV_EndBug> } else { prev_slice_err = 2 ; <S2SV_StartBug> num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) <S2SV_EndBug> - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { <S2SV_StartBug> if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) <S2SV_EndBug> { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) <S2SV_StartBug> - ps_dec -> u2_total_mbs_coded ; <S2SV_EndBug> ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { ps_dec -> ps_decode_cur_slice ++ ; } ps_dec -> u1_slice_header_done = 0 ; if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { <S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_EndBug> ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }
","<S2SV_ModStart> -> u1_first_slice_in_stream && <S2SV_ModEnd> ps_dec -> u4_first_slice_in_pic <S2SV_ModStart> ps_dec -> u4_first_slice_in_pic <S2SV_ModEnd> ) { pocstruct_t <S2SV_ModStart> ps_dec -> u4_first_slice_in_pic == 0 <S2SV_ModEnd> ) { i1_is_end_of_poc <S2SV_ModStart> ps_dec -> u4_first_slice_in_pic <S2SV_ModEnd> ) { if <S2SV_ModStart> } else { prev_slice_err = 2 <S2SV_ModEnd> ; num_mb_skipped = <S2SV_ModStart> ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } } else { if ( ( <S2SV_ModStart> u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) <S2SV_ModEnd> { prev_slice_err = <S2SV_ModStart> ; num_mb_skipped = <S2SV_ModEnd> ( u2_first_mb_in_slice << <S2SV_ModStart> << u1_mbaff ) - <S2SV_ModEnd> ps_dec -> u2_total_mbs_coded <S2SV_ModStart> ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( <S2SV_ModEnd> ( u2_first_mb_in_slice << <S2SV_ModStart> << u1_mbaff ) <S2SV_ModEnd> < ps_dec -> <S2SV_ModStart> ps_dec -> u4_first_slice_in_pic <S2SV_ModEnd> ) { ret <S2SV_ModStart> ps_dec -> u4_first_slice_in_pic <S2SV_ModEnd> ) { if <S2SV_ModStart> { ps_dec -> <S2SV_ModEnd> u1_first_slice_in_stream = 0
",external@libavc/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,CVE-2017-0555,https://android.googlesource.com/platform/external/libavc/+/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,2017-04-07T22:59Z,<S2SV_StartBug> if ( ! ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic != 2 ) <S2SV_EndBug> <S2SV_StartBug> else if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic ) <S2SV_EndBug> <S2SV_StartBug> num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; <S2SV_EndBug> <S2SV_StartBug> num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) <S2SV_EndBug> <S2SV_StartBug> if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) <S2SV_EndBug> <S2SV_StartBug> - ps_dec -> u2_total_mbs_coded ; <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_EndBug>
6232,CWE-000,"static int makeDirDirective ( MaState * state , cchar * key , cchar * value ) { MprPath info ; char * auth , * dirs , * path , * perms , * tok ; cchar * dir , * group , * owner ; int gid , mode , uid ; if ( ! maTokenize ( state , value , ""%S<S2SV_blank>?*"" , & auth , & dirs ) ) { return MPR_ERR_BAD_SYNTAX ; } uid = gid = 0 ; mode = 0750 ; if ( schr ( auth , ':' ) ) { <S2SV_StartBug> owner = stok ( auth , "":"" , & tok ) ; <S2SV_EndBug> if ( owner && * owner ) { if ( snumber ( owner ) ) { uid = ( int ) stoi ( owner ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { uid = HTTP -> uid ; } else { uid = userToID ( owner ) ; } } <S2SV_StartBug> group = stok ( tok , "":"" , & perms ) ; <S2SV_EndBug> if ( group && * group ) { if ( snumber ( group ) ) { gid = ( int ) stoi ( group ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { gid = HTTP -> gid ; } else { gid = groupToID ( group ) ; } } if ( perms && snumber ( perms ) ) { mode = ( int ) stoiradix ( perms , - 1 , NULL ) ; } else { mode = 0 ; } if ( gid < 0 || uid < 0 ) { return MPR_ERR_BAD_SYNTAX ; } } else { dirs = auth ; auth = 0 ; } tok = dirs ; for ( tok = sclone ( dirs ) ; ( dir = stok ( tok , "","" , & tok ) ) != 0 ; ) { path = httpMakePath ( state -> route , state -> configDir , dir ) ; if ( mprGetPathInfo ( path , & info ) == 0 && info . isDir ) { continue ; } if ( mprMakeDir ( path , mode , uid , gid , 1 ) < 0 ) { return MPR_ERR_BAD_SYNTAX ; } } return 0 ; }
","<S2SV_ModStart> { owner = ssplit <S2SV_ModEnd> ( auth , <S2SV_ModStart> } group = ssplit <S2SV_ModEnd> ( tok ,
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,"<S2SV_StartBug> owner = stok ( auth , "":"" , & tok ) ; <S2SV_EndBug> <S2SV_StartBug> group = stok ( tok , "":"" , & perms ) ; <S2SV_EndBug>"
4160,CWE-20,"static int db_dict_iter_lookup_key_values ( struct db_dict_value_iter * iter ) { struct db_dict_iter_key * key ; string_t * path ; const char * error ; int ret ; array_sort ( & iter -> keys , db_dict_iter_key_cmp ) ; path = t_str_new ( 128 ) ; str_append ( path , DICT_PATH_SHARED ) ; array_foreach_modifiable ( & iter -> keys , key ) { if ( ! key -> used ) continue ; str_truncate ( path , strlen ( DICT_PATH_SHARED ) ) ; <S2SV_StartBug> ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , <S2SV_EndBug> <S2SV_StartBug> ""Failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , key -> key -> key , error ) ; <S2SV_EndBug> return - 1 ; } <S2SV_StartBug> ret = dict_lookup ( iter -> conn -> dict , iter -> pool , <S2SV_EndBug> str_c ( path ) , & key -> value , & error ) ; if ( ret > 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) , error ) ; return - 1 ; } else if ( key -> key -> default_value != NULL ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>%s"" , str_c ( path ) , key -> key -> default_value ) ; key -> value = key -> key -> default_value ; } else { return 0 ; } } return 1 ; }
","<S2SV_ModStart> ) ) ; str_append ( path , key -> key -> key ) ; ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value <S2SV_ModEnd> , & error <S2SV_ModStart> if ( ret > <S2SV_ModEnd> 0 ) { <S2SV_ModStart> 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { <S2SV_ModStart> , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) <S2SV_ModEnd> , error ) <S2SV_ModStart> 1 ; } <S2SV_ModEnd> else if (
",dovecot@core/000030feb7a30f193197f1aab8a7b04a26b42735,CVE-2017-2669,https://github.com/dovecot/core/commit/000030feb7a30f193197f1aab8a7b04a26b42735,2018-06-21T13:29Z,"<S2SV_StartBug> ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , <S2SV_EndBug> <S2SV_StartBug> ""Failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , key -> key -> key , error ) ; <S2SV_EndBug> <S2SV_StartBug> ret = dict_lookup ( iter -> conn -> dict , iter -> pool , <S2SV_EndBug>"
903,CWE-000,"static int ras_putdatastd ( jas_stream_t * out , ras_hdr_t * hdr , jas_image_t * image , int numcmpts , int * cmpts ) { int rowsize ; int pad ; unsigned int z ; int nz ; int c ; int x ; int y ; int v ; jas_matrix_t * data [ 3 ] ; int i ; <S2SV_StartBug> for ( i = 0 ; i < numcmpts ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( jas_image_height ( image ) , jas_image_width ( image ) ) ; <S2SV_EndBug> assert ( data [ i ] ) ; } rowsize = RAS_ROWSIZE ( hdr ) ; pad = rowsize - ( hdr -> width * hdr -> depth + 7 ) / 8 ; hdr -> length = hdr -> height * rowsize ; for ( y = 0 ; y < hdr -> height ; y ++ ) { for ( i = 0 ; i < numcmpts ; ++ i ) { if ( jas_image_readcmpt ( image , cmpts [ i ] , 0 , y , jas_image_width ( image ) , 1 , data [ i ] ) ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } } z = 0 ; nz = 0 ; for ( x = 0 ; x < hdr -> width ; x ++ ) { z <<= hdr -> depth ; if ( RAS_ISRGB ( hdr ) ) { v = RAS_RED ( ( jas_matrix_getv ( data [ 0 ] , x ) ) ) | RAS_GREEN ( ( jas_matrix_getv ( data [ 1 ] , x ) ) ) | RAS_BLUE ( ( jas_matrix_getv ( data [ 2 ] , x ) ) ) ; } else { v = ( jas_matrix_getv ( data [ 0 ] , x ) ) ; } z |= v & RAS_ONES ( hdr -> depth ) ; nz += hdr -> depth ; while ( nz >= 8 ) { c = ( z >> ( nz - 8 ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> nz -= 8 ; <S2SV_EndBug> z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { return - 1 ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { return - 1 ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; } return 0 ; }
","<S2SV_ModStart> int i ; assert ( numcmpts <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } <S2SV_ModStart> i ) { if ( ! ( <S2SV_ModStart> image ) ) ) ) { goto error ; } <S2SV_ModEnd> } rowsize = <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> EOF ) { goto error ; } nz -= 8 ; z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { goto error ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { goto error ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < numcmpts ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",mdadams@jasper/411a4068f8c464e883358bf403a3e25158863823,CVE-2016-9388,https://github.com/mdadams/jasper/commit/411a4068f8c464e883358bf403a3e25158863823,2017-03-23T18:59Z,"<S2SV_StartBug> for ( i = 0 ; i < numcmpts ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( jas_image_height ( image ) , jas_image_width ( image ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> nz -= 8 ; <S2SV_EndBug>"
7831,CWE-20,"error_t ipStringToAddr ( const char_t * str , IpAddr * ipAddr ) { error_t error ; # if ( IPV6_SUPPORT == ENABLED ) <S2SV_StartBug> if ( strchr ( str , ':' ) ) <S2SV_EndBug> { ipAddr -> length = sizeof ( Ipv6Addr ) ; error = ipv6StringToAddr ( str , & ipAddr -> ipv6Addr ) ; } else # endif # if ( IPV4_SUPPORT == ENABLED ) <S2SV_StartBug> if ( strchr ( str , '.' ) ) <S2SV_EndBug> { ipAddr -> length = sizeof ( Ipv4Addr ) ; error = ipv4StringToAddr ( str , & ipAddr -> ipv4Addr ) ; } else # endif { error = ERROR_FAILURE ; } return error ; }
","<S2SV_ModStart> ) if ( osStrchr <S2SV_ModEnd> ( str , <S2SV_ModStart> , ':' ) != NULL <S2SV_ModStart> ) if ( osStrchr <S2SV_ModEnd> ( str , <S2SV_ModStart> , '.' ) != NULL
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> if ( strchr ( str , ':' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( strchr ( str , '.' ) ) <S2SV_EndBug>"
4119,CWE-119,"void queue_push ( register Queue * qp , size_t extra_length , char const * info ) { register char * cp ; size_t memory_length ; size_t available_length ; size_t begin_length ; size_t n_begin ; size_t q_length ; if ( ! extra_length ) return ; memory_length = qp -> d_memory_end - qp -> d_memory ; q_length = qp -> d_read <= qp -> d_write ? ( size_t ) ( qp -> d_write - qp -> d_read ) : memory_length - ( qp -> d_read - qp -> d_write ) ; available_length = memory_length - q_length - 1 ; if ( message_show ( MSG_INFO ) ) message ( ""push_front<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>`%s\'"" , ( unsigned ) extra_length , info ) ; if ( extra_length > available_length ) { <S2SV_StartBug> memory_length += extra_length - available_length + BLOCK_QUEUE ; <S2SV_EndBug> cp = new_memory ( memory_length , sizeof ( char ) ) ; if ( message_show ( MSG_INFO ) ) message ( ""Reallocating<S2SV_blank>queue<S2SV_blank>at<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p"" , qp -> d_memory , cp ) ; if ( qp -> d_read > qp -> d_write ) { size_t tail_len = qp -> d_memory_end - qp -> d_read ; memcpy ( cp , qp -> d_read , tail_len ) ; memcpy ( cp + tail_len , qp -> d_memory , ( size_t ) ( qp -> d_write - qp -> d_memory ) ) ; qp -> d_write = cp + q_length ; qp -> d_read = cp ; } else { <S2SV_StartBug> memcpy ( cp , qp -> d_memory , memory_length ) ; <S2SV_EndBug> qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ; qp -> d_write = cp + ( qp -> d_write - qp -> d_memory ) ; } free ( qp -> d_memory ) ; qp -> d_memory_end = cp + memory_length ; qp -> d_memory = cp ; } begin_length = qp -> d_read - qp -> d_memory ; n_begin = extra_length <= begin_length ? extra_length : begin_length ; memcpy ( qp -> d_read -= n_begin , info + extra_length - n_begin , n_begin ) ; if ( extra_length > begin_length ) { extra_length -= begin_length ; memcpy ( qp -> d_read = qp -> d_memory_end - extra_length , info , extra_length ) ; } }
","<S2SV_ModStart> available_length ) { size_t original_length = memory_length ; <S2SV_ModStart> -> d_memory , original_length <S2SV_ModEnd> ) ; qp
",fbb-git@yodl/fd85f8c94182558ff1480d06a236d6fb927979a3,CVE-2016-10375,https://github.com/fbb-git/yodl/commit/fd85f8c94182558ff1480d06a236d6fb927979a3,2017-05-26T17:29Z,"<S2SV_StartBug> memory_length += extra_length - available_length + BLOCK_QUEUE ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( cp , qp -> d_memory , memory_length ) ; <S2SV_EndBug>"
4849,CWE-252,"size_t _dl_dst_count ( const char * name , int is_path ) { <S2SV_StartBug> size_t cnt = 0 ; <S2SV_EndBug> do { size_t len = 1 ; <S2SV_StartBug> if ( ( ( ( ! __libc_enable_secure <S2SV_EndBug> <S2SV_StartBug> && strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 ) <S2SV_EndBug> || ( strncmp ( & name [ 1 ] , ""PLATFORM"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( ! __libc_enable_secure <S2SV_StartBug> && strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( len = 9 ) != 0 ) <S2SV_EndBug> || ( strncmp ( & name [ 2 ] , ""PLATFORM}"" , 9 ) == 0 && ( len = 11 ) != 0 ) ) ) ) ++ cnt ; name = strchr ( name + len , '$' ) ; } while ( name != NULL ) ; return cnt ; }
","<S2SV_ModStart> is_path ) { const char * const start = name ; <S2SV_ModStart> ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN}"" , 6 ) == 0 && ( ! __libc_enable_secure || ( ( name [ 7 ] == '\\0' || ( is_path && name [ 7 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) ) && ( len = 7 ) != 0 ) || ( <S2SV_ModEnd> strncmp ( & <S2SV_ModStart> 1 ] , ""PLATFORM}"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && <S2SV_ModEnd> ( ! __libc_enable_secure <S2SV_ModStart> ( ! __libc_enable_secure || ( ( name [ 9 ] == '\\0' || ( is_path && name [ 9 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) ) <S2SV_ModEnd> && ( len
",bminor@glibc/2864e767053317538feafa815046fff89e5a16be,CVE-1999-0199,https://github.com/bminor/glibc/commit/2864e767053317538feafa815046fff89e5a16be,2020-10-06T13:15Z,"<S2SV_StartBug> size_t cnt = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( ( ! __libc_enable_secure <S2SV_EndBug> <S2SV_StartBug> && strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> && strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( len = 9 ) != 0 ) <S2SV_EndBug>"
904,CWE-119,"static int decode_bit_string ( const u8 * inbuf , size_t inlen , void * outbuf , size_t outlen , int invert ) { const u8 * in = inbuf ; u8 * out = ( u8 * ) outbuf ; <S2SV_StartBug> int zero_bits = * in & 0x07 ; <S2SV_EndBug> <S2SV_StartBug> size_t octets_left = inlen - 1 ; <S2SV_EndBug> <S2SV_StartBug> int i , count = 0 ; <S2SV_EndBug> memset ( outbuf , 0 , outlen ) ; in ++ ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 ) - zero_bits ; }
","<S2SV_ModStart> outbuf ; int i , count = 0 ; int zero_bits ; size_t octets_left ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; <S2SV_ModStart> & 0x07 ; <S2SV_ModEnd> octets_left = inlen <S2SV_ModStart> - 1 ; in ++ ; memset ( outbuf , 0 , outlen ) ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 <S2SV_ModEnd> ) - zero_bits
",OpenSC@OpenSC/412a6142c27a5973c61ba540e33cdc22d5608e68,CVE-2019-15945,https://github.com/OpenSC/OpenSC/commit/412a6142c27a5973c61ba540e33cdc22d5608e68,2019-09-05T17:15Z,"<S2SV_StartBug> int zero_bits = * in & 0x07 ; <S2SV_EndBug> <S2SV_StartBug> size_t octets_left = inlen - 1 ; <S2SV_EndBug> <S2SV_StartBug> int i , count = 0 ; <S2SV_EndBug>"
3834,CWE-264,"static ssize_t ib_uverbs_write ( struct file * filp , const char __user * buf , size_t count , loff_t * pos ) { struct ib_uverbs_file * file = filp -> private_data ; struct ib_device * ib_dev ; struct ib_uverbs_cmd_hdr hdr ; __u32 command ; __u32 flags ; int srcu_key ; ssize_t ret ; <S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug> return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof hdr ) ) return - EFAULT ; srcu_key = srcu_read_lock ( & file -> device -> disassociate_srcu ) ; ib_dev = srcu_dereference ( file -> device -> ib_dev , & file -> device -> disassociate_srcu ) ; if ( ! ib_dev ) { ret = - EIO ; goto out ; } if ( hdr . command & ~ ( __u32 ) ( IB_USER_VERBS_CMD_FLAGS_MASK | IB_USER_VERBS_CMD_COMMAND_MASK ) ) { ret = - EINVAL ; goto out ; } command = hdr . command & IB_USER_VERBS_CMD_COMMAND_MASK ; if ( verify_command_mask ( ib_dev , command ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( ! file -> ucontext && command != IB_USER_VERBS_CMD_GET_CONTEXT ) { ret = - EINVAL ; goto out ; } flags = ( hdr . command & IB_USER_VERBS_CMD_FLAGS_MASK ) >> IB_USER_VERBS_CMD_FLAGS_SHIFT ; if ( ! flags ) { if ( command >= ARRAY_SIZE ( uverbs_cmd_table ) || ! uverbs_cmd_table [ command ] ) { ret = - EINVAL ; goto out ; } if ( hdr . in_words * 4 != count ) { ret = - EINVAL ; goto out ; } ret = uverbs_cmd_table [ command ] ( file , ib_dev , buf + sizeof ( hdr ) , hdr . in_words * 4 , hdr . out_words * 4 ) ; } else if ( flags == IB_USER_VERBS_CMD_FLAG_EXTENDED ) { struct ib_uverbs_ex_cmd_hdr ex_hdr ; struct ib_udata ucore ; struct ib_udata uhw ; size_t written_count = count ; if ( command >= ARRAY_SIZE ( uverbs_ex_cmd_table ) || ! uverbs_ex_cmd_table [ command ] ) { ret = - ENOSYS ; goto out ; } if ( ! file -> ucontext ) { ret = - EINVAL ; goto out ; } if ( count < ( sizeof ( hdr ) + sizeof ( ex_hdr ) ) ) { ret = - EINVAL ; goto out ; } if ( copy_from_user ( & ex_hdr , buf + sizeof ( hdr ) , sizeof ( ex_hdr ) ) ) { ret = - EFAULT ; goto out ; } count -= sizeof ( hdr ) + sizeof ( ex_hdr ) ; buf += sizeof ( hdr ) + sizeof ( ex_hdr ) ; if ( ( hdr . in_words + ex_hdr . provider_in_words ) * 8 != count ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . cmd_hdr_reserved ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . response ) { if ( ! hdr . out_words && ! ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } if ( ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) ex_hdr . response , ( hdr . out_words + ex_hdr . provider_out_words ) * 8 ) ) { ret = - EFAULT ; goto out ; } } else { if ( hdr . out_words || ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } } INIT_UDATA_BUF_OR_NULL ( & ucore , buf , ( unsigned long ) ex_hdr . response , hdr . in_words * 8 , hdr . out_words * 8 ) ; INIT_UDATA_BUF_OR_NULL ( & uhw , buf + ucore . inlen , ( unsigned long ) ex_hdr . response + ucore . outlen , ex_hdr . provider_in_words * 8 , ex_hdr . provider_out_words * 8 ) ; ret = uverbs_ex_cmd_table [ command ] ( file , ib_dev , & ucore , & uhw ) ; if ( ! ret ) ret = written_count ; } else { ret = - ENOSYS ; } out : srcu_read_unlock ( & file -> device -> disassociate_srcu , srcu_key ) ; return ret ; }
","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (
",torvalds@linux/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,CVE-2016-4565,https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,2016-05-23T10:59Z,<S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug>
3902,CWE-119,"static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timespec ts ; __u32 ts_status ; <S2SV_StartBug> bool is_drop_n_account = false ; <S2SV_EndBug> BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h3 ) ) != 48 ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; else if ( skb -> pkt_type != PACKET_OUTGOING && ( skb -> ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary ( skb ) ) ) status |= TP_STATUS_CSUM_VALID ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned int maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ; <S2SV_StartBug> if ( po -> has_vnet_hdr ) <S2SV_EndBug> netoff += sizeof ( struct virtio_net_hdr ) ; <S2SV_StartBug> macoff = netoff - maclen ; <S2SV_EndBug> } if ( po -> tp_version <= TPACKET_V2 ) { if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) < sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ; <S2SV_StartBug> if ( ( int ) snaplen < 0 ) <S2SV_EndBug> <S2SV_StartBug> snaplen = 0 ; <S2SV_EndBug> } } else if ( unlikely ( macoff + snaplen > GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ) ) { u32 nval ; nval = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len - macoff ; pr_err_once ( ""tpacket_rcv:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>big,<S2SV_blank>clamped<S2SV_blank>from<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>%u.<S2SV_blank>macoff=%u\\n"" , snaplen , nval , macoff ) ; snaplen = nval ; if ( unlikely ( ( int ) snaplen < 0 ) ) { snaplen = 0 ; macoff = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ; <S2SV_StartBug> } <S2SV_EndBug> } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_rx_frame ( po , skb , TP_STATUS_KERNEL , ( macoff + snaplen ) ) ; if ( ! h . raw ) goto drop_n_account ; if ( po -> tp_version <= TPACKET_V2 ) { packet_increment_rx_head ( po , & po -> rx_ring ) ; if ( po -> stats . stats1 . tp_drops ) status |= TP_STATUS_LOSING ; } po -> stats . stats1 . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } spin_unlock ( & sk -> sk_receive_queue . lock ) ; <S2SV_StartBug> if ( po -> has_vnet_hdr ) { <S2SV_EndBug> if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) { spin_lock ( & sk -> sk_receive_queue . lock ) ; goto drop_n_account ; } } skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; if ( ! ( ts_status = tpacket_get_timestamp ( skb , & ts , po -> tp_tstamp ) ) ) getnstimeofday ( & ts ) ; status |= ts_status ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; h . h1 -> tp_sec = ts . tv_sec ; h . h1 -> tp_usec = ts . tv_nsec / NSEC_PER_USEC ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( skb_vlan_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = skb_vlan_tag_get ( skb ) ; h . h2 -> tp_vlan_tpid = ntohs ( skb -> vlan_proto ) ; status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; h . h2 -> tp_vlan_tpid = 0 ; } memset ( h . h2 -> tp_padding , 0 , sizeof ( h . h2 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h2 ) ; break ; case TPACKET_V3 : h . h3 -> tp_status |= status ; h . h3 -> tp_len = skb -> len ; h . h3 -> tp_snaplen = snaplen ; h . h3 -> tp_mac = macoff ; h . h3 -> tp_net = netoff ; h . h3 -> tp_sec = ts . tv_sec ; h . h3 -> tp_nsec = ts . tv_nsec ; memset ( h . h3 -> tp_padding , 0 , sizeof ( h . h3 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h3 ) ; break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 if ( po -> tp_version <= TPACKET_V2 ) { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } smp_wmb ( ) ; # endif if ( po -> tp_version <= TPACKET_V2 ) { __packet_set_status ( po , h . raw , status ) ; sk -> sk_data_ready ( sk ) ; } else { prb_clear_blk_fill_status ( & po -> rx_ring ) ; } drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : if ( ! is_drop_n_account ) consume_skb ( skb ) ; else kfree_skb ( skb ) ; return 0 ; drop_n_account : is_drop_n_account = true ; po -> stats . stats1 . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }
","<S2SV_ModStart> ; bool is_drop_n_account = false ; bool do_vnet <S2SV_ModStart> -> has_vnet_hdr ) { <S2SV_ModStart> virtio_net_hdr ) ; do_vnet = true ; } <S2SV_ModStart> < 0 ) { <S2SV_ModStart> = 0 ; do_vnet = false ; } <S2SV_ModStart> -> max_frame_len ; do_vnet = false ; <S2SV_ModStart> ; if ( do_vnet <S2SV_ModEnd> ) { if
",torvalds@linux/edbd58be15a957f6a760c4a514cd475217eb97fd,CVE-2017-14497,https://github.com/torvalds/linux/commit/edbd58be15a957f6a760c4a514cd475217eb97fd,2017-09-15T18:29Z,<S2SV_StartBug> bool is_drop_n_account = false ; <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) <S2SV_EndBug> <S2SV_StartBug> macoff = netoff - maclen ; <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) snaplen < 0 ) <S2SV_EndBug> <S2SV_StartBug> snaplen = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) { <S2SV_EndBug>
2474,CWE-772,"static Image * ReadARTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { const unsigned char * pixels ; Image * image ; QuantumInfo * quantum_info ; QuantumType quantum_type ; MagickBooleanType status ; size_t length ; ssize_t count , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 1 ; image -> endian = MSBEndian ; ( void ) ReadBlobLSBShort ( image ) ; image -> columns = ( size_t ) ReadBlobLSBShort ( image ) ; ( void ) ReadBlobLSBShort ( image ) ; image -> rows = ( size_t ) ReadBlobLSBShort ( image ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } SetImageColorspace ( image , GRAYColorspace ) ; quantum_type = IndexQuantum ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register PixelPacket * magick_restrict q ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) <S2SV_StartBug> ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; <S2SV_EndBug> ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; ( void ) ReadBlobStream ( image , ( size_t ) ( - ( ssize_t ) length ) & 0x01 , GetQuantumPixels ( quantum_info ) , & count ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) length ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> ""UnableToReadImageData"" ) ; }
",ImageMagick@ImageMagick/7b8c1df65b25d6671f113e2306982eded44ce3b4,CVE-2017-9143,https://github.com/ImageMagick/ImageMagick/commit/7b8c1df65b25d6671f113e2306982eded44ce3b4,2017-05-22T14:29Z,"<S2SV_StartBug> ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; <S2SV_EndBug>"
863,CWE-264,"static int pppol2tp_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct l2tp_session * session ; struct l2tp_tunnel * tunnel ; int val , len ; int err ; struct pppol2tp_session * ps ; if ( level != SOL_PPPOL2TP ) <S2SV_StartBug> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> if ( get_user ( len , optlen ) ) return - EFAULT ; len = min_t ( unsigned int , len , sizeof ( int ) ) ; if ( len < 0 ) return - EINVAL ; err = - ENOTCONN ; if ( sk -> sk_user_data == NULL ) goto end ; err = - EBADF ; session = pppol2tp_sock_to_session ( sk ) ; if ( session == NULL ) goto end ; ps = l2tp_session_priv ( session ) ; if ( ( session -> session_id == 0 ) && ( session -> peer_session_id == 0 ) ) { err = - EBADF ; tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; if ( tunnel == NULL ) goto end_put_sess ; err = pppol2tp_tunnel_getsockopt ( sk , tunnel , optname , & val ) ; sock_put ( ps -> tunnel_sock ) ; } else err = pppol2tp_session_getsockopt ( sk , session , optname , & val ) ; err = - EFAULT ; if ( put_user ( len , optlen ) ) goto end_put_sess ; if ( copy_to_user ( ( void __user * ) optval , & val , len ) ) goto end_put_sess ; err = 0 ; end_put_sess : sock_put ( sk ) ; end : return err ; }
","<S2SV_ModStart> SOL_PPPOL2TP ) return - EINVAL <S2SV_ModEnd> ; if (
",torvalds@linux/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf,CVE-2014-4943,https://github.com/torvalds/linux/commit/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf,2014-07-19T19:55Z,"<S2SV_StartBug> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug>"
2851,CWE-125,"static int lha_read_file_header_1 ( struct archive_read * a , struct lha * lha ) { const unsigned char * p ; size_t extdsize ; int i , err , err2 ; int namelen , padding ; unsigned char headersum , sum_calculated ; err = ARCHIVE_OK ; if ( ( p = __archive_read_ahead ( a , H1_FIXED_SIZE , NULL ) ) == NULL ) return ( truncated_error ( a ) ) ; lha -> header_size = p [ H1_HEADER_SIZE_OFFSET ] + 2 ; headersum = p [ H1_HEADER_SUM_OFFSET ] ; lha -> compsize = archive_le32dec ( p + H1_COMP_SIZE_OFFSET ) ; lha -> origsize = archive_le32dec ( p + H1_ORIG_SIZE_OFFSET ) ; lha -> mtime = lha_dos_time ( p + H1_DOS_TIME_OFFSET ) ; namelen = p [ H1_NAME_LEN_OFFSET ] ; padding = ( ( int ) lha -> header_size ) - H1_FIXED_SIZE - namelen ; if ( namelen > 230 || padding < 0 ) goto invalid ; if ( ( p = __archive_read_ahead ( a , lha -> header_size , NULL ) ) == NULL ) return ( truncated_error ( a ) ) ; for ( i = 0 ; i < namelen ; i ++ ) { if ( p [ i + H1_FILE_NAME_OFFSET ] == 0xff ) goto invalid ; } archive_strncpy ( & lha -> filename , p + H1_FILE_NAME_OFFSET , namelen ) ; lha -> crc = archive_le16dec ( p + H1_FILE_NAME_OFFSET + namelen ) ; lha -> setflag |= CRC_IS_SET ; sum_calculated = lha_calcsum ( 0 , p , 2 , lha -> header_size - 2 ) ; __archive_read_consume ( a , lha -> header_size - 2 ) ; err2 = lha_read_file_extended_header ( a , lha , NULL , 2 , ( size_t ) ( lha -> compsize + 2 ) , & extdsize ) ; if ( err2 < ARCHIVE_WARN ) return ( err2 ) ; if ( err2 < err ) err = err2 ; lha -> compsize -= extdsize - 2 ; <S2SV_StartBug> if ( sum_calculated != headersum ) { <S2SV_EndBug> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ; return ( ARCHIVE_FATAL ) ; } return ( err ) ; invalid : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>LHa<S2SV_blank>header"" ) ; return ( ARCHIVE_FATAL ) ; }
","<S2SV_ModStart> ; if ( lha -> compsize < 0 ) goto invalid ; if (
",libarchive@libarchive/98dcbbf0bf4854bf987557e55e55fff7abbf3ea9,CVE-2017-5601,https://github.com/libarchive/libarchive/commit/98dcbbf0bf4854bf987557e55e55fff7abbf3ea9,2017-01-27T22:59Z,<S2SV_StartBug> if ( sum_calculated != headersum ) { <S2SV_EndBug>
1876,CWE-119,"void vp9_reset_segment_features ( struct segmentation * seg ) { seg -> enabled = 0 ; seg -> update_map = 0 ; seg -> update_data = 0 ; <S2SV_StartBug> vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ; <S2SV_EndBug> vp9_clearall_segfeatures ( seg ) ; }
","<S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( seg ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ; <S2SV_EndBug>"
3450,CWE-000,"static int clie_5_attach ( struct usb_serial * serial ) { struct usb_serial_port * port ; unsigned int pipe ; int j ; <S2SV_StartBug> if ( serial -> num_ports < 2 ) <S2SV_EndBug> return - 1 ; port = serial -> port [ 0 ] ; port -> bulk_out_endpointAddress = serial -> port [ 1 ] -> bulk_out_endpointAddress ; pipe = usb_sndbulkpipe ( serial -> dev , port -> bulk_out_endpointAddress ) ; for ( j = 0 ; j < ARRAY_SIZE ( port -> write_urbs ) ; ++ j ) port -> write_urbs [ j ] -> pipe = pipe ; return 0 ; }
","<S2SV_ModStart> ( serial -> num_bulk_out <S2SV_ModEnd> < 2 ) <S2SV_ModStart> < 2 ) { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; } <S2SV_ModEnd> port = serial
",torvalds@linux/cb3232138e37129e88240a98a1d2aba2187ff57c,CVE-2015-7566,https://github.com/torvalds/linux/commit/cb3232138e37129e88240a98a1d2aba2187ff57c,2016-02-08T03:59Z,<S2SV_StartBug> if ( serial -> num_ports < 2 ) <S2SV_EndBug>
127,CWE-119,"static int fx_command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { struct effect_s * effect = ( struct effect_s * ) self ; if ( effect == NULL ) return - EINVAL ; switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) return - EINVAL ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_CONFIG : { if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_SET_CONFIG<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } * ( int * ) pReplyData = session_set_config ( effect -> session , ( effect_config_t * ) pCmdData ) ; if ( * ( int * ) pReplyData != 0 ) break ; if ( effect -> state != EFFECT_STATE_ACTIVE ) * ( int * ) pReplyData = effect_set_state ( effect , EFFECT_STATE_CONFIG ) ; } break ; case EFFECT_CMD_GET_CONFIG : if ( pReplyData == NULL || * replySize != sizeof ( effect_config_t ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_GET_CONFIG<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } session_get_config ( effect -> session , ( effect_config_t * ) pReplyData ) ; break ; case EFFECT_CMD_RESET : break ; case EFFECT_CMD_GET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) sizeof ( effect_param_t ) || pReplyData == NULL || <S2SV_StartBug> * replySize < ( int ) sizeof ( effect_param_t ) ) { <S2SV_EndBug> ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } effect_param_t * p = ( effect_param_t * ) pCmdData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + p -> psize ) ; p = ( effect_param_t * ) pReplyData ; p -> status = - ENOSYS ; } break ; case EFFECT_CMD_SET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) sizeof ( effect_param_t ) || pReplyData == NULL || * replySize != sizeof ( int32_t ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } effect_param_t * p = ( effect_param_t * ) pCmdData ; if ( p -> psize != sizeof ( int32_t ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>invalid<S2SV_blank>param<S2SV_blank>format"" ) ; return - EINVAL ; } * ( int * ) pReplyData = - ENOSYS ; } break ; case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_ENABLE<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } * ( int * ) pReplyData = effect_set_state ( effect , EFFECT_STATE_ACTIVE ) ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_DISABLE<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } * ( int * ) pReplyData = effect_set_state ( effect , EFFECT_STATE_CONFIG ) ; break ; case EFFECT_CMD_SET_DEVICE : case EFFECT_CMD_SET_INPUT_DEVICE : case EFFECT_CMD_SET_VOLUME : case EFFECT_CMD_SET_AUDIO_MODE : if ( pCmdData == NULL || cmdSize != sizeof ( uint32_t ) ) { ALOGV ( ""fx_command()<S2SV_blank>%s<S2SV_blank>invalid<S2SV_blank>args"" , cmdCode == EFFECT_CMD_SET_DEVICE ? ""EFFECT_CMD_SET_DEVICE"" : cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? ""EFFECT_CMD_SET_INPUT_DEVICE"" : cmdCode == EFFECT_CMD_SET_VOLUME ? ""EFFECT_CMD_SET_VOLUME"" : cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? ""EFFECT_CMD_SET_AUDIO_MODE"" : """" ) ; return - EINVAL ; } ALOGV ( ""fx_command()<S2SV_blank>%s<S2SV_blank>value<S2SV_blank>%08x"" , cmdCode == EFFECT_CMD_SET_DEVICE ? ""EFFECT_CMD_SET_DEVICE"" : cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? ""EFFECT_CMD_SET_INPUT_DEVICE"" : cmdCode == EFFECT_CMD_SET_VOLUME ? ""EFFECT_CMD_SET_VOLUME"" : cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? ""EFFECT_CMD_SET_AUDIO_MODE"" : """" , * ( int * ) pCmdData ) ; break ; default : return - EINVAL ; } return 0 ; }
","<S2SV_ModStart> ( int ) sizeof ( effect_param_t ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize -
",hardware@qcom@audio/073a80800f341325932c66818ce4302b312909a4,CVE-2016-3745,https://android.googlesource.com/platform/hardware/qcom/audio/+/073a80800f341325932c66818ce4302b312909a4,2016-07-11T01:59Z,<S2SV_StartBug> * replySize < ( int ) sizeof ( effect_param_t ) ) { <S2SV_EndBug>
845,CWE-119,"static int PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = ""PredictorEncodeTile"" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , ""Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>allocating<S2SV_blank>"" TIFF_SSIZE_FORMAT ""<S2SV_blank>byte<S2SV_blank>temp<S2SV_blank>buffer."" , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; <S2SV_StartBug> assert ( ( cc0 % rowsize ) == 0 ) ; <S2SV_EndBug> while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }
","<S2SV_ModStart> 0 ) ; if <S2SV_ModEnd> ( ( cc0 <S2SV_ModStart> % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ; return 0 ; } <S2SV_ModEnd> while ( cc
",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z,<S2SV_StartBug> assert ( ( cc0 % rowsize ) == 0 ) ; <S2SV_EndBug>
2981,CWE-119,"TEE_Result syscall_cryp_derive_key ( unsigned long state , const struct utee_attribute * usr_params , unsigned long param_count , unsigned long derived_key ) { TEE_Result res = TEE_ERROR_NOT_SUPPORTED ; struct tee_ta_session * sess ; struct tee_obj * ko ; struct tee_obj * so ; struct tee_cryp_state * cs ; struct tee_cryp_obj_secret * sk ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & ko ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , tee_svc_uref_to_vaddr ( derived_key ) , & so ) ; if ( res != TEE_SUCCESS ) goto out ; sk = so -> attr ; type_props = tee_svc_find_type_props ( so -> info . objectType ) ; if ( ! type_props ) { res = TEE_ERROR_NOT_SUPPORTED ; goto out ; } if ( cs -> algo == TEE_ALG_DH_DERIVE_SHARED_SECRET ) { size_t alloc_size ; struct bignum * pub ; struct bignum * ss ; if ( param_count != 1 || params [ 0 ] . attributeID != TEE_ATTR_DH_PUBLIC_VALUE ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } alloc_size = params [ 0 ] . content . ref . length * 8 ; pub = crypto_bignum_allocate ( alloc_size ) ; ss = crypto_bignum_allocate ( alloc_size ) ; if ( pub && ss ) { crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , pub ) ; res = crypto_acipher_dh_shared_secret ( ko -> attr , pub , ss ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = crypto_bignum_num_bytes ( ss ) ; crypto_bignum_bn2bin ( ss , ( uint8_t * ) ( sk + 1 ) ) ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } else { res = TEE_ERROR_OUT_OF_MEMORY ; } crypto_bignum_free ( pub ) ; crypto_bignum_free ( ss ) ; } else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_ECDH ) { size_t alloc_size ; struct ecc_public_key key_public ; uint8_t * pt_secret ; unsigned long pt_secret_len ; if ( param_count != 2 || params [ 0 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X || params [ 1 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_ECDH_P192 : alloc_size = 192 ; break ; case TEE_ALG_ECDH_P224 : alloc_size = 224 ; break ; case TEE_ALG_ECDH_P256 : alloc_size = 256 ; break ; case TEE_ALG_ECDH_P384 : alloc_size = 384 ; break ; case TEE_ALG_ECDH_P521 : alloc_size = 521 ; break ; default : res = TEE_ERROR_NOT_IMPLEMENTED ; goto out ; } res = crypto_acipher_alloc_ecc_public_key ( & key_public , alloc_size ) ; if ( res != TEE_SUCCESS ) goto out ; key_public . curve = ( ( struct ecc_keypair * ) ko -> attr ) -> curve ; crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , key_public . x ) ; crypto_bignum_bin2bn ( params [ 1 ] . content . ref . buffer , params [ 1 ] . content . ref . length , key_public . y ) ; pt_secret = ( uint8_t * ) ( sk + 1 ) ; pt_secret_len = sk -> alloc_size ; res = crypto_acipher_ecc_shared_secret ( ko -> attr , & key_public , pt_secret , & pt_secret_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = pt_secret_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } crypto_acipher_free_ecc_public_key ( & key_public ) ; } # if defined ( CFG_CRYPTO_HKDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_HKDF ) { void * salt , * info ; size_t salt_len , info_len , okm_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ik = ko -> attr ; const uint8_t * ikm = ( const uint8_t * ) ( ik + 1 ) ; res = get_hkdf_params ( params , param_count , & salt , & salt_len , & info , & info_len , & okm_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( okm_len > ik -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_hkdf ( hash_id , ikm , ik -> key_size , salt , salt_len , info , info_len , ( uint8_t * ) ( sk + 1 ) , okm_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = okm_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_CONCAT_KDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_CONCAT_KDF ) { void * info ; size_t info_len , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * shared_secret = ( const uint8_t * ) ( ss + 1 ) ; res = get_concat_kdf_params ( params , param_count , & info , & info_len , & derived_key_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_concat_kdf ( hash_id , shared_secret , ss -> key_size , info , info_len , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_PBKDF2 ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_PBKDF2 ) { void * salt ; size_t salt_len , iteration_count , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * password = ( const uint8_t * ) ( ss + 1 ) ; res = get_pbkdf2_params ( params , param_count , & salt , & salt_len , & derived_key_len , & iteration_count ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_pbkdf2 ( hash_id , password , ss -> key_size , salt , salt_len , iteration_count , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif else res = TEE_ERROR_NOT_SUPPORTED ; out : free ( params ) ; return res ; }
","<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
",OP-TEE@optee_os/a637243270fc1faae16de059091795c32d86e65e,CVE-2019-1010297,https://github.com/OP-TEE/optee_os/commit/a637243270fc1faae16de059091795c32d86e65e,2019-07-15T18:15Z,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug>
1988,CWE-119,"vpx_codec_err_t vpx_codec_set_frame_buffer_functions ( vpx_codec_ctx_t * ctx , vpx_get_frame_buffer_cb_fn_t cb_get , vpx_release_frame_buffer_cb_fn_t cb_release , void * cb_priv ) { vpx_codec_err_t res ; if ( ! ctx || ! cb_get || ! cb_release ) { res = VPX_CODEC_INVALID_PARAM ; } else if ( ! ctx -> iface || ! ctx -> priv || ! ( ctx -> iface -> caps & VPX_CODEC_CAP_EXTERNAL_FRAME_BUFFER ) ) { res = VPX_CODEC_ERROR ; } else { <S2SV_StartBug> res = ctx -> iface -> dec . set_fb_fn ( ctx -> priv -> alg_priv , cb_get , cb_release , <S2SV_EndBug> cb_priv ) ; } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> . set_fb_fn ( get_alg_priv ( ctx ) <S2SV_ModEnd> , cb_get ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> res = ctx -> iface -> dec . set_fb_fn ( ctx -> priv -> alg_priv , cb_get , cb_release , <S2SV_EndBug>"
4117,CWE-20,"int auth_password ( Authctxt * authctxt , const char * password ) { struct passwd * pw = authctxt -> pw ; int result , ok = authctxt -> valid ; # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) static int expire_checked = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> # ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ; # endif if ( * password == '\\0' && options . permit_empty_passwd == 0 ) return 0 ; # ifdef KRB5 if ( options . kerberos_authentication == 1 ) { int ret = auth_krb5_password ( authctxt , password ) ; if ( ret == 1 || ret == 0 ) return ret && ok ; } # endif # ifdef HAVE_CYGWIN { HANDLE hToken = cygwin_logon_user ( pw , password ) ; if ( hToken == INVALID_HANDLE_VALUE ) return 0 ; cygwin_set_impersonation_token ( hToken ) ; return ok ; } # endif # ifdef USE_PAM if ( options . use_pam ) return ( sshpam_auth_passwd ( authctxt , password ) && ok ) ; # endif # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) if ( ! expire_checked ) { expire_checked = 1 ; if ( auth_shadow_pwexpired ( authctxt ) ) authctxt -> force_pwchange = 1 ; } # endif result = sys_auth_passwd ( authctxt , password ) ; if ( authctxt -> force_pwchange ) disable_forwarding ( ) ; return ( result && ok ) ; }
","<S2SV_ModStart> ; # endif if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ;
",openssh@openssh-portable/fcd135c9df440bcd2d5870405ad3311743d78d97,CVE-2016-6515,https://github.com/openssh/openssh-portable/commit/fcd135c9df440bcd2d5870405ad3311743d78d97,2016-08-07T21:59Z,<S2SV_StartBug> # endif <S2SV_EndBug>
6068,CWE-000,"static void mpage_put_bnr_to_bhs ( struct mpage_da_data * mpd , sector_t logical , struct buffer_head * exbh ) { struct inode * inode = mpd -> inode ; struct address_space * mapping = inode -> i_mapping ; int blocks = exbh -> b_size >> inode -> i_blkbits ; sector_t pblock = exbh -> b_blocknr , cur_logical ; struct buffer_head * head , * bh ; pgoff_t index , end ; struct pagevec pvec ; int nr_pages , i ; index = logical >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; end = ( logical + blocks - 1 ) >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; cur_logical = index << ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; pagevec_init ( & pvec , 0 ) ; while ( index <= end ) { nr_pages = pagevec_lookup ( & pvec , mapping , index , PAGEVEC_SIZE ) ; if ( nr_pages == 0 ) break ; for ( i = 0 ; i < nr_pages ; i ++ ) { struct page * page = pvec . pages [ i ] ; index = page -> index ; if ( index > end ) break ; index ++ ; BUG_ON ( ! PageLocked ( page ) ) ; BUG_ON ( PageWriteback ( page ) ) ; BUG_ON ( ! page_has_buffers ( page ) ) ; bh = page_buffers ( page ) ; head = bh ; do { if ( cur_logical >= logical ) break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do { if ( cur_logical >= logical + blocks ) break ; if ( buffer_delay ( bh ) || buffer_unwritten ( bh ) ) { BUG_ON ( bh -> b_bdev != inode -> i_sb -> s_bdev ) ; if ( buffer_delay ( bh ) ) { clear_buffer_delay ( bh ) ; bh -> b_blocknr = pblock ; } else { clear_buffer_unwritten ( bh ) ; BUG_ON ( bh -> b_blocknr != pblock ) ; } } else if ( buffer_mapped ( bh ) ) BUG_ON ( bh -> b_blocknr != pblock ) ; <S2SV_StartBug> cur_logical ++ ; <S2SV_EndBug> pblock ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; } pagevec_release ( & pvec ) ; } }
","<S2SV_ModStart> pblock ) ; if ( buffer_uninit ( exbh ) ) set_buffer_uninit ( bh ) ;
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,<S2SV_StartBug> cur_logical ++ ; <S2SV_EndBug>
2574,CWE-000,"OM_uint32 kg_unseal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int * conf_state , gss_qop_t * qop_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; OM_uint32 code ; ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_STREAM ) != NULL ) { code = kg_unseal_stream_iov ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } else { code = kg_unseal_iov_token ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } return code ; }
","<S2SV_ModStart> ; if ( ctx -> terminated ||
",krb5@krb5/82dc33da50338ac84c7b4102dc6513d897d0506a,CVE-2014-5352,https://github.com/krb5/krb5/commit/82dc33da50338ac84c7b4102dc6513d897d0506a,2015-02-19T11:59Z,<S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug>
3325,CWE-399,"static int process_one_ticket ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , <S2SV_StartBug> void * * p , void * end , <S2SV_EndBug> void * dbuf , void * ticket_buf ) { struct ceph_x_info * xi = ac -> private ; int type ; u8 tkt_struct_v , blob_struct_v ; struct ceph_x_ticket_handler * th ; <S2SV_StartBug> void * dp , * dend ; <S2SV_EndBug> int dlen ; char is_enc ; struct timespec validity ; <S2SV_StartBug> struct ceph_crypto_key old_key ; <S2SV_EndBug> void * tp , * tpend ; struct ceph_timespec new_validity ; struct ceph_crypto_key new_session_key ; struct ceph_buffer * new_ticket_blob ; unsigned long new_expires , new_renew_after ; u64 new_secret_id ; int ret ; ceph_decode_need ( p , end , sizeof ( u32 ) + 1 , bad ) ; type = ceph_decode_32 ( p ) ; dout ( ""<S2SV_blank>ticket<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>%s\\n"" , type , ceph_entity_type_name ( type ) ) ; tkt_struct_v = ceph_decode_8 ( p ) ; if ( tkt_struct_v != 1 ) goto bad ; th = get_ticket_handler ( ac , type ) ; if ( IS_ERR ( th ) ) { ret = PTR_ERR ( th ) ; goto out ; } <S2SV_StartBug> dlen = ceph_x_decrypt ( secret , p , end , dbuf , <S2SV_EndBug> TEMP_TICKET_BUF_LEN ) ; if ( dlen <= 0 ) { ret = dlen ; goto out ; } dout ( ""<S2SV_blank>decrypted<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dlen ) ; dp = dbuf ; dend = dp + dlen ; tkt_struct_v = ceph_decode_8 ( & dp ) ; if ( tkt_struct_v != 1 ) goto bad ; memcpy ( & old_key , & th -> session_key , sizeof ( old_key ) ) ; ret = ceph_crypto_key_decode ( & new_session_key , & dp , dend ) ; if ( ret ) goto out ; ceph_decode_copy ( & dp , & new_validity , sizeof ( new_validity ) ) ; ceph_decode_timespec ( & validity , & new_validity ) ; new_expires = get_seconds ( ) + validity . tv_sec ; new_renew_after = new_expires - ( validity . tv_sec / 4 ) ; dout ( ""<S2SV_blank>expires=%lu<S2SV_blank>renew_after=%lu\\n"" , new_expires , new_renew_after ) ; ceph_decode_8_safe ( p , end , is_enc , bad ) ; <S2SV_StartBug> tp = ticket_buf ; <S2SV_EndBug> if ( is_enc ) { dout ( ""<S2SV_blank>encrypted<S2SV_blank>ticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , ticket_buf , TEMP_TICKET_BUF_LEN ) ; if ( dlen < 0 ) { ret = dlen ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> dlen = ceph_decode_32 ( & tp ) ; } else { ceph_decode_32_safe ( p , end , dlen , bad ) ; <S2SV_StartBug> ceph_decode_need ( p , end , dlen , bad ) ; <S2SV_EndBug> ceph_decode_copy ( p , ticket_buf , dlen ) ; } tpend = tp + dlen ; dout ( ""<S2SV_blank>ticket<S2SV_blank>blob<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dlen ) ; ceph_decode_need ( & tp , tpend , 1 + sizeof ( u64 ) , bad ) ; blob_struct_v = ceph_decode_8 ( & tp ) ; new_secret_id = ceph_decode_64 ( & tp ) ; ret = ceph_decode_buffer ( & new_ticket_blob , & tp , tpend ) ; if ( ret ) goto out ; ceph_crypto_key_destroy ( & th -> session_key ) ; if ( th -> ticket_blob ) ceph_buffer_put ( th -> ticket_blob ) ; th -> session_key = new_session_key ; th -> ticket_blob = new_ticket_blob ; th -> validity = new_validity ; th -> secret_id = new_secret_id ; th -> expires = new_expires ; th -> renew_after = new_renew_after ; dout ( ""<S2SV_blank>got<S2SV_blank>ticket<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>(%s)<S2SV_blank>secret_id<S2SV_blank>%lld<S2SV_blank>len<S2SV_blank>%d\\n"" , type , ceph_entity_type_name ( type ) , th -> secret_id , ( int ) th -> ticket_blob -> vec . iov_len ) ; xi -> have_keys |= th -> service ; out : <S2SV_StartBug> return ret ; <S2SV_EndBug> bad : ret = - EINVAL ; goto out ; }
","<S2SV_ModStart> void * end <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; void * dbuf = NULL ; void * <S2SV_ModStart> struct ceph_crypto_key old_key ; void * ticket_buf = NULL <S2SV_ModStart> , end , & dbuf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> bad ) ; if ( is_enc ) { dout ( ""<S2SV_blank>encrypted<S2SV_blank>ticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> out ; } tp = ticket_buf ; <S2SV_ModStart> bad ) ; ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> ; out : kfree ( ticket_buf ) ; kfree ( dbuf ) ;
",torvalds@linux/c27a3e4d667fdcad3db7b104f75659478e0c68d8,CVE-2014-6418,https://github.com/torvalds/linux/commit/c27a3e4d667fdcad3db7b104f75659478e0c68d8,2014-09-28T10:55Z,"<S2SV_StartBug> void * * p , void * end , <S2SV_EndBug> <S2SV_StartBug> void * dp , * dend ; <S2SV_EndBug> <S2SV_StartBug> struct ceph_crypto_key old_key ; <S2SV_EndBug> <S2SV_StartBug> dlen = ceph_x_decrypt ( secret , p , end , dbuf , <S2SV_EndBug> <S2SV_StartBug> tp = ticket_buf ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ceph_decode_need ( p , end , dlen , bad ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug>"
6343,CWE-772,"gstrings_ret * get_strings_2_svc ( gstrings_arg * arg , struct svc_req * rqstp ) { static gstrings_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gstrings_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_GET ; log_unauth ( ""kadm5_get_strings"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_strings ( ( void * ) handle , arg -> princ , & ret . strings , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_strings"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug>"
1219,CWE-436,"static gssize find_auth_end ( FlatpakProxyClient * client , Buffer * buffer ) { <S2SV_StartBug> guchar * match ; <S2SV_EndBug> int i ; if ( client -> auth_end_offset > 0 ) { gsize left = strlen ( AUTH_END_STRING ) - client -> auth_end_offset ; <S2SV_StartBug> gsize to_match = MIN ( left , buffer -> pos ) ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) <S2SV_EndBug> { client -> auth_end_offset += to_match ; if ( client -> auth_end_offset == strlen ( AUTH_END_STRING ) ) return to_match ; return - 1 ; } client -> auth_end_offset = - 1 ; } match = memmem ( buffer , buffer -> pos , AUTH_END_STRING , strlen ( AUTH_END_STRING ) ) ; if ( match != NULL ) <S2SV_StartBug> return match - buffer -> data + strlen ( AUTH_END_STRING ) ; <S2SV_EndBug> for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ; i > 0 ; i -- ) { if ( memcmp ( buffer -> data + buffer -> pos - i , AUTH_END_STRING , i ) == 0 ) { client -> auth_end_offset = i ; break ; } } return - 1 ; }
","<S2SV_ModStart> buffer ) { goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer <S2SV_ModEnd> , buffer -> <S2SV_ModStart> , buffer -> data , buffer -> <S2SV_ModStart> pos ) ; while ( TRUE ) { guint8 * line_start = client -> auth_buffer <S2SV_ModEnd> -> data + <S2SV_ModStart> -> data + offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",flatpak@flatpak/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6,CVE-2018-6560,https://github.com/flatpak/flatpak/commit/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6,2018-02-02T14:29Z,"<S2SV_StartBug> guchar * match ; <S2SV_EndBug> <S2SV_StartBug> gsize to_match = MIN ( left , buffer -> pos ) ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> return match - buffer -> data + strlen ( AUTH_END_STRING ) ; <S2SV_EndBug>"
3685,CWE-189,"static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ; krb5_key_data * key_data ; if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; if ( key_data_in == NULL ) goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { krb5_data * code ; if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) { ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ; if ( ret [ j ] == NULL ) goto cleanup ; err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ; if ( err ) goto cleanup ; ret [ j ] -> bv_len = code -> length ; ret [ j ] -> bv_val = code -> data ; free ( code ) ; j ++ ; last = i + 1 ; <S2SV_StartBug> currkvno = key_data [ i ] . key_data_kvno ; <S2SV_EndBug> } } ret [ num_versions ] = NULL ; cleanup : free ( key_data ) ; if ( err != 0 ) { if ( ret != NULL ) { for ( i = 0 ; i <= num_versions ; i ++ ) if ( ret [ i ] != NULL ) free ( ret [ i ] ) ; free ( ret ) ; ret = NULL ; } } return ret ; }
","<S2SV_ModStart> + 1 ; if ( i < n_key_data - 1 ) <S2SV_ModStart> key_data [ i + 1
",krb5@krb5/dc7ed55c689d57de7f7408b34631bf06fec9dab1,CVE-2014-4345,https://github.com/krb5/krb5/commit/dc7ed55c689d57de7f7408b34631bf06fec9dab1,2014-08-14T05:01Z,<S2SV_StartBug> currkvno = key_data [ i ] . key_data_kvno ; <S2SV_EndBug>
3717,CWE-000,"static int jpc_dec_tiledecode ( jpc_dec_t * dec , jpc_dec_tile_t * tile ) { int i ; int j ; jpc_dec_tcomp_t * tcomp ; jpc_dec_rlvl_t * rlvl ; jpc_dec_band_t * band ; int compno ; int rlvlno ; int bandno ; int adjust ; int v ; jpc_dec_ccp_t * ccp ; jpc_dec_cmpt_t * cmpt ; if ( jpc_dec_decodecblks ( dec , tile ) ) { jas_eprintf ( ""jpc_dec_decodecblks<S2SV_blank>failed\\n"" ) ; return - 1 ; } for ( compno = 0 , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ tcomp ) { ccp = & tile -> cp -> ccps [ compno ] ; for ( rlvlno = 0 , rlvl = tcomp -> rlvls ; rlvlno < tcomp -> numrlvls ; ++ rlvlno , ++ rlvl ) { if ( ! rlvl -> bands ) { continue ; } for ( bandno = 0 , band = rlvl -> bands ; bandno < rlvl -> numbands ; ++ bandno , ++ band ) { if ( ! band -> data ) { continue ; } jpc_undo_roi ( band -> data , band -> roishift , ccp -> roishift - band -> roishift , band -> numbps ) ; if ( tile -> realmode ) { jas_matrix_asl ( band -> data , JPC_FIX_FRACBITS ) ; jpc_dequantize ( band -> data , band -> absstepsize ) ; } } } } for ( compno = 0 , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ tcomp ) { ccp = & tile -> cp -> ccps [ compno ] ; jpc_tsfb_synthesize ( tcomp -> tsfb , tcomp -> data ) ; } switch ( tile -> cp -> mctid ) { case JPC_MCT_RCT : if ( dec -> numcomps < 3 ) { <S2SV_StartBug> jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n"" ) ; <S2SV_EndBug> return - 1 ; } jpc_irct ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , tile -> tcomps [ 2 ] . data ) ; break ; case JPC_MCT_ICT : if ( dec -> numcomps < 3 ) { jas_eprintf ( ""ICT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n"" ) ; return - 1 ; } <S2SV_StartBug> jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , <S2SV_EndBug> tile -> tcomps [ 2 ] . data ) ; break ; } if ( tile -> realmode ) { for ( compno = 0 , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ tcomp ) { for ( i = 0 ; i < jas_matrix_numrows ( tcomp -> data ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( tcomp -> data ) ; ++ j ) { v = jas_matrix_get ( tcomp -> data , i , j ) ; v = jpc_fix_round ( v ) ; jas_matrix_set ( tcomp -> data , i , j , jpc_fixtoint ( v ) ) ; } } } } for ( compno = 0 , tcomp = tile -> tcomps , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ tcomp , ++ cmpt ) { adjust = cmpt -> sgnd ? 0 : ( 1 << ( cmpt -> prec - 1 ) ) ; for ( i = 0 ; i < jas_matrix_numrows ( tcomp -> data ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( tcomp -> data ) ; ++ j ) { * jas_matrix_getref ( tcomp -> data , i , j ) += adjust ; } } } for ( compno = 0 , tcomp = tile -> tcomps , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ tcomp , ++ cmpt ) { jpc_fix_t mn ; jpc_fix_t mx ; mn = cmpt -> sgnd ? ( - ( 1 << ( cmpt -> prec - 1 ) ) ) : ( 0 ) ; mx = cmpt -> sgnd ? ( ( 1 << ( cmpt -> prec - 1 ) ) - 1 ) : ( ( 1 << cmpt -> prec ) - 1 ) ; jas_matrix_clip ( tcomp -> data , mn , mx ) ; } for ( compno = 0 , tcomp = tile -> tcomps , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ tcomp , ++ cmpt ) { if ( jas_image_writecmpt ( dec -> image , compno , tcomp -> xstart - JPC_CEILDIV ( dec -> xstart , cmpt -> hstep ) , tcomp -> ystart - JPC_CEILDIV ( dec -> ystart , cmpt -> vstep ) , jas_matrix_numcols ( tcomp -> data ) , jas_matrix_numrows ( tcomp -> data ) , tcomp -> data ) ) { jas_eprintf ( ""write<S2SV_blank>component<S2SV_blank>failed\\n"" ) ; return - 1 ; } } return 0 ; }
","<S2SV_ModStart> jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n"" ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n"" <S2SV_ModStart> 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n"" ) ; return - 1 ; }
",mdadams@jasper/dee11ec440d7908d1daf69f40a3324b27cf213ba,CVE-2016-9389,https://github.com/mdadams/jasper/commit/dee11ec440d7908d1daf69f40a3324b27cf213ba,2017-03-23T18:59Z,"<S2SV_StartBug> jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , <S2SV_EndBug>"
3361,CWE-264,"static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) { struct sk_buff * skb ; <S2SV_StartBug> int err ; <S2SV_EndBug> if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { <S2SV_StartBug> struct frag_hdr fhdr ; <S2SV_EndBug> skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> protocol = htons ( ETH_P_IPV6 ) ; <S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> skb -> csum = 0 ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; ipv6_select_ident ( & fhdr , rt ) ; skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; <S2SV_StartBug> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_EndBug> } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; }
","<S2SV_ModStart> * skb ; struct frag_hdr fhdr ; <S2SV_ModStart> NULL ) { <S2SV_ModEnd> skb = sock_alloc_send_skb <S2SV_ModStart> ; skb -> csum = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart> ip_summed = CHECKSUM_PARTIAL <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> . identification ; append : <S2SV_ModEnd> return skb_append_datato_frags (
",torvalds@linux/c547dbf55d5f8cf615ccc0e7265e98db27d3fb8b,CVE-2013-4470,https://github.com/torvalds/linux/commit/c547dbf55d5f8cf615ccc0e7265e98db27d3fb8b,2013-11-04T15:55Z,"<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> struct frag_hdr fhdr ; <S2SV_EndBug> <S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> <S2SV_StartBug> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_EndBug>"
695,CWE-189,"static int32 makepol ( QPRS_STATE * state ) { int32 val = 0 , type ; int32 lenval = 0 ; char * strval = NULL ; int32 stack [ STACKDEPTH ] ; int32 lenstack = 0 ; uint16 flag = 0 ; <S2SV_StartBug> while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) <S2SV_EndBug> { switch ( type ) { case VAL : pushval_asis ( state , VAL , strval , lenval , flag ) ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case OPR : if ( lenstack && val == ( int32 ) '|' ) pushquery ( state , OPR , val , 0 , 0 , 0 ) ; else { if ( lenstack == STACKDEPTH ) elog ( ERROR , ""stack<S2SV_blank>too<S2SV_blank>short"" ) ; stack [ lenstack ] = val ; lenstack ++ ; } break ; case OPEN : if ( makepol ( state ) == ERR ) return ERR ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case CLOSE : while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; break ; case ERR : default : ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) ) ) ; return ERR ; } } while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; }
","<S2SV_ModStart> = 0 ; check_stack_depth ( ) ;
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,"<S2SV_StartBug> while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) <S2SV_EndBug>"
3815,CWE-77,"static void cmd_parse_lsub ( struct ImapData * idata , char * s ) { char buf [ STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct Url url ; struct ImapList list ; if ( idata -> cmddata && idata -> cmdtype == IMAP_CT_LIST ) { cmd_parse_list ( idata , s ) ; return ; } if ( ! ImapCheckSubscribed ) return ; idata -> cmdtype = IMAP_CT_LIST ; idata -> cmddata = & list ; cmd_parse_list ( idata , s ) ; idata -> cmddata = NULL ; if ( ! list . name || list . noselect ) return ; mutt_debug ( 3 , ""Subscribing<S2SV_blank>to<S2SV_blank>%s\\n"" , list . name ) ; mutt_str_strfcpy ( buf , ""mailboxes<S2SV_blank>\\"""" , sizeof ( buf ) ) ; mutt_account_tourl ( & idata -> conn -> account , & url ) ; <S2SV_StartBug> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <S2SV_EndBug> url . path = errstr + 1 ; url . path [ strlen ( url . path ) - 1 ] = '\\0' ; if ( mutt_str_strcmp ( url . user , ImapUser ) == 0 ) url . user = NULL ; url_tostring ( & url , buf + 11 , sizeof ( buf ) - 11 , 0 ) ; mutt_str_strcat ( buf , sizeof ( buf ) , ""\\"""" ) ; mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; if ( mutt_parse_rc_line ( buf , & token , & err ) ) mutt_debug ( 1 , ""Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\n"" , errstr ) ; FREE ( & token . data ) ; }
","<S2SV_ModStart> list . name , true
",neomutt@neomutt/e52393740334443ae0206cab2d7caef381646725,CVE-2018-14357,https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725,2018-07-17T17:29Z,"<S2SV_StartBug> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <S2SV_EndBug>"
8134,CWE-754,"void sqlite3Pragma ( Parse * pParse , Token * pId1 , Token * pId2 , Token * pValue , int minusFlag ) { char * zLeft = 0 ; char * zRight = 0 ; const char * zDb = 0 ; Token * pId ; char * aFcntl [ 4 ] ; int iDb ; int rc ; sqlite3 * db = pParse -> db ; Db * pDb ; Vdbe * v = sqlite3GetVdbe ( pParse ) ; const PragmaName * pPragma ; if ( v == 0 ) return ; sqlite3VdbeRunOnlyOnce ( v ) ; pParse -> nMem = 2 ; iDb = sqlite3TwoPartName ( pParse , pId1 , pId2 , & pId ) ; if ( iDb < 0 ) return ; pDb = & db -> aDb [ iDb ] ; if ( iDb == 1 && sqlite3OpenTempDatabase ( pParse ) ) { return ; } zLeft = sqlite3NameFromToken ( db , pId ) ; if ( ! zLeft ) return ; if ( minusFlag ) { zRight = sqlite3MPrintf ( db , ""-%T"" , pValue ) ; } else { zRight = sqlite3NameFromToken ( db , pValue ) ; } assert ( pId2 ) ; zDb = pId2 -> n > 0 ? pDb -> zDbSName : 0 ; if ( sqlite3AuthCheck ( pParse , SQLITE_PRAGMA , zLeft , zRight , zDb ) ) { goto pragma_out ; } aFcntl [ 0 ] = 0 ; aFcntl [ 1 ] = zLeft ; aFcntl [ 2 ] = zRight ; aFcntl [ 3 ] = 0 ; db -> busyHandler . nBusy = 0 ; rc = sqlite3_file_control ( db , zDb , SQLITE_FCNTL_PRAGMA , ( void * ) aFcntl ) ; if ( rc == SQLITE_OK ) { sqlite3VdbeSetNumCols ( v , 1 ) ; sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , aFcntl [ 0 ] , SQLITE_TRANSIENT ) ; returnSingleText ( v , aFcntl [ 0 ] ) ; sqlite3_free ( aFcntl [ 0 ] ) ; goto pragma_out ; } if ( rc != SQLITE_NOTFOUND ) { if ( aFcntl [ 0 ] ) { sqlite3ErrorMsg ( pParse , ""%s"" , aFcntl [ 0 ] ) ; sqlite3_free ( aFcntl [ 0 ] ) ; } pParse -> nErr ++ ; pParse -> rc = rc ; goto pragma_out ; } pPragma = pragmaLocate ( zLeft ) ; if ( pPragma == 0 ) goto pragma_out ; if ( ( pPragma -> mPragFlg & PragFlg_NeedSchema ) != 0 ) { if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; } if ( ( pPragma -> mPragFlg & PragFlg_NoColumns ) == 0 && ( ( pPragma -> mPragFlg & PragFlg_NoColumns1 ) == 0 || zRight == 0 ) ) { setPragmaResultColumnNames ( v , pPragma ) ; } switch ( pPragma -> ePragTyp ) { # if ! defined ( SQLITE_OMIT_PAGER_PRAGMAS ) && ! defined ( SQLITE_OMIT_DEPRECATED ) case PragTyp_DEFAULT_CACHE_SIZE : { static const int iLn = VDBE_OFFSET_LINENO ( 2 ) ; static const VdbeOpList getCacheSize [ ] = { { OP_Transaction , 0 , 0 , 0 } , { OP_ReadCookie , 0 , 1 , BTREE_DEFAULT_CACHE_SIZE } , { OP_IfPos , 1 , 8 , 0 } , { OP_Integer , 0 , 2 , 0 } , { OP_Subtract , 1 , 2 , 1 } , { OP_IfPos , 1 , 8 , 0 } , { OP_Integer , 0 , 1 , 0 } , { OP_Noop , 0 , 0 , 0 } , { OP_ResultRow , 1 , 1 , 0 } , } ; VdbeOp * aOp ; sqlite3VdbeUsesBtree ( v , iDb ) ; if ( ! zRight ) { pParse -> nMem += 2 ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( getCacheSize ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( getCacheSize ) , getCacheSize , iLn ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 6 ] . p1 = SQLITE_DEFAULT_CACHE_SIZE ; } else { int size = sqlite3AbsInt32 ( sqlite3Atoi ( zRight ) ) ; sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; sqlite3VdbeAddOp3 ( v , OP_SetCookie , iDb , BTREE_DEFAULT_CACHE_SIZE , size ) ; assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; pDb -> pSchema -> cache_size = size ; sqlite3BtreeSetCacheSize ( pDb -> pBt , pDb -> pSchema -> cache_size ) ; } break ; } # endif # if ! defined ( SQLITE_OMIT_PAGER_PRAGMAS ) case PragTyp_PAGE_SIZE : { Btree * pBt = pDb -> pBt ; assert ( pBt != 0 ) ; if ( ! zRight ) { int size = ALWAYS ( pBt ) ? sqlite3BtreeGetPageSize ( pBt ) : 0 ; returnSingleInt ( v , size ) ; } else { db -> nextPagesize = sqlite3Atoi ( zRight ) ; if ( SQLITE_NOMEM == sqlite3BtreeSetPageSize ( pBt , db -> nextPagesize , - 1 , 0 ) ) { sqlite3OomFault ( db ) ; } } break ; } case PragTyp_SECURE_DELETE : { Btree * pBt = pDb -> pBt ; int b = - 1 ; assert ( pBt != 0 ) ; if ( zRight ) { if ( sqlite3_stricmp ( zRight , ""fast"" ) == 0 ) { b = 2 ; } else { b = sqlite3GetBoolean ( zRight , 0 ) ; } } if ( pId2 -> n == 0 && b >= 0 ) { int ii ; for ( ii = 0 ; ii < db -> nDb ; ii ++ ) { sqlite3BtreeSecureDelete ( db -> aDb [ ii ] . pBt , b ) ; } } b = sqlite3BtreeSecureDelete ( pBt , b ) ; returnSingleInt ( v , b ) ; break ; } case PragTyp_PAGE_COUNT : { int iReg ; sqlite3CodeVerifySchema ( pParse , iDb ) ; iReg = ++ pParse -> nMem ; if ( sqlite3Tolower ( zLeft [ 0 ] ) == 'p' ) { sqlite3VdbeAddOp2 ( v , OP_Pagecount , iDb , iReg ) ; } else { sqlite3VdbeAddOp3 ( v , OP_MaxPgcnt , iDb , iReg , sqlite3AbsInt32 ( sqlite3Atoi ( zRight ) ) ) ; } sqlite3VdbeAddOp2 ( v , OP_ResultRow , iReg , 1 ) ; break ; } case PragTyp_LOCKING_MODE : { const char * zRet = ""normal"" ; int eMode = getLockingMode ( zRight ) ; if ( pId2 -> n == 0 && eMode == PAGER_LOCKINGMODE_QUERY ) { eMode = db -> dfltLockMode ; } else { Pager * pPager ; if ( pId2 -> n == 0 ) { int ii ; assert ( pDb == & db -> aDb [ 0 ] ) ; for ( ii = 2 ; ii < db -> nDb ; ii ++ ) { pPager = sqlite3BtreePager ( db -> aDb [ ii ] . pBt ) ; sqlite3PagerLockingMode ( pPager , eMode ) ; } db -> dfltLockMode = ( u8 ) eMode ; } pPager = sqlite3BtreePager ( pDb -> pBt ) ; eMode = sqlite3PagerLockingMode ( pPager , eMode ) ; } assert ( eMode == PAGER_LOCKINGMODE_NORMAL || eMode == PAGER_LOCKINGMODE_EXCLUSIVE ) ; if ( eMode == PAGER_LOCKINGMODE_EXCLUSIVE ) { zRet = ""exclusive"" ; } returnSingleText ( v , zRet ) ; break ; } case PragTyp_JOURNAL_MODE : { int eMode ; int ii ; if ( zRight == 0 ) { eMode = PAGER_JOURNALMODE_QUERY ; } else { const char * zMode ; int n = sqlite3Strlen30 ( zRight ) ; for ( eMode = 0 ; ( zMode = sqlite3JournalModename ( eMode ) ) != 0 ; eMode ++ ) { if ( sqlite3StrNICmp ( zRight , zMode , n ) == 0 ) break ; } if ( ! zMode ) { eMode = PAGER_JOURNALMODE_QUERY ; } if ( eMode == PAGER_JOURNALMODE_OFF && ( db -> flags & SQLITE_Defensive ) != 0 ) { eMode = PAGER_JOURNALMODE_QUERY ; } } if ( eMode == PAGER_JOURNALMODE_QUERY && pId2 -> n == 0 ) { iDb = 0 ; pId2 -> n = 1 ; } for ( ii = db -> nDb - 1 ; ii >= 0 ; ii -- ) { if ( db -> aDb [ ii ] . pBt && ( ii == iDb || pId2 -> n == 0 ) ) { sqlite3VdbeUsesBtree ( v , ii ) ; sqlite3VdbeAddOp3 ( v , OP_JournalMode , ii , 1 , eMode ) ; } } sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ) ; break ; } case PragTyp_JOURNAL_SIZE_LIMIT : { Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; i64 iLimit = - 2 ; if ( zRight ) { sqlite3DecOrHexToI64 ( zRight , & iLimit ) ; if ( iLimit < - 1 ) iLimit = - 1 ; } iLimit = sqlite3PagerJournalSizeLimit ( pPager , iLimit ) ; returnSingleInt ( v , iLimit ) ; break ; } # endif # ifndef SQLITE_OMIT_AUTOVACUUM case PragTyp_AUTO_VACUUM : { Btree * pBt = pDb -> pBt ; assert ( pBt != 0 ) ; if ( ! zRight ) { returnSingleInt ( v , sqlite3BtreeGetAutoVacuum ( pBt ) ) ; } else { int eAuto = getAutoVacuum ( zRight ) ; assert ( eAuto >= 0 && eAuto <= 2 ) ; db -> nextAutovac = ( u8 ) eAuto ; rc = sqlite3BtreeSetAutoVacuum ( pBt , eAuto ) ; if ( rc == SQLITE_OK && ( eAuto == 1 || eAuto == 2 ) ) { static const int iLn = VDBE_OFFSET_LINENO ( 2 ) ; static const VdbeOpList setMeta6 [ ] = { { OP_Transaction , 0 , 1 , 0 } , { OP_ReadCookie , 0 , 1 , BTREE_LARGEST_ROOT_PAGE } , { OP_If , 1 , 0 , 0 } , { OP_Halt , SQLITE_OK , OE_Abort , 0 } , { OP_SetCookie , 0 , BTREE_INCR_VACUUM , 0 } , } ; VdbeOp * aOp ; int iAddr = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( setMeta6 ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( setMeta6 ) , setMeta6 , iLn ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 2 ] . p2 = iAddr + 4 ; aOp [ 4 ] . p1 = iDb ; aOp [ 4 ] . p3 = eAuto - 1 ; sqlite3VdbeUsesBtree ( v , iDb ) ; } } break ; } # endif # ifndef SQLITE_OMIT_AUTOVACUUM case PragTyp_INCREMENTAL_VACUUM : { int iLimit , addr ; if ( zRight == 0 || ! sqlite3GetInt32 ( zRight , & iLimit ) || iLimit <= 0 ) { iLimit = 0x7fffffff ; } sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , iLimit , 1 ) ; addr = sqlite3VdbeAddOp1 ( v , OP_IncrVacuum , iDb ) ; VdbeCoverage ( v ) ; sqlite3VdbeAddOp1 ( v , OP_ResultRow , 1 ) ; sqlite3VdbeAddOp2 ( v , OP_AddImm , 1 , - 1 ) ; sqlite3VdbeAddOp2 ( v , OP_IfPos , 1 , addr ) ; VdbeCoverage ( v ) ; sqlite3VdbeJumpHere ( v , addr ) ; break ; } # endif # ifndef SQLITE_OMIT_PAGER_PRAGMAS case PragTyp_CACHE_SIZE : { assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; if ( ! zRight ) { returnSingleInt ( v , pDb -> pSchema -> cache_size ) ; } else { int size = sqlite3Atoi ( zRight ) ; pDb -> pSchema -> cache_size = size ; sqlite3BtreeSetCacheSize ( pDb -> pBt , pDb -> pSchema -> cache_size ) ; } break ; } case PragTyp_CACHE_SPILL : { assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; if ( ! zRight ) { returnSingleInt ( v , ( db -> flags & SQLITE_CacheSpill ) == 0 ? 0 : sqlite3BtreeSetSpillSize ( pDb -> pBt , 0 ) ) ; } else { int size = 1 ; if ( sqlite3GetInt32 ( zRight , & size ) ) { sqlite3BtreeSetSpillSize ( pDb -> pBt , size ) ; } if ( sqlite3GetBoolean ( zRight , size != 0 ) ) { db -> flags |= SQLITE_CacheSpill ; } else { db -> flags &= ~ ( u64 ) SQLITE_CacheSpill ; } setAllPagerFlags ( db ) ; } break ; } case PragTyp_MMAP_SIZE : { sqlite3_int64 sz ; # if SQLITE_MAX_MMAP_SIZE > 0 assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; if ( zRight ) { int ii ; sqlite3DecOrHexToI64 ( zRight , & sz ) ; if ( sz < 0 ) sz = sqlite3GlobalConfig . szMmap ; if ( pId2 -> n == 0 ) db -> szMmap = sz ; for ( ii = db -> nDb - 1 ; ii >= 0 ; ii -- ) { if ( db -> aDb [ ii ] . pBt && ( ii == iDb || pId2 -> n == 0 ) ) { sqlite3BtreeSetMmapLimit ( db -> aDb [ ii ] . pBt , sz ) ; } } } sz = - 1 ; rc = sqlite3_file_control ( db , zDb , SQLITE_FCNTL_MMAP_SIZE , & sz ) ; # else sz = 0 ; rc = SQLITE_OK ; # endif if ( rc == SQLITE_OK ) { returnSingleInt ( v , sz ) ; } else if ( rc != SQLITE_NOTFOUND ) { pParse -> nErr ++ ; pParse -> rc = rc ; } break ; } case PragTyp_TEMP_STORE : { if ( ! zRight ) { returnSingleInt ( v , db -> temp_store ) ; } else { changeTempStorage ( pParse , zRight ) ; } break ; } case PragTyp_TEMP_STORE_DIRECTORY : { if ( ! zRight ) { returnSingleText ( v , sqlite3_temp_directory ) ; } else { # ifndef SQLITE_OMIT_WSD if ( zRight [ 0 ] ) { int res ; rc = sqlite3OsAccess ( db -> pVfs , zRight , SQLITE_ACCESS_READWRITE , & res ) ; if ( rc != SQLITE_OK || res == 0 ) { sqlite3ErrorMsg ( pParse , ""not<S2SV_blank>a<S2SV_blank>writable<S2SV_blank>directory"" ) ; goto pragma_out ; } } if ( SQLITE_TEMP_STORE == 0 || ( SQLITE_TEMP_STORE == 1 && db -> temp_store <= 1 ) || ( SQLITE_TEMP_STORE == 2 && db -> temp_store == 1 ) ) { invalidateTempStorage ( pParse ) ; } sqlite3_free ( sqlite3_temp_directory ) ; if ( zRight [ 0 ] ) { sqlite3_temp_directory = sqlite3_mprintf ( ""%s"" , zRight ) ; } else { sqlite3_temp_directory = 0 ; } # endif } break ; } # if SQLITE_OS_WIN case PragTyp_DATA_STORE_DIRECTORY : { if ( ! zRight ) { returnSingleText ( v , sqlite3_data_directory ) ; } else { # ifndef SQLITE_OMIT_WSD if ( zRight [ 0 ] ) { int res ; rc = sqlite3OsAccess ( db -> pVfs , zRight , SQLITE_ACCESS_READWRITE , & res ) ; if ( rc != SQLITE_OK || res == 0 ) { sqlite3ErrorMsg ( pParse , ""not<S2SV_blank>a<S2SV_blank>writable<S2SV_blank>directory"" ) ; goto pragma_out ; } } sqlite3_free ( sqlite3_data_directory ) ; if ( zRight [ 0 ] ) { sqlite3_data_directory = sqlite3_mprintf ( ""%s"" , zRight ) ; } else { sqlite3_data_directory = 0 ; } # endif } break ; } # endif # if SQLITE_ENABLE_LOCKING_STYLE case PragTyp_LOCK_PROXY_FILE : { if ( ! zRight ) { Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; char * proxy_file_path = NULL ; sqlite3_file * pFile = sqlite3PagerFile ( pPager ) ; sqlite3OsFileControlHint ( pFile , SQLITE_GET_LOCKPROXYFILE , & proxy_file_path ) ; returnSingleText ( v , proxy_file_path ) ; } else { Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; sqlite3_file * pFile = sqlite3PagerFile ( pPager ) ; int res ; if ( zRight [ 0 ] ) { res = sqlite3OsFileControl ( pFile , SQLITE_SET_LOCKPROXYFILE , zRight ) ; } else { res = sqlite3OsFileControl ( pFile , SQLITE_SET_LOCKPROXYFILE , NULL ) ; } if ( res != SQLITE_OK ) { sqlite3ErrorMsg ( pParse , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>lock<S2SV_blank>proxy<S2SV_blank>file"" ) ; goto pragma_out ; } } break ; } # endif case PragTyp_SYNCHRONOUS : { if ( ! zRight ) { returnSingleInt ( v , pDb -> safety_level - 1 ) ; } else { if ( ! db -> autoCommit ) { sqlite3ErrorMsg ( pParse , ""Safety<S2SV_blank>level<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>changed<S2SV_blank>inside<S2SV_blank>a<S2SV_blank>transaction"" ) ; } else if ( iDb != 1 ) { int iLevel = ( getSafetyLevel ( zRight , 0 , 1 ) + 1 ) & PAGER_SYNCHRONOUS_MASK ; if ( iLevel == 0 ) iLevel = 1 ; pDb -> safety_level = iLevel ; pDb -> bSyncSet = 1 ; setAllPagerFlags ( db ) ; } } break ; } # endif # ifndef SQLITE_OMIT_FLAG_PRAGMAS case PragTyp_FLAG : { if ( zRight == 0 ) { setPragmaResultColumnNames ( v , pPragma ) ; returnSingleInt ( v , ( db -> flags & pPragma -> iArg ) != 0 ) ; } else { u64 mask = pPragma -> iArg ; if ( db -> autoCommit == 0 ) { mask &= ~ ( SQLITE_ForeignKeys ) ; } # if SQLITE_USER_AUTHENTICATION if ( db -> auth . authLevel == UAUTH_User ) { mask &= ~ ( SQLITE_WriteSchema ) ; } # endif if ( sqlite3GetBoolean ( zRight , 0 ) ) { db -> flags |= mask ; } else { db -> flags &= ~ mask ; if ( mask == SQLITE_DeferFKs ) db -> nDeferredImmCons = 0 ; } sqlite3VdbeAddOp0 ( v , OP_Expire ) ; setAllPagerFlags ( db ) ; } break ; } # endif # ifndef SQLITE_OMIT_SCHEMA_PRAGMAS case PragTyp_TABLE_INFO : if ( zRight ) { Table * pTab ; pTab = sqlite3LocateTable ( pParse , LOCATE_NOERR , zRight , zDb ) ; if ( pTab ) { int iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; int i , k ; int nHidden = 0 ; Column * pCol ; Index * pPk = sqlite3PrimaryKeyIndex ( pTab ) ; pParse -> nMem = 7 ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; sqlite3ViewGetColumnNames ( pParse , pTab ) ; for ( i = 0 , pCol = pTab -> aCol ; i < pTab -> nCol ; i ++ , pCol ++ ) { int isHidden = 0 ; if ( pCol -> colFlags & COLFLAG_NOINSERT ) { if ( pPragma -> iArg == 0 ) { nHidden ++ ; continue ; } if ( pCol -> colFlags & COLFLAG_VIRTUAL ) { isHidden = 2 ; } else if ( pCol -> colFlags & COLFLAG_STORED ) { isHidden = 3 ; } else { assert ( pCol -> colFlags & COLFLAG_HIDDEN ) ; isHidden = 1 ; } } if ( ( pCol -> colFlags & COLFLAG_PRIMKEY ) == 0 ) { k = 0 ; } else if ( pPk == 0 ) { k = 1 ; } else { for ( k = 1 ; k <= pTab -> nCol && pPk -> aiColumn [ k - 1 ] != i ; k ++ ) { } } assert ( pCol -> pDflt == 0 || pCol -> pDflt -> op == TK_SPAN || isHidden >= 2 ) ; sqlite3VdbeMultiLoad ( v , 1 , pPragma -> iArg ? ""issisii"" : ""issisi"" , i - nHidden , pCol -> zName , sqlite3ColumnType ( pCol , """" ) , pCol -> notNull ? 1 : 0 , pCol -> pDflt && isHidden < 2 ? pCol -> pDflt -> u . zToken : 0 , k , isHidden ) ; } } } break ; # ifdef SQLITE_DEBUG case PragTyp_STATS : { Index * pIdx ; HashElem * i ; pParse -> nMem = 5 ; sqlite3CodeVerifySchema ( pParse , iDb ) ; for ( i = sqliteHashFirst ( & pDb -> pSchema -> tblHash ) ; i ; i = sqliteHashNext ( i ) ) { Table * pTab = sqliteHashData ( i ) ; sqlite3VdbeMultiLoad ( v , 1 , ""ssiii"" , pTab -> zName , 0 , pTab -> szTabRow , pTab -> nRowLogEst , pTab -> tabFlags ) ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3VdbeMultiLoad ( v , 2 , ""siiiX"" , pIdx -> zName , pIdx -> szIdxRow , pIdx -> aiRowLogEst [ 0 ] , pIdx -> hasStat1 ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 5 ) ; } } } break ; # endif case PragTyp_INDEX_INFO : if ( zRight ) { Index * pIdx ; Table * pTab ; pIdx = sqlite3FindIndex ( db , zRight , zDb ) ; if ( pIdx == 0 ) { pTab = sqlite3LocateTable ( pParse , LOCATE_NOERR , zRight , zDb ) ; if ( pTab && ! HasRowid ( pTab ) ) { pIdx = sqlite3PrimaryKeyIndex ( pTab ) ; } } if ( pIdx ) { int iIdxDb = sqlite3SchemaToIndex ( db , pIdx -> pSchema ) ; int i ; int mx ; if ( pPragma -> iArg ) { mx = pIdx -> nColumn ; pParse -> nMem = 6 ; } else { mx = pIdx -> nKeyCol ; pParse -> nMem = 3 ; } pTab = pIdx -> pTable ; sqlite3CodeVerifySchema ( pParse , iIdxDb ) ; assert ( pParse -> nMem <= pPragma -> nPragCName ) ; for ( i = 0 ; i < mx ; i ++ ) { i16 cnum = pIdx -> aiColumn [ i ] ; sqlite3VdbeMultiLoad ( v , 1 , ""iisX"" , i , cnum , cnum < 0 ? 0 : pTab -> aCol [ cnum ] . zName ) ; if ( pPragma -> iArg ) { sqlite3VdbeMultiLoad ( v , 4 , ""isiX"" , pIdx -> aSortOrder [ i ] , pIdx -> azColl [ i ] , i < pIdx -> nKeyCol ) ; } sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , pParse -> nMem ) ; } } } break ; case PragTyp_INDEX_LIST : if ( zRight ) { Index * pIdx ; Table * pTab ; int i ; pTab = sqlite3FindTable ( db , zRight , zDb ) ; if ( pTab ) { int iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; pParse -> nMem = 5 ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; for ( pIdx = pTab -> pIndex , i = 0 ; pIdx ; pIdx = pIdx -> pNext , i ++ ) { const char * azOrigin [ ] = { ""c"" , ""u"" , ""pk"" } ; sqlite3VdbeMultiLoad ( v , 1 , ""isisi"" , i , pIdx -> zName , IsUniqueIndex ( pIdx ) , azOrigin [ pIdx -> idxType ] , pIdx -> pPartIdxWhere != 0 ) ; } } } break ; case PragTyp_DATABASE_LIST : { int i ; pParse -> nMem = 3 ; for ( i = 0 ; i < db -> nDb ; i ++ ) { if ( db -> aDb [ i ] . pBt == 0 ) continue ; assert ( db -> aDb [ i ] . zDbSName != 0 ) ; sqlite3VdbeMultiLoad ( v , 1 , ""iss"" , i , db -> aDb [ i ] . zDbSName , sqlite3BtreeGetFilename ( db -> aDb [ i ] . pBt ) ) ; } } break ; case PragTyp_COLLATION_LIST : { int i = 0 ; HashElem * p ; pParse -> nMem = 2 ; for ( p = sqliteHashFirst ( & db -> aCollSeq ) ; p ; p = sqliteHashNext ( p ) ) { CollSeq * pColl = ( CollSeq * ) sqliteHashData ( p ) ; sqlite3VdbeMultiLoad ( v , 1 , ""is"" , i ++ , pColl -> zName ) ; } } break ; # ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS case PragTyp_FUNCTION_LIST : { int i ; HashElem * j ; FuncDef * p ; pParse -> nMem = 2 ; for ( i = 0 ; i < SQLITE_FUNC_HASH_SZ ; i ++ ) { for ( p = sqlite3BuiltinFunctions . a [ i ] ; p ; p = p -> u . pHash ) { if ( p -> funcFlags & SQLITE_FUNC_INTERNAL ) continue ; sqlite3VdbeMultiLoad ( v , 1 , ""si"" , p -> zName , 1 ) ; } } for ( j = sqliteHashFirst ( & db -> aFunc ) ; j ; j = sqliteHashNext ( j ) ) { p = ( FuncDef * ) sqliteHashData ( j ) ; sqlite3VdbeMultiLoad ( v , 1 , ""si"" , p -> zName , 0 ) ; } } break ; # ifndef SQLITE_OMIT_VIRTUALTABLE case PragTyp_MODULE_LIST : { HashElem * j ; pParse -> nMem = 1 ; for ( j = sqliteHashFirst ( & db -> aModule ) ; j ; j = sqliteHashNext ( j ) ) { Module * pMod = ( Module * ) sqliteHashData ( j ) ; sqlite3VdbeMultiLoad ( v , 1 , ""s"" , pMod -> zName ) ; } } break ; # endif case PragTyp_PRAGMA_LIST : { int i ; for ( i = 0 ; i < ArraySize ( aPragmaName ) ; i ++ ) { sqlite3VdbeMultiLoad ( v , 1 , ""s"" , aPragmaName [ i ] . zName ) ; } } break ; # endif # endif # ifndef SQLITE_OMIT_FOREIGN_KEY case PragTyp_FOREIGN_KEY_LIST : if ( zRight ) { FKey * pFK ; Table * pTab ; pTab = sqlite3FindTable ( db , zRight , zDb ) ; if ( pTab ) { pFK = pTab -> pFKey ; if ( pFK ) { int iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; int i = 0 ; pParse -> nMem = 8 ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; while ( pFK ) { int j ; for ( j = 0 ; j < pFK -> nCol ; j ++ ) { sqlite3VdbeMultiLoad ( v , 1 , ""iissssss"" , i , j , pFK -> zTo , pTab -> aCol [ pFK -> aCol [ j ] . iFrom ] . zName , pFK -> aCol [ j ] . zCol , actionName ( pFK -> aAction [ 1 ] ) , actionName ( pFK -> aAction [ 0 ] ) , ""NONE"" ) ; } ++ i ; pFK = pFK -> pNextFrom ; } } } } break ; # endif # ifndef SQLITE_OMIT_FOREIGN_KEY # ifndef SQLITE_OMIT_TRIGGER case PragTyp_FOREIGN_KEY_CHECK : { FKey * pFK ; Table * pTab ; Table * pParent ; Index * pIdx ; int i ; int j ; HashElem * k ; int x ; int regResult ; int regKey ; int regRow ; int addrTop ; int addrOk ; int * aiCols ; regResult = pParse -> nMem + 1 ; pParse -> nMem += 4 ; regKey = ++ pParse -> nMem ; regRow = ++ pParse -> nMem ; k = sqliteHashFirst ( & db -> aDb [ iDb ] . pSchema -> tblHash ) ; while ( k ) { int iTabDb ; if ( zRight ) { pTab = sqlite3LocateTable ( pParse , 0 , zRight , zDb ) ; k = 0 ; } else { pTab = ( Table * ) sqliteHashData ( k ) ; k = sqliteHashNext ( k ) ; } if ( pTab == 0 || pTab -> pFKey == 0 ) continue ; iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; sqlite3TableLock ( pParse , iTabDb , pTab -> tnum , 0 , pTab -> zName ) ; if ( pTab -> nCol + regRow > pParse -> nMem ) pParse -> nMem = pTab -> nCol + regRow ; sqlite3OpenTable ( pParse , 0 , iTabDb , pTab , OP_OpenRead ) ; sqlite3VdbeLoadString ( v , regResult , pTab -> zName ) ; for ( i = 1 , pFK = pTab -> pFKey ; pFK ; i ++ , pFK = pFK -> pNextFrom ) { pParent = sqlite3FindTable ( db , pFK -> zTo , zDb ) ; if ( pParent == 0 ) continue ; pIdx = 0 ; sqlite3TableLock ( pParse , iTabDb , pParent -> tnum , 0 , pParent -> zName ) ; x = sqlite3FkLocateIndex ( pParse , pParent , pFK , & pIdx , 0 ) ; if ( x == 0 ) { if ( pIdx == 0 ) { sqlite3OpenTable ( pParse , i , iTabDb , pParent , OP_OpenRead ) ; } else { sqlite3VdbeAddOp3 ( v , OP_OpenRead , i , pIdx -> tnum , iTabDb ) ; sqlite3VdbeSetP4KeyInfo ( pParse , pIdx ) ; } } else { k = 0 ; break ; } } assert ( pParse -> nErr > 0 || pFK == 0 ) ; if ( pFK ) break ; if ( pParse -> nTab < i ) pParse -> nTab = i ; addrTop = sqlite3VdbeAddOp1 ( v , OP_Rewind , 0 ) ; VdbeCoverage ( v ) ; for ( i = 1 , pFK = pTab -> pFKey ; pFK ; i ++ , pFK = pFK -> pNextFrom ) { pParent = sqlite3FindTable ( db , pFK -> zTo , zDb ) ; pIdx = 0 ; aiCols = 0 ; if ( pParent ) { x = sqlite3FkLocateIndex ( pParse , pParent , pFK , & pIdx , & aiCols ) ; assert ( x == 0 ) ; } addrOk = sqlite3VdbeMakeLabel ( pParse ) ; for ( j = 0 ; j < pFK -> nCol ; j ++ ) { int iCol = aiCols ? aiCols [ j ] : pFK -> aCol [ j ] . iFrom ; sqlite3ExprCodeGetColumnOfTable ( v , pTab , 0 , iCol , regRow + j ) ; sqlite3VdbeAddOp2 ( v , OP_IsNull , regRow + j , addrOk ) ; VdbeCoverage ( v ) ; } if ( pIdx ) { sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , pFK -> nCol , regKey , sqlite3IndexAffinityStr ( db , pIdx ) , pFK -> nCol ) ; sqlite3VdbeAddOp4Int ( v , OP_Found , i , addrOk , regKey , 0 ) ; VdbeCoverage ( v ) ; } else if ( pParent ) { int jmp = sqlite3VdbeCurrentAddr ( v ) + 2 ; sqlite3VdbeAddOp3 ( v , OP_SeekRowid , i , jmp , regRow ) ; VdbeCoverage ( v ) ; sqlite3VdbeGoto ( v , addrOk ) ; assert ( pFK -> nCol == 1 ) ; } if ( HasRowid ( pTab ) ) { sqlite3VdbeAddOp2 ( v , OP_Rowid , 0 , regResult + 1 ) ; } else { sqlite3VdbeAddOp2 ( v , OP_Null , 0 , regResult + 1 ) ; } sqlite3VdbeMultiLoad ( v , regResult + 2 , ""siX"" , pFK -> zTo , i - 1 ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , 4 ) ; sqlite3VdbeResolveLabel ( v , addrOk ) ; sqlite3DbFree ( db , aiCols ) ; } sqlite3VdbeAddOp2 ( v , OP_Next , 0 , addrTop + 1 ) ; VdbeCoverage ( v ) ; sqlite3VdbeJumpHere ( v , addrTop ) ; } } break ; # endif # endif # ifndef SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA case PragTyp_CASE_SENSITIVE_LIKE : { if ( zRight ) { sqlite3RegisterLikeFunctions ( db , sqlite3GetBoolean ( zRight , 0 ) ) ; } } break ; # endif # ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX # define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100 # endif # ifndef SQLITE_OMIT_INTEGRITY_CHECK case PragTyp_INTEGRITY_CHECK : { int i , j , addr , mxErr ; int isQuick = ( sqlite3Tolower ( zLeft [ 0 ] ) == 'q' ) ; assert ( iDb >= 0 ) ; assert ( iDb == 0 || pId2 -> z ) ; if ( pId2 -> z == 0 ) iDb = - 1 ; pParse -> nMem = 6 ; mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX ; if ( zRight ) { sqlite3GetInt32 ( zRight , & mxErr ) ; if ( mxErr <= 0 ) { mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX ; } } sqlite3VdbeAddOp2 ( v , OP_Integer , mxErr - 1 , 1 ) ; for ( i = 0 ; i < db -> nDb ; i ++ ) { HashElem * x ; Hash * pTbls ; int * aRoot ; int cnt = 0 ; int mxIdx = 0 ; if ( OMIT_TEMPDB && i == 1 ) continue ; if ( iDb >= 0 && i != iDb ) continue ; sqlite3CodeVerifySchema ( pParse , i ) ; assert ( sqlite3SchemaMutexHeld ( db , i , 0 ) ) ; pTbls = & db -> aDb [ i ] . pSchema -> tblHash ; for ( cnt = 0 , x = sqliteHashFirst ( pTbls ) ; x ; x = sqliteHashNext ( x ) ) { Table * pTab = sqliteHashData ( x ) ; Index * pIdx ; int nIdx ; if ( HasRowid ( pTab ) ) cnt ++ ; for ( nIdx = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , nIdx ++ ) { cnt ++ ; } if ( nIdx > mxIdx ) mxIdx = nIdx ; } aRoot = sqlite3DbMallocRawNN ( db , sizeof ( int ) * ( cnt + 1 ) ) ; if ( aRoot == 0 ) break ; for ( cnt = 0 , x = sqliteHashFirst ( pTbls ) ; x ; x = sqliteHashNext ( x ) ) { Table * pTab = sqliteHashData ( x ) ; Index * pIdx ; if ( HasRowid ( pTab ) ) aRoot [ ++ cnt ] = pTab -> tnum ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { aRoot [ ++ cnt ] = pIdx -> tnum ; } } aRoot [ 0 ] = cnt ; pParse -> nMem = MAX ( pParse -> nMem , 8 + mxIdx ) ; sqlite3ClearTempRegCache ( pParse ) ; sqlite3VdbeAddOp4 ( v , OP_IntegrityCk , 2 , cnt , 1 , ( char * ) aRoot , P4_INTARRAY ) ; sqlite3VdbeChangeP5 ( v , ( u8 ) i ) ; addr = sqlite3VdbeAddOp1 ( v , OP_IsNull , 2 ) ; VdbeCoverage ( v ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , sqlite3MPrintf ( db , ""***<S2SV_blank>in<S2SV_blank>database<S2SV_blank>%s<S2SV_blank>***\\n"" , db -> aDb [ i ] . zDbSName ) , P4_DYNAMIC ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 2 , 3 , 3 ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , addr ) ; for ( x = sqliteHashFirst ( pTbls ) ; x ; x = sqliteHashNext ( x ) ) { Table * pTab = sqliteHashData ( x ) ; Index * pIdx , * pPk ; Index * pPrior = 0 ; int loopTop ; int iDataCur , iIdxCur ; int r1 = - 1 ; if ( pTab -> tnum < 1 ) continue ; pPk = HasRowid ( pTab ) ? 0 : sqlite3PrimaryKeyIndex ( pTab ) ; sqlite3OpenTableAndIndices ( pParse , pTab , OP_OpenRead , 0 , 1 , 0 , & iDataCur , & iIdxCur ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , 7 ) ; for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , 8 + j ) ; } assert ( pParse -> nMem >= 8 + j ) ; assert ( sqlite3NoTempsInRange ( pParse , 1 , 7 + j ) ) ; sqlite3VdbeAddOp2 ( v , OP_Rewind , iDataCur , 0 ) ; VdbeCoverage ( v ) ; loopTop = sqlite3VdbeAddOp2 ( v , OP_AddImm , 7 , 1 ) ; if ( ! isQuick ) { sqlite3VdbeAddOp3 ( v , OP_Column , iDataCur , pTab -> nNVCol - 1 , 3 ) ; sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ) ; } for ( j = 0 ; j < pTab -> nCol ; j ++ ) { char * zErr ; int jmp2 ; if ( j == pTab -> iPKey ) continue ; if ( pTab -> aCol [ j ] . notNull == 0 ) continue ; sqlite3ExprCodeGetColumnOfTable ( v , pTab , iDataCur , j , 3 ) ; <S2SV_StartBug> sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ) ; <S2SV_EndBug> jmp2 = sqlite3VdbeAddOp1 ( v , OP_NotNull , 3 ) ; VdbeCoverage ( v ) ; zErr = sqlite3MPrintf ( db , ""NULL<S2SV_blank>value<S2SV_blank>in<S2SV_blank>%s.%s"" , pTab -> zName , pTab -> aCol [ j ] . zName ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , zErr , P4_DYNAMIC ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , jmp2 ) ; } if ( pTab -> pCheck && ( db -> flags & SQLITE_IgnoreChecks ) == 0 ) { ExprList * pCheck = sqlite3ExprListDup ( db , pTab -> pCheck , 0 ) ; if ( db -> mallocFailed == 0 ) { int addrCkFault = sqlite3VdbeMakeLabel ( pParse ) ; int addrCkOk = sqlite3VdbeMakeLabel ( pParse ) ; char * zErr ; int k ; pParse -> iSelfTab = iDataCur + 1 ; for ( k = pCheck -> nExpr - 1 ; k > 0 ; k -- ) { sqlite3ExprIfFalse ( pParse , pCheck -> a [ k ] . pExpr , addrCkFault , 0 ) ; } sqlite3ExprIfTrue ( pParse , pCheck -> a [ 0 ] . pExpr , addrCkOk , SQLITE_JUMPIFNULL ) ; sqlite3VdbeResolveLabel ( v , addrCkFault ) ; pParse -> iSelfTab = 0 ; zErr = sqlite3MPrintf ( db , ""CHECK<S2SV_blank>constraint<S2SV_blank>failed<S2SV_blank>in<S2SV_blank>%s"" , pTab -> zName ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , zErr , P4_DYNAMIC ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeResolveLabel ( v , addrCkOk ) ; } sqlite3ExprListDelete ( db , pCheck ) ; } if ( ! isQuick ) { for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { int jmp2 , jmp3 , jmp4 , jmp5 ; int ckUniq = sqlite3VdbeMakeLabel ( pParse ) ; if ( pPk == pIdx ) continue ; r1 = sqlite3GenerateIndexKey ( pParse , pIdx , iDataCur , 0 , 0 , & jmp3 , pPrior , r1 ) ; pPrior = pIdx ; sqlite3VdbeAddOp2 ( v , OP_AddImm , 8 + j , 1 ) ; jmp2 = sqlite3VdbeAddOp4Int ( v , OP_Found , iIdxCur + j , ckUniq , r1 , pIdx -> nColumn ) ; VdbeCoverage ( v ) ; sqlite3VdbeLoadString ( v , 3 , ""row<S2SV_blank>"" ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 7 , 3 , 3 ) ; sqlite3VdbeLoadString ( v , 4 , ""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>index<S2SV_blank>"" ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 3 , 3 ) ; jmp5 = sqlite3VdbeLoadString ( v , 4 , pIdx -> zName ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 3 , 3 ) ; jmp4 = integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , jmp2 ) ; if ( IsUniqueIndex ( pIdx ) ) { int uniqOk = sqlite3VdbeMakeLabel ( pParse ) ; int jmp6 ; int kk ; for ( kk = 0 ; kk < pIdx -> nKeyCol ; kk ++ ) { int iCol = pIdx -> aiColumn [ kk ] ; assert ( iCol != XN_ROWID && iCol < pTab -> nCol ) ; if ( iCol >= 0 && pTab -> aCol [ iCol ] . notNull ) continue ; sqlite3VdbeAddOp2 ( v , OP_IsNull , r1 + kk , uniqOk ) ; VdbeCoverage ( v ) ; } jmp6 = sqlite3VdbeAddOp1 ( v , OP_Next , iIdxCur + j ) ; VdbeCoverage ( v ) ; sqlite3VdbeGoto ( v , uniqOk ) ; sqlite3VdbeJumpHere ( v , jmp6 ) ; sqlite3VdbeAddOp4Int ( v , OP_IdxGT , iIdxCur + j , uniqOk , r1 , pIdx -> nKeyCol ) ; VdbeCoverage ( v ) ; sqlite3VdbeLoadString ( v , 3 , ""non-unique<S2SV_blank>entry<S2SV_blank>in<S2SV_blank>index<S2SV_blank>"" ) ; sqlite3VdbeGoto ( v , jmp5 ) ; sqlite3VdbeResolveLabel ( v , uniqOk ) ; } sqlite3VdbeJumpHere ( v , jmp4 ) ; sqlite3ResolvePartIdxLabel ( pParse , jmp3 ) ; } } sqlite3VdbeAddOp2 ( v , OP_Next , iDataCur , loopTop ) ; VdbeCoverage ( v ) ; sqlite3VdbeJumpHere ( v , loopTop - 1 ) ; # ifndef SQLITE_OMIT_BTREECOUNT if ( ! isQuick ) { sqlite3VdbeLoadString ( v , 2 , ""wrong<S2SV_blank>#<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>index<S2SV_blank>"" ) ; for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { if ( pPk == pIdx ) continue ; sqlite3VdbeAddOp2 ( v , OP_Count , iIdxCur + j , 3 ) ; addr = sqlite3VdbeAddOp3 ( v , OP_Eq , 8 + j , 0 , 3 ) ; VdbeCoverage ( v ) ; sqlite3VdbeChangeP5 ( v , SQLITE_NOTNULL ) ; sqlite3VdbeLoadString ( v , 4 , pIdx -> zName ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 2 , 3 ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , addr ) ; } } # endif } } { static const int iLn = VDBE_OFFSET_LINENO ( 2 ) ; static const VdbeOpList endCode [ ] = { { OP_AddImm , 1 , 0 , 0 } , { OP_IfNotZero , 1 , 4 , 0 } , { OP_String8 , 0 , 3 , 0 } , { OP_ResultRow , 3 , 1 , 0 } , { OP_Halt , 0 , 0 , 0 } , { OP_String8 , 0 , 3 , 0 } , { OP_Goto , 0 , 3 , 0 } , } ; VdbeOp * aOp ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( endCode ) , endCode , iLn ) ; if ( aOp ) { aOp [ 0 ] . p2 = 1 - mxErr ; aOp [ 2 ] . p4type = P4_STATIC ; aOp [ 2 ] . p4 . z = ""ok"" ; aOp [ 5 ] . p4type = P4_STATIC ; aOp [ 5 ] . p4 . z = ( char * ) sqlite3ErrStr ( SQLITE_CORRUPT ) ; } sqlite3VdbeChangeP3 ( v , 0 , sqlite3VdbeCurrentAddr ( v ) - 2 ) ; } } break ; # endif # ifndef SQLITE_OMIT_UTF16 case PragTyp_ENCODING : { static const struct EncName { char * zName ; u8 enc ; } encnames [ ] = { { ""UTF8"" , SQLITE_UTF8 } , { ""UTF-8"" , SQLITE_UTF8 } , { ""UTF-16le"" , SQLITE_UTF16LE } , { ""UTF-16be"" , SQLITE_UTF16BE } , { ""UTF16le"" , SQLITE_UTF16LE } , { ""UTF16be"" , SQLITE_UTF16BE } , { ""UTF-16"" , 0 } , { ""UTF16"" , 0 } , { 0 , 0 } } ; const struct EncName * pEnc ; if ( ! zRight ) { if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; assert ( encnames [ SQLITE_UTF8 ] . enc == SQLITE_UTF8 ) ; assert ( encnames [ SQLITE_UTF16LE ] . enc == SQLITE_UTF16LE ) ; assert ( encnames [ SQLITE_UTF16BE ] . enc == SQLITE_UTF16BE ) ; returnSingleText ( v , encnames [ ENC ( pParse -> db ) ] . zName ) ; } else { if ( ! ( DbHasProperty ( db , 0 , DB_SchemaLoaded ) ) || DbHasProperty ( db , 0 , DB_Empty ) ) { for ( pEnc = & encnames [ 0 ] ; pEnc -> zName ; pEnc ++ ) { if ( 0 == sqlite3StrICmp ( zRight , pEnc -> zName ) ) { SCHEMA_ENC ( db ) = ENC ( db ) = pEnc -> enc ? pEnc -> enc : SQLITE_UTF16NATIVE ; break ; } } if ( ! pEnc -> zName ) { sqlite3ErrorMsg ( pParse , ""unsupported<S2SV_blank>encoding:<S2SV_blank>%s"" , zRight ) ; } } } } break ; # endif # ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS case PragTyp_HEADER_VALUE : { int iCookie = pPragma -> iArg ; sqlite3VdbeUsesBtree ( v , iDb ) ; if ( zRight && ( pPragma -> mPragFlg & PragFlg_ReadOnly ) == 0 ) { static const VdbeOpList setCookie [ ] = { { OP_Transaction , 0 , 1 , 0 } , { OP_SetCookie , 0 , 0 , 0 } , } ; VdbeOp * aOp ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( setCookie ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( setCookie ) , setCookie , 0 ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 1 ] . p2 = iCookie ; aOp [ 1 ] . p3 = sqlite3Atoi ( zRight ) ; } else { static const VdbeOpList readCookie [ ] = { { OP_Transaction , 0 , 0 , 0 } , { OP_ReadCookie , 0 , 1 , 0 } , { OP_ResultRow , 1 , 1 , 0 } } ; VdbeOp * aOp ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( readCookie ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( readCookie ) , readCookie , 0 ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 1 ] . p3 = iCookie ; sqlite3VdbeReusable ( v ) ; } } break ; # endif # ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS case PragTyp_COMPILE_OPTIONS : { int i = 0 ; const char * zOpt ; pParse -> nMem = 1 ; while ( ( zOpt = sqlite3_compileoption_get ( i ++ ) ) != 0 ) { sqlite3VdbeLoadString ( v , 1 , zOpt ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ) ; } sqlite3VdbeReusable ( v ) ; } break ; # endif # ifndef SQLITE_OMIT_WAL case PragTyp_WAL_CHECKPOINT : { int iBt = ( pId2 -> z ? iDb : SQLITE_MAX_ATTACHED ) ; int eMode = SQLITE_CHECKPOINT_PASSIVE ; if ( zRight ) { if ( sqlite3StrICmp ( zRight , ""full"" ) == 0 ) { eMode = SQLITE_CHECKPOINT_FULL ; } else if ( sqlite3StrICmp ( zRight , ""restart"" ) == 0 ) { eMode = SQLITE_CHECKPOINT_RESTART ; } else if ( sqlite3StrICmp ( zRight , ""truncate"" ) == 0 ) { eMode = SQLITE_CHECKPOINT_TRUNCATE ; } } pParse -> nMem = 3 ; sqlite3VdbeAddOp3 ( v , OP_Checkpoint , iBt , eMode , 1 ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 3 ) ; } break ; case PragTyp_WAL_AUTOCHECKPOINT : { if ( zRight ) { sqlite3_wal_autocheckpoint ( db , sqlite3Atoi ( zRight ) ) ; } returnSingleInt ( v , db -> xWalCallback == sqlite3WalDefaultHook ? SQLITE_PTR_TO_INT ( db -> pWalArg ) : 0 ) ; } break ; # endif case PragTyp_SHRINK_MEMORY : { sqlite3_db_release_memory ( db ) ; break ; } case PragTyp_OPTIMIZE : { int iDbLast ; int iTabCur ; HashElem * k ; Schema * pSchema ; Table * pTab ; Index * pIdx ; LogEst szThreshold ; char * zSubSql ; u32 opMask ; if ( zRight ) { opMask = ( u32 ) sqlite3Atoi ( zRight ) ; if ( ( opMask & 0x02 ) == 0 ) break ; } else { opMask = 0xfffe ; } iTabCur = pParse -> nTab ++ ; for ( iDbLast = zDb ? iDb : db -> nDb - 1 ; iDb <= iDbLast ; iDb ++ ) { if ( iDb == 1 ) continue ; sqlite3CodeVerifySchema ( pParse , iDb ) ; pSchema = db -> aDb [ iDb ] . pSchema ; for ( k = sqliteHashFirst ( & pSchema -> tblHash ) ; k ; k = sqliteHashNext ( k ) ) { pTab = ( Table * ) sqliteHashData ( k ) ; if ( ( pTab -> tabFlags & TF_StatsUsed ) == 0 ) continue ; szThreshold = pTab -> nRowLogEst + 46 ; assert ( sqlite3LogEst ( 25 ) == 46 ) ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { if ( ! pIdx -> hasStat1 ) { szThreshold = 0 ; break ; } } if ( szThreshold ) { sqlite3OpenTable ( pParse , iTabCur , iDb , pTab , OP_OpenRead ) ; sqlite3VdbeAddOp3 ( v , OP_IfSmaller , iTabCur , sqlite3VdbeCurrentAddr ( v ) + 2 + ( opMask & 1 ) , szThreshold ) ; VdbeCoverage ( v ) ; } zSubSql = sqlite3MPrintf ( db , ""ANALYZE<S2SV_blank>\\""%w\\"".\\""%w\\"""" , db -> aDb [ iDb ] . zDbSName , pTab -> zName ) ; if ( opMask & 0x01 ) { int r1 = sqlite3GetTempReg ( pParse ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , r1 , 0 , zSubSql , P4_DYNAMIC ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , r1 , 1 ) ; } else { sqlite3VdbeAddOp4 ( v , OP_SqlExec , 0 , 0 , 0 , zSubSql , P4_DYNAMIC ) ; } } } sqlite3VdbeAddOp0 ( v , OP_Expire ) ; break ; } default : { assert ( pPragma -> ePragTyp == PragTyp_BUSY_TIMEOUT ) ; if ( zRight ) { sqlite3_busy_timeout ( db , sqlite3Atoi ( zRight ) ) ; } returnSingleInt ( v , db -> busyTimeout ) ; break ; } case PragTyp_SOFT_HEAP_LIMIT : { sqlite3_int64 N ; if ( zRight && sqlite3DecOrHexToI64 ( zRight , & N ) == SQLITE_OK ) { sqlite3_soft_heap_limit64 ( N ) ; } returnSingleInt ( v , sqlite3_soft_heap_limit64 ( - 1 ) ) ; break ; } case PragTyp_HARD_HEAP_LIMIT : { sqlite3_int64 N ; if ( zRight && sqlite3DecOrHexToI64 ( zRight , & N ) == SQLITE_OK ) { sqlite3_int64 iPrior = sqlite3_hard_heap_limit64 ( - 1 ) ; if ( N > 0 && ( iPrior == 0 || iPrior > N ) ) sqlite3_hard_heap_limit64 ( N ) ; } returnSingleInt ( v , sqlite3_hard_heap_limit64 ( - 1 ) ) ; break ; } case PragTyp_THREADS : { sqlite3_int64 N ; if ( zRight && sqlite3DecOrHexToI64 ( zRight , & N ) == SQLITE_OK && N >= 0 ) { sqlite3_limit ( db , SQLITE_LIMIT_WORKER_THREADS , ( int ) ( N & 0x7fffffff ) ) ; } returnSingleInt ( v , sqlite3_limit ( db , SQLITE_LIMIT_WORKER_THREADS , - 1 ) ) ; break ; } # if defined ( SQLITE_DEBUG ) || defined ( SQLITE_TEST ) case PragTyp_LOCK_STATUS : { static const char * const azLockName [ ] = { ""unlocked"" , ""shared"" , ""reserved"" , ""pending"" , ""exclusive"" } ; int i ; pParse -> nMem = 2 ; for ( i = 0 ; i < db -> nDb ; i ++ ) { Btree * pBt ; const char * zState = ""unknown"" ; int j ; if ( db -> aDb [ i ] . zDbSName == 0 ) continue ; pBt = db -> aDb [ i ] . pBt ; if ( pBt == 0 || sqlite3BtreePager ( pBt ) == 0 ) { zState = ""closed"" ; } else if ( sqlite3_file_control ( db , i ? db -> aDb [ i ] . zDbSName : 0 , SQLITE_FCNTL_LOCKSTATE , & j ) == SQLITE_OK ) { zState = azLockName [ j ] ; } sqlite3VdbeMultiLoad ( v , 1 , ""ss"" , db -> aDb [ i ] . zDbSName , zState ) ; } break ; } # endif # ifdef SQLITE_HAS_CODEC case PragTyp_KEY : { if ( zRight ) { char zBuf [ 40 ] ; const char * zKey = zRight ; int n ; if ( pPragma -> iArg == 2 || pPragma -> iArg == 3 ) { u8 iByte ; int i ; for ( i = 0 , iByte = 0 ; i < sizeof ( zBuf ) * 2 && sqlite3Isxdigit ( zRight [ i ] ) ; i ++ ) { iByte = ( iByte << 4 ) + sqlite3HexToInt ( zRight [ i ] ) ; if ( ( i & 1 ) != 0 ) zBuf [ i / 2 ] = iByte ; } zKey = zBuf ; n = i / 2 ; } else { n = pPragma -> iArg < 4 ? sqlite3Strlen30 ( zRight ) : - 1 ; } if ( ( pPragma -> iArg & 1 ) == 0 ) { rc = sqlite3_key_v2 ( db , zDb , zKey , n ) ; } else { rc = sqlite3_rekey_v2 ( db , zDb , zKey , n ) ; } if ( rc == SQLITE_OK && n != 0 ) { sqlite3VdbeSetNumCols ( v , 1 ) ; sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , ""ok"" , SQLITE_STATIC ) ; returnSingleText ( v , ""ok"" ) ; } } break ; } # endif # if defined ( SQLITE_HAS_CODEC ) || defined ( SQLITE_ENABLE_CEROD ) case PragTyp_ACTIVATE_EXTENSIONS : if ( zRight ) { # ifdef SQLITE_HAS_CODEC if ( sqlite3StrNICmp ( zRight , ""see-"" , 4 ) == 0 ) { sqlite3_activate_see ( & zRight [ 4 ] ) ; } # endif # ifdef SQLITE_ENABLE_CEROD if ( sqlite3StrNICmp ( zRight , ""cerod-"" , 6 ) == 0 ) { sqlite3_activate_cerod ( & zRight [ 6 ] ) ; } # endif } break ; # endif } if ( ( pPragma -> mPragFlg & PragFlg_NoColumns1 ) && zRight ) { sqlite3VdbeVerifyNoResultRow ( v ) ; } pragma_out : sqlite3DbFree ( db , zLeft ) ; sqlite3DbFree ( db , zRight ) ; }
","<S2SV_ModStart> 3 ) ; if ( sqlite3VdbeGetOp ( v , - 1 ) -> opcode == OP_Column ) { <S2SV_ModStart> OPFLAG_TYPEOFARG ) ; }
",sqlite@sqlite/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd,CVE-2019-19646,https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd,2019-12-09T19:15Z,"<S2SV_StartBug> sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ) ; <S2SV_EndBug>"
4,CWE-362,"static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug> fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }
","<S2SV_ModStart> { rq = tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; fn (
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z,"<S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug>"
1118,CWE-119,"static __u8 * lg_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { struct lg_drv_data * drv_data = hid_get_drvdata ( hdev ) ; struct usb_device_descriptor * udesc ; __u16 bcdDevice , rev_maj , rev_min ; <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>keyboard<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 84 ] = rdesc [ 89 ] = 0x4d ; rdesc [ 85 ] = rdesc [ 90 ] = 0x10 ; } <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug> rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>rel/abs<S2SV_blank>in<S2SV_blank>Logitech<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 33 ] = rdesc [ 50 ] = 0x02 ; } switch ( hdev -> product ) { case USB_DEVICE_ID_LOGITECH_WHEEL : udesc = & ( hid_to_usb_dev ( hdev ) -> descriptor ) ; if ( ! udesc ) { hid_err ( hdev , ""NULL<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>descriptor\\n"" ) ; break ; } bcdDevice = le16_to_cpu ( udesc -> bcdDevice ) ; rev_maj = bcdDevice >> 8 ; rev_min = bcdDevice & 0xff ; if ( rev_maj == 1 && rev_min == 2 && * rsize == DF_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = df_rdesc_fixed ; * rsize = sizeof ( df_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL : if ( * rsize == MOMO_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Force<S2SV_blank>(Red)<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = momo_rdesc_fixed ; * rsize = sizeof ( momo_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2 : if ( * rsize == MOMO2_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Racing<S2SV_blank>Force<S2SV_blank>(Black)<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = momo2_rdesc_fixed ; * rsize = sizeof ( momo2_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL : if ( * rsize == FV_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Formula<S2SV_blank>Vibration<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = fv_rdesc_fixed ; * rsize = sizeof ( fv_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_DFP_WHEEL : if ( * rsize == DFP_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>Pro<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = dfp_rdesc_fixed ; * rsize = sizeof ( dfp_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_WII_WHEEL : if ( * rsize >= 101 && rdesc [ 41 ] == 0x95 && rdesc [ 42 ] == 0x0B && rdesc [ 47 ] == 0x05 && rdesc [ 48 ] == 0x09 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Speed<S2SV_blank>Force<S2SV_blank>Wireless<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 41 ] = 0x05 ; rdesc [ 42 ] = 0x09 ; rdesc [ 47 ] = 0x95 ; rdesc [ 48 ] = 0x0B ; } break ; } return rdesc ; }
","<S2SV_ModStart> * rsize >= 91 <S2SV_ModEnd> && rdesc [ <S2SV_ModStart> * rsize >= 51 <S2SV_ModEnd> && rdesc [
",torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,CVE-2014-3184,https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,2014-09-28T10:55Z,<S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug>
62,CWE-59,"static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s"" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }
","<S2SV_ModStart> O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW
",acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306,CVE-2018-19044,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,2018-11-08T20:29Z,"<S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug>"
4916,CWE-908,"int im_vips2dz ( IMAGE * in , const char * filename ) { char * p , * q ; char name [ FILENAME_MAX ] ; char mode [ FILENAME_MAX ] ; char buf [ FILENAME_MAX ] ; int i ; VipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ ; char * suffix = "".jpeg"" ; int overlap = 0 ; int tile_size = 256 ; VipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL ; gboolean centre = FALSE ; VipsAngle angle = VIPS_ANGLE_D0 ; im_strncpy ( name , filename , FILENAME_MAX ) ; if ( ( p = strchr ( name , ':' ) ) ) { * p = '\\0' ; im_strncpy ( mode , p + 1 , FILENAME_MAX ) ; } <S2SV_StartBug> strcpy ( buf , mode ) ; <S2SV_EndBug> p = & buf [ 0 ] ; if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , VIPS_TYPE_FOREIGN_DZ_LAYOUT , q ) ) < 0 ) return ( - 1 ) ; layout = i ; } if ( ( q = im_getnextoption ( & p ) ) ) suffix = g_strdup ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) overlap = atoi ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) tile_size = atoi ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , VIPS_TYPE_FOREIGN_DZ_DEPTH , q ) ) < 0 ) return ( - 1 ) ; depth = i ; } if ( ( q = im_getnextoption ( & p ) ) ) { if ( im_isprefix ( ""cen"" , q ) ) centre = TRUE ; } if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , VIPS_TYPE_ANGLE , q ) ) < 0 ) return ( - 1 ) ; angle = i ; } if ( vips_dzsave ( in , name , ""layout"" , layout , ""suffix"" , suffix , ""overlap"" , overlap , ""tile_size"" , tile_size , ""depth"" , depth , ""centre"" , centre , ""angle"" , angle , NULL ) ) return ( - 1 ) ; return ( 0 ) ; }
","<S2SV_ModStart> ) ; } else strcpy ( mode , """" ) ;
",libvips@libvips/2ab5aa7bf515135c2b02d42e9a72e4c98e17031a,CVE-2020-20739,https://github.com/libvips/libvips/commit/2ab5aa7bf515135c2b02d42e9a72e4c98e17031a,2020-11-20T19:15Z,"<S2SV_StartBug> strcpy ( buf , mode ) ; <S2SV_EndBug>"
2408,CWE-264,"<S2SV_StartBug> static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) <S2SV_EndBug> { char * p ; int rc = 0 ; int sig_set = 0 ; int cipher_name_set = 0 ; int fn_cipher_name_set = 0 ; int cipher_key_bytes ; int cipher_key_bytes_set = 0 ; int fn_cipher_key_bytes ; int fn_cipher_key_bytes_set = 0 ; struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; substring_t args [ MAX_OPT_ARGS ] ; int token ; char * sig_src ; char * cipher_name_dst ; char * cipher_name_src ; char * fn_cipher_name_dst ; char * fn_cipher_name_src ; char * fnek_dst ; char * fnek_src ; char * cipher_key_bytes_src ; char * fn_cipher_key_bytes_src ; <S2SV_StartBug> if ( ! options ) { <S2SV_EndBug> rc = - EINVAL ; goto out ; } ecryptfs_init_mount_crypt_stat ( mount_crypt_stat ) ; while ( ( p = strsep ( & options , "","" ) ) != NULL ) { if ( ! * p ) continue ; token = match_token ( p , tokens , args ) ; switch ( token ) { case ecryptfs_opt_sig : case ecryptfs_opt_ecryptfs_sig : sig_src = args [ 0 ] . from ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>"" ""global<S2SV_blank>sig;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , rc ) ; goto out ; } sig_set = 1 ; break ; case ecryptfs_opt_cipher : case ecryptfs_opt_ecryptfs_cipher : cipher_name_src = args [ 0 ] . from ; cipher_name_dst = mount_crypt_stat -> global_default_cipher_name ; strncpy ( cipher_name_dst , cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; cipher_name_dst [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; cipher_name_set = 1 ; break ; case ecryptfs_opt_ecryptfs_key_bytes : cipher_key_bytes_src = args [ 0 ] . from ; cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes ; cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_passthrough : mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED ; break ; case ecryptfs_opt_xattr_metadata : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; break ; case ecryptfs_opt_encrypted_view : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED ; break ; case ecryptfs_opt_fnek_sig : fnek_src = args [ 0 ] . from ; fnek_dst = mount_crypt_stat -> global_default_fnek_sig ; strncpy ( fnek_dst , fnek_src , ECRYPTFS_SIG_SIZE_HEX ) ; mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\\0' ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>"" ""global<S2SV_blank>fnek<S2SV_blank>sig<S2SV_blank>[%s];<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fnek_sig , rc ) ; goto out ; } mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ) ; break ; case ecryptfs_opt_fn_cipher : fn_cipher_name_src = args [ 0 ] . from ; fn_cipher_name_dst = mount_crypt_stat -> global_default_fn_cipher_name ; strncpy ( fn_cipher_name_dst , fn_cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; fn_cipher_name_set = 1 ; break ; case ecryptfs_opt_fn_cipher_key_bytes : fn_cipher_key_bytes_src = args [ 0 ] . from ; fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes ; fn_cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_unlink_sigs : mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS ; break ; case ecryptfs_opt_mount_auth_tok_only : mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY ; break ; <S2SV_StartBug> case ecryptfs_opt_err : <S2SV_EndBug> default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\n"" , __func__ , p ) ; } } if ( ! sig_set ) { rc = - EINVAL ; ecryptfs_printk ( KERN_ERR , ""You<S2SV_blank>must<S2SV_blank>supply<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>valid<S2SV_blank>"" ""auth<S2SV_blank>tok<S2SV_blank>signature<S2SV_blank>as<S2SV_blank>a<S2SV_blank>mount<S2SV_blank>"" ""parameter;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>eCryptfs<S2SV_blank>README\\n"" ) ; goto out ; } if ( ! cipher_name_set ) { int cipher_name_len = strlen ( ECRYPTFS_DEFAULT_CIPHER ) ; BUG_ON ( cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; strcpy ( mount_crypt_stat -> global_default_cipher_name , ECRYPTFS_DEFAULT_CIPHER ) ; } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_name_set ) strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ) ; if ( ! cipher_key_bytes_set ) mount_crypt_stat -> global_default_cipher_key_size = 0 ; if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_key_bytes_set ) mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size ; mutex_lock ( & key_tfm_list_mutex ) ; if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>"" ""rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ) ; if ( rc ) { printk ( KERN_ERR ""Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>"" ""rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } mutex_unlock ( & key_tfm_list_mutex ) ; rc = ecryptfs_init_global_auth_toks ( mount_crypt_stat ) ; if ( rc ) printk ( KERN_WARNING ""One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>global<S2SV_blank>auth<S2SV_blank>toks<S2SV_blank>could<S2SV_blank>not<S2SV_blank>"" ""properly<S2SV_blank>register;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , rc ) ; out : return rc ; }
","<S2SV_ModStart> char * options , uid_t * check_ruid <S2SV_ModStart> * fn_cipher_key_bytes_src ; * check_ruid = 0 ; <S2SV_ModStart> break ; case ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ; break ; case
",torvalds@linux/764355487ea220fdc2faf128d577d7f679b91f97,CVE-2011-1833,https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97,2012-10-03T11:02Z,"<S2SV_StartBug> static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) <S2SV_EndBug> <S2SV_StartBug> if ( ! options ) { <S2SV_EndBug> <S2SV_StartBug> case ecryptfs_opt_err : <S2SV_EndBug>"
3016,CWE-399,"static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; <S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; if ( pmc_overflow ( val ) ) write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
","<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug>"
7369,CWE-835,"int dwg_decode_add_object ( Dwg_Data * restrict dwg , Bit_Chain * dat , Bit_Chain * hdl_dat , long unsigned int address ) { long unsigned int objpos , restartpos ; Bit_Chain abs_dat = { NULL } ; unsigned char previous_bit ; Dwg_Object * restrict obj ; BITCODE_BL num = dwg -> num_objects ; int error = 0 ; int realloced = 0 ; abs_dat = * dat ; dat -> byte = address ; dat -> bit = 0 ; realloced = dwg_add_object ( dwg ) ; if ( realloced > 0 ) { * dat = abs_dat ; return realloced ; } obj = & dwg -> object [ num ] ; LOG_INFO ( ""==========================================\\n"" ""Object<S2SV_blank>number:<S2SV_blank>%lu/%lX"" , ( unsigned long ) num , ( unsigned long ) num ) obj -> size = bit_read_MS ( dat ) ; LOG_INFO ( "",<S2SV_blank>Size:<S2SV_blank>%d<S2SV_blank>[MS]"" , obj -> size ) SINCE ( R_2010 ) { obj -> handlestream_size = bit_read_UMC ( dat ) ; LOG_INFO ( "",<S2SV_blank>Hdlsize:<S2SV_blank>"" FORMAT_UMC ""<S2SV_blank>[UMC]<S2SV_blank>"" , obj -> handlestream_size ) ; obj -> bitsize = obj -> size * 8 - obj -> handlestream_size ; } objpos = bit_position ( dat ) ; obj -> address = dat -> byte ; bit_reset_chain ( dat ) ; if ( obj -> size > dat -> size ) { LOG_ERROR ( ""\\nInvalid<S2SV_blank>object<S2SV_blank>size.<S2SV_blank>Would<S2SV_blank>overflow"" ) ; * dat = abs_dat ; return DWG_ERR_VALUEOUTOFBOUNDS ; } dat -> size = obj -> size ; SINCE ( R_2010 ) { obj -> type = bit_read_BOT ( dat ) ; } else { obj -> type = bit_read_BS ( dat ) ; } LOG_INFO ( "",<S2SV_blank>Type:<S2SV_blank>%d<S2SV_blank>[%s]\\n"" , obj -> type , dat -> version >= R_2010 ? ""BOT"" : ""BS"" ) ; restartpos = bit_position ( dat ) ; switch ( obj -> type ) { case DWG_TYPE_TEXT : error = dwg_decode_TEXT ( dat , obj ) ; break ; case DWG_TYPE_ATTRIB : error = dwg_decode_ATTRIB ( dat , obj ) ; break ; case DWG_TYPE_ATTDEF : error = dwg_decode_ATTDEF ( dat , obj ) ; break ; case DWG_TYPE_BLOCK : error = dwg_decode_BLOCK ( dat , obj ) ; break ; case DWG_TYPE_ENDBLK : error = dwg_decode_ENDBLK ( dat , obj ) ; break ; case DWG_TYPE_SEQEND : error = dwg_decode_SEQEND ( dat , obj ) ; if ( dat -> version >= R_13 && obj -> tio . entity -> ownerhandle ) { Dwg_Object * restrict owner = dwg_resolve_handle ( dwg , obj -> tio . entity -> ownerhandle -> absolute_ref ) ; if ( ! owner ) { LOG_WARN ( ""no<S2SV_blank>SEQEND.ownerhandle"" ) } else if ( owner -> fixedtype == DWG_TYPE_INSERT || owner -> fixedtype == DWG_TYPE_MINSERT ) { hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_INSERT ( owner ) ; } else if ( owner -> fixedtype == DWG_TYPE_POLYLINE_2D || owner -> fixedtype == DWG_TYPE_POLYLINE_3D || owner -> fixedtype == DWG_TYPE_POLYLINE_PFACE || owner -> fixedtype == DWG_TYPE_POLYLINE_MESH ) { Dwg_Entity_POLYLINE_2D * restrict _obj = owner -> tio . entity -> tio . POLYLINE_2D ; if ( ! _obj -> seqend ) hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_POLYLINE ( owner ) ; } } break ; case DWG_TYPE_INSERT : error = dwg_decode_INSERT ( dat , obj ) ; break ; case DWG_TYPE_MINSERT : error = dwg_decode_MINSERT ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_2D : error = dwg_decode_VERTEX_2D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_3D : error = dwg_decode_VERTEX_3D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_MESH : error = dwg_decode_VERTEX_MESH ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE : error = dwg_decode_VERTEX_PFACE ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE_FACE : error = dwg_decode_VERTEX_PFACE_FACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_2D : error = dwg_decode_POLYLINE_2D ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_POLYLINE_3D : error = dwg_decode_POLYLINE_3D ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_ARC : error = dwg_decode_ARC ( dat , obj ) ; break ; case DWG_TYPE_CIRCLE : error = dwg_decode_CIRCLE ( dat , obj ) ; break ; case DWG_TYPE_LINE : error = dwg_decode_LINE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ORDINATE : error = dwg_decode_DIMENSION_ORDINATE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_LINEAR : error = dwg_decode_DIMENSION_LINEAR ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ALIGNED : error = dwg_decode_DIMENSION_ALIGNED ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG3PT : error = dwg_decode_DIMENSION_ANG3PT ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG2LN : error = dwg_decode_DIMENSION_ANG2LN ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_RADIUS : error = dwg_decode_DIMENSION_RADIUS ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_DIAMETER : error = dwg_decode_DIMENSION_DIAMETER ( dat , obj ) ; break ; case DWG_TYPE_POINT : error = dwg_decode_POINT ( dat , obj ) ; break ; case DWG_TYPE__3DFACE : error = dwg_decode__3DFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_PFACE : error = dwg_decode_POLYLINE_PFACE ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_POLYLINE_MESH : error = dwg_decode_POLYLINE_MESH ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_SOLID : error = dwg_decode_SOLID ( dat , obj ) ; break ; case DWG_TYPE_TRACE : error = dwg_decode_TRACE ( dat , obj ) ; break ; case DWG_TYPE_SHAPE : error = dwg_decode_SHAPE ( dat , obj ) ; break ; case DWG_TYPE_VIEWPORT : error = dwg_decode_VIEWPORT ( dat , obj ) ; break ; case DWG_TYPE_ELLIPSE : error = dwg_decode_ELLIPSE ( dat , obj ) ; break ; case DWG_TYPE_SPLINE : error = dwg_decode_SPLINE ( dat , obj ) ; break ; case DWG_TYPE_REGION : error = dwg_decode_REGION ( dat , obj ) ; break ; case DWG_TYPE__3DSOLID : error = dwg_decode__3DSOLID ( dat , obj ) ; break ; case DWG_TYPE_BODY : error = dwg_decode_BODY ( dat , obj ) ; break ; case DWG_TYPE_RAY : error = dwg_decode_RAY ( dat , obj ) ; break ; case DWG_TYPE_XLINE : error = dwg_decode_XLINE ( dat , obj ) ; break ; case DWG_TYPE_DICTIONARY : error = dwg_decode_DICTIONARY ( dat , obj ) ; break ; case DWG_TYPE_MTEXT : error = dwg_decode_MTEXT ( dat , obj ) ; break ; case DWG_TYPE_LEADER : error = dwg_decode_LEADER ( dat , obj ) ; break ; case DWG_TYPE_TOLERANCE : error = dwg_decode_TOLERANCE ( dat , obj ) ; break ; case DWG_TYPE_MLINE : error = dwg_decode_MLINE ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_CONTROL : error = dwg_decode_BLOCK_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . BLOCK_CONTROL ) { obj -> tio . object -> tio . BLOCK_CONTROL -> objid = num ; if ( ! dwg -> block_control . parent ) dwg -> block_control = * obj -> tio . object -> tio . BLOCK_CONTROL ; else LOG_WARN ( ""Second<S2SV_blank>BLOCK_CONTROL<S2SV_blank>object<S2SV_blank>ignored"" ) ; } break ; case DWG_TYPE_BLOCK_HEADER : error = dwg_decode_BLOCK_HEADER ( dat , obj ) ; break ; case DWG_TYPE_LAYER_CONTROL : error = dwg_decode_LAYER_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . LAYER_CONTROL ) { obj -> tio . object -> tio . LAYER_CONTROL -> objid = num ; dwg -> layer_control = * obj -> tio . object -> tio . LAYER_CONTROL ; } break ; case DWG_TYPE_LAYER : error = dwg_decode_LAYER ( dat , obj ) ; break ; case DWG_TYPE_STYLE_CONTROL : error = dwg_decode_STYLE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . STYLE_CONTROL ) { obj -> tio . object -> tio . STYLE_CONTROL -> objid = num ; dwg -> style_control = * obj -> tio . object -> tio . STYLE_CONTROL ; } break ; case DWG_TYPE_STYLE : error = dwg_decode_STYLE ( dat , obj ) ; break ; case DWG_TYPE_LTYPE_CONTROL : error = dwg_decode_LTYPE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . LTYPE_CONTROL ) { obj -> tio . object -> tio . LTYPE_CONTROL -> objid = num ; dwg -> ltype_control = * obj -> tio . object -> tio . LTYPE_CONTROL ; } break ; case DWG_TYPE_LTYPE : error = dwg_decode_LTYPE ( dat , obj ) ; break ; case DWG_TYPE_VIEW_CONTROL : error = dwg_decode_VIEW_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VIEW_CONTROL ) { obj -> tio . object -> tio . VIEW_CONTROL -> objid = num ; dwg -> view_control = * obj -> tio . object -> tio . VIEW_CONTROL ; } break ; case DWG_TYPE_VIEW : error = dwg_decode_VIEW ( dat , obj ) ; break ; case DWG_TYPE_UCS_CONTROL : error = dwg_decode_UCS_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . UCS_CONTROL ) { obj -> tio . object -> tio . UCS_CONTROL -> objid = num ; dwg -> ucs_control = * obj -> tio . object -> tio . UCS_CONTROL ; } break ; case DWG_TYPE_UCS : error = dwg_decode_UCS ( dat , obj ) ; break ; case DWG_TYPE_VPORT_CONTROL : error = dwg_decode_VPORT_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VPORT_CONTROL ) { obj -> tio . object -> tio . VPORT_CONTROL -> objid = num ; dwg -> vport_control = * obj -> tio . object -> tio . VPORT_CONTROL ; } break ; case DWG_TYPE_VPORT : error = dwg_decode_VPORT ( dat , obj ) ; break ; case DWG_TYPE_APPID_CONTROL : error = dwg_decode_APPID_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . APPID_CONTROL ) { obj -> tio . object -> tio . APPID_CONTROL -> objid = num ; dwg -> appid_control = * obj -> tio . object -> tio . APPID_CONTROL ; } break ; case DWG_TYPE_APPID : error = dwg_decode_APPID ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE_CONTROL : error = dwg_decode_DIMSTYLE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . DIMSTYLE_CONTROL ) { obj -> tio . object -> tio . DIMSTYLE_CONTROL -> objid = num ; dwg -> dimstyle_control = * obj -> tio . object -> tio . DIMSTYLE_CONTROL ; } break ; case DWG_TYPE_DIMSTYLE : error = dwg_decode_DIMSTYLE ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_CONTROL : error = dwg_decode_VPORT_ENTITY_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VPORT_ENTITY_CONTROL ) { obj -> tio . object -> tio . VPORT_ENTITY_CONTROL -> objid = num ; dwg -> vport_entity_control = * obj -> tio . object -> tio . VPORT_ENTITY_CONTROL ; } break ; case DWG_TYPE_VPORT_ENTITY_HEADER : error = dwg_decode_VPORT_ENTITY_HEADER ( dat , obj ) ; break ; case DWG_TYPE_GROUP : error = dwg_decode_GROUP ( dat , obj ) ; break ; case DWG_TYPE_MLINESTYLE : error = dwg_decode_MLINESTYLE ( dat , obj ) ; break ; case DWG_TYPE_OLE2FRAME : error = dwg_decode_OLE2FRAME ( dat , obj ) ; break ; case DWG_TYPE_DUMMY : error = dwg_decode_DUMMY ( dat , obj ) ; break ; case DWG_TYPE_LONG_TRANSACTION : error = dwg_decode_LONG_TRANSACTION ( dat , obj ) ; break ; case DWG_TYPE_LWPOLYLINE : error = dwg_decode_LWPOLYLINE ( dat , obj ) ; break ; case DWG_TYPE_HATCH : error = dwg_decode_HATCH ( dat , obj ) ; break ; case DWG_TYPE_XRECORD : error = dwg_decode_XRECORD ( dat , obj ) ; break ; case DWG_TYPE_PLACEHOLDER : error = dwg_decode_PLACEHOLDER ( dat , obj ) ; break ; case DWG_TYPE_OLEFRAME : error = dwg_decode_OLEFRAME ( dat , obj ) ; break ; case DWG_TYPE_VBA_PROJECT : LOG_ERROR ( ""Unhandled<S2SV_blank>Object<S2SV_blank>VBA_PROJECT.<S2SV_blank>Has<S2SV_blank>its<S2SV_blank>own<S2SV_blank>section"" ) ; error = DWG_ERR_UNHANDLEDCLASS ; break ; case DWG_TYPE_LAYOUT : error = dwg_decode_LAYOUT ( dat , obj ) ; break ; case DWG_TYPE_PROXY_ENTITY : error = dwg_decode_PROXY_ENTITY ( dat , obj ) ; break ; case DWG_TYPE_PROXY_OBJECT : error = dwg_decode_PROXY_OBJECT ( dat , obj ) ; break ; default : if ( obj -> type == dwg -> layout_type ) error = dwg_decode_LAYOUT ( dat , obj ) ; else if ( ( error = dwg_decode_variable_type ( dwg , dat , hdl_dat , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) { int is_entity = 0 ; int i = obj -> type - 500 ; Dwg_Class * klass = NULL ; <S2SV_StartBug> bit_set_position ( dat , restartpos ) ; <S2SV_EndBug> if ( i >= 0 && i < ( int ) dwg -> num_classes ) { klass = & dwg -> dwg_class [ i ] ; is_entity = dwg_class_is_entity ( klass ) ; } else { if ( i < 0 ) { LOG_ERROR ( ""Invalid<S2SV_blank>class<S2SV_blank>index<S2SV_blank>%d<S2SV_blank><0"" , i ) ; } else { LOG_ERROR ( ""Invalid<S2SV_blank>class<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>>%d"" , i , ( int ) dwg -> num_classes ) ; } <S2SV_StartBug> obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; <S2SV_EndBug> obj -> type = 0 ; * dat = abs_dat ; return error | DWG_ERR_VALUEOUTOFBOUNDS ; } <S2SV_StartBug> if ( klass && ! is_entity ) <S2SV_EndBug> { int err = dwg_decode_UNKNOWN_OBJ ( dat , obj ) ; error |= err ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; if ( ! dat ) return error ; <S2SV_StartBug> if ( err >= DWG_ERR_CRITICAL ) <S2SV_EndBug> * dat = abs_dat ; <S2SV_StartBug> } <S2SV_EndBug> else if ( klass ) { int err ; # if 0 && ! defined ( IS_RELEASE ) if ( strEQc ( klass -> dxfname , ""MULTILEADER"" ) ) { char * mleader = bit_read_TF ( dat , obj -> size ) ; LOG_INSANE_TF ( mleader , ( int ) obj -> size ) bit_set_position ( dat , restartpos ) ; free ( mleader ) ; } # endif err = dwg_decode_UNKNOWN_ENT ( dat , obj ) ; error |= err ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; if ( ! dat ) return error ; if ( err >= DWG_ERR_CRITICAL ) * dat = abs_dat ; } else { LOG_WARN ( ""Unknown<S2SV_blank>object,<S2SV_blank>skipping<S2SV_blank>eed/reactors/xdic"" ) ; SINCE ( R_2000 ) { obj -> bitsize = bit_read_RL ( dat ) ; LOG_TRACE ( ""bitsize:<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>[RL]<S2SV_blank>@%lu.%u\\n"" , obj -> bitsize , dat -> byte - 2 , dat -> bit ) ; if ( obj -> bitsize > obj -> size * 8 ) { LOG_ERROR ( ""Invalid<S2SV_blank>bitsize<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>=><S2SV_blank>"" FORMAT_RL , obj -> bitsize , obj -> size * 8 ) ; obj -> bitsize = obj -> size * 8 ; error |= DWG_ERR_VALUEOUTOFBOUNDS ; } } if ( ! bit_read_H ( dat , & obj -> handle ) ) { LOG_TRACE ( ""handle:<S2SV_blank>"" FORMAT_H ""<S2SV_blank>[H<S2SV_blank>5]\\n"" , ARGS_H ( obj -> handle ) ) ; } restartpos = dat -> byte ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; obj -> tio . unknown = bit_read_TF ( dat , obj -> size ) ; dat -> byte = restartpos ; } } } if ( obj -> handle . value ) { LOG_HANDLE ( ""<S2SV_blank>object_map{%lX}<S2SV_blank>=<S2SV_blank>%lu\\n"" , obj -> handle . value , ( unsigned long ) num ) ; hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; } if ( dat -> byte > 8 * dat -> size ) { LOG_ERROR ( ""Invalid<S2SV_blank>object<S2SV_blank>address<S2SV_blank>(overflow):<S2SV_blank>%lu<S2SV_blank>><S2SV_blank>%lu"" , dat -> byte , 8 * dat -> size ) ; * dat = abs_dat ; return error | DWG_ERR_INVALIDDWG ; } restartpos = bit_position ( dat ) ; * dat = abs_dat ; bit_set_position ( dat , objpos + restartpos ) ; if ( dat -> bit ) { unsigned char r = 8 - dat -> bit ; LOG_HANDLE ( ""<S2SV_blank>padding:<S2SV_blank>%X/%X<S2SV_blank>(%d<S2SV_blank>bits)\\n"" , dat -> chain [ dat -> byte ] , dat -> chain [ dat -> byte ] & ( ( 1 << r ) - 1 ) , r ) ; bit_advance_position ( dat , r ) ; } bit_set_position ( dat , ( obj -> address + obj -> size ) * 8 - 2 ) ; if ( ! bit_check_CRC ( dat , address , 0xC0C1 ) ) error |= DWG_ERR_WRONGCRC ; * dat = abs_dat ; return realloced ? - 1 : error ; }
","<S2SV_ModStart> , restartpos ) ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN <S2SV_ModStart> } obj -> <S2SV_ModEnd> type = 0 <S2SV_ModStart> } if ( is_entity ) error |= dwg_decode_UNKNOWN_ENT ( dat , obj ) ; else error |= dwg_decode_UNKNOWN_OBJ ( dat , obj ) ; if ( ! <S2SV_ModEnd> dat ) return <S2SV_ModStart> ; if ( error <S2SV_ModEnd> >= DWG_ERR_CRITICAL ) <S2SV_ModStart> = abs_dat ; <S2SV_ModEnd> } } if
",LibreDWG@libredwg/c6f6668b82bfe595899cc820279ac37bb9ef16f5,CVE-2019-20911,https://github.com/LibreDWG/libredwg/commit/c6f6668b82bfe595899cc820279ac37bb9ef16f5,2020-07-16T18:15Z,"<S2SV_StartBug> bit_set_position ( dat , restartpos ) ; <S2SV_EndBug> <S2SV_StartBug> obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; <S2SV_EndBug> <S2SV_StartBug> if ( klass && ! is_entity ) <S2SV_EndBug> <S2SV_StartBug> if ( err >= DWG_ERR_CRITICAL ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
3826,CWE-125,"static int lldp_private_8023_print ( netdissect_options * ndo , const u_char * tptr , u_int tlv_len ) { int subtype , hexdump = FALSE ; if ( tlv_len < 4 ) { return hexdump ; } subtype = * ( tptr + 3 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Subtype<S2SV_blank>(%u)"" , tok2str ( lldp_8023_subtype_values , ""unknown"" , subtype ) , subtype ) ) ; switch ( subtype ) { case LLDP_PRIVATE_8023_SUBTYPE_MACPHY : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>autonegotiation<S2SV_blank>[%s]<S2SV_blank>(0x%02x)"" , bittok2str ( lldp_8023_autonegotiation_values , ""none"" , * ( tptr + 4 ) ) , * ( tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>PMD<S2SV_blank>autoneg<S2SV_blank>capability<S2SV_blank>[%s]<S2SV_blank>(0x%04x)"" , bittok2str ( lldp_pmd_capability_values , ""unknown"" , EXTRACT_16BITS ( tptr + 5 ) ) , EXTRACT_16BITS ( tptr + 5 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MAU<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , tok2str ( lldp_mau_types_values , ""unknown"" , EXTRACT_16BITS ( tptr + 7 ) ) , EXTRACT_16BITS ( tptr + 7 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER : if ( tlv_len < 7 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MDI<S2SV_blank>power<S2SV_blank>support<S2SV_blank>[%s],<S2SV_blank>power<S2SV_blank>pair<S2SV_blank>%s,<S2SV_blank>power<S2SV_blank>class<S2SV_blank>%s"" , bittok2str ( lldp_mdi_values , ""none"" , * ( tptr + 4 ) ) , tok2str ( lldp_mdi_power_pairs_values , ""unknown"" , * ( tptr + 5 ) ) , tok2str ( lldp_mdi_power_class_values , ""unknown"" , * ( tptr + 6 ) ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>aggregation<S2SV_blank>status<S2SV_blank>[%s],<S2SV_blank>aggregation<S2SV_blank>port<S2SV_blank>ID<S2SV_blank>%u"" , bittok2str ( lldp_aggregation_values , ""none"" , * ( tptr + 4 ) ) , EXTRACT_32BITS ( tptr + 5 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MTU : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MTU<S2SV_blank>size<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; <S2SV_EndBug> break ; default : hexdump = TRUE ; break ; } return hexdump ; }
","<S2SV_ModStart> case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) { return hexdump ; }
",the-tcpdump-group@tcpdump/e6511cc1a950fe1566b2236329d6b4bd0826cc7a,CVE-2017-13054,https://github.com/the-tcpdump-group/tcpdump/commit/e6511cc1a950fe1566b2236329d6b4bd0826cc7a,2017-09-14T06:29Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MTU<S2SV_blank>size<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; <S2SV_EndBug>"
7516,CWE-20,"static char_u * did_set_string_option ( int opt_idx , char_u * * varp , int new_value_alloced , char_u * oldval , char_u * errbuf , int opt_flags ) { char_u * errmsg = NULL ; char_u * s , * p ; int did_chartab = FALSE ; char_u * * gvarp ; long_u free_oldval = ( options [ opt_idx ] . flags & P_ALLOCED ) ; # ifdef FEAT_GUI int redraw_gui_only = FALSE ; # endif gvarp = ( char_u * * ) get_varp_scope ( & ( options [ opt_idx ] ) , OPT_GLOBAL ) ; if ( ( secure # ifdef HAVE_SANDBOX || sandbox != 0 # endif ) && ( options [ opt_idx ] . flags & P_SECURE ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ] . flags & P_NFNAME ) && vim_strpbrk ( * varp , ( char_u * ) ""/\\\\*?[|<>"" ) != NULL ) { errmsg = e_invarg ; } else if ( varp == & T_NAME ) { if ( T_NAME [ 0 ] == NUL ) errmsg = ( char_u * ) N_ ( ""E529:<S2SV_blank>Cannot<S2SV_blank>set<S2SV_blank>\'term\'<S2SV_blank>to<S2SV_blank>empty<S2SV_blank>string"" ) ; # ifdef FEAT_GUI if ( gui . in_use ) errmsg = ( char_u * ) N_ ( ""E530:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>term<S2SV_blank>in<S2SV_blank>GUI"" ) ; else if ( term_is_gui ( T_NAME ) ) errmsg = ( char_u * ) N_ ( ""E531:<S2SV_blank>Use<S2SV_blank>\\"":gui\\""<S2SV_blank>to<S2SV_blank>start<S2SV_blank>the<S2SV_blank>GUI"" ) ; # endif else if ( set_termname ( T_NAME ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E522:<S2SV_blank>Not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>termcap"" ) ; else redraw_later_clear ( ) ; } else if ( gvarp == & p_bkc ) { char_u * bkc = p_bkc ; unsigned int * flags = & bkc_flags ; if ( opt_flags & OPT_LOCAL ) { bkc = curbuf -> b_p_bkc ; flags = & curbuf -> b_bkc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * bkc == NUL ) * flags = 0 ; else { if ( opt_strings_flags ( bkc , p_bkc_values , flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ( ( int ) * flags & BKC_AUTO ) != 0 ) + ( ( ( int ) * flags & BKC_YES ) != 0 ) + ( ( ( int ) * flags & BKC_NO ) != 0 ) != 1 ) { ( void ) opt_strings_flags ( oldval , p_bkc_values , flags , TRUE ) ; errmsg = e_invarg ; } } } else if ( varp == & p_bex || varp == & p_pm ) { if ( STRCMP ( * p_bex == '.' ? p_bex + 1 : p_bex , * p_pm == '.' ? p_pm + 1 : p_pm ) == 0 ) errmsg = ( char_u * ) N_ ( ""E589:<S2SV_blank>\'backupext\'<S2SV_blank>and<S2SV_blank>\'patchmode\'<S2SV_blank>are<S2SV_blank>equal"" ) ; } # ifdef FEAT_LINEBREAK else if ( varp == & curwin -> w_p_briopt ) { if ( briopt_check ( curwin ) == FAIL ) errmsg = e_invarg ; } # endif else if ( varp == & p_isi || varp == & ( curbuf -> b_p_isk ) || varp == & p_isp || varp == & p_isf ) { if ( init_chartab ( ) == FAIL ) { did_chartab = TRUE ; errmsg = e_invarg ; } } else if ( varp == & p_hf ) { if ( didset_vim ) { vim_setenv ( ( char_u * ) ""VIM"" , ( char_u * ) """" ) ; didset_vim = FALSE ; } if ( didset_vimruntime ) { vim_setenv ( ( char_u * ) ""VIMRUNTIME"" , ( char_u * ) """" ) ; didset_vimruntime = FALSE ; } } # ifdef FEAT_SYN_HL else if ( varp == & curwin -> w_p_cc ) errmsg = check_colorcolumn ( curwin ) ; # endif # ifdef FEAT_MULTI_LANG else if ( varp == & p_hlg ) { for ( s = p_hlg ; * s != NUL ; s += 3 ) { if ( s [ 1 ] == NUL || ( ( s [ 2 ] != ',' || s [ 3 ] == NUL ) && s [ 2 ] != NUL ) ) { errmsg = e_invarg ; break ; } if ( s [ 2 ] == NUL ) break ; } } # endif else if ( varp == & p_hl ) { if ( highlight_changed ( ) == FAIL ) errmsg = e_invarg ; } else if ( gvarp == & p_nf ) { if ( check_opt_strings ( * varp , p_nf_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_SESSION else if ( varp == & p_ssop ) { if ( opt_strings_flags ( p_ssop , p_ssop_values , & ssop_flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ssop_flags & SSOP_CURDIR ) && ( ssop_flags & SSOP_SESDIR ) ) { ( void ) opt_strings_flags ( oldval , p_ssop_values , & ssop_flags , TRUE ) ; errmsg = e_invarg ; } } else if ( varp == & p_vop ) { if ( opt_strings_flags ( p_vop , p_ssop_values , & vop_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_SCROLLBIND else if ( varp == & p_sbo ) { if ( check_opt_strings ( p_sbo , p_scbopt_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_ambw || varp == & p_emoji ) { if ( check_opt_strings ( p_ambw , p_ambw_values , FALSE ) != OK ) errmsg = e_invarg ; else if ( set_chars_option ( & p_lcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E834:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'listchars\'"" ) ; # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( set_chars_option ( & p_fcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E835:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'fillchars\'"" ) ; # endif } # endif else if ( varp == & p_bg ) { if ( check_opt_strings ( p_bg , p_bg_values , FALSE ) == OK ) { # ifdef FEAT_EVAL int dark = ( * p_bg == 'd' ) ; # endif init_highlight ( FALSE , FALSE ) ; # ifdef FEAT_EVAL if ( dark != ( * p_bg == 'd' ) && get_var_value ( ( char_u * ) ""g:colors_name"" ) != NULL ) { do_unlet ( ( char_u * ) ""g:colors_name"" , TRUE ) ; free_string_option ( p_bg ) ; p_bg = vim_strsave ( ( char_u * ) ( dark ? ""dark"" : ""light"" ) ) ; check_string_option ( & p_bg ) ; init_highlight ( FALSE , FALSE ) ; } # endif } else errmsg = e_invarg ; } else if ( varp == & p_wim ) { if ( check_opt_wim ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_CMDL_COMPL else if ( varp == & p_wop ) { if ( check_opt_strings ( p_wop , p_wop_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_WAK else if ( varp == & p_wak ) { if ( * p_wak == NUL || check_opt_strings ( p_wak , p_wak_values , FALSE ) != OK ) errmsg = e_invarg ; # ifdef FEAT_MENU # ifdef FEAT_GUI_MOTIF else if ( gui . in_use ) gui_motif_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # else # ifdef FEAT_GUI_GTK else if ( gui . in_use ) gui_gtk_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # endif # endif # endif } # endif # ifdef FEAT_AUTOCMD else if ( varp == & p_ei ) { if ( check_ei ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_enc || gvarp == & p_fenc || varp == & p_tenc ) { if ( gvarp == & p_fenc ) { if ( ! curbuf -> b_p_ma && opt_flags != OPT_GLOBAL ) errmsg = e_modifiable ; else if ( vim_strchr ( * varp , ',' ) != NULL ) errmsg = e_invarg ; else { # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; } } if ( errmsg == NULL ) { p = enc_canonize ( * varp ) ; if ( p != NULL ) { vim_free ( * varp ) ; * varp = p ; } if ( varp == & p_enc ) { errmsg = mb_init ( ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # if defined ( FEAT_GUI_GTK ) if ( errmsg == NULL && varp == & p_tenc && gui . in_use ) { if ( STRCMP ( p_tenc , ""utf-8"" ) != 0 ) errmsg = ( char_u * ) N_ ( ""E617:<S2SV_blank>Cannot<S2SV_blank>be<S2SV_blank>changed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>GTK+<S2SV_blank>2<S2SV_blank>GUI"" ) ; } # endif if ( errmsg == NULL ) { # ifdef FEAT_KEYMAP if ( varp == & p_enc && * curbuf -> b_p_keymap != NUL ) ( void ) keymap_init ( ) ; # endif if ( ( ( varp == & p_enc && * p_tenc != NUL ) || varp == & p_tenc ) ) { convert_setup ( & input_conv , p_tenc , p_enc ) ; convert_setup ( & output_conv , p_enc , p_tenc ) ; } # if defined ( WIN3264 ) && defined ( FEAT_MBYTE ) if ( varp == & p_enc ) init_homedir ( ) ; # endif } } # endif # if defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_penc ) { p = enc_canonize ( p_penc ) ; if ( p != NULL ) { vim_free ( p_penc ) ; p_penc = p ; } else { for ( s = p_penc ; * s != NUL ; s ++ ) { if ( * s == '_' ) * s = '-' ; else * s = TOLOWER_ASC ( * s ) ; } } } # endif # if defined ( FEAT_XIM ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_imak ) { if ( gui . in_use && ! im_xim_isvalid_imactivate ( ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap ) <S2SV_StartBug> { <S2SV_EndBug> errmsg = keymap_init ( ) ; if ( errmsg == NULL ) { if ( * curbuf -> b_p_keymap != NUL ) { curbuf -> b_p_iminsert = B_IMODE_LMAP ; if ( curbuf -> b_p_imsearch != B_IMODE_USE_INSERT ) curbuf -> b_p_imsearch = B_IMODE_LMAP ; } else { if ( curbuf -> b_p_iminsert == B_IMODE_LMAP ) curbuf -> b_p_iminsert = B_IMODE_NONE ; if ( curbuf -> b_p_imsearch == B_IMODE_LMAP ) curbuf -> b_p_imsearch = B_IMODE_USE_INSERT ; } if ( ( opt_flags & OPT_LOCAL ) == 0 ) { set_iminsert_global ( ) ; set_imsearch_global ( ) ; } # ifdef FEAT_WINDOWS status_redraw_curbuf ( ) ; # endif } } # endif else if ( gvarp == & p_ff ) { if ( ! curbuf -> b_p_ma && ! ( opt_flags & OPT_GLOBAL ) ) errmsg = e_modifiable ; else if ( check_opt_strings ( * varp , p_ff_values , FALSE ) != OK ) errmsg = e_invarg ; else { if ( get_fileformat ( curbuf ) == EOL_DOS ) curbuf -> b_p_tx = TRUE ; else curbuf -> b_p_tx = FALSE ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; if ( get_fileformat ( curbuf ) == EOL_MAC || * oldval == 'm' ) redraw_curbuf_later ( NOT_VALID ) ; } } else if ( varp == & p_ffs ) { if ( check_opt_strings ( p_ffs , p_ff_values , TRUE ) != OK ) errmsg = e_invarg ; else { if ( * p_ffs == NUL ) p_ta = FALSE ; else p_ta = TRUE ; } } # if defined ( FEAT_CRYPT ) else if ( gvarp == & p_key ) { # if defined ( FEAT_CMDHIST ) remove_key_from_history ( ) ; # endif if ( STRCMP ( curbuf -> b_p_key , oldval ) != 0 ) ml_set_crypt_key ( curbuf , oldval , * curbuf -> b_p_cm == NUL ? p_cm : curbuf -> b_p_cm ) ; } else if ( gvarp == & p_cm ) { if ( opt_flags & OPT_LOCAL ) p = curbuf -> b_p_cm ; else p = p_cm ; if ( check_opt_strings ( p , p_cm_values , TRUE ) != OK ) errmsg = e_invarg ; else if ( crypt_self_test ( ) == FAIL ) errmsg = e_invarg ; else { if ( * p_cm == NUL ) { if ( new_value_alloced ) free_string_option ( p_cm ) ; p_cm = vim_strsave ( ( char_u * ) ""zip"" ) ; new_value_alloced = TRUE ; } if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 ) { free_string_option ( curbuf -> b_p_cm ) ; curbuf -> b_p_cm = empty_option ; } if ( ( opt_flags & OPT_LOCAL ) && * oldval == NUL ) s = p_cm ; else s = oldval ; if ( * curbuf -> b_p_cm == NUL ) p = p_cm ; else p = curbuf -> b_p_cm ; if ( STRCMP ( s , p ) != 0 ) ml_set_crypt_key ( curbuf , curbuf -> b_p_key , s ) ; if ( ( opt_flags & OPT_GLOBAL ) && STRCMP ( p_cm , oldval ) != 0 ) { buf_T * buf ; FOR_ALL_BUFFERS ( buf ) if ( buf != curbuf && * buf -> b_p_cm == NUL ) ml_set_crypt_key ( buf , buf -> b_p_key , oldval ) ; } } } # endif else if ( gvarp == & p_mps ) { # ifdef FEAT_MBYTE if ( has_mbyte ) { for ( p = * varp ; * p != NUL ; ++ p ) { int x2 = - 1 ; int x3 = - 1 ; if ( * p != NUL ) p += mb_ptr2len ( p ) ; if ( * p != NUL ) x2 = * p ++ ; if ( * p != NUL ) { x3 = mb_ptr2char ( p ) ; p += mb_ptr2len ( p ) ; } if ( x2 != ':' || x3 == - 1 || ( * p != NUL && * p != ',' ) ) { errmsg = e_invarg ; break ; } if ( * p == NUL ) break ; } } else # endif { for ( p = * varp ; * p != NUL ; p += 4 ) { if ( p [ 1 ] != ':' || p [ 2 ] == NUL || ( p [ 3 ] != NUL && p [ 3 ] != ',' ) ) { errmsg = e_invarg ; break ; } if ( p [ 3 ] == NUL ) break ; } } } # ifdef FEAT_COMMENTS else if ( gvarp == & p_com ) { for ( s = * varp ; * s ; ) { while ( * s && * s != ':' ) { if ( vim_strchr ( ( char_u * ) COM_ALL , * s ) == NULL && ! VIM_ISDIGIT ( * s ) && * s != '-' ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } ++ s ; } if ( * s ++ == NUL ) errmsg = ( char_u * ) N_ ( ""E524:<S2SV_blank>Missing<S2SV_blank>colon"" ) ; else if ( * s == ',' || * s == NUL ) errmsg = ( char_u * ) N_ ( ""E525:<S2SV_blank>Zero<S2SV_blank>length<S2SV_blank>string"" ) ; if ( errmsg != NULL ) break ; while ( * s && * s != ',' ) { if ( * s == '\\\\' && s [ 1 ] != NUL ) ++ s ; ++ s ; } s = skip_to_option_part ( s ) ; } } # endif else if ( varp == & p_lcs ) { errmsg = set_chars_option ( varp ) ; } # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( varp == & p_fcs ) { errmsg = set_chars_option ( varp ) ; } # endif # ifdef FEAT_CMDWIN else if ( varp == & p_cedit ) { errmsg = check_cedit ( ) ; } # endif else if ( varp == & p_vfile ) { verbose_stop ( ) ; if ( * p_vfile != NUL && verbose_open ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_VIMINFO else if ( varp == & p_viminfo ) { for ( s = p_viminfo ; * s ; ) { if ( vim_strchr ( ( char_u * ) ""!\\""%\'/:<@cfhnrs"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * s == 'n' ) { break ; } else if ( * s == 'r' ) { while ( * ++ s && * s != ',' ) ; } else if ( * s == '%' ) { while ( vim_isdigit ( * ++ s ) ) ; } else if ( * s == '!' || * s == 'h' || * s == 'c' ) ++ s ; else { while ( vim_isdigit ( * ++ s ) ) ; if ( ! VIM_ISDIGIT ( * ( s - 1 ) ) ) { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E526:<S2SV_blank>Missing<S2SV_blank>number<S2SV_blank>after<S2SV_blank><%s>"" ) , transchar_byte ( * ( s - 1 ) ) ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } if ( * s == ',' ) ++ s ; else if ( * s ) { if ( errbuf != NULL ) errmsg = ( char_u * ) N_ ( ""E527:<S2SV_blank>Missing<S2SV_blank>comma"" ) ; else errmsg = ( char_u * ) """" ; break ; } } if ( * p_viminfo && errmsg == NULL && get_viminfo_parameter ( '\\'' ) < 0 ) errmsg = ( char_u * ) N_ ( ""E528:<S2SV_blank>Must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>\'<S2SV_blank>value"" ) ; } # endif else if ( istermoption ( & options [ opt_idx ] ) && full_screen ) { if ( varp == & T_CCO ) { int colors = atoi ( ( char * ) T_CCO ) ; if ( colors != t_colors ) { t_colors = colors ; if ( t_colors <= 1 ) { if ( new_value_alloced ) vim_free ( T_CCO ) ; T_CCO = empty_option ; } init_highlight ( TRUE , FALSE ) ; } } ttest ( FALSE ) ; if ( varp == & T_ME ) { out_str ( T_ME ) ; redraw_later ( CLEAR ) ; # if defined ( WIN3264 ) && ! defined ( FEAT_GUI_W32 ) mch_set_normal_colors ( ) ; # endif } } # ifdef FEAT_LINEBREAK else if ( varp == & p_sbr ) { for ( s = p_sbr ; * s ; ) { if ( ptr2cells ( s ) != 1 ) errmsg = ( char_u * ) N_ ( ""E595:<S2SV_blank>contains<S2SV_blank>unprintable<S2SV_blank>or<S2SV_blank>wide<S2SV_blank>character"" ) ; mb_ptr_adv ( s ) ; } } # endif # ifdef FEAT_GUI else if ( varp == & p_guifont ) { if ( gui . in_use ) { p = p_guifont ; # if defined ( FEAT_GUI_GTK ) if ( STRCMP ( p , ""*"" ) == 0 ) { p = gui_mch_font_dialog ( oldval ) ; if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = ( p != NULL ) ? p : vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } # endif if ( p != NULL && gui_init_font ( p_guifont , FALSE ) != OK ) { # if defined ( FEAT_GUI_MSWIN ) || defined ( FEAT_GUI_PHOTON ) if ( STRCMP ( p_guifont , ""*"" ) == 0 ) { if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } else # endif errmsg = ( char_u * ) N_ ( ""E596:<S2SV_blank>Invalid<S2SV_blank>font(s)"" ) ; } } redraw_gui_only = TRUE ; } # ifdef FEAT_XFONTSET else if ( varp == & p_guifontset ) { if ( STRCMP ( p_guifontset , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E597:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>fontset"" ) ; else if ( gui . in_use && gui_init_font ( p_guifontset , TRUE ) != OK ) errmsg = ( char_u * ) N_ ( ""E598:<S2SV_blank>Invalid<S2SV_blank>fontset"" ) ; redraw_gui_only = TRUE ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_guifontwide ) { if ( STRCMP ( p_guifontwide , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E533:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>wide<S2SV_blank>font"" ) ; else if ( gui_get_wide_font ( ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E534:<S2SV_blank>Invalid<S2SV_blank>wide<S2SV_blank>font"" ) ; redraw_gui_only = TRUE ; } # endif # endif # ifdef CURSOR_SHAPE else if ( varp == & p_guicursor ) errmsg = parse_shape_opt ( SHAPE_CURSOR ) ; # endif # ifdef FEAT_MOUSESHAPE else if ( varp == & p_mouseshape ) { errmsg = parse_shape_opt ( SHAPE_MOUSE ) ; update_mouseshape ( - 1 ) ; } # endif # ifdef FEAT_PRINTER else if ( varp == & p_popt ) errmsg = parse_printoptions ( ) ; # if defined ( FEAT_MBYTE ) && defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_pmfn ) errmsg = parse_printmbfont ( ) ; # endif # endif # ifdef FEAT_LANGMAP else if ( varp == & p_langmap ) langmap_set ( ) ; # endif # ifdef FEAT_LINEBREAK else if ( varp == & p_breakat ) fill_breakat_flags ( ) ; # endif # ifdef FEAT_TITLE else if ( varp == & p_titlestring || varp == & p_iconstring ) { # ifdef FEAT_STL_OPT int flagval = ( varp == & p_titlestring ) ? STL_IN_TITLE : STL_IN_ICON ; if ( vim_strchr ( * varp , '%' ) && check_stl_option ( * varp ) == NULL ) stl_syntax |= flagval ; else stl_syntax &= ~ flagval ; # endif did_set_title ( varp == & p_iconstring ) ; } # endif # ifdef FEAT_GUI else if ( varp == & p_go ) { gui_init_which_components ( oldval ) ; redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_GUI_TABLINE ) else if ( varp == & p_gtl ) { redraw_tabline = TRUE ; redraw_gui_only = TRUE ; } else if ( varp == & p_gtt ) { redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_MOUSE_TTY ) && ( defined ( UNIX ) || defined ( VMS ) ) else if ( varp == & p_ttym ) { mch_setmouse ( FALSE ) ; if ( opt_strings_flags ( p_ttym , p_ttym_values , & ttym_flags , FALSE ) != OK ) errmsg = e_invarg ; else check_mouse_termcode ( ) ; if ( termcap_active ) setmouse ( ) ; } # endif else if ( varp == & p_sel ) { if ( * p_sel == NUL || check_opt_strings ( p_sel , p_sel_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_slm ) { if ( check_opt_strings ( p_slm , p_slm_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_BROWSE else if ( varp == & p_bsdir ) { if ( check_opt_strings ( p_bsdir , p_bsdir_values , FALSE ) != OK && ! mch_isdir ( p_bsdir ) ) errmsg = e_invarg ; } # endif else if ( varp == & p_km ) { if ( check_opt_strings ( p_km , p_km_values , TRUE ) != OK ) errmsg = e_invarg ; else { km_stopsel = ( vim_strchr ( p_km , 'o' ) != NULL ) ; km_startsel = ( vim_strchr ( p_km , 'a' ) != NULL ) ; } } else if ( varp == & p_mousem ) { if ( check_opt_strings ( p_mousem , p_mousem_values , FALSE ) != OK ) errmsg = e_invarg ; # if defined ( FEAT_GUI_MOTIF ) && defined ( FEAT_MENU ) && ( XmVersion <= 1002 ) else if ( * p_mousem != * oldval ) gui_motif_update_mousemodel ( root_menu ) ; # endif } else if ( varp == & p_swb ) { if ( opt_strings_flags ( p_swb , p_swb_values , & swb_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_debug ) { if ( check_opt_strings ( p_debug , p_debug_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_dy ) { if ( opt_strings_flags ( p_dy , p_dy_values , & dy_flags , TRUE ) != OK ) errmsg = e_invarg ; else ( void ) init_chartab ( ) ; } # ifdef FEAT_WINDOWS else if ( varp == & p_ead ) { if ( check_opt_strings ( p_ead , p_ead_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_CLIPBOARD else if ( varp == & p_cb ) errmsg = check_clipboard_option ( ) ; # endif # ifdef FEAT_SPELL else if ( varp == & ( curwin -> w_s -> b_p_spl ) || varp == & ( curwin -> w_s -> b_p_spf ) ) { errmsg = did_set_spell_option ( varp == & ( curwin -> w_s -> b_p_spf ) ) ; } else if ( varp == & ( curwin -> w_s -> b_p_spc ) ) { errmsg = compile_cap_prog ( curwin -> w_s ) ; } else if ( varp == & p_sps ) { if ( spell_check_sps ( ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_msm ) { if ( spell_check_msm ( ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_QUICKFIX else if ( gvarp == & p_bh ) { if ( check_opt_strings ( curbuf -> b_p_bh , p_bufhidden_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_bt ) { if ( check_opt_strings ( curbuf -> b_p_bt , p_buftype_values , FALSE ) != OK ) errmsg = e_invarg ; else { # ifdef FEAT_WINDOWS if ( curwin -> w_status_height ) { curwin -> w_redr_status = TRUE ; redraw_later ( VALID ) ; } # endif curbuf -> b_help = ( curbuf -> b_p_bt [ 0 ] == 'h' ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # endif # ifdef FEAT_STL_OPT else if ( gvarp == & p_stl || varp == & p_ruf ) { int wid ; if ( varp == & p_ruf ) ru_wid = 0 ; s = * varp ; if ( varp == & p_ruf && * s == '%' ) { if ( * ++ s == '-' ) s ++ ; wid = getdigits ( & s ) ; if ( wid && * s == '(' && ( errmsg = check_stl_option ( p_ruf ) ) == NULL ) ru_wid = wid ; else errmsg = check_stl_option ( p_ruf ) ; } else if ( varp == & p_ruf || s [ 0 ] != '%' || s [ 1 ] != '!' ) errmsg = check_stl_option ( s ) ; if ( varp == & p_ruf && errmsg == NULL ) comp_col ( ) ; } # endif # ifdef FEAT_INS_EXPAND else if ( gvarp == & p_cpt ) { for ( s = * varp ; * s ; ) { while ( * s == ',' || * s == '<S2SV_blank>' ) s ++ ; if ( ! * s ) break ; if ( vim_strchr ( ( char_u * ) "".wbuksid]tU"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * ++ s != NUL && * s != ',' && * s != '<S2SV_blank>' ) { if ( s [ - 1 ] == 'k' || s [ - 1 ] == 's' ) { while ( * s && * s != ',' && * s != '<S2SV_blank>' ) { if ( * s == '\\\\' ) ++ s ; ++ s ; } } else { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E535:<S2SV_blank>Illegal<S2SV_blank>character<S2SV_blank>after<S2SV_blank><%c>"" ) , * -- s ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } } } else if ( varp == & p_cot ) { if ( check_opt_strings ( p_cot , p_cot_values , TRUE ) != OK ) errmsg = e_invarg ; else completeopt_was_set ( ) ; } # endif # ifdef FEAT_SIGNS else if ( varp == & curwin -> w_p_scl ) { if ( check_opt_strings ( * varp , p_scl_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # if defined ( FEAT_TOOLBAR ) && ! defined ( FEAT_GUI_W32 ) else if ( varp == & p_toolbar ) { if ( opt_strings_flags ( p_toolbar , p_toolbar_values , & toolbar_flags , TRUE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif # if defined ( FEAT_TOOLBAR ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_tbis ) { if ( opt_strings_flags ( p_tbis , p_tbis_values , & tbis_flags , FALSE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif else if ( varp == & p_pt ) { if ( * p_pt ) { ( void ) replace_termcodes ( p_pt , & p , TRUE , TRUE , FALSE ) ; if ( p != NULL ) { if ( new_value_alloced ) free_string_option ( p_pt ) ; p_pt = p ; new_value_alloced = TRUE ; } } } else if ( varp == & p_bs ) { if ( VIM_ISDIGIT ( * p_bs ) ) { if ( * p_bs > '2' || p_bs [ 1 ] != NUL ) errmsg = e_invarg ; } else if ( check_opt_strings ( p_bs , p_bs_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_bo ) { if ( opt_strings_flags ( p_bo , p_bo_values , & bo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_tc ) { unsigned int * flags ; if ( opt_flags & OPT_LOCAL ) { p = curbuf -> b_p_tc ; flags = & curbuf -> b_tc_flags ; } else { p = p_tc ; flags = & tc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * p == NUL ) * flags = 0 ; else if ( * p == NUL || opt_strings_flags ( p , p_tc_values , flags , FALSE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_MBYTE else if ( varp == & p_cmp ) { if ( opt_strings_flags ( p_cmp , p_cmp_values , & cmp_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_DIFF else if ( varp == & p_dip ) { if ( diffopt_changed ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_FOLDING else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdm ) { if ( check_opt_strings ( * varp , p_fdm_values , FALSE ) != OK || * curwin -> w_p_fdm == NUL ) errmsg = e_invarg ; else { foldUpdateAll ( curwin ) ; if ( foldmethodIsDiff ( curwin ) ) newFoldLevel ( ) ; } } # ifdef FEAT_EVAL else if ( varp == & curwin -> w_p_fde ) { if ( foldmethodIsExpr ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif else if ( gvarp == & curwin -> w_allbuf_opt . wo_fmr ) { p = vim_strchr ( * varp , ',' ) ; if ( p == NULL ) errmsg = ( char_u * ) N_ ( ""E536:<S2SV_blank>comma<S2SV_blank>required"" ) ; else if ( p == * varp || p [ 1 ] == NUL ) errmsg = e_invarg ; else if ( foldmethodIsMarker ( curwin ) ) foldUpdateAll ( curwin ) ; } else if ( gvarp == & p_cms ) { if ( * * varp != NUL && strstr ( ( char * ) * varp , ""%s"" ) == NULL ) errmsg = ( char_u * ) N_ ( ""E537:<S2SV_blank>\'commentstring\'<S2SV_blank>must<S2SV_blank>be<S2SV_blank>empty<S2SV_blank>or<S2SV_blank>contain<S2SV_blank>%s"" ) ; } else if ( varp == & p_fdo ) { if ( opt_strings_flags ( p_fdo , p_fdo_values , & fdo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_fcl ) { if ( check_opt_strings ( p_fcl , p_fcl_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdi ) { if ( foldmethodIsIndent ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif # ifdef FEAT_VIRTUALEDIT else if ( varp == & p_ve ) { if ( opt_strings_flags ( p_ve , p_ve_values , & ve_flags , TRUE ) != OK ) errmsg = e_invarg ; else if ( STRCMP ( p_ve , oldval ) != 0 ) { validate_virtcol ( ) ; coladvance ( curwin -> w_virtcol ) ; } } # endif # if defined ( FEAT_CSCOPE ) && defined ( FEAT_QUICKFIX ) else if ( varp == & p_csqf ) { if ( p_csqf != NULL ) { p = p_csqf ; while ( * p != NUL ) { if ( vim_strchr ( ( char_u * ) CSQF_CMDS , * p ) == NULL || p [ 1 ] == NUL || vim_strchr ( ( char_u * ) CSQF_FLAGS , p [ 1 ] ) == NULL || ( p [ 2 ] != NUL && p [ 2 ] != ',' ) ) { errmsg = e_invarg ; break ; } else if ( p [ 2 ] == NUL ) break ; else p += 3 ; } } } # endif # ifdef FEAT_CINDENT else if ( gvarp == & p_cino ) { parse_cino ( curbuf ) ; } # endif # if defined ( FEAT_RENDER_OPTIONS ) else if ( varp == & p_rop && gui . in_use ) { <S2SV_StartBug> if ( ! gui_mch_set_rendering_options ( p_rop ) ) <S2SV_EndBug> errmsg = e_invarg ; } # endif else { p = NULL ; if ( varp == & p_ww ) p = ( char_u * ) WW_ALL ; if ( varp == & p_shm ) p = ( char_u * ) SHM_ALL ; else if ( varp == & ( p_cpo ) ) p = ( char_u * ) CPO_ALL ; else if ( varp == & ( curbuf -> b_p_fo ) ) p = ( char_u * ) FO_ALL ; # ifdef FEAT_CONCEAL else if ( varp == & curwin -> w_p_cocu ) p = ( char_u * ) COCU_ALL ; # endif else if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE p = ( char_u * ) MOUSE_ALL ; # else if ( * p_mouse != NUL ) errmsg = ( char_u * ) N_ ( ""E538:<S2SV_blank>No<S2SV_blank>mouse<S2SV_blank>support"" ) ; # endif } # if defined ( FEAT_GUI ) else if ( varp == & p_go ) p = ( char_u * ) GO_ALL ; # endif if ( p != NULL ) { for ( s = * varp ; * s ; ++ s ) if ( vim_strchr ( p , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } } } if ( errmsg != NULL ) { if ( new_value_alloced ) free_string_option ( * varp ) ; * varp = oldval ; if ( did_chartab ) ( void ) init_chartab ( ) ; if ( varp == & p_hl ) ( void ) highlight_changed ( ) ; } else { # ifdef FEAT_EVAL set_option_scriptID_idx ( opt_idx , opt_flags , current_SID ) ; # endif if ( free_oldval ) free_string_option ( oldval ) ; if ( new_value_alloced ) options [ opt_idx ] . flags |= P_ALLOCED ; else options [ opt_idx ] . flags &= ~ P_ALLOCED ; if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 && ( ( int ) options [ opt_idx ] . indir & PV_BOTH ) ) { p = get_varp_scope ( & ( options [ opt_idx ] ) , OPT_LOCAL ) ; free_string_option ( * ( char_u * * ) p ) ; * ( char_u * * ) p = empty_option ; } else if ( ! ( opt_flags & OPT_LOCAL ) && opt_flags != OPT_GLOBAL ) set_string_option_global ( opt_idx , varp ) ; # ifdef FEAT_AUTOCMD # ifdef FEAT_SYN_HL if ( varp == & ( curbuf -> b_p_syn ) ) { apply_autocmds ( EVENT_SYNTAX , curbuf -> b_p_syn , curbuf -> b_fname , TRUE , curbuf ) ; } # endif else if ( varp == & ( curbuf -> b_p_ft ) ) { did_filetype = TRUE ; apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } # endif # ifdef FEAT_SPELL if ( varp == & ( curwin -> w_s -> b_p_spl ) ) { char_u fname [ 200 ] ; char_u * q = curwin -> w_s -> b_p_spl ; if ( STRNCMP ( q , ""cjk,"" , 4 ) == 0 ) q += 4 ; for ( p = q ; * p != NUL ; ++ p ) if ( vim_strchr ( ( char_u * ) ""_.,"" , * p ) != NULL ) break ; vim_snprintf ( ( char * ) fname , 200 , ""spell/%.*s.vim"" , ( int ) ( p - q ) , q ) ; source_runtime ( fname , DIP_ALL ) ; } # endif } # ifdef FEAT_MOUSE if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE_TTY if ( * p_mouse == NUL ) mch_setmouse ( FALSE ) ; else # endif setmouse ( ) ; } # endif if ( curwin -> w_curswant != MAXCOL && ( options [ opt_idx ] . flags & ( P_CURSWANT | P_RALL ) ) != 0 ) curwin -> w_set_curswant = TRUE ; # ifdef FEAT_GUI if ( ! redraw_gui_only || gui . in_use ) # endif check_redraw ( options [ opt_idx ] . flags ) ; return errmsg ; }
","<S2SV_ModStart> b_p_keymap ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; else <S2SV_ModStart> gui_mch_set_rendering_options ( p_rop ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) { if ( ! valid_filetype ( * varp
",vim@vim/d0b5138ba4bccff8a744c99836041ef6322ed39a,CVE-2016-1248,https://github.com/vim/vim/commit/d0b5138ba4bccff8a744c99836041ef6322ed39a,2016-11-23T15:59Z,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( ! gui_mch_set_rendering_options ( p_rop ) ) <S2SV_EndBug>
6925,CWE-400,"asmlinkage void kernel_unaligned_trap ( struct pt_regs * regs , unsigned int insn ) { enum direction dir = decode_direction ( insn ) ; int size = decode_access_size ( regs , insn ) ; int orig_asi , asi ; current_thread_info ( ) -> kern_una_regs = regs ; current_thread_info ( ) -> kern_una_insn = insn ; orig_asi = asi = decode_asi ( insn , regs ) ; if ( asi == ASI_AIUS ) { kernel_mna_trap_fault ( 0 ) ; return ; } log_unaligned ( regs ) ; if ( ! ok_for_kernel ( insn ) || dir == both ) { printk ( ""Unsupported<S2SV_blank>unaligned<S2SV_blank>load/store<S2SV_blank>trap<S2SV_blank>for<S2SV_blank>kernel<S2SV_blank>"" ""at<S2SV_blank><%016lx>.\\n"" , regs -> tpc ) ; unaligned_panic ( ""Kernel<S2SV_blank>does<S2SV_blank>fpu/atomic<S2SV_blank>"" ""unaligned<S2SV_blank>load/store."" , regs ) ; kernel_mna_trap_fault ( 0 ) ; } else { unsigned long addr , * reg_addr ; int err ; addr = compute_effective_address ( regs , insn , ( ( insn >> 25 ) & 0x1f ) ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug> switch ( asi ) { case ASI_NL : case ASI_AIUPL : case ASI_AIUSL : case ASI_PL : case ASI_SL : case ASI_PNFL : case ASI_SNFL : asi &= ~ 0x08 ; break ; } switch ( dir ) { case load : reg_addr = fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) , regs ) ; err = do_int_load ( reg_addr , size , ( unsigned long * ) addr , decode_signedness ( insn ) , asi ) ; if ( likely ( ! err ) && unlikely ( asi != orig_asi ) ) { unsigned long val_in = * reg_addr ; switch ( size ) { case 2 : val_in = swab16 ( val_in ) ; break ; case 4 : val_in = swab32 ( val_in ) ; break ; case 8 : val_in = swab64 ( val_in ) ; break ; case 16 : default : BUG ( ) ; break ; } * reg_addr = val_in ; } break ; case store : err = do_int_store ( ( ( insn >> 25 ) & 0x1f ) , size , ( unsigned long * ) addr , regs , asi , orig_asi ) ; break ; default : panic ( ""Impossible<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>trap."" ) ; } if ( unlikely ( err ) ) kernel_mna_trap_fault ( 1 ) ; else advance ( regs ) ; } }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug>"
1287,CWE-125,"static char * isis_print_id ( const uint8_t * cp , int id_len ) { int i ; static char id [ sizeof ( ""xxxx.xxxx.xxxx.yy-zz"" ) ] ; char * pos = id ; <S2SV_StartBug> for ( i = 1 ; i <= SYSTEM_ID_LEN ; i ++ ) { <S2SV_EndBug> snprintf ( pos , sizeof ( id ) - ( pos - id ) , ""%02x"" , * cp ++ ) ; pos += strlen ( pos ) ; if ( i == 2 || i == 4 ) * pos ++ = '.' ; } if ( id_len >= NODE_ID_LEN ) { snprintf ( pos , sizeof ( id ) - ( pos - id ) , "".%02x"" , * cp ++ ) ; pos += strlen ( pos ) ; } if ( id_len == LSP_ID_LEN ) snprintf ( pos , sizeof ( id ) - ( pos - id ) , ""-%02x"" , * cp ) ; return ( id ) ; }
","<S2SV_ModStart> = id ; int sysid_len ; sysid_len = SYSTEM_ID_LEN ; if ( sysid_len > id_len ) sysid_len = id_len ; <S2SV_ModStart> ; i <= sysid_len <S2SV_ModEnd> ; i ++
",the-tcpdump-group@tcpdump/571a6f33f47e7a2394fa08f925e534135c29cf1e,CVE-2017-13035,https://github.com/the-tcpdump-group/tcpdump/commit/571a6f33f47e7a2394fa08f925e534135c29cf1e,2017-09-14T06:29Z,<S2SV_StartBug> for ( i = 1 ; i <= SYSTEM_ID_LEN ; i ++ ) { <S2SV_EndBug>
636,CWE-119,"static int catc_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct device * dev = & intf -> dev ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct net_device * netdev ; struct catc * catc ; u8 broadcast [ ETH_ALEN ] ; <S2SV_StartBug> int i , pktsz , ret ; <S2SV_EndBug> if ( usb_set_interface ( usbdev , intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) { dev_err ( dev , ""Can\'t<S2SV_blank>set<S2SV_blank>altsetting<S2SV_blank>1.\\n"" ) ; return - EIO ; } netdev = alloc_etherdev ( sizeof ( struct catc ) ) ; if ( ! netdev ) return - ENOMEM ; catc = netdev_priv ( netdev ) ; netdev -> netdev_ops = & catc_netdev_ops ; netdev -> watchdog_timeo = TX_TIMEOUT ; netdev -> ethtool_ops = & ops ; catc -> usbdev = usbdev ; catc -> netdev = netdev ; spin_lock_init ( & catc -> tx_lock ) ; spin_lock_init ( & catc -> ctrl_lock ) ; init_timer ( & catc -> timer ) ; catc -> timer . data = ( long ) catc ; catc -> timer . function = catc_stats_timer ; catc -> ctrl_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> tx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> rx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> irq_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ( ! catc -> ctrl_urb ) || ( ! catc -> tx_urb ) || ( ! catc -> rx_urb ) || ( ! catc -> irq_urb ) ) { dev_err ( & intf -> dev , ""No<S2SV_blank>free<S2SV_blank>urbs<S2SV_blank>available.\\n"" ) ; ret = - ENOMEM ; goto fail_free ; } if ( le16_to_cpu ( usbdev -> descriptor . idVendor ) == 0x0423 && le16_to_cpu ( usbdev -> descriptor . idProduct ) == 0xa && le16_to_cpu ( catc -> usbdev -> descriptor . bcdDevice ) == 0x0130 ) { dev_dbg ( dev , ""Testing<S2SV_blank>for<S2SV_blank>f5u011\\n"" ) ; catc -> is_f5u011 = 1 ; atomic_set ( & catc -> recq_sz , 0 ) ; pktsz = RX_PKT_SZ ; } else { pktsz = RX_MAX_BURST * ( PKT_SZ + 2 ) ; } usb_fill_control_urb ( catc -> ctrl_urb , usbdev , usb_sndctrlpipe ( usbdev , 0 ) , NULL , NULL , 0 , catc_ctrl_done , catc ) ; usb_fill_bulk_urb ( catc -> tx_urb , usbdev , usb_sndbulkpipe ( usbdev , 1 ) , NULL , 0 , catc_tx_done , catc ) ; usb_fill_bulk_urb ( catc -> rx_urb , usbdev , usb_rcvbulkpipe ( usbdev , 1 ) , catc -> rx_buf , pktsz , catc_rx_done , catc ) ; usb_fill_int_urb ( catc -> irq_urb , usbdev , usb_rcvintpipe ( usbdev , 2 ) , catc -> irq_buf , 2 , catc_irq_done , catc , 1 ) ; if ( ! catc -> is_f5u011 ) { <S2SV_StartBug> dev_dbg ( dev , ""Checking<S2SV_blank>memory<S2SV_blank>size\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x12345678 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x87654321 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0xfa80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> catc_read_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( i ) { <S2SV_EndBug> case 0x12345678 : catc_set_reg ( catc , TxBufCount , 8 ) ; catc_set_reg ( catc , RxBufCount , 32 ) ; dev_dbg ( dev , ""64k<S2SV_blank>Memory\\n"" ) ; break ; default : dev_warn ( & intf -> dev , ""Couldn\'t<S2SV_blank>detect<S2SV_blank>memory<S2SV_blank>size,<S2SV_blank>assuming<S2SV_blank>32k\\n"" ) ; case 0x87654321 : catc_set_reg ( catc , TxBufCount , 4 ) ; catc_set_reg ( catc , RxBufCount , 16 ) ; dev_dbg ( dev , ""32k<S2SV_blank>Memory\\n"" ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> dev_dbg ( dev , ""Getting<S2SV_blank>MAC<S2SV_blank>from<S2SV_blank>SEEROM.\\n"" ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , ""Setting<S2SV_blank>MAC<S2SV_blank>into<S2SV_blank>registers.\\n"" ) ; for ( i = 0 ; i < 6 ; i ++ ) catc_set_reg ( catc , StationAddr0 - i , netdev -> dev_addr [ i ] ) ; dev_dbg ( dev , ""Filling<S2SV_blank>the<S2SV_blank>multicast<S2SV_blank>list.\\n"" ) ; eth_broadcast_addr ( broadcast ) ; catc_multicast ( broadcast , catc -> multicast ) ; catc_multicast ( netdev -> dev_addr , catc -> multicast ) ; catc_write_mem ( catc , 0xfa80 , catc -> multicast , 64 ) ; dev_dbg ( dev , ""Clearing<S2SV_blank>error<S2SV_blank>counters.\\n"" ) ; for ( i = 0 ; i < 8 ; i ++ ) catc_set_reg ( catc , EthStats + i , 0 ) ; catc -> last_stats = jiffies ; dev_dbg ( dev , ""Enabling.\\n"" ) ; catc_set_reg ( catc , MaxBurst , RX_MAX_BURST ) ; catc_set_reg ( catc , OpModes , OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits ) ; catc_set_reg ( catc , LEDCtrl , LEDLink ) ; catc_set_reg ( catc , RxUnit , RxEnable | RxPolarity | RxMultiCast ) ; } else { dev_dbg ( dev , ""Performing<S2SV_blank>reset\\n"" ) ; catc_reset ( catc ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , ""Setting<S2SV_blank>RX<S2SV_blank>Mode\\n"" ) ; catc -> rxmode [ 0 ] = RxEnable | RxPolarity | RxMultiCast ; catc -> rxmode [ 1 ] = 0 ; f5u011_rxmode ( catc , catc -> rxmode ) ; } dev_dbg ( dev , ""Init<S2SV_blank>done.\\n"" ) ; printk ( KERN_INFO ""%s:<S2SV_blank>%s<S2SV_blank>USB<S2SV_blank>Ethernet<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%pM.\\n"" , netdev -> name , ( catc -> is_f5u011 ) ? ""Belkin<S2SV_blank>F5U011"" : ""CATC<S2SV_blank>EL1210A<S2SV_blank>NetMate"" , usbdev -> bus -> bus_name , usbdev -> devpath , netdev -> dev_addr ) ; usb_set_intfdata ( intf , catc ) ; SET_NETDEV_DEV ( netdev , & intf -> dev ) ; ret = register_netdev ( netdev ) ; if ( ret ) goto fail_clear_intfdata ; return 0 ; fail_clear_intfdata : usb_set_intfdata ( intf , NULL ) ; fail_free : usb_free_urb ( catc -> ctrl_urb ) ; usb_free_urb ( catc -> tx_urb ) ; usb_free_urb ( catc -> rx_urb ) ; usb_free_urb ( catc -> irq_urb ) ; free_netdev ( netdev ) ; return ret ; }
","<S2SV_ModStart> ] ; int <S2SV_ModEnd> pktsz , ret <S2SV_ModStart> is_f5u011 ) { u32 * buf ; int i ; <S2SV_ModStart> ""Checking<S2SV_blank>memory<S2SV_blank>size\\n"" ) ; buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf <S2SV_ModEnd> = 0x12345678 ; <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> 4 ) ; * buf <S2SV_ModEnd> = 0x87654321 ; <S2SV_ModStart> , 0xfa80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> ; switch ( * buf <S2SV_ModEnd> ) { case <S2SV_ModStart> break ; } kfree ( buf ) ;
",torvalds@linux/2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478,CVE-2017-8070,https://github.com/torvalds/linux/commit/2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478,2017-04-23T05:59Z,"<S2SV_StartBug> int i , pktsz , ret ; <S2SV_EndBug> <S2SV_StartBug> dev_dbg ( dev , ""Checking<S2SV_blank>memory<S2SV_blank>size\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x12345678 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x87654321 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0xfa80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> catc_read_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( i ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
1047,CWE-284,"bool config_save ( const config_t * config , const char * filename ) { assert ( config != NULL ) ; assert ( filename != NULL ) ; assert ( * filename != '\\0' ) ; <S2SV_StartBug> char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! temp_filename ) { <S2SV_EndBug> LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>filename."" , __func__ ) ; return false ; } strcpy ( temp_filename , filename ) ; strcat ( temp_filename , "".new"" ) ; FILE * fp = fopen ( temp_filename , ""wt"" ) ; if ( ! fp ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } for ( const list_node_t * node = list_begin ( config -> sections ) ; node != list_end ( config -> sections ) ; node = list_next ( node ) ) { const section_t * section = ( const section_t * ) list_node ( node ) ; <S2SV_StartBug> fprintf ( fp , ""[%s]\\n"" , section -> name ) ; <S2SV_EndBug> for ( const list_node_t * enode = list_begin ( section -> entries ) ; enode != list_end ( section -> entries ) ; enode = list_next ( enode ) ) { const entry_t * entry = ( const entry_t * ) list_node ( enode ) ; <S2SV_StartBug> fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\n"" , entry -> key , entry -> value ) ; <S2SV_EndBug> } if ( list_next ( node ) != list_end ( config -> sections ) ) <S2SV_StartBug> fputc ( '\\n' , fp ) ; <S2SV_EndBug> } fflush ( fp ) ; <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>file<S2SV_blank>permissions<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } if ( rename ( temp_filename , filename ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>commit<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug> return true ; <S2SV_StartBug> error : ; <S2SV_EndBug> unlink ( temp_filename ) ; <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug> return false ; }
","<S2SV_ModStart> '\\0' ) ; int dir_fd = - 1 ; FILE * fp = NULL ; static const char * temp_file_ext = "".new"" ; const int filename_len = strlen ( filename ) ; const int temp_filename_len = filename_len + strlen ( temp_file_ext ) + 1 ; char * <S2SV_ModEnd> temp_filename = osi_calloc <S2SV_ModStart> = osi_calloc ( temp_filename_len ) ; snprintf ( temp_filename , temp_filename_len , ""%s%s"" , filename , temp_file_ext ) ; char * temp_dirname = osi_strdup ( filename ) ; const char * directoryname = dirname ( temp_dirname <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! directoryname ) { LOG_ERROR ( ""%s<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>directory<S2SV_blank>from<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } dir_fd = TEMP_FAILURE_RETRY ( open ( directoryname , O_RDONLY ) ) ; if ( dir_fd < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> fp = fopen <S2SV_ModStart> node ) ; if ( <S2SV_ModStart> -> name ) < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> for ( const <S2SV_ModStart> enode ) ; if ( <S2SV_ModStart> -> value ) < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> } if ( <S2SV_ModStart> sections ) ) { if ( <S2SV_ModStart> , fp ) == EOF ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } } } if ( fsync ( fileno ( fp ) ) < 0 ) { LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; } if ( <S2SV_ModEnd> fclose ( fp <S2SV_ModStart> ( fp ) == EOF ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } fp = NULL <S2SV_ModStart> error ; } if ( fsync ( dir_fd ) < 0 ) { LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; } if ( close ( dir_fd ) < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModStart> osi_free ( temp_filename ) ; osi_free ( temp_dirname <S2SV_ModStart> ; error : <S2SV_ModEnd> unlink ( temp_filename <S2SV_ModStart> temp_filename ) ; if ( fp ) fclose ( fp ) ; if ( dir_fd != - 1 ) close ( dir_fd ) ; <S2SV_ModStart> osi_free ( temp_filename ) ; osi_free ( temp_dirname
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! temp_filename ) { <S2SV_EndBug> <S2SV_StartBug> fprintf ( fp , ""[%s]\\n"" , section -> name ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\n"" , entry -> key , entry -> value ) ; <S2SV_EndBug> <S2SV_StartBug> fputc ( '\\n' , fp ) ; <S2SV_EndBug> <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug> <S2SV_StartBug> error : ; <S2SV_EndBug> <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug>"
7247,CWE-125,"int pure_strcmp ( const char * const s1 , const char * const s2 ) { <S2SV_StartBug> return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ; <S2SV_EndBug> }
","<S2SV_ModStart> s2 ) { const size_t s1_len = strlen ( s1 ) ; const size_t s2_len = strlen ( s2 ) ; const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ; <S2SV_ModStart> , s2 , len + 1 <S2SV_ModEnd> ) ; }
",jedisct1@pure-ftpd/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,CVE-2020-9365,https://github.com/jedisct1/pure-ftpd/commit/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,2020-02-24T16:15Z,"<S2SV_StartBug> return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ; <S2SV_EndBug>"
4514,CWE-125,"static char * fp_readl ( char * s , int size , struct tok_state * tok ) { PyObject * bufobj ; const char * buf ; Py_ssize_t buflen ; assert ( size > 0 ) ; size -- ; if ( tok -> decoding_buffer ) { bufobj = tok -> decoding_buffer ; Py_INCREF ( bufobj ) ; } else { <S2SV_StartBug> bufobj = PyObject_CallObject ( tok -> decoding_readline , NULL ) ; <S2SV_EndBug> if ( bufobj == NULL ) goto error ; } if ( PyUnicode_CheckExact ( bufobj ) ) { buf = PyUnicode_AsUTF8AndSize ( bufobj , & buflen ) ; if ( buf == NULL ) { goto error ; } } else { buf = PyByteArray_AsString ( bufobj ) ; if ( buf == NULL ) { goto error ; } buflen = PyByteArray_GET_SIZE ( bufobj ) ; } Py_XDECREF ( tok -> decoding_buffer ) ; if ( buflen > size ) { tok -> decoding_buffer = PyByteArray_FromStringAndSize ( buf + size , buflen - size ) ; if ( tok -> decoding_buffer == NULL ) goto error ; buflen = size ; } else tok -> decoding_buffer = NULL ; memcpy ( s , buf , buflen ) ; s [ buflen ] = '\\0' ; if ( buflen == 0 ) s = NULL ; Py_DECREF ( bufobj ) ; return s ; error : Py_XDECREF ( bufobj ) ; return error_ret ( tok ) ; }
","<S2SV_ModStart> { bufobj = _PyObject_CallNoArg <S2SV_ModEnd> ( tok -> <S2SV_ModStart> tok -> decoding_readline <S2SV_ModEnd> ) ; if
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> bufobj = PyObject_CallObject ( tok -> decoding_readline , NULL ) ; <S2SV_EndBug>"
1791,CWE-119,"void vp9_update_mbgraph_stats ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; int i , n_frames = vp9_lookahead_depth ( cpi -> lookahead ) ; <S2SV_StartBug> YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; <S2SV_EndBug> if ( n_frames <= cpi -> rc . frames_till_gf_update_due ) return ; if ( n_frames > MAX_LAG_BUFFERS ) n_frames = MAX_LAG_BUFFERS ; cpi -> mbgraph_n_frames = n_frames ; for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; <S2SV_StartBug> vpx_memset ( frame_stats -> mb_stats , 0 , <S2SV_EndBug> cm -> mb_rows * cm -> mb_cols * sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ; } for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; struct lookahead_entry * q_cur = vp9_lookahead_peek ( cpi -> lookahead , i ) ; assert ( q_cur != NULL ) ; update_mbgraph_frame_stats ( cpi , frame_stats , & q_cur -> img , golden_ref , cpi -> Source ) ; } <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> separate_arf_mbs ( cpi ) ; }
","<S2SV_ModStart> cpi , GOLDEN_FRAME ) ; assert ( golden_ref != NULL <S2SV_ModStart> i ] ; memset <S2SV_ModEnd> ( frame_stats -> <S2SV_ModStart> ) ; } vpx_clear_system_state <S2SV_ModEnd> ( ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( frame_stats -> mb_stats , 0 , <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug>"
4550,CWE-125,"int obj2ast_type_ignore ( PyObject * obj , type_ignore_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) TypeIgnore_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { int lineno ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_int ( tmp , & lineno , arena ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res != 0 ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>TypeIgnore"" ) ; return 1 ; } * out = TypeIgnore ( lineno , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>type_ignore,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>TypeIgnore"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } * out = TypeIgnore ( <S2SV_ModEnd> lineno , arena <S2SV_ModStart> ; if ( * out == NULL <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; <S2SV_ModEnd> return 0 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_int ( tmp , & lineno , arena ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res != 0 ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug>"
3863,CWE-125,"static const struct usb_cdc_union_desc * ims_pcu_get_cdc_union_desc ( struct usb_interface * intf ) { const void * buf = intf -> altsetting -> extra ; size_t buflen = intf -> altsetting -> extralen ; struct usb_cdc_union_desc * union_desc ; if ( ! buf ) { dev_err ( & intf -> dev , ""Missing<S2SV_blank>descriptor<S2SV_blank>data\\n"" ) ; return NULL ; } if ( ! buflen ) { dev_err ( & intf -> dev , ""Zero<S2SV_blank>length<S2SV_blank>descriptor\\n"" ) ; return NULL ; } <S2SV_StartBug> while ( buflen > 0 ) { <S2SV_EndBug> union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bDescriptorType == USB_DT_CS_INTERFACE && union_desc -> bDescriptorSubType == USB_CDC_UNION_TYPE ) { dev_dbg ( & intf -> dev , ""Found<S2SV_blank>union<S2SV_blank>header\\n"" ) ; <S2SV_StartBug> return union_desc ; <S2SV_EndBug> } buflen -= union_desc -> bLength ; buf += union_desc -> bLength ; } dev_err ( & intf -> dev , ""Missing<S2SV_blank>CDC<S2SV_blank>union<S2SV_blank>descriptor\\n"" ) ; return NULL ; }
","<S2SV_ModStart> while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , ""Too<S2SV_blank>large<S2SV_blank>descriptor\\n"" ) ; return NULL ; } <S2SV_ModEnd> if ( union_desc <S2SV_ModStart> ""Found<S2SV_blank>union<S2SV_blank>header\\n"" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , ""Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\n)"" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <S2SV_ModEnd> ; } buflen
",torvalds@linux/ea04efee7635c9120d015dcdeeeb6988130cb67a,CVE-2017-16645,https://github.com/torvalds/linux/commit/ea04efee7635c9120d015dcdeeeb6988130cb67a,2017-11-07T23:29Z,<S2SV_StartBug> while ( buflen > 0 ) { <S2SV_EndBug> <S2SV_StartBug> return union_desc ; <S2SV_EndBug>
3913,CWE-119,"char * selaGetCombName ( SELA * sela , l_int32 size , l_int32 direction ) { char * selname ; <S2SV_StartBug> char combname [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 i , nsels , sx , sy , found ; SEL * sel ; PROCNAME ( ""selaGetCombName"" ) ; if ( ! sela ) return ( char * ) ERROR_PTR ( ""sela<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( direction != L_HORIZ && direction != L_VERT ) return ( char * ) ERROR_PTR ( ""invalid<S2SV_blank>direction"" , procName , NULL ) ; if ( direction == L_HORIZ ) <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dh"" , size ) ; <S2SV_EndBug> else <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dv"" , size ) ; <S2SV_EndBug> found = FALSE ; nsels = selaGetCount ( sela ) ; for ( i = 0 ; i < nsels ; i ++ ) { sel = selaGetSel ( sela , i ) ; selGetParameters ( sel , & sy , & sx , NULL , NULL ) ; if ( sy != 1 && sx != 1 ) continue ; selname = selGetName ( sel ) ; if ( ! strcmp ( selname , combname ) ) { found = TRUE ; break ; } } if ( found ) return stringNew ( selname ) ; else return ( char * ) ERROR_PTR ( ""sel<S2SV_blank>not<S2SV_blank>found"" , procName , NULL ) ; }
","<S2SV_ModStart> char combname [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( combname , L_BUFSIZE <S2SV_ModEnd> , ""sel_comb_%dh"" , <S2SV_ModStart> ( combname , L_BUFSIZE <S2SV_ModEnd> , ""sel_comb_%dv"" ,
",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z,"<S2SV_StartBug> char combname [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dh"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dv"" , size ) ; <S2SV_EndBug>"
3287,CWE-399,"static void __udf_read_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; <S2SV_StartBug> unsigned int link_count ; <S2SV_EndBug> bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n"" , inode -> i_ino ) ; make_bad_inode ( inode ) ; return ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) { <S2SV_StartBug> struct buffer_head * nbh = NULL ; <S2SV_EndBug> struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; <S2SV_StartBug> if ( ie -> indirectICB . extLength && <S2SV_EndBug> <S2SV_StartBug> ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , <S2SV_EndBug> & ident ) ) ) { if ( ident == TAG_IDENT_FE || ident == TAG_IDENT_EFE ) { memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; brelse ( bh ) ; brelse ( ibh ) ; brelse ( nbh ) ; __udf_read_inode ( inode ) ; return ; } <S2SV_StartBug> brelse ( nbh ) ; <S2SV_EndBug> } } brelse ( ibh ) ; } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n"" , le16_to_cpu ( fe -> icbTag . strategyType ) ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & ICBTAG_FLAG_AD_MASK ; iinfo -> i_unique = 0 ; iinfo -> i_lenEAttr = 0 ; iinfo -> i_lenExtents = 0 ; iinfo -> i_lenAlloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenAlloc = le32_to_cpu ( ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> lengthAllocDescs ) ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocSpaceEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; return ; } read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_fmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_dmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> fileLinkCount ) ; if ( ! link_count ) link_count = 1 ; set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; iinfo -> i_lenExtents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } switch ( fe -> icbTag . fileType ) { case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= S_IFDIR ; inc_nlink ( inode ) ; break ; case ICBTAG_FILE_TYPE_REALTIME : case ICBTAG_FILE_TYPE_REGULAR : case ICBTAG_FILE_TYPE_UNDEF : case ICBTAG_FILE_TYPE_VAT20 : if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= S_IFREG ; break ; case ICBTAG_FILE_TYPE_BLOCK : inode -> i_mode |= S_IFBLK ; break ; case ICBTAG_FILE_TYPE_CHAR : inode -> i_mode |= S_IFCHR ; break ; case ICBTAG_FILE_TYPE_FIFO : init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; break ; case ICBTAG_FILE_TYPE_SOCKET : init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; break ; case ICBTAG_FILE_TYPE_SYMLINK : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = S_IFLNK | S_IRWXUGO ; break ; case ICBTAG_FILE_TYPE_MAIN : udf_debug ( ""METADATA<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_MIRROR : udf_debug ( ""METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_BITMAP : udf_debug ( ""METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n"" , inode -> i_ino , fe -> icbTag . fileType ) ; make_bad_inode ( inode ) ; return ; } if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { struct deviceSpec * dsea = ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; } else make_bad_inode ( inode ) ; } brelse ( bh ) ; }
","<S2SV_ModStart> int link_count ; unsigned int indirections = 0 ; reread : <S2SV_ModStart> ) { struct <S2SV_ModEnd> kernel_lb_addr loc ; <S2SV_ModStart> indirectICB . extLength ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <S2SV_ModEnd> , & loc <S2SV_ModStart> & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <S2SV_ModEnd> ( inode ) <S2SV_ModStart> return ; } goto reread <S2SV_ModEnd> ; } }
",torvalds@linux/c03aa9f6e1f938618e6db2e23afef0574efeeb65,CVE-2014-6410,https://github.com/torvalds/linux/commit/c03aa9f6e1f938618e6db2e23afef0574efeeb65,2014-09-28T10:55Z,"<S2SV_StartBug> unsigned int link_count ; <S2SV_EndBug> <S2SV_StartBug> struct buffer_head * nbh = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ie -> indirectICB . extLength && <S2SV_EndBug> <S2SV_StartBug> ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , <S2SV_EndBug> <S2SV_StartBug> brelse ( nbh ) ; <S2SV_EndBug>"
3858,CWE-264,"static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; int res , ret ; if ( uaddr == uaddr2 ) return - EINVAL ; if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; RB_CLEAR_NODE ( & rt_waiter . pi_tree_entry ) ; RB_CLEAR_NODE ( & rt_waiter . tree_entry ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; <S2SV_StartBug> futex_wait_queue_me ( hb , & q , to ) ; <S2SV_EndBug> spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { WARN_ON ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - EFAULT ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - EINTR ) { ret = - EWOULDBLOCK ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }
","<S2SV_ModStart> goto out_key2 ; if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
",torvalds@linux/e9c243a5a6de0be8e584c604d353412584b592f8,CVE-2014-3153,https://github.com/torvalds/linux/commit/e9c243a5a6de0be8e584c604d353412584b592f8,2014-06-07T14:55Z,"<S2SV_StartBug> futex_wait_queue_me ( hb , & q , to ) ; <S2SV_EndBug>"
7770,CWE-125,"stmt_ty <S2SV_StartBug> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! value ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>value<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>Assign"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Assign_kind ; p -> v . Assign . targets = targets ; p -> v . Assign . value = value ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
","<S2SV_ModStart> expr_ty value , string type_comment , <S2SV_ModStart> ; p -> v . Assign . type_comment = type_comment ; p ->
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug>"
1716,CWE-119,"static void rd_auto_partition_range ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> int mi_row , int mi_col , <S2SV_EndBug> BLOCK_SIZE * min_block_size , BLOCK_SIZE * max_block_size ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = xd -> mi ; <S2SV_EndBug> <S2SV_StartBug> const int left_in_image = xd -> left_available && mi_8x8 [ - 1 ] ; <S2SV_EndBug> const int above_in_image = xd -> up_available && <S2SV_StartBug> mi_8x8 [ - xd -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * above_sb64_mi_8x8 ; <S2SV_EndBug> MODE_INFO * * left_sb64_mi_8x8 ; int row8x8_remaining = tile -> mi_row_end - mi_row ; <S2SV_StartBug> int col8x8_remaining = tile -> mi_col_end - mi_col ; <S2SV_EndBug> int bh , bw ; BLOCK_SIZE min_size = BLOCK_4X4 ; <S2SV_StartBug> BLOCK_SIZE max_size = BLOCK_64X64 ; <S2SV_EndBug> if ( left_in_image || above_in_image || cm -> frame_type != KEY_FRAME ) { min_size = BLOCK_64X64 ; max_size = BLOCK_4X4 ; if ( cm -> frame_type != KEY_FRAME ) { <S2SV_StartBug> MODE_INFO * * const prev_mi = <S2SV_EndBug> & cm -> prev_mi_grid_visible [ mi_row * xd -> mi_stride + mi_col ] ; <S2SV_StartBug> get_sb_partition_size_range ( cpi , prev_mi , & min_size , & max_size ) ; <S2SV_EndBug> } if ( left_in_image ) { <S2SV_StartBug> left_sb64_mi_8x8 = & mi_8x8 [ - MI_BLOCK_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> get_sb_partition_size_range ( cpi , left_sb64_mi_8x8 , <S2SV_EndBug> & min_size , & max_size ) ; } if ( above_in_image ) { <S2SV_StartBug> above_sb64_mi_8x8 = & mi_8x8 [ - xd -> mi_stride * MI_BLOCK_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> get_sb_partition_size_range ( cpi , above_sb64_mi_8x8 , <S2SV_EndBug> & min_size , & max_size ) ; } if ( cpi -> sf . auto_min_max_partition_size == RELAXED_NEIGHBORING_MIN_MAX ) { min_size = min_partition_size [ min_size ] ; max_size = max_partition_size [ max_size ] ; } } max_size = find_partition_size ( max_size , row8x8_remaining , col8x8_remaining , & bh , & bw ) ; <S2SV_StartBug> min_size = MIN ( min_size , max_size ) ; <S2SV_EndBug> if ( cpi -> sf . use_square_partition_only && next_square_size [ max_size ] < min_size ) { min_size = next_square_size [ max_size ] ; } * min_block_size = min_size ; * max_block_size = max_size ; }
","<S2SV_ModStart> const tile , MACROBLOCKD * const xd , <S2SV_ModStart> -> common ; <S2SV_ModEnd> MODE_INFO * * <S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> = xd -> <S2SV_ModStart> -> left_available && mi <S2SV_ModEnd> [ - 1 <S2SV_ModStart> -> up_available && mi <S2SV_ModEnd> [ - xd <S2SV_ModStart> mi_stride ] ; const <S2SV_ModEnd> int row8x8_remaining = <S2SV_ModStart> - mi_row ; const <S2SV_ModStart> max_size = BLOCK_64X64 ; int bs_hist [ BLOCK_SIZES ] = { 0 } <S2SV_ModStart> MODE_INFO * * <S2SV_ModEnd> prev_mi = & <S2SV_ModStart> ; get_sb_partition_size_range ( xd <S2SV_ModEnd> , prev_mi , <S2SV_ModStart> , & max_size , bs_hist <S2SV_ModStart> left_in_image ) { MODE_INFO * * left_sb64_mi = & mi <S2SV_ModEnd> [ - MI_BLOCK_SIZE <S2SV_ModStart> ; get_sb_partition_size_range ( xd , left_sb64_mi , & min_size , & max_size , bs_hist <S2SV_ModEnd> ) ; } <S2SV_ModStart> above_in_image ) { MODE_INFO * * above_sb64_mi = & mi <S2SV_ModEnd> [ - xd <S2SV_ModStart> ; get_sb_partition_size_range ( xd , above_sb64_mi , & min_size , & max_size , bs_hist <S2SV_ModEnd> ) ; } <S2SV_ModStart> bw ) ; if ( vp9_active_edge_sb ( cpi , mi_row , mi_col ) ) { min_size = BLOCK_4X4 ; } else { <S2SV_ModStart> = MIN ( cpi -> sf . rd_auto_partition_min_limit , MIN ( min_size , max_size ) ) ; } <S2SV_ModEnd> if ( cpi
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int mi_row , int mi_col , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = xd -> mi ; <S2SV_EndBug> <S2SV_StartBug> const int left_in_image = xd -> left_available && mi_8x8 [ - 1 ] ; <S2SV_EndBug> <S2SV_StartBug> mi_8x8 [ - xd -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * above_sb64_mi_8x8 ; <S2SV_EndBug> <S2SV_StartBug> int col8x8_remaining = tile -> mi_col_end - mi_col ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE max_size = BLOCK_64X64 ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * const prev_mi = <S2SV_EndBug> <S2SV_StartBug> get_sb_partition_size_range ( cpi , prev_mi , & min_size , & max_size ) ; <S2SV_EndBug> <S2SV_StartBug> left_sb64_mi_8x8 = & mi_8x8 [ - MI_BLOCK_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> get_sb_partition_size_range ( cpi , left_sb64_mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> above_sb64_mi_8x8 = & mi_8x8 [ - xd -> mi_stride * MI_BLOCK_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> get_sb_partition_size_range ( cpi , above_sb64_mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> min_size = MIN ( min_size , max_size ) ; <S2SV_EndBug>"
3312,CWE-125,"opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; <S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if <S2SV_EndBug> ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }
","<S2SV_ModStart> -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> ) ) ; }
",uclouvain@openjpeg/c16bc057ba3f125051c9966cf1f5b68a05681de4,CVE-2016-7163,https://github.com/uclouvain/openjpeg/commit/c16bc057ba3f125051c9966cf1f5b68a05681de4,2016-09-21T14:25Z,"<S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if <S2SV_EndBug>"
1443,CWE-119,"int vp8_refining_search_sad_c ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int error_per_bit , int search_range , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { MV neighbors [ 4 ] = { { - 1 , 0 } , { 0 , - 1 } , { 0 , 1 } , { 1 , 0 } } ; int i , j ; short this_row_offset , this_col_offset ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; unsigned char * best_address = ( unsigned char * ) ( base_pre + d -> offset + ( ref_mv -> as_mv . row * pre_stride ) + ref_mv -> as_mv . col ) ; unsigned char * check_here ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; bestsad = fn_ptr -> sdf ( what , what_stride , best_address , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( ref_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; for ( i = 0 ; i < search_range ; i ++ ) { int best_site = - 1 ; for ( j = 0 ; j < 4 ; j ++ ) { this_row_offset = ref_mv -> as_mv . row + neighbors [ j ] . row ; this_col_offset = ref_mv -> as_mv . col + neighbors [ j ] . col ; if ( ( this_col_offset > x -> mv_col_min ) && ( this_col_offset < x -> mv_col_max ) && ( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ( neighbors [ j ] . row ) * in_what_stride + neighbors [ j ] . col + best_address ; <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . row = this_row_offset ; this_mv . as_mv . col = this_col_offset ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_site = j ; } } } } if ( best_site == - 1 ) break ; else { ref_mv -> as_mv . row += neighbors [ best_site ] . row ; ref_mv -> as_mv . col += neighbors [ best_site ] . col ; best_address += ( neighbors [ best_site ] . row ) * in_what_stride + neighbors [ best_site ] . col ; } } this_mv . as_mv . row = ref_mv -> as_mv . row << 3 ; this_mv . as_mv . col = ref_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , best_address , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
","<S2SV_ModStart> best_address , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> check_here , in_what_stride <S2SV_ModEnd> ) ; if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug>"
6230,CWE-000,"static int crossOriginDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * option , * ovalue , * tok ; route = state -> route ; tok = sclone ( value ) ; while ( ( option = maGetNextArg ( tok , & tok ) ) != 0 ) { <S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( scaselessmatch ( option , ""origin"" ) ) { route -> corsOrigin = sclone ( ovalue ) ; } else if ( scaselessmatch ( option , ""credentials"" ) ) { route -> corsCredentials = httpGetBoolToken ( ovalue ) ; } else if ( scaselessmatch ( option , ""headers"" ) ) { route -> corsHeaders = sclone ( ovalue ) ; } else if ( scaselessmatch ( option , ""age"" ) ) { route -> corsAge = atoi ( ovalue ) ; } else { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Unknown<S2SV_blank>CrossOrigin<S2SV_blank>option<S2SV_blank>%s"" , option ) ; return MPR_ERR_BAD_SYNTAX ; } } # if KEEP if ( smatch ( route -> corsOrigin , ""*"" ) && route -> corsCredentials ) { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""CrossOrigin:<S2SV_blank>Cannot<S2SV_blank>use<S2SV_blank>wildcard<S2SV_blank>Origin<S2SV_blank>if<S2SV_blank>allowing<S2SV_blank>credentials"" ) ; return MPR_ERR_BAD_STATE ; } # endif httpAddRouteMethods ( route , ""OPTIONS"" ) ; route -> flags |= HTTP_ROUTE_CORS ; return 0 ; }
","<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug>"
3845,CWE-119,"static void dump_boot ( DOS_FS * fs , struct boot_sector * b , unsigned lss ) { unsigned short sectors ; printf ( ""Boot<S2SV_blank>sector<S2SV_blank>contents:\\n"" ) ; if ( ! atari_format ) { char id [ 9 ] ; strncpy ( id , ( const char * ) b -> system_id , 8 ) ; id [ 8 ] = 0 ; printf ( ""System<S2SV_blank>ID<S2SV_blank>\\""%s\\""\\n"" , id ) ; } else { printf ( ""Serial<S2SV_blank>number<S2SV_blank>0x%x\\n"" , b -> system_id [ 5 ] | ( b -> system_id [ 6 ] << 8 ) | ( b -> system_id [ 7 ] << 16 ) ) ; } printf ( ""Media<S2SV_blank>byte<S2SV_blank>0x%02x<S2SV_blank>(%s)\\n"" , b -> media , get_media_descr ( b -> media ) ) ; printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>logical<S2SV_blank>sector\\n"" , GET_UNALIGNED_W ( b -> sector_size ) ) ; printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>cluster\\n"" , fs -> cluster_size ) ; printf ( ""%10d<S2SV_blank>reserved<S2SV_blank>sector%s\\n"" , le16toh ( b -> reserved ) , le16toh ( b -> reserved ) == 1 ? """" : ""s"" ) ; printf ( ""First<S2SV_blank>FAT<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\n"" , ( unsigned long long ) fs -> fat_start , ( unsigned long long ) fs -> fat_start / lss ) ; printf ( ""%10d<S2SV_blank>FATs,<S2SV_blank>%d<S2SV_blank>bit<S2SV_blank>entries\\n"" , b -> fats , fs -> fat_bits ) ; <S2SV_StartBug> printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\n"" , fs -> fat_size , <S2SV_EndBug> <S2SV_StartBug> fs -> fat_size / lss ) ; <S2SV_EndBug> if ( ! fs -> root_cluster ) { printf ( ""Root<S2SV_blank>directory<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\n"" , ( unsigned long long ) fs -> root_start , ( unsigned long long ) fs -> root_start / lss ) ; printf ( ""%10d<S2SV_blank>root<S2SV_blank>directory<S2SV_blank>entries\\n"" , fs -> root_entries ) ; } else { printf ( ""Root<S2SV_blank>directory<S2SV_blank>start<S2SV_blank>at<S2SV_blank>cluster<S2SV_blank>%lu<S2SV_blank>(arbitrary<S2SV_blank>size)\\n"" , ( unsigned long ) fs -> root_cluster ) ; } printf ( ""Data<S2SV_blank>area<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\n"" , ( unsigned long long ) fs -> data_start , ( unsigned long long ) fs -> data_start / lss ) ; printf ( ""%10lu<S2SV_blank>data<S2SV_blank>clusters<S2SV_blank>(%llu<S2SV_blank>bytes)\\n"" , ( unsigned long ) fs -> data_clusters , ( unsigned long long ) fs -> data_clusters * fs -> cluster_size ) ; printf ( ""%u<S2SV_blank>sectors/track,<S2SV_blank>%u<S2SV_blank>heads\\n"" , le16toh ( b -> secs_track ) , le16toh ( b -> heads ) ) ; printf ( ""%10u<S2SV_blank>hidden<S2SV_blank>sectors\\n"" , atari_format ? ( ( ( unsigned char * ) & b -> hidden ) [ 0 ] | ( ( unsigned char * ) & b -> hidden ) [ 1 ] << 8 ) : le32toh ( b -> hidden ) ) ; sectors = GET_UNALIGNED_W ( b -> sectors ) ; printf ( ""%10u<S2SV_blank>sectors<S2SV_blank>total\\n"" , sectors ? sectors : le32toh ( b -> total_sect ) ) ; }
","<S2SV_ModStart> ; printf ( ""%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\n"" , ( long long ) <S2SV_ModEnd> fs -> fat_size <S2SV_ModStart> -> fat_size , ( long long )
",dosfstools@dosfstools/e8eff147e9da1185f9afd5b25948153a3b97cf52,CVE-2016-4804,https://github.com/dosfstools/dosfstools/commit/e8eff147e9da1185f9afd5b25948153a3b97cf52,2016-06-03T14:59Z,"<S2SV_StartBug> printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\n"" , fs -> fat_size , <S2SV_EndBug> <S2SV_StartBug> fs -> fat_size / lss ) ; <S2SV_EndBug>"
3603,CWE-119,"int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { <S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? ""RF64"" : ""RIFF"" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , ""WAVE"" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ; <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , ""data"" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , ""junk"" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , ""ds64"" , sizeof ( ds64hdr . ckID ) ) ; <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ; <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; } <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } return TRUE ; }
","<S2SV_ModStart> write_junk = 1 , table_length = 0 <S2SV_ModStart> ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> sizeof ( junkchunk <S2SV_ModStart> ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) ) ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk &&
",dbry@WavPack/d5bf76b5a88d044a1be1d5656698e3ba737167e5,CVE-2018-6767,https://github.com/dbry/WavPack/commit/d5bf76b5a88d044a1be1d5656698e3ba737167e5,2018-02-06T22:29Z,"<S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug>"
6128,CWE-401,"static int nfp_abm_u32_knode_replace ( struct nfp_abm_link * alink , struct tc_cls_u32_knode * knode , __be16 proto , struct netlink_ext_ack * extack ) { struct nfp_abm_u32_match * match = NULL , * iter ; unsigned int tos_off ; u8 mask , val ; int err ; <S2SV_StartBug> if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) <S2SV_EndBug> <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ; val = be32_to_cpu ( knode -> sel -> keys [ 0 ] . val ) >> tos_off & 0xff ; mask = be32_to_cpu ( knode -> sel -> keys [ 0 ] . mask ) >> tos_off & 0xff ; list_for_each_entry ( iter , & alink -> dscp_map , list ) { u32 cmask ; if ( iter -> handle == knode -> handle ) { match = iter ; continue ; } cmask = iter -> mask & mask ; if ( ( iter -> val & cmask ) == ( val & cmask ) && iter -> band != knode -> res -> classid ) { NL_SET_ERR_MSG_MOD ( extack , ""conflict<S2SV_blank>with<S2SV_blank>already<S2SV_blank>offloaded<S2SV_blank>filter"" ) ; <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> } } if ( ! match ) { match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> list_add ( & match -> list , & alink -> dscp_map ) ; <S2SV_EndBug> } match -> handle = knode -> handle ; match -> band = knode -> res -> classid ; match -> mask = mask ; match -> val = val ; err = nfp_abm_update_band_map ( alink ) ; if ( err ) goto err_delete ; return 0 ; err_delete : nfp_abm_u32_knode_delete ( alink , knode ) ; <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> }
","<S2SV_ModStart> extack ) ) { err = - EOPNOTSUPP ; <S2SV_ModStart> goto err_delete ; } <S2SV_ModStart> ""conflict<S2SV_blank>with<S2SV_blank>already<S2SV_blank>offloaded<S2SV_blank>filter"" ) ; err = - EOPNOTSUPP ; <S2SV_ModStart> ! match ) { err = <S2SV_ModEnd> - ENOMEM ; <S2SV_ModStart> - ENOMEM ; goto err_delete ; } <S2SV_ModStart> ) ; return err <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/78beef629fd95be4ed853b2d37b832f766bd96ca,CVE-2019-19076,https://github.com/torvalds/linux/commit/78beef629fd95be4ed853b2d37b832f766bd96ca,2019-11-18T06:15Z,"<S2SV_StartBug> if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) <S2SV_EndBug> <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> list_add ( & match -> list , & alink -> dscp_map ) ; <S2SV_EndBug> <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug>"
228,CWE-17,"static struct fileIdentDesc * udf_find_entry ( struct inode * dir , const struct qstr * child , struct udf_fileident_bh * fibh , struct fileIdentDesc * cfi ) { struct fileIdentDesc * fi = NULL ; loff_t f_pos ; int block , flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint8_t lfi ; uint16_t liu ; loff_t size ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; struct extent_position epos = { } ; struct udf_inode_info * dinfo = UDF_I ( dir ) ; int isdotdot = child -> len == 2 && child -> name [ 0 ] == '.' && child -> name [ 1 ] == '.' ; size = udf_ext0_offset ( dir ) + dir -> i_size ; f_pos = udf_ext0_offset ( dir ) ; fibh -> sbh = fibh -> ebh = NULL ; fibh -> soffset = fibh -> eoffset = f_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( dinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { if ( inode_bmap ( dir , f_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) goto out_err ; block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) epos . offset -= sizeof ( struct short_ad ) ; else if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) epos . offset -= sizeof ( struct long_ad ) ; } else offset = 0 ; fibh -> sbh = fibh -> ebh = udf_tread ( dir -> i_sb , block ) ; if ( ! fibh -> sbh ) goto out_err ; } fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) goto out_err ; while ( f_pos < size ) { fi = udf_fileident_read ( dir , & f_pos , fibh , cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out_err ; liu = le16_to_cpu ( cfi -> lengthOfImpUse ) ; lfi = cfi -> lengthFileIdent ; if ( fibh -> sbh == fibh -> ebh ) { nameptr = fi -> fileIdent + liu ; } else { int poffset ; poffset = fibh -> soffset + sizeof ( struct fileIdentDesc ) + liu + lfi ; if ( poffset >= lfi ) nameptr = ( uint8_t * ) ( fibh -> ebh -> b_data + poffset - lfi ) ; else { nameptr = fname ; memcpy ( nameptr , fi -> fileIdent + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh -> ebh -> b_data , poffset ) ; } } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) continue ; } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) continue ; } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_PARENT ) && isdotdot ) goto out_ok ; if ( ! lfi ) continue ; <S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ; } out_err : fi = NULL ; if ( fibh -> sbh != fibh -> ebh ) brelse ( fibh -> ebh ) ; brelse ( fibh -> sbh ) ; out_ok : brelse ( epos . bh ) ; kfree ( fname ) ; return fi ; }
","<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z,"<S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug>"
4877,CWE-362,"static int <S2SV_StartBug> mptctl_mpt_command ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_command __user * uarg = ( void __user * ) arg ; <S2SV_StartBug> struct mpt_ioctl_command karg ; <S2SV_EndBug> MPT_ADAPTER * ioc ; int iocnum ; int rc ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_command ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_command<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_mpt_command()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } <S2SV_StartBug> rc = mptctl_do_mpt_command ( karg , & uarg -> MF ) ; <S2SV_EndBug> return rc ; }
","<S2SV_ModStart> int mptctl_mpt_command ( MPT_ADAPTER * ioc , <S2SV_ModStart> struct mpt_ioctl_command karg <S2SV_ModEnd> ; int rc <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> rc = mptctl_do_mpt_command <S2SV_ModStart> = mptctl_do_mpt_command ( ioc ,
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,"<S2SV_StartBug> mptctl_mpt_command ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> struct mpt_ioctl_command karg ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> <S2SV_StartBug> rc = mptctl_do_mpt_command ( karg , & uarg -> MF ) ; <S2SV_EndBug>"
3118,CWE-20,"static inline int mk_vhost_fdt_open ( int id , unsigned int hash , struct session_request * sr ) { int i ; int fd ; struct vhost_fdt_hash_table * ht = NULL ; struct vhost_fdt_hash_chain * hc ; if ( config -> fdt == MK_FALSE ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } ht = mk_vhost_fdt_table_lookup ( id , sr -> host_conf ) ; if ( mk_unlikely ( ! ht ) ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } hc = mk_vhost_fdt_chain_lookup ( hash , ht ) ; if ( hc ) { hc -> readers ++ ; return hc -> fd ; } fd = open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; if ( fd == - 1 ) { return - 1 ; } if ( ht -> av_slots <= 0 ) { return fd ; } for ( i = 0 ; i < VHOST_FDT_HASHTABLE_CHAINS ; i ++ ) { hc = & ht -> chain [ i ] ; if ( hc -> fd == - 1 ) { hc -> fd = fd ; hc -> hash = hash ; hc -> readers ++ ; ht -> av_slots -- ; sr -> vhost_fdt_id = id ; sr -> vhost_fdt_hash = hash ; <S2SV_StartBug> return fd ; <S2SV_EndBug> } } return - 1 ; }
","<S2SV_ModStart> = hash ; sr -> fd_is_fdt = MK_TRUE ;
",monkey@monkey/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd,CVE-2014-5336,https://github.com/monkey/monkey/commit/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd,2014-08-26T14:55Z,<S2SV_StartBug> return fd ; <S2SV_EndBug>
736,CWE-362,"static void queue_delete ( struct snd_seq_queue * q ) { <S2SV_StartBug> snd_seq_timer_stop ( q -> timer ) ; <S2SV_EndBug> <S2SV_StartBug> snd_seq_timer_close ( q ) ; <S2SV_EndBug> snd_use_lock_sync ( & q -> use_lock ) ; snd_seq_prioq_delete ( & q -> tickq ) ; snd_seq_prioq_delete ( & q -> timeq ) ; snd_seq_timer_delete ( & q -> timer ) ; kfree ( q ) ; }
","<S2SV_ModStart> q ) { mutex_lock ( & q -> timer_mutex ) ; <S2SV_ModStart> snd_seq_timer_close ( q ) ; mutex_unlock ( & q -> timer_mutex
",torvalds@linux/3567eb6af614dac436c4b16a8d426f9faed639b3,CVE-2016-2544,https://github.com/torvalds/linux/commit/3567eb6af614dac436c4b16a8d426f9faed639b3,2016-04-27T17:59Z,<S2SV_StartBug> snd_seq_timer_stop ( q -> timer ) ; <S2SV_EndBug> <S2SV_StartBug> snd_seq_timer_close ( q ) ; <S2SV_EndBug>
3047,CWE-125,"u_int mfr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int tlen , idx , hdr_len = 0 ; uint16_t sequence_num ; uint8_t ie_type , ie_len ; const uint8_t * tptr ; ND_TCHECK2 ( * p , 4 ) ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_CTRL_FRAME && p [ 1 ] == 0 ) { ND_PRINT ( ( ndo , ""FRF.16<S2SV_blank>Control,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , bittok2str ( frf_flag_values , ""none"" , ( p [ 0 ] & MFR_BEC_MASK ) ) , tok2str ( mfr_ctrl_msg_values , ""Unknown<S2SV_blank>Message<S2SV_blank>(0x%02x)"" , p [ 2 ] ) , length ) ) ; tptr = p + 3 ; tlen = length - 3 ; hdr_len = 3 ; if ( ! ndo -> ndo_vflag ) return hdr_len ; while ( tlen > sizeof ( struct ie_tlv_header_t ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct ie_tlv_header_t ) ) ; ie_type = tptr [ 0 ] ; ie_len = tptr [ 1 ] ; ND_PRINT ( ( ndo , ""\\n\\tIE<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>"" , tok2str ( mfr_ctrl_ie_values , ""Unknown"" , ie_type ) , ie_type , ie_len ) ) ; if ( ie_type == 0 || ie_len <= sizeof ( struct ie_tlv_header_t ) ) return hdr_len ; ND_TCHECK2 ( * tptr , ie_len ) ; tptr += sizeof ( struct ie_tlv_header_t ) ; ie_len -= sizeof ( struct ie_tlv_header_t ) ; tlen -= sizeof ( struct ie_tlv_header_t ) ; switch ( ie_type ) { <S2SV_StartBug> case MFR_CTRL_IE_MAGIC_NUM : <S2SV_EndBug> ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case MFR_CTRL_IE_BUNDLE_ID : case MFR_CTRL_IE_LINK_ID : for ( idx = 0 ; idx < ie_len && idx < MFR_ID_STRING_MAXLEN ; idx ++ ) { if ( * ( tptr + idx ) != 0 ) safeputchar ( ndo , * ( tptr + idx ) ) ; else break ; } break ; case MFR_CTRL_IE_TIMESTAMP : if ( ie_len == sizeof ( struct timeval ) ) { ts_print ( ndo , ( const struct timeval * ) tptr ) ; break ; } case MFR_CTRL_IE_VENDOR_EXT : case MFR_CTRL_IE_CAUSE : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ie_len ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ie_len ) ; tlen -= ie_len ; tptr += ie_len ; } return hdr_len ; } sequence_num = ( p [ 0 ] & 0x1e ) << 7 | p [ 1 ] ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_FRAG_FRAME || ( p [ 0 ] & MFR_BEC_MASK ) == MFR_B_BIT ) { ND_PRINT ( ( ndo , ""FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>"" , sequence_num , bittok2str ( frf_flag_values , ""none"" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; hdr_len = 2 ; fr_print ( ndo , p + hdr_len , length - hdr_len ) ; return hdr_len ; } ND_PRINT ( ( ndo , ""FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]"" , sequence_num , bittok2str ( frf_flag_values , ""none"" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; print_unknown_data ( ndo , p , ""\\n\\t"" , length ) ; return hdr_len ; trunc : ND_PRINT ( ( ndo , ""[|mfr]"" ) ) ; return length ; }
","<S2SV_ModStart> case MFR_CTRL_IE_MAGIC_NUM : if ( ie_len != 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>length)"" ) ) ; break ; }
",the-tcpdump-group@tcpdump/aa3e54f594385ce7e1e319b0c84999e51192578b,CVE-2018-14468,https://github.com/the-tcpdump-group/tcpdump/commit/aa3e54f594385ce7e1e319b0c84999e51192578b,2019-10-03T16:15Z,<S2SV_StartBug> case MFR_CTRL_IE_MAGIC_NUM : <S2SV_EndBug>
4747,CWE-416,"static void nodeDestruct ( struct SaveNode * node ) { <S2SV_StartBug> if ( node -> v == & node -> sorted ) <S2SV_EndBug> { <S2SV_StartBug> tr_free ( node -> sorted . val . l . vals ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> node ) { TR_ASSERT ( node != NULL ) ; <S2SV_ModStart> ( node -> sorted != NULL <S2SV_ModEnd> ) { tr_free <S2SV_ModStart> node -> sorted -> <S2SV_ModEnd> val . l <S2SV_ModStart> vals ) ; tr_free ( node -> sorted ) ;
",transmission@transmission/2123adf8e5e1c2b48791f9d22fc8c747e974180e,CVE-2018-10756,https://github.com/transmission/transmission/commit/2123adf8e5e1c2b48791f9d22fc8c747e974180e,2020-05-15T16:15Z,<S2SV_StartBug> if ( node -> v == & node -> sorted ) <S2SV_EndBug> <S2SV_StartBug> tr_free ( node -> sorted . val . l . vals ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
4871,CWE-362,"static int <S2SV_StartBug> mptctl_eventreport ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_eventreport __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_eventreport karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> int iocnum ; int numBytes , maxEvents , max ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_eventreport ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_eventreport<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_eventreport<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_eventreport()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_eventreport<S2SV_blank>called.\\n"" , ioc -> name ) ) ; numBytes = karg . hdr . maxDataSize - sizeof ( mpt_ioctl_header ) ; maxEvents = numBytes / sizeof ( MPT_IOCTL_EVENTS ) ; max = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents ; if ( ( max < 1 ) || ! ioc -> events ) return - ENODATA ; ioc -> aen_event_read_flag = 0 ; numBytes = max * sizeof ( MPT_IOCTL_EVENTS ) ; if ( copy_to_user ( uarg -> eventData , ioc -> events , numBytes ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_eventreport<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_eventreport<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , ioc -> events ) ; return - EFAULT ; } return 0 ; }
","<S2SV_ModStart> int mptctl_eventreport ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_eventreport karg ; <S2SV_ModEnd> int numBytes , <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,<S2SV_StartBug> mptctl_eventreport ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug>
4128,CWE-20,"long kvm_arch_vcpu_ioctl ( struct file * filp , unsigned int ioctl , unsigned long arg ) { struct kvm_vcpu * vcpu = filp -> private_data ; void __user * argp = ( void __user * ) arg ; int r ; union { struct kvm_lapic_state * lapic ; struct kvm_xsave * xsave ; struct kvm_xcrs * xcrs ; void * buffer ; } u ; u . buffer = NULL ; switch ( ioctl ) { case KVM_GET_LAPIC : { r = - EINVAL ; if ( ! vcpu -> arch . apic ) goto out ; u . lapic = kzalloc ( sizeof ( struct kvm_lapic_state ) , GFP_KERNEL ) ; r = - ENOMEM ; if ( ! u . lapic ) goto out ; r = kvm_vcpu_ioctl_get_lapic ( vcpu , u . lapic ) ; if ( r ) goto out ; r = - EFAULT ; if ( copy_to_user ( argp , u . lapic , sizeof ( struct kvm_lapic_state ) ) ) goto out ; r = 0 ; break ; } case KVM_SET_LAPIC : { r = - EINVAL ; if ( ! vcpu -> arch . apic ) goto out ; u . lapic = memdup_user ( argp , sizeof ( * u . lapic ) ) ; if ( IS_ERR ( u . lapic ) ) return PTR_ERR ( u . lapic ) ; r = kvm_vcpu_ioctl_set_lapic ( vcpu , u . lapic ) ; break ; } case KVM_INTERRUPT : { struct kvm_interrupt irq ; r = - EFAULT ; if ( copy_from_user ( & irq , argp , sizeof irq ) ) goto out ; r = kvm_vcpu_ioctl_interrupt ( vcpu , & irq ) ; break ; } case KVM_NMI : { r = kvm_vcpu_ioctl_nmi ( vcpu ) ; break ; } case KVM_SET_CPUID : { struct kvm_cpuid __user * cpuid_arg = argp ; struct kvm_cpuid cpuid ; r = - EFAULT ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_set_cpuid ( vcpu , & cpuid , cpuid_arg -> entries ) ; break ; } case KVM_SET_CPUID2 : { struct kvm_cpuid2 __user * cpuid_arg = argp ; struct kvm_cpuid2 cpuid ; r = - EFAULT ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_set_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ; break ; } case KVM_GET_CPUID2 : { struct kvm_cpuid2 __user * cpuid_arg = argp ; struct kvm_cpuid2 cpuid ; r = - EFAULT ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_get_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ; if ( r ) goto out ; r = - EFAULT ; if ( copy_to_user ( cpuid_arg , & cpuid , sizeof cpuid ) ) goto out ; r = 0 ; break ; } case KVM_GET_MSRS : r = msr_io ( vcpu , argp , kvm_get_msr , 1 ) ; break ; case KVM_SET_MSRS : r = msr_io ( vcpu , argp , do_set_msr , 0 ) ; break ; case KVM_TPR_ACCESS_REPORTING : { struct kvm_tpr_access_ctl tac ; r = - EFAULT ; if ( copy_from_user ( & tac , argp , sizeof tac ) ) goto out ; r = vcpu_ioctl_tpr_access_reporting ( vcpu , & tac ) ; if ( r ) goto out ; r = - EFAULT ; if ( copy_to_user ( argp , & tac , sizeof tac ) ) goto out ; r = 0 ; break ; } ; case KVM_SET_VAPIC_ADDR : { struct kvm_vapic_addr va ; r = - EINVAL ; if ( ! irqchip_in_kernel ( vcpu -> kvm ) ) goto out ; r = - EFAULT ; if ( copy_from_user ( & va , argp , sizeof va ) ) goto out ; <S2SV_StartBug> r = 0 ; <S2SV_EndBug> kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ; break ; } case KVM_X86_SETUP_MCE : { u64 mcg_cap ; r = - EFAULT ; if ( copy_from_user ( & mcg_cap , argp , sizeof mcg_cap ) ) goto out ; r = kvm_vcpu_ioctl_x86_setup_mce ( vcpu , mcg_cap ) ; break ; } case KVM_X86_SET_MCE : { struct kvm_x86_mce mce ; r = - EFAULT ; if ( copy_from_user ( & mce , argp , sizeof mce ) ) goto out ; r = kvm_vcpu_ioctl_x86_set_mce ( vcpu , & mce ) ; break ; } case KVM_GET_VCPU_EVENTS : { struct kvm_vcpu_events events ; kvm_vcpu_ioctl_x86_get_vcpu_events ( vcpu , & events ) ; r = - EFAULT ; if ( copy_to_user ( argp , & events , sizeof ( struct kvm_vcpu_events ) ) ) break ; r = 0 ; break ; } case KVM_SET_VCPU_EVENTS : { struct kvm_vcpu_events events ; r = - EFAULT ; if ( copy_from_user ( & events , argp , sizeof ( struct kvm_vcpu_events ) ) ) break ; r = kvm_vcpu_ioctl_x86_set_vcpu_events ( vcpu , & events ) ; break ; } case KVM_GET_DEBUGREGS : { struct kvm_debugregs dbgregs ; kvm_vcpu_ioctl_x86_get_debugregs ( vcpu , & dbgregs ) ; r = - EFAULT ; if ( copy_to_user ( argp , & dbgregs , sizeof ( struct kvm_debugregs ) ) ) break ; r = 0 ; break ; } case KVM_SET_DEBUGREGS : { struct kvm_debugregs dbgregs ; r = - EFAULT ; if ( copy_from_user ( & dbgregs , argp , sizeof ( struct kvm_debugregs ) ) ) break ; r = kvm_vcpu_ioctl_x86_set_debugregs ( vcpu , & dbgregs ) ; break ; } case KVM_GET_XSAVE : { u . xsave = kzalloc ( sizeof ( struct kvm_xsave ) , GFP_KERNEL ) ; r = - ENOMEM ; if ( ! u . xsave ) break ; kvm_vcpu_ioctl_x86_get_xsave ( vcpu , u . xsave ) ; r = - EFAULT ; if ( copy_to_user ( argp , u . xsave , sizeof ( struct kvm_xsave ) ) ) break ; r = 0 ; break ; } case KVM_SET_XSAVE : { u . xsave = memdup_user ( argp , sizeof ( * u . xsave ) ) ; if ( IS_ERR ( u . xsave ) ) return PTR_ERR ( u . xsave ) ; r = kvm_vcpu_ioctl_x86_set_xsave ( vcpu , u . xsave ) ; break ; } case KVM_GET_XCRS : { u . xcrs = kzalloc ( sizeof ( struct kvm_xcrs ) , GFP_KERNEL ) ; r = - ENOMEM ; if ( ! u . xcrs ) break ; kvm_vcpu_ioctl_x86_get_xcrs ( vcpu , u . xcrs ) ; r = - EFAULT ; if ( copy_to_user ( argp , u . xcrs , sizeof ( struct kvm_xcrs ) ) ) break ; r = 0 ; break ; } case KVM_SET_XCRS : { u . xcrs = memdup_user ( argp , sizeof ( * u . xcrs ) ) ; if ( IS_ERR ( u . xcrs ) ) return PTR_ERR ( u . xcrs ) ; r = kvm_vcpu_ioctl_x86_set_xcrs ( vcpu , u . xcrs ) ; break ; } case KVM_SET_TSC_KHZ : { u32 user_tsc_khz ; r = - EINVAL ; user_tsc_khz = ( u32 ) arg ; if ( user_tsc_khz >= kvm_max_guest_tsc_khz ) goto out ; if ( user_tsc_khz == 0 ) user_tsc_khz = tsc_khz ; kvm_set_tsc_khz ( vcpu , user_tsc_khz ) ; r = 0 ; goto out ; } case KVM_GET_TSC_KHZ : { r = vcpu -> arch . virtual_tsc_khz ; goto out ; } case KVM_KVMCLOCK_CTRL : { r = kvm_set_guest_paused ( vcpu ) ; goto out ; } default : r = - EINVAL ; } out : kfree ( u . buffer ) ; return r ; }
","<S2SV_ModStart> ; r = <S2SV_ModEnd> kvm_lapic_set_vapic_addr ( vcpu
",torvalds@linux/fda4e2e85589191b123d31cdc21fd33ee70f50fd,CVE-2013-6368,https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd,2013-12-14T18:08Z,<S2SV_StartBug> r = 0 ; <S2SV_EndBug>
8120,CWE-295,"void options_defaults ( ) { SERVICE_OPTIONS * service ; memset ( & new_global_options , 0 , sizeof ( GLOBAL_OPTIONS ) ) ; memset ( & new_service_options , 0 , sizeof ( SERVICE_OPTIONS ) ) ; new_service_options . next = NULL ; <S2SV_StartBug> parse_global_option ( CMD_SET_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug> service = & new_service_options ; parse_service_option ( CMD_SET_DEFAULTS , & service , NULL , NULL ) ; }
","<S2SV_ModStart> ( CMD_SET_DEFAULTS , & new_global_options ,
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,"<S2SV_StartBug> parse_global_option ( CMD_SET_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug>"
3714,CWE-362,"static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ; if ( ! sel ) return 0 ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug> limit = ( limit << 12 ) + 0xfff ; return limit ; }
","<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; unsigned <S2SV_ModStart> return 0 ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> = get_desc_limit ( & <S2SV_ModStart> if ( desc . <S2SV_ModEnd> g ) limit
",torvalds@linux/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,CVE-2019-13233,https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,2019-07-04T13:15Z,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug>
1588,CWE-119,"<S2SV_StartBug> static void predict_and_reconstruct_intra_block ( int plane , int block , <S2SV_EndBug> BLOCK_SIZE plane_bsize , <S2SV_StartBug> TX_SIZE tx_size , void * arg ) { <S2SV_EndBug> struct intra_args * const args = ( struct intra_args * ) arg ; VP9_COMMON * const cm = args -> cm ; MACROBLOCKD * const xd = args -> xd ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> MODE_INFO * const mi = xd -> mi [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) <S2SV_EndBug> : mi -> mbmi . uv_mode ; int x , y ; uint8_t * dst ; <S2SV_StartBug> txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ; <S2SV_EndBug> <S2SV_StartBug> dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_predict_intra_block ( xd , block >> ( tx_size << 1 ) , <S2SV_EndBug> b_width_log2 ( plane_bsize ) , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , x , y , plane ) ; <S2SV_StartBug> if ( ! mi -> mbmi . skip ) { <S2SV_EndBug> <S2SV_StartBug> const int eob = vp9_decode_block_tokens ( cm , xd , plane , block , <S2SV_EndBug> plane_bsize , x , y , tx_size , args -> r ) ; inverse_transform_block ( xd , plane , block , tx_size , dst , pd -> dst . stride , eob ) ; } }
","<S2SV_ModStart> void predict_and_reconstruct_intra_block ( MACROBLOCKD * const xd , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col <S2SV_ModEnd> , TX_SIZE tx_size <S2SV_ModStart> , TX_SIZE tx_size ) { <S2SV_ModEnd> struct macroblockd_plane * <S2SV_ModStart> plane ] ; PREDICTION_MODE <S2SV_ModEnd> mode = ( <S2SV_ModStart> 0 ) ? mbmi -> mode : mbmi -> uv_mode ; <S2SV_ModEnd> uint8_t * dst <S2SV_ModStart> * dst ; <S2SV_ModEnd> dst = & <S2SV_ModStart> [ 4 * row <S2SV_ModEnd> * pd -> <S2SV_ModStart> + 4 * col ] ; if ( mbmi -> sb_type < BLOCK_8X8 ) if ( plane == 0 ) mode = xd -> mi [ 0 ] -> bmi [ ( row <S2SV_ModEnd> << 1 ) <S2SV_ModStart> << 1 ) + col ] . as_mode ; vp9_predict_intra_block ( xd , pd -> n4_wl , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , col , row <S2SV_ModEnd> , plane ) <S2SV_ModStart> if ( ! mbmi -> <S2SV_ModEnd> skip ) { <S2SV_ModStart> ) { const TX_TYPE tx_type = ( plane || xd -> lossless ) ? DCT_DCT : intra_mode_to_tx_type_lookup [ mode ] ; const scan_order * sc = ( plane || xd -> lossless ) ? & vp9_default_scan_orders [ tx_size ] : & vp9_scan_orders [ tx_size ] [ tx_type ] ; const <S2SV_ModStart> = vp9_decode_block_tokens ( xd , plane , sc , col , row , tx_size , r , mbmi -> segment_id ) ; inverse_transform_block_intra ( xd , plane , tx_type , tx_size , dst , pd -> dst . stride , <S2SV_ModEnd> eob ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void predict_and_reconstruct_intra_block ( int plane , int block , <S2SV_EndBug> <S2SV_StartBug> TX_SIZE tx_size , void * arg ) { <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * const mi = xd -> mi [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) <S2SV_EndBug> <S2SV_StartBug> txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ; <S2SV_EndBug> <S2SV_StartBug> dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_predict_intra_block ( xd , block >> ( tx_size << 1 ) , <S2SV_EndBug> <S2SV_StartBug> if ( ! mi -> mbmi . skip ) { <S2SV_EndBug> <S2SV_StartBug> const int eob = vp9_decode_block_tokens ( cm , xd , plane , block , <S2SV_EndBug>"
4930,CWE-617,"int pci_emul_alloc_pbar ( struct pci_vdev * pdi , int idx , uint64_t hostbase , enum pcibar_type type , uint64_t size ) { int error ; uint64_t * baseptr , limit , addr , mask , lobits , bar ; <S2SV_StartBug> assert ( idx >= 0 && idx <= PCI_BARMAX ) ; <S2SV_EndBug> if ( ( size & ( size - 1 ) ) != 0 ) size = 1UL << flsl ( size ) ; if ( type == PCIBAR_IO ) { if ( size < 4 ) size = 4 ; } else { if ( size < 16 ) size = 16 ; } switch ( type ) { case PCIBAR_NONE : baseptr = NULL ; addr = mask = lobits = 0 ; break ; case PCIBAR_IO : baseptr = & pci_emul_iobase ; limit = PCI_EMUL_IOLIMIT ; mask = PCIM_BAR_IO_BASE ; lobits = PCIM_BAR_IO_SPACE ; break ; <S2SV_StartBug> case PCIBAR_MEM64 : <S2SV_EndBug> if ( ! skip_pci_mem64bar_workaround && ( size <= 32 * 1024 * 1024 ) ) { baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 ; break ; } if ( size == 0x100000000UL ) baseptr = & hostbase ; else baseptr = & pci_emul_membase64 ; limit = PCI_EMUL_MEMLIMIT64 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 | PCIM_BAR_MEM_PREFETCH ; break ; case PCIBAR_MEM32 : baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32 ; break ; default : <S2SV_StartBug> printf ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , type ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> } if ( baseptr != NULL ) { error = pci_emul_alloc_resource ( baseptr , limit , size , & addr ) ; if ( error != 0 ) return error ; } pdi -> bar [ idx ] . type = type ; pdi -> bar [ idx ] . addr = addr ; pdi -> bar [ idx ] . size = size ; bar = ( addr & mask ) | lobits ; pci_set_cfgdata32 ( pdi , PCIR_BAR ( idx ) , bar ) ; if ( type == PCIBAR_MEM64 ) { <S2SV_StartBug> assert ( idx + 1 <= PCI_BARMAX ) ; <S2SV_EndBug> pdi -> bar [ idx + 1 ] . type = PCIBAR_MEMHI64 ; pci_set_cfgdata32 ( pdi , PCIR_BAR ( idx + 1 ) , bar >> 32 ) ; } register_bar ( pdi , idx ) ; return 0 ; }
","<S2SV_ModStart> , bar ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> case PCIBAR_MEM64 : if ( idx + 1 > PCI_BARMAX ) { pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>MEM64<S2SV_blank>type\\n"" , __func__ , idx ) ; return - 1 ; } <S2SV_ModStart> ; default : pr_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , <S2SV_ModStart> type ) ; return - 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> PCIBAR_MEM64 ) { <S2SV_ModEnd> pdi -> bar
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,"<S2SV_StartBug> assert ( idx >= 0 && idx <= PCI_BARMAX ) ; <S2SV_EndBug> <S2SV_StartBug> case PCIBAR_MEM64 : <S2SV_EndBug> <S2SV_StartBug> printf ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , type ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( idx + 1 <= PCI_BARMAX ) ; <S2SV_EndBug>"
2730,CWE-834,"static int mxf_read_index_entry_array ( AVIOContext * pb , MXFIndexTableSegment * segment ) { int i , length ; segment -> nb_index_entries = avio_rb32 ( pb ) ; length = avio_rb32 ( pb ) ; <S2SV_StartBug> if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || <S2SV_EndBug> ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) { av_freep ( & segment -> temporal_offset_entries ) ; av_freep ( & segment -> flag_entries ) ; return AVERROR ( ENOMEM ) ; } <S2SV_StartBug> for ( i = 0 ; i < segment -> nb_index_entries ; i ++ ) { <S2SV_EndBug> segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ; avio_r8 ( pb ) ; segment -> flag_entries [ i ] = avio_r8 ( pb ) ; segment -> stream_offset_entries [ i ] = avio_rb64 ( pb ) ; avio_skip ( pb , length - 11 ) ; } return 0 ; }
","<S2SV_ModStart> ; if ( segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ; if ( <S2SV_ModStart> ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;
",FFmpeg@FFmpeg/900f39692ca0337a98a7cf047e4e2611071810c2,CVE-2017-14170,https://github.com/FFmpeg/FFmpeg/commit/900f39692ca0337a98a7cf047e4e2611071810c2,2017-09-07T06:29Z,"<S2SV_StartBug> if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < segment -> nb_index_entries ; i ++ ) { <S2SV_EndBug>"
6918,CWE-400,"asmlinkage void kernel_unaligned_trap ( struct pt_regs * regs , unsigned int insn ) { enum direction dir = decode_direction ( insn ) ; int size = decode_access_size ( insn ) ; if ( ! ok_for_kernel ( insn ) || dir == both ) { printk ( ""Unsupported<S2SV_blank>unaligned<S2SV_blank>load/store<S2SV_blank>trap<S2SV_blank>for<S2SV_blank>kernel<S2SV_blank>at<S2SV_blank><%08lx>.\\n"" , regs -> pc ) ; unaligned_panic ( ""Wheee.<S2SV_blank>Kernel<S2SV_blank>does<S2SV_blank>fpu/atomic<S2SV_blank>unaligned<S2SV_blank>load/store."" ) ; } else { unsigned long addr = compute_effective_address ( regs , insn ) ; int err ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug> switch ( dir ) { case load : err = do_int_load ( fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) , regs ) , size , ( unsigned long * ) addr , decode_signedness ( insn ) ) ; break ; case store : err = do_int_store ( ( ( insn >> 25 ) & 0x1f ) , size , ( unsigned long * ) addr , regs ) ; break ; default : panic ( ""Impossible<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>trap."" ) ; } if ( err ) kernel_mna_trap_fault ( regs , insn ) ; else advance ( regs ) ; } }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug>"
1339,CWE-119,"int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; VpxVideoReader * reader = NULL ; const VpxInterface * decoder = NULL ; const VpxVideoInfo * info = NULL ; exec_name = argv [ 0 ] ; if ( argc != 3 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , ""wb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 2 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( ""Unknown<S2SV_blank>input<S2SV_blank>codec."" ) ; <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder."" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame."" ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) { vpx_img_write ( img , outfile ) ; ++ frame_cnt ; } } printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec"" ) ; printf ( ""Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\n"" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }
","<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug>"
1880,CWE-119,"<S2SV_StartBug> static void encode_term_subexp ( vp9_writer * w , int word ) { <S2SV_EndBug> if ( ! write_bit_gte ( w , word , 16 ) ) { <S2SV_StartBug> vp9_write_literal ( w , word , 4 ) ; <S2SV_EndBug> } else if ( ! write_bit_gte ( w , word , 32 ) ) { <S2SV_StartBug> vp9_write_literal ( w , word - 16 , 4 ) ; <S2SV_EndBug> } else if ( ! write_bit_gte ( w , word , 64 ) ) { <S2SV_StartBug> vp9_write_literal ( w , word - 32 , 5 ) ; <S2SV_EndBug> } else { encode_uniform ( w , word - 64 ) ; } }
","<S2SV_ModStart> void encode_term_subexp ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> ) ) { vpx_write_literal <S2SV_ModEnd> ( w , <S2SV_ModStart> ) ) { vpx_write_literal <S2SV_ModEnd> ( w , <S2SV_ModStart> ) ) { vpx_write_literal <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void encode_term_subexp ( vp9_writer * w , int word ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word - 16 , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word - 32 , 5 ) ; <S2SV_EndBug>"
7790,CWE-125,"static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Py_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Py_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , ""non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument"" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; <S2SV_StartBug> i += 2 ; <S2SV_EndBug> break ; case STAR : if ( i + 1 >= NCH ( n ) || <S2SV_StartBug> ( i + 2 == NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == COMMA ) ) { <S2SV_EndBug> ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; <S2SV_StartBug> res = handle_keywordonly_args ( c , n , i , <S2SV_EndBug> kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; <S2SV_StartBug> i += 3 ; <S2SV_EndBug> if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; <S2SV_StartBug> i += 3 ; <S2SV_EndBug> break ; default : PyErr_Format ( PyExc_SystemError , ""unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d"" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }
","<S2SV_ModStart> ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 <S2SV_ModEnd> ; break ; <S2SV_ModStart> n ) && ( <S2SV_ModStart> ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) <S2SV_ModStart> += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } <S2SV_ModStart> ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } <S2SV_ModEnd> if ( i <S2SV_ModStart> ; i += 2 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 <S2SV_ModEnd> ; break ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> i += 2 ; <S2SV_EndBug> <S2SV_StartBug> ( i + 2 == NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == COMMA ) ) { <S2SV_EndBug> <S2SV_StartBug> res = handle_keywordonly_args ( c , n , i , <S2SV_EndBug> <S2SV_StartBug> i += 3 ; <S2SV_EndBug> <S2SV_StartBug> i += 3 ; <S2SV_EndBug>"
7795,CWE-125,"static asdl_seq * ast_for_suite ( struct compiling * c , const node * n ) { asdl_seq * seq ; stmt_ty s ; int i , total , num , end , pos = 0 ; node * ch ; <S2SV_StartBug> REQ ( n , suite ) ; <S2SV_EndBug> total = num_stmts ( n ) ; seq = _Py_asdl_seq_new ( total , c -> c_arena ) ; if ( ! seq ) return NULL ; if ( TYPE ( CHILD ( n , 0 ) ) == simple_stmt ) { n = CHILD ( n , 0 ) ; end = NCH ( n ) - 1 ; if ( TYPE ( CHILD ( n , end - 1 ) ) == SEMI ) end -- ; for ( i = 0 ; i < end ; i += 2 ) { ch = CHILD ( n , i ) ; s = ast_for_stmt ( c , ch ) ; if ( ! s ) return NULL ; asdl_seq_SET ( seq , pos ++ , s ) ; } } else { <S2SV_StartBug> for ( i = 2 ; i < ( NCH ( n ) - 1 ) ; i ++ ) { <S2SV_EndBug> ch = CHILD ( n , i ) ; REQ ( ch , stmt ) ; num = num_stmts ( ch ) ; if ( num == 1 ) { s = ast_for_stmt ( c , ch ) ; if ( ! s ) return NULL ; asdl_seq_SET ( seq , pos ++ , s ) ; } else { int j ; ch = CHILD ( ch , 0 ) ; REQ ( ch , simple_stmt ) ; for ( j = 0 ; j < NCH ( ch ) ; j += 2 ) { if ( NCH ( CHILD ( ch , j ) ) == 0 ) { assert ( ( j + 1 ) == NCH ( ch ) ) ; break ; } s = ast_for_stmt ( c , CHILD ( ch , j ) ) ; if ( ! s ) return NULL ; asdl_seq_SET ( seq , pos ++ , s ) ; } } } } assert ( pos == seq -> size ) ; return seq ; }
","<S2SV_ModStart> * ch ; if ( TYPE ( n ) != func_body_suite ) { <S2SV_ModStart> suite ) ; } <S2SV_ModStart> } else { i = 2 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) { i += 2 ; REQ ( CHILD ( n , 2 ) , NEWLINE ) ; } for ( <S2SV_ModEnd> ; i <
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> REQ ( n , suite ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( NCH ( n ) - 1 ) ; i ++ ) { <S2SV_EndBug>"
7605,CWE-190,"<S2SV_StartBug> static inline ulong encode_twos_comp ( long n , int prec ) <S2SV_EndBug> { <S2SV_StartBug> ulong result ; <S2SV_EndBug> assert ( prec >= 2 ) ; jas_eprintf ( ""warning:<S2SV_blank>support<S2SV_blank>for<S2SV_blank>signed<S2SV_blank>data<S2SV_blank>is<S2SV_blank>untested\\n"" ) ; if ( n < 0 ) { result = - n ; result = ( result ^ 0xffffffffUL ) + 1 ; result &= ( 1 << prec ) - 1 ; } else { result = n ; } return result ; }
","<S2SV_ModStart> <S2SV_null> static inline jas_ulong <S2SV_ModEnd> encode_twos_comp ( long <S2SV_ModStart> prec ) { jas_ulong <S2SV_ModEnd> result ; assert
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,"<S2SV_StartBug> static inline ulong encode_twos_comp ( long n , int prec ) <S2SV_EndBug> <S2SV_StartBug> ulong result ; <S2SV_EndBug>"
1973,CWE-119,"static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) { char * input_string ; char * option_name ; char * option_value ; char * input_ptr ; <S2SV_StartBug> int is_keyframe_qaunt_set = 0 ; <S2SV_EndBug> vpx_codec_err_t res = VPX_CODEC_OK ; if ( options == NULL ) return VPX_CODEC_OK ; input_string = strdup ( options ) ; option_name = strtok_r ( input_string , ""="" , & input_ptr ) ; while ( option_name != NULL ) { option_value = strtok_r ( NULL , ""<S2SV_blank>"" , & input_ptr ) ; if ( option_value == NULL ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""option<S2SV_blank>missing<S2SV_blank>value:<S2SV_blank>%s\\n"" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; } <S2SV_StartBug> if ( strcmp ( ""encoding-mode"" , option_name ) == 0 ) { <S2SV_EndBug> res = set_option_encoding_mode ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ; <S2SV_StartBug> } else if ( strcmp ( ""layers"" , option_name ) == 0 ) { <S2SV_EndBug> svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) { res = parse_scale_factors ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ; <S2SV_StartBug> } else if ( strcmp ( ""quantizers"" , option_name ) == 0 ) { <S2SV_EndBug> res = parse_quantizer_values ( svc_ctx , option_value , 0 ) ; if ( res != VPX_CODEC_OK ) break ; <S2SV_StartBug> if ( ! is_keyframe_qaunt_set ) { <S2SV_EndBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; memcpy ( get_svc_internal ( svc_ctx ) -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ; } } else if ( strcmp ( ""quantizers-keyframe"" , option_name ) == 0 ) { res = parse_quantizer_values ( svc_ctx , option_value , 1 ) ; if ( res != VPX_CODEC_OK ) break ; <S2SV_StartBug> is_keyframe_qaunt_set = 1 ; <S2SV_EndBug> } else { svc_log ( svc_ctx , SVC_LOG_ERROR , ""invalid<S2SV_blank>option:<S2SV_blank>%s\\n"" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; } option_name = strtok_r ( NULL , ""="" , & input_ptr ) ; } free ( input_string ) ; <S2SV_StartBug> return res ; <S2SV_EndBug> }
","<S2SV_ModStart> * input_ptr ; SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ; vpx_codec_err_t res = VPX_CODEC_OK ; int i , alt_ref_enabled = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( strcmp ( ""spatial-layers"" , option_name ) == 0 ) { svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( ""temporal-layers"" , option_name ) == 0 ) { svc_ctx -> temporal_layers = atoi ( option_value ) ; } else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , SCALE_FACTOR , option_value , si -> svc_params . scaling_factor_num , si -> svc_params . scaling_factor_den <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( strcmp ( ""max-quantizers"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . max_quantizers , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( strcmp ( ""min-quantizers"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . min_quantizers , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) break ; } else if ( strcmp ( ""auto-alt-refs"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , AUTO_ALT_REF , option_value , si -> enable_auto_alt_ref , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) break ; } else if ( strcmp ( ""bitrates"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , BITRATE , option_value , si -> bitrates , NULL ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( ""multi-frame-contexts"" , option_name ) == 0 ) { si -> use_multiple_frame_contexts = atoi ( option_value ) <S2SV_ModEnd> ; } else <S2SV_ModStart> input_string ) ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { if ( si -> svc_params . max_quantizers [ i ] > MAX_QUANTIZER || si -> svc_params . max_quantizers [ i ] < 0 || si -> svc_params . min_quantizers [ i ] > si -> svc_params . max_quantizers [ i ] || si -> svc_params . min_quantizers [ i ] < 0 ) res = VPX_CODEC_INVALID_PARAM ; } if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) alt_ref_enabled += si -> enable_auto_alt_ref [ i ] ; if ( alt_ref_enabled > REF_FRAMES - svc_ctx -> spatial_layers ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""svc:<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>ref:<S2SV_blank>Maxinum<S2SV_blank>%d(REF_FRAMES<S2SV_blank>-<S2SV_blank>layers)<S2SV_blank>layers<S2SV_blank>could"" ""enabled<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>reference<S2SV_blank>frame,<S2SV_blank>but<S2SV_blank>%<S2SV_blank>layers<S2SV_blank>are<S2SV_blank>enabled\\n"" , REF_FRAMES - svc_ctx -> spatial_layers , alt_ref_enabled ) ; res = VPX_CODEC_INVALID_PARAM ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int is_keyframe_qaunt_set = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( ""encoding-mode"" , option_name ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( ""layers"" , option_name ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( ""quantizers"" , option_name ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! is_keyframe_qaunt_set ) { <S2SV_EndBug> <S2SV_StartBug> is_keyframe_qaunt_set = 1 ; <S2SV_EndBug> <S2SV_StartBug> return res ; <S2SV_EndBug>"
555,CWE-189,"int sysMapFile ( const char * fn , MemMapping * pMap ) { memset ( pMap , 0 , sizeof ( * pMap ) ) ; if ( fn && fn [ 0 ] == '@' ) { FILE * mapf = fopen ( fn + 1 , ""r"" ) ; if ( mapf == NULL ) { LOGV ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\'%s\':<S2SV_blank>%s\\n"" , fn + 1 , strerror ( errno ) ) ; return - 1 ; } if ( sysMapBlockFile ( mapf , pMap ) != 0 ) { LOGW ( ""Map<S2SV_blank>of<S2SV_blank>\'%s\'<S2SV_blank>failed\\n"" , fn ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } fclose ( mapf ) ; } else { int fd = open ( fn , O_RDONLY , 0 ) ; if ( fd < 0 ) { LOGE ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\'%s\':<S2SV_blank>%s\\n"" , fn , strerror ( errno ) ) ; return - 1 ; } if ( sysMapFD ( fd , pMap ) != 0 ) { LOGE ( ""Map<S2SV_blank>of<S2SV_blank>\'%s\'<S2SV_blank>failed\\n"" , fn ) ; close ( fd ) ; return - 1 ; } close ( fd ) ; } return 0 ; }
","<S2SV_ModStart> fn ) ; fclose ( mapf ) ;
",bootable@recovery/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,CVE-2016-0849,https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,2016-04-18T00:59Z,<S2SV_StartBug> return - 1 ; <S2SV_EndBug>
1336,CWE-119,"static void set_roi_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { unsigned int i ; <S2SV_StartBug> vpx_roi_map_t roi = { 0 } ; <S2SV_EndBug> roi . rows = ( cfg -> g_h + 15 ) / 16 ; roi . cols = ( cfg -> g_w + 15 ) / 16 ; roi . delta_q [ 0 ] = 0 ; roi . delta_q [ 1 ] = - 2 ; roi . delta_q [ 2 ] = - 4 ; roi . delta_q [ 3 ] = - 6 ; roi . delta_lf [ 0 ] = 0 ; roi . delta_lf [ 1 ] = 1 ; roi . delta_lf [ 2 ] = 2 ; roi . delta_lf [ 3 ] = 3 ; roi . static_threshold [ 0 ] = 1500 ; roi . static_threshold [ 1 ] = 1000 ; roi . static_threshold [ 2 ] = 500 ; roi . static_threshold [ 3 ] = 0 ; roi . roi_map = ( uint8_t * ) malloc ( roi . rows * roi . cols ) ; for ( i = 0 ; i < roi . rows * roi . cols ; ++ i ) roi . roi_map [ i ] = i % 4 ; if ( vpx_codec_control ( codec , VP8E_SET_ROI_MAP , & roi ) ) die_codec ( codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>ROI<S2SV_blank>map"" ) ; free ( roi . roi_map ) ; }
","<S2SV_ModStart> ; vpx_roi_map_t roi ; memset ( & roi , 0 , sizeof ( roi ) ) <S2SV_ModEnd> ; roi .
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> vpx_roi_map_t roi = { 0 } ; <S2SV_EndBug>
7892,CWE-20,"error_t httpClientSetUri ( HttpClientContext * context , const char_t * uri ) { size_t m ; size_t n ; char_t * p ; char_t * q ; if ( context == NULL || uri == NULL ) return ERROR_INVALID_PARAMETER ; if ( uri [ 0 ] == '\\0' ) return ERROR_INVALID_PARAMETER ; if ( context -> requestState != HTTP_REQ_STATE_FORMAT_HEADER ) return ERROR_WRONG_STATE ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ; <S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( p == NULL ) return ERROR_INVALID_SYNTAX ; p ++ ; q = strpbrk ( p , ""<S2SV_blank>?"" ) ; if ( q == NULL ) return ERROR_INVALID_SYNTAX ; m = q - p ; n = osStrlen ( uri ) ; if ( ( context -> bufferLen + n - m ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + n , q , context -> buffer + context -> bufferLen + 1 - q ) ; osStrncpy ( p , uri , n ) ; context -> bufferLen = context -> bufferLen + n - m ; return NO_ERROR ; }
","<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug>"
7893,CWE-20,"error_t httpClientFormatAuthorizationField ( HttpClientContext * context ) { size_t n ; char_t * p ; HttpClientAuthParams * authParams ; if ( context -> bufferLen < 2 || context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; authParams = & context -> authParams ; # if ( HTTP_CLIENT_BASIC_AUTH_SUPPORT == ENABLED ) if ( authParams -> mode == HTTP_AUTH_MODE_BASIC ) { size_t k ; size_t m ; n = osStrlen ( authParams -> username ) + osStrlen ( authParams -> password ) ; if ( ( context -> bufferLen + n + 22 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; p = context -> buffer + context -> bufferLen - 2 ; n = osSprintf ( p , ""Authorization:<S2SV_blank>Basic<S2SV_blank>"" ) ; m = osSprintf ( p + n , ""%s:%s"" , authParams -> username , authParams -> password ) ; base64Encode ( p + n , m , NULL , & k ) ; if ( ( context -> bufferLen + n + k ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; base64Encode ( p + n , m , p + n , & k ) ; n += k ; if ( ( context -> bufferLen + n + 2 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osSprintf ( p + n , ""\\r\\n\\r\\n"" ) ; context -> bufferLen = context -> bufferLen + n + 2 ; } else # endif # if ( HTTP_CLIENT_DIGEST_AUTH_SUPPORT == ENABLED ) if ( authParams -> mode == HTTP_AUTH_MODE_DIGEST ) { error_t error ; const char_t * q ; const char_t * uri ; size_t uriLen ; char_t response [ HTTP_CLIENT_MAX_RESPONSE_LEN + 1 ] ; context -> buffer [ context -> bufferLen ] = '\\0' ; <S2SV_StartBug> q = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; uri = q + 1 ; <S2SV_StartBug> q = strchr ( uri , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; uriLen = q - uri ; if ( authParams -> qop == HTTP_AUTH_QOP_AUTH || authParams -> qop == HTTP_AUTH_QOP_AUTH_INT ) { if ( context -> randCallback == NULL ) return ERROR_PRNG_NOT_READY ; error = context -> randCallback ( authParams -> cnonce , HTTP_CLIENT_CNONCE_SIZE ) ; if ( error ) return error ; httpEncodeHexString ( authParams -> cnonce , HTTP_CLIENT_CNONCE_SIZE , authParams -> cnonce ) ; authParams -> nc ++ ; } error = httpClientComputeDigest ( authParams , context -> method , osStrlen ( context -> method ) , uri , uriLen , response ) ; if ( error ) return error ; n = osStrlen ( authParams -> username ) + osStrlen ( authParams -> realm ) + uriLen + osStrlen ( authParams -> nonce ) + osStrlen ( authParams -> cnonce ) + osStrlen ( response ) + osStrlen ( authParams -> opaque ) ; if ( ( context -> bufferLen + n + 121 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; p = context -> buffer + context -> bufferLen - 2 ; n = osSprintf ( p , ""Authorization:<S2SV_blank>Digest<S2SV_blank>"" ) ; n += osSprintf ( p + n , ""username=\\""%s\\"",<S2SV_blank>"" , authParams -> username ) ; n += osSprintf ( p + n , ""realm=\\""%s\\"",<S2SV_blank>"" , authParams -> realm ) ; n += osSprintf ( p + n , ""uri=\\"""" ) ; osStrncpy ( p + n , uri , uriLen ) ; n += uriLen ; n += osSprintf ( p + n , ""\\"",<S2SV_blank>"" ) ; n += osSprintf ( p + n , ""nonce=\\""%s\\"",<S2SV_blank>"" , authParams -> nonce ) ; if ( authParams -> qop == HTTP_AUTH_QOP_AUTH ) { n += osSprintf ( p + n , ""qop=auth,<S2SV_blank>"" ) ; n += osSprintf ( p + n , ""nc=%08x,<S2SV_blank>"" , authParams -> nc ) ; n += osSprintf ( p + n , ""cnonce=\\""%s\\"",<S2SV_blank>"" , authParams -> cnonce ) ; } n += osSprintf ( p + n , ""response=\\""%s\\"""" , response ) ; if ( authParams -> opaque [ 0 ] != '\\0' ) { n += osSprintf ( p + n , "",<S2SV_blank>opaque=\\""%s\\"""" , authParams -> opaque ) ; } osSprintf ( p + n , ""\\r\\n\\r\\n"" ) ; context -> bufferLen = context -> bufferLen + n + 2 ; } else # endif { } return NO_ERROR ; }
","<S2SV_ModStart> ; q = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> ; q = osStrchr <S2SV_ModEnd> ( uri ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> q = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> <S2SV_StartBug> q = strchr ( uri , '<S2SV_blank>' ) ; <S2SV_EndBug>"
2603,CWE-416,"static int packet_set_ring ( struct sock * sk , union tpacket_req_u * req_u , int closing , int tx_ring ) { struct pgv * pg_vec = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; int was_running , order = 0 ; struct packet_ring_buffer * rb ; struct sk_buff_head * rb_queue ; __be16 num ; int err = - EINVAL ; <S2SV_StartBug> struct tpacket_req * req = & req_u -> req ; <S2SV_EndBug> if ( ! closing && tx_ring && ( po -> tp_version > TPACKET_V2 ) ) { net_warn_ratelimited ( ""Tx-ring<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported.\\n"" ) ; goto out ; } rb = tx_ring ? & po -> tx_ring : & po -> rx_ring ; rb_queue = tx_ring ? & sk -> sk_write_queue : & sk -> sk_receive_queue ; err = - EBUSY ; if ( ! closing ) { if ( atomic_read ( & po -> mapped ) ) goto out ; if ( packet_read_pending ( rb ) ) goto out ; } if ( req -> tp_block_nr ) { err = - EBUSY ; if ( unlikely ( rb -> pg_vec ) ) goto out ; switch ( po -> tp_version ) { case TPACKET_V1 : po -> tp_hdrlen = TPACKET_HDRLEN ; break ; case TPACKET_V2 : po -> tp_hdrlen = TPACKET2_HDRLEN ; break ; case TPACKET_V3 : po -> tp_hdrlen = TPACKET3_HDRLEN ; break ; } err = - EINVAL ; if ( unlikely ( ( int ) req -> tp_block_size <= 0 ) ) goto out ; if ( unlikely ( ! PAGE_ALIGNED ( req -> tp_block_size ) ) ) goto out ; if ( po -> tp_version >= TPACKET_V3 && ( int ) ( req -> tp_block_size - BLK_PLUS_PRIV ( req_u -> req3 . tp_sizeof_priv ) ) <= 0 ) goto out ; if ( unlikely ( req -> tp_frame_size < po -> tp_hdrlen + po -> tp_reserve ) ) goto out ; if ( unlikely ( req -> tp_frame_size & ( TPACKET_ALIGNMENT - 1 ) ) ) goto out ; rb -> frames_per_block = req -> tp_block_size / req -> tp_frame_size ; if ( unlikely ( rb -> frames_per_block == 0 ) ) goto out ; if ( unlikely ( ( rb -> frames_per_block * req -> tp_block_nr ) != req -> tp_frame_nr ) ) goto out ; err = - ENOMEM ; order = get_order ( req -> tp_block_size ) ; pg_vec = alloc_pg_vec ( req , order ) ; if ( unlikely ( ! pg_vec ) ) goto out ; switch ( po -> tp_version ) { case TPACKET_V3 : if ( ! tx_ring ) init_prb_bdqc ( po , rb , pg_vec , req_u ) ; break ; default : break ; } } else { err = - EINVAL ; if ( unlikely ( req -> tp_frame_nr ) ) goto out ; } <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> spin_lock ( & po -> bind_lock ) ; was_running = po -> running ; num = po -> num ; if ( was_running ) { po -> num = 0 ; __unregister_prot_hook ( sk , false ) ; } spin_unlock ( & po -> bind_lock ) ; synchronize_net ( ) ; err = - EBUSY ; mutex_lock ( & po -> pg_vec_lock ) ; if ( closing || atomic_read ( & po -> mapped ) == 0 ) { err = 0 ; spin_lock_bh ( & rb_queue -> lock ) ; swap ( rb -> pg_vec , pg_vec ) ; rb -> frame_max = ( req -> tp_frame_nr - 1 ) ; rb -> head = 0 ; rb -> frame_size = req -> tp_frame_size ; spin_unlock_bh ( & rb_queue -> lock ) ; swap ( rb -> pg_vec_order , order ) ; swap ( rb -> pg_vec_len , req -> tp_block_nr ) ; rb -> pg_vec_pages = req -> tp_block_size / PAGE_SIZE ; po -> prot_hook . func = ( po -> rx_ring . pg_vec ) ? tpacket_rcv : packet_rcv ; skb_queue_purge ( rb_queue ) ; if ( atomic_read ( & po -> mapped ) ) pr_err ( ""packet_mmap:<S2SV_blank>vma<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>%d\\n"" , atomic_read ( & po -> mapped ) ) ; } mutex_unlock ( & po -> pg_vec_lock ) ; spin_lock ( & po -> bind_lock ) ; if ( was_running ) { po -> num = num ; register_prot_hook ( sk ) ; } spin_unlock ( & po -> bind_lock ) ; if ( closing && ( po -> tp_version > TPACKET_V2 ) ) { if ( ! tx_ring ) prb_shutdown_retire_blk_timer ( po , rb_queue ) ; } <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pg_vec ) <S2SV_EndBug> free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : return err ; }
","<S2SV_ModStart> req_u -> req ; lock_sock ( sk ) <S2SV_ModStart> out ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ; } if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : <S2SV_ModStart> sk ) ; <S2SV_ModEnd> return err ;
",torvalds@linux/84ac7260236a49c79eede91617700174c2c19b0c,CVE-2016-8655,https://github.com/torvalds/linux/commit/84ac7260236a49c79eede91617700174c2c19b0c,2016-12-08T08:59Z,<S2SV_StartBug> struct tpacket_req * req = & req_u -> req ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pg_vec ) <S2SV_EndBug>
2262,CWE-20,"static int do_anonymous_page ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags ) { struct mem_cgroup * memcg ; struct page * page ; spinlock_t * ptl ; pte_t entry ; pte_unmap ( page_table ) ; <S2SV_StartBug> if ( check_stack_guard_page ( vma , address ) < 0 ) <S2SV_EndBug> return VM_FAULT_SIGSEGV ; if ( ! ( flags & FAULT_FLAG_WRITE ) && ! mm_forbids_zeropage ( mm ) ) { entry = pte_mkspecial ( pfn_pte ( my_zero_pfn ( address ) , vma -> vm_page_prot ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto unlock ; goto setpte ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) goto oom ; page = alloc_zeroed_user_highpage_movable ( vma , address ) ; if ( ! page ) goto oom ; if ( mem_cgroup_try_charge ( page , mm , GFP_KERNEL , & memcg ) ) goto oom_free_page ; __SetPageUptodate ( page ) ; entry = mk_pte ( page , vma -> vm_page_prot ) ; if ( vma -> vm_flags & VM_WRITE ) entry = pte_mkwrite ( pte_mkdirty ( entry ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto release ; inc_mm_counter_fast ( mm , MM_ANONPAGES ) ; page_add_new_anon_rmap ( page , vma , address ) ; mem_cgroup_commit_charge ( page , memcg , false ) ; lru_cache_add_active_or_unevictable ( page , vma ) ; setpte : set_pte_at ( mm , address , page_table , entry ) ; update_mmu_cache ( vma , address , page_table ) ; unlock : pte_unmap_unlock ( page_table , ptl ) ; return 0 ; release : mem_cgroup_cancel_charge ( page , memcg ) ; page_cache_release ( page ) ; goto unlock ; oom_free_page : page_cache_release ( page ) ; oom : return VM_FAULT_OOM ; }
","<S2SV_ModStart> ; if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if (
",torvalds@linux/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,CVE-2015-3288,https://github.com/torvalds/linux/commit/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,2016-10-16T21:59Z,"<S2SV_StartBug> if ( check_stack_guard_page ( vma , address ) < 0 ) <S2SV_EndBug>"
6566,CWE-119,"cJSON * iperf_json_printf ( const char * format , ... ) { cJSON * o ; va_list argp ; const char * cp ; char name [ 100 ] ; char * np ; cJSON * j ; o = cJSON_CreateObject ( ) ; if ( o == NULL ) return NULL ; va_start ( argp , format ) ; np = name ; for ( cp = format ; * cp != '\\0' ; ++ cp ) { switch ( * cp ) { case '<S2SV_blank>' : break ; case ':' : * np = '\\0' ; break ; case '%' : ++ cp ; switch ( * cp ) { case 'b' : j = cJSON_CreateBool ( va_arg ( argp , int ) ) ; break ; case 'd' : <S2SV_StartBug> j = cJSON_CreateInt ( va_arg ( argp , int64_t ) ) ; <S2SV_EndBug> break ; case 'f' : <S2SV_StartBug> j = cJSON_CreateFloat ( va_arg ( argp , double ) ) ; <S2SV_EndBug> break ; case 's' : j = cJSON_CreateString ( va_arg ( argp , char * ) ) ; break ; default : return NULL ; } if ( j == NULL ) return NULL ; cJSON_AddItemToObject ( o , name , j ) ; np = name ; break ; default : * np ++ = * cp ; break ; } } va_end ( argp ) ; return o ; }
","<S2SV_ModStart> : j = cJSON_CreateNumber <S2SV_ModEnd> ( va_arg ( <S2SV_ModStart> : j = cJSON_CreateNumber <S2SV_ModEnd> ( va_arg (
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,"<S2SV_StartBug> j = cJSON_CreateInt ( va_arg ( argp , int64_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> j = cJSON_CreateFloat ( va_arg ( argp , double ) ) ; <S2SV_EndBug>"
3087,CWE-264,"static int command_write ( struct pci_dev * dev , int offset , u16 value , void * data ) { struct xen_pcibk_dev_data * dev_data ; int err ; <S2SV_StartBug> dev_data = pci_get_drvdata ( dev ) ; <S2SV_EndBug> if ( ! pci_is_enabled ( dev ) && is_enable_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME "":<S2SV_blank>%s:<S2SV_blank>enable\\n"" , pci_name ( dev ) ) ; err = pci_enable_device ( dev ) ; if ( err ) return err ; if ( dev_data ) dev_data -> enable_intx = 1 ; } else if ( pci_is_enabled ( dev ) && ! is_enable_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME "":<S2SV_blank>%s:<S2SV_blank>disable\\n"" , pci_name ( dev ) ) ; pci_disable_device ( dev ) ; if ( dev_data ) dev_data -> enable_intx = 0 ; } if ( ! dev -> is_busmaster && is_master_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME "":<S2SV_blank>%s:<S2SV_blank>set<S2SV_blank>bus<S2SV_blank>master\\n"" , pci_name ( dev ) ) ; pci_set_master ( dev ) ; } if ( value & PCI_COMMAND_INVALIDATE ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME "":<S2SV_blank>%s:<S2SV_blank>enable<S2SV_blank>memory-write-invalidate\\n"" , pci_name ( dev ) ) ; err = pci_set_mwi ( dev ) ; if ( err ) { pr_warn ( ""%s:<S2SV_blank>cannot<S2SV_blank>enable<S2SV_blank>memory-write-invalidate<S2SV_blank>(%d)\\n"" , pci_name ( dev ) , err ) ; value &= ~ PCI_COMMAND_INVALIDATE ; } } <S2SV_StartBug> return pci_write_config_word ( dev , offset , value ) ; <S2SV_EndBug> }
","<S2SV_ModStart> int err ; u16 val ; struct pci_cmd_info * cmd = data ; <S2SV_ModStart> ; } } cmd -> val = value ; if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ; err = pci_read_config_word ( dev , offset , & val ) ; if ( err || val == value ) return err ; value &= PCI_COMMAND_GUEST ; value |= val & ~ PCI_COMMAND_GUEST ;
",torvalds@linux/af6fc858a35b90e89ea7a7ee58e66628c55c776b,CVE-2015-2150,https://github.com/torvalds/linux/commit/af6fc858a35b90e89ea7a7ee58e66628c55c776b,2015-03-12T14:59Z,"<S2SV_StartBug> dev_data = pci_get_drvdata ( dev ) ; <S2SV_EndBug> <S2SV_StartBug> return pci_write_config_word ( dev , offset , value ) ; <S2SV_EndBug>"
1745,CWE-119,"void vp9_xform_quant ( MACROBLOCK * x , int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size ) { MACROBLOCKD * const xd = & x -> e_mbd ; const struct macroblock_plane * const p = & x -> plane [ plane ] ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; const scan_order * const scan_order = & vp9_default_scan_orders [ tx_size ] ; <S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> uint16_t * const eob = & p -> eobs [ block ] ; const int diff_stride = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ; int i , j ; const int16_t * src_diff ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; src_diff = & p -> src_diff [ 4 * ( j * diff_stride + i ) ] ; <S2SV_StartBug> switch ( tx_size ) { <S2SV_EndBug> case TX_32X32 : <S2SV_StartBug> fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , <S2SV_EndBug> <S2SV_StartBug> p -> quant , p -> quant_shift , qcoeff , dqcoeff , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , scan_order -> scan , <S2SV_EndBug> scan_order -> iscan ) ; break ; case TX_16X16 : <S2SV_StartBug> vp9_fdct16x16 ( src_diff , coeff , diff_stride ) ; <S2SV_EndBug> vp9_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> scan_order -> scan , scan_order -> iscan ) ; break ; case TX_8X8 : <S2SV_StartBug> vp9_fdct8x8 ( src_diff , coeff , diff_stride ) ; <S2SV_EndBug> vp9_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> scan_order -> scan , scan_order -> iscan ) ; break ; case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; <S2SV_StartBug> vp9_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , <S2SV_EndBug> p -> quant , p -> quant_shift , qcoeff , dqcoeff , <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> scan_order -> scan , scan_order -> iscan ) ; break ; default : <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> tx_size ] ; tran_low_t <S2SV_ModEnd> * const coeff <S2SV_ModStart> block ) ; tran_low_t <S2SV_ModEnd> * const qcoeff <S2SV_ModStart> block ) ; tran_low_t <S2SV_ModEnd> * const dqcoeff <S2SV_ModStart> ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> case TX_32X32 : highbd_fdct32x32 <S2SV_ModEnd> ( x -> <S2SV_ModStart> diff_stride ) ; vpx_highbd_quantize_b_32x32 <S2SV_ModEnd> ( coeff , <S2SV_ModStart> , qcoeff , dqcoeff , <S2SV_ModEnd> pd -> dequant <S2SV_ModStart> -> dequant , eob , <S2SV_ModEnd> scan_order -> scan <S2SV_ModStart> case TX_16X16 : vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff , <S2SV_ModStart> pd -> dequant <S2SV_ModEnd> , eob , <S2SV_ModStart> case TX_8X8 : vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff , <S2SV_ModStart> pd -> dequant <S2SV_ModEnd> , eob , <S2SV_ModStart> diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff , <S2SV_ModStart> -> dequant , <S2SV_ModEnd> eob , scan_order <S2SV_ModStart> ( 0 ) ; } return ; } # endif switch ( tx_size ) { case TX_32X32 : fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_16X16 : vpx_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_8X8 : vpx_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; default : assert ( 0 ) ; break
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( tx_size ) { <S2SV_EndBug> <S2SV_StartBug> fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , <S2SV_EndBug> <S2SV_StartBug> p -> quant , p -> quant_shift , qcoeff , dqcoeff , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , scan_order -> scan , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct16x16 ( src_diff , coeff , diff_stride ) ; <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct8x8 ( src_diff , coeff , diff_stride ) ; <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> <S2SV_StartBug> vp9_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug>"
3505,CWE-264,"static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ; <S2SV_StartBug> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <S2SV_EndBug> rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }
","<S2SV_ModStart> ; if ( dumpable != SUID_DUMP_USER && <S2SV_ModEnd> ! ptrace_has_cap (
",torvalds@linux/d049f74f2dbe71354d43d393ac3a188947811348,CVE-2013-2929,https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348,2013-12-09T18:55Z,"<S2SV_StartBug> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <S2SV_EndBug>"
404,CWE-362,"void ieee80211_sta_ps_deliver_wakeup ( struct sta_info * sta ) { struct ieee80211_sub_if_data * sdata = sta -> sdata ; struct ieee80211_local * local = sdata -> local ; struct sk_buff_head pending ; int filtered = 0 , buffered = 0 , ac ; unsigned long flags ; clear_sta_flag ( sta , WLAN_STA_SP ) ; BUILD_BUG_ON ( BITS_TO_LONGS ( IEEE80211_NUM_TIDS ) > 1 ) ; sta -> driver_buffered_tids = 0 ; if ( ! ( local -> hw . flags & IEEE80211_HW_AP_LINK_PS ) ) drv_sta_notify ( local , sdata , STA_NOTIFY_AWAKE , & sta -> sta ) ; skb_queue_head_init ( & pending ) ; <S2SV_StartBug> for ( ac = 0 ; ac < IEEE80211_NUM_ACS ; ac ++ ) { <S2SV_EndBug> int count = skb_queue_len ( & pending ) , tmp ; spin_lock_irqsave ( & sta -> tx_filtered [ ac ] . lock , flags ) ; skb_queue_splice_tail_init ( & sta -> tx_filtered [ ac ] , & pending ) ; spin_unlock_irqrestore ( & sta -> tx_filtered [ ac ] . lock , flags ) ; tmp = skb_queue_len ( & pending ) ; filtered += tmp - count ; count = tmp ; spin_lock_irqsave ( & sta -> ps_tx_buf [ ac ] . lock , flags ) ; skb_queue_splice_tail_init ( & sta -> ps_tx_buf [ ac ] , & pending ) ; spin_unlock_irqrestore ( & sta -> ps_tx_buf [ ac ] . lock , flags ) ; tmp = skb_queue_len ( & pending ) ; buffered += tmp - count ; } <S2SV_StartBug> ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ; <S2SV_EndBug> if ( ! ieee80211_smps_is_restrictive ( sta -> known_smps_mode , sdata -> smps_mode ) && sta -> known_smps_mode != sdata -> bss -> req_smps && sta_info_tx_streams ( sta ) != 1 ) { ht_dbg ( sdata , ""%pM<S2SV_blank>just<S2SV_blank>woke<S2SV_blank>up<S2SV_blank>and<S2SV_blank>MIMO<S2SV_blank>capable<S2SV_blank>-<S2SV_blank>update<S2SV_blank>SMPS\\n"" , sta -> sta . addr ) ; ieee80211_send_smps_action ( sdata , sdata -> bss -> req_smps , sta -> sta . addr , sdata -> vif . bss_conf . bssid ) ; } local -> total_ps_buffered -= buffered ; sta_info_recalc_tim ( sta ) ; ps_dbg ( sdata , ""STA<S2SV_blank>%pM<S2SV_blank>aid<S2SV_blank>%d<S2SV_blank>sending<S2SV_blank>%d<S2SV_blank>filtered/%d<S2SV_blank>PS<S2SV_blank>frames<S2SV_blank>since<S2SV_blank>STA<S2SV_blank>not<S2SV_blank>sleeping<S2SV_blank>anymore\\n"" , sta -> sta . addr , sta -> sta . aid , filtered , buffered ) ; }
","<S2SV_ModStart> pending ) ; spin_lock ( & sta -> ps_lock ) ; <S2SV_ModStart> clear_sta_ps_flags , sta ) ; spin_unlock ( & sta -> ps_lock
",torvalds@linux/1d147bfa64293b2723c4fec50922168658e613ba,CVE-2014-2706,https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba,2014-04-14T23:55Z,"<S2SV_StartBug> for ( ac = 0 ; ac < IEEE80211_NUM_ACS ; ac ++ ) { <S2SV_EndBug> <S2SV_StartBug> ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ; <S2SV_EndBug>"
5379,CWE-476,"static int pb0100_start ( struct sd * sd ) { int err , packet_size , max_packet_size ; struct usb_host_interface * alt ; struct usb_interface * intf ; struct gspca_dev * gspca_dev = ( struct gspca_dev * ) sd ; struct cam * cam = & sd -> gspca_dev . cam ; u32 mode = cam -> cam_mode [ sd -> gspca_dev . curr_mode ] . priv ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; <S2SV_StartBug> if ( ! alt ) <S2SV_EndBug> return - ENODEV ; packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; max_packet_size = sd -> sensor -> max_packet_size [ sd -> gspca_dev . curr_mode ] ; if ( packet_size < max_packet_size ) stv06xx_write_sensor ( sd , PB_ROWSPEED , BIT ( 4 ) | BIT ( 3 ) | BIT ( 1 ) ) ; else stv06xx_write_sensor ( sd , PB_ROWSPEED , BIT ( 5 ) | BIT ( 3 ) | BIT ( 1 ) ) ; if ( mode & PB0100_CROP_TO_VGA ) { stv06xx_write_sensor ( sd , PB_RSTART , 30 ) ; stv06xx_write_sensor ( sd , PB_CSTART , 20 ) ; stv06xx_write_sensor ( sd , PB_RWSIZE , 240 - 1 ) ; stv06xx_write_sensor ( sd , PB_CWSIZE , 320 - 1 ) ; } else { stv06xx_write_sensor ( sd , PB_RSTART , 8 ) ; stv06xx_write_sensor ( sd , PB_CSTART , 4 ) ; stv06xx_write_sensor ( sd , PB_RWSIZE , 288 - 1 ) ; stv06xx_write_sensor ( sd , PB_CWSIZE , 352 - 1 ) ; } if ( mode & PB0100_SUBSAMPLE ) { stv06xx_write_bridge ( sd , STV_Y_CTRL , 0x02 ) ; stv06xx_write_bridge ( sd , STV_X_CTRL , 0x06 ) ; stv06xx_write_bridge ( sd , STV_SCAN_RATE , 0x10 ) ; } else { stv06xx_write_bridge ( sd , STV_Y_CTRL , 0x01 ) ; stv06xx_write_bridge ( sd , STV_X_CTRL , 0x0a ) ; stv06xx_write_bridge ( sd , STV_SCAN_RATE , 0x20 ) ; } err = stv06xx_write_sensor ( sd , PB_CONTROL , BIT ( 5 ) | BIT ( 3 ) | BIT ( 1 ) ) ; gspca_dbg ( gspca_dev , D_STREAM , ""Started<S2SV_blank>stream,<S2SV_blank>status:<S2SV_blank>%d\\n"" , err ) ; return ( err < 0 ) ? err : 0 ; }
","<S2SV_ModStart> ( ! alt ) return - ENODEV ; if ( alt -> desc . bNumEndpoints < 1
",torvalds@linux/485b06aadb933190f4bc44e006076bc27a23f205,CVE-2020-11609,https://github.com/torvalds/linux/commit/485b06aadb933190f4bc44e006076bc27a23f205,2020-04-07T17:15Z,<S2SV_StartBug> if ( ! alt ) <S2SV_EndBug>
1696,CWE-119,"<S2SV_StartBug> static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> if ( x -> ab_index > 0 ) return ; } <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize , <S2SV_EndBug> output_enabled ) ; <S2SV_StartBug> encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; <S2SV_EndBug> if ( output_enabled ) { <S2SV_StartBug> update_stats ( cpi ) ; <S2SV_EndBug> ( * tp ) -> token = EOSB_TOKEN ; ( * tp ) ++ ; } }
","<S2SV_ModStart> * const tile , ThreadData * td <S2SV_ModStart> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> -> mb ; <S2SV_ModEnd> set_offsets ( cpi <S2SV_ModStart> cpi , tile , x <S2SV_ModStart> ( cpi , td , ctx <S2SV_ModEnd> , mi_row , <S2SV_ModStart> encode_superblock ( cpi , td <S2SV_ModStart> mi_col , bsize , ctx <S2SV_ModStart> { update_stats ( & cpi -> common , td <S2SV_ModEnd> ) ; (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize , <S2SV_EndBug> <S2SV_StartBug> encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_stats ( cpi ) ; <S2SV_EndBug>"
71,CWE-416,"static void test_modules ( ) { assert_true_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_error ( ""import<S2SV_blank>\\""\\\\x00\\"""" , ERROR_INVALID_MODULE_NAME ) ; assert_error ( ""import<S2SV_blank>\\""\\"""" , ERROR_INVALID_MODULE_NAME ) ; }
","<S2SV_ModStart> { assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL )
",VirusTotal@yara/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e,CVE-2017-8929,https://github.com/VirusTotal/yara/commit/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e,2017-05-14T22:29Z,"<S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug>"
1691,CWE-119,"<S2SV_StartBug> void vp9_fht8x8_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <S2SV_StartBug> vp9_fdct8x8_c ( input , output , stride ) ; <S2SV_EndBug> } else { <S2SV_StartBug> int16_t out [ 64 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> int i , j ; <S2SV_StartBug> int16_t temp_in [ 8 ] , temp_out [ 8 ] ; <S2SV_EndBug> const transform_2d ht = FHT_8 [ tx_type ] ; for ( i = 0 ; i < 8 ; ++ i ) { for ( j = 0 ; j < 8 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 8 ; ++ j ) <S2SV_StartBug> outptr [ j * 8 + i ] = temp_out [ j ] ; <S2SV_EndBug> } for ( i = 0 ; i < 8 ; ++ i ) { for ( j = 0 ; j < 8 ; ++ j ) temp_in [ j ] = out [ j + i * 8 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 8 ; ++ j ) output [ j + i * 8 ] = ( temp_out [ j ] + ( temp_out [ j ] < 0 ) ) >> 1 ; } } }
","<S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output , <S2SV_ModStart> DCT_DCT ) { vpx_fdct8x8_c <S2SV_ModEnd> ( input , <S2SV_ModStart> } else { tran_low_t <S2SV_ModEnd> out [ 64 <S2SV_ModStart> 64 ] ; <S2SV_ModEnd> int i , <S2SV_ModStart> , j ; tran_low_t <S2SV_ModEnd> temp_in [ 8 <S2SV_ModStart> ++ j ) out <S2SV_ModEnd> [ j *
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> void vp9_fht8x8_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct8x8_c ( input , output , stride ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t out [ 64 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 8 ] , temp_out [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> outptr [ j * 8 + i ] = temp_out [ j ] ; <S2SV_EndBug>"
426,CWE-000,"int jpc_bitstream_putbits ( jpc_bitstream_t * bitstream , int n , long v ) { int m ; <S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> assert ( ! ( v & ( ~ JAS_ONES ( n ) ) ) ) ; m = n - 1 ; while ( -- n >= 0 ) { if ( jpc_bitstream_putbit ( bitstream , ( v >> m ) & 1 ) == EOF ) { return EOF ; } v <<= 1 ; } return 0 ; }
","<S2SV_ModStart> int m ; if ( n < 0 || n >= 32 ) { return EOF ; } <S2SV_ModEnd> assert ( !
",mdadams@jasper/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,CVE-2016-9391,https://github.com/mdadams/jasper/commit/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,2017-03-23T18:59Z,<S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug>
8143,CWE-416,"static void win_enter_ext ( win_T * wp , int undo_sync , int curwin_invalid , int trigger_new_autocmds , int trigger_enter_autocmds , int trigger_leave_autocmds ) { int other_buffer = FALSE ; if ( wp == curwin && ! curwin_invalid ) return ; # ifdef FEAT_JOB_CHANNEL if ( ! curwin_invalid ) leaving_window ( curwin ) ; # endif if ( ! curwin_invalid && trigger_leave_autocmds ) { if ( wp -> w_buffer != curbuf ) { apply_autocmds ( EVENT_BUFLEAVE , NULL , NULL , FALSE , curbuf ) ; other_buffer = TRUE ; if ( ! win_valid ( wp ) ) return ; } apply_autocmds ( EVENT_WINLEAVE , NULL , NULL , FALSE , curbuf ) ; if ( ! win_valid ( wp ) ) return ; # ifdef FEAT_EVAL if ( aborting ( ) ) return ; # endif } if ( undo_sync && curbuf != wp -> w_buffer ) u_sync ( FALSE ) ; update_topline ( ) ; if ( wp -> w_buffer != curbuf ) buf_copy_options ( wp -> w_buffer , BCO_ENTER | BCO_NOHELP ) ; if ( ! curwin_invalid ) { prevwin = curwin ; curwin -> w_redr_status = TRUE ; } curwin = wp ; curbuf = wp -> w_buffer ; check_cursor ( ) ; if ( ! virtual_active ( ) ) curwin -> w_cursor . coladd = 0 ; changed_line_abv_curs ( ) ; if ( curwin -> w_localdir != NULL || curtab -> tp_localdir != NULL ) { char_u * dirname ; if ( globaldir == NULL ) { char_u cwd [ MAXPATHL ] ; if ( mch_dirname ( cwd , MAXPATHL ) == OK ) globaldir = vim_strsave ( cwd ) ; } if ( curwin -> w_localdir != NULL ) dirname = curwin -> w_localdir ; else dirname = curtab -> tp_localdir ; if ( mch_chdir ( ( char * ) dirname ) == 0 ) shorten_fnames ( TRUE ) ; } else if ( globaldir != NULL ) { vim_ignored = mch_chdir ( ( char * ) globaldir ) ; VIM_CLEAR ( globaldir ) ; shorten_fnames ( TRUE ) ; } # ifdef FEAT_JOB_CHANNEL entering_window ( curwin ) ; # endif if ( trigger_new_autocmds ) apply_autocmds ( EVENT_WINNEW , NULL , NULL , FALSE , curbuf ) ; if ( trigger_enter_autocmds ) { apply_autocmds ( EVENT_WINENTER , NULL , NULL , FALSE , curbuf ) ; if ( other_buffer ) apply_autocmds ( EVENT_BUFENTER , NULL , NULL , FALSE , curbuf ) ; } # ifdef FEAT_TITLE maketitle ( ) ; # endif curwin -> w_redr_status = TRUE ; # ifdef FEAT_TERMINAL <S2SV_StartBug> if ( bt_terminal ( wp -> w_buffer ) ) <S2SV_EndBug> redraw_mode = TRUE ; # endif redraw_tabline = TRUE ; if ( restart_edit ) redraw_later ( VALID ) ; if ( curwin -> w_height < p_wh && ! curwin -> w_p_wfh # ifdef FEAT_TEXT_PROP && ! popup_is_popup ( curwin ) # endif ) win_setheight ( ( int ) p_wh ) ; else if ( curwin -> w_height == 0 ) win_setheight ( 1 ) ; if ( curwin -> w_width < p_wiw && ! curwin -> w_p_wfw ) win_setwidth ( ( int ) p_wiw ) ; setmouse ( ) ; DO_AUTOCHDIR ; }
","<S2SV_ModStart> ( bt_terminal ( curwin <S2SV_ModEnd> -> w_buffer )
",vim@vim/ec66c41d84e574baf8009dbc0bd088d2bc5b2421,CVE-2019-20079,https://github.com/vim/vim/commit/ec66c41d84e574baf8009dbc0bd088d2bc5b2421,2019-12-30T01:15Z,<S2SV_StartBug> if ( bt_terminal ( wp -> w_buffer ) ) <S2SV_EndBug>
2175,CWE-119,"void grubfs_free ( GrubFS * gf ) { if ( gf ) { <S2SV_StartBug> if ( gf -> file && gf -> file -> device ) <S2SV_EndBug> <S2SV_StartBug> free ( gf -> file -> device -> disk ) ; <S2SV_EndBug> free ( gf -> file ) ; free ( gf ) ; } }
","<S2SV_ModStart> -> device ) { <S2SV_ModStart> disk ) ; }
",radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z,<S2SV_StartBug> if ( gf -> file && gf -> file -> device ) <S2SV_EndBug> <S2SV_StartBug> free ( gf -> file -> device -> disk ) ; <S2SV_EndBug>
5598,CWE-674,"static krb5_error_code decode_sequence_of ( const uint8_t * asn1 , size_t len , const struct atype_info * elemtype , void * * seq_out , size_t * count_out ) { krb5_error_code ret ; void * seq = NULL , * elem , * newseq ; const uint8_t * contents ; size_t clen , count = 0 ; taginfo t ; * seq_out = NULL ; * count_out = 0 ; while ( len > 0 ) { <S2SV_StartBug> ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; <S2SV_EndBug> if ( ret ) goto error ; if ( ! check_atype_tag ( elemtype , & t ) ) { ret = ASN1_BAD_ID ; goto error ; } newseq = realloc ( seq , ( count + 1 ) * elemtype -> size ) ; if ( newseq == NULL ) { ret = ENOMEM ; goto error ; } seq = newseq ; elem = ( char * ) seq + count * elemtype -> size ; memset ( elem , 0 , elemtype -> size ) ; ret = decode_atype ( & t , contents , clen , elemtype , elem ) ; if ( ret ) goto error ; count ++ ; } * seq_out = seq ; * count_out = count ; return 0 ; error : free_sequence_of ( elemtype , seq , count ) ; free ( seq ) ; return ret ; }
","<S2SV_ModStart> , & len , 0
",krb5@krb5/57415dda6cf04e73ffc3723be518eddfae599bfd,CVE-2020-28196,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,2020-11-06T08:15Z,"<S2SV_StartBug> ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; <S2SV_EndBug>"
3236,CWE-200,"static int raw_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) { err = ip_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }
","<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
",torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69,CVE-2013-7281,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,2014-01-08T16:55Z,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
2179,CWE-415,"struct sock * inet_csk_clone_lock ( const struct sock * sk , const struct request_sock * req , const gfp_t priority ) { struct sock * newsk = sk_clone_lock ( sk , priority ) ; if ( newsk ) { struct inet_connection_sock * newicsk = inet_csk ( newsk ) ; newsk -> sk_state = TCP_SYN_RECV ; newicsk -> icsk_bind_hash = NULL ; inet_sk ( newsk ) -> inet_dport = inet_rsk ( req ) -> ir_rmt_port ; inet_sk ( newsk ) -> inet_num = inet_rsk ( req ) -> ir_num ; inet_sk ( newsk ) -> inet_sport = htons ( inet_rsk ( req ) -> ir_num ) ; newsk -> sk_write_space = sk_stream_write_space ; sock_reset_flag ( newsk , SOCK_RCU_FREE ) ; <S2SV_StartBug> newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; <S2SV_EndBug> atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ; newicsk -> icsk_retransmits = 0 ; newicsk -> icsk_backoff = 0 ; newicsk -> icsk_probes_out = 0 ; memset ( & newicsk -> icsk_accept_queue , 0 , sizeof ( newicsk -> icsk_accept_queue ) ) ; security_inet_csk_clone ( newsk , req ) ; } return newsk ; }
","<S2SV_ModStart> SOCK_RCU_FREE ) ; inet_sk ( newsk ) -> mc_list = NULL ;
",torvalds@linux/657831ffc38e30092a2d5f03d385d710eb88b09a,CVE-2017-8890,https://github.com/torvalds/linux/commit/657831ffc38e30092a2d5f03d385d710eb88b09a,2017-05-10T16:29Z,<S2SV_StartBug> newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; <S2SV_EndBug>
3065,CWE-119,"static void dex_parse_debug_item ( RBinFile * binfile , RBinDexObj * bin , RBinDexClass * c , int MI , int MA , int paddr , int ins_size , int insns_size , char * class_name , int regsz , int debug_info_off ) { struct r_bin_t * rbin = binfile -> rbin ; const ut8 * p4 = r_buf_get_at ( binfile -> buf , debug_info_off , NULL ) ; const ut8 * p4_end = p4 + binfile -> buf -> length - debug_info_off ; ut64 line_start ; ut64 parameters_size ; ut64 param_type_idx ; ut16 argReg = regsz - ins_size ; ut64 source_file_idx = c -> source_file ; RList * params , * debug_positions , * emitted_debug_locals = NULL ; bool keep = true ; <S2SV_StartBug> if ( argReg >= regsz ) { <S2SV_EndBug> } p4 = r_uleb128 ( p4 , p4_end - p4 , & line_start ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & parameters_size ) ; ut32 address = 0 ; ut32 line = line_start ; if ( ! ( debug_positions = r_list_newf ( ( RListFree ) free ) ) ) { return ; } if ( ! ( emitted_debug_locals = r_list_newf ( ( RListFree ) free ) ) ) { r_list_free ( debug_positions ) ; return ; } struct dex_debug_local_t debug_locals [ regsz ] ; memset ( debug_locals , 0 , sizeof ( struct dex_debug_local_t ) * regsz ) ; if ( ! ( MA & 0x0008 ) ) { debug_locals [ argReg ] . name = ""this"" ; debug_locals [ argReg ] . descriptor = r_str_newf ( ""%s;"" , class_name ) ; debug_locals [ argReg ] . startAddress = 0 ; debug_locals [ argReg ] . signature = NULL ; debug_locals [ argReg ] . live = true ; argReg ++ ; } if ( ! ( params = dex_method_signature2 ( bin , MI ) ) ) { r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; return ; } RListIter * iter = r_list_iterator ( params ) ; char * name ; char * type ; int reg ; r_list_foreach ( params , iter , type ) { if ( ( argReg >= regsz ) || ! type || parameters_size <= 0 ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; r_list_free ( emitted_debug_locals ) ; return ; } p4 = r_uleb128 ( p4 , p4_end - p4 , & param_type_idx ) ; param_type_idx -= 1 ; name = getstr ( bin , param_type_idx ) ; reg = argReg ; switch ( type [ 0 ] ) { case 'D' : case 'J' : argReg += 2 ; break ; default : argReg += 1 ; break ; } if ( name ) { debug_locals [ reg ] . name = name ; debug_locals [ reg ] . descriptor = type ; debug_locals [ reg ] . signature = NULL ; debug_locals [ reg ] . startAddress = address ; debug_locals [ reg ] . live = true ; } -- parameters_size ; } ut8 opcode = * ( p4 ++ ) & 0xff ; while ( keep ) { switch ( opcode ) { case 0x0 : keep = false ; break ; case 0x1 : { ut64 addr_diff ; p4 = r_uleb128 ( p4 , p4_end - p4 , & addr_diff ) ; address += addr_diff ; } break ; case 0x2 : { st64 line_diff = r_sleb128 ( & p4 , p4_end ) ; line += line_diff ; } break ; case 0x3 : { ut64 register_num ; ut64 name_idx ; ut64 type_idx ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & name_idx ) ; name_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & type_idx ) ; type_idx -= 1 ; if ( register_num >= regsz ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; return ; } if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . name = getstr ( bin , name_idx ) ; debug_locals [ register_num ] . descriptor = dex_type_descriptor ( bin , type_idx ) ; debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . signature = NULL ; debug_locals [ register_num ] . live = true ; } break ; case 0x4 : { ut64 register_num ; ut64 name_idx ; ut64 type_idx ; ut64 sig_idx ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & name_idx ) ; name_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & type_idx ) ; type_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & sig_idx ) ; sig_idx -= 1 ; if ( register_num >= regsz ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; return ; } if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . name = getstr ( bin , name_idx ) ; debug_locals [ register_num ] . descriptor = dex_type_descriptor ( bin , type_idx ) ; debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . signature = getstr ( bin , sig_idx ) ; debug_locals [ register_num ] . live = true ; } break ; case 0x5 : { ut64 register_num ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . live = false ; } break ; case 0x6 : { ut64 register_num ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; if ( ! debug_locals [ register_num ] . live ) { debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . live = true ; } } break ; case 0x7 : break ; case 0x8 : break ; case 0x9 : { p4 = r_uleb128 ( p4 , p4_end - p4 , & source_file_idx ) ; source_file_idx -- ; } break ; default : { int adjusted_opcode = opcode - 0x0a ; address += ( adjusted_opcode / 15 ) ; line += - 4 + ( adjusted_opcode % 15 ) ; struct dex_debug_position_t * position = malloc ( sizeof ( struct dex_debug_position_t ) ) ; if ( ! position ) { keep = false ; break ; } position -> source_file_idx = source_file_idx ; position -> address = address ; position -> line = line ; r_list_append ( debug_positions , position ) ; } break ; } opcode = * ( p4 ++ ) & 0xff ; } if ( ! binfile -> sdb_addrinfo ) { binfile -> sdb_addrinfo = sdb_new0 ( ) ; } char * fileline ; char offset [ 64 ] ; char * offset_ptr ; RListIter * iter1 ; struct dex_debug_position_t * pos ; r_list_foreach ( debug_positions , iter1 , pos ) { fileline = r_str_newf ( ""%s|%"" PFMT64d , getstr ( bin , pos -> source_file_idx ) , pos -> line ) ; offset_ptr = sdb_itoa ( pos -> address + paddr , offset , 16 ) ; sdb_set ( binfile -> sdb_addrinfo , offset_ptr , fileline , 0 ) ; sdb_set ( binfile -> sdb_addrinfo , fileline , offset_ptr , 0 ) ; } if ( ! dexdump ) { r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; r_list_free ( params ) ; return ; } RListIter * iter2 ; struct dex_debug_position_t * position ; rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>positions<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:\\n"" ) ; r_list_foreach ( debug_positions , iter2 , position ) { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04llx<S2SV_blank>line=%llu\\n"" , position -> address , position -> line ) ; } rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>locals<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:\\n"" ) ; RListIter * iter3 ; struct dex_debug_local_t * local ; r_list_foreach ( emitted_debug_locals , iter3 , local ) { if ( local -> signature ) { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n"" , local -> startAddress , local -> endAddress , local -> reg , local -> name , local -> descriptor , local -> signature ) ; } else { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s\\n"" , local -> startAddress , local -> endAddress , local -> reg , local -> name , local -> descriptor ) ; } } for ( reg = 0 ; reg < regsz ; reg ++ ) { if ( debug_locals [ reg ] . live ) { if ( debug_locals [ reg ] . signature ) { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>"" ""%s\\n"" , debug_locals [ reg ] . startAddress , insns_size , reg , debug_locals [ reg ] . name , debug_locals [ reg ] . descriptor , debug_locals [ reg ] . signature ) ; } else { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s"" ""\\n"" , debug_locals [ reg ] . startAddress , insns_size , reg , debug_locals [ reg ] . name , debug_locals [ reg ] . descriptor ) ; } } } r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; r_list_free ( params ) ; }
","<S2SV_ModStart> if ( argReg > <S2SV_ModEnd> regsz ) { <S2SV_ModStart> regsz ) { return ;
",radare@radare2/ad55822430a03fe075221b543efb434567e9e431,CVE-2017-6319,https://github.com/radare/radare2/commit/ad55822430a03fe075221b543efb434567e9e431,2017-03-02T01:59Z,<S2SV_StartBug> if ( argReg >= regsz ) { <S2SV_EndBug>
2622,CWE-000,"static int http_rxchunk ( struct http * hp ) { char * q ; int l , i ; l = hp -> prxbuf ; do ( void ) http_rxchar ( hp , 1 , 0 ) ; while ( hp -> rxbuf [ hp -> prxbuf - 1 ] != '\\n' ) ; vtc_dump ( hp -> vl , 4 , ""len"" , hp -> rxbuf + l , - 1 ) ; i = strtoul ( hp -> rxbuf + l , & q , 16 ) ; bprintf ( hp -> chunklen , ""%d"" , i ) ; if ( ( q == hp -> rxbuf + l ) || ( * q != '\\0' && ! vct_islws ( * q ) ) ) { vtc_log ( hp -> vl , hp -> fatal , ""chunked<S2SV_blank>fail<S2SV_blank>%02x<S2SV_blank>@<S2SV_blank>%d"" , * q , q - ( hp -> rxbuf + l ) ) ; } assert ( q != hp -> rxbuf + l ) ; assert ( * q == '\\0' || vct_islws ( * q ) ) ; hp -> prxbuf = l ; if ( i > 0 ) { ( void ) http_rxchar ( hp , i , 0 ) ; vtc_dump ( hp -> vl , 4 , ""chunk"" , hp -> rxbuf + l , i ) ; } l = hp -> prxbuf ; ( void ) http_rxchar ( hp , 2 , 0 ) ; <S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l ] ) ) <S2SV_EndBug> vtc_log ( hp -> vl , hp -> fatal , ""Wrong<S2SV_blank>chunk<S2SV_blank>tail[0]<S2SV_blank>=<S2SV_blank>%02x"" , hp -> rxbuf [ l ] & 0xff ) ; <S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l + 1 ] ) ) <S2SV_EndBug> vtc_log ( hp -> vl , hp -> fatal , ""Wrong<S2SV_blank>chunk<S2SV_blank>tail[1]<S2SV_blank>=<S2SV_blank>%02x"" , hp -> rxbuf [ l + 1 ] & 0xff ) ; hp -> prxbuf = l ; hp -> rxbuf [ l ] = '\\0' ; return ( i ) ; }
","<S2SV_ModStart> ! vct_iscrlf ( & <S2SV_ModStart> ! vct_iscrlf ( &
",varnish@Varnish-Cache/85e8468bec9416bd7e16b0d80cb820ecd2b330c3,CVE-2015-8852,https://github.com/varnish/Varnish-Cache/commit/85e8468bec9416bd7e16b0d80cb820ecd2b330c3,2016-04-25T14:59Z,<S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l ] ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l + 1 ] ) ) <S2SV_EndBug>
3780,CWE-787,"static int decode_zbuf ( AVBPrint * bp , const uint8_t * data , const uint8_t * data_end ) { z_stream zstream ; unsigned char * buf ; unsigned buf_size ; int ret ; zstream . zalloc = ff_png_zalloc ; zstream . zfree = ff_png_zfree ; zstream . opaque = NULL ; if ( inflateInit ( & zstream ) != Z_OK ) return AVERROR_EXTERNAL ; zstream . next_in = ( unsigned char * ) data ; zstream . avail_in = data_end - data ; av_bprint_init ( bp , 0 , - 1 ) ; while ( zstream . avail_in > 0 ) { <S2SV_StartBug> av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; <S2SV_EndBug> if ( ! buf_size ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } zstream . next_out = buf ; <S2SV_StartBug> zstream . avail_out = buf_size ; <S2SV_EndBug> ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ; if ( ret != Z_OK && ret != Z_STREAM_END ) { ret = AVERROR_EXTERNAL ; goto fail ; } bp -> len += zstream . next_out - buf ; if ( ret == Z_STREAM_END ) break ; } inflateEnd ( & zstream ) ; bp -> str [ bp -> len ] = 0 ; return 0 ; fail : inflateEnd ( & zstream ) ; av_bprint_finalize ( bp , NULL ) ; return ret ; }
","<S2SV_ModStart> ( bp , 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> ) { ret <S2SV_ModStart> avail_out = buf_size - 1
",FFmpeg@FFmpeg/e371f031b942d73e02c090170975561fabd5c264,CVE-2017-7866,https://github.com/FFmpeg/FFmpeg/commit/e371f031b942d73e02c090170975561fabd5c264,2017-04-14T04:59Z,"<S2SV_StartBug> av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; <S2SV_EndBug> <S2SV_StartBug> zstream . avail_out = buf_size ; <S2SV_EndBug>"
3580,CWE-189,"static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , struct bpf_reg_state * dst_reg , bool off_is_neg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_insn_aux_data * aux = cur_aux ( env ) ; bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; <S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> return 0 ; if ( vstate -> speculative ) goto do_sim ; alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ; <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) ) <S2SV_StartBug> return - EACCES ; <S2SV_EndBug> aux -> alu_state = alu_state ; aux -> alu_limit = alu_limit ; do_sim : if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg ) * dst_reg = tmp ; return ! ret ? - EFAULT : 0 ; }
","<S2SV_ModStart> ; if ( can_skip_alu_sanitation ( env , insn ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( update_alu_sanitation_state ( aux , alu_state , <S2SV_ModEnd> alu_limit ) ) <S2SV_ModStart> return - EACCES <S2SV_ModEnd> ; do_sim :
",torvalds@linux/d3bd7413e0ca40b60cf60d4003246d067cafdeda,CVE-2019-7308,https://github.com/torvalds/linux/commit/d3bd7413e0ca40b60cf60d4003246d067cafdeda,2019-02-01T22:29Z,<S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> <S2SV_StartBug> return - EACCES ; <S2SV_EndBug>
1206,CWE-190,"SQLITE_PRIVATE VList * sqlite3VListAdd ( sqlite3 * db , VList * pIn , const char * zName , int nName , int iVal ) { int nInt ; char * z ; int i ; nInt = nName / 4 + 3 ; assert ( pIn == 0 || pIn [ 0 ] >= 3 ) ; if ( pIn == 0 || pIn [ 1 ] + nInt > pIn [ 0 ] ) { <S2SV_StartBug> int nAlloc = ( pIn ? pIn [ 0 ] * 2 : 10 ) + nInt ; <S2SV_EndBug> VList * pOut = sqlite3DbRealloc ( db , pIn , nAlloc * sizeof ( int ) ) ; if ( pOut == 0 ) return pIn ; if ( pIn == 0 ) pOut [ 1 ] = 2 ; pIn = pOut ; pIn [ 0 ] = nAlloc ; } i = pIn [ 1 ] ; pIn [ i ] = iVal ; pIn [ i + 1 ] = nInt ; z = ( char * ) & pIn [ i + 2 ] ; pIn [ 1 ] = i + nInt ; assert ( pIn [ 1 ] <= pIn [ 0 ] ) ; memcpy ( z , zName , nName ) ; z [ nName ] = 0 ; return pIn ; }
","<S2SV_ModStart> ] ) { sqlite3_int64 <S2SV_ModEnd> nAlloc = ( <S2SV_ModStart> ( pIn ? 2 * ( sqlite3_int64 ) pIn [ 0 ] <S2SV_ModEnd> : 10 )
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z,<S2SV_StartBug> int nAlloc = ( pIn ? pIn [ 0 ] * 2 : 10 ) + nInt ; <S2SV_EndBug>
3985,CWE-20,"static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }
","<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug>
678,CWE-119,"static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { struct common_audit_data sa ; struct apparmor_audit_data aad = { 0 , } ; <S2SV_StartBug> char * command , * args = value ; <S2SV_EndBug> size_t arg_size ; int error ; if ( size == 0 ) <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( args [ size - 1 ] != '\\0' ) { <S2SV_StartBug> if ( size == PAGE_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> args [ size ] = '\\0' ; <S2SV_EndBug> } if ( current != task ) return - EACCES ; args = value ; args = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) return - EINVAL ; args = skip_spaces ( args ) ; if ( ! * args ) return - EINVAL ; arg_size = size - ( args - ( char * ) value ) ; <S2SV_StartBug> if ( strcmp ( name , ""current"" ) == 0 ) { <S2SV_EndBug> if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; <S2SV_StartBug> } else if ( strcmp ( command , ""permhat"" ) == 0 ) { <S2SV_EndBug> error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; <S2SV_StartBug> } else if ( strcmp ( name , ""exec"" ) == 0 ) { <S2SV_EndBug> if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ; else goto fail ; <S2SV_StartBug> } else <S2SV_EndBug> return - EINVAL ; if ( ! error ) error = size ; return error ; fail : sa . type = LSM_AUDIT_DATA_NONE ; sa . aad = & aad ; aad . profile = aa_current_profile ( ) ; aad . op = OP_SETPROCATTR ; aad . info = name ; <S2SV_StartBug> aad . error = - EINVAL ; <S2SV_EndBug> aa_audit_msg ( AUDIT_APPARMOR_DENIED , & sa , NULL ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> }
","<S2SV_ModStart> command , * largs = NULL , * <S2SV_ModStart> return - EINVAL ; if ( current != task ) return - EACCES <S2SV_ModStart> '\\0' ) { largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ; if ( ! args <S2SV_ModEnd> ) return - <S2SV_ModStart> ) return - ENOMEM ; memcpy ( args , value , size ) ; args [ size ] = '\\0' ; } error = - <S2SV_ModStart> EINVAL ; args = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) goto out ; args = skip_spaces ( args ) ; if ( ! * args ) goto out ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; } else <S2SV_ModEnd> if ( strcmp <S2SV_ModStart> ( name , ""exec"" ) == 0 ) { if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC <S2SV_ModEnd> , ! AA_DO_TEST <S2SV_ModStart> AA_DO_TEST ) ; <S2SV_ModEnd> else goto fail <S2SV_ModStart> ; } else <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; if ( ! error ) error = size ; out : kfree ( largs ) <S2SV_ModEnd> ; return error <S2SV_ModStart> . error = error = <S2SV_ModStart> NULL ) ; goto out <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/30a46a4647fd1df9cf52e43bf467f0d9265096ca,CVE-2016-6187,https://github.com/torvalds/linux/commit/30a46a4647fd1df9cf52e43bf467f0d9265096ca,2016-08-06T20:59Z,"<S2SV_StartBug> char * command , * args = value ; <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> if ( size == PAGE_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> args [ size ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( name , ""current"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( command , ""permhat"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( name , ""exec"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> aad . error = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug>"
6202,CWE-190,"static u_int16_t concat_hash_string ( struct ndpi_packet_struct * packet , char * buf , u_int8_t client_hash ) { <S2SV_StartBug> u_int16_t offset = 22 , buf_out_len = 0 ; <S2SV_EndBug> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; u_int32_t len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( buf , ( const char * ) & packet -> payload [ offset ] , buf_out_len = len ) ; buf [ buf_out_len ++ ] = ';' ; offset += len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; <S2SV_StartBug> offset += len ; <S2SV_EndBug> } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; <S2SV_StartBug> offset += len ; <S2SV_EndBug> } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; <S2SV_StartBug> offset += len ; <S2SV_EndBug> } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; <S2SV_StartBug> offset += len ; <S2SV_EndBug> } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; <S2SV_StartBug> offset += len ; <S2SV_EndBug> } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; <S2SV_StartBug> offset += len ; <S2SV_EndBug> } else offset += 4 + len ; # ifdef SSH_DEBUG printf ( ""[SSH]<S2SV_blank>%s\\n"" , buf ) ; # endif return ( buf_out_len ) ; invalid_payload : # ifdef SSH_DEBUG printf ( ""[SSH]<S2SV_blank>Invalid<S2SV_blank>packet<S2SV_blank>payload\\n"" ) ; # endif return ( 0 ) ; }
","<S2SV_ModStart> client_hash ) { u_int32_t <S2SV_ModEnd> offset = 22 <S2SV_ModStart> ] ) ; if ( len > UINT32_MAX - 4 - offset ) goto invalid_payload ; <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; #
",ntop@nDPI/7ce478a58b4dd29a8d1e6f4e9df2f778613d9202,CVE-2020-11939,https://github.com/ntop/nDPI/commit/7ce478a58b4dd29a8d1e6f4e9df2f778613d9202,2020-04-23T15:15Z,"<S2SV_StartBug> u_int16_t offset = 22 , buf_out_len = 0 ; <S2SV_EndBug> <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug>"
271,CWE-269,"void Com_WriteConfig_f ( void ) { char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { <S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , "".cfg"" ) ; Com_Printf ( ""Writing<S2SV_blank>%s.\\n"" , filename ) ; Com_WriteConfigToFile ( filename ) ; }
","<S2SV_ModStart> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n""
",iortcw@iortcw/11a83410153756ae350a82ed41b08d128ff7f998,CVE-2017-6903,https://github.com/iortcw/iortcw/commit/11a83410153756ae350a82ed41b08d128ff7f998,2017-03-14T22:59Z,"<S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug>"
6833,CWE-190,"static int <S2SV_StartBug> _Unpickler_MemoPut ( UnpicklerObject * self , Py_ssize_t idx , PyObject * value ) <S2SV_EndBug> { PyObject * old_item ; if ( idx >= self -> memo_size ) { if ( _Unpickler_ResizeMemoList ( self , idx * 2 ) < 0 ) return - 1 ; assert ( idx < self -> memo_size ) ; } Py_INCREF ( value ) ; old_item = self -> memo [ idx ] ; self -> memo [ idx ] = value ; if ( old_item != NULL ) { Py_DECREF ( old_item ) ; } else { self -> memo_len ++ ; } return 0 ; }
","<S2SV_ModStart> * self , size_t <S2SV_ModEnd> idx , PyObject
",python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z,"<S2SV_StartBug> _Unpickler_MemoPut ( UnpicklerObject * self , Py_ssize_t idx , PyObject * value ) <S2SV_EndBug>"
1120,CWE-119,"static __u8 * pl_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <S2SV_EndBug> rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Petalynx<S2SV_blank>Maxter<S2SV_blank>Remote<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 60 ] = 0xfa ; rdesc [ 40 ] = 0xfa ; } return rdesc ; }
","<S2SV_ModStart> * rsize >= 62 <S2SV_ModEnd> && rdesc [
",torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,CVE-2014-3184,https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,2014-09-28T10:55Z,<S2SV_StartBug> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <S2SV_EndBug>
3214,CWE-119,"bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { applog ( LOG_INFO , ""setup_stratum_socket()<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>failed"" , get_pool_name ( pool ) ) ; sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\"",<S2SV_blank>\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\""]}"" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = ( unsigned char * ) calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin"" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , ""%s<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , get_pool_name ( pool ) , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""%s<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , get_pool_name ( pool ) , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiating<S2SV_blank>stratum<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>%s"" , get_pool_name ( pool ) ) ; if ( sockd ) { applog ( LOG_DEBUG , ""Suspending<S2SV_blank>stratum<S2SV_blank>on<S2SV_blank>%s"" , get_pool_name ( pool ) ) ; suspend_stratum ( pool ) ; } } json_decref ( val ) ; return ret ; }
","<S2SV_ModStart> ; if ( n2size < 1 ) <S2SV_ModEnd> { applog (
",sgminer-dev@sgminer/bac5831b355f916e0696b7bbcccfc51c057b729a,CVE-2014-4502,https://github.com/sgminer-dev/sgminer/commit/bac5831b355f916e0696b7bbcccfc51c057b729a,2014-07-23T14:55Z,<S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug>
1642,CWE-119,"static void build_tree_distribution ( VP9_COMP * cpi , TX_SIZE tx_size , <S2SV_StartBug> vp9_coeff_stats * coef_branch_ct ) { <S2SV_EndBug> <S2SV_StartBug> vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ; <S2SV_EndBug> vp9_coeff_count * coef_counts = cpi -> coef_counts [ tx_size ] ; unsigned int ( * eob_branch_ct ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] = cpi -> common . counts . eob_branch [ tx_size ] ; int i , j , k , l , m ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { vp9_tree_probs_from_distribution ( vp9_coef_tree , coef_branch_ct [ i ] [ j ] [ k ] [ l ] , coef_counts [ i ] [ j ] [ k ] [ l ] ) ; coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 1 ] = eob_branch_ct [ i ] [ j ] [ k ] [ l ] - coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 0 ] ; for ( m = 0 ; m < UNCONSTRAINED_NODES ; ++ m ) coef_probs [ i ] [ j ] [ k ] [ l ] [ m ] = get_binary_prob ( coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ m ] [ 0 ] , coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ m ] [ 1 ] ) ; } } } } }
","<S2SV_ModStart> vp9_coeff_stats * coef_branch_ct , <S2SV_ModEnd> vp9_coeff_probs_model * coef_probs <S2SV_ModStart> vp9_coeff_probs_model * coef_probs ) { vp9_coeff_count * coef_counts <S2SV_ModStart> = cpi -> td . rd_counts . <S2SV_ModEnd> coef_counts [ tx_size
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> vp9_coeff_stats * coef_branch_ct ) { <S2SV_EndBug> <S2SV_StartBug> vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ; <S2SV_EndBug>
1531,CWE-119,"void vp9_foreach_transformed_block ( const MACROBLOCKD * const xd , BLOCK_SIZE bsize , foreach_transformed_block_visitor visit , void * arg ) { int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ ) <S2SV_EndBug> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ; }
","<S2SV_ModStart> < MAX_MB_PLANE ; ++ plane <S2SV_ModEnd> ) vp9_foreach_transformed_block_in_plane (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ ) <S2SV_EndBug>
1701,CWE-119,"<S2SV_StartBug> static void encode_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> int ctx ; PARTITION_TYPE partition ; <S2SV_StartBug> BLOCK_SIZE subsize ; <S2SV_EndBug> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; if ( bsize >= BLOCK_8X8 ) { ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> subsize = * get_sb_partitioning ( x , bsize ) ; <S2SV_EndBug> } else { ctx = 0 ; subsize = BLOCK_4X4 ; } <S2SV_StartBug> partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_EndBug> switch ( partition ) { case PARTITION_NONE : <S2SV_StartBug> if ( output_enabled && bsize >= BLOCK_8X8 ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_NONE ] ++ ; <S2SV_StartBug> encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> break ; case PARTITION_VERT : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; } break ; case PARTITION_HORZ : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_HORZ ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; } break ; case PARTITION_SPLIT : <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_EndBug> if ( output_enabled ) cm -> counts . partition [ ctx ] [ PARTITION_SPLIT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 2 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 3 ; encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize ) ; break ; default : <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> } if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; }
","<S2SV_ModStart> * cpi , ThreadData * td , <S2SV_ModStart> , BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = <S2SV_ModStart> ; BLOCK_SIZE subsize = bsize <S2SV_ModStart> ; subsize = get_subsize ( bsize , pc_tree -> partitioning <S2SV_ModEnd> ) ; } <S2SV_ModStart> [ subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ <S2SV_ModStart> case PARTITION_NONE : <S2SV_ModEnd> encode_b ( cpi <S2SV_ModStart> , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none <S2SV_ModEnd> ) ; break <S2SV_ModStart> case PARTITION_VERT : encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> cm -> mi_cols && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_HORZ : encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> cm -> mi_rows && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_SPLIT : if ( bsize == BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> encode_sb ( cpi <S2SV_ModStart> ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) ; encode_sb ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> ; encode_sb ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; encode_sb ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] ) ; } <S2SV_ModEnd> break ; default <S2SV_ModStart> : assert ( 0 && ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break <S2SV_ModEnd> ; } if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void encode_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE subsize ; <S2SV_EndBug> <S2SV_StartBug> subsize = * get_sb_partitioning ( x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled && bsize >= BLOCK_8X8 ) <S2SV_EndBug> <S2SV_StartBug> encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_EndBug> <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug>"
7734,CWE-000,"<S2SV_StartBug> static struct nfs4_state * nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred ) <S2SV_EndBug> { struct nfs4_exception exception = { } ; struct nfs4_state * res ; int status ; do { <S2SV_StartBug> status = _nfs4_do_open ( dir , path , flags , sattr , cred , & res ) ; <S2SV_EndBug> if ( status == 0 ) break ; if ( status == - NFS4ERR_BAD_SEQID ) { printk ( KERN_WARNING ""NFS:<S2SV_blank>v4<S2SV_blank>server<S2SV_blank>%s<S2SV_blank>"" ""<S2SV_blank>returned<S2SV_blank>a<S2SV_blank>bad<S2SV_blank>sequence-id<S2SV_blank>error!\\n"" , NFS_SERVER ( dir ) -> nfs_client -> cl_hostname ) ; exception . retry = 1 ; continue ; } if ( status == - NFS4ERR_BAD_STATEID ) { exception . retry = 1 ; continue ; } if ( status == - EAGAIN ) { exception . retry = 1 ; continue ; } res = ERR_PTR ( nfs4_handle_exception ( NFS_SERVER ( dir ) , status , & exception ) ) ; } while ( exception . retry ) ; return res ; }
","<S2SV_ModStart> path * path , fmode_t fmode <S2SV_ModStart> dir , path , fmode
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static struct nfs4_state * nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred ) <S2SV_EndBug> <S2SV_StartBug> status = _nfs4_do_open ( dir , path , flags , sattr , cred , & res ) ; <S2SV_EndBug>"
5156,CWE-674,"<S2SV_StartBug> static int renameColumnSelectCb ( Walker * pWalker , Select * p ) { <S2SV_EndBug> renameWalkWith ( pWalker , p ) ; return WRC_Continue ; }
","<S2SV_ModStart> p ) { if ( p -> selFlags & SF_View ) return WRC_Prune ;
",sqlite@sqlite/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,CVE-2019-19645,https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,2019-12-09T16:15Z,"<S2SV_StartBug> static int renameColumnSelectCb ( Walker * pWalker , Select * p ) { <S2SV_EndBug>"
2722,CWE-125,"static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) <S2SV_EndBug> <S2SV_StartBug> iris_info . name ) ; <S2SV_EndBug> iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; <S2SV_StartBug> ( void ) count ; <S2SV_EndBug> image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; } <S2SV_StartBug> if ( EOFBlob ( image ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> image ) ; count = <S2SV_ModEnd> ReadBlob ( image <S2SV_ModStart> iris_info . name ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" <S2SV_ModStart> filler ) ; if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) <S2SV_ModEnd> ; image -> <S2SV_ModStart> } if ( <S2SV_ModEnd> ( image_info ->
",ImageMagick@ImageMagick/8f8959033e4e59418d6506b345829af1f7a71127,CVE-2016-7101,https://github.com/ImageMagick/ImageMagick/commit/8f8959033e4e59418d6506b345829af1f7a71127,2017-01-18T17:59Z,"<S2SV_StartBug> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) <S2SV_EndBug> <S2SV_StartBug> iris_info . name ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) count ; <S2SV_EndBug> <S2SV_StartBug> if ( EOFBlob ( image ) != MagickFalse ) <S2SV_EndBug>"
1413,CWE-119,"static void calc_av_activity ( VP8_COMP * cpi , int64_t activity_sum ) { # if ACT_MEDIAN { unsigned int median ; unsigned int i , j ; unsigned int * sortlist ; unsigned int tmp ; CHECK_MEM_ERROR ( sortlist , vpx_calloc ( sizeof ( unsigned int ) , cpi -> common . MBs ) ) ; <S2SV_StartBug> vpx_memcpy ( sortlist , cpi -> mb_activity_map , <S2SV_EndBug> sizeof ( unsigned int ) * cpi -> common . MBs ) ; for ( i = 1 ; i < cpi -> common . MBs ; i ++ ) { for ( j = i ; j > 0 ; j -- ) { if ( sortlist [ j ] < sortlist [ j - 1 ] ) { tmp = sortlist [ j - 1 ] ; sortlist [ j - 1 ] = sortlist [ j ] ; sortlist [ j ] = tmp ; } else break ; } } median = ( 1 + sortlist [ cpi -> common . MBs >> 1 ] + sortlist [ ( cpi -> common . MBs >> 1 ) + 1 ] ) >> 1 ; cpi -> activity_avg = median ; vpx_free ( sortlist ) ; } # else cpi -> activity_avg = ( unsigned int ) ( activity_sum / cpi -> common . MBs ) ; # endif if ( cpi -> activity_avg < VP8_ACTIVITY_AVG_MIN ) cpi -> activity_avg = VP8_ACTIVITY_AVG_MIN ; if ( ALT_ACT_MEASURE ) cpi -> activity_avg = 100000 ; }
","<S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( sortlist ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( sortlist , cpi -> mb_activity_map , <S2SV_EndBug>"
2386,CWE-000,"static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct ext4_ext_path * path , int flags , unsigned int allocated , struct buffer_head * bh_result , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = EXT4_I ( inode ) -> cur_aio_dio ; ext_debug ( ""ext4_ext_handle_uninitialized_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>%d,<S2SV_blank>allocated<S2SV_blank>%u"" , inode -> i_ino , ( unsigned long long ) iblock , max_blocks , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ; if ( io ) io -> flag = EXT4_IO_UNWRITTEN ; else <S2SV_StartBug> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_EndBug> goto out ; } <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_CONVERT ) { <S2SV_EndBug> ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { set_buffer_unwritten ( bh_result ) ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , path , iblock , max_blocks ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; set_buffer_new ( bh_result ) ; if ( allocated > max_blocks ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + max_blocks , allocated - max_blocks ) ; allocated = max_blocks ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ext4_da_update_reserve_space ( inode , allocated , 0 ) ; map_out : set_buffer_mapped ( bh_result ) ; out1 : if ( allocated > max_blocks ) allocated = max_blocks ; ext4_ext_show_leaf ( inode , path ) ; bh_result -> b_bdev = inode -> i_sb -> s_bdev ; bh_result -> b_blocknr = newblock ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }
","<S2SV_ModStart> ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { ret = <S2SV_ModStart> inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> ) { ret
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,"<S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> <S2SV_StartBug> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_CONVERT ) { <S2SV_EndBug>"
2525,CWE-59,"<S2SV_StartBug> static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs ) <S2SV_EndBug> { FILE * fp = fopen ( dest_filename , ""w"" ) ; if ( ! fp ) return false ; unsigned fd = 0 ; while ( fd <= 99999 ) { sprintf ( source_filename + source_base_ofs , ""fd/%u"" , fd ) ; char * name = malloc_readlink ( source_filename ) ; if ( ! name ) break ; fprintf ( fp , ""%u:%s\\n"" , fd , name ) ; free ( name ) ; sprintf ( source_filename + source_base_ofs , ""fdinfo/%u"" , fd ) ; fd ++ ; FILE * in = fopen ( source_filename , ""r"" ) ; if ( ! in ) continue ; char buf [ 128 ] ; while ( fgets ( buf , sizeof ( buf ) - 1 , in ) ) { char * eol = strchrnul ( buf , '\\n' ) ; eol [ 0 ] = '\\n' ; eol [ 1 ] = '\\0' ; fputs ( buf , fp ) ; } fclose ( in ) ; } <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> return true ; }
","<S2SV_ModStart> , int source_base_ofs , uid_t uid , gid_t gid <S2SV_ModStart> ) ; } const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( ""Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu"" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; }
",abrt@abrt/80408e9e24a1c10f85fd969e1853e0f192157f92,CVE-2015-3315,https://github.com/abrt/abrt/commit/80408e9e24a1c10f85fd969e1853e0f192157f92,2017-06-26T15:29Z,"<S2SV_StartBug> static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs ) <S2SV_EndBug> <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug>"
101,CWE-119,"unsigned int X509v3_addr_get_afi ( const IPAddressFamily * f ) { <S2SV_StartBug> return ( ( f != NULL && <S2SV_EndBug> <S2SV_StartBug> f -> addressFamily != NULL && f -> addressFamily -> data != NULL ) <S2SV_EndBug> <S2SV_StartBug> ? ( ( f -> addressFamily -> data [ 0 ] << 8 ) | ( f -> addressFamily -> data [ 1 ] ) ) <S2SV_EndBug> : 0 ) ; }
","<S2SV_ModStart> f ) { if ( f == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> f -> addressFamily == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> addressFamily -> data == NULL || f -> addressFamily -> length < 2 ) return 0 ; return <S2SV_ModEnd> ( f -> <S2SV_ModStart> 8 ) | <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ; } <S2SV_null>
",openssl@openssl/068b963bb7afc57f5bdd723de0dd15e7795d5822,CVE-2017-3735,https://github.com/openssl/openssl/commit/068b963bb7afc57f5bdd723de0dd15e7795d5822,2017-08-28T19:29Z,<S2SV_StartBug> return ( ( f != NULL && <S2SV_EndBug> <S2SV_StartBug> f -> addressFamily != NULL && f -> addressFamily -> data != NULL ) <S2SV_EndBug> <S2SV_StartBug> ? ( ( f -> addressFamily -> data [ 0 ] << 8 ) | ( f -> addressFamily -> data [ 1 ] ) ) <S2SV_EndBug>
1843,CWE-119,"static int64_t encode_inter_mb_segment ( VP9_COMP * cpi , MACROBLOCK * x , int64_t best_yrd , int i , int * labelyrate , int64_t * distortion , int64_t * sse , ENTROPY_CONTEXT * ta , ENTROPY_CONTEXT * tl , int mi_row , int mi_col ) { int k ; MACROBLOCKD * xd = & x -> e_mbd ; struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ; struct macroblock_plane * const p = & x -> plane [ 0 ] ; MODE_INFO * const mi = xd -> mi [ 0 ] ; const BLOCK_SIZE plane_bsize = get_plane_block_size ( mi -> mbmi . sb_type , pd ) ; const int width = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ; const int height = 4 * num_4x4_blocks_high_lookup [ plane_bsize ] ; int idx , idy ; <S2SV_StartBug> const uint8_t * const src = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> p -> src . stride ) ] ; <S2SV_StartBug> uint8_t * const dst = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> pd -> dst . stride ) ] ; int64_t thisdistortion = 0 , thissse = 0 ; int thisrate = 0 , ref ; const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; const int is_compound = has_second_ref ( & mi -> mbmi ) ; <S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ; <S2SV_EndBug> for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) { <S2SV_StartBug> const uint8_t * pre = & pd -> pre [ ref ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> pd -> pre [ ref ] . stride ) ] ; <S2SV_StartBug> vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , <S2SV_EndBug> dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , <S2SV_StartBug> & xd -> block_refs [ ref ] -> sf , width , height , ref , <S2SV_EndBug> kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , <S2SV_StartBug> mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; <S2SV_EndBug> } <S2SV_StartBug> vp9_subtract_block ( height , width , <S2SV_EndBug> raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , <S2SV_StartBug> dst , pd -> dst . stride ) ; <S2SV_EndBug> k = i ; for ( idy = 0 ; idy < height / 4 ; ++ idy ) { for ( idx = 0 ; idx < width / 4 ; ++ idx ) { int64_t ssz , rd , rd1 , rd2 ; <S2SV_StartBug> int16_t * coeff ; <S2SV_EndBug> k += ( idy * 2 + idx ) ; coeff = BLOCK_OFFSET ( p -> coeff , k ) ; <S2SV_StartBug> x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , <S2SV_EndBug> coeff , 8 ) ; <S2SV_StartBug> vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ; <S2SV_EndBug> thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ; <S2SV_StartBug> thissse += ssz ; <S2SV_EndBug> thisrate += cost_coeffs ( x , 0 , k , ta + ( k & 1 ) , tl + ( k >> 1 ) , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; rd1 = RDCOST ( x -> rdmult , x -> rddiv , thisrate , thisdistortion >> 2 ) ; rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , thissse >> 2 ) ; rd = MIN ( rd1 , rd2 ) ; if ( rd >= best_yrd ) return INT64_MAX ; } } * distortion = thisdistortion >> 2 ; * labelyrate = thisrate ; * sse = thissse >> 2 ; return RDCOST ( x -> rdmult , x -> rddiv , * labelyrate , * distortion ) ; }
","<S2SV_ModStart> . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> * kernel = vp9_filter_kernels [ <S2SV_ModEnd> mi -> mbmi <S2SV_ModStart> mbmi . interp_filter ] <S2SV_ModEnd> ; for ( <S2SV_ModStart> . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor <S2SV_ModEnd> ( pre , <S2SV_ModStart> , height , ref , <S2SV_ModEnd> kernel , MV_PRECISION_Q3 <S2SV_ModStart> / 2 ) , xd -> bd <S2SV_ModStart> ) ; } else { vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; } # else vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; # endif } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( height , width , vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> . stride , dst , pd -> dst . stride , xd -> bd ) ; } else { vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; } # else vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; # endif <S2SV_ModEnd> k = i <S2SV_ModStart> , rd2 ; tran_low_t <S2SV_ModEnd> * coeff ; <S2SV_ModStart> -> fwd_txm4x4 ( vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> iscan ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { thisdistortion += vp9_highbd_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz , xd -> bd ) ; } else { <S2SV_ModStart> ssz ) ; } # else thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ; # endif
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> const uint8_t * const src = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> <S2SV_StartBug> uint8_t * const dst = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> <S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ; <S2SV_EndBug> <S2SV_StartBug> const uint8_t * pre = & pd -> pre [ ref ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , <S2SV_EndBug> <S2SV_StartBug> & xd -> block_refs [ ref ] -> sf , width , height , ref , <S2SV_EndBug> <S2SV_StartBug> mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_subtract_block ( height , width , <S2SV_EndBug> <S2SV_StartBug> dst , pd -> dst . stride ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * coeff ; <S2SV_EndBug> <S2SV_StartBug> x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , <S2SV_EndBug> <S2SV_StartBug> vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ; <S2SV_EndBug> <S2SV_StartBug> thissse += ssz ; <S2SV_EndBug>"
5506,CWE-190,"static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MagickPathExtent ] , text [ MagickPathExtent ] ; Image * image ; long x_offset , y_offset ; PixelInfo pixel ; MagickBooleanType status ; QuantumAny range ; register ssize_t i , x ; register Quantum * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = width ; image -> rows = height ; <S2SV_StartBug> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; <S2SV_EndBug> image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> alpha_trait = UndefinedPixelTrait ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> alpha_trait = BlendPixelTrait ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , ( ColorspaceType ) type , exception ) ; GetPixelInfo ( image , & pixel ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double alpha , black , blue , green , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; black = 0.0 ; alpha = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & alpha ) ; green = red ; blue = red ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black ) ; break ; } default : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; black *= 0.01 * range ; alpha *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . black = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( black + 0.5 ) , range ) ; pixel . alpha = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( alpha + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) continue ; SetPixelViaPixelInfo ( image , & pixel , q ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> depth ++ ) if ( depth >= 64 ) break
",ImageMagick@ImageMagick/50f54462076648ac2e36c3f58f4dadd4babbf1c9,CVE-2017-14173,https://github.com/ImageMagick/ImageMagick/commit/50f54462076648ac2e36c3f58f4dadd4babbf1c9,2017-09-07T06:29Z,<S2SV_StartBug> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; <S2SV_EndBug>
2737,CWE-399,"static void hugetlbfs_put_super ( struct super_block * sb ) { struct hugetlbfs_sb_info * sbi = HUGETLBFS_SB ( sb ) ; if ( sbi ) { sb -> s_fs_info = NULL ; <S2SV_StartBug> kfree ( sbi ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> = NULL ; if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ;
",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z,<S2SV_StartBug> kfree ( sbi ) ; <S2SV_EndBug>
211,CWE-787,"void pdf_load_pages_kids ( FILE * fp , pdf_t * pdf ) { int i , id , dummy ; char * buf , * c ; long start , sz ; start = ftell ( fp ) ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . version && ( pdf -> xrefs [ i ] . end != 0 ) ) { fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; while ( SAFE_F ( fp , ( fgetc ( fp ) != 't' ) ) ) ; sz = pdf -> xrefs [ i ] . end - ftell ( fp ) ; <S2SV_StartBug> buf = malloc ( sz + 1 ) ; <S2SV_EndBug> SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>/Root.\\n"" ) ; buf [ sz ] = '\\0' ; if ( ! ( c = strstr ( buf , ""/Root"" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( ""/Root"" ) + 1 ) ; free ( buf ) ; buf = get_object ( fp , id , & pdf -> xrefs [ i ] , NULL , & dummy ) ; if ( ! buf || ! ( c = strstr ( buf , ""/Pages"" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( ""/Pages"" ) + 1 ) ; load_kids ( fp , id , & pdf -> xrefs [ i ] ) ; free ( buf ) ; } } fseek ( fp , start , SEEK_SET ) ; }
","<S2SV_ModStart> ; buf = safe_calloc <S2SV_ModEnd> ( sz +
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,<S2SV_StartBug> buf = malloc ( sz + 1 ) ; <S2SV_EndBug>
2480,CWE-120,"void mwifiex_set_uap_rates ( struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { struct ieee_types_header * rate_ie ; int var_offset = offsetof ( struct ieee80211_mgmt , u . beacon . variable ) ; const u8 * var_pos = params -> beacon . head + var_offset ; int len = params -> beacon . head_len - var_offset ; u8 rate_len = 0 ; rate_ie = ( void * ) cfg80211_find_ie ( WLAN_EID_SUPP_RATES , var_pos , len ) ; if ( rate_ie ) { <S2SV_StartBug> memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> rate_len = rate_ie -> len ; } rate_ie = ( void * ) cfg80211_find_ie ( WLAN_EID_EXT_SUPP_RATES , params -> beacon . tail , params -> beacon . tail_len ) ; <S2SV_StartBug> if ( rate_ie ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> return ; }
","<S2SV_ModStart> rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ; <S2SV_ModStart> ( rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ; <S2SV_ModStart> len ) ; }
",torvalds@linux/7caac62ed598a196d6ddf8d9c121e12e082cac3a,CVE-2019-14814,https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a,2019-09-20T19:15Z,"<S2SV_StartBug> memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rate_ie ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug>"
1914,CWE-119,"<S2SV_StartBug> void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> fadst16_8col ( in0 ) ; fadst16_8col ( in1 ) ; array_transpose_16x16 ( in0 , in1 ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug>"
1140,CWE-369,"int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; <S2SV_StartBug> uint16_t numChannels , chansSpecified , chanMask = 0 ; <S2SV_EndBug> uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; <S2SV_StartBug> if ( numChannels < chansSpecified || numChannels < 1 ) { <S2SV_EndBug> error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) { <S2SV_StartBug> total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; <S2SV_EndBug> break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> ; uint16_t numChannels = 0 <S2SV_ModStart> numChannels < 1 || numChannels > 256 <S2SV_ModStart> ) ) { if ( ! config -> num_channels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
",dbry@WavPack/4c0faba32fddbd0745cbfaf1e1aeb3da5d35b9fc,CVE-2019-1010315,https://github.com/dbry/WavPack/commit/4c0faba32fddbd0745cbfaf1e1aeb3da5d35b9fc,2019-07-11T20:15Z,"<S2SV_StartBug> uint16_t numChannels , chansSpecified , chanMask = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( numChannels < chansSpecified || numChannels < 1 ) { <S2SV_EndBug> <S2SV_StartBug> total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; <S2SV_EndBug>"
1442,CWE-119,"int vp8_hex_search ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvsadcost [ 2 ] , int * mvcost [ 2 ] , int_mv * center_mv ) { MV hex [ 6 ] = { { - 1 , - 2 } , { 1 , - 2 } , { 2 , 0 } , { 1 , 2 } , { - 1 , 2 } , { - 2 , 0 } } ; MV neighbors [ 4 ] = { { 0 , - 1 } , { - 1 , 0 } , { 1 , 0 } , { 0 , 1 } } ; int i , j ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int br , bc ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; unsigned char * base_offset ; unsigned char * this_offset ; int k = - 1 ; int all_in ; int best_site = - 1 ; int hex_range = 127 ; int dia_range = 8 ; int_mv fcenter_mv ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; <S2SV_StartBug> vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; <S2SV_EndBug> br = ref_mv -> as_mv . row ; bc = ref_mv -> as_mv . col ; base_offset = ( unsigned char * ) ( base_pre + d -> offset ) ; this_offset = base_offset + ( br * ( pre_stride ) ) + bc ; this_mv . as_mv . row = br ; this_mv . as_mv . col = bc ; <S2SV_StartBug> bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; # if CONFIG_MULTI_RES_ENCODING if ( search_param >= 6 ) goto cal_neighbors ; else if ( search_param >= 5 ) hex_range = 4 ; else if ( search_param >= 4 ) hex_range = 6 ; else if ( search_param >= 3 ) hex_range = 15 ; else if ( search_param >= 2 ) hex_range = 31 ; else if ( search_param >= 1 ) hex_range = 63 ; dia_range = 8 ; <S2SV_StartBug> # endif <S2SV_EndBug> CHECK_BOUNDS ( 2 ) if ( all_in ) { for ( i = 0 ; i < 6 ; i ++ ) { this_mv . as_mv . row = br + hex [ i ] . row ; this_mv . as_mv . col = bc + hex [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 6 ; i ++ ) { this_mv . as_mv . row = br + hex [ i ] . row ; this_mv . as_mv . col = bc + hex [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) goto cal_neighbors ; else { br += hex [ best_site ] . row ; bc += hex [ best_site ] . col ; k = best_site ; } for ( j = 1 ; j < hex_range ; j ++ ) { best_site = - 1 ; CHECK_BOUNDS ( 2 ) if ( all_in ) { for ( i = 0 ; i < 3 ; i ++ ) { this_mv . as_mv . row = br + next_chkpts [ k ] [ i ] . row ; this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 3 ; i ++ ) { this_mv . as_mv . row = br + next_chkpts [ k ] [ i ] . row ; this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) break ; else { br += next_chkpts [ k ] [ best_site ] . row ; bc += next_chkpts [ k ] [ best_site ] . col ; k += 5 + best_site ; if ( k >= 12 ) k -= 12 ; else if ( k >= 6 ) k -= 6 ; } } cal_neighbors : for ( j = 0 ; j < dia_range ; j ++ ) { best_site = - 1 ; CHECK_BOUNDS ( 1 ) if ( all_in ) { for ( i = 0 ; i < 4 ; i ++ ) { this_mv . as_mv . row = br + neighbors [ i ] . row ; this_mv . as_mv . col = bc + neighbors [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 4 ; i ++ ) { this_mv . as_mv . row = br + neighbors [ i ] . row ; this_mv . as_mv . col = bc + neighbors [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) break ; else { br += neighbors [ best_site ] . row ; bc += neighbors [ best_site ] . col ; } } best_mv -> as_mv . row = br ; best_mv -> as_mv . col = bc ; return bestsad ; }
","<S2SV_ModStart> >> 3 ; ( void ) mvcost ; <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> 8 ; # else ( void ) search_param ; # <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; <S2SV_EndBug> <S2SV_StartBug> bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug>"
4075,CWE-787,"char * enl_ipc_get ( const char * msg_data ) { static char * message = NULL ; <S2SV_StartBug> static unsigned short len = 0 ; <S2SV_EndBug> char buff [ 13 ] , * ret_msg = NULL ; register unsigned char i ; unsigned char blen ; if ( msg_data == IPC_TIMEOUT ) { return ( IPC_TIMEOUT ) ; } for ( i = 0 ; i < 12 ; i ++ ) { buff [ i ] = msg_data [ i ] ; } buff [ 12 ] = 0 ; blen = strlen ( buff ) ; if ( message != NULL ) { len += blen ; message = ( char * ) erealloc ( message , len + 1 ) ; strcat ( message , buff ) ; } else { len = blen ; message = ( char * ) emalloc ( len + 1 ) ; strcpy ( message , buff ) ; } if ( blen < 12 ) { ret_msg = message ; message = NULL ; D ( ( ""Received<S2SV_blank>complete<S2SV_blank>reply:<S2SV_blank><S2SV_blank>\\""%s\\""\\n"" , ret_msg ) ) ; } return ( ret_msg ) ; }
","<S2SV_ModStart> NULL ; static size_t <S2SV_ModEnd> len = 0
",derf@feh/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d,CVE-2017-7875,https://github.com/derf/feh/commit/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d,2017-04-14T18:59Z,<S2SV_StartBug> static unsigned short len = 0 ; <S2SV_EndBug>
4145,CWE-254,"IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; impeg2d_bit_stream_get ( ps_stream , 10 ) ; ps_dec -> e_pic_type = ( e_pic_type_t ) impeg2d_bit_stream_get ( ps_stream , 3 ) ; if ( ( ps_dec -> e_pic_type < I_PIC ) || ( ps_dec -> e_pic_type > D_PIC ) ) { impeg2d_next_code ( ps_dec , PICTURE_START_CODE ) ; return IMPEG2D_INVALID_PIC_TYPE ; } impeg2d_bit_stream_get ( ps_stream , 16 ) ; if ( ps_dec -> e_pic_type == P_PIC || ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_forw_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_back_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_back_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> u2_is_mpeg2 == 0 ) { ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ; } <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <S2SV_EndBug> { impeg2d_bit_stream_get ( ps_stream , 9 ) ; } impeg2d_bit_stream_get_bit ( ps_stream ) ; impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
","<S2SV_ModStart> ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset
",external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3,CVE-2016-0824,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,2016-03-12T21:59Z,"<S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <S2SV_EndBug>"
6028,CWE-401,"int ath9k_wmi_cmd ( struct wmi * wmi , enum wmi_cmd_id cmd_id , u8 * cmd_buf , u32 cmd_len , u8 * rsp_buf , u32 rsp_len , u32 timeout ) { struct ath_hw * ah = wmi -> drv_priv -> ah ; struct ath_common * common = ath9k_hw_common ( ah ) ; u16 headroom = sizeof ( struct htc_frame_hdr ) + sizeof ( struct wmi_cmd_hdr ) ; struct sk_buff * skb ; unsigned long time_left ; int ret = 0 ; if ( ah -> ah_flags & AH_UNPLUGGED ) return 0 ; skb = alloc_skb ( headroom + cmd_len , GFP_ATOMIC ) ; if ( ! skb ) return - ENOMEM ; skb_reserve ( skb , headroom ) ; if ( cmd_len != 0 && cmd_buf != NULL ) { skb_put_data ( skb , cmd_buf , cmd_len ) ; } mutex_lock ( & wmi -> op_mutex ) ; if ( unlikely ( wmi -> stopped ) ) { ret = - EPROTO ; goto out ; } wmi -> cmd_rsp_buf = rsp_buf ; wmi -> cmd_rsp_len = rsp_len ; ret = ath9k_wmi_cmd_issue ( wmi , skb , cmd_id , cmd_len ) ; if ( ret ) goto out ; time_left = wait_for_completion_timeout ( & wmi -> cmd_wait , timeout ) ; if ( ! time_left ) { ath_dbg ( common , WMI , ""Timeout<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>WMI<S2SV_blank>command:<S2SV_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ; <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> } mutex_unlock ( & wmi -> op_mutex ) ; return 0 ; out : ath_dbg ( common , WMI , ""WMI<S2SV_blank>failure<S2SV_blank>for:<S2SV_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ; kfree_skb ( skb ) ; return ret ; }
","<S2SV_ModStart> op_mutex ) ; kfree_skb ( skb ) ;
",torvalds@linux/728c1e2a05e4b5fc52fab3421dce772a806612a2,CVE-2019-19074,https://github.com/torvalds/linux/commit/728c1e2a05e4b5fc52fab3421dce772a806612a2,2019-11-18T06:15Z,<S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug>
5365,CWE-125,"void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; return ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; return ; } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , tcpport_string ( ndo , sport ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } else { if ( ip -> ip_p == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ipaddr_string ( ndo , & ip -> ip_src ) , tcpport_string ( ndo , sport ) , ipaddr_string ( ndo , & ip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } ND_TCHECK ( * pgm ) ; ND_PRINT ( ( ndo , ""PGM,<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_PRINT ( ( ndo , ""<S2SV_blank>0x%02x%02x%02x%02x%02x%02x<S2SV_blank>"" , pgm -> pgm_gsid [ 0 ] , pgm -> pgm_gsid [ 1 ] , pgm -> pgm_gsid [ 2 ] , pgm -> pgm_gsid [ 3 ] , pgm -> pgm_gsid [ 4 ] , pgm -> pgm_gsid [ 5 ] ) ) ; switch ( pgm -> pgm_type ) { case PGM_SPM : { const struct pgm_spm * spm ; spm = ( const struct pgm_spm * ) ( pgm + 1 ) ; ND_TCHECK ( * spm ) ; bp = ( const u_char * ) ( spm + 1 ) ; switch ( EXTRACT_16BITS ( & spm -> pgms_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""SPM<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>lead<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s"" , EXTRACT_32BITS ( & spm -> pgms_seq ) , EXTRACT_32BITS ( & spm -> pgms_trailseq ) , EXTRACT_32BITS ( & spm -> pgms_leadseq ) , nla_buf ) ) ; break ; } case PGM_POLL : { const struct pgm_poll * poll_msg ; poll_msg = ( const struct pgm_poll * ) ( pgm + 1 ) ; ND_TCHECK ( * poll_msg ) ; ND_PRINT ( ( ndo , ""POLL<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u"" , EXTRACT_32BITS ( & poll_msg -> pgmp_seq ) , EXTRACT_16BITS ( & poll_msg -> pgmp_round ) ) ) ; bp = ( const u_char * ) ( poll_msg + 1 ) ; break ; } case PGM_POLR : { const struct pgm_polr * polr ; uint32_t ivl , rnd , mask ; polr = ( const struct pgm_polr * ) ( pgm + 1 ) ; ND_TCHECK ( * polr ) ; bp = ( const u_char * ) ( polr + 1 ) ; switch ( EXTRACT_16BITS ( & polr -> pgmp_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; ivl = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; rnd = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; mask = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""POLR<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>rnd<S2SV_blank>0x%08x<S2SV_blank>"" ""mask<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & polr -> pgmp_seq ) , EXTRACT_16BITS ( & polr -> pgmp_round ) , nla_buf , ivl , rnd , mask ) ) ; break ; } case PGM_ODATA : { const struct pgm_data * odata ; odata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * odata ) ; ND_PRINT ( ( ndo , ""ODATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & odata -> pgmd_trailseq ) , EXTRACT_32BITS ( & odata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( odata + 1 ) ; break ; } case PGM_RDATA : { const struct pgm_data * rdata ; rdata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * rdata ) ; ND_PRINT ( ( ndo , ""RDATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & rdata -> pgmd_trailseq ) , EXTRACT_32BITS ( & rdata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( rdata + 1 ) ; break ; } case PGM_NAK : case PGM_NULLNAK : case PGM_NCF : { const struct pgm_nak * nak ; char source_buf [ INET6_ADDRSTRLEN ] , group_buf [ INET6_ADDRSTRLEN ] ; nak = ( const struct pgm_nak * ) ( pgm + 1 ) ; ND_TCHECK ( * nak ) ; bp = ( const u_char * ) ( nak + 1 ) ; switch ( EXTRACT_16BITS ( & nak -> pgmn_source_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( EXTRACT_16BITS ( bp ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } switch ( pgm -> pgm_type ) { case PGM_NAK : ND_PRINT ( ( ndo , ""NAK<S2SV_blank>"" ) ) ; break ; case PGM_NULLNAK : ND_PRINT ( ( ndo , ""NNAK<S2SV_blank>"" ) ) ; break ; case PGM_NCF : ND_PRINT ( ( ndo , ""NCF<S2SV_blank>"" ) ) ; break ; default : break ; } ND_PRINT ( ( ndo , ""(%s<S2SV_blank>-><S2SV_blank>%s),<S2SV_blank>seq<S2SV_blank>%u"" , source_buf , group_buf , EXTRACT_32BITS ( & nak -> pgmn_seq ) ) ) ; break ; } case PGM_ACK : { const struct pgm_ack * ack ; ack = ( const struct pgm_ack * ) ( pgm + 1 ) ; ND_TCHECK ( * ack ) ; ND_PRINT ( ( ndo , ""ACK<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & ack -> pgma_rx_max_seq ) ) ) ; bp = ( const u_char * ) ( ack + 1 ) ; break ; } case PGM_SPMR : ND_PRINT ( ( ndo , ""SPMR"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""UNKNOWN<S2SV_blank>type<S2SV_blank>0x%02x"" , pgm -> pgm_type ) ) ; break ; } if ( pgm -> pgm_options & PGM_OPT_BIT_PRESENT ) { if ( ! ND_TTEST2 ( * bp , PGM_MIN_OPT_LEN ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; if ( ( opt_type & PGM_OPT_MASK ) != PGM_OPT_LENGTH ) { ND_PRINT ( ( ndo , ""[First<S2SV_blank>option<S2SV_blank>bad,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>PGM_OPT_LENGTH,<S2SV_blank>is<S2SV_blank>%u]"" , opt_type & PGM_OPT_MASK ) ) ; return ; } opt_len = * bp ++ ; if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } opts_len = EXTRACT_16BITS ( bp ) ; if ( opts_len < 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>4]"" , opts_len ) ) ; return ; } bp += sizeof ( uint16_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>%d"" , opts_len ) ) ; opts_len -= 4 ; while ( opts_len ) { if ( opts_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; opt_len = * bp ++ ; if ( opt_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_MIN_OPT_LEN ) ) ; break ; } if ( opts_len < opt_len ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , opt_len - 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } switch ( opt_type & PGM_OPT_MASK ) { case PGM_OPT_LENGTH : <S2SV_StartBug> if ( opt_len != 4 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; <S2SV_EndBug> bp += sizeof ( uint16_t ) ; opts_len -= 4 ; <S2SV_StartBug> break ; <S2SV_EndBug> case PGM_OPT_FRAGMENT : <S2SV_StartBug> if ( opt_len != 16 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>16]"" , opt_len ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; <S2SV_StartBug> bp += sizeof ( uint32_t ) ; <S2SV_EndBug> offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u"" , seq , offset , len ) ) ; <S2SV_StartBug> opts_len -= 16 ; <S2SV_EndBug> break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>NAK<S2SV_blank>LIST"" ) ) ; while ( opt_len ) { <S2SV_StartBug> if ( opt_len < sizeof ( uint32_t ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ; return ; } <S2SV_StartBug> ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; <S2SV_EndBug> bp += sizeof ( uint32_t ) ; opt_len -= sizeof ( uint32_t ) ; <S2SV_StartBug> opts_len -= sizeof ( uint32_t ) ; <S2SV_EndBug> } break ; case PGM_OPT_JOIN : <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]"" , opt_len ) ) ; return ; } bp += 2 ; <S2SV_StartBug> seq = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> <S2SV_StartBug> bp += sizeof ( uint32_t ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq ) ) ; <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> break ; case PGM_OPT_NAK_BO_IVL : <S2SV_StartBug> if ( opt_len != 12 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]"" , opt_len ) ) ; return ; } <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u"" , offset , seq ) ) ; <S2SV_StartBug> opts_len -= 12 ; <S2SV_EndBug> break ; case PGM_OPT_NAK_BO_RNG : <S2SV_StartBug> if ( opt_len != 12 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]"" , opt_len ) ) ; return ; } <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u"" , offset , seq ) ) ; <S2SV_StartBug> opts_len -= 12 ; <S2SV_EndBug> break ; case PGM_OPT_REDIRECT : bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : <S2SV_StartBug> if ( opt_len != 4 + sizeof ( struct in_addr ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; <S2SV_StartBug> opts_len -= 4 + sizeof ( struct in_addr ) ; <S2SV_EndBug> break ; case AFNUM_INET6 : <S2SV_StartBug> if ( opt_len != 4 + sizeof ( struct in6_addr ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; <S2SV_StartBug> opts_len -= 4 + sizeof ( struct in6_addr ) ; <S2SV_EndBug> break ; default : goto trunc ; break ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; <S2SV_EndBug> break ; <S2SV_StartBug> case PGM_OPT_PARITY_PRM : <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]"" , opt_len ) ) ; return ; } <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) ) ; <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> break ; case PGM_OPT_PARITY_GRP : <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]"" , opt_len ) ) ; return ; } <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u"" , seq ) ) ; <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> break ; case PGM_OPT_CURR_TGSIZE : if ( opt_len != 8 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]"" , opt_len ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u"" , len ) ) ; opts_len -= 8 ; break ; case PGM_OPT_NBR_UNREACH : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NBR_UNREACH"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""<S2SV_blank>PATH_NLA<S2SV_blank>[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>SYN"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_FIN : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FIN"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_RST : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>RST"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""<S2SV_blank>CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>CRQST"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_PGMCC_DATA : bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; case PGM_OPT_PGMCC_FEEDBACK : bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>FEEDBACK<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>OPT_%02X<S2SV_blank>[%d]<S2SV_blank>"" , opt_type , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; } if ( opt_type & PGM_OPT_END ) break ; } } ND_PRINT ( ( ndo , ""<S2SV_blank>[%u]"" , length ) ) ; if ( ndo -> ndo_packettype == PT_PGM_ZMTP1 && ( pgm -> pgm_type == PGM_ODATA || pgm -> pgm_type == PGM_RDATA ) ) zmtp1_print_datagram ( ndo , bp , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|pgm]"" ) ) ; if ( ch != '\\0' ) ND_PRINT ( ( ndo , "">"" ) ) ; }
","<S2SV_ModStart> case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) <S2SV_ModStart> ( opt_len != PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FRAGMENT_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u"" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NAK<S2SV_blank>LIST"" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4 <S2SV_ModEnd> ; opts_len -= <S2SV_ModStart> -= 4 ; } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_JOIN_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; opts_len -= PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_IVL_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } bp += 2 ; offset = <S2SV_ModEnd> EXTRACT_32BITS ( bp <S2SV_ModStart> ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u"" , offset , seq ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_RNG_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; <S2SV_ModStart> ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u"" , offset <S2SV_ModEnd> , seq ) <S2SV_ModStart> ; opts_len -= PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <S2SV_ModEnd> : if ( <S2SV_ModStart> ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , PGM_OPT_REDIRECT_FIXED_LEN <S2SV_ModEnd> , opt_len ) <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u"" , seq ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NBR_UNREACH"" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""<S2SV_blank>PATH_NLA<S2SV_blank>[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>SYN"" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FIN"" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>RST"" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""<S2SV_blank>CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>CRQST"" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN <S2SV_ModEnd> + sizeof ( <S2SV_ModStart> ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset <S2SV_ModEnd> , nla_buf ) <S2SV_ModStart> break ; case PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>PGM_OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <S2SV_ModEnd> : if ( <S2SV_ModStart> ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> + sizeof (
",the-tcpdump-group@tcpdump/4601c685e7fd19c3724d5e499c69b8d3ec49933e,CVE-2017-13019,https://github.com/the-tcpdump-group/tcpdump/commit/4601c685e7fd19c3724d5e499c69b8d3ec49933e,2017-09-14T06:29Z,"<S2SV_StartBug> if ( opt_len != 4 ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 16 ) { <S2SV_EndBug> <S2SV_StartBug> bp += sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 16 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len < sizeof ( uint32_t ) ) { <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> <S2SV_StartBug> seq = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> <S2SV_StartBug> bp += sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 12 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 12 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 12 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 12 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 4 + sizeof ( struct in_addr ) ) { <S2SV_EndBug> <S2SV_StartBug> opts_len -= 4 + sizeof ( struct in_addr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 4 + sizeof ( struct in6_addr ) ) { <S2SV_EndBug> <S2SV_StartBug> opts_len -= 4 + sizeof ( struct in6_addr ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; <S2SV_EndBug> <S2SV_StartBug> case PGM_OPT_PARITY_PRM : <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug>"
4399,CWE-000,"void print_arrays_for ( char * set ) { FILE * f ; <S2SV_StartBug> sprintf ( buf , ""%s.conf"" , set ) ; <S2SV_EndBug> if ( ( f = fopen ( buf , ""r"" ) ) == NULL ) { fprintf ( stderr , ""%s:<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>conf<S2SV_blank>file<S2SV_blank>for<S2SV_blank>charset<S2SV_blank>%s\\n"" , prog , set ) ; exit ( EXIT_FAILURE ) ; } <S2SV_StartBug> printf ( ""\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\n\\n"" , <S2SV_EndBug> set , prog ) ; print_array ( f , set , ""ctype"" , CTYPE_TABLE_SIZE ) ; print_array ( f , set , ""to_lower"" , TO_LOWER_TABLE_SIZE ) ; print_array ( f , set , ""to_upper"" , TO_UPPER_TABLE_SIZE ) ; print_array ( f , set , ""sort_order"" , SORT_ORDER_TABLE_SIZE ) ; printf ( ""\\n"" ) ; fclose ( f ) ; return ; }
","<S2SV_ModStart> * f ; snprintf ( buf , sizeof ( buf ) <S2SV_ModEnd> , ""%s.conf"" , <S2SV_ModStart> } printf ( ""\\\n<S2SV_blank><S2SV_blank><S2SV_blank>\\n\\n"" <S2SV_ModEnd> , set ,
",mysql@mysql-server/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,CVE-2016-0546,https://github.com/mysql/mysql-server/commit/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,2016-01-21T03:01Z,"<S2SV_StartBug> sprintf ( buf , ""%s.conf"" , set ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\n\\n"" , <S2SV_EndBug>"
1717,CWE-119,"<S2SV_StartBug> static void rd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , <S2SV_StartBug> int mi_col , BLOCK_SIZE bsize , int * rate , <S2SV_EndBug> int64_t * dist , int do_recon , int64_t best_rd ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; const int mi_step = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; TOKENEXTRA * tp_orig = * tp ; <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <S2SV_EndBug> int i , pl ; BLOCK_SIZE subsize ; <S2SV_StartBug> int this_rate , sum_rate = 0 , best_rate = INT_MAX ; <S2SV_EndBug> int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ; int64_t sum_rd = 0 ; int do_split = bsize >= BLOCK_8X8 ; int do_rect = 1 ; const int force_horz_split = ( mi_row + mi_step >= cm -> mi_rows ) ; const int force_vert_split = ( mi_col + mi_step >= cm -> mi_cols ) ; const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; <S2SV_StartBug> int partition_none_allowed = ! force_horz_split && ! force_vert_split ; <S2SV_EndBug> int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ; int partition_vert_allowed = ! force_horz_split && xss <= yss && bsize >= BLOCK_8X8 ; ( void ) * tp_orig ; <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> if ( x -> ab_index != 0 ) { * rate = 0 ; * dist = 0 ; return ; } } assert ( num_8x8_blocks_wide_lookup [ bsize ] == <S2SV_StartBug> num_8x8_blocks_high_lookup [ bsize ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_16X16 ) { <S2SV_EndBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ; <S2SV_StartBug> } else { <S2SV_EndBug> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; } if ( cpi -> sf . auto_min_max_partition_size ) { <S2SV_StartBug> partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> bsize >= cpi -> sf . min_partition_size ) ; <S2SV_StartBug> partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> bsize > cpi -> sf . min_partition_size ) || force_horz_split ) ; <S2SV_StartBug> partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> bsize > cpi -> sf . min_partition_size ) || force_vert_split ) ; <S2SV_StartBug> do_split &= bsize > cpi -> sf . min_partition_size ; <S2SV_EndBug> } if ( cpi -> sf . use_square_partition_only ) { partition_horz_allowed &= force_horz_split ; partition_vert_allowed &= force_vert_split ; } <S2SV_StartBug> save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . disable_split_var_thresh && partition_none_allowed ) { <S2SV_EndBug> unsigned int source_variancey ; vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ; source_variancey = get_sby_perpixel_variance ( cpi , x , bsize ) ; if ( source_variancey < cpi -> sf . disable_split_var_thresh ) { do_split = 0 ; <S2SV_StartBug> if ( source_variancey < cpi -> sf . disable_split_var_thresh / 2 ) <S2SV_EndBug> do_rect = 0 ; } } if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) ) do_split = 0 ; if ( partition_none_allowed ) { <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , bsize , <S2SV_EndBug> ctx , best_rd ) ; if ( this_rate != INT_MAX ) { if ( bsize >= BLOCK_8X8 ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ; <S2SV_EndBug> if ( sum_rd < best_rd ) { <S2SV_StartBug> int64_t stop_thresh = 4096 ; <S2SV_EndBug> int64_t stop_thresh_rd ; best_rate = this_rate ; best_dist = this_dist ; best_rd = sum_rd ; if ( bsize >= BLOCK_8X8 ) <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; <S2SV_EndBug> stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ; <S2SV_StartBug> stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) { <S2SV_EndBug> do_split = 0 ; do_rect = 0 ; } } } <S2SV_StartBug> if ( ! x -> in_active_map ) { <S2SV_EndBug> do_split = 0 ; do_rect = 0 ; } restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( cpi -> sf . adaptive_motion_search ) store_pred_mv ( x , ctx ) ; sum_rd = 0 ; if ( do_split ) { subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_StartBug> for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) { <S2SV_EndBug> const int x_idx = ( i & 1 ) * mi_step ; const int y_idx = ( i >> 1 ) * mi_step ; if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) continue ; <S2SV_StartBug> * get_sb_index ( x , subsize ) = i ; <S2SV_EndBug> if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) get_block_context ( x , subsize ) -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ; <S2SV_StartBug> rd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , i != 3 , best_rd - sum_rd ) ; <S2SV_EndBug> if ( this_rate == INT_MAX ) { <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> sum_dist += this_dist ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; } } if ( sum_rd < best_rd && i == 4 ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } else { if ( cpi -> sf . less_rectangular_check ) do_rect &= ! partition_none_allowed ; } <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( partition_horz_allowed && do_rect ) { <S2SV_EndBug> <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_HORZ ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 0 ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & sum_rate , & sum_dist , subsize , get_block_context ( x , subsize ) , best_rd ) ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_StartBug> if ( sum_rd < best_rd && mi_row + mi_step < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> subsize , 0 ) ; encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; * get_sb_index ( x , subsize ) = 1 ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> ctx -> mic . mbmi . interp_filter ; <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row + mi_step , mi_col , & this_rate , <S2SV_EndBug> & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ; if ( this_rate == INT_MAX ) { <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> } else { <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> sum_dist += this_dist ; <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> } } if ( sum_rd < best_rd ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; if ( sum_rd < best_rd ) { best_rd = sum_rd ; best_rate = sum_rate ; best_dist = sum_dist ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( partition_vert_allowed && do_rect ) { <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_VERT ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 0 ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & sum_rate , & sum_dist , subsize , get_block_context ( x , subsize ) , best_rd ) ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_StartBug> if ( sum_rd < best_rd && mi_col + mi_step < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> subsize , 0 ) ; encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; * get_sb_index ( x , subsize ) = 1 ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> ctx -> mic . mbmi . interp_filter ; <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + mi_step , & this_rate , <S2SV_EndBug> & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ; if ( this_rate == INT_MAX ) { <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> } else { <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> sum_dist += this_dist ; <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> } } if ( sum_rd < best_rd ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ; sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; if ( sum_rd < best_rd ) { best_rate = sum_rate ; best_dist = sum_dist ; best_rd = sum_rd ; * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } } restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; } ( void ) best_rd ; * rate = best_rate ; * dist = best_dist ; <S2SV_StartBug> if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) { <S2SV_EndBug> int output_enabled = ( bsize == BLOCK_64X64 ) ; <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { <S2SV_EndBug> vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled , <S2SV_StartBug> best_rate ) ; <S2SV_EndBug> } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ; encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; } if ( bsize == BLOCK_64X64 ) { assert ( tp_orig < * tp ) ; <S2SV_StartBug> assert ( best_rate < INT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( best_dist < INT64_MAX ) ; <S2SV_EndBug> } else { assert ( tp_orig == * tp ) ; } }
","<S2SV_ModStart> * cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , TOKENEXTRA * <S2SV_ModStart> int mi_row , int mi_col , <S2SV_ModEnd> BLOCK_SIZE bsize , <S2SV_ModStart> BLOCK_SIZE bsize , RD_COST * rd_cost , int64_t best_rd , PC_TREE * pc_tree <S2SV_ModEnd> ) { VP9_COMMON <S2SV_ModStart> -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> * ctx = & pc_tree -> none <S2SV_ModEnd> ; int i <S2SV_ModStart> BLOCK_SIZE subsize ; RD_COST this_rdc , sum_rdc , best_rdc <S2SV_ModEnd> ; int do_split <S2SV_ModStart> . subsampling_y ; BLOCK_SIZE min_size = x -> min_partition_size ; BLOCK_SIZE max_size = x -> max_partition_size ; # if CONFIG_FP_MB_STATS unsigned int src_diff_var = UINT_MAX ; int none_complexity = 0 ; # endif <S2SV_ModStart> * tp_orig ; <S2SV_ModEnd> assert ( num_8x8_blocks_wide_lookup <S2SV_ModStart> [ bsize ] ) ; vp9_rd_cost_init ( & this_rdc ) ; vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize <S2SV_ModStart> bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) <S2SV_ModEnd> x -> mb_energy <S2SV_ModStart> bsize ) ; if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) { int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( bsize <= max_size && bsize >= min_size <S2SV_ModEnd> ) ; partition_horz_allowed <S2SV_ModStart> ( bsize <= max_size && bsize > min_size <S2SV_ModEnd> ) || force_horz_split <S2SV_ModStart> ( bsize <= max_size && bsize > min_size <S2SV_ModEnd> ) || force_vert_split <S2SV_ModStart> &= bsize > min_size <S2SV_ModEnd> ; } if <S2SV_ModStart> } save_context ( x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> bsize ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } # endif # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && partition_none_allowed && src_diff_var > 4 && cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c ; MOTION_DIRECTION this_mv ; MOTION_DIRECTION right_mv ; MOTION_DIRECTION bottom_mv ; this_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ; if ( c != mb_col_end - 1 ) { right_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ; none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ; } if ( r != mb_row_end - 1 ) { bottom_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ; none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ; } } } if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) { partition_none_allowed <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; } } # endif <S2SV_ModEnd> if ( partition_none_allowed <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col , & this_rdc , bsize , ctx , best_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> != INT_MAX ) <S2SV_ModStart> bsize ) ; this_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> PARTITION_NONE ] ; this_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , this_rdc . rate , this_rdc . dist ) ; } if ( this_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ) { int64_t <S2SV_ModStart> ) { int64_t dist_breakout_thr = cpi -> sf . partition_search_breakout_dist_thr ; int rate_breakout_thr = cpi -> sf . partition_search_breakout_rate_thr ; best_rdc = this_rdc <S2SV_ModEnd> ; if ( <S2SV_ModStart> >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ; dist_breakout_thr <S2SV_ModEnd> >>= 8 - <S2SV_ModStart> ] ) ; rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; if ( ! x -> e_mbd . lossless && ( ctx -> skippable && best_rdc . dist < dist_breakout_thr && best_rdc . rate < rate_breakout_thr ) ) { do_split = 0 ; do_rect = 0 ; } # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && do_split != 0 && cm -> base_qindex > qindex_skip_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; int skip = 1 ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_MOTION_ZERO_MASK ) || ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_ERROR_SMALL_MASK ) ) { skip = 0 ; break ; } } if ( skip == 0 ) { break ; } } if ( skip ) { if ( src_diff_var == UINT_MAX ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } if ( src_diff_var < 8 <S2SV_ModEnd> ) { do_split <S2SV_ModStart> } } } # endif } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( cpi -> sf . adaptive_motion_search ) store_pred_mv ( x , ctx ) ; if ( do_split ) { subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { i = 4 ; if ( cpi -> sf . adaptive_pred_interp_filter && partition_none_allowed ) pc_tree -> leaf_split [ 0 ] -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , pc_tree -> leaf_split [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rate == INT_MAX ) sum_rdc . rdcost = INT64_MAX ; } else { <S2SV_ModEnd> for ( i <S2SV_ModStart> < 4 && sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ; ++ i <S2SV_ModStart> ) continue ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> split [ i ] -> index = i <S2SV_ModEnd> ; rd_pick_partition ( <S2SV_ModStart> ( cpi , td , tile_data <S2SV_ModEnd> , tp , <S2SV_ModStart> subsize , & this_rdc , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX ) <S2SV_ModStart> INT_MAX ) { sum_rdc . rdcost <S2SV_ModEnd> = INT64_MAX ; <S2SV_ModStart> = INT64_MAX ; break ; <S2SV_ModStart> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } } if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && i == <S2SV_ModStart> bsize ) ; sum_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ <S2SV_ModStart> PARTITION_SPLIT ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModEnd> ; } } <S2SV_ModStart> } restore_context ( x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ( partition_horz_allowed && ( do_rect || vp9_active_h_edge ( cpi , mi_row , mi_step ) ) <S2SV_ModEnd> ) { subsize <S2SV_ModStart> , PARTITION_HORZ ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> && partition_none_allowed ) pc_tree -> horizontal [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> horizontal [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_row + <S2SV_ModStart> cm -> mi_rows && bsize > BLOCK_8X8 ) { PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; <S2SV_ModEnd> update_state ( cpi <S2SV_ModStart> ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> && partition_none_allowed ) pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> pred_interp_filter = ctx <S2SV_ModStart> ( cpi , tile_data , x <S2SV_ModEnd> , mi_row + <S2SV_ModStart> mi_col , & this_rdc , subsize , & pc_tree -> horizontal [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX ) <S2SV_ModStart> INT_MAX ) { sum_rdc . rdcost <S2SV_ModEnd> = INT64_MAX ; <S2SV_ModStart> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( partition_vert_allowed && ( do_rect || vp9_active_v_edge ( cpi , mi_col , mi_step ) ) ) { subsize <S2SV_ModEnd> = get_subsize ( <S2SV_ModStart> , PARTITION_VERT ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> && partition_none_allowed ) pc_tree -> vertical [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> vertical [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_col + <S2SV_ModStart> cm -> mi_cols && bsize > BLOCK_8X8 <S2SV_ModStart> ( cpi , td , & pc_tree -> vertical [ 0 ] , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> && partition_none_allowed ) pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> pred_interp_filter = ctx <S2SV_ModStart> ( cpi , tile_data , x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> mi_step , & this_rdc , subsize , & pc_tree -> vertical [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX ) <S2SV_ModStart> INT_MAX ) { sum_rdc . rdcost <S2SV_ModEnd> = INT64_MAX ; <S2SV_ModStart> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( <S2SV_ModStart> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } ( void ) best_rd ; * rd_cost = best_rdc ; if ( best_rdc . rate <S2SV_ModEnd> < INT_MAX && <S2SV_ModStart> < INT_MAX && best_rdc . dist <S2SV_ModEnd> < INT64_MAX && <S2SV_ModStart> < INT64_MAX && pc_tree -> index != 3 <S2SV_ModEnd> ) { int <S2SV_ModStart> BLOCK_64X64 ) ; encode_sb ( cpi , td , tile_info , tp <S2SV_ModEnd> , mi_row , <S2SV_ModStart> , output_enabled , bsize , pc_tree <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; assert ( best_rdc . rate <S2SV_ModEnd> < INT_MAX ) <S2SV_ModStart> ; assert ( best_rdc . dist <S2SV_ModEnd> < INT64_MAX )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void rd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int mi_col , BLOCK_SIZE bsize , int * rate , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> int this_rate , sum_rate = 0 , best_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> int partition_none_allowed = ! force_horz_split && ! force_vert_split ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> num_8x8_blocks_high_lookup [ bsize ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_16X16 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> do_split &= bsize > cpi -> sf . min_partition_size ; <S2SV_EndBug> <S2SV_StartBug> save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . disable_split_var_thresh && partition_none_allowed ) { <S2SV_EndBug> <S2SV_StartBug> if ( source_variancey < cpi -> sf . disable_split_var_thresh / 2 ) <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , bsize , <S2SV_EndBug> <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ; <S2SV_EndBug> <S2SV_StartBug> int64_t stop_thresh = 4096 ; <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; <S2SV_EndBug> <S2SV_StartBug> stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> in_active_map ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = i ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , i != 3 , best_rd - sum_rd ) ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( partition_horz_allowed && do_rect ) { <S2SV_EndBug> <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_HORZ ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> if ( sum_rd < best_rd && mi_row + mi_step < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row + mi_step , mi_col , & this_rate , <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_VERT ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> if ( sum_rd < best_rd && mi_col + mi_step < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + mi_step , & this_rate , <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { <S2SV_EndBug> <S2SV_StartBug> best_rate ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( best_rate < INT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( best_dist < INT64_MAX ) ; <S2SV_EndBug>"
2428,CWE-190,"static void common_hrtimer_rearm ( struct k_itimer * timr ) { struct hrtimer * timer = & timr -> it . real . timer ; if ( ! timr -> it_interval ) return ; <S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug> timer -> base -> get_time ( ) , timr -> it_interval ) ; hrtimer_restart ( timer ) ; }
","<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
",torvalds@linux/78c9c4dfbf8c04883941445a195276bb4bb92c76,CVE-2018-12896,https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76,2018-07-02T17:29Z,"<S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug>"
3554,CWE-200,"static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; unsigned int copied , rlen ; struct sk_buff * skb , * cskb ; int err = 0 ; <S2SV_StartBug> pr_debug ( ""%p<S2SV_blank>%zu\\n"" , sk , len ) ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state == LLCP_CLOSED && skb_queue_empty ( & sk -> sk_receive_queue ) ) { release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { pr_err ( ""Recv<S2SV_blank>datagram<S2SV_blank>failed<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d"" , sk -> sk_state , err , sock_error ( sk ) ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } sock_recv_timestamp ( msg , sk , skb ) ; if ( sk -> sk_type == SOCK_DGRAM && msg -> msg_name ) { struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; struct sockaddr_nfc_llcp * sockaddr = ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; pr_debug ( ""Datagram<S2SV_blank>socket<S2SV_blank>%d<S2SV_blank>%d\\n"" , ui_cb -> dsap , ui_cb -> ssap ) ; <S2SV_StartBug> sockaddr -> sa_family = AF_NFC ; <S2SV_EndBug> sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ; sockaddr -> dsap = ui_cb -> dsap ; sockaddr -> ssap = ui_cb -> ssap ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
","<S2SV_ModStart> , len ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ;
",torvalds@linux/d26d6504f23e803824e8ebd14e52d4fc0a0b09cb,CVE-2013-3233,https://github.com/torvalds/linux/commit/d26d6504f23e803824e8ebd14e52d4fc0a0b09cb,2013-04-22T11:41Z,"<S2SV_StartBug> pr_debug ( ""%p<S2SV_blank>%zu\\n"" , sk , len ) ; <S2SV_EndBug> <S2SV_StartBug> sockaddr -> sa_family = AF_NFC ; <S2SV_EndBug>"
7471,CWE-476,"static int resize ( int new_rows , int new_cols , VTermPos * delta , void * user ) { VTermScreen * screen = user ; int is_altscreen = ( screen -> buffers [ 1 ] && screen -> buffer == screen -> buffers [ 1 ] ) ; int old_rows = screen -> rows ; int old_cols = screen -> cols ; int first_blank_row ; if ( ! is_altscreen && new_rows < old_rows ) { VTermPos pos = { 0 , 0 } ; VTermPos cursor = screen -> state -> pos ; for ( pos . row = old_rows - 1 ; pos . row >= new_rows ; pos . row -- ) if ( ! vterm_screen_is_eol ( screen , pos ) || cursor . row == pos . row ) break ; first_blank_row = pos . row + 1 ; if ( first_blank_row > new_rows ) { VTermRect rect = { 0 , 0 , 0 , 0 } ; rect . end_row = old_rows ; rect . end_col = old_cols ; scrollrect ( rect , first_blank_row - new_rows , 0 , user ) ; vterm_screen_flush_damage ( screen ) ; delta -> row -= first_blank_row - new_rows ; } } screen -> buffers [ 0 ] = realloc_buffer ( screen , screen -> buffers [ 0 ] , new_rows , new_cols ) ; if ( screen -> buffers [ 1 ] ) screen -> buffers [ 1 ] = realloc_buffer ( screen , screen -> buffers [ 1 ] , new_rows , new_cols ) ; screen -> buffer = is_altscreen ? screen -> buffers [ 1 ] : screen -> buffers [ 0 ] ; screen -> rows = new_rows ; screen -> cols = new_cols ; <S2SV_StartBug> if ( screen -> sb_buffer ) <S2SV_EndBug> vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ; screen -> sb_buffer = vterm_allocator_malloc ( screen -> vt , sizeof ( VTermScreenCell ) * new_cols ) ; if ( new_cols > old_cols ) { VTermRect rect ; rect . start_row = 0 ; rect . end_row = old_rows ; rect . start_col = old_cols ; rect . end_col = new_cols ; damagerect ( screen , rect ) ; } if ( new_rows > old_rows ) { if ( ! is_altscreen && screen -> callbacks && screen -> callbacks -> sb_popline ) { int rows = new_rows - old_rows ; while ( rows ) { VTermRect rect = { 0 , 0 , 0 , 0 } ; VTermPos pos = { 0 , 0 } ; if ( ! ( screen -> callbacks -> sb_popline ( screen -> cols , screen -> sb_buffer , screen -> cbdata ) ) ) break ; rect . end_row = screen -> rows ; rect . end_col = screen -> cols ; scrollrect ( rect , - 1 , 0 , user ) ; for ( pos . col = 0 ; pos . col < screen -> cols ; pos . col += screen -> sb_buffer [ pos . col ] . width ) vterm_screen_set_cell ( screen , pos , screen -> sb_buffer + pos . col ) ; rect . end_row = 1 ; damagerect ( screen , rect ) ; vterm_screen_flush_damage ( screen ) ; rows -- ; delta -> row ++ ; } } { VTermRect rect ; rect . start_row = old_rows ; rect . end_row = new_rows ; rect . start_col = 0 ; rect . end_col = new_cols ; damagerect ( screen , rect ) ; } } if ( screen -> callbacks && screen -> callbacks -> resize ) return ( * screen -> callbacks -> resize ) ( new_rows , new_cols , screen -> cbdata ) ; return 1 ; }
","<S2SV_ModStart> = new_cols ; <S2SV_ModEnd> vterm_allocator_free ( screen
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,<S2SV_StartBug> if ( screen -> sb_buffer ) <S2SV_EndBug>
7725,CWE-000,"<S2SV_StartBug> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <S2SV_EndBug> { write_seqlock ( & state -> seqlock ) ; if ( deleg_stateid != NULL ) { memcpy ( state -> stateid . data , deleg_stateid -> data , sizeof ( state -> stateid . data ) ) ; set_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } if ( open_stateid != NULL ) <S2SV_StartBug> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <S2SV_EndBug> write_sequnlock ( & state -> seqlock ) ; spin_lock ( & state -> owner -> so_lock ) ; <S2SV_StartBug> update_open_stateflags ( state , open_flags ) ; <S2SV_EndBug> spin_unlock ( & state -> owner -> so_lock ) ; }
","<S2SV_ModStart> * deleg_stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , open_stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock <S2SV_ModStart> ( state , fmode <S2SV_ModEnd> ) ; spin_unlock
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <S2SV_EndBug> <S2SV_StartBug> update_open_stateflags ( state , open_flags ) ; <S2SV_EndBug>"
4803,CWE-444,"agooCon agoo_con_create ( agooErr err , int sock , uint64_t id , agooBind b ) { agooCon c ; if ( NULL == ( c = ( agooCon ) AGOO_CALLOC ( 1 , sizeof ( struct _agooCon ) ) ) ) { AGOO_ERR_MEM ( err , ""Connection"" ) ; } else { <S2SV_StartBug> c -> sock = sock ; <S2SV_EndBug> c -> id = id ; c -> timeout = dtime ( ) + CON_TIMEOUT ; c -> bind = b ; c -> loop = NULL ; pthread_mutex_init ( & c -> res_lock , 0 ) ; } return c ; }
","<S2SV_ModStart> } else { struct sockaddr_storage addr ; socklen_t len = sizeof ( addr ) ; getpeername ( sock , ( struct sockaddr * ) & addr , & len ) ; if ( addr . ss_family == AF_INET ) { struct sockaddr_in * s = ( struct sockaddr_in * ) & addr ; inet_ntop ( AF_INET , & s -> sin_addr , c -> remote , sizeof ( c -> remote ) ) ; } else { struct sockaddr_in6 * s = ( struct sockaddr_in6 * ) & addr ; inet_ntop ( AF_INET6 , & s -> sin6_addr , c -> remote , sizeof ( c -> remote ) ) ; }
",ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130,CVE-2020-7670,https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130,2020-06-10T16:15Z,<S2SV_StartBug> c -> sock = sock ; <S2SV_EndBug>
4066,CWE-119,"static Image * ReadHALDImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; size_t cube_size , level ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; level = 0 ; if ( * image_info -> filename != '\\0' ) level = StringToUnsignedLong ( image_info -> filename ) ; if ( level < 2 ) level = 8 ; status = MagickTrue ; cube_size = level * level ; image -> columns = ( size_t ) ( level * cube_size ) ; image -> rows = ( size_t ) ( level * cube_size ) ; <S2SV_StartBug> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y += ( ssize_t ) level ) <S2SV_EndBug> { ssize_t blue , green , red ; register PixelPacket * restrict q ; if ( status == MagickFalse ) continue ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , ( size_t ) level , exception ) ; if ( q == ( PixelPacket * ) NULL ) { status = MagickFalse ; continue ; } blue = y / ( ssize_t ) level ; for ( green = 0 ; green < ( ssize_t ) cube_size ; green ++ ) { for ( red = 0 ; red < ( ssize_t ) cube_size ; red ++ ) { SetPixelRed ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * red / ( cube_size - 1.0 ) ) ) ) ; SetPixelGreen ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * green / ( cube_size - 1.0 ) ) ) ) ; SetPixelBlue ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * blue / ( cube_size - 1.0 ) ) ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) status = MagickFalse ; } return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> cube_size ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,<S2SV_StartBug> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y += ( ssize_t ) level ) <S2SV_EndBug>
7736,CWE-000,"static void nfs4_open_confirm_release ( void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state * state = NULL ; if ( data -> cancelled == 0 ) goto out_free ; if ( ! data -> rpc_done ) goto out_free ; state = nfs4_opendata_to_nfs4_state ( data ) ; if ( ! IS_ERR ( state ) ) <S2SV_StartBug> nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ; <S2SV_EndBug> out_free : nfs4_opendata_put ( data ) ; }
","<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; out_free
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ; <S2SV_EndBug>"
3771,CWE-20,"long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) { <S2SV_StartBug> if ( shmflg & SHM_RND ) <S2SV_EndBug> addr &= ~ ( shmlba - 1 ) ; else # ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) # endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock ; } err = - EACCES ; if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) goto out_unlock ; err = security_shm_shmat ( shp , shmaddr , shmflg ) ; if ( err ) goto out_unlock ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ipc_valid_object ( & shp -> shm_perm ) ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; } path = shp -> shm_file -> f_path ; path_get ( & path ) ; shp -> shm_nattch ++ ; size = i_size_read ( d_inode ( path . dentry ) ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; err = - ENOMEM ; sfd = kzalloc ( sizeof ( * sfd ) , GFP_KERNEL ) ; if ( ! sfd ) { path_put ( & path ) ; goto out_nattch ; } file = alloc_file ( & path , f_mode , is_file_hugepages ( shp -> shm_file ) ? & shm_file_operations_huge : & shm_file_operations ) ; err = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) { kfree ( sfd ) ; path_put ( & path ) ; goto out_nattch ; } file -> private_data = sfd ; file -> f_mapping = shp -> shm_file -> f_mapping ; sfd -> id = shp -> shm_perm . id ; sfd -> ns = get_ipc_ns ( ns ) ; sfd -> file = shp -> shm_file ; sfd -> vm_ops = NULL ; err = security_mmap_file ( file , prot , flags ) ; if ( err ) goto out_fput ; if ( down_write_killable ( & current -> mm -> mmap_sem ) ) { err = - EINTR ; goto out_fput ; } if ( addr && ! ( shmflg & SHM_REMAP ) ) { err = - EINVAL ; if ( addr + size < addr ) goto invalid ; if ( find_vma_intersection ( current -> mm , addr , addr + size ) ) goto invalid ; } addr = do_mmap_pgoff ( file , addr , size , prot , flags , 0 , & populate , NULL ) ; * raddr = addr ; err = 0 ; if ( IS_ERR_VALUE ( addr ) ) err = ( long ) addr ; invalid : up_write ( & current -> mm -> mmap_sem ) ; if ( populate ) mm_populate ( addr , populate ) ; out_fput : fput ( file ) ; out_nattch : down_write ( & shm_ids ( ns ) . rwsem ) ; shp = shm_lock ( ns , shmid ) ; shp -> shm_nattch -- ; if ( shm_may_destroy ( ns , shp ) ) shm_destroy ( ns , shp ) ; else shm_unlock ( shp ) ; up_write ( & shm_ids ( ns ) . rwsem ) ; return err ; out_unlock : rcu_read_unlock ( ) ; out : return err ; }
","<S2SV_ModStart> { if ( ( <S2SV_ModStart> shmflg & SHM_RND ) && addr >= shmlba
",torvalds@linux/e1d35d4dc7f089e6c9c080d556feedf9c706f0c7,CVE-2017-5669,https://github.com/torvalds/linux/commit/e1d35d4dc7f089e6c9c080d556feedf9c706f0c7,2017-02-24T15:59Z,<S2SV_StartBug> if ( shmflg & SHM_RND ) <S2SV_EndBug>
1227,CWE-125,"int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; <S2SV_StartBug> if ( op -> op > 0xbf ) return 1 ; <S2SV_EndBug> WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i64)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f64)"" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>?)"" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; <S2SV_StartBug> if ( ! ( n > 0 && n < buf_len ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ; <S2SV_EndBug> int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; <S2SV_StartBug> if ( ! ( op -> len + n <= buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> op -> len += n ; <S2SV_EndBug> } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; <S2SV_StartBug> if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ; <S2SV_EndBug> op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>"" , opdef -> txt , count ) ; <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_EndBug> } snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""invalid"" ) ; return op -> len ; }
","<S2SV_ModStart> > 0xbf ) { <S2SV_ModStart> return 1 ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> ) ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> -> txt ) + 10 <S2SV_ModStart> ++ ) { int optxtlen = strlen ( op -> txt ) ; <S2SV_ModStart> -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen <S2SV_ModEnd> , ""%d<S2SV_blank>"" ,
",radare@radare2/52b1526443c1f433087928291d1c3d37a5600515,CVE-2017-15368,https://github.com/radare/radare2/commit/52b1526443c1f433087928291d1c3d37a5600515,2017-10-16T01:29Z,"<S2SV_StartBug> if ( op -> op > 0xbf ) return 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( n > 0 && n < buf_len ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( op -> len + n <= buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> op -> len += n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_EndBug>"
1648,CWE-119,"<S2SV_StartBug> static void encode_unsigned_max ( struct vp9_write_bit_buffer * wb , <S2SV_EndBug> int data , int max ) { <S2SV_StartBug> vp9_wb_write_literal ( wb , data , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> encode_unsigned_max ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb , <S2SV_ModStart> max ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void encode_unsigned_max ( struct vp9_write_bit_buffer * wb , <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , data , get_unsigned_bits ( max ) ) ; <S2SV_EndBug>"
895,CWE-125,"static bool r_bin_mdmp_init_directory ( struct r_bin_mdmp_obj * obj ) { int i ; <S2SV_StartBug> ut8 * directory_base ; <S2SV_EndBug> struct minidump_directory * entry ; directory_base = obj -> b -> buf + obj -> hdr -> stream_directory_rva ; sdb_num_set ( obj -> kv , ""mdmp_directory.offset"" , obj -> hdr -> stream_directory_rva , 0 ) ; sdb_set ( obj -> kv , ""mdmp_directory.format"" , ""[4]E?<S2SV_blank>"" ""(mdmp_stream_type)StreamType<S2SV_blank>"" ""(mdmp_location_descriptor)Location"" , 0 ) ; <S2SV_StartBug> for ( i = 0 ; i < ( int ) obj -> hdr -> number_of_streams ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> r_bin_mdmp_init_directory_entry ( obj , entry ) ; <S2SV_EndBug> } return true ; }
","<S2SV_ModStart> int i ; struct minidump_directory entry <S2SV_ModEnd> ; sdb_num_set ( <S2SV_ModStart> 0 ) ; ut64 rvadir = obj -> hdr -> stream_directory_rva ; <S2SV_ModStart> ++ ) { ut32 delta = <S2SV_ModEnd> i * sizeof <S2SV_ModStart> struct minidump_directory ) ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory <S2SV_ModStart> ) ) ; if ( r ) { <S2SV_ModStart> ( obj , & <S2SV_ModStart> entry ) ; }
",radare@radare2/40b021ba29c8f90ccf7c879fde2580bc73a17e8e,CVE-2018-14016,https://github.com/radare/radare2/commit/40b021ba29c8f90ccf7c879fde2580bc73a17e8e,2018-07-12T20:29Z,"<S2SV_StartBug> ut8 * directory_base ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( int ) obj -> hdr -> number_of_streams ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> r_bin_mdmp_init_directory_entry ( obj , entry ) ; <S2SV_EndBug>"
3183,CWE-834,"static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MaxTextExtent ] , name [ MaxTextExtent ] ; Image <S2SV_StartBug> * image ; <S2SV_EndBug> MagickBooleanType status ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length , <S2SV_StartBug> padding , <S2SV_EndBug> value , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( sscanf ( buffer , ""static<S2SV_blank>short<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , ""static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , ""static<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) NULL ) p = ( unsigned char * ) name ; else p ++ ; if ( LocaleCompare ( ""bits[]"" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) { <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) <S2SV_StartBug> * p ++ = ( unsigned char ) ( value >> 8 ) ; <S2SV_EndBug> } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { value = XBMInteger ( image , hex_digits ) ; <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 ) <S2SV_StartBug> byte = ( size_t ) ( * p ++ ) ; <S2SV_EndBug> SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ( void ) SyncImage ( image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> Image * image ; int c <S2SV_ModStart> length , padding <S2SV_ModEnd> , version , <S2SV_ModStart> ) ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c <S2SV_ModEnd> ; if ( <S2SV_ModStart> char ) ( c <S2SV_ModEnd> >> 8 ) <S2SV_ModStart> hex_digits ) ; if ( c < 0 ) break ; <S2SV_ModStart> unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) <S2SV_ModEnd> ; } p <S2SV_ModStart> byte = ( unsigned int <S2SV_ModEnd> ) ( *
",ImageMagick@ImageMagick/b8c63b156bf26b52e710b1a0643c846a6cd01e56,CVE-2017-14175,https://github.com/ImageMagick/ImageMagick/commit/b8c63b156bf26b52e710b1a0643c846a6cd01e56,2017-09-07T06:29Z,"<S2SV_StartBug> * image ; <S2SV_EndBug> <S2SV_StartBug> padding , <S2SV_EndBug> <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) ( value >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> byte = ( size_t ) ( * p ++ ) ; <S2SV_EndBug>"
1779,CWE-119,"void vp9_rc_get_second_pass_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_StartBug> struct twopass_rc * const twopass = & cpi -> twopass ; <S2SV_EndBug> int frames_left ; FIRSTPASS_STATS this_frame ; <S2SV_StartBug> FIRSTPASS_STATS this_frame_copy ; <S2SV_EndBug> <S2SV_StartBug> double this_frame_intra_error ; <S2SV_EndBug> double this_frame_coded_error ; int target ; LAYER_CONTEXT * lc = NULL ; <S2SV_StartBug> int is_spatial_svc = ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) ; <S2SV_EndBug> if ( is_spatial_svc ) { <S2SV_StartBug> lc = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] ; <S2SV_EndBug> frames_left = ( int ) ( twopass -> total_stats . count - lc -> current_video_frame_in_layer ) ; } else { frames_left = ( int ) ( twopass -> total_stats . count - <S2SV_StartBug> cm -> current_video_frame ) ; <S2SV_EndBug> } if ( ! twopass -> stats_in ) return ; if ( cpi -> refresh_alt_ref_frame ) { cm -> frame_type = INTER_FRAME ; vp9_rc_set_frame_target ( cpi , twopass -> gf_bits ) ; return ; } vp9_clear_system_state ( ) ; if ( is_spatial_svc && twopass -> kf_intra_err_min == 0 ) { twopass -> kf_intra_err_min = KF_MB_INTRA_MIN * cpi -> common . MBs ; twopass -> gf_intra_err_min = GF_MB_INTRA_MIN * cpi -> common . MBs ; } if ( cpi -> oxcf . end_usage == USAGE_CONSTANT_QUALITY ) { twopass -> active_worst_quality = cpi -> oxcf . cq_level ; } else if ( cm -> current_video_frame == 0 || ( is_spatial_svc && lc -> current_video_frame_in_layer == 0 ) ) { const int section_target_bandwidth = ( int ) ( twopass -> bits_left / frames_left ) ; const int tmp_q = vp9_twopass_worst_quality ( cpi , & twopass -> total_left_stats , section_target_bandwidth ) ; twopass -> active_worst_quality = tmp_q ; rc -> ni_av_qi = tmp_q ; rc -> avg_q = vp9_convert_qindex_to_q ( tmp_q ) ; } vp9_zero ( this_frame ) ; if ( EOF == input_stats ( twopass , & this_frame ) ) return ; this_frame_intra_error = this_frame . intra_error ; this_frame_coded_error = this_frame . coded_error ; if ( rc -> frames_to_key == 0 || ( cm -> frame_flags & FRAMEFLAGS_KEY ) ) { this_frame_copy = this_frame ; find_next_key_frame ( cpi , & this_frame_copy ) ; if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 && cpi -> svc . spatial_layer_id > 0 ) { cm -> frame_type = INTER_FRAME ; } } else { cm -> frame_type = INTER_FRAME ; } <S2SV_StartBug> if ( rc -> frames_till_gf_update_due == 0 ) { <S2SV_EndBug> this_frame_copy = this_frame ; # if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) { define_fixed_arf_period ( cpi ) ; } else { # endif define_gf_group ( cpi , & this_frame_copy ) ; # if CONFIG_MULTIPLE_ARF } # endif if ( twopass -> gf_zeromotion_pct > 995 ) { if ( ! cm -> show_frame ) cpi -> allow_encode_breakout = ENCODE_BREAKOUT_DISABLED ; else cpi -> allow_encode_breakout = ENCODE_BREAKOUT_LIMITED ; } rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; cpi -> refresh_golden_frame = 1 ; } else { this_frame_copy = this_frame ; assign_std_frame_bits ( cpi , & this_frame_copy ) ; } twopass -> this_iiratio = ( int ) ( this_frame_intra_error / DOUBLE_DIVIDE_CHECK ( this_frame_coded_error ) ) ; { FIRSTPASS_STATS next_frame ; if ( lookup_next_frame_stats ( twopass , & next_frame ) != EOF ) { twopass -> next_iiratio = ( int ) ( next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; } } if ( cpi -> common . frame_type == KEY_FRAME ) target = vp9_rc_clamp_iframe_target_size ( cpi , rc -> this_frame_target ) ; else target = vp9_rc_clamp_pframe_target_size ( cpi , rc -> this_frame_target ) ; vp9_rc_set_frame_target ( cpi , target ) ; subtract_stats ( & twopass -> total_left_stats , & this_frame ) ; }
","<S2SV_ModStart> -> rc ; TWO_PASS <S2SV_ModEnd> * const twopass <S2SV_ModStart> cpi -> twopass ; GF_GROUP * const gf_group = & twopass -> gf_group <S2SV_ModStart> FIRSTPASS_STATS this_frame ; int target_rate ; LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : 0 ; if ( lc != NULL ) { frames_left = ( int ) ( twopass -> total_stats . count - lc -> current_video_frame_in_layer ) ; } else { frames_left = ( int ) ( twopass -> total_stats . count - cm -> current_video_frame ) ; } if ( ! twopass -> stats_in ) return ; if ( gf_group -> update_type [ gf_group -> index ] == ARF_UPDATE ) { int target_rate ; configure_buffer_updates ( cpi ) ; target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; cm -> frame_type = INTER_FRAME ; if ( lc != NULL ) { if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ 0 ] . is_key_frame ; if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; } } if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } return ; } vpx_clear_system_state ( ) ; if ( cpi -> oxcf . rc_mode == VPX_Q ) { twopass -> active_worst_quality = cpi -> oxcf . cq_level ; } else if ( cm -> current_video_frame == 0 || ( lc != NULL && lc -> current_video_frame_in_layer == 0 ) ) { const int section_target_bandwidth = ( int ) ( twopass -> bits_left / frames_left ) ; const double section_length = twopass -> total_left_stats . count ; const double section_error = twopass -> total_left_stats . coded_error / section_length ; const double section_intra_skip = twopass -> total_left_stats . intra_skip_pct / section_length ; const double section_inactive_zone = ( twopass -> total_left_stats . inactive_zone_rows * 2 ) / ( ( double ) cm -> mb_rows * section_length ) ; const int tmp_q = get_twopass_worst_quality ( cpi , section_error , section_intra_skip + section_inactive_zone , section_target_bandwidth , DEFAULT_GRP_WEIGHT ) ; twopass -> active_worst_quality = tmp_q ; twopass -> baseline_active_worst_quality = tmp_q ; rc -> ni_av_qi = tmp_q ; rc -> last_q [ INTER_FRAME ] = tmp_q ; rc -> avg_q = vp9_convert_qindex_to_q ( tmp_q , cm -> bit_depth ) ; rc -> avg_frame_qindex [ INTER_FRAME ] = tmp_q ; rc -> last_q [ KEY_FRAME ] = ( tmp_q + cpi -> oxcf . best_allowed_q ) / 2 ; rc -> avg_frame_qindex [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] ; } vp9_zero ( this_frame ) ; if ( EOF == input_stats ( twopass , & this_frame ) ) return ; if ( this_frame . intra_skip_pct >= FC_ANIMATION_THRESH ) twopass -> fr_content_type = FC_GRAPHICS_ANIMATION ; else twopass -> fr_content_type = FC_NORMAL ; if ( rc -> frames_to_key == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) ) { <S2SV_ModStart> FIRSTPASS_STATS this_frame_copy ; this_frame_copy = this_frame ; find_next_key_frame ( cpi , & this_frame ) ; this_frame = this_frame_copy ; } else { cm -> frame_type = INTER_FRAME ; } if ( lc != NULL ) { if ( <S2SV_ModEnd> cpi -> svc <S2SV_ModStart> -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; lc -> frames_from_key_frame = 0 ; cpi -> svc . encode_intra_empty_frame = 1 ; } } else { cm -> frame_type = INTER_FRAME ; lc -> is_key_frame = <S2SV_ModEnd> cpi -> svc <S2SV_ModStart> . layer_context [ 0 ] . is_key_frame ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; lc -> frames_from_key_frame = 0 ; } } } if ( rc -> frames_till_gf_update_due == 0 ) { define_gf_group ( cpi , & this_frame ) ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( lc != NULL ) cpi -> refresh_golden_frame = 1 ; # if ARF_STATS_OUTPUT { FILE * fpfile ; fpfile = fopen ( ""arf.stt"" , ""a"" ) ; ++ arf_count ; fprintf ( fpfile , ""%10d<S2SV_blank>%10ld<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10ld\\n"" , <S2SV_ModEnd> cm -> current_video_frame <S2SV_ModStart> cm -> current_video_frame , <S2SV_ModEnd> rc -> frames_till_gf_update_due <S2SV_ModStart> rc -> frames_till_gf_update_due , rc -> kf_boost , arf_count , rc -> gfu_boost ) ; fclose ( fpfile ) ; } # endif } configure_buffer_updates ( cpi ) ; if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; if ( cpi -> common . frame_type == KEY_FRAME ) target_rate = vp9_rc_clamp_iframe_target_size ( cpi , target_rate ) ; else target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; { const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; twopass -> mb_av_energy = log ( ( ( this_frame . intra_error * 256.0 ) / num_mbs ) + 1.0 ) ; } <S2SV_ModEnd> subtract_stats ( &
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> struct twopass_rc * const twopass = & cpi -> twopass ; <S2SV_EndBug> <S2SV_StartBug> FIRSTPASS_STATS this_frame_copy ; <S2SV_EndBug> <S2SV_StartBug> double this_frame_intra_error ; <S2SV_EndBug> <S2SV_StartBug> int is_spatial_svc = ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) ; <S2SV_EndBug> <S2SV_StartBug> lc = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] ; <S2SV_EndBug> <S2SV_StartBug> cm -> current_video_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> frames_till_gf_update_due == 0 ) { <S2SV_EndBug>
608,CWE-119,"<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) { <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { ALOGE ( ""can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>*<S2SV_blank>%u<S2SV_blank>bytes"" , size , num ) ; android_errorWriteLog ( 0x534e4554 , ""27855419"" ) ; return NULL ; } <S2SV_ModEnd> return malloc ( <S2SV_ModStart> malloc ( size * num
",frameworks@av/2b6f22dc64d456471a1dc6df09d515771d1427c8,CVE-2016-2463,https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8,2016-06-13T01:59Z,<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) { <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug>
530,CWE-416,"static int tcpmss_mangle_packet ( struct sk_buff * skb , const struct xt_action_param * par , unsigned int family , unsigned int tcphoff , unsigned int minlen ) { const struct xt_tcpmss_info * info = par -> targinfo ; struct tcphdr * tcph ; int len , tcp_hdrlen ; unsigned int i ; __be16 oldval ; u16 newmss ; u8 * opt ; if ( par -> fragoff != 0 ) return 0 ; if ( ! skb_make_writable ( skb , skb -> len ) ) return - 1 ; len = skb -> len - tcphoff ; if ( len < ( int ) sizeof ( struct tcphdr ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ; <S2SV_StartBug> if ( len < tcp_hdrlen ) <S2SV_EndBug> return - 1 ; if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) { struct net * net = xt_net ( par ) ; unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; if ( min_mtu <= minlen ) { net_err_ratelimited ( ""unknown<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>path-MTU<S2SV_blank>(%u)\\n"" , min_mtu ) ; return - 1 ; } newmss = min_mtu - minlen ; } else newmss = info -> mss ; opt = ( u_int8_t * ) tcph ; for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - TCPOLEN_MSS ; i += optlen ( opt , i ) ) { if ( opt [ i ] == TCPOPT_MSS && opt [ i + 1 ] == TCPOLEN_MSS ) { u_int16_t oldmss ; oldmss = ( opt [ i + 2 ] << 8 ) | opt [ i + 3 ] ; if ( oldmss <= newmss ) return 0 ; opt [ i + 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ i + 3 ] = newmss & 0x00ff ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( oldmss ) , htons ( newmss ) , false ) ; return 0 ; } } if ( len > tcp_hdrlen ) return 0 ; <S2SV_StartBug> if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) { <S2SV_EndBug> if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; } skb_put ( skb , TCPOLEN_MSS ) ; if ( xt_family ( par ) == NFPROTO_IPV4 ) newmss = min ( newmss , ( u16 ) 536 ) ; else newmss = min ( newmss , ( u16 ) 1220 ) ; opt = ( u_int8_t * ) tcph + sizeof ( struct tcphdr ) ; memmove ( opt + TCPOLEN_MSS , opt , len - sizeof ( struct tcphdr ) ) ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( len ) , htons ( len + TCPOLEN_MSS ) , true ) ; opt [ 0 ] = TCPOPT_MSS ; opt [ 1 ] = TCPOLEN_MSS ; opt [ 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ 3 ] = newmss & 0x00ff ; inet_proto_csum_replace4 ( & tcph -> check , skb , 0 , * ( ( __be32 * ) opt ) , false ) ; oldval = ( ( __be16 * ) tcph ) [ 6 ] ; tcph -> doff += TCPOLEN_MSS / 4 ; inet_proto_csum_replace2 ( & tcph -> check , skb , oldval , ( ( __be16 * ) tcph ) [ 6 ] , false ) ; return TCPOLEN_MSS ; }
","<S2SV_ModStart> len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) <S2SV_ModStart> ; if ( tcp_hdrlen >= 15 * 4 ) return 0 ; if (
",torvalds@linux/2638fd0f92d4397884fd991d8f4925cb3f081901,CVE-2017-18017,https://github.com/torvalds/linux/commit/2638fd0f92d4397884fd991d8f4925cb3f081901,2018-01-03T06:29Z,<S2SV_StartBug> if ( len < tcp_hdrlen ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) { <S2SV_EndBug>
7843,CWE-20,"error_t tcpSendResetSegment ( NetInterface * interface , IpPseudoHeader * pseudoHeader , TcpHeader * segment , size_t length ) { error_t error ; size_t offset ; uint8_t flags ; uint32_t seqNum ; uint32_t ackNum ; NetBuffer * buffer ; TcpHeader * segment2 ; IpPseudoHeader pseudoHeader2 ; NetTxAncillary ancillary ; if ( segment -> flags & TCP_FLAG_ACK ) { flags = TCP_FLAG_RST ; seqNum = segment -> ackNum ; ackNum = 0 ; } else { flags = TCP_FLAG_RST | TCP_FLAG_ACK ; seqNum = 0 ; ackNum = segment -> seqNum + length ; if ( segment -> flags & TCP_FLAG_SYN ) <S2SV_StartBug> ackNum ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( segment -> flags & TCP_FLAG_FIN ) <S2SV_EndBug> <S2SV_StartBug> ackNum ++ ; <S2SV_EndBug> } buffer = ipAllocBuffer ( sizeof ( TcpHeader ) , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; segment2 = netBufferAt ( buffer , offset ) ; segment2 -> srcPort = htons ( segment -> destPort ) ; segment2 -> destPort = htons ( segment -> srcPort ) ; segment2 -> seqNum = htonl ( seqNum ) ; segment2 -> ackNum = htonl ( ackNum ) ; segment2 -> reserved1 = 0 ; segment2 -> dataOffset = 5 ; segment2 -> flags = flags ; segment2 -> reserved2 = 0 ; segment2 -> window = 0 ; segment2 -> checksum = 0 ; segment2 -> urgentPointer = 0 ; # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { pseudoHeader2 . length = sizeof ( Ipv4PseudoHeader ) ; pseudoHeader2 . ipv4Data . srcAddr = pseudoHeader -> ipv4Data . destAddr ; pseudoHeader2 . ipv4Data . destAddr = pseudoHeader -> ipv4Data . srcAddr ; pseudoHeader2 . ipv4Data . reserved = 0 ; pseudoHeader2 . ipv4Data . protocol = IPV4_PROTOCOL_TCP ; pseudoHeader2 . ipv4Data . length = HTONS ( sizeof ( TcpHeader ) ) ; segment2 -> checksum = ipCalcUpperLayerChecksumEx ( & pseudoHeader2 . ipv4Data , sizeof ( Ipv4PseudoHeader ) , buffer , offset , sizeof ( TcpHeader ) ) ; } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { pseudoHeader2 . length = sizeof ( Ipv6PseudoHeader ) ; pseudoHeader2 . ipv6Data . srcAddr = pseudoHeader -> ipv6Data . destAddr ; pseudoHeader2 . ipv6Data . destAddr = pseudoHeader -> ipv6Data . srcAddr ; pseudoHeader2 . ipv6Data . length = HTONL ( sizeof ( TcpHeader ) ) ; pseudoHeader2 . ipv6Data . reserved [ 0 ] = 0 ; pseudoHeader2 . ipv6Data . reserved [ 1 ] = 0 ; pseudoHeader2 . ipv6Data . reserved [ 2 ] = 0 ; pseudoHeader2 . ipv6Data . nextHeader = IPV6_TCP_HEADER ; segment2 -> checksum = ipCalcUpperLayerChecksumEx ( & pseudoHeader2 . ipv6Data , sizeof ( Ipv6PseudoHeader ) , buffer , offset , sizeof ( TcpHeader ) ) ; } else # endif { netBufferFree ( buffer ) ; return ERROR_INVALID_ADDRESS ; } MIB2_INC_COUNTER32 ( tcpGroup . tcpOutSegs , 1 ) ; TCP_MIB_INC_COUNTER32 ( tcpOutSegs , 1 ) ; TCP_MIB_INC_COUNTER64 ( tcpHCOutSegs , 1 ) ; MIB2_INC_COUNTER32 ( tcpGroup . tcpOutRsts , 1 ) ; TCP_MIB_INC_COUNTER32 ( tcpOutRsts , 1 ) ; TRACE_DEBUG ( ""%s:<S2SV_blank>Sending<S2SV_blank>TCP<S2SV_blank>reset<S2SV_blank>segment...\\r\\n"" , formatSystemTime ( osGetSystemTime ( ) , NULL ) ) ; tcpDumpHeader ( segment2 , length , 0 , 0 ) ; ancillary = NET_DEFAULT_TX_ANCILLARY ; error = ipSendDatagram ( interface , & pseudoHeader2 , buffer , offset , & ancillary ) ; netBufferFree ( buffer ) ; return error ; }
","<S2SV_ModStart> & TCP_FLAG_SYN ) { <S2SV_ModStart> ackNum ++ ; } <S2SV_ModStart> & TCP_FLAG_FIN ) { <S2SV_ModStart> ackNum ++ ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> ackNum ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( segment -> flags & TCP_FLAG_FIN ) <S2SV_EndBug> <S2SV_StartBug> ackNum ++ ; <S2SV_EndBug>
2348,CWE-119,"gboolean _pango_emoji_iter_next ( PangoEmojiIter * iter ) { PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID ; if ( iter -> end == iter -> text_end ) return FALSE ; iter -> start = iter -> end ; for ( ; iter -> end < iter -> text_end ; iter -> end = g_utf8_next_char ( iter -> end ) ) { gunichar ch = g_utf8_get_char ( iter -> end ) ; if ( ( ! ( ch == kZeroWidthJoinerCharacter && ! iter -> is_emoji ) && ch != kVariationSelector15Character && ch != kVariationSelector16Character && ch != kCombiningEnclosingCircleBackslashCharacter && ! _pango_Is_Regional_Indicator ( ch ) && ! ( ( ch == kLeftSpeechBubbleCharacter || ch == kRainbowCharacter || ch == kMaleSignCharacter || ch == kFemaleSignCharacter || ch == kStaffOfAesculapiusCharacter ) && ! iter -> is_emoji ) ) || current_emoji_type == PANGO_EMOJI_TYPE_INVALID ) { current_emoji_type = _pango_get_emoji_type ( ch ) ; } if ( g_utf8_next_char ( iter -> end ) < iter -> text_end ) { gunichar peek_char = g_utf8_get_char ( g_utf8_next_char ( iter -> end ) ) ; if ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_EMOJI && peek_char == kVariationSelector15Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT ; } if ( ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_TEXT || _pango_Is_Emoji_Keycap_Base ( ch ) ) && peek_char == kVariationSelector16Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( _pango_Is_Emoji_Keycap_Base ( ch ) && peek_char == kCombiningEnclosingKeycapCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } ; if ( _pango_Is_Regional_Indicator ( ch ) && _pango_Is_Regional_Indicator ( peek_char ) ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( ( ch == kEyeCharacter || ch == kWavingWhiteFlagCharacter ) && peek_char == kZeroWidthJoinerCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } } if ( iter -> is_emoji == ( gboolean ) 2 ) iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; if ( iter -> is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ) { iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; <S2SV_StartBug> return TRUE ; <S2SV_EndBug> } } iter -> is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; return TRUE ; }
","<S2SV_ModStart> current_emoji_type ) ; if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;
",GNOME@pango/71aaeaf020340412b8d012fe23a556c0420eda5f,CVE-2018-15120,https://github.com/GNOME/pango/commit/71aaeaf020340412b8d012fe23a556c0420eda5f,2018-08-24T19:29Z,<S2SV_StartBug> return TRUE ; <S2SV_EndBug>
6247,CWE-189,"void * chk_malloc ( size_t bytes ) { <S2SV_StartBug> char * buffer = ( char * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ; <S2SV_EndBug> if ( buffer ) { memset ( buffer , CHK_SENTINEL_VALUE , bytes + CHK_OVERHEAD_SIZE ) ; size_t offset = dlmalloc_usable_size ( buffer ) - sizeof ( size_t ) ; * ( size_t * ) ( buffer + offset ) = bytes ; buffer += CHK_SENTINEL_HEAD_SIZE ; } return buffer ; }
","<S2SV_ModStart> bytes ) { size_t size = bytes + CHK_OVERHEAD_SIZE ; if ( size < bytes ) { return NULL ; } uint8_t <S2SV_ModEnd> * buffer = <S2SV_ModStart> buffer = ( uint8_t <S2SV_ModEnd> * ) dlmalloc <S2SV_ModStart> ) dlmalloc ( size <S2SV_ModEnd> ) ; if
",android@platform_bionic/7f5aa4f35e23fd37425b3a5041737cdf58f87385,CVE-2012-2674,https://github.com/android/platform_bionic/commit/7f5aa4f35e23fd37425b3a5041737cdf58f87385,2012-07-25T19:55Z,<S2SV_StartBug> char * buffer = ( char * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ; <S2SV_EndBug>
115,CWE-285,"int ext2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; else { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext2_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext2_xattr_set ( inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug>"
7231,CWE-19,"static int ext2_xattr_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; struct ext2_xattr_entry * entry ; char * end ; size_t rest = buffer_size ; <S2SV_StartBug> int error ; <S2SV_EndBug> ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ; down_read ( & EXT2_I ( inode ) -> xattr_sem ) ; error = 0 ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<S2SV_blank>block<S2SV_blank>%d"" , EXT2_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; end = bh -> b_data + bh -> b_size ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { bad_block : ext2_error ( inode -> i_sb , ""ext2_xattr_list"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; goto cleanup ; } entry = FIRST_ENTRY ( bh ) ; while ( ! IS_LAST_ENTRY ( entry ) ) { struct ext2_xattr_entry * next = EXT2_XATTR_NEXT ( entry ) ; if ( ( char * ) next >= end ) goto bad_block ; entry = next ; } <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug> ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ; for ( entry = FIRST_ENTRY ( bh ) ; ! IS_LAST_ENTRY ( entry ) ; entry = EXT2_XATTR_NEXT ( entry ) ) { const struct xattr_handler * handler = ext2_xattr_handler ( entry -> e_name_index ) ; if ( handler && ( ! handler -> list || handler -> list ( dentry ) ) ) { const char * prefix = handler -> prefix ? : handler -> name ; size_t prefix_len = strlen ( prefix ) ; size_t size = prefix_len + entry -> e_name_len + 1 ; if ( buffer ) { if ( size > rest ) { error = - ERANGE ; goto cleanup ; } memcpy ( buffer , prefix , prefix_len ) ; buffer += prefix_len ; memcpy ( buffer , entry -> e_name , entry -> e_name_len ) ; buffer += entry -> e_name_len ; * buffer ++ = 0 ; } rest -= size ; } } error = buffer_size - rest ; cleanup : brelse ( bh ) ; up_read ( & EXT2_I ( inode ) -> xattr_sem ) ; return error ; }
","<S2SV_ModStart> ; int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModStart> ( ext2_xattr_cache_insert ( ext2_mb_cache ,
",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z,<S2SV_StartBug> int error ; <S2SV_EndBug> <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug>
696,CWE-189,"static ltxtquery * queryin ( char * buf ) { QPRS_STATE state ; int32 i ; ltxtquery * query ; int32 commonlen ; ITEM * ptr ; NODE * tmp ; int32 pos = 0 ; # ifdef BS_DEBUG char pbuf [ 16384 ] , * cur ; # endif state . buf = buf ; state . state = WAITOPERAND ; state . count = 0 ; state . num = 0 ; state . str = NULL ; state . sumlen = 0 ; state . lenop = 64 ; state . curop = state . op = ( char * ) palloc ( state . lenop ) ; * ( state . curop ) = '\\0' ; makepol ( & state ) ; if ( ! state . num ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Empty<S2SV_blank>query."" ) ) ) ; <S2SV_StartBug> commonlen = COMPUTESIZE ( state . num , state . sumlen ) ; <S2SV_EndBug> query = ( ltxtquery * ) palloc ( commonlen ) ; SET_VARSIZE ( query , commonlen ) ; query -> size = state . num ; ptr = GETQUERY ( query ) ; for ( i = 0 ; i < state . num ; i ++ ) { ptr [ i ] . type = state . str -> type ; ptr [ i ] . val = state . str -> val ; ptr [ i ] . distance = state . str -> distance ; ptr [ i ] . length = state . str -> length ; ptr [ i ] . flag = state . str -> flag ; tmp = state . str -> next ; pfree ( state . str ) ; state . str = tmp ; } memcpy ( ( void * ) GETOPERAND ( query ) , ( void * ) state . op , state . sumlen ) ; pfree ( state . op ) ; pos = 0 ; findoprnd ( ptr , & pos ) ; return query ; }
","<S2SV_ModStart> ) ) ; if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,"<S2SV_StartBug> commonlen = COMPUTESIZE ( state . num , state . sumlen ) ; <S2SV_EndBug>"
2472,CWE-754,"STATIC int xfs_attr_shortform_addname ( xfs_da_args_t * args ) { int newsize , forkoff , retval ; trace_xfs_attr_sf_addname ( args ) ; retval = xfs_attr_shortform_lookup ( args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == - ENOATTR ) ) { return retval ; } else if ( retval == - EEXIST ) { if ( args -> flags & ATTR_CREATE ) return retval ; retval = xfs_attr_shortform_remove ( args ) ; <S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug> } if ( args -> namelen >= XFS_ATTR_SF_ENTSIZE_MAX || args -> valuelen >= XFS_ATTR_SF_ENTSIZE_MAX ) return - ENOSPC ; newsize = XFS_ATTR_SF_TOTSIZE ( args -> dp ) ; newsize += XFS_ATTR_SF_ENTSIZE_BYNAME ( args -> namelen , args -> valuelen ) ; forkoff = xfs_attr_shortform_bytesfit ( args -> dp , newsize ) ; if ( ! forkoff ) return - ENOSPC ; xfs_attr_shortform_add ( args , forkoff ) ; return 0 ; }
","<S2SV_ModStart> args ) ; if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> ; } if
",torvalds@linux/7b38460dc8e4eafba06c78f8e37099d3b34d473c,CVE-2018-18690,https://github.com/torvalds/linux/commit/7b38460dc8e4eafba06c78f8e37099d3b34d473c,2018-10-26T18:29Z,<S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug>
8298,CWE-20,"static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug>
5680,CWE-119,"static int search_impl ( i_ctx_t * i_ctx_p , bool forward ) { os_ptr op = osp ; os_ptr op1 = op - 1 ; uint size = r_size ( op ) ; uint count ; byte * pat ; byte * ptr ; byte ch ; int incr = forward ? 1 : - 1 ; check_read_type ( * op1 , t_string ) ; check_read_type ( * op , t_string ) ; if ( size > r_size ( op1 ) ) { make_false ( op ) ; return 0 ; } count = r_size ( op1 ) - size ; ptr = op1 -> value . bytes ; if ( size == 0 ) goto found ; if ( ! forward ) ptr += count ; pat = op -> value . bytes ; ch = pat [ 0 ] ; do { if ( * ptr == ch && ( size == 1 || ! memcmp ( ptr , pat , size ) ) ) goto found ; ptr += incr ; } while ( count -- ) ; make_false ( op ) ; return 0 ; found : op -> tas . type_attrs = op1 -> tas . type_attrs ; op -> value . bytes = ptr ; <S2SV_StartBug> r_set_size ( op , size ) ; <S2SV_EndBug> push ( 2 ) ; op [ - 1 ] = * op1 ; <S2SV_StartBug> r_set_size ( op - 1 , ptr - op [ - 1 ] . value . bytes ) ; <S2SV_EndBug> op1 -> value . bytes = ptr + size ; <S2SV_StartBug> r_set_size ( op1 , count + ( ! forward ? ( size - 1 ) : 0 ) ) ; <S2SV_EndBug> make_true ( op ) ; return 0 ; }
","<S2SV_ModStart> = ptr ; op -> tas . rsize = size <S2SV_ModEnd> ; push ( <S2SV_ModStart> * op1 ; op [ - 3 ] . <S2SV_ModEnd> value . bytes <S2SV_ModStart> + size ; if ( forward ) { op [ - 1 ] . tas . rsize = ptr - op [ - 1 ] . value . bytes ; op [ - 3 ] . tas . rsize = count ; } else { op [ - 1 ] . tas . rsize = count ; op [ - 3 ] . tas . rsize -= count + size ; } <S2SV_ModEnd> make_true ( op
",ArtifexSoftware@ghostpdl/5d499272b95a6b890a1397e11d20937de000d31b,CVE-2020-15900,https://github.com/ArtifexSoftware/ghostpdl/commit/5d499272b95a6b890a1397e11d20937de000d31b,2020-07-28T16:15Z,"<S2SV_StartBug> r_set_size ( op , size ) ; <S2SV_EndBug> <S2SV_StartBug> r_set_size ( op - 1 , ptr - op [ - 1 ] . value . bytes ) ; <S2SV_EndBug> <S2SV_StartBug> r_set_size ( op1 , count + ( ! forward ? ( size - 1 ) : 0 ) ) ; <S2SV_EndBug>"
8081,CWE-400,"<S2SV_StartBug> static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop ) <S2SV_EndBug> { struct evtchn_fifo_control_block * control_block ; unsigned long ready ; unsigned q ; control_block = per_cpu ( cpu_control_block , cpu ) ; ready = xchg ( & control_block -> ready , 0 ) ; while ( ready ) { q = find_first_bit ( & ready , EVTCHN_FIFO_MAX_QUEUES ) ; <S2SV_StartBug> consume_one_event ( cpu , control_block , q , & ready , drop ) ; <S2SV_EndBug> ready |= xchg ( & control_block -> ready , 0 ) ; } }
","<S2SV_ModStart> unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModEnd> ) { struct <S2SV_ModStart> ( cpu , ctrl , <S2SV_ModStart> , & ready <S2SV_ModEnd> ) ; ready
",torvalds@linux/e99502f76271d6bc4e374fe368c50c67a1fd3070,CVE-2020-27673,https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070,2020-10-22T21:15Z,"<S2SV_StartBug> static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop ) <S2SV_EndBug> <S2SV_StartBug> consume_one_event ( cpu , control_block , q , & ready , drop ) ; <S2SV_EndBug>"
6816,CWE-772,"static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , sequence , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; data = ( unsigned char * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . polarity = MagickFalse ; info . scale = ( Quantum * ) NULL ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . significant_bits = 0 ; info . rescale = MagickFalse ; info . rescale_intercept = 0.0 ; info . rescale_slope = 1.0 ; info . window_center = 0.0 ; info . window_width = 0.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; sequence = MagickFalse ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > GetBlobSize ( image ) ) <S2SV_StartBug> ThrowReaderException ( CorruptImageError , <S2SV_EndBug> ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( info . depth > 32 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( info . depth > 32 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; ( void ) ( ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( data <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> image ) ) ThrowDCMException <S2SV_ModEnd> ( CorruptImageError ,
",ImageMagick@ImageMagick/a33f7498f9052b50e8fe8c8422a11ba84474cb42,CVE-2017-12644,https://github.com/ImageMagick/ImageMagick/commit/a33f7498f9052b50e8fe8c8422a11ba84474cb42,2017-08-07T15:29Z,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( CorruptImageError , <S2SV_EndBug>"
1977,CWE-119,"vpx_codec_err_t vpx_svc_encode ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx , struct vpx_image * rawimg , vpx_codec_pts_t pts , int64_t duration , int deadline ) { vpx_codec_err_t res ; vpx_codec_iter_t iter ; const vpx_codec_cx_pkt_t * cx_pkt ; <S2SV_StartBug> struct LayerData * cx_layer_list = NULL ; <S2SV_EndBug> struct LayerData * layer_data ; struct Superframe superframe ; SvcInternal * const si = get_svc_internal ( svc_ctx ) ; if ( svc_ctx == NULL || codec_ctx == NULL || si == NULL ) { return VPX_CODEC_INVALID_PARAM ; } <S2SV_StartBug> memset ( & superframe , 0 , sizeof ( superframe ) ) ; <S2SV_EndBug> svc_log_reset ( svc_ctx ) ; si -> rc_stats_buf_used = 0 ; si -> layers = svc_ctx -> spatial_layers ; if ( si -> frame_within_gop >= si -> kf_dist || si -> encode_frame_count == 0 ) { si -> frame_within_gop = 0 ; } si -> is_keyframe = ( si -> frame_within_gop == 0 ) ; si -> frame_size = 0 ; if ( rawimg != NULL ) { svc_log ( svc_ctx , SVC_LOG_DEBUG , ""vpx_svc_encode<S2SV_blank><S2SV_blank>layers:<S2SV_blank>%d,<S2SV_blank>frame_count:<S2SV_blank>%d,<S2SV_blank>"" ""frame_within_gop:<S2SV_blank>%d\\n"" , si -> layers , si -> encode_frame_count , si -> frame_within_gop ) ; } for ( si -> layer = 0 ; si -> layer < si -> layers ; ++ si -> layer ) { if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && si -> is_keyframe && ( si -> layer == 1 || si -> layer == 3 ) ) { svc_log ( svc_ctx , SVC_LOG_DEBUG , ""Skip<S2SV_blank>encoding<S2SV_blank>layer<S2SV_blank>%d\\n"" , si -> layer ) ; continue ; } if ( rawimg != NULL ) { calculate_enc_frame_flags ( svc_ctx ) ; set_svc_parameters ( svc_ctx , codec_ctx ) ; } res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration , si -> enc_frame_flags , deadline ) ; if ( res != VPX_CODEC_OK ) { return res ; } iter = NULL ; while ( ( cx_pkt = vpx_codec_get_cx_data ( codec_ctx , & iter ) ) ) { switch ( cx_pkt -> kind ) { <S2SV_StartBug> case VPX_CODEC_CX_FRAME_PKT : { <S2SV_EndBug> const uint32_t frame_pkt_size = ( uint32_t ) ( cx_pkt -> data . frame . sz ) ; <S2SV_StartBug> si -> bytes_sum [ si -> layer ] += frame_pkt_size ; <S2SV_EndBug> svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>size:<S2SV_blank>%u\\n"" , si -> encode_frame_count , si -> layer , frame_pkt_size ) ; layer_data = ld_create ( cx_pkt -> data . frame . buf , ( size_t ) frame_pkt_size ) ; if ( layer_data == NULL ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""Error<S2SV_blank>allocating<S2SV_blank>LayerData\\n"" ) ; return VPX_CODEC_OK ; } <S2SV_StartBug> ld_list_add ( & cx_layer_list , layer_data ) ; <S2SV_EndBug> superframe . sizes [ superframe . count ++ ] = frame_pkt_size ; superframe . magnitude |= frame_pkt_size ; break ; } case VPX_CODEC_PSNR_PKT : { int i ; svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>PSNR(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n"" , si -> encode_frame_count , si -> layer , cx_pkt -> data . psnr . psnr [ 0 ] , cx_pkt -> data . psnr . psnr [ 1 ] , cx_pkt -> data . psnr . psnr [ 2 ] , cx_pkt -> data . psnr . psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>SSE(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n"" , si -> encode_frame_count , si -> layer , cx_pkt -> data . psnr . sse [ 0 ] , cx_pkt -> data . psnr . sse [ 1 ] , cx_pkt -> data . psnr . sse [ 2 ] , cx_pkt -> data . psnr . sse [ 3 ] ) ; for ( i = 0 ; i < COMPONENTS ; i ++ ) { si -> psnr_sum [ si -> layer ] [ i ] += cx_pkt -> data . psnr . psnr [ i ] ; si -> sse_sum [ si -> layer ] [ i ] += cx_pkt -> data . psnr . sse [ i ] ; } break ; } case VPX_CODEC_STATS_PKT : { size_t new_size = si -> rc_stats_buf_used + cx_pkt -> data . twopass_stats . sz ; if ( new_size > si -> rc_stats_buf_size ) { char * p = ( char * ) realloc ( si -> rc_stats_buf , new_size ) ; if ( p == NULL ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""Error<S2SV_blank>allocating<S2SV_blank>stats<S2SV_blank>buf\\n"" ) ; break ; } si -> rc_stats_buf = p ; si -> rc_stats_buf_size = new_size ; } memcpy ( si -> rc_stats_buf + si -> rc_stats_buf_used , cx_pkt -> data . twopass_stats . buf , cx_pkt -> data . twopass_stats . sz ) ; si -> rc_stats_buf_used += cx_pkt -> data . twopass_stats . sz ; break ; } default : { break ; } } } if ( rawimg == NULL ) { break ; } } if ( codec_ctx -> config . enc -> g_pass != VPX_RC_FIRST_PASS ) { sf_create_index ( & superframe ) ; layer_data = ld_create ( superframe . buffer , superframe . index_size ) ; ld_list_add ( & cx_layer_list , layer_data ) ; si -> frame_size = ld_list_get_buffer_size ( cx_layer_list ) ; if ( si -> frame_size > 0 ) { if ( si -> frame_size > si -> buffer_size ) { free ( si -> buffer ) ; si -> buffer = malloc ( si -> frame_size ) ; if ( si -> buffer == NULL ) { ld_list_free ( cx_layer_list ) ; return VPX_CODEC_MEM_ERROR ; } si -> buffer_size = si -> frame_size ; } ld_list_copy_to_buffer ( cx_layer_list , ( uint8_t * ) si -> buffer ) ; ld_list_free ( cx_layer_list ) ; svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>kf:<S2SV_blank>%d,<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>"" ""pts:<S2SV_blank>%d\\n"" , si -> encode_frame_count , si -> is_keyframe , ( int ) si -> frame_size , ( int ) pts ) ; } } ++ si -> frame_within_gop ; ++ si -> encode_frame_count ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> * cx_pkt ; SvcInternal_t <S2SV_ModEnd> * const si <S2SV_ModStart> VPX_CODEC_INVALID_PARAM ; } svc_log_reset ( svc_ctx ) ; res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , <S2SV_ModEnd> deadline ) ; <S2SV_ModStart> kind ) { # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC case VPX_CODEC_SPATIAL_SVC_LAYER_PSNR : { int i ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { int j ; svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>PSNR(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n"" , si -> psnr_pkt_received , i , cx_pkt -> data . layer_psnr [ i ] . psnr [ 0 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 1 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 2 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>SSE(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n"" , si -> psnr_pkt_received , i , cx_pkt -> data . layer_psnr [ i ] . sse [ 0 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 1 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 2 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 3 ] ) ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] += cx_pkt -> data . layer_psnr [ i ] . psnr [ j ] ; si -> sse_sum [ i ] [ j ] += cx_pkt -> data . layer_psnr [ i ] . sse [ j ] ; } } ++ si -> psnr_pkt_received ; break ; } case VPX_CODEC_SPATIAL_SVC_LAYER_SIZES : { int i ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) <S2SV_ModEnd> si -> bytes_sum <S2SV_ModStart> -> bytes_sum [ i ] += cx_pkt -> data . layer_sizes [ i ] ; break ; } # endif # endif default : { break ; } } } <S2SV_ModEnd> return VPX_CODEC_OK ; <S2SV_ModStart> VPX_CODEC_OK ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> struct LayerData * cx_layer_list = NULL ; <S2SV_EndBug> <S2SV_StartBug> memset ( & superframe , 0 , sizeof ( superframe ) ) ; <S2SV_EndBug> <S2SV_StartBug> case VPX_CODEC_CX_FRAME_PKT : { <S2SV_EndBug> <S2SV_StartBug> si -> bytes_sum [ si -> layer ] += frame_pkt_size ; <S2SV_EndBug> <S2SV_StartBug> ld_list_add ( & cx_layer_list , layer_data ) ; <S2SV_EndBug>"
3651,CWE-190,"static int jpc_dec_process_siz ( jpc_dec_t * dec , jpc_ms_t * ms ) { jpc_siz_t * siz = & ms -> parms . siz ; int compno ; int tileno ; jpc_dec_tile_t * tile ; jpc_dec_tcomp_t * tcomp ; int htileno ; int vtileno ; jpc_dec_cmpt_t * cmpt ; <S2SV_StartBug> dec -> xstart = siz -> xoff ; <S2SV_EndBug> dec -> ystart = siz -> yoff ; dec -> xend = siz -> width ; dec -> yend = siz -> height ; dec -> tilewidth = siz -> tilewidth ; dec -> tileheight = siz -> tileheight ; dec -> tilexoff = siz -> tilexoff ; dec -> tileyoff = siz -> tileyoff ; dec -> numcomps = siz -> numcomps ; if ( ! ( dec -> cp = jpc_dec_cp_create ( dec -> numcomps ) ) ) { return - 1 ; } if ( ! ( dec -> cmpts = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_cmpt_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ cmpt ) { cmpt -> prec = siz -> comps [ compno ] . prec ; cmpt -> sgnd = siz -> comps [ compno ] . sgnd ; cmpt -> hstep = siz -> comps [ compno ] . hsamp ; cmpt -> vstep = siz -> comps [ compno ] . vsamp ; cmpt -> width = JPC_CEILDIV ( dec -> xend , cmpt -> hstep ) - JPC_CEILDIV ( dec -> xstart , cmpt -> hstep ) ; cmpt -> height = JPC_CEILDIV ( dec -> yend , cmpt -> vstep ) - JPC_CEILDIV ( dec -> ystart , cmpt -> vstep ) ; cmpt -> hsubstep = 0 ; cmpt -> vsubstep = 0 ; } dec -> image = 0 ; dec -> numhtiles = JPC_CEILDIV ( dec -> xend - dec -> tilexoff , dec -> tilewidth ) ; dec -> numvtiles = JPC_CEILDIV ( dec -> yend - dec -> tileyoff , dec -> tileheight ) ; <S2SV_StartBug> dec -> numtiles = dec -> numhtiles * dec -> numvtiles ; <S2SV_EndBug> JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n"" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; } <S2SV_StartBug> for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno , <S2SV_EndBug> ++ tile ) { htileno = tileno % dec -> numhtiles ; vtileno = tileno / dec -> numhtiles ; tile -> realmode = 0 ; tile -> state = JPC_TILE_INIT ; tile -> xstart = JAS_MAX ( dec -> tilexoff + htileno * dec -> tilewidth , dec -> xstart ) ; tile -> ystart = JAS_MAX ( dec -> tileyoff + vtileno * dec -> tileheight , dec -> ystart ) ; tile -> xend = JAS_MIN ( dec -> tilexoff + ( htileno + 1 ) * dec -> tilewidth , dec -> xend ) ; tile -> yend = JAS_MIN ( dec -> tileyoff + ( vtileno + 1 ) * dec -> tileheight , dec -> yend ) ; tile -> numparts = 0 ; tile -> partno = 0 ; tile -> pkthdrstream = 0 ; tile -> pkthdrstreampos = 0 ; tile -> pptstab = 0 ; tile -> cp = 0 ; tile -> pi = 0 ; if ( ! ( tile -> tcomps = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_tcomp_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ cmpt , ++ tcomp ) { tcomp -> rlvls = 0 ; tcomp -> numrlvls = 0 ; tcomp -> data = 0 ; tcomp -> xstart = JPC_CEILDIV ( tile -> xstart , cmpt -> hstep ) ; tcomp -> ystart = JPC_CEILDIV ( tile -> ystart , cmpt -> vstep ) ; tcomp -> xend = JPC_CEILDIV ( tile -> xend , cmpt -> hstep ) ; tcomp -> yend = JPC_CEILDIV ( tile -> yend , cmpt -> vstep ) ; tcomp -> tsfb = 0 ; } } dec -> pkthdrstreams = 0 ; dec -> state = JPC_MH ; return 0 ; }
","<S2SV_ModStart> * cmpt ; size_t size ; <S2SV_ModStart> tileheight ) ; if ( ! jas_safe_size_mul ( <S2SV_ModEnd> dec -> numhtiles <S2SV_ModStart> dec -> numhtiles , <S2SV_ModEnd> dec -> numvtiles <S2SV_ModStart> dec -> numvtiles , & size <S2SV_ModEnd> ) ) { <S2SV_ModStart> 1 ; } dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n"" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; }
",mdadams@jasper/d91198abd00fc435a397fe6bad906a4c1748e9cf,CVE-2016-9387,https://github.com/mdadams/jasper/commit/d91198abd00fc435a397fe6bad906a4c1748e9cf,2017-03-23T18:59Z,"<S2SV_StartBug> dec -> xstart = siz -> xoff ; <S2SV_EndBug> <S2SV_StartBug> dec -> numtiles = dec -> numhtiles * dec -> numvtiles ; <S2SV_EndBug> <S2SV_StartBug> for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno , <S2SV_EndBug>"
36,CWE-416,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } quantum_info = ( QuantumInfo * ) NULL ; clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) { MATLAB_KO : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) { clone_info = DestroyImageInfo ( clone_info ) ; continue ; } MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : <S2SV_StartBug> if ( clone_info ) <S2SV_EndBug> clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; <S2SV_StartBug> DeleteImageFromList ( & tmp ) ; <S2SV_EndBug> } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) else if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; return ( image ) ; }
","<S2SV_ModStart> ; END_OF_READING : <S2SV_ModEnd> CloseBlob ( image <S2SV_ModStart> -> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ;
",ImageMagick@ImageMagick/04178de2247e353fc095846784b9a10fefdbf890,CVE-2017-12877,https://github.com/ImageMagick/ImageMagick/commit/04178de2247e353fc095846784b9a10fefdbf890,2017-08-28T19:29Z,<S2SV_StartBug> if ( clone_info ) <S2SV_EndBug> <S2SV_StartBug> DeleteImageFromList ( & tmp ) ; <S2SV_EndBug>
5398,CWE-787,"static PyObject * patch ( PyObject * self , PyObject * args ) { char * origData , * newData , * diffBlock , * extraBlock , * diffPtr , * extraPtr ; Py_ssize_t origDataLength , newDataLength , diffBlockLength , extraBlockLength ; PyObject * controlTuples , * tuple , * results ; off_t oldpos , newpos , x , y , z ; int i , j , numTuples ; if ( ! PyArg_ParseTuple ( args , ""s#nO!s#s#"" , & origData , & origDataLength , & newDataLength , & PyList_Type , & controlTuples , & diffBlock , & diffBlockLength , & extraBlock , & extraBlockLength ) ) return NULL ; newData = PyMem_Malloc ( newDataLength + 1 ) ; if ( ! newData ) return PyErr_NoMemory ( ) ; oldpos = 0 ; newpos = 0 ; diffPtr = diffBlock ; extraPtr = extraBlock ; numTuples = PyList_GET_SIZE ( controlTuples ) ; for ( i = 0 ; i < numTuples ; i ++ ) { tuple = PyList_GET_ITEM ( controlTuples , i ) ; if ( ! PyTuple_Check ( tuple ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple"" ) ; return NULL ; } if ( PyTuple_GET_SIZE ( tuple ) != 3 ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple<S2SV_blank>of<S2SV_blank>size<S2SV_blank>3"" ) ; return NULL ; } x = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 0 ) ) ; y = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 1 ) ) ; z = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 2 ) ) ; if ( newpos + x > newDataLength || <S2SV_StartBug> diffPtr + x > diffBlock + diffBlockLength || <S2SV_EndBug> extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } <S2SV_StartBug> memcpy ( newData + newpos , diffPtr , x ) ; <S2SV_EndBug> diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; memcpy ( newData + newpos , extraPtr , y ) ; extraPtr += y ; newpos += y ; oldpos += z ; } if ( newpos != newDataLength || diffPtr != diffBlock + diffBlockLength || extraPtr != extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(underflow)"" ) ; return NULL ; } results = PyBytes_FromStringAndSize ( newData , newDataLength ) ; PyMem_Free ( newData ) ; return results ; }
","<S2SV_ModStart> diffBlock + diffBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } memcpy ( newData + newpos , diffPtr , x ) ; diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; if ( newpos + y > newDataLength <S2SV_ModStart> NULL ; } <S2SV_ModEnd> memcpy ( newData
",ilanschnell@bsdiff4/49a4cee2feef7deaf9d89e5e793a8824930284d7,CVE-2020-15904,https://github.com/ilanschnell/bsdiff4/commit/49a4cee2feef7deaf9d89e5e793a8824930284d7,2020-07-22T23:15Z,"<S2SV_StartBug> diffPtr + x > diffBlock + diffBlockLength || <S2SV_EndBug> <S2SV_StartBug> memcpy ( newData + newpos , diffPtr , x ) ; <S2SV_EndBug>"
7793,CWE-125,"static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n0 , asdl_seq * decorator_seq , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; int end_lineno , end_col_offset ; <S2SV_StartBug> REQ ( n , funcdef ) ; <S2SV_EndBug> name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } <S2SV_StartBug> body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; <S2SV_EndBug> if ( ! body ) return NULL ; get_last_end_pos ( body , & end_lineno , & end_col_offset ) ; <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return FunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> , end_col_offset ; node * tc ; string type_comment = NULL ; <S2SV_ModStart> 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; if ( ! type_comment ) return NULL ; name_i += 1 ; } <S2SV_ModStart> ; if ( NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) { if ( type_comment != NULL ) { ast_error ( c , n , ""Cannot<S2SV_blank>have<S2SV_blank>two<S2SV_blank>type<S2SV_blank>comments<S2SV_blank>on<S2SV_blank>def"" ) ; return NULL ; } type_comment = NEW_TYPE_COMMENT ( tc ) ; if ( ! type_comment ) return NULL ; } } if ( <S2SV_ModStart> decorator_seq , returns , type_comment <S2SV_ModStart> , returns , type_comment ,
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> REQ ( n , funcdef ) ; <S2SV_EndBug> <S2SV_StartBug> body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> <S2SV_StartBug> return FunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug>"
4772,CWE-119,"void l2tp_packet_print ( const struct l2tp_packet_t * pack , void ( * print ) ( const char * fmt , ... ) ) { const struct l2tp_attr_t * attr ; const struct l2tp_dict_value_t * val ; <S2SV_StartBug> if ( pack -> hdr . ver == 2 ) { <S2SV_EndBug> print ( ""[L2TP<S2SV_blank>tid=%u<S2SV_blank>sid=%u"" , ntohs ( pack -> hdr . tid ) , ntohs ( pack -> hdr . sid ) ) ; log_ppp_debug ( ""<S2SV_blank>Ns=%u<S2SV_blank>Nr=%u"" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ; <S2SV_StartBug> } else { <S2SV_EndBug> print ( ""[L2TP<S2SV_blank>cid=%u"" , pack -> hdr . cid ) ; <S2SV_StartBug> log_ppp_debug ( ""<S2SV_blank>Ns=%u<S2SV_blank>Nr=%u"" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ; <S2SV_EndBug> } list_for_each_entry ( attr , & pack -> attrs , entry ) { print ( ""<S2SV_blank><%s"" , attr -> attr -> name ) ; val = l2tp_dict_find_value ( attr -> attr , attr -> val ) ; if ( val ) print ( ""<S2SV_blank>%s"" , val -> name ) ; else if ( attr -> H ) print ( ""<S2SV_blank>(hidden,<S2SV_blank>%hu<S2SV_blank>bytes)"" , attr -> length ) ; else { switch ( attr -> attr -> type ) { case ATTR_TYPE_INT16 : print ( ""<S2SV_blank>%i"" , attr -> val . int16 ) ; break ; case ATTR_TYPE_INT32 : print ( ""<S2SV_blank>%i"" , attr -> val . int32 ) ; break ; case ATTR_TYPE_STRING : print ( ""<S2SV_blank>%s"" , attr -> val . string ) ; break ; } } print ( "">"" ) ; } print ( ""]\\n"" ) ; }
","<S2SV_ModStart> * val ; switch ( pack -> hdr . flags & L2TP_VER_MASK ) { case 2 : <S2SV_ModEnd> print ( ""[L2TP<S2SV_blank>tid=%u<S2SV_blank>sid=%u"" <S2SV_ModStart> ) ) ; break ; case 3 : <S2SV_ModEnd> print ( ""[L2TP<S2SV_blank>cid=%u"" <S2SV_ModStart> Nr ) ) ; break ; default : print ( ""[L2TP<S2SV_blank>unknown<S2SV_blank>version]\\n"" ) ; return
",accel-ppp@accel-ppp/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,CVE-2020-15173,https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,2020-09-09T23:15Z,"<S2SV_StartBug> if ( pack -> hdr . ver == 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> log_ppp_debug ( ""<S2SV_blank>Ns=%u<S2SV_blank>Nr=%u"" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ; <S2SV_EndBug>"
3272,CWE-125,"static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4"" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%lu"" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>Object<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%s"" , ident , tok2str ( rsvp_obj_values , ""Unknown"" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? ""ignore"" : ""reject"" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? ""and<S2SV_blank>forward"" : ""silently"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>if<S2SV_blank>unknown],<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( rsvp_ctype_values , ""Unknown"" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>objects<S2SV_blank>TLV"" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u"" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u"" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Generalized<S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Waveband<S2SV_blank>ID:<S2SV_blank>%u%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>Label:<S2SV_blank>%u,<S2SV_blank>Stop<S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Reservation<S2SV_blank>Style:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]"" , ident , tok2str ( rsvp_resstyle_values , ""Unknown"" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "",%s<S2SV_blank>merge<S2SV_blank>capability"" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? ""no"" : """" ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Minimum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Maximum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Minimum/Maximum<S2SV_blank>DLCI:<S2SV_blank>%u/%u,<S2SV_blank>%s%s<S2SV_blank>bit<S2SV_blank>DLCI"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? ""10"" : """" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? ""23"" : """" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>LSP<S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , tok2str ( gmpls_encoding_values , ""Unknown"" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Payload<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_xro_values , ""Unknown<S2SV_blank>%u"" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>ERROR:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>ERO<S2SV_blank>subtype"" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>Prefix<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>32"" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , "",<S2SV_blank>%s,<S2SV_blank>%s/%u,<S2SV_blank>Flags:<S2SV_blank>[%s]"" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? ""Loose"" : ""Strict"" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , ""none"" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%u"" , bittok2str ( rsvp_obj_rro_label_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , ""Unknown"" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Instance:<S2SV_blank>0x%08x,<S2SV_blank>Destination<S2SV_blank>Instance:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Restart<S2SV_blank><S2SV_blank>Time:<S2SV_blank>%ums,<S2SV_blank>Recovery<S2SV_blank>Time:<S2SV_blank>%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Session<S2SV_blank>Name:<S2SV_blank>"" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x)"" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) { if ( total_subobj_len < 4 ) goto invalid ; subobj_len = EXTRACT_16BITS ( obj_tptr ) ; subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>AF:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_generalized_uni_values , ""Unknown"" , subobj_type ) , subobj_type , tok2str ( af_values , ""Unknown"" , af ) , af , subobj_len ) ) ; if ( subobj_len < 4 || subobj_len > total_subobj_len ) goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv4<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv6<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U-bit:<S2SV_blank>%x,<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u,<S2SV_blank>Logical<S2SV_blank>port<S2SV_blank>id:<S2SV_blank>%u,<S2SV_blank>Label:<S2SV_blank>%u"" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Service<S2SV_blank>level:<S2SV_blank>%u"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Refresh<S2SV_blank>Period:<S2SV_blank>%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Msg-Version:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Service<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>break<S2SV_blank>bit<S2SV_blank>%s<S2SV_blank>set,<S2SV_blank>Service<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_intserv_service_type_values , ""unknown"" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? """" : ""not"" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flow<S2SV_blank>Label:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Include-any:<S2SV_blank>0x%08x,<S2SV_blank>Exclude-any:<S2SV_blank>0x%08x,<S2SV_blank>Include-all:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Include<S2SV_blank>Colors:<S2SV_blank>0x%08x,<S2SV_blank>Exclude<S2SV_blank>Colors:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>PLR-ID:<S2SV_blank>%s,<S2SV_blank>Avoid-Node-ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u"" , <S2SV_EndBug> ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_diffserv_te_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>Unknown<S2SV_blank>Error<S2SV_blank>Value<S2SV_blank>(%u)"" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>TLV<S2SV_blank>count:<S2SV_blank>%u,<S2SV_blank>padding<S2SV_blank>bytes:<S2SV_blank>%u"" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%02x),<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_prop_tlv_values , ""unknown"" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , ""\\n\\t\\t"" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[0x%02x],<S2SV_blank>epoch:<S2SV_blank>%u"" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message-ID<S2SV_blank>0x%08x<S2SV_blank>(%u)"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Key-ID<S2SV_blank>0x%04x%08x,<S2SV_blank>Sequence<S2SV_blank>0x%08x%08x,<S2SV_blank>Flags<S2SV_blank>[%s]"" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , ""none"" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>MD5-sum<S2SV_blank>0x%08x%08x%08x%08x<S2SV_blank>"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , tok2str ( signature_check_values , ""Unknown"" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[%s]"" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Action:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_label_set_action_values , ""Unknown"" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>range:<S2SV_blank>%u,<S2SV_blank>End<S2SV_blank>range:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subchannel<S2SV_blank>#%u:<S2SV_blank>%u"" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return - 1 ; }
","<S2SV_ModStart> case RSVP_CTYPE_1 : ND_TCHECK_32BITS ( obj_tptr ) ;
",the-tcpdump-group@tcpdump/bea2686c296b79609060a104cc139810785b0739,CVE-2018-14465,https://github.com/the-tcpdump-group/tcpdump/commit/bea2686c296b79609060a104cc139810785b0739,2019-10-03T16:15Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u"" , <S2SV_EndBug>"
2167,CWE-119,"static int fallocate_chunk ( struct inode * inode , loff_t offset , loff_t len , int mode ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct buffer_head * dibh ; int error ; <S2SV_StartBug> u64 start = offset >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> unsigned int start_offset = offset & ~ PAGE_CACHE_MASK ; <S2SV_StartBug> u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> pgoff_t curr ; struct page * page ; unsigned int end_offset = ( offset + len ) & ~ PAGE_CACHE_MASK ; unsigned int from , to ; if ( ! end_offset ) end_offset = PAGE_CACHE_SIZE ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) goto out ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } curr = start ; offset = start << PAGE_CACHE_SHIFT ; from = start_offset ; to = PAGE_CACHE_SIZE ; while ( curr <= end ) { page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ; if ( unlikely ( ! page ) ) { error = - ENOMEM ; goto out ; } if ( curr == end ) to = end_offset ; error = write_empty_blocks ( page , from , to , mode ) ; if ( ! error && offset + to > inode -> i_size && <S2SV_StartBug> ! ( mode & FALLOC_FL_KEEP_SIZE ) ) { <S2SV_EndBug> <S2SV_StartBug> i_size_write ( inode , offset + to ) ; <S2SV_EndBug> } unlock_page ( page ) ; page_cache_release ( page ) ; if ( error ) goto out ; curr ++ ; offset += PAGE_CACHE_SIZE ; from = 0 ; } <S2SV_StartBug> mark_inode_dirty ( inode ) ; <S2SV_EndBug> brelse ( dibh ) ; out : <S2SV_StartBug> return error ; <S2SV_EndBug> }
","<S2SV_ModStart> int error ; unsigned int nr_blks ; sector_t lblock <S2SV_ModEnd> = offset >> <S2SV_ModStart> = offset >> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if <S2SV_ModEnd> ( offset + <S2SV_ModStart> offset + len <S2SV_ModEnd> > inode -> <S2SV_ModStart> FALLOC_FL_KEEP_SIZE ) ) <S2SV_ModEnd> i_size_write ( inode <S2SV_ModStart> , offset + len ) ; <S2SV_ModEnd> mark_inode_dirty ( inode <S2SV_ModStart> mark_inode_dirty ( inode <S2SV_ModEnd> ) ; out <S2SV_ModStart> ; out : brelse ( dibh ) ;
",torvalds@linux/64dd153c83743af81f20924c6343652d731eeecb,CVE-2011-4098,https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb,2013-06-08T13:05Z,"<S2SV_StartBug> u64 start = offset >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> ! ( mode & FALLOC_FL_KEEP_SIZE ) ) { <S2SV_EndBug> <S2SV_StartBug> i_size_write ( inode , offset + to ) ; <S2SV_EndBug> <S2SV_StartBug> mark_inode_dirty ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> return error ; <S2SV_EndBug>"
344,CWE-704,"static void merge_param ( HashTable * params , zval * zdata , zval * * * current_param , zval * * * current_args TSRMLS_DC ) { zval * * ptr , * * zdata_ptr ; php_http_array_hashkey_t hkey = php_http_array_hashkey_init ( 0 ) ; # if 0 { zval tmp ; INIT_PZVAL_ARRAY ( & tmp , params ) ; fprintf ( stderr , ""params<S2SV_blank>=<S2SV_blank>"" ) ; zend_print_zval_r ( & tmp , 1 TSRMLS_CC ) ; fprintf ( stderr , ""\\n"" ) ; } # endif hkey . type = zend_hash_get_current_key_ex ( Z_ARRVAL_P ( zdata ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ; if ( ( hkey . type == HASH_KEY_IS_STRING && ! zend_hash_exists ( params , hkey . str , hkey . len ) ) || ( hkey . type == HASH_KEY_IS_LONG && ! zend_hash_index_exists ( params , hkey . num ) ) ) { zval * tmp , * arg , * * args ; zend_hash_get_current_data ( Z_ARRVAL_P ( zdata ) , ( void * ) & ptr ) ; Z_ADDREF_PP ( ptr ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( tmp , ZEND_STRS ( ""value"" ) , * ptr ) ; MAKE_STD_ZVAL ( arg ) ; array_init ( arg ) ; zend_hash_update ( Z_ARRVAL_P ( tmp ) , ""arguments"" , sizeof ( ""arguments"" ) , ( void * ) & arg , sizeof ( zval * ) , ( void * ) & args ) ; * current_args = args ; if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_update ( params , hkey . str , hkey . len , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_index_update ( params , hkey . num , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } } else { if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_find ( params , hkey . str , hkey . len , ( void * ) & ptr ) ; } else { zend_hash_index_find ( params , hkey . num , ( void * ) & ptr ) ; } zdata_ptr = & zdata ; if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) { zval * * test_ptr ; while ( Z_TYPE_PP ( zdata_ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & test_ptr ) ) { <S2SV_StartBug> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <S2SV_EndBug> if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { if ( SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } else { if ( SUCCESS == zend_hash_index_find ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else if ( hkey . num ) { Z_ADDREF_PP ( test_ptr ) ; zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } } else { Z_ADDREF_PP ( test_ptr ) ; if ( Z_TYPE_PP ( ptr ) != IS_ARRAY ) { zval_dtor ( * ptr ) ; array_init ( * ptr ) ; } if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else if ( hkey . num ) { zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } break ; } } } } while ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( ptr ) , ( void * ) & ptr ) ) ; * current_param = ptr ; }
","<S2SV_ModStart> ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY
",m6w6@ext-http/17137d4ab1ce81a2cee0fae842340a344ef3da83,CVE-2016-7398,https://github.com/m6w6/ext-http/commit/17137d4ab1ce81a2cee0fae842340a344ef3da83,2019-09-06T19:15Z,<S2SV_StartBug> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <S2SV_EndBug>
3608,CWE-264,"static __inline__ int scm_check_creds ( struct ucred * creds ) { const struct cred * cred = current_cred ( ) ; kuid_t uid = make_kuid ( cred -> user_ns , creds -> uid ) ; kgid_t gid = make_kgid ( cred -> user_ns , creds -> gid ) ; if ( ! uid_valid ( uid ) || ! gid_valid ( gid ) ) return - EINVAL ; if ( ( creds -> pid == task_tgid_vnr ( current ) || <S2SV_StartBug> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) { return 0 ; } return - EPERM ; }
","<S2SV_ModStart> || ns_capable ( task_active_pid_ns ( current ) <S2SV_ModEnd> -> user_ns ,
",torvalds@linux/d661684cf6820331feae71146c35da83d794467e,CVE-2013-4300,https://github.com/torvalds/linux/commit/d661684cf6820331feae71146c35da83d794467e,2013-09-25T10:31Z,"<S2SV_StartBug> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && <S2SV_EndBug>"
2877,CWE-310,"static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> skb ) { strncpy ( <S2SV_ModEnd> ualg -> cru_name <S2SV_ModStart> -> cru_name , <S2SV_ModEnd> alg -> cra_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_driver_name <S2SV_ModStart> -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name <S2SV_ModStart> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . <S2SV_ModStart> . type , ""larval"" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if
",torvalds@linux/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,CVE-2013-2548,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,2013-03-15T20:55Z,"<S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ; <S2SV_EndBug>"
2210,CWE-200,"static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , struct vsock_sock * vsk , struct msghdr * msg , size_t len , int flags ) { int err ; int noblock ; struct vmci_datagram * dg ; size_t payload_len ; struct sk_buff * skb ; noblock = flags & MSG_DONTWAIT ; if ( flags & MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ; <S2SV_StartBug> err = 0 ; <S2SV_EndBug> skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; if ( err ) return err ; if ( ! skb ) return - EAGAIN ; dg = ( struct vmci_datagram * ) skb -> data ; if ( ! dg ) goto out ; payload_len = dg -> payload_size ; if ( payload_len != skb -> len - sizeof ( * dg ) ) { err = - EINVAL ; goto out ; } if ( payload_len > len ) { payload_len = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ; if ( err ) goto out ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> if ( msg -> msg_name ) { struct sockaddr_vm * vm_addr ; vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; msg -> msg_namelen = sizeof ( * vm_addr ) ; } err = payload_len ; out : skb_free_datagram ( & vsk -> sk , skb ) ; return err ; }
","<S2SV_ModStart> - EOPNOTSUPP ; msg -> msg_namelen = 0 ; <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( msg
",torvalds@linux/680d04e0ba7e926233e3b9cee59125ce181f66ba,CVE-2013-3236,https://github.com/torvalds/linux/commit/680d04e0ba7e926233e3b9cee59125ce181f66ba,2013-04-22T11:41Z,<S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug>
3946,CWE-476,"static int tls_construct_cke_ecdhe ( SSL * s , unsigned char * * p , int * len , int * al ) { # ifndef OPENSSL_NO_EC unsigned char * encodedPoint = NULL ; int encoded_pt_len = 0 ; EVP_PKEY * ckey = NULL , * skey = NULL ; skey = s -> s3 -> peer_tmp ; if ( skey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; } ckey = ssl_generate_pkey ( skey ) ; <S2SV_StartBug> if ( ssl_derive ( s , ckey , skey ) == 0 ) { <S2SV_EndBug> SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EVP_LIB ) ; goto err ; } encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint ( ckey , & encodedPoint ) ; if ( encoded_pt_len == 0 ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EC_LIB ) ; goto err ; } EVP_PKEY_free ( ckey ) ; ckey = NULL ; * len = encoded_pt_len ; * * p = * len ; * p += 1 ; memcpy ( * p , encodedPoint , * len ) ; * len += 1 ; OPENSSL_free ( encodedPoint ) ; return 1 ; err : EVP_PKEY_free ( ckey ) ; return 0 ; # else SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; # endif }
","<S2SV_ModStart> ; if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if (
",openssl@openssl/efbe126e3ebb9123ac9d058aa2bb044261342aaa,CVE-2017-3730,https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa,2017-05-04T19:29Z,"<S2SV_StartBug> if ( ssl_derive ( s , ckey , skey ) == 0 ) { <S2SV_EndBug>"
2412,CWE-119,"IMPEG2D_ERROR_CODES_T impeg2d_dec_p_b_slice ( dec_state_t * ps_dec ) { WORD16 * pi2_vld_out ; UWORD32 i ; yuv_buf_t * ps_cur_frm_buf = & ps_dec -> s_cur_frm_buf ; UWORD32 u4_frm_offset = 0 ; const dec_mb_params_t * ps_dec_mb_params ; IMPEG2D_ERROR_CODES_T e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; pi2_vld_out = ps_dec -> ai2_vld_buf ; memset ( ps_dec -> ai2_pred_mv , 0 , sizeof ( ps_dec -> ai2_pred_mv ) ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_first_mb = 1 ; ps_dec -> u2_picture_width = ps_dec -> u2_frame_width ; if ( ps_dec -> u2_picture_structure != FRAME_PICTURE ) { ps_dec -> u2_picture_width <<= 1 ; if ( ps_dec -> u2_picture_structure == BOTTOM_FIELD ) { u4_frm_offset = ps_dec -> u2_frame_width ; } } do { UWORD32 u4_x_offset , u4_y_offset ; WORD32 ret ; UWORD32 u4_x_dst_offset = 0 ; UWORD32 u4_y_dst_offset = 0 ; UWORD8 * pu1_out_p ; UWORD8 * pu1_pred ; WORD32 u4_pred_strd ; IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ; if ( ps_dec -> e_pic_type == B_PIC ) ret = impeg2d_dec_pnb_mb_params ( ps_dec ) ; else ret = impeg2d_dec_p_mb_params ( ps_dec ) ; if ( ret ) <S2SV_StartBug> return IMPEG2D_MB_TEX_DECODE_ERR ; <S2SV_EndBug> IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ; u4_x_dst_offset = u4_frm_offset + ( ps_dec -> u2_mb_x << 4 ) ; u4_y_dst_offset = ( ps_dec -> u2_mb_y << 4 ) * ps_dec -> u2_picture_width ; pu1_out_p = ps_cur_frm_buf -> pu1_y + u4_x_dst_offset + u4_y_dst_offset ; if ( ps_dec -> u2_prev_intra_mb == 0 ) { UWORD32 offset_x , offset_y , stride ; UWORD16 index = ( ps_dec -> u2_motion_type ) ; if ( ps_dec -> e_mb_pred == BIDIRECT ) { ps_dec_mb_params = & ps_dec -> ps_func_bi_direct [ index ] ; } else { ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ index ] ; } stride = ps_dec -> u2_picture_width ; offset_x = u4_frm_offset + ( ps_dec -> u2_mb_x << 4 ) ; offset_y = ( ps_dec -> u2_mb_y << 4 ) ; ps_dec -> s_dest_buf . pu1_y = ps_cur_frm_buf -> pu1_y + offset_y * stride + offset_x ; stride = stride >> 1 ; ps_dec -> s_dest_buf . pu1_u = ps_cur_frm_buf -> pu1_u + ( offset_y >> 1 ) * stride + ( offset_x >> 1 ) ; ps_dec -> s_dest_buf . pu1_v = ps_cur_frm_buf -> pu1_v + ( offset_y >> 1 ) * stride + ( offset_x >> 1 ) ; PROFILE_DISABLE_MC_IF0 ps_dec_mb_params -> pf_mc ( ps_dec ) ; } for ( i = 0 ; i < NUM_LUMA_BLKS ; ++ i ) { if ( ( ps_dec -> u2_cbp & ( 1 << ( BLOCKS_IN_MB - 1 - i ) ) ) != 0 ) { e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , Y_LUMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } u4_x_offset = gai2_impeg2_blk_x_off [ i ] ; if ( ps_dec -> u2_field_dct == 0 ) u4_y_offset = gai2_impeg2_blk_y_off_frm [ i ] ; else u4_y_offset = gai2_impeg2_blk_y_off_fld [ i ] ; IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p + u4_y_offset * ps_dec -> u2_picture_width + u4_x_offset ; u4_pred_strd = ps_dec -> u2_picture_width << ps_dec -> u2_field_dct ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p + u4_y_offset * ps_dec -> u2_picture_width + u4_x_offset , 8 , u4_pred_strd , ps_dec -> u2_picture_width << ps_dec -> u2_field_dct , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } } u4_x_dst_offset >>= 1 ; u4_y_dst_offset >>= 2 ; if ( ( ps_dec -> u2_cbp & 0x02 ) != 0 ) { pu1_out_p = ps_cur_frm_buf -> pu1_u + u4_x_dst_offset + u4_y_dst_offset ; e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , U_CHROMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p ; u4_pred_strd = ps_dec -> u2_picture_width >> 1 ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p , 8 , u4_pred_strd , ps_dec -> u2_picture_width >> 1 , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } if ( ( ps_dec -> u2_cbp & 0x01 ) != 0 ) { pu1_out_p = ps_cur_frm_buf -> pu1_v + u4_x_dst_offset + u4_y_dst_offset ; e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , V_CHROMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p ; u4_pred_strd = ps_dec -> u2_picture_width >> 1 ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p , 8 , u4_pred_strd , ps_dec -> u2_picture_width >> 1 , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } ps_dec -> u2_num_mbs_left -- ; ps_dec -> u2_first_mb = 0 ; ps_dec -> u2_mb_x ++ ; if ( ps_dec -> s_bit_stream . u4_offset > ps_dec -> s_bit_stream . u4_max_offset ) { return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR ; } else if ( ps_dec -> u2_mb_x == ps_dec -> u2_num_horiz_mb ) { ps_dec -> u2_mb_x = 0 ; ps_dec -> u2_mb_y ++ ; } } while ( ps_dec -> u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt ( & ps_dec -> s_bit_stream , 23 ) != 0x0 ) ; return e_error ; }
","<S2SV_ModStart> return IMPEG2D_MB_TEX_DECODE_ERR ; if ( 0 >= ps_dec -> u2_num_mbs_left ) { break ; }
",external@libmpeg2/7737780815fe523ad7b0e49456eb75d27a30818a,CVE-2017-0810,https://android.googlesource.com/platform/external/libmpeg2/+/7737780815fe523ad7b0e49456eb75d27a30818a,2017-10-04T01:29Z,<S2SV_StartBug> return IMPEG2D_MB_TEX_DECODE_ERR ; <S2SV_EndBug>
1061,CWE-284,"static void uipc_check_interrupt_locked ( void ) { if ( SAFE_FD_ISSET ( uipc_main . signal_fds [ 0 ] , & uipc_main . read_set ) ) { char sig_recv = 0 ; <S2SV_StartBug> recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> = 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_WAITALL ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <S2SV_EndBug>"
1903,CWE-119,"static INLINE int get_tx_eob ( const struct segmentation * seg , int segment_id , TX_SIZE tx_size ) { const int eob_max = 16 << ( tx_size << 1 ) ; <S2SV_StartBug> return vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ? 0 : eob_max ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; return segfeature_active <S2SV_ModEnd> ( seg ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> return vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ? 0 : eob_max ; <S2SV_EndBug>"
2221,CWE-000,"int vp8_remove_decoder_instances ( struct frame_buffers * fb ) { if ( ! fb -> use_frame_threads ) { VP8D_COMP * pbi = fb -> pbi [ 0 ] ; if ( ! pbi ) return VPX_CODEC_ERROR ; # if CONFIG_MULTITHREAD <S2SV_StartBug> if ( pbi -> b_multithreaded_rd ) <S2SV_EndBug> vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ; vp8_decoder_remove_threads ( pbi ) ; # endif remove_decompressor ( pbi ) ; } else { } return VPX_CODEC_OK ; }
","<S2SV_ModStart> # if CONFIG_MULTITHREAD <S2SV_ModEnd> vp8_decoder_remove_threads ( pbi
",external@libvpx/6886e8e0a9db2dbad723dc37a548233e004b33bc,CVE-2017-0393,https://android.googlesource.com/platform/external/libvpx/+/6886e8e0a9db2dbad723dc37a548233e004b33bc,2017-01-12T20:59Z,<S2SV_StartBug> if ( pbi -> b_multithreaded_rd ) <S2SV_EndBug>
6577,CWE-20,"void CleanupOutput ( char * str ) { char * s , * t ; int period = 0 ; s = t = str ; <S2SV_StartBug> while ( * s && * s != '}' ) { <S2SV_EndBug> <S2SV_StartBug> if ( * s == '\\n' ) * s = '<S2SV_blank>' ; <S2SV_EndBug> <S2SV_StartBug> if ( ( * s == '<S2SV_blank>' || * s == '\\n' ) && ( s [ 1 ] == '<S2SV_blank>' || s [ 1 ] == '\\n' ) ) s ++ ; <S2SV_EndBug> else * t ++ = * s ++ ; } while ( * s ) * t ++ = * s ++ ; * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '.' ) { period = 1 ; * t ++ = * s ++ ; } else if ( * s == '-' && s [ 1 ] == '0' && s [ 2 ] == '<S2SV_blank>' ) { s ++ ; } else if ( * s <= '9' && * s >= '0' ) { * t ++ = * s ++ ; } else if ( * s == '\\n' && ( t > str && t [ - 1 ] == '\\n' ) ) { s ++ ; } else if ( period ) { while ( t > str && t [ - 1 ] == '0' ) t -- ; if ( t > str && t [ - 1 ] == '.' ) t -- ; while ( * s == '<S2SV_blank>' && s [ 1 ] == '<S2SV_blank>' ) s ++ ; period = 0 ; * t ++ = * s ++ ; } else if ( * s == '<S2SV_blank>' && s [ 1 ] == '<S2SV_blank>' ) s ++ ; else { period = 0 ; * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '-' && s [ 1 ] == '0' && s [ 2 ] == '<S2SV_blank>' ) { s ++ ; } else * t ++ = * s ++ ; } * t = 0 ; }
","<S2SV_ModStart> ( * s <S2SV_ModEnd> ) { if <S2SV_ModStart> == '\\n' ) { <S2SV_ModStart> = '<S2SV_blank>' ; } if ( ( * s == '<S2SV_blank>' ) && ( s [ 1 ] <S2SV_ModEnd> == '<S2SV_blank>' || <S2SV_ModStart> == '<S2SV_blank>' || s [ 1 ] == '\\n' || s [ 1 ] == 0 ) ) { s ++ ; } else { * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '.' ) { period = 1 ; * t ++ = * s ++ ; } else if ( isdigit ( * s ) ) { * t ++ = * s ++ ; } else if ( period ) { while ( t > str && t [ - 1 ] == '0' ) { t -- ; } if ( t > str && t [ - 1 ] == '.' ) { t -- ; if ( t > str && ! isdigit ( t [ - 1 ] ) ) { * t ++ = '0' ; } } period = 0 ; * t ++ = * s ++ ; } else { period = 0 ; * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '-' && s [ 1 ] == '0' && s [ 2 <S2SV_ModEnd> ] == '<S2SV_blank>' <S2SV_ModStart> ] == '<S2SV_blank>' <S2SV_ModEnd> ) { s
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,<S2SV_StartBug> while ( * s && * s != '}' ) { <S2SV_EndBug> <S2SV_StartBug> if ( * s == '\\n' ) * s = '<S2SV_blank>' ; <S2SV_EndBug> <S2SV_StartBug> if ( ( * s == '<S2SV_blank>' || * s == '\\n' ) && ( s [ 1 ] == '<S2SV_blank>' || s [ 1 ] == '\\n' ) ) s ++ ; <S2SV_EndBug>
3397,CWE-404,"int nfs3svc_decode_readdirargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> cookie ) ; args -> verf = p ; p += 2 ; args -> dircount = ~ 0 ; args -> count = ntohl ( * p ++ ) ; <S2SV_StartBug> args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ; <S2SV_EndBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z,"<S2SV_StartBug> args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug>"
4026,CWE-287,"int m_authenticate ( struct Client * cptr , struct Client * sptr , int parc , char * parv [ ] ) { struct Client * acptr ; int first = 0 ; char realhost [ HOSTLEN + 3 ] ; char * hoststr = ( cli_sockhost ( cptr ) ? cli_sockhost ( cptr ) : cli_sock_ip ( cptr ) ) ; if ( ! CapActive ( cptr , CAP_SASL ) ) return 0 ; if ( parc < 2 ) return need_more_params ( cptr , ""AUTHENTICATE"" ) ; if ( strlen ( parv [ 1 ] ) > 400 ) return send_reply ( cptr , ERR_SASLTOOLONG ) ; if ( IsSASLComplete ( cptr ) ) return send_reply ( cptr , ERR_SASLALREADY ) ; if ( ! ( acptr = cli_saslagent ( cptr ) ) ) { if ( strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) acptr = find_match_server ( ( char * ) feature_str ( FEAT_SASL_SERVER ) ) ; else acptr = NULL ; } if ( ! acptr && strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) return send_reply ( cptr , ERR_SASLFAIL , "":<S2SV_blank>service<S2SV_blank>unavailable"" ) ; if ( acptr && IsMe ( acptr ) ) return 0 ; if ( ! cli_saslcookie ( cptr ) ) { do { cli_saslcookie ( cptr ) = ircrandom ( ) & 0x7fffffff ; } while ( ! cli_saslcookie ( cptr ) ) ; first = 1 ; } if ( strchr ( hoststr , ':' ) != NULL ) ircd_snprintf ( 0 , realhost , sizeof ( realhost ) , ""[%s]"" , hoststr ) ; else ircd_strncpy ( realhost , hoststr , sizeof ( realhost ) ) ; if ( acptr ) { if ( first ) { <S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } else { if ( first ) { <S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } if ( ! t_active ( & cli_sasltimeout ( cptr ) ) ) timer_add ( timer_init ( & cli_sasltimeout ( cptr ) ) , sasl_timeout_callback , ( void * ) cptr , TT_RELATIVE , feature_int ( FEAT_SASL_TIMEOUT ) ) ; return 0 ; }
","<S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if ( <S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if (
",evilnet@nefarious2/f50a84bad996d438e7b31b9e74c32a41e43f8be5,CVE-2016-7145,https://github.com/evilnet/nefarious2/commit/f50a84bad996d438e7b31b9e74c32a41e43f8be5,2017-03-07T15:59Z,<S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug>
7474,CWE-476,"INTERNAL void vterm_allocator_free ( VTerm * vt , void * ptr ) <S2SV_StartBug> { <S2SV_EndBug> ( * vt -> allocator -> free ) ( ptr , vt -> allocdata ) ; }
","<S2SV_ModStart> ptr ) { if ( ptr )
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,<S2SV_StartBug> { <S2SV_EndBug>
2893,CWE-119,"static long vop_ioctl ( struct file * f , unsigned int cmd , unsigned long arg ) { struct vop_vdev * vdev = f -> private_data ; struct vop_info * vi = vdev -> vi ; void __user * argp = ( void __user * ) arg ; int ret ; switch ( cmd ) { case MIC_VIRTIO_ADD_DEVICE : { struct mic_device_desc dd , * dd_config ; if ( copy_from_user ( & dd , argp , sizeof ( dd ) ) ) return - EFAULT ; if ( mic_aligned_desc_size ( & dd ) > MIC_MAX_DESC_BLK_SIZE || dd . num_vq > MIC_MAX_VRINGS ) return - EINVAL ; dd_config = kzalloc ( mic_desc_size ( & dd ) , GFP_KERNEL ) ; if ( ! dd_config ) return - ENOMEM ; if ( copy_from_user ( dd_config , argp , mic_desc_size ( & dd ) ) ) { ret = - EFAULT ; goto free_ret ; } <S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug> mutex_lock ( & vi -> vop_mutex ) ; ret = vop_virtio_add_device ( vdev , dd_config ) ; if ( ret ) goto unlock_ret ; list_add_tail ( & vdev -> list , & vi -> vdev_list ) ; unlock_ret : mutex_unlock ( & vi -> vop_mutex ) ; mutex_unlock ( & vdev -> vdev_mutex ) ; free_ret : kfree ( dd_config ) ; return ret ; } case MIC_VIRTIO_COPY_DESC : { struct mic_copy_desc copy ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto _unlock_ret ; if ( copy_from_user ( & copy , argp , sizeof ( copy ) ) ) { ret = - EFAULT ; goto _unlock_ret ; } ret = vop_virtio_copy_desc ( vdev , & copy ) ; if ( ret < 0 ) goto _unlock_ret ; if ( copy_to_user ( & ( ( struct mic_copy_desc __user * ) argp ) -> out_len , & copy . out_len , sizeof ( copy . out_len ) ) ) ret = - EFAULT ; _unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } case MIC_VIRTIO_CONFIG_CHANGE : { void * buf ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto __unlock_ret ; buf = kzalloc ( vdev -> dd -> config_len , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto __unlock_ret ; } if ( copy_from_user ( buf , argp , vdev -> dd -> config_len ) ) { ret = - EFAULT ; goto done ; } ret = vop_virtio_config_change ( vdev , buf ) ; done : kfree ( buf ) ; __unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } default : return - ENOIOCTLCMD ; } ; return 0 ; }
","<S2SV_ModStart> free_ret ; } if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; }
",torvalds@linux/9bf292bfca94694a721449e3fd752493856710f6,CVE-2016-5728,https://github.com/torvalds/linux/commit/9bf292bfca94694a721449e3fd752493856710f6,2016-06-27T10:59Z,<S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug>
1323,CWE-119,"static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; <S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> int ret ; if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> return ERR_PTR ( - EINVAL ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>struct<S2SV_blank>vhost_scsi_tpg"" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }
","<S2SV_ModStart> * tpg ; u16 <S2SV_ModEnd> tpgt ; int <S2SV_ModStart> ; if ( kstrtou16 <S2SV_ModEnd> ( name + <S2SV_ModStart> ) || tpgt >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> ) return ERR_PTR
",torvalds@linux/59c816c1f24df0204e01851431d3bab3eb76719c,CVE-2015-4036,https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c,2015-08-31T20:59Z,"<S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug>"
3782,CWE-416,"void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_mrtree_set ( rt1 , pair -> key , it2 -> data ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
","<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair <S2SV_ModStart> it ) ; <S2SV_ModEnd> for ( it
",rpm-software-management@libcomps/e3a5d056633677959ad924a51758876d415e7046,CVE-2019-3817,https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046,2019-03-27T13:29Z,<S2SV_StartBug> char added ; <S2SV_EndBug> <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug>
1834,CWE-119,"void vp9_rc_set_frame_target ( VP9_COMP * cpi , int target ) { const VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; rc -> this_frame_target = target ; <S2SV_StartBug> rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / <S2SV_EndBug> ( cm -> width * cm -> height ) ; }
","<S2SV_ModStart> = target ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / <S2SV_EndBug>
8107,CWE-416,"void luaT_getvarargs ( lua_State * L , CallInfo * ci , StkId where , int wanted ) { int i ; int nextra = ci -> u . l . nextraargs ; if ( wanted < 0 ) { wanted = nextra ; <S2SV_StartBug> checkstackp ( L , nextra , where ) ; <S2SV_EndBug> L -> top = where + nextra ; } for ( i = 0 ; i < wanted && i < nextra ; i ++ ) setobjs2s ( L , where + i , ci -> func - nextra + i ) ; for ( ; i < wanted ; i ++ ) setnilvalue ( s2v ( where + i ) ) ; }
","<S2SV_ModStart> = nextra ; checkstackGCp <S2SV_ModEnd> ( L ,
",lua@lua/eb41999461b6f428186c55abd95f4ce1a76217d5,CVE-2020-15888,https://github.com/lua/lua/commit/eb41999461b6f428186c55abd95f4ce1a76217d5,2020-07-21T22:15Z,"<S2SV_StartBug> checkstackp ( L , nextra , where ) ; <S2SV_EndBug>"
885,CWE-200,"static int hci_sock_getname ( struct socket * sock , struct sockaddr * addr , int * addr_len , int peer ) { struct sockaddr_hci * haddr = ( struct sockaddr_hci * ) addr ; struct sock * sk = sock -> sk ; struct hci_dev * hdev = hci_pi ( sk ) -> hdev ; BT_DBG ( ""sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; if ( ! hdev ) return - EBADFD ; lock_sock ( sk ) ; * addr_len = sizeof ( * haddr ) ; haddr -> hci_family = AF_BLUETOOTH ; haddr -> hci_dev = hdev -> id ; <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> -> id ; haddr -> hci_channel = 0 ;
",torvalds@linux/3f68ba07b1da811bf383b4b701b129bfcb2e4988,CVE-2012-6544,https://github.com/torvalds/linux/commit/3f68ba07b1da811bf383b4b701b129bfcb2e4988,2013-03-15T20:55Z,<S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug>
6873,CWE-763,"<S2SV_StartBug> static void atomic2gen ( lua_State * L , global_State * g ) { <S2SV_EndBug> sweep2old ( L , & g -> allgc ) ; g -> reallyold = g -> old = g -> survival = g -> allgc ; sweep2old ( L , & g -> finobj ) ; g -> finobjrold = g -> finobjold = g -> finobjsur = g -> finobj ; sweep2old ( L , & g -> tobefnz ) ; g -> gckind = KGC_GEN ; g -> lastatomic = 0 ; g -> GCestimate = gettotalbytes ( g ) ; finishgencycle ( L , g ) ; }
","<S2SV_ModStart> g ) { g -> gcstate = GCSswpallgc ;
",lua@lua/a6da1472c0c5e05ff249325f979531ad51533110,CVE-2020-24371,https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110,2020-08-17T17:15Z,"<S2SV_StartBug> static void atomic2gen ( lua_State * L , global_State * g ) { <S2SV_EndBug>"
5763,CWE-295,"static int ssl_verify_cert ( struct tunnel * tunnel ) { int ret = - 1 ; int cert_valid = 0 ; unsigned char digest [ SHA256LEN ] ; unsigned int len ; struct x509_digest * elem ; char digest_str [ SHA256STRLEN ] , * subject , * issuer ; char * line ; int i ; X509_NAME * subj ; SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gateway<S2SV_blank>certificate.\\n"" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , NULL ) == 1 ) cert_valid = 1 ; # else <S2SV_StartBug> char common_name [ FIELD_SIZE + 1 ] ; <S2SV_EndBug> if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , <S2SV_StartBug> FIELD_SIZE ) == 0 ) <S2SV_EndBug> cert_valid = 1 ; # endif if ( cert_valid && SSL_get_verify_result ( tunnel -> ssl_handle ) == X509_V_OK ) { log_debug ( ""Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>succeeded.\\n"" ) ; ret = 0 ; goto free_cert ; } log_debug ( ""Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>failed.\\n"" ) ; if ( X509_digest ( cert , EVP_sha256 ( ) , digest , & len ) <= 0 || len != SHA256LEN ) { log_error ( ""Could<S2SV_blank>not<S2SV_blank>compute<S2SV_blank>certificate<S2SV_blank>sha256<S2SV_blank>digest.\\n"" ) ; goto free_cert ; } for ( i = 0 ; i < SHA256LEN ; i ++ ) sprintf ( & digest_str [ 2 * i ] , ""%02x"" , digest [ i ] ) ; digest_str [ SHA256STRLEN - 1 ] = '\\0' ; for ( elem = tunnel -> config -> cert_whitelist ; elem != NULL ; elem = elem -> next ) if ( memcmp ( digest_str , elem -> data , SHA256STRLEN - 1 ) == 0 ) break ; if ( elem != NULL ) { log_debug ( ""Gateway<S2SV_blank>certificate<S2SV_blank>digest<S2SV_blank>found<S2SV_blank>in<S2SV_blank>white<S2SV_blank>list.\\n"" ) ; ret = 0 ; goto free_cert ; } subject = X509_NAME_oneline ( subj , NULL , 0 ) ; issuer = X509_NAME_oneline ( X509_get_issuer_name ( cert ) , NULL , 0 ) ; log_error ( ""Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>failed,<S2SV_blank>and<S2SV_blank>the<S2SV_blank>certificate<S2SV_blank>digest<S2SV_blank>in<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>local<S2SV_blank>whitelist.<S2SV_blank>If<S2SV_blank>you<S2SV_blank>trust<S2SV_blank>it,<S2SV_blank>rerun<S2SV_blank>with:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--trusted-cert<S2SV_blank>%s\\n"" , digest_str ) ; log_error ( ""or<S2SV_blank>add<S2SV_blank>this<S2SV_blank>line<S2SV_blank>to<S2SV_blank>your<S2SV_blank>config<S2SV_blank>file:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>trusted-cert<S2SV_blank>=<S2SV_blank>%s\\n"" , digest_str ) ; log_error ( ""Gateway<S2SV_blank>certificate:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>subject:\\n"" ) ; for ( line = strtok ( subject , ""/"" ) ; line != NULL ; line = strtok ( NULL , ""/"" ) ) log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" , line ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>issuer:\\n"" ) ; for ( line = strtok ( issuer , ""/"" ) ; line != NULL ; line = strtok ( NULL , ""/"" ) ) log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" , line ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>sha256<S2SV_blank>digest:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" , digest_str ) ; free_cert : X509_free ( cert ) ; return ret ; }
","<S2SV_ModStart> ; # else if ( validate_hostname ( <S2SV_ModEnd> tunnel -> config <S2SV_ModStart> -> gateway_host , cert ) == MatchFound <S2SV_ModEnd> ) cert_valid =
",adrienverge@openfortivpn/6328a070ddaab16faaf008cb9a8a62439c30f2a8,CVE-2020-7043,https://github.com/adrienverge/openfortivpn/commit/6328a070ddaab16faaf008cb9a8a62439c30f2a8,2020-02-27T18:15Z,<S2SV_StartBug> char common_name [ FIELD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> FIELD_SIZE ) == 0 ) <S2SV_EndBug>
92,CWE-119,"static int parse_codes ( struct archive_read * a ) { int i , j , val , n , r ; unsigned char bitlengths [ MAX_SYMBOLS ] , zerocount , ppmd_flags ; unsigned int maxorder ; struct huffman_code precode ; struct rar * rar = ( struct rar * ) ( a -> format -> data ) ; struct rar_br * br = & ( rar -> br ) ; free_codes ( a ) ; rar_br_consume_unalined_bits ( br ) ; if ( ! rar_br_read_ahead ( a , br , 1 ) ) goto truncated_data ; if ( ( rar -> is_ppmd_block = rar_br_bits ( br , 1 ) ) != 0 ) { rar_br_consume ( br , 1 ) ; if ( ! rar_br_read_ahead ( a , br , 7 ) ) goto truncated_data ; ppmd_flags = rar_br_bits ( br , 7 ) ; rar_br_consume ( br , 7 ) ; if ( ppmd_flags & 0x20 ) { if ( ! rar_br_read_ahead ( a , br , 8 ) ) goto truncated_data ; rar -> dictionary_size = ( rar_br_bits ( br , 8 ) + 1 ) << 20 ; rar_br_consume ( br , 8 ) ; } if ( ppmd_flags & 0x40 ) { if ( ! rar_br_read_ahead ( a , br , 8 ) ) goto truncated_data ; rar -> ppmd_escape = rar -> ppmd7_context . InitEsc = rar_br_bits ( br , 8 ) ; rar_br_consume ( br , 8 ) ; } else rar -> ppmd_escape = 2 ; if ( ppmd_flags & 0x20 ) { maxorder = ( ppmd_flags & 0x1F ) + 1 ; if ( maxorder > 16 ) maxorder = 16 + ( maxorder - 16 ) * 3 ; if ( maxorder == 1 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Truncated<S2SV_blank>RAR<S2SV_blank>file<S2SV_blank>data"" ) ; return ( ARCHIVE_FATAL ) ; } __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context , & g_szalloc ) ; rar -> bytein . a = a ; rar -> bytein . Read = & ppmd_read ; __archive_ppmd7_functions . PpmdRAR_RangeDec_CreateVTable ( & rar -> range_dec ) ; rar -> range_dec . Stream = & rar -> bytein ; __archive_ppmd7_functions . Ppmd7_Construct ( & rar -> ppmd7_context ) ; <S2SV_StartBug> if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context , <S2SV_EndBug> rar -> dictionary_size , & g_szalloc ) ) { archive_set_error ( & a -> archive , ENOMEM , ""Out<S2SV_blank>of<S2SV_blank>memory"" ) ; return ( ARCHIVE_FATAL ) ; } if ( ! __archive_ppmd7_functions . PpmdRAR_RangeDec_Init ( & rar -> range_dec ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PPMd<S2SV_blank>range<S2SV_blank>decoder"" ) ; return ( ARCHIVE_FATAL ) ; } __archive_ppmd7_functions . Ppmd7_Init ( & rar -> ppmd7_context , maxorder ) ; rar -> ppmd_valid = 1 ; } else { if ( ! rar -> ppmd_valid ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>PPMd<S2SV_blank>sequence"" ) ; return ( ARCHIVE_FATAL ) ; } if ( ! __archive_ppmd7_functions . PpmdRAR_RangeDec_Init ( & rar -> range_dec ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PPMd<S2SV_blank>range<S2SV_blank>decoder"" ) ; return ( ARCHIVE_FATAL ) ; } } } else { rar_br_consume ( br , 1 ) ; if ( ! rar_br_read_ahead ( a , br , 1 ) ) goto truncated_data ; if ( ! rar_br_bits ( br , 1 ) ) memset ( rar -> lengthtable , 0 , sizeof ( rar -> lengthtable ) ) ; rar_br_consume ( br , 1 ) ; memset ( & bitlengths , 0 , sizeof ( bitlengths ) ) ; for ( i = 0 ; i < MAX_SYMBOLS ; ) { if ( ! rar_br_read_ahead ( a , br , 4 ) ) goto truncated_data ; bitlengths [ i ++ ] = rar_br_bits ( br , 4 ) ; rar_br_consume ( br , 4 ) ; if ( bitlengths [ i - 1 ] == 0xF ) { if ( ! rar_br_read_ahead ( a , br , 4 ) ) goto truncated_data ; zerocount = rar_br_bits ( br , 4 ) ; rar_br_consume ( br , 4 ) ; if ( zerocount ) { i -- ; for ( j = 0 ; j < zerocount + 2 && i < MAX_SYMBOLS ; j ++ ) bitlengths [ i ++ ] = 0 ; } } } memset ( & precode , 0 , sizeof ( precode ) ) ; r = create_code ( a , & precode , bitlengths , MAX_SYMBOLS , MAX_SYMBOL_LENGTH ) ; if ( r != ARCHIVE_OK ) { free ( precode . tree ) ; free ( precode . table ) ; return ( r ) ; } for ( i = 0 ; i < HUFFMAN_TABLE_SIZE ; ) { if ( ( val = read_next_symbol ( a , & precode ) ) < 0 ) { free ( precode . tree ) ; free ( precode . table ) ; return ( ARCHIVE_FATAL ) ; } if ( val < 16 ) { rar -> lengthtable [ i ] = ( rar -> lengthtable [ i ] + val ) & 0xF ; i ++ ; } else if ( val < 18 ) { if ( i == 0 ) { free ( precode . tree ) ; free ( precode . table ) ; archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Internal<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>RAR<S2SV_blank>file."" ) ; return ( ARCHIVE_FATAL ) ; } if ( val == 16 ) { if ( ! rar_br_read_ahead ( a , br , 3 ) ) { free ( precode . tree ) ; free ( precode . table ) ; goto truncated_data ; } n = rar_br_bits ( br , 3 ) + 3 ; rar_br_consume ( br , 3 ) ; } else { if ( ! rar_br_read_ahead ( a , br , 7 ) ) { free ( precode . tree ) ; free ( precode . table ) ; goto truncated_data ; } n = rar_br_bits ( br , 7 ) + 11 ; rar_br_consume ( br , 7 ) ; } for ( j = 0 ; j < n && i < HUFFMAN_TABLE_SIZE ; j ++ ) { rar -> lengthtable [ i ] = rar -> lengthtable [ i - 1 ] ; i ++ ; } } else { if ( val == 18 ) { if ( ! rar_br_read_ahead ( a , br , 3 ) ) { free ( precode . tree ) ; free ( precode . table ) ; goto truncated_data ; } n = rar_br_bits ( br , 3 ) + 3 ; rar_br_consume ( br , 3 ) ; } else { if ( ! rar_br_read_ahead ( a , br , 7 ) ) { free ( precode . tree ) ; free ( precode . table ) ; goto truncated_data ; } n = rar_br_bits ( br , 7 ) + 11 ; rar_br_consume ( br , 7 ) ; } for ( j = 0 ; j < n && i < HUFFMAN_TABLE_SIZE ; j ++ ) rar -> lengthtable [ i ++ ] = 0 ; } } free ( precode . tree ) ; free ( precode . table ) ; r = create_code ( a , & rar -> maincode , & rar -> lengthtable [ 0 ] , MAINCODE_SIZE , MAX_SYMBOL_LENGTH ) ; if ( r != ARCHIVE_OK ) return ( r ) ; r = create_code ( a , & rar -> offsetcode , & rar -> lengthtable [ MAINCODE_SIZE ] , OFFSETCODE_SIZE , MAX_SYMBOL_LENGTH ) ; if ( r != ARCHIVE_OK ) return ( r ) ; r = create_code ( a , & rar -> lowoffsetcode , & rar -> lengthtable [ MAINCODE_SIZE + OFFSETCODE_SIZE ] , LOWOFFSETCODE_SIZE , MAX_SYMBOL_LENGTH ) ; if ( r != ARCHIVE_OK ) return ( r ) ; r = create_code ( a , & rar -> lengthcode , & rar -> lengthtable [ MAINCODE_SIZE + OFFSETCODE_SIZE + LOWOFFSETCODE_SIZE ] , LENGTHCODE_SIZE , MAX_SYMBOL_LENGTH ) ; if ( r != ARCHIVE_OK ) return ( r ) ; } if ( ! rar -> dictionary_size || ! rar -> lzss . window ) { void * new_window ; unsigned int new_size ; if ( rar -> unp_size >= DICTIONARY_MAX_SIZE ) new_size = DICTIONARY_MAX_SIZE ; else new_size = rar_fls ( ( unsigned int ) rar -> unp_size ) << 1 ; new_window = realloc ( rar -> lzss . window , new_size ) ; if ( new_window == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>uncompressed<S2SV_blank>data."" ) ; return ( ARCHIVE_FATAL ) ; } rar -> lzss . window = ( unsigned char * ) new_window ; rar -> dictionary_size = new_size ; memset ( rar -> lzss . window , 0 , rar -> dictionary_size ) ; rar -> lzss . mask = rar -> dictionary_size - 1 ; } rar -> start_new_table = 0 ; return ( ARCHIVE_OK ) ; truncated_data : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Truncated<S2SV_blank>RAR<S2SV_blank>file<S2SV_blank>data"" ) ; rar -> valid = 0 ; return ( ARCHIVE_FATAL ) ; }
","<S2SV_ModStart> ; if ( rar -> dictionary_size == 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } if (
",libarchive@libarchive/05caadc7eedbef471ac9610809ba683f0c698700,CVE-2016-4302,https://github.com/libarchive/libarchive/commit/05caadc7eedbef471ac9610809ba683f0c698700,2016-09-21T14:25Z,"<S2SV_StartBug> if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context , <S2SV_EndBug>"
1108,CWE-119,"void jpc_qmfb_join_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t joinbuf [ QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = joinbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int hstartcol ; if ( bufsize > QMFB_JOINBUFSIZE ) { if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } hstartcol = ( numrows + 1 - parity ) >> 1 ; n = hstartcol ; srcptr = & a [ 0 ] ; dstptr = buf ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } srcptr += stride ; dstptr += JPC_QMFB_COLGRPSIZE ; } srcptr = & a [ hstartcol * stride ] ; dstptr = & a [ ( 1 - parity ) * stride ] ; n = numrows - hstartcol ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += 2 * stride ; srcptr += stride ; } srcptr = buf ; dstptr = & a [ parity * stride ] ; n = hstartcol ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += 2 * stride ; srcptr += JPC_QMFB_COLGRPSIZE ; } if ( buf != joinbuf ) { jas_free ( buf ) ; } }
","
",mdadams@jasper/4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,CVE-2016-8654,https://github.com/mdadams/jasper/commit/4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,2018-08-01T16:29Z,
3662,CWE-119,"static void numtostr ( js_State * J , const char * fmt , int w , double n ) { <S2SV_StartBug> char buf [ 32 ] , * e ; <S2SV_EndBug> sprintf ( buf , fmt , w , n ) ; e = strchr ( buf , 'e' ) ; if ( e ) { int exp = atoi ( e + 1 ) ; sprintf ( e , ""e%+d"" , exp ) ; } js_pushstring ( J , buf ) ; }
","<S2SV_ModStart> char buf [ 50 <S2SV_ModEnd> ] , *
",ccxvii@mujs/da632ca08f240590d2dec786722ed08486ce1be6,CVE-2019-11411,https://github.com/ccxvii/mujs/commit/da632ca08f240590d2dec786722ed08486ce1be6,2019-04-22T11:29Z,"<S2SV_StartBug> char buf [ 32 ] , * e ; <S2SV_EndBug>"
2794,CWE-476,"static int crypto_rng_init_tfm ( struct crypto_tfm * tfm ) { <S2SV_StartBug> struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ; <S2SV_EndBug> struct rng_alg * alg = crypto_rng_alg ( rng ) ; struct old_rng_alg * oalg = crypto_old_rng_alg ( rng ) ; if ( oalg -> rng_make_random ) { rng -> generate = generate ; rng -> seed = rngapi_reset ; rng -> seedsize = oalg -> seedsize ; return 0 ; } rng -> generate = alg -> generate ; rng -> seed = alg -> seed ; rng -> seedsize = alg -> seedsize ; return 0 ; }
","<S2SV_ModStart> tfm ) { <S2SV_ModEnd> return 0 ;
",torvalds@linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,CVE-2017-15116,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,2017-11-30T18:29Z,<S2SV_StartBug> struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ; <S2SV_EndBug>
889,CWE-416,"int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , ""Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> EIO ; } io -> io_cleanup = mem_cleanup ;
",torvalds@linux/401e7e88d4ef80188ffa07095ac00456f901b8c4,CVE-2019-11811,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,2019-05-07T14:29Z,<S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>
5761,CWE-369,"void fmtutil_macbitmap_read_pixmap_only_fields ( deark * c , dbuf * f , struct fmtutil_macbitmap_info * bi , i64 pos ) { i64 pixmap_version ; i64 pack_size ; i64 plane_bytes ; i64 n ; de_dbg ( c , ""additional<S2SV_blank>PixMap<S2SV_blank>header<S2SV_blank>fields,<S2SV_blank>at<S2SV_blank>%d"" , ( int ) pos ) ; de_dbg_indent ( c , 1 ) ; pixmap_version = dbuf_getu16be ( f , pos + 0 ) ; de_dbg ( c , ""pixmap<S2SV_blank>version:<S2SV_blank>%d"" , ( int ) pixmap_version ) ; bi -> packing_type = dbuf_getu16be ( f , pos + 2 ) ; de_dbg ( c , ""packing<S2SV_blank>type:<S2SV_blank>%d"" , ( int ) bi -> packing_type ) ; pack_size = dbuf_getu32be ( f , pos + 4 ) ; de_dbg ( c , ""pixel<S2SV_blank>data<S2SV_blank>length:<S2SV_blank>%d"" , ( int ) pack_size ) ; bi -> hdpi = pict_read_fixed ( f , pos + 8 ) ; bi -> vdpi = pict_read_fixed ( f , pos + 12 ) ; de_dbg ( c , ""dpi:<S2SV_blank>%.2f"" DE_CHAR_TIMES ""%.2f"" , bi -> hdpi , bi -> vdpi ) ; bi -> pixeltype = dbuf_getu16be ( f , pos + 16 ) ; bi -> pixelsize = dbuf_getu16be ( f , pos + 18 ) ; bi -> cmpcount = dbuf_getu16be ( f , pos + 20 ) ; bi -> cmpsize = dbuf_getu16be ( f , pos + 22 ) ; de_dbg ( c , ""pixel<S2SV_blank>type=%d,<S2SV_blank>bits/pixel=%d,<S2SV_blank>components/pixel=%d,<S2SV_blank>bits/comp=%d"" , ( int ) bi -> pixeltype , ( int ) bi -> pixelsize , ( int ) bi -> cmpcount , ( int ) bi -> cmpsize ) ; <S2SV_StartBug> bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ; <S2SV_EndBug> <S2SV_StartBug> if ( bi -> pdwidth < bi -> npwidth ) { <S2SV_EndBug> bi -> pdwidth = bi -> npwidth ; } plane_bytes = dbuf_getu32be ( f , pos + 24 ) ; de_dbg ( c , ""plane<S2SV_blank>bytes:<S2SV_blank>%d"" , ( int ) plane_bytes ) ; bi -> pmTable = ( u32 ) dbuf_getu32be ( f , pos + 28 ) ; de_dbg ( c , ""pmTable:<S2SV_blank>0x%08x"" , ( unsigned int ) bi -> pmTable ) ; n = dbuf_getu32be ( f , pos + 32 ) ; de_dbg ( c , ""pmReserved:<S2SV_blank>0x%08x"" , ( unsigned int ) n ) ; de_dbg_indent ( c , - 1 ) ; }
","<S2SV_ModStart> cmpsize ) ; if ( bi -> pixelsize > 0 ) { <S2SV_ModStart> -> pixelsize ; }
",jsummers@deark/62acb7753b0e3c0d3ab3c15057b0a65222313334,CVE-2021-28856,https://github.com/jsummers/deark/commit/62acb7753b0e3c0d3ab3c15057b0a65222313334,2021-04-14T17:15Z,<S2SV_StartBug> bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ; <S2SV_EndBug> <S2SV_StartBug> if ( bi -> pdwidth < bi -> npwidth ) { <S2SV_EndBug>
1245,CWE-119,"static bool check_underflow ( const struct arpt_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> arp ) ) <S2SV_EndBug> return false ; t = arpt_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }
","<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z,<S2SV_StartBug> if ( ! unconditional ( & e -> arp ) ) <S2SV_EndBug>
7794,CWE-125,"static stmt_ty ast_for_import_stmt ( struct compiling * c , const node * n ) { int lineno ; int col_offset ; int i ; asdl_seq * aliases ; REQ ( n , import_stmt ) ; lineno = LINENO ( n ) ; col_offset = n -> n_col_offset ; n = CHILD ( n , 0 ) ; if ( TYPE ( n ) == import_name ) { n = CHILD ( n , 1 ) ; REQ ( n , dotted_as_names ) ; aliases = _Py_asdl_seq_new ( ( NCH ( n ) + 1 ) / 2 , c -> c_arena ) ; if ( ! aliases ) return NULL ; for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { alias_ty import_alias = alias_for_import_name ( c , CHILD ( n , i ) , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , i / 2 , import_alias ) ; } return Import ( aliases , lineno , col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( n ) == import_from ) { int n_children ; int idx , ndots = 0 ; const node * n_copy = n ; alias_ty mod = NULL ; identifier modname = NULL ; for ( idx = 1 ; idx < NCH ( n ) ; idx ++ ) { if ( TYPE ( CHILD ( n , idx ) ) == dotted_name ) { mod = alias_for_import_name ( c , CHILD ( n , idx ) , 0 ) ; if ( ! mod ) return NULL ; idx ++ ; break ; } else if ( TYPE ( CHILD ( n , idx ) ) == ELLIPSIS ) { ndots += 3 ; continue ; } else if ( TYPE ( CHILD ( n , idx ) ) != DOT ) { break ; } ndots ++ ; } idx ++ ; switch ( TYPE ( CHILD ( n , idx ) ) ) { case STAR : n = CHILD ( n , idx ) ; n_children = 1 ; break ; case LPAR : n = CHILD ( n , idx + 1 ) ; n_children = NCH ( n ) ; break ; case import_as_names : n = CHILD ( n , idx ) ; n_children = NCH ( n ) ; if ( n_children % 2 == 0 ) { ast_error ( c , n , ""trailing<S2SV_blank>comma<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>without"" ""<S2SV_blank>surrounding<S2SV_blank>parentheses"" ) ; return NULL ; } break ; default : ast_error ( c , n , ""Unexpected<S2SV_blank>node-type<S2SV_blank>in<S2SV_blank>from-import"" ) ; return NULL ; } aliases = _Py_asdl_seq_new ( ( n_children + 1 ) / 2 , c -> c_arena ) ; if ( ! aliases ) return NULL ; if ( TYPE ( n ) == STAR ) { alias_ty import_alias = alias_for_import_name ( c , n , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , 0 , import_alias ) ; } else { for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { alias_ty import_alias = alias_for_import_name ( c , CHILD ( n , i ) , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , i / 2 , import_alias ) ; } } if ( mod != NULL ) modname = mod -> name ; return ImportFrom ( modname , aliases , ndots , lineno , col_offset , n_copy -> n_end_lineno , n_copy -> n_end_col_offset , c -> c_arena ) ; } PyErr_Format ( PyExc_SystemError , ""unknown<S2SV_blank>import<S2SV_blank>statement:<S2SV_blank>starts<S2SV_blank>with<S2SV_blank>command<S2SV_blank>\'%s\'"" , STR ( CHILD ( n , 0 ) ) ) ; return NULL ; }
","
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,
634,CWE-362,"static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , struct sctp_association * assoc , sctp_socket_type_t type ) { struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; struct sctp_sock * newsp = sctp_sk ( newsk ) ; struct sctp_bind_bucket * pp ; struct sctp_endpoint * newep = newsp -> ep ; struct sk_buff * skb , * tmp ; struct sctp_ulpevent * event ; struct sctp_bind_hashbucket * head ; <S2SV_StartBug> struct list_head tmplist ; <S2SV_EndBug> newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ; <S2SV_StartBug> if ( oldsp -> do_auto_asconf ) { <S2SV_EndBug> memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ; inet_sk_copy_descendant ( newsk , oldsk ) ; memcpy ( & newsp -> auto_asconf_list , & tmplist , sizeof ( tmplist ) ) ; } else inet_sk_copy_descendant ( newsk , oldsk ) ; newsp -> ep = newep ; newsp -> hmac = NULL ; head = & sctp_port_hashtable [ sctp_phashfn ( sock_net ( oldsk ) , inet_sk ( oldsk ) -> inet_num ) ] ; local_bh_disable ( ) ; spin_lock ( & head -> lock ) ; pp = sctp_sk ( oldsk ) -> bind_hash ; sk_add_bind_node ( newsk , & pp -> owner ) ; sctp_sk ( newsk ) -> bind_hash = pp ; inet_sk ( newsk ) -> inet_num = inet_sk ( oldsk ) -> inet_num ; spin_unlock ( & head -> lock ) ; local_bh_enable ( ) ; sctp_bind_addr_dup ( & newsp -> ep -> base . bind_addr , & oldsp -> ep -> base . bind_addr , GFP_KERNEL ) ; sctp_skb_for_each ( skb , & oldsk -> sk_receive_queue , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { __skb_unlink ( skb , & oldsk -> sk_receive_queue ) ; __skb_queue_tail ( & newsk -> sk_receive_queue , skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } } skb_queue_head_init ( & newsp -> pd_lobby ) ; atomic_set ( & sctp_sk ( newsk ) -> pd_mode , assoc -> ulpq . pd_mode ) ; if ( atomic_read ( & sctp_sk ( oldsk ) -> pd_mode ) ) { struct sk_buff_head * queue ; if ( assoc -> ulpq . pd_mode ) { queue = & newsp -> pd_lobby ; } else queue = & newsk -> sk_receive_queue ; sctp_skb_for_each ( skb , & oldsp -> pd_lobby , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { __skb_unlink ( skb , & oldsp -> pd_lobby ) ; __skb_queue_tail ( queue , skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } } if ( assoc -> ulpq . pd_mode ) sctp_clear_pd ( oldsk , NULL ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) sctp_skb_set_owner_r_frag ( skb , newsk ) ; sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) sctp_skb_set_owner_r_frag ( skb , newsk ) ; newsp -> type = type ; lock_sock_nested ( newsk , SINGLE_DEPTH_NESTING ) ; sctp_assoc_migrate ( assoc , newsk ) ; if ( sctp_state ( assoc , CLOSED ) && sctp_style ( newsk , TCP ) ) newsk -> sk_shutdown |= RCV_SHUTDOWN ; newsk -> sk_state = SCTP_SS_ESTABLISHED ; release_sock ( newsk ) ; }
","<S2SV_ModStart> * head ; <S2SV_ModEnd> newsk -> sk_sndbuf <S2SV_ModStart> -> sk_rcvbuf ; sctp_copy_descendant <S2SV_ModEnd> ( newsk ,
",torvalds@linux/2d45a02d0166caf2627fe91897c6ffc3b19514c4,CVE-2015-3212,https://github.com/torvalds/linux/commit/2d45a02d0166caf2627fe91897c6ffc3b19514c4,2015-08-31T10:59Z,<S2SV_StartBug> struct list_head tmplist ; <S2SV_EndBug> <S2SV_StartBug> if ( oldsp -> do_auto_asconf ) { <S2SV_EndBug>
4149,CWE-254,"void impeg2d_flush_ext_and_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; <S2SV_StartBug> while ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) <S2SV_EndBug> { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <S2SV_EndBug> { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }
","<S2SV_ModStart> ; while ( ( <S2SV_ModStart> u4_start_code == USER_DATA_START_CODE ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <S2SV_ModStart> ) != START_CODE_PREFIX && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
",external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3,CVE-2016-0824,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,2016-03-12T21:59Z,"<S2SV_StartBug> while ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) <S2SV_EndBug> <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <S2SV_EndBug>"
3033,CWE-264,"static int cg_opendir ( const char * path , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; const char * cgroup ; struct file_info * dir_info ; char * controller = NULL ; if ( ! fc ) return - EIO ; if ( strcmp ( path , ""/cgroup"" ) == 0 ) { cgroup = NULL ; controller = NULL ; } else { controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { cgroup = ""/"" ; } } <S2SV_StartBug> if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { <S2SV_EndBug> return - EACCES ; } dir_info = malloc ( sizeof ( * dir_info ) ) ; if ( ! dir_info ) return - ENOMEM ; dir_info -> controller = must_copy_string ( controller ) ; dir_info -> cgroup = must_copy_string ( cgroup ) ; dir_info -> type = LXC_TYPE_CGDIR ; dir_info -> buf = NULL ; dir_info -> file = NULL ; dir_info -> buflen = 0 ; fi -> fh = ( unsigned long ) dir_info ; return 0 ; }
","<S2SV_ModStart> if ( cgroup ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ; if ( <S2SV_ModEnd> ! fc_may_access ( <S2SV_ModStart> O_RDONLY ) ) <S2SV_ModEnd> return - EACCES
",lxc@lxcfs/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,CVE-2015-1342,https://github.com/lxc/lxcfs/commit/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,2015-12-07T20:59Z,"<S2SV_StartBug> if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { <S2SV_EndBug>"
4055,CWE-119,"static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MaxTextExtent ] ; CINInfo cin ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register PixelPacket * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , ""\\200\\052\\137\\327"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.version"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.filename"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_date"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_time"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , ""dpx:image.orientation"" , ""%d"" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , ""dpx:image.label"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ( int ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.x_offset"" , ""%.20g"" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.y_offset"" , ""%.20g"" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.filename"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_date"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_time"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.device"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.model"" , property ) ; ( void ) ResetMagickMemory ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.serial"" , property ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.id"" , ""%d"" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.type"" , ""%d"" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.offset"" , ""%d"" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.prefix"" , ""%.20g"" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.format"" , property ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_position"" , ""%.20g"" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_rate"" , ""%g"" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.frame_id"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.slate_info"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; profile = BlobToStringInfo ( ( const void * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , ""dpx:user.data"" , profile ) ; profile = DestroyStringInfo ( profile ) ; } for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) ( void ) ReadBlobByte ( image ) ; image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ; <S2SV_StartBug> if ( image_info -> ping ) <S2SV_EndBug> { ( void ) CloseBlob ( image ) ; <S2SV_StartBug> return ( image ) ; <S2SV_EndBug> } quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_info -> quantum = 32 ; quantum_info -> pack = MagickFalse ; quantum_type = RGBQuantum ; pixels = GetQuantumPixels ( quantum_info ) ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , LogColorspace ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> image_info -> ping != MagickFalse <S2SV_ModStart> return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image )
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,<S2SV_StartBug> if ( image_info -> ping ) <S2SV_EndBug> <S2SV_StartBug> return ( image ) ; <S2SV_EndBug>
5742,CWE-269,"STATIC_OVL void escapes ( cp , tp ) const char * cp ; char * tp ; { <S2SV_StartBug> while ( * cp ) { <S2SV_EndBug> int cval = 0 , meta = 0 ; if ( * cp == '\\\\' && cp [ 1 ] && index ( ""mM"" , cp [ 1 ] ) && cp [ 2 ] ) { meta = 1 ; cp += 2 ; } if ( * cp == '\\\\' && cp [ 1 ] && index ( ""0123456789xXoO"" , cp [ 1 ] ) && cp [ 2 ] ) { <S2SV_StartBug> NEARDATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ; <S2SV_EndBug> const char * dp ; <S2SV_StartBug> int dcount = 0 ; <S2SV_EndBug> <S2SV_StartBug> cp ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( * cp == 'x' || * cp == 'X' ) <S2SV_EndBug> <S2SV_StartBug> for ( ++ cp ; * cp && ( dp = index ( hex , * cp ) ) && ( dcount ++ < 2 ) ; cp ++ ) <S2SV_EndBug> cval = ( cval * 16 ) + ( ( int ) ( dp - hex ) / 2 ) ; <S2SV_StartBug> else if ( * cp == 'o' || * cp == 'O' ) <S2SV_EndBug> for ( ++ cp ; * cp && ( index ( ""01234567"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 8 ) + ( * cp - '0' ) ; else for ( ; * cp && ( index ( ""0123456789"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 10 ) + ( * cp - '0' ) ; } else if ( * cp == '\\\\' && cp [ 1 ] ) { switch ( * ++ cp ) { case '\\\\' : cval = '\\\\' ; break ; case 'n' : cval = '\\n' ; break ; case 't' : cval = '\\t' ; break ; case 'b' : cval = '\\b' ; break ; case 'r' : cval = '\\r' ; break ; default : cval = * cp ; } <S2SV_StartBug> cp ++ ; <S2SV_EndBug> } else if ( * cp == '^' && cp [ 1 ] ) { cval = ( * ++ cp & 0x1f ) ; cp ++ ; } else cval = * cp ++ ; if ( meta ) cval |= 0x80 ; <S2SV_StartBug> * tp ++ = cval ; <S2SV_EndBug> } * tp = '\\0' ; }
","<S2SV_ModStart> tp ; { static <S2SV_ModEnd> NEARDATA const char <S2SV_ModStart> NEARDATA const char oct [ ] = ""01234567"" , dec [ ] = ""0123456789"" , <S2SV_ModStart> dp ; int cval , meta , dcount ; while ( * cp ) { meta = ( * cp == '\\\\' && ( cp [ 1 ] == 'm' || cp [ 1 ] == 'M' ) && cp [ 2 ] ) ; if ( meta ) cp += 2 ; cval = dcount <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; if ( ( * cp != '\\\\' && * cp != '^' ) || ! cp [ 1 ] ) { cval = * cp ++ ; } else if ( * cp == '^' ) { cval = ( * ++ cp & 0x1f ) ; ++ cp ; } else if ( index ( dec , cp [ 1 ] ) ) { ++ cp ; do { cval = ( cval * 10 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( dec , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] == 'o' || cp [ 1 ] == 'O' ) && cp [ 2 ] && index ( oct , cp [ 2 ] ) ) { cp += 2 ; do { cval = ( cval * 8 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( oct , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] <S2SV_ModEnd> == 'x' || <S2SV_ModStart> == 'x' || cp [ 1 ] <S2SV_ModEnd> == 'X' ) <S2SV_ModStart> == 'X' ) && cp [ 2 ] <S2SV_ModEnd> && ( dp <S2SV_ModStart> ( hex , cp [ 2 ] ) ) != 0 ) { cp += 2 ; do { <S2SV_ModEnd> cval = ( <S2SV_ModStart> 2 ) ; } while ( * ++ cp && ( dp = index ( hex , * cp ) ) != 0 && ++ dcount < 2 ) ; } else <S2SV_ModEnd> { switch ( <S2SV_ModStart> cp ; } ++ cp ; } <S2SV_ModEnd> if ( meta <S2SV_ModStart> tp ++ = ( char )
",NetHack@NetHack/612755bfb5c412079795c68ba392df5d93874ed8,CVE-2020-5253,https://github.com/NetHack/NetHack/commit/612755bfb5c412079795c68ba392df5d93874ed8,2020-03-10T17:15Z,"<S2SV_StartBug> while ( * cp ) { <S2SV_EndBug> <S2SV_StartBug> NEARDATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ; <S2SV_EndBug> <S2SV_StartBug> int dcount = 0 ; <S2SV_EndBug> <S2SV_StartBug> cp ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( * cp == 'x' || * cp == 'X' ) <S2SV_EndBug> <S2SV_StartBug> for ( ++ cp ; * cp && ( dp = index ( hex , * cp ) ) && ( dcount ++ < 2 ) ; cp ++ ) <S2SV_EndBug> <S2SV_StartBug> else if ( * cp == 'o' || * cp == 'O' ) <S2SV_EndBug> <S2SV_StartBug> cp ++ ; <S2SV_EndBug> <S2SV_StartBug> * tp ++ = cval ; <S2SV_EndBug>"
140,CWE-362,"static int snd_ctl_elem_user_put ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { int change ; <S2SV_StartBug> struct user_element * ue = kcontrol -> private_data ; <S2SV_EndBug> change = memcmp ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) != 0 ; if ( change ) memcpy ( ue -> elem_data , & ucontrol -> value , ue -> elem_data_size ) ; <S2SV_StartBug> return change ; <S2SV_EndBug> }
","<S2SV_ModStart> kcontrol -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) <S2SV_ModStart> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
",torvalds@linux/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92,CVE-2014-4652,https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92,2014-07-03T04:22Z,<S2SV_StartBug> struct user_element * ue = kcontrol -> private_data ; <S2SV_EndBug> <S2SV_StartBug> return change ; <S2SV_EndBug>
4131,CWE-000,"static struct sock * sctp_v6_create_accept_sk ( struct sock * sk , struct sctp_association * asoc , bool kern ) { struct sock * newsk ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct sctp6_sock * newsctp6sk ; struct ipv6_txoptions * opt ; newsk = sk_alloc ( sock_net ( sk ) , PF_INET6 , GFP_KERNEL , sk -> sk_prot , kern ) ; if ( ! newsk ) goto out ; sock_init_data ( NULL , newsk ) ; sctp_copy_sock ( newsk , sk , asoc ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; newsctp6sk = ( struct sctp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newsctp6sk -> inet6 ; sctp_sk ( newsk ) -> v4mapped = sctp_sk ( sk ) -> v4mapped ; newnp = inet6_sk ( newsk ) ; <S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug> rcu_read_lock ( ) ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; rcu_read_unlock ( ) ; sctp_v6_to_sk_daddr ( & asoc -> peer . primary_addr , newsk ) ; newsk -> sk_v6_rcv_saddr = sk -> sk_v6_rcv_saddr ; sk_refcnt_debug_inc ( newsk ) ; if ( newsk -> sk_prot -> init ( newsk ) ) { sk_common_release ( newsk ) ; newsk = NULL ; } out : return newsk ; }
","<S2SV_ModStart> ipv6_pinfo ) ) ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL
",torvalds@linux/fdcee2cbb8438702ea1b328fb6e0ac5e9a40c7f8,CVE-2017-9075,https://github.com/torvalds/linux/commit/fdcee2cbb8438702ea1b328fb6e0ac5e9a40c7f8,2017-05-19T07:29Z,"<S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug>"
802,CWE-476,"bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; return true ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; return true ; default : break ; } log_wsgo ( ctx , ""Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n"" , expr -> expr . op ) ; return false ; }
","<S2SV_ModStart> NULL ; return ( * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_FIELD_REF
",xkbcommon@libxkbcommon/38e1766bc6e20108948aec8a0b222a4bad0254e9,CVE-2018-15861,https://github.com/xkbcommon/libxkbcommon/commit/38e1766bc6e20108948aec8a0b222a4bad0254e9,2018-08-25T21:29Z,<S2SV_StartBug> return true ; <S2SV_EndBug>
1274,CWE-119,"static int set_register ( pegasus_t * pegasus , __u16 indx , __u8 data ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REG , PEGASUS_REQT_WRITE , data , <S2SV_StartBug> indx , & data , 1 , 1000 ) ; <S2SV_EndBug> if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\n"" , __func__ , ret ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , 1 , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
",torvalds@linux/5593523f968bc86d42a035c6df47d5e0979b5ace,CVE-2017-8068,https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace,2017-04-23T05:59Z,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , & data , 1 , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug>"
1475,CWE-119,"void vp8cx_pick_filter_level_fast ( YV12_BUFFER_CONFIG * sd , VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int best_err = 0 ; int filt_err = 0 ; int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filt_val ; <S2SV_StartBug> int best_filt_val = cm -> filter_level ; <S2SV_EndBug> YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ; if ( cm -> frame_type == KEY_FRAME ) cm -> sharpness_level = 0 ; else cm -> sharpness_level = cpi -> oxcf . Sharpness ; if ( cm -> sharpness_level != cm -> last_sharpness_level ) { vp8_loop_filter_update_sharpness ( & cm -> lf_info , cm -> sharpness_level ) ; cm -> last_sharpness_level = cm -> sharpness_level ; } if ( cm -> filter_level < min_filter_level ) cm -> filter_level = min_filter_level ; else if ( cm -> filter_level > max_filter_level ) cm -> filter_level = max_filter_level ; filt_val = cm -> filter_level ; best_filt_val = filt_val ; <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; best_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; filt_val -= 1 + ( filt_val > 10 ) ; while ( filt_val >= min_filter_level ) { <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; filt_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; if ( filt_err < best_err ) { best_err = filt_err ; best_filt_val = filt_val ; } else break ; filt_val -= 1 + ( filt_val > 10 ) ; } filt_val = cm -> filter_level + 1 + ( filt_val > 10 ) ; if ( best_filt_val == cm -> filter_level ) { best_err -= ( best_err >> 10 ) ; while ( filt_val < max_filter_level ) { <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; filt_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; if ( filt_err < best_err ) { best_err = filt_err - ( filt_err >> 10 ) ; best_filt_val = filt_val ; } else break ; filt_val += 1 + ( filt_val > 10 ) ; } } cm -> filter_level = best_filt_val ; if ( cm -> filter_level < min_filter_level ) cm -> filter_level = min_filter_level ; if ( cm -> filter_level > max_filter_level ) cm -> filter_level = max_filter_level ; cm -> frame_to_show = saved_frame ; }
","<S2SV_ModStart> ; int best_filt_val <S2SV_ModEnd> ; YV12_BUFFER_CONFIG * <S2SV_ModStart> = filt_val ; yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame , <S2SV_ModStart> min_filter_level ) { yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame , <S2SV_ModStart> max_filter_level ) { yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int best_filt_val = cm -> filter_level ; <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug>"
1200,CWE-190,"static int growOpArray ( Vdbe * v , int nOp ) { VdbeOp * pNew ; Parse * p = v -> pParse ; # ifdef SQLITE_TEST_REALLOC_STRESS <S2SV_StartBug> int nNew = ( v -> nOpAlloc >= 512 ? v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ; <S2SV_EndBug> # else <S2SV_StartBug> int nNew = ( v -> nOpAlloc ? v -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ; <S2SV_EndBug> UNUSED_PARAMETER ( nOp ) ; # endif if ( nNew > p -> db -> aLimit [ SQLITE_LIMIT_VDBE_OP ] ) { sqlite3OomFault ( p -> db ) ; return SQLITE_NOMEM ; } assert ( nOp <= ( 1024 / sizeof ( Op ) ) ) ; assert ( nNew >= ( v -> nOpAlloc + nOp ) ) ; pNew = sqlite3DbRealloc ( p -> db , v -> aOp , nNew * sizeof ( Op ) ) ; if ( pNew ) { p -> szOpAlloc = sqlite3DbMallocSize ( p -> db , pNew ) ; v -> nOpAlloc = p -> szOpAlloc / sizeof ( Op ) ; v -> aOp = pNew ; } return ( pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT ) ; }
","<S2SV_ModStart> # ifdef SQLITE_TEST_REALLOC_STRESS sqlite3_int64 <S2SV_ModEnd> nNew = ( <S2SV_ModStart> >= 512 ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> v -> nOpAlloc <S2SV_ModStart> ; # else sqlite3_int64 <S2SV_ModEnd> nNew = ( <S2SV_ModStart> -> nOpAlloc ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> 1024 / sizeof <S2SV_ModStart> sizeof ( Op <S2SV_ModEnd> ) ) ;
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z,<S2SV_StartBug> int nNew = ( v -> nOpAlloc >= 512 ? v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ; <S2SV_EndBug> <S2SV_StartBug> int nNew = ( v -> nOpAlloc ? v -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ; <S2SV_EndBug>
2503,CWE-264,"int rpc_type_of_NPPVariable ( int variable ) { int type ; switch ( variable ) { case NPPVpluginNameString : case NPPVpluginDescriptionString : <S2SV_StartBug> case NPPVformValue : <S2SV_EndBug> type = RPC_TYPE_STRING ; break ; case NPPVpluginWindowSize : case NPPVpluginTimerInterval : type = RPC_TYPE_INT32 ; break ; case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory : <S2SV_StartBug> type = RPC_TYPE_BOOLEAN ; <S2SV_EndBug> break ; case NPPVpluginScriptableNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; }
","<S2SV_ModStart> : case NPPVformValue : case NPPVpluginNativeAccessibleAtkPlugId <S2SV_ModStart> case NPPVpluginKeepLibraryInMemory : case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling :
",davidben@nspluginwrapper/7e4ab8e1189846041f955e6c83f72bc1624e7a98,CVE-2011-2486,https://github.com/davidben/nspluginwrapper/commit/7e4ab8e1189846041f955e6c83f72bc1624e7a98,2012-11-19T12:10Z,<S2SV_StartBug> case NPPVformValue : <S2SV_EndBug> <S2SV_StartBug> type = RPC_TYPE_BOOLEAN ; <S2SV_EndBug>
1519,CWE-119,"<S2SV_StartBug> static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctrl_id , va_list args ) { int * update_info = va_arg ( args , int * ) ; if ( update_info && ! ctx -> yv12_frame_buffers . use_frame_threads ) { VP8D_COMP * pbi = ( VP8D_COMP * ) ctx -> yv12_frame_buffers . pbi [ 0 ] ; * update_info = pbi -> common . refresh_alt_ref_frame * ( int ) VP8_ALTR_FRAME + pbi -> common . refresh_golden_frame * ( int ) VP8_GOLD_FRAME + pbi -> common . refresh_last_frame * ( int ) VP8_LAST_FRAME ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug>"
383,CWE-119,"int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { <S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> ( ( const char * ) ( const void * ) p + <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; <S2SV_StartBug> DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_EndBug> inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
","<S2SV_ModStart> ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ) p + ofs <S2SV_ModEnd> - 2 * <S2SV_ModStart> sizeof ( uint32_t ) <S2SV_ModStart> SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_ModEnd> inp [ i <S2SV_ModStart> - p , offs <S2SV_ModEnd> ) ) ;
",glensc@file/1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b,CVE-2012-1571,https://github.com/glensc/file/commit/1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b,2012-07-17T21:55Z,"<S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_EndBug> <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug>"
6540,CWE-119,"static cJSON * cJSON_New_Item ( void ) { cJSON * node = ( cJSON * ) cJSON_malloc ( sizeof ( cJSON ) ) ; if ( node ) memset ( node , 0 , sizeof ( cJSON ) ) ; return node ; }
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,
2295,CWE-119,"static xmlChar * xmlParseAttValueComplex ( xmlParserCtxtPtr ctxt , int * attlen , int normalize ) { xmlChar limit = 0 ; xmlChar * buf = NULL ; xmlChar * rep = NULL ; int len = 0 ; int buf_size = 0 ; int c , l , in_space = 0 ; xmlChar * current = NULL ; xmlEntityPtr ent ; if ( NXT ( 0 ) == \'""\' ) { ctxt -> instate = XML_PARSER_ATTRIBUTE_VALUE ; limit = \'""\' ; NEXT ; } else if ( NXT ( 0 ) == '\\'' ) { limit = '\\'' ; ctxt -> instate = XML_PARSER_ATTRIBUTE_VALUE ; NEXT ; } else { xmlFatalErr ( ctxt , XML_ERR_ATTRIBUTE_NOT_STARTED , NULL ) ; return ( NULL ) ; } buf_size = XML_PARSER_BUFFER_SIZE ; buf = ( xmlChar * ) xmlMallocAtomic ( buf_size * sizeof ( xmlChar ) ) ; if ( buf == NULL ) goto mem_error ; c = CUR_CHAR ( l ) ; while ( ( NXT ( 0 ) != limit ) && ( IS_CHAR ( c ) ) && ( c != '<' ) ) { if ( c == 0 ) break ; if ( c == '&' ) { in_space = 0 ; if ( NXT ( 1 ) == '#' ) { int val = xmlParseCharRef ( ctxt ) ; if ( val == '&' ) { if ( ctxt -> replaceEntities ) { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } buf [ len ++ ] = '&' ; } else { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } buf [ len ++ ] = '&' ; buf [ len ++ ] = '#' ; buf [ len ++ ] = '3' ; buf [ len ++ ] = '8' ; buf [ len ++ ] = ';' ; } } else if ( val != 0 ) { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } len += xmlCopyChar ( 0 , & buf [ len ] , val ) ; } } else { ent = xmlParseEntityRef ( ctxt ) ; ctxt -> nbentities ++ ; if ( ent != NULL ) ctxt -> nbentities += ent -> owner ; if ( ( ent != NULL ) && ( ent -> etype == XML_INTERNAL_PREDEFINED_ENTITY ) ) { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } if ( ( ctxt -> replaceEntities == 0 ) && ( ent -> content [ 0 ] == '&' ) ) { buf [ len ++ ] = '&' ; buf [ len ++ ] = '#' ; buf [ len ++ ] = '3' ; buf [ len ++ ] = '8' ; buf [ len ++ ] = ';' ; } else { buf [ len ++ ] = ent -> content [ 0 ] ; } } else if ( ( ent != NULL ) && ( ctxt -> replaceEntities != 0 ) ) { if ( ent -> etype != XML_INTERNAL_PREDEFINED_ENTITY ) { rep = xmlStringDecodeEntities ( ctxt , ent -> content , XML_SUBSTITUTE_REF , 0 , 0 , 0 ) ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { if ( ( * current == 0xD ) || ( * current == 0xA ) || ( * current == 0x9 ) ) { buf [ len ++ ] = 0x20 ; current ++ ; } else buf [ len ++ ] = * current ++ ; if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } } xmlFree ( rep ) ; rep = NULL ; } } else { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } if ( ent -> content != NULL ) buf [ len ++ ] = ent -> content [ 0 ] ; } } else if ( ent != NULL ) { int i = xmlStrlen ( ent -> name ) ; const xmlChar * cur = ent -> name ; if ( ( ent -> etype != XML_INTERNAL_PREDEFINED_ENTITY ) && ( ent -> content != NULL ) ) { rep = xmlStringDecodeEntities ( ctxt , ent -> content , XML_SUBSTITUTE_REF , 0 , 0 , 0 ) ; if ( rep != NULL ) { xmlFree ( rep ) ; rep = NULL ; } } buf [ len ++ ] = '&' ; while ( len > buf_size - i - 10 ) { growBuffer ( buf , i + 10 ) ; } for ( ; i > 0 ; i -- ) buf [ len ++ ] = * cur ++ ; buf [ len ++ ] = ';' ; } } } else { if ( ( c == 0x20 ) || ( c == 0xD ) || ( c == 0xA ) || ( c == 0x9 ) ) { if ( ( len != 0 ) || ( ! normalize ) ) { if ( ( ! normalize ) || ( ! in_space ) ) { COPY_BUF ( l , buf , len , 0x20 ) ; while ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } } in_space = 1 ; } } else { in_space = 0 ; COPY_BUF ( l , buf , len , c ) ; if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } } NEXTL ( l ) ; } GROW ; c = CUR_CHAR ( l ) ; } if ( ( in_space ) && ( normalize ) ) { <S2SV_StartBug> while ( buf [ len - 1 ] == 0x20 ) len -- ; <S2SV_EndBug> } buf [ len ] = 0 ; if ( RAW == '<' ) { xmlFatalErr ( ctxt , XML_ERR_LT_IN_ATTRIBUTE , NULL ) ; } else if ( RAW != limit ) { if ( ( c != 0 ) && ( ! IS_CHAR ( c ) ) ) { xmlFatalErrMsg ( ctxt , XML_ERR_INVALID_CHAR , ""invalid<S2SV_blank>character<S2SV_blank>in<S2SV_blank>attribute<S2SV_blank>value\\n"" ) ; } else { xmlFatalErrMsg ( ctxt , XML_ERR_ATTRIBUTE_NOT_FINISHED , ""AttValue:<S2SV_blank>\'<S2SV_blank>expected\\n"" ) ; } } else NEXT ; if ( attlen != NULL ) * attlen = len ; return ( buf ) ; mem_error : xmlErrMemory ( ctxt , NULL ) ; if ( buf != NULL ) xmlFree ( buf ) ; if ( rep != NULL ) xmlFree ( rep ) ; return ( NULL ) ; }
","<S2SV_ModStart> { while ( ( len > 0 ) && ( <S2SV_ModStart> == 0x20 ) )
",chromium@chromium/6e487b9db2ff0324523a040180f8da42796aeef5,CVE-2012-5134,https://github.com/chromium/chromium/commit/6e487b9db2ff0324523a040180f8da42796aeef5,2012-11-28T01:55Z,<S2SV_StartBug> while ( buf [ len - 1 ] == 0x20 ) len -- ; <S2SV_EndBug>
3195,CWE-189,"static u32 apic_get_tmcct ( struct kvm_lapic * apic ) { ktime_t remaining ; s64 ns ; u32 tmcct ; ASSERT ( apic != NULL ) ; <S2SV_StartBug> if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 ) <S2SV_EndBug> return 0 ; remaining = hrtimer_get_remaining ( & apic -> lapic_timer . timer ) ; if ( ktime_to_ns ( remaining ) < 0 ) remaining = ktime_set ( 0 , 0 ) ; ns = mod_64 ( ktime_to_ns ( remaining ) , apic -> lapic_timer . period ) ; tmcct = div64_u64 ( ns , ( APIC_BUS_CYCLE_NS * apic -> divide_count ) ) ; return tmcct ; }
","<S2SV_ModStart> , APIC_TMICT ) == 0 || apic -> lapic_timer . period
",torvalds@linux/b963a22e6d1a266a67e9eecc88134713fd54775c,CVE-2013-6367,https://github.com/torvalds/linux/commit/b963a22e6d1a266a67e9eecc88134713fd54775c,2013-12-14T18:08Z,"<S2SV_StartBug> if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 ) <S2SV_EndBug>"
3568,CWE-119,"<S2SV_StartBug> void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) { <S2SV_EndBug> bloc = * offset ; <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> * offset = bloc ; }
","<S2SV_ModStart> int * offset , int maxoffset <S2SV_ModStart> NULL , fout , maxoffset
",ioquake@ioq3/d2b1d124d4055c2fcbe5126863487c52fd58cca1,CVE-2017-11721,https://github.com/ioquake/ioq3/commit/d2b1d124d4055c2fcbe5126863487c52fd58cca1,2017-08-03T08:29Z,"<S2SV_StartBug> void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) { <S2SV_EndBug> <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug>"
2582,CWE-125,"static int print_prefix ( netdissect_options * ndo , const u_char * prefix , u_int max_length ) { int plenbytes ; char buf [ sizeof ( ""xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128"" ) ] ; if ( prefix [ 0 ] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 && is_ipv4_mapped_address ( & prefix [ 1 ] ) ) { struct in_addr addr ; u_int plen ; plen = prefix [ 0 ] - 96 ; if ( 32 < plen ) return - 1 ; max_length -= 1 ; memset ( & addr , 0 , sizeof ( addr ) ) ; plenbytes = ( plen + 7 ) / 8 ; if ( max_length < ( u_int ) plenbytes + IPV4_MAPPED_HEADING_LEN ) return - 3 ; memcpy ( & addr , & prefix [ 1 + IPV4_MAPPED_HEADING_LEN ] , plenbytes ) ; if ( plen % 8 ) { ( ( u_char * ) & addr ) [ plenbytes - 1 ] &= ( ( 0xff00 >> ( plen % 8 ) ) & 0xff ) ; } snprintf ( buf , sizeof ( buf ) , ""%s/%d"" , ipaddr_string ( ndo , & addr ) , plen ) ; plenbytes += 1 + IPV4_MAPPED_HEADING_LEN ; } else { plenbytes = decode_prefix6 ( ndo , prefix , max_length , buf , sizeof ( buf ) ) ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , buf ) ) ; return plenbytes ; }
","<S2SV_ModStart> ) ) ; if ( plenbytes < 0 ) return plenbytes ;
",the-tcpdump-group@tcpdump/83a412a5275cac973c5841eca3511c766bed778d,CVE-2018-16228,https://github.com/the-tcpdump-group/tcpdump/commit/83a412a5275cac973c5841eca3511c766bed778d,2019-10-03T16:15Z,<S2SV_StartBug> } <S2SV_EndBug>
2100,CWE-125,"static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) <S2SV_EndBug> return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) <S2SV_EndBug> return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) <S2SV_EndBug> return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ; <S2SV_StartBug> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <S2SV_EndBug> offset += tim . length - 3 ; length -= tim . length - 3 ; if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }
","<S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> p + offset <S2SV_ModEnd> , tim .
",the-tcpdump-group@tcpdump/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562,CVE-2017-13008,https://github.com/the-tcpdump-group/tcpdump/commit/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562,2017-09-14T06:29Z,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <S2SV_EndBug>"
5056,CWE-189,"Datum varbit_in ( PG_FUNCTION_ARGS ) { char * input_string = PG_GETARG_CSTRING ( 0 ) ; # ifdef NOT_USED Oid typelem = PG_GETARG_OID ( 1 ) ; # endif int32 atttypmod = PG_GETARG_INT32 ( 2 ) ; VarBit * result ; char * sp ; bits8 * r ; int len , bitlen , slen ; bool bit_not_hex ; int bc ; bits8 x = 0 ; if ( input_string [ 0 ] == 'b' || input_string [ 0 ] == 'B' ) { bit_not_hex = true ; sp = input_string + 1 ; } else if ( input_string [ 0 ] == 'x' || input_string [ 0 ] == 'X' ) { bit_not_hex = false ; sp = input_string + 1 ; } else { bit_not_hex = true ; sp = input_string ; } slen = strlen ( sp ) ; if ( bit_not_hex ) bitlen = slen ; else <S2SV_StartBug> bitlen = slen * 4 ; <S2SV_EndBug> if ( atttypmod <= 0 ) atttypmod = bitlen ; else if ( bitlen > atttypmod ) ereport ( ERROR , ( errcode ( ERRCODE_STRING_DATA_RIGHT_TRUNCATION ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long<S2SV_blank>for<S2SV_blank>type<S2SV_blank>bit<S2SV_blank>varying(%d)"" , atttypmod ) ) ) ; len = VARBITTOTALLEN ( bitlen ) ; result = ( VarBit * ) palloc0 ( len ) ; SET_VARSIZE ( result , len ) ; VARBITLEN ( result ) = Min ( bitlen , atttypmod ) ; r = VARBITS ( result ) ; if ( bit_not_hex ) { x = HIGHBIT ; for ( ; * sp ; sp ++ ) { if ( * sp == '1' ) * r |= x ; else if ( * sp != '0' ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""\\""%c\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>binary<S2SV_blank>digit"" , * sp ) ) ) ; x >>= 1 ; if ( x == 0 ) { x = HIGHBIT ; r ++ ; } } } else { for ( bc = 0 ; * sp ; sp ++ ) { if ( * sp >= '0' && * sp <= '9' ) x = ( bits8 ) ( * sp - '0' ) ; else if ( * sp >= 'A' && * sp <= 'F' ) x = ( bits8 ) ( * sp - 'A' ) + 10 ; else if ( * sp >= 'a' && * sp <= 'f' ) x = ( bits8 ) ( * sp - 'a' ) + 10 ; else ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""\\""%c\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>hexadecimal<S2SV_blank>digit"" , * sp ) ) ) ; if ( bc ) { * r ++ |= x ; bc = 0 ; } else { * r = x << 4 ; bc = 1 ; } } } PG_RETURN_VARBIT_P ( result ) ; }
","<S2SV_ModStart> slen ; else { if ( slen > VARBITMAXLEN / 4 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) ) ; <S2SV_ModStart> * 4 ; }
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,<S2SV_StartBug> bitlen = slen * 4 ; <S2SV_EndBug>
3141,CWE-20,"static int snd_timer_start_slave ( struct snd_timer_instance * timeri ) { unsigned long flags ; spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags |= SNDRV_TIMER_IFLG_RUNNING ; <S2SV_StartBug> if ( timeri -> master ) <S2SV_EndBug> list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ; <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> return 1 ; }
","<S2SV_ModStart> timeri -> master && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ; <S2SV_ModEnd> list_add_tail ( & <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & timeri -> timer -> lock ) ; }
",torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z,"<S2SV_StartBug> if ( timeri -> master ) <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug>"
476,CWE-125,"static int java_switch_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { ut8 op_byte = data [ 0 ] ; ut64 offset = addr - java_get_method_start ( ) ; ut8 pos = ( offset + 1 ) % 4 ? 1 + 4 - ( offset + 1 ) % 4 : 1 ; if ( op_byte == 0xaa ) { <S2SV_StartBug> if ( pos + 8 > len ) { <S2SV_EndBug> return op -> size ; } <S2SV_StartBug> int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) , <S2SV_EndBug> max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ; ut32 default_loc = ( ut32 ) ( UINT ( data , pos ) ) , cur_case = 0 ; op -> switch_op = r_anal_switch_op_new ( addr , min_val , default_loc ) ; RAnalCaseOp * caseop = NULL ; pos += 12 ; if ( max_val > min_val && ( ( max_val - min_val ) < ( UT16_MAX / 4 ) ) ) { for ( cur_case = 0 ; cur_case <= max_val - min_val ; pos += 4 , cur_case ++ ) { if ( pos + 4 >= len ) { break ; } int offset = ( int ) ( ut32 ) ( R_BIN_JAVA_UINT ( data , pos ) ) ; caseop = r_anal_switch_op_add_case ( op -> switch_op , addr + pos , cur_case + min_val , addr + offset ) ; if ( caseop ) { caseop -> bb_ref_to = addr + offset ; caseop -> bb_ref_from = addr ; } } } else { eprintf ( ""Invalid<S2SV_blank>switch<S2SV_blank>boundaries<S2SV_blank>at<S2SV_blank>0x%"" PFMT64x ""\\n"" , addr ) ; } } op -> size = pos ; return op -> size ; }
","<S2SV_ModStart> pos + 8 + 8 <S2SV_ModStart> size ; } const <S2SV_ModStart> 4 ) ) ; const int <S2SV_ModEnd> max_val = (
",radare@radare2/224e6bc13fa353dd3b7f7a2334588f1c4229e58d,CVE-2018-12321,https://github.com/radare/radare2/commit/224e6bc13fa353dd3b7f7a2334588f1c4229e58d,2018-06-13T16:29Z,"<S2SV_StartBug> if ( pos + 8 > len ) { <S2SV_EndBug> <S2SV_StartBug> int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) , <S2SV_EndBug>"
2155,CWE-362,"void sctp_generate_heartbeat_event ( unsigned long data ) { int error = 0 ; struct sctp_transport * transport = ( struct sctp_transport * ) data ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> hb_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_HEARTBEAT ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_transport_put ( transport ) ; }
","<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
",torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e,CVE-2015-8767,https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e,2016-02-08T03:59Z,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug>
2435,CWE-119,"static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; } switch ( sun_info . maptype ) { case RMT_NONE : { if ( sun_info . depth < 24 ) { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * sun_data ) ) ; <S2SV_EndBug> if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; <S2SV_StartBug> height = sun_info . height ; <S2SV_EndBug> bytes_per_line = sun_info . width * sun_info . depth ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> ( size_t ) MagickMax ( <S2SV_ModStart> . length , bytes_per_line * sun_info . width ) , <S2SV_ModStart> sun_info . height <S2SV_ModEnd> ; if (
",ImageMagick@ImageMagick/78f82d9d1c2944725a279acd573a22168dc6e22a,CVE-2015-8957,https://github.com/ImageMagick/ImageMagick/commit/78f82d9d1c2944725a279acd573a22168dc6e22a,2017-04-20T18:59Z,"<S2SV_StartBug> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * sun_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> height = sun_info . height ; <S2SV_EndBug>"
794,CWE-119,"static void WritePixels ( struct ngiflib_img * i , struct ngiflib_decode_context * context , const u8 * pixels , u16 n ) { u16 tocopy ; struct ngiflib_gif * p = i -> parent ; while ( n > 0 ) { tocopy = ( context -> Xtogo < n ) ? context -> Xtogo : n ; if ( ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif ngiflib_memcpy ( context -> frbuff_p . p8 , pixels , tocopy ) ; pixels += tocopy ; context -> frbuff_p . p8 += tocopy ; # ifndef NGIFLIB_INDEXED_ONLY } else { int j ; for ( j = ( int ) tocopy ; j > 0 ; j -- ) { * ( context -> frbuff_p . p32 ++ ) = GifIndexToTrueColor ( i -> palette , * pixels ++ ) ; } } # endif } else { int j ; # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) * context -> frbuff_p . p8 = * pixels ; pixels ++ ; context -> frbuff_p . p8 ++ ; } # ifndef NGIFLIB_INDEXED_ONLY } else { for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) { * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , * pixels ) ; } pixels ++ ; context -> frbuff_p . p32 ++ ; } } # endif } context -> Xtogo -= tocopy ; if ( context -> Xtogo == 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } n -= tocopy ; } }
","<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
",miniupnp@ngiflib/37d939a6f511d16d4c95678025c235fe62e6417a,CVE-2019-16347,https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a,2019-09-16T13:15Z,<S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug>
10,CWE-400,"static void Rp_test ( js_State * J ) { js_Regexp * re ; const char * text ; <S2SV_StartBug> int opts ; <S2SV_EndBug> Resub m ; re = js_toregexp ( J , 0 ) ; text = js_tostring ( J , 1 ) ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushboolean ( J , 0 ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; js_pushboolean ( J , 1 ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushboolean ( J , 0 ) ; }
","<S2SV_ModStart> text ; int result ; int <S2SV_ModStart> ; } } result = <S2SV_ModEnd> js_regexec ( re <S2SV_ModStart> , opts ) ; if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ; if ( result == 0
",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z,"<S2SV_StartBug> int opts ; <S2SV_EndBug> <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug>"
1100,CWE-119,"int yr_object_array_set_item ( YR_OBJECT * object , YR_OBJECT * item , int index ) { YR_OBJECT_ARRAY * array ; int i ; int count ; assert ( index >= 0 ) ; assert ( object -> type == OBJECT_TYPE_ARRAY ) ; array = object_as_array ( object ) ; if ( array -> items == NULL ) { <S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; memset ( array -> items -> objects , 0 , count * sizeof ( YR_OBJECT * ) ) ; array -> items -> count = count ; } else if ( index >= array -> items -> count ) { count = array -> items -> count * 2 ; <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; for ( i = array -> items -> count ; i < count ; i ++ ) array -> items -> objects [ i ] = NULL ; array -> items -> count = count ; } item -> parent = object ; array -> items -> objects [ index ] = item ; return ERROR_SUCCESS ; }
","<S2SV_ModStart> { count = 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> ; array -> <S2SV_ModStart> * 2 ; while ( count <= index ) count *= 2 ;
",VirusTotal@yara/4a342f01e5439b9bb901aff1c6c23c536baeeb3f,CVE-2017-11328,https://github.com/VirusTotal/yara/commit/4a342f01e5439b9bb901aff1c6c23c536baeeb3f,2017-07-17T13:18Z,"<S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug>"
4921,CWE-617,"void deinit_pci ( struct vmctx * ctx ) { struct pci_vdev_ops * ops ; struct businfo * bi ; struct slotinfo * si ; struct funcinfo * fi ; int bus , slot , func ; size_t lowmem ; struct mem_range mr ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""PCI<S2SV_blank>ECFG"" ; mr . base = PCI_EMUL_ECFG_BASE ; mr . size = PCI_EMUL_ECFG_SIZE ; unregister_mem ( & mr ) ; lowmem = vm_get_lowmem_size ( ctx ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""PCI<S2SV_blank>hole<S2SV_blank>(32-bit)"" ; mr . base = lowmem ; mr . size = ( 4ULL * 1024 * 1024 * 1024 ) - lowmem ; unregister_mem_fallback ( & mr ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""PCI<S2SV_blank>hole<S2SV_blank>(64-bit)"" ; mr . base = PCI_EMUL_MEMBASE64 ; mr . size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64 ; unregister_mem_fallback ( & mr ) ; for ( bus = 0 ; bus < MAXBUSES ; bus ++ ) { bi = pci_businfo [ bus ] ; if ( bi == NULL ) continue ; for ( slot = 0 ; slot < MAXSLOTS ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { fi = & si -> si_funcs [ func ] ; if ( fi -> fi_name == NULL ) continue ; ops = pci_emul_finddev ( fi -> fi_name ) ; <S2SV_StartBug> assert ( ops != NULL ) ; <S2SV_EndBug> pr_notice ( ""pci<S2SV_blank>deinit<S2SV_blank>%s\\n"" , fi -> fi_name ) ; pci_emul_deinit ( ctx , ops , bus , slot , func , fi ) ; } } } }
","<S2SV_ModStart> fi_name ) ; if ( ! ops ) { pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\n"" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> pr_notice ( ""pci<S2SV_blank>deinit<S2SV_blank>%s\\n""
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,<S2SV_StartBug> assert ( ops != NULL ) ; <S2SV_EndBug>
6149,CWE-125,"int dbd_st_prepare ( SV * sth , imp_sth_t * imp_sth , char * statement , SV * attribs ) { int i ; SV * * svp ; dTHX ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION # if MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION char * str_ptr , * str_last_ptr ; # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION int limit_flag = 0 ; # endif # endif <S2SV_StartBug> int col_type , prepare_retval ; <S2SV_EndBug> MYSQL_BIND * bind , * bind_end ; imp_sth_phb_t * fbind ; # endif D_imp_xxh ( sth ) ; D_imp_dbh_from_sth ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t-><S2SV_blank>dbd_st_prepare<S2SV_blank>MYSQL_VERSION_ID<S2SV_blank>%d,<S2SV_blank>SQL<S2SV_blank>statement:<S2SV_blank>%s\\n"" , MYSQL_VERSION_ID , statement ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION imp_sth -> use_server_side_prepare = imp_dbh -> use_server_side_prepare ; if ( attribs ) { svp = DBD_ATTRIB_GET_SVP ( attribs , ""mysql_server_prepare"" , 20 ) ; imp_sth -> use_server_side_prepare = ( svp ) ? SvTRUE ( * svp ) : imp_dbh -> use_server_side_prepare ; svp = DBD_ATTRIB_GET_SVP ( attribs , ""async"" , 5 ) ; if ( svp && SvTRUE ( * svp ) ) { # if MYSQL_ASYNC imp_sth -> is_async = TRUE ; imp_sth -> use_server_side_prepare = FALSE ; # else do_error ( sth , 2000 , ""Async<S2SV_blank>support<S2SV_blank>was<S2SV_blank>not<S2SV_blank>built<S2SV_blank>into<S2SV_blank>this<S2SV_blank>version<S2SV_blank>of<S2SV_blank>DBD::mysql"" , ""HY000"" ) ; return 0 ; # endif } } imp_sth -> fetch_done = 0 ; # endif imp_sth -> done_desc = 0 ; imp_sth -> result = NULL ; imp_sth -> currow = 0 ; svp = DBD_ATTRIB_GET_SVP ( attribs , ""mysql_use_result"" , 16 ) ; imp_sth -> use_mysql_use_result = svp ? SvTRUE ( * svp ) : imp_dbh -> use_mysql_use_result ; for ( i = 0 ; i < AV_ATTRIB_LAST ; i ++ ) imp_sth -> av_attr [ i ] = Nullav ; mysql_st_free_result_sets ( sth , imp_sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION && MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tuse_server_side_prepare<S2SV_blank>set,<S2SV_blank>check<S2SV_blank>restrictions\\n"" ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION ""\\t\\tneed<S2SV_blank>to<S2SV_blank>test<S2SV_blank>for<S2SV_blank>LIMIT<S2SV_blank>&<S2SV_blank>CALL\\n"" ) ; # else ""\\t\\tneed<S2SV_blank>to<S2SV_blank>test<S2SV_blank>for<S2SV_blank>restrictions\\n"" ) ; # endif str_last_ptr = statement + strlen ( statement ) ; for ( str_ptr = statement ; str_ptr < str_last_ptr ; str_ptr ++ ) { # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION if ( limit_flag ) { if ( * str_ptr == '?' ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tLIMIT<S2SV_blank>and<S2SV_blank>?<S2SV_blank>found,<S2SV_blank>set<S2SV_blank>to<S2SV_blank>use_server_side_prepare=0\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; break ; } } else if ( str_ptr < str_last_ptr - 6 && isspace ( * ( str_ptr + 0 ) ) && tolower ( * ( str_ptr + 1 ) ) == 'l' && tolower ( * ( str_ptr + 2 ) ) == 'i' && tolower ( * ( str_ptr + 3 ) ) == 'm' && tolower ( * ( str_ptr + 4 ) ) == 'i' && tolower ( * ( str_ptr + 5 ) ) == 't' && isspace ( * ( str_ptr + 6 ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""LIMIT<S2SV_blank>set<S2SV_blank>limit<S2SV_blank>flag<S2SV_blank>to<S2SV_blank>1\\n"" ) ; limit_flag = 1 ; } # endif if ( str_ptr < str_last_ptr - 4 && tolower ( * ( str_ptr + 0 ) ) == 'c' && tolower ( * ( str_ptr + 1 ) ) == 'a' && tolower ( * ( str_ptr + 2 ) ) == 'l' && tolower ( * ( str_ptr + 3 ) ) == 'l' && isspace ( * ( str_ptr + 4 ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""Disable<S2SV_blank>PS<S2SV_blank>mode<S2SV_blank>for<S2SV_blank>CALL()\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; break ; } } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tuse_server_side_prepare<S2SV_blank>set\\n"" ) ; if ( imp_sth -> stmt ) fprintf ( stderr , <S2SV_StartBug> ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" ) ; <S2SV_EndBug> imp_sth -> stmt = mysql_stmt_init ( imp_dbh -> pmysql ) ; if ( ! imp_sth -> stmt ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , <S2SV_StartBug> ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" , <S2SV_EndBug> mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) ) ; } prepare_retval = mysql_stmt_prepare ( imp_sth -> stmt , statement , strlen ( statement ) ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_stmt_prepare<S2SV_blank>returned<S2SV_blank>%d\\n"" , prepare_retval ) ; if ( prepare_retval ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_stmt_prepare<S2SV_blank>%d<S2SV_blank>%s\\n"" , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) ) ; if ( mysql_stmt_errno ( imp_sth -> stmt ) == ER_UNSUPPORTED_PS ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tSETTING<S2SV_blank>imp_sth->use_server_side_prepare<S2SV_blank>to<S2SV_blank>0\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; } else { do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; mysql_stmt_close ( imp_sth -> stmt ) ; imp_sth -> stmt = NULL ; return FALSE ; } } else { DBIc_NUM_PARAMS ( imp_sth ) = mysql_stmt_param_count ( imp_sth -> stmt ) ; if ( DBIc_NUM_PARAMS ( imp_sth ) > 0 ) { <S2SV_StartBug> int has_statement_fields = imp_sth -> stmt -> fields != 0 ; <S2SV_EndBug> imp_sth -> bind = alloc_bind ( DBIc_NUM_PARAMS ( imp_sth ) ) ; imp_sth -> fbind = alloc_fbind ( DBIc_NUM_PARAMS ( imp_sth ) ) ; imp_sth -> has_been_bound = 0 ; for ( i = 0 , bind = imp_sth -> bind , fbind = imp_sth -> fbind , bind_end = bind + DBIc_NUM_PARAMS ( imp_sth ) ; bind < bind_end ; bind ++ , fbind ++ , i ++ ) { <S2SV_StartBug> col_type = ( has_statement_fields ? <S2SV_EndBug> imp_sth -> stmt -> fields [ i ] . type : MYSQL_TYPE_STRING ) ; bind -> buffer_type = mysql_to_perl_type ( col_type ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_to_perl_type<S2SV_blank>returned<S2SV_blank>%d\\n"" , col_type ) ; bind -> buffer = NULL ; bind -> length = & ( fbind -> length ) ; bind -> is_null = ( char * ) & ( fbind -> is_null ) ; fbind -> is_null = 1 ; fbind -> length = 0 ; } } } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare == 0 ) DBIc_NUM_PARAMS ( imp_sth ) = count_params ( ( imp_xxh_t * ) imp_dbh , aTHX_ statement , imp_dbh -> bind_comment_placeholders ) ; # else DBIc_NUM_PARAMS ( imp_sth ) = count_params ( ( imp_xxh_t * ) imp_dbh , aTHX_ statement , imp_dbh -> bind_comment_placeholders ) ; # endif imp_sth -> params = alloc_param ( DBIc_NUM_PARAMS ( imp_sth ) ) ; DBIc_IMPSET_on ( imp_sth ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_prepare\\n"" ) ; return 1 ; }
","<S2SV_ModStart> # endif int <S2SV_ModEnd> prepare_retval ; MYSQL_BIND <S2SV_ModStart> ( stderr , ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" <S2SV_ModEnd> ) ; imp_sth <S2SV_ModStart> imp_xxh ) , ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" <S2SV_ModEnd> , mysql_errno ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> imp_sth -> bind <S2SV_ModStart> ++ ) { bind -> buffer_type = MYSQL_TYPE_STRING <S2SV_ModEnd> ; bind ->
",perl5-dbi@DBD-mysql/793b72b1a0baa5070adacaac0e12fd995a6fbabe,CVE-2016-1249,https://github.com/perl5-dbi/DBD-mysql/commit/793b72b1a0baa5070adacaac0e12fd995a6fbabe,2017-02-17T02:59Z,"<S2SV_StartBug> int col_type , prepare_retval ; <S2SV_EndBug> <S2SV_StartBug> ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> int has_statement_fields = imp_sth -> stmt -> fields != 0 ; <S2SV_EndBug> <S2SV_StartBug> col_type = ( has_statement_fields ? <S2SV_EndBug>"
2793,CWE-125,"static const char * parse_string ( cJSON * item , const char * str , const char * * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; if ( * str != \'\\""\' ) { * ep = str ; return 0 ; } <S2SV_StartBug> while ( * end_ptr != \'\\""\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\' ) end_ptr ++ ; <S2SV_EndBug> out = ( char * ) cJSON_malloc ( len + 1 ) ; if ( ! out ) return 0 ; item -> valuestring = out ; item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) { if ( * ptr != '\\\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\\b' ; break ; case 'f' : * ptr2 ++ = '\\f' ; break ; case 'n' : * ptr2 ++ = '\\n' ; break ; case 'r' : * ptr2 ++ = '\\r' ; break ; case 't' : * ptr2 ++ = '\\t' ; break ; case 'u' : uc = parse_hex4 ( ptr + 1 ) ; ptr += 4 ; if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) { * ep = str ; return 0 ; } if ( uc >= 0xD800 && uc <= 0xDBFF ) { if ( ptr + 6 > end_ptr ) { * ep = str ; return 0 ; } if ( ptr [ 1 ] != '\\\\' || ptr [ 2 ] != 'u' ) { * ep = str ; return 0 ; } uc2 = parse_hex4 ( ptr + 3 ) ; ptr += 6 ; if ( uc2 < 0xDC00 || uc2 > 0xDFFF ) { * ep = str ; return 0 ; } uc = 0x10000 + ( ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF ) ) ; } len = 4 ; if ( uc < 0x80 ) len = 1 ; else if ( uc < 0x800 ) len = 2 ; else if ( uc < 0x10000 ) len = 3 ; ptr2 += len ; switch ( len ) { case 4 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 3 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 2 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 1 : * -- ptr2 = ( uc | firstByteMark [ len ] ) ; } ptr2 += len ; break ; default : * ptr2 ++ = * ptr ; break ; } ptr ++ ; } } * ptr2 = 0 ; if ( * ptr == \'\\""\' ) ptr ++ ; return ptr ; }
","<S2SV_ModStart> ++ len ) { <S2SV_ModStart> == '\\\\' ) { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } } <S2SV_ModEnd> out = (
",DaveGamble@cJSON/94df772485c92866ca417d92137747b2e3b0a917,CVE-2016-10749,https://github.com/DaveGamble/cJSON/commit/94df772485c92866ca417d92137747b2e3b0a917,2019-04-29T14:29Z,"<S2SV_StartBug> while ( * end_ptr != \'\\""\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\' ) end_ptr ++ ; <S2SV_EndBug>"
2351,CWE-20,"int bnep_add_connection ( struct bnep_connadd_req * req , struct socket * sock ) { struct net_device * dev ; struct bnep_session * s , * ss ; u8 dst [ ETH_ALEN ] , src [ ETH_ALEN ] ; int err ; BT_DBG ( """" ) ; <S2SV_StartBug> baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ; <S2SV_EndBug> baswap ( ( void * ) src , & l2cap_pi ( sock -> sk ) -> chan -> src ) ; dev = alloc_netdev ( sizeof ( struct bnep_session ) , ( * req -> device ) ? req -> device : ""bnep%d"" , NET_NAME_UNKNOWN , bnep_net_setup ) ; if ( ! dev ) return - ENOMEM ; down_write ( & bnep_session_sem ) ; ss = __bnep_get_session ( dst ) ; if ( ss && ss -> state == BT_CONNECTED ) { err = - EEXIST ; goto failed ; } s = netdev_priv ( dev ) ; memcpy ( s -> eh . h_dest , & src , ETH_ALEN ) ; memcpy ( s -> eh . h_source , & dst , ETH_ALEN ) ; memcpy ( dev -> dev_addr , s -> eh . h_dest , ETH_ALEN ) ; s -> dev = dev ; s -> sock = sock ; s -> role = req -> role ; s -> state = BT_CONNECTED ; s -> msg . msg_flags = MSG_NOSIGNAL ; # ifdef CONFIG_BT_BNEP_MC_FILTER set_bit ( bnep_mc_hash ( dev -> broadcast ) , ( ulong * ) & s -> mc_filter ) ; # endif # ifdef CONFIG_BT_BNEP_PROTO_FILTER bnep_set_default_proto_filter ( s ) ; # endif SET_NETDEV_DEV ( dev , bnep_get_device ( s ) ) ; SET_NETDEV_DEVTYPE ( dev , & bnep_type ) ; err = register_netdev ( dev ) ; if ( err ) goto failed ; __bnep_link_session ( s ) ; __module_get ( THIS_MODULE ) ; s -> task = kthread_run ( bnep_session , s , ""kbnepd<S2SV_blank>%s"" , dev -> name ) ; if ( IS_ERR ( s -> task ) ) { module_put ( THIS_MODULE ) ; unregister_netdev ( dev ) ; __bnep_unlink_session ( s ) ; err = PTR_ERR ( s -> task ) ; goto failed ; } up_write ( & bnep_session_sem ) ; strcpy ( req -> device , dev -> name ) ; return 0 ; failed : up_write ( & bnep_session_sem ) ; free_netdev ( dev ) ; return err ; }
","<S2SV_ModStart> """" ) ; if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ;
",torvalds@linux/71bb99a02b32b4cc4265118e85f6035ca72923f0,CVE-2017-15868,https://github.com/torvalds/linux/commit/71bb99a02b32b4cc4265118e85f6035ca72923f0,2017-12-05T23:29Z,"<S2SV_StartBug> baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ; <S2SV_EndBug>"
2483,CWE-22,"int main ( int argc , char * argv [ ] ) { struct mschm_decompressor * chmd ; struct mschmd_header * chm ; struct mschmd_file * file , * * f ; unsigned int numf , i ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; user_umask = umask ( 0 ) ; umask ( user_umask ) ; MSPACK_SYS_SELFTEST ( i ) ; if ( i ) return 0 ; if ( ( chmd = mspack_create_chm_decompressor ( NULL ) ) ) { for ( argv ++ ; * argv ; argv ++ ) { printf ( ""%s\\n"" , * argv ) ; if ( ( chm = chmd -> open ( chmd , * argv ) ) ) { for ( numf = 0 , file = chm -> files ; file ; file = file -> next ) numf ++ ; if ( ( f = ( struct mschmd_file * * ) calloc ( numf , sizeof ( struct mschmd_file * ) ) ) ) { for ( i = 0 , file = chm -> files ; file ; file = file -> next ) f [ i ++ ] = file ; qsort ( f , numf , sizeof ( struct mschmd_file * ) , & sortfunc ) ; for ( i = 0 ; i < numf ; i ++ ) { <S2SV_StartBug> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <S2SV_EndBug> printf ( ""Extracting<S2SV_blank>%s\\n"" , outname ) ; ensure_filepath ( outname ) ; if ( chmd -> extract ( chmd , f [ i ] , outname ) ) { printf ( ""%s:<S2SV_blank>extract<S2SV_blank>error<S2SV_blank>on<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , * argv , f [ i ] -> filename , ERROR ( chmd ) ) ; } free ( outname ) ; } free ( f ) ; } chmd -> close ( chmd , chm ) ; } else { printf ( ""%s:<S2SV_blank>can\'t<S2SV_blank>open<S2SV_blank>--<S2SV_blank>%s\\n"" , * argv , ERROR ( chmd ) ) ; } } mspack_destroy_chm_decompressor ( chmd ) ; } return 0 ; }
","<S2SV_ModStart> = create_output_name ( <S2SV_ModEnd> f [ i <S2SV_ModStart> ] -> filename <S2SV_ModEnd> ) ; printf
",kyz@libmspack/7cadd489698be117c47efcadd742651594429e6d,CVE-2018-18586,https://github.com/kyz/libmspack/commit/7cadd489698be117c47efcadd742651594429e6d,2018-10-23T02:29Z,"<S2SV_StartBug> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <S2SV_EndBug>"
1915,CWE-119,"<S2SV_StartBug> void fadst4_sse2 ( __m128i * in ) { <S2SV_EndBug> const __m128i k__sinpi_p01_p02 = pair_set_epi16 ( sinpi_1_9 , sinpi_2_9 ) ; const __m128i k__sinpi_p04_m01 = pair_set_epi16 ( sinpi_4_9 , - sinpi_1_9 ) ; const __m128i k__sinpi_p03_p04 = pair_set_epi16 ( sinpi_3_9 , sinpi_4_9 ) ; const __m128i k__sinpi_m03_p02 = pair_set_epi16 ( - sinpi_3_9 , sinpi_2_9 ) ; <S2SV_StartBug> const __m128i k__sinpi_p03_p03 = _mm_set1_epi16 ( sinpi_3_9 ) ; <S2SV_EndBug> const __m128i kZero = _mm_set1_epi16 ( 0 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; __m128i u [ 8 ] , v [ 8 ] ; __m128i in7 = _mm_add_epi16 ( in [ 0 ] , in [ 1 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( in [ 0 ] , in [ 1 ] ) ; u [ 1 ] = _mm_unpacklo_epi16 ( in [ 2 ] , in [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( in7 , kZero ) ; u [ 3 ] = _mm_unpacklo_epi16 ( in [ 2 ] , kZero ) ; u [ 4 ] = _mm_unpacklo_epi16 ( in [ 3 ] , kZero ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__sinpi_p01_p02 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__sinpi_p03_p04 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__sinpi_p03_p03 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 0 ] , k__sinpi_p04_m01 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 1 ] , k__sinpi_m03_p02 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__sinpi_p03_p03 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 4 ] , k__sinpi_p03_p03 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 1 ] ) ; u [ 1 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 6 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 3 ] , v [ 4 ] ) ; u [ 3 ] = _mm_sub_epi32 ( u [ 2 ] , u [ 0 ] ) ; u [ 4 ] = _mm_slli_epi32 ( v [ 5 ] , 2 ) ; u [ 5 ] = _mm_sub_epi32 ( u [ 4 ] , v [ 5 ] ) ; u [ 6 ] = _mm_add_epi32 ( u [ 3 ] , u [ 5 ] ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 2 ] ) ; in [ 1 ] = _mm_packs_epi32 ( u [ 1 ] , u [ 3 ] ) ; transpose_4x4 ( in ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> void fadst4_sse2 ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__sinpi_p03_p03 = _mm_set1_epi16 ( sinpi_3_9 ) ; <S2SV_EndBug>
641,CWE-362,"static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( ""%s:<S2SV_blank>asoc:%p,<S2SV_blank>timeo:%ld,<S2SV_blank>msg_len:%zu\\n"" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <S2SV_StartBug> BUG_ON ( sk != asoc -> base . sk ) ; <S2SV_EndBug> lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }
","<S2SV_ModStart> current_timeo ) ; if <S2SV_ModEnd> ( sk != <S2SV_ModStart> . sk ) goto do_error
",torvalds@linux/2dcab598484185dea7ec22219c76dcdd59e3cb90,CVE-2017-5986,https://github.com/torvalds/linux/commit/2dcab598484185dea7ec22219c76dcdd59e3cb90,2017-02-18T21:59Z,<S2SV_StartBug> BUG_ON ( sk != asoc -> base . sk ) ; <S2SV_EndBug>
2680,CWE-20,"static void llc_sap_rcv ( struct llc_sap * sap , struct sk_buff * skb , struct sock * sk ) { struct llc_sap_state_ev * ev = llc_sap_ev ( skb ) ; ev -> type = LLC_SAP_EV_TYPE_PDU ; ev -> reason = 0 ; <S2SV_StartBug> skb -> sk = sk ; <S2SV_EndBug> llc_sap_state_process ( sap , skb ) ; }
","<S2SV_ModStart> = 0 ; skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> sk = sk ; skb -> destructor = sock_efree
",torvalds@linux/8b74d439e1697110c5e5c600643e823eb1dd0762,CVE-2017-6345,https://github.com/torvalds/linux/commit/8b74d439e1697110c5e5c600643e823eb1dd0762,2017-03-01T20:59Z,<S2SV_StartBug> skb -> sk = sk ; <S2SV_EndBug>
1102,CWE-772,"int sas_smp_get_phy_events ( struct sas_phy * phy ) { int res ; u8 * req ; u8 * resp ; struct sas_rphy * rphy = dev_to_rphy ( phy -> dev . parent ) ; struct domain_device * dev = sas_find_dev_by_rphy ( rphy ) ; req = alloc_smp_req ( RPEL_REQ_SIZE ) ; if ( ! req ) return - ENOMEM ; resp = alloc_smp_resp ( RPEL_RESP_SIZE ) ; if ( ! resp ) { kfree ( req ) ; return - ENOMEM ; } req [ 1 ] = SMP_REPORT_PHY_ERR_LOG ; req [ 9 ] = phy -> number ; res = smp_execute_task ( dev , req , RPEL_REQ_SIZE , resp , RPEL_RESP_SIZE ) ; if ( ! res ) goto out ; phy -> invalid_dword_count = scsi_to_u32 ( & resp [ 12 ] ) ; phy -> running_disparity_error_count = scsi_to_u32 ( & resp [ 16 ] ) ; phy -> loss_of_dword_sync_count = scsi_to_u32 ( & resp [ 20 ] ) ; phy -> phy_reset_problem_count = scsi_to_u32 ( & resp [ 24 ] ) ; out : <S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> return res ; }
","<S2SV_ModStart> : kfree ( req ) ; kfree (
",torvalds@linux/4a491b1ab11ca0556d2fda1ff1301e862a2d44c4,CVE-2018-7757,https://github.com/torvalds/linux/commit/4a491b1ab11ca0556d2fda1ff1301e862a2d44c4,2018-03-08T14:29Z,<S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug>
2211,CWE-119,"static void command_port_read_callback ( struct urb * urb ) { struct usb_serial_port * command_port = urb -> context ; struct whiteheat_command_private * command_info ; int status = urb -> status ; unsigned char * data = urb -> transfer_buffer ; int result ; command_info = usb_get_serial_port_data ( command_port ) ; if ( ! command_info ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>command_info<S2SV_blank>is<S2SV_blank>NULL,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; } <S2SV_StartBug> if ( status ) { <S2SV_EndBug> dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\n"" , __func__ , status ) ; if ( status != - ENOENT ) command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; return ; } usb_serial_debug_data ( & command_port -> dev , __func__ , urb -> actual_length , data ) ; if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE ) { command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) { command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_EVENT ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>event<S2SV_blank>received\\n"" , __func__ ) ; <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> memcpy ( command_info -> result_buffer , & data [ 1 ] , <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug> command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>reply<S2SV_blank>from<S2SV_blank>firmware\\n"" , __func__ ) ; result = usb_submit_urb ( command_port -> read_urb , GFP_ATOMIC ) ; if ( result ) dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>resubmitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\n"" , __func__ , result ) ; }
","<S2SV_ModStart> } if ( ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; } if ( <S2SV_ModStart> else if ( ( <S2SV_ModStart> == WHITEHEAT_GET_DTR_RTS ) && ( <S2SV_ModEnd> urb -> actual_length <S2SV_ModStart> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1
",torvalds@linux/6817ae225cd650fb1c3295d769298c38b1eba818,CVE-2014-3185,https://github.com/torvalds/linux/commit/6817ae225cd650fb1c3295d769298c38b1eba818,2014-09-28T10:55Z,<S2SV_StartBug> if ( status ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug>
3706,CWE-119,"<S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> { struct bitmap * base = data ; bitmap_set ( base , find_object_pos ( object -> oid . hash ) ) ; mark_as_seen ( object ) ; }
","<S2SV_ModStart> * object , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void *
",git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2315,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z,"<S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug>"
259,CWE-119,"static void scsi_write_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; <S2SV_StartBug> uint32_t len ; <S2SV_EndBug> uint32_t n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_WRITE ) ) { return ; } } <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; if ( r -> sector_count == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; } else { <S2SV_StartBug> len = r -> sector_count * 512 ; <S2SV_EndBug> if ( len > SCSI_DMA_BUF_SIZE ) { len = SCSI_DMA_BUF_SIZE ; } r -> iov . iov_len = len ; <S2SV_StartBug> DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n"" , r -> req . tag , len ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , len ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ) ; uint32_t <S2SV_ModEnd> n ; if <S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> } else { scsi_init_iovec ( r ) <S2SV_ModEnd> ; DPRINTF ( <S2SV_ModStart> . tag , r -> qiov . size <S2SV_ModEnd> ) ; scsi_req_data <S2SV_ModStart> -> req , r -> qiov . size <S2SV_ModEnd> ) ; }
",bonzini@qemu/103b40f51e4012b3b0ad20f615562a1806d7f49a,CVE-2011-3346,https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a,2014-04-01T06:35Z,"<S2SV_StartBug> uint32_t len ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> len = r -> sector_count * 512 ; <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n"" , r -> req . tag , len ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , len ) ; <S2SV_EndBug>"
1589,CWE-119,"static int read_compressed_header ( VP9Decoder * pbi , const uint8_t * data , size_t partition_size ) { VP9_COMMON * const cm = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> vp9_reader r ; int k ; <S2SV_StartBug> if ( vp9_reader_init ( & r , data , partition_size ) ) <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0"" ) ; cm -> tx_mode = xd -> lossless ? ONLY_4X4 : read_tx_mode ( & r ) ; if ( cm -> tx_mode == TX_MODE_SELECT ) read_tx_mode_probs ( & fc -> tx_probs , & r ) ; read_coef_probs ( fc , cm -> tx_mode , & r ) ; for ( k = 0 ; k < SKIP_CONTEXTS ; ++ k ) vp9_diff_update_prob ( & r , & fc -> skip_probs [ k ] ) ; if ( ! frame_is_intra_only ( cm ) ) { nmv_context * const nmvc = & fc -> nmvc ; int i , j ; read_inter_mode_probs ( fc , & r ) ; if ( cm -> interp_filter == SWITCHABLE ) read_switchable_interp_probs ( fc , & r ) ; for ( i = 0 ; i < INTRA_INTER_CONTEXTS ; i ++ ) vp9_diff_update_prob ( & r , & fc -> intra_inter_prob [ i ] ) ; cm -> reference_mode = read_frame_reference_mode ( cm , & r ) ; if ( cm -> reference_mode != SINGLE_REFERENCE ) setup_compound_reference_mode ( cm ) ; read_frame_reference_mode_probs ( cm , & r ) ; for ( j = 0 ; j < BLOCK_SIZE_GROUPS ; j ++ ) for ( i = 0 ; i < INTRA_MODES - 1 ; ++ i ) vp9_diff_update_prob ( & r , & fc -> y_mode_prob [ j ] [ i ] ) ; for ( j = 0 ; j < PARTITION_CONTEXTS ; ++ j ) for ( i = 0 ; i < PARTITION_TYPES - 1 ; ++ i ) vp9_diff_update_prob ( & r , & fc -> partition_prob [ j ] [ i ] ) ; read_mv_probs ( nmvc , cm -> allow_high_precision_mv , & r ) ; } <S2SV_StartBug> return vp9_reader_has_error ( & r ) ; <S2SV_EndBug> }
","<S2SV_ModStart> const fc = cm -> fc ; vpx_reader <S2SV_ModEnd> r ; int <S2SV_ModStart> ; if ( vpx_reader_init <S2SV_ModEnd> ( & r <S2SV_ModStart> data , partition_size , pbi -> decrypt_cb , pbi -> decrypt_state <S2SV_ModStart> ; } return vpx_reader_has_error <S2SV_ModEnd> ( & r
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_reader_init ( & r , data , partition_size ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_reader_has_error ( & r ) ; <S2SV_EndBug>"
4644,CWE-190,"<S2SV_StartBug> static int bson_string_is_db_ref ( const unsigned char * string , const int length ) { <S2SV_EndBug> int result = 0 ; if ( length >= 4 ) { if ( string [ 1 ] == 'r' && string [ 2 ] == 'e' && string [ 3 ] == 'f' ) result = 1 ; } else if ( length >= 3 ) { if ( string [ 1 ] == 'i' && string [ 2 ] == 'd' ) result = 1 ; else if ( string [ 1 ] == 'd' && string [ 2 ] == 'b' ) result = 1 ; } return result ; }
","<S2SV_ModStart> string , const size_t <S2SV_ModEnd> length ) {
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,"<S2SV_StartBug> static int bson_string_is_db_ref ( const unsigned char * string , const int length ) { <S2SV_EndBug>"
7907,CWE-20,"error_t mqttSnClientSendUnsubscribe ( MqttSnClientContext * context , const char_t * topicName ) { error_t error ; systime_t time ; uint16_t topicId ; MqttSnFlags flags ; error = NO_ERROR ; flags . all = 0 ; topicId = mqttSnClientFindPredefTopicName ( context , topicName ) ; if ( topicId != MQTT_SN_INVALID_TOPIC_ID ) { flags . topicIdType = MQTT_SN_PREDEFINED_TOPIC_ID ; } else { <S2SV_StartBug> if ( osStrlen ( topicName ) == 2 && strchr ( topicName , '#' ) == NULL && <S2SV_EndBug> <S2SV_StartBug> strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug> { flags . topicIdType = MQTT_SN_SHORT_TOPIC_NAME ; } else { flags . topicIdType = MQTT_SN_NORMAL_TOPIC_NAME ; } error = mqttSnFormatUnsubscribe ( & context -> message , flags , context -> msgId , topicId , topicName ) ; } if ( ! error ) { TRACE_INFO ( ""Sending<S2SV_blank>UNSUBSCRIBE<S2SV_blank>message<S2SV_blank>(%"" PRIuSIZE ""<S2SV_blank>bytes)...\\r\\n"" , context -> message . length ) ; mqttSnDumpMessage ( context -> message . buffer , context -> message . length ) ; error = mqttSnClientSendDatagram ( context , context -> message . buffer , context -> message . length ) ; time = osGetSystemTime ( ) ; context -> retransmitStartTime = time ; context -> keepAliveTimestamp = time ; context -> state = MQTT_SN_CLIENT_STATE_SENDING_REQ ; context -> msgType = MQTT_SN_MSG_TYPE_UNSUBSCRIBE ; } return error ; }
","<S2SV_ModStart> == 2 && osStrchr <S2SV_ModEnd> ( topicName , <S2SV_ModStart> == NULL && osStrchr <S2SV_ModEnd> ( topicName ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> if ( osStrlen ( topicName ) == 2 && strchr ( topicName , '#' ) == NULL && <S2SV_EndBug> <S2SV_StartBug> strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug>"
413,CWE-125,"void mpls_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const u_char * p ; uint32_t label_entry ; uint16_t label_stack_depth = 0 ; enum mpls_packet_type pt = PT_UNKNOWN ; p = bp ; ND_PRINT ( ( ndo , ""MPLS"" ) ) ; do { ND_TCHECK2 ( * p , sizeof ( label_entry ) ) ; if ( length < sizeof ( label_entry ) ) { ND_PRINT ( ( ndo , ""[|MPLS],<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; } label_entry = EXTRACT_32BITS ( p ) ; ND_PRINT ( ( ndo , ""%s(label<S2SV_blank>%u"" , ( label_stack_depth && ndo -> ndo_vflag ) ? ""\\n\\t"" : ""<S2SV_blank>"" , MPLS_LABEL ( label_entry ) ) ) ; label_stack_depth ++ ; if ( ndo -> ndo_vflag && MPLS_LABEL ( label_entry ) < sizeof ( mpls_labelname ) / sizeof ( mpls_labelname [ 0 ] ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , mpls_labelname [ MPLS_LABEL ( label_entry ) ] ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_EXP ( label_entry ) ) ) ; if ( MPLS_STACK ( label_entry ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u)"" , MPLS_TTL ( label_entry ) ) ) ; p += sizeof ( label_entry ) ; length -= sizeof ( label_entry ) ; } while ( ! MPLS_STACK ( label_entry ) ) ; switch ( MPLS_LABEL ( label_entry ) ) { case 0 : case 3 : pt = PT_IPV4 ; break ; case 2 : pt = PT_IPV6 ; break ; default : ND_TCHECK ( * p ) ; if ( length < 1 ) { return ; } switch ( * p ) { case 0x45 : case 0x46 : case 0x47 : case 0x48 : case 0x49 : case 0x4a : case 0x4b : case 0x4c : case 0x4d : case 0x4e : case 0x4f : pt = PT_IPV4 ; break ; case 0x60 : case 0x61 : case 0x62 : case 0x63 : case 0x64 : case 0x65 : case 0x66 : case 0x67 : case 0x68 : case 0x69 : case 0x6a : case 0x6b : case 0x6c : case 0x6d : case 0x6e : case 0x6f : pt = PT_IPV6 ; break ; case 0x81 : case 0x82 : case 0x83 : pt = PT_OSI ; break ; default : break ; } } if ( pt == PT_UNKNOWN ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , length ) ; return ; } ND_PRINT ( ( ndo , ndo -> ndo_vflag ? ""\\n\\t"" : ""<S2SV_blank>"" ) ) ; switch ( pt ) { case PT_IPV4 : ip_print ( ndo , p , length ) ; break ; case PT_IPV6 : ip6_print ( ndo , p , length ) ; break ; case PT_OSI : <S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|MPLS]"" ) ) ; }
","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,"<S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug>"
1913,CWE-119,"<S2SV_StartBug> void fadst16_8col ( __m128i * in ) { <S2SV_EndBug> __m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ; const __m128i k__cospi_p01_p31 = pair_set_epi16 ( cospi_1_64 , cospi_31_64 ) ; const __m128i k__cospi_p31_m01 = pair_set_epi16 ( cospi_31_64 , - cospi_1_64 ) ; const __m128i k__cospi_p05_p27 = pair_set_epi16 ( cospi_5_64 , cospi_27_64 ) ; const __m128i k__cospi_p27_m05 = pair_set_epi16 ( cospi_27_64 , - cospi_5_64 ) ; const __m128i k__cospi_p09_p23 = pair_set_epi16 ( cospi_9_64 , cospi_23_64 ) ; const __m128i k__cospi_p23_m09 = pair_set_epi16 ( cospi_23_64 , - cospi_9_64 ) ; const __m128i k__cospi_p13_p19 = pair_set_epi16 ( cospi_13_64 , cospi_19_64 ) ; const __m128i k__cospi_p19_m13 = pair_set_epi16 ( cospi_19_64 , - cospi_13_64 ) ; const __m128i k__cospi_p17_p15 = pair_set_epi16 ( cospi_17_64 , cospi_15_64 ) ; const __m128i k__cospi_p15_m17 = pair_set_epi16 ( cospi_15_64 , - cospi_17_64 ) ; const __m128i k__cospi_p21_p11 = pair_set_epi16 ( cospi_21_64 , cospi_11_64 ) ; const __m128i k__cospi_p11_m21 = pair_set_epi16 ( cospi_11_64 , - cospi_21_64 ) ; const __m128i k__cospi_p25_p07 = pair_set_epi16 ( cospi_25_64 , cospi_7_64 ) ; const __m128i k__cospi_p07_m25 = pair_set_epi16 ( cospi_7_64 , - cospi_25_64 ) ; const __m128i k__cospi_p29_p03 = pair_set_epi16 ( cospi_29_64 , cospi_3_64 ) ; const __m128i k__cospi_p03_m29 = pair_set_epi16 ( cospi_3_64 , - cospi_29_64 ) ; const __m128i k__cospi_p04_p28 = pair_set_epi16 ( cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p28_m04 = pair_set_epi16 ( cospi_28_64 , - cospi_4_64 ) ; const __m128i k__cospi_p20_p12 = pair_set_epi16 ( cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p12_m20 = pair_set_epi16 ( cospi_12_64 , - cospi_20_64 ) ; const __m128i k__cospi_m28_p04 = pair_set_epi16 ( - cospi_28_64 , cospi_4_64 ) ; const __m128i k__cospi_m12_p20 = pair_set_epi16 ( - cospi_12_64 , cospi_20_64 ) ; const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ; <S2SV_StartBug> const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( - cospi_16_64 ) ; <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; const __m128i kZero = _mm_set1_epi16 ( 0 ) ; u [ 0 ] = _mm_unpacklo_epi16 ( in [ 15 ] , in [ 0 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( in [ 15 ] , in [ 0 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( in [ 13 ] , in [ 2 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( in [ 13 ] , in [ 2 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( in [ 11 ] , in [ 4 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( in [ 11 ] , in [ 4 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( in [ 9 ] , in [ 6 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( in [ 9 ] , in [ 6 ] ) ; u [ 8 ] = _mm_unpacklo_epi16 ( in [ 7 ] , in [ 8 ] ) ; u [ 9 ] = _mm_unpackhi_epi16 ( in [ 7 ] , in [ 8 ] ) ; u [ 10 ] = _mm_unpacklo_epi16 ( in [ 5 ] , in [ 10 ] ) ; u [ 11 ] = _mm_unpackhi_epi16 ( in [ 5 ] , in [ 10 ] ) ; u [ 12 ] = _mm_unpacklo_epi16 ( in [ 3 ] , in [ 12 ] ) ; u [ 13 ] = _mm_unpackhi_epi16 ( in [ 3 ] , in [ 12 ] ) ; u [ 14 ] = _mm_unpacklo_epi16 ( in [ 1 ] , in [ 14 ] ) ; u [ 15 ] = _mm_unpackhi_epi16 ( in [ 1 ] , in [ 14 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p01_p31 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p01_p31 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p31_m01 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p31_m01 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p05_p27 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p05_p27 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p27_m05 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p27_m05 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p09_p23 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p09_p23 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p23_m09 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p23_m09 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p13_p19 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p13_p19 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p19_m13 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p19_m13 ) ; v [ 16 ] = _mm_madd_epi16 ( u [ 8 ] , k__cospi_p17_p15 ) ; v [ 17 ] = _mm_madd_epi16 ( u [ 9 ] , k__cospi_p17_p15 ) ; v [ 18 ] = _mm_madd_epi16 ( u [ 8 ] , k__cospi_p15_m17 ) ; v [ 19 ] = _mm_madd_epi16 ( u [ 9 ] , k__cospi_p15_m17 ) ; v [ 20 ] = _mm_madd_epi16 ( u [ 10 ] , k__cospi_p21_p11 ) ; v [ 21 ] = _mm_madd_epi16 ( u [ 11 ] , k__cospi_p21_p11 ) ; v [ 22 ] = _mm_madd_epi16 ( u [ 10 ] , k__cospi_p11_m21 ) ; v [ 23 ] = _mm_madd_epi16 ( u [ 11 ] , k__cospi_p11_m21 ) ; v [ 24 ] = _mm_madd_epi16 ( u [ 12 ] , k__cospi_p25_p07 ) ; v [ 25 ] = _mm_madd_epi16 ( u [ 13 ] , k__cospi_p25_p07 ) ; v [ 26 ] = _mm_madd_epi16 ( u [ 12 ] , k__cospi_p07_m25 ) ; v [ 27 ] = _mm_madd_epi16 ( u [ 13 ] , k__cospi_p07_m25 ) ; v [ 28 ] = _mm_madd_epi16 ( u [ 14 ] , k__cospi_p29_p03 ) ; v [ 29 ] = _mm_madd_epi16 ( u [ 15 ] , k__cospi_p29_p03 ) ; v [ 30 ] = _mm_madd_epi16 ( u [ 14 ] , k__cospi_p03_m29 ) ; v [ 31 ] = _mm_madd_epi16 ( u [ 15 ] , k__cospi_p03_m29 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 16 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 17 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 18 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 19 ] ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , v [ 20 ] ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , v [ 21 ] ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , v [ 22 ] ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , v [ 23 ] ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , v [ 24 ] ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , v [ 25 ] ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , v [ 26 ] ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , v [ 27 ] ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , v [ 28 ] ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , v [ 29 ] ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , v [ 30 ] ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , v [ 31 ] ) ; u [ 16 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 16 ] ) ; u [ 17 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 17 ] ) ; u [ 18 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 18 ] ) ; u [ 19 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 19 ] ) ; u [ 20 ] = _mm_sub_epi32 ( v [ 4 ] , v [ 20 ] ) ; u [ 21 ] = _mm_sub_epi32 ( v [ 5 ] , v [ 21 ] ) ; u [ 22 ] = _mm_sub_epi32 ( v [ 6 ] , v [ 22 ] ) ; u [ 23 ] = _mm_sub_epi32 ( v [ 7 ] , v [ 23 ] ) ; u [ 24 ] = _mm_sub_epi32 ( v [ 8 ] , v [ 24 ] ) ; u [ 25 ] = _mm_sub_epi32 ( v [ 9 ] , v [ 25 ] ) ; u [ 26 ] = _mm_sub_epi32 ( v [ 10 ] , v [ 26 ] ) ; u [ 27 ] = _mm_sub_epi32 ( v [ 11 ] , v [ 27 ] ) ; u [ 28 ] = _mm_sub_epi32 ( v [ 12 ] , v [ 28 ] ) ; u [ 29 ] = _mm_sub_epi32 ( v [ 13 ] , v [ 29 ] ) ; u [ 30 ] = _mm_sub_epi32 ( v [ 14 ] , v [ 30 ] ) ; u [ 31 ] = _mm_sub_epi32 ( v [ 15 ] , v [ 31 ] ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; v [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; v [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; v [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; v [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; v [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; v [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; v [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 16 ] = _mm_add_epi32 ( u [ 16 ] , k__DCT_CONST_ROUNDING ) ; v [ 17 ] = _mm_add_epi32 ( u [ 17 ] , k__DCT_CONST_ROUNDING ) ; v [ 18 ] = _mm_add_epi32 ( u [ 18 ] , k__DCT_CONST_ROUNDING ) ; v [ 19 ] = _mm_add_epi32 ( u [ 19 ] , k__DCT_CONST_ROUNDING ) ; v [ 20 ] = _mm_add_epi32 ( u [ 20 ] , k__DCT_CONST_ROUNDING ) ; v [ 21 ] = _mm_add_epi32 ( u [ 21 ] , k__DCT_CONST_ROUNDING ) ; v [ 22 ] = _mm_add_epi32 ( u [ 22 ] , k__DCT_CONST_ROUNDING ) ; v [ 23 ] = _mm_add_epi32 ( u [ 23 ] , k__DCT_CONST_ROUNDING ) ; v [ 24 ] = _mm_add_epi32 ( u [ 24 ] , k__DCT_CONST_ROUNDING ) ; v [ 25 ] = _mm_add_epi32 ( u [ 25 ] , k__DCT_CONST_ROUNDING ) ; v [ 26 ] = _mm_add_epi32 ( u [ 26 ] , k__DCT_CONST_ROUNDING ) ; v [ 27 ] = _mm_add_epi32 ( u [ 27 ] , k__DCT_CONST_ROUNDING ) ; v [ 28 ] = _mm_add_epi32 ( u [ 28 ] , k__DCT_CONST_ROUNDING ) ; v [ 29 ] = _mm_add_epi32 ( u [ 29 ] , k__DCT_CONST_ROUNDING ) ; v [ 30 ] = _mm_add_epi32 ( u [ 30 ] , k__DCT_CONST_ROUNDING ) ; v [ 31 ] = _mm_add_epi32 ( u [ 31 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; u [ 8 ] = _mm_srai_epi32 ( v [ 8 ] , DCT_CONST_BITS ) ; u [ 9 ] = _mm_srai_epi32 ( v [ 9 ] , DCT_CONST_BITS ) ; u [ 10 ] = _mm_srai_epi32 ( v [ 10 ] , DCT_CONST_BITS ) ; u [ 11 ] = _mm_srai_epi32 ( v [ 11 ] , DCT_CONST_BITS ) ; u [ 12 ] = _mm_srai_epi32 ( v [ 12 ] , DCT_CONST_BITS ) ; u [ 13 ] = _mm_srai_epi32 ( v [ 13 ] , DCT_CONST_BITS ) ; u [ 14 ] = _mm_srai_epi32 ( v [ 14 ] , DCT_CONST_BITS ) ; u [ 15 ] = _mm_srai_epi32 ( v [ 15 ] , DCT_CONST_BITS ) ; u [ 16 ] = _mm_srai_epi32 ( v [ 16 ] , DCT_CONST_BITS ) ; u [ 17 ] = _mm_srai_epi32 ( v [ 17 ] , DCT_CONST_BITS ) ; u [ 18 ] = _mm_srai_epi32 ( v [ 18 ] , DCT_CONST_BITS ) ; u [ 19 ] = _mm_srai_epi32 ( v [ 19 ] , DCT_CONST_BITS ) ; u [ 20 ] = _mm_srai_epi32 ( v [ 20 ] , DCT_CONST_BITS ) ; u [ 21 ] = _mm_srai_epi32 ( v [ 21 ] , DCT_CONST_BITS ) ; u [ 22 ] = _mm_srai_epi32 ( v [ 22 ] , DCT_CONST_BITS ) ; u [ 23 ] = _mm_srai_epi32 ( v [ 23 ] , DCT_CONST_BITS ) ; u [ 24 ] = _mm_srai_epi32 ( v [ 24 ] , DCT_CONST_BITS ) ; u [ 25 ] = _mm_srai_epi32 ( v [ 25 ] , DCT_CONST_BITS ) ; u [ 26 ] = _mm_srai_epi32 ( v [ 26 ] , DCT_CONST_BITS ) ; u [ 27 ] = _mm_srai_epi32 ( v [ 27 ] , DCT_CONST_BITS ) ; u [ 28 ] = _mm_srai_epi32 ( v [ 28 ] , DCT_CONST_BITS ) ; u [ 29 ] = _mm_srai_epi32 ( v [ 29 ] , DCT_CONST_BITS ) ; u [ 30 ] = _mm_srai_epi32 ( v [ 30 ] , DCT_CONST_BITS ) ; u [ 31 ] = _mm_srai_epi32 ( v [ 31 ] , DCT_CONST_BITS ) ; s [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; s [ 1 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; s [ 2 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; s [ 3 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; s [ 4 ] = _mm_packs_epi32 ( u [ 8 ] , u [ 9 ] ) ; s [ 5 ] = _mm_packs_epi32 ( u [ 10 ] , u [ 11 ] ) ; s [ 6 ] = _mm_packs_epi32 ( u [ 12 ] , u [ 13 ] ) ; s [ 7 ] = _mm_packs_epi32 ( u [ 14 ] , u [ 15 ] ) ; s [ 8 ] = _mm_packs_epi32 ( u [ 16 ] , u [ 17 ] ) ; s [ 9 ] = _mm_packs_epi32 ( u [ 18 ] , u [ 19 ] ) ; s [ 10 ] = _mm_packs_epi32 ( u [ 20 ] , u [ 21 ] ) ; s [ 11 ] = _mm_packs_epi32 ( u [ 22 ] , u [ 23 ] ) ; s [ 12 ] = _mm_packs_epi32 ( u [ 24 ] , u [ 25 ] ) ; s [ 13 ] = _mm_packs_epi32 ( u [ 26 ] , u [ 27 ] ) ; s [ 14 ] = _mm_packs_epi32 ( u [ 28 ] , u [ 29 ] ) ; s [ 15 ] = _mm_packs_epi32 ( u [ 30 ] , u [ 31 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 8 ] , s [ 9 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 8 ] , s [ 9 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 12 ] , s [ 13 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 12 ] , s [ 13 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 14 ] , s [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 14 ] , s [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p04_p28 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p04_p28 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_m04 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_m04 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p20_p12 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p20_p12 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_m20 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_m20 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m28_p04 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m28_p04 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p04_p28 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p04_p28 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m12_p20 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m12_p20 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p20_p12 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p20_p12 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 8 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 9 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 10 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 11 ] ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , v [ 12 ] ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , v [ 13 ] ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , v [ 14 ] ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , v [ 15 ] ) ; u [ 8 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 8 ] ) ; u [ 9 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 9 ] ) ; u [ 10 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 10 ] ) ; u [ 11 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 11 ] ) ; u [ 12 ] = _mm_sub_epi32 ( v [ 4 ] , v [ 12 ] ) ; u [ 13 ] = _mm_sub_epi32 ( v [ 5 ] , v [ 13 ] ) ; u [ 14 ] = _mm_sub_epi32 ( v [ 6 ] , v [ 14 ] ) ; u [ 15 ] = _mm_sub_epi32 ( v [ 7 ] , v [ 15 ] ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; v [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; v [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; v [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; v [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; v [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; v [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; v [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; u [ 8 ] = _mm_srai_epi32 ( v [ 8 ] , DCT_CONST_BITS ) ; u [ 9 ] = _mm_srai_epi32 ( v [ 9 ] , DCT_CONST_BITS ) ; u [ 10 ] = _mm_srai_epi32 ( v [ 10 ] , DCT_CONST_BITS ) ; u [ 11 ] = _mm_srai_epi32 ( v [ 11 ] , DCT_CONST_BITS ) ; u [ 12 ] = _mm_srai_epi32 ( v [ 12 ] , DCT_CONST_BITS ) ; u [ 13 ] = _mm_srai_epi32 ( v [ 13 ] , DCT_CONST_BITS ) ; u [ 14 ] = _mm_srai_epi32 ( v [ 14 ] , DCT_CONST_BITS ) ; u [ 15 ] = _mm_srai_epi32 ( v [ 15 ] , DCT_CONST_BITS ) ; x [ 0 ] = _mm_add_epi16 ( s [ 0 ] , s [ 4 ] ) ; x [ 1 ] = _mm_add_epi16 ( s [ 1 ] , s [ 5 ] ) ; x [ 2 ] = _mm_add_epi16 ( s [ 2 ] , s [ 6 ] ) ; x [ 3 ] = _mm_add_epi16 ( s [ 3 ] , s [ 7 ] ) ; x [ 4 ] = _mm_sub_epi16 ( s [ 0 ] , s [ 4 ] ) ; x [ 5 ] = _mm_sub_epi16 ( s [ 1 ] , s [ 5 ] ) ; x [ 6 ] = _mm_sub_epi16 ( s [ 2 ] , s [ 6 ] ) ; x [ 7 ] = _mm_sub_epi16 ( s [ 3 ] , s [ 7 ] ) ; x [ 8 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; x [ 9 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; x [ 10 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; x [ 11 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; x [ 12 ] = _mm_packs_epi32 ( u [ 8 ] , u [ 9 ] ) ; x [ 13 ] = _mm_packs_epi32 ( u [ 10 ] , u [ 11 ] ) ; x [ 14 ] = _mm_packs_epi32 ( u [ 12 ] , u [ 13 ] ) ; x [ 15 ] = _mm_packs_epi32 ( u [ 14 ] , u [ 15 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( x [ 4 ] , x [ 5 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( x [ 4 ] , x [ 5 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( x [ 6 ] , x [ 7 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( x [ 6 ] , x [ 7 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( x [ 12 ] , x [ 13 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( x [ 12 ] , x [ 13 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( x [ 14 ] , x [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( x [ 14 ] , x [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p08_p24 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p08_p24 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_m08 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_m08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_p08 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_p08 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_p24 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_p24 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p08_p24 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p08_p24 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p24_m08 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p24_m08 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m24_p08 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m24_p08 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p08_p24 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p08_p24 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 4 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 5 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 6 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 7 ] ) ; u [ 4 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 4 ] ) ; u [ 5 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 5 ] ) ; u [ 6 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 6 ] ) ; u [ 7 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 7 ] ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , v [ 12 ] ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , v [ 13 ] ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , v [ 14 ] ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , v [ 15 ] ) ; u [ 12 ] = _mm_sub_epi32 ( v [ 8 ] , v [ 12 ] ) ; u [ 13 ] = _mm_sub_epi32 ( v [ 9 ] , v [ 13 ] ) ; u [ 14 ] = _mm_sub_epi32 ( v [ 10 ] , v [ 14 ] ) ; u [ 15 ] = _mm_sub_epi32 ( v [ 11 ] , v [ 15 ] ) ; u [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; s [ 0 ] = _mm_add_epi16 ( x [ 0 ] , x [ 2 ] ) ; s [ 1 ] = _mm_add_epi16 ( x [ 1 ] , x [ 3 ] ) ; s [ 2 ] = _mm_sub_epi16 ( x [ 0 ] , x [ 2 ] ) ; s [ 3 ] = _mm_sub_epi16 ( x [ 1 ] , x [ 3 ] ) ; s [ 4 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; s [ 5 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; s [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; s [ 7 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; s [ 8 ] = _mm_add_epi16 ( x [ 8 ] , x [ 10 ] ) ; s [ 9 ] = _mm_add_epi16 ( x [ 9 ] , x [ 11 ] ) ; s [ 10 ] = _mm_sub_epi16 ( x [ 8 ] , x [ 10 ] ) ; s [ 11 ] = _mm_sub_epi16 ( x [ 9 ] , x [ 11 ] ) ; s [ 12 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; s [ 13 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; s [ 14 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; s [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 3 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 6 ] , s [ 7 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 6 ] , s [ 7 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 14 ] , s [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 14 ] , s [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_m16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_m16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_m16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_m16 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p16_p16 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p16_p16 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m16_p16 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m16_p16 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m16_m16 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m16_m16 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p16_m16 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p16_m16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; in [ 0 ] = s [ 0 ] ; in [ 1 ] = _mm_sub_epi16 ( kZero , s [ 8 ] ) ; in [ 2 ] = s [ 12 ] ; in [ 3 ] = _mm_sub_epi16 ( kZero , s [ 4 ] ) ; in [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 5 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; in [ 6 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; in [ 7 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 8 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 9 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; in [ 10 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; in [ 11 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; in [ 12 ] = s [ 5 ] ; in [ 13 ] = _mm_sub_epi16 ( kZero , s [ 13 ] ) ; in [ 14 ] = s [ 9 ] ; in [ 15 ] = _mm_sub_epi16 ( kZero , s [ 1 ] ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t ) <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> void fadst16_8col ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( - cospi_16_64 ) ; <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug>
844,CWE-119,"static int PredictorEncodeRow ( TIFF * tif , uint8 * bp , tmsize_t cc , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encoderow != NULL ) ; <S2SV_StartBug> ( * sp -> encodepfunc ) ( tif , bp , cc ) ; <S2SV_EndBug> return ( * sp -> encoderow ) ( tif , bp , cc , s ) ; }
","<S2SV_ModStart> NULL ) ; if ( ! <S2SV_ModStart> , cc ) ) return 0
",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z,"<S2SV_StartBug> ( * sp -> encodepfunc ) ( tif , bp , cc ) ; <S2SV_EndBug>"
6063,CWE-000,"static void ext4_invalidatepage ( struct page * page , unsigned long offset ) { <S2SV_StartBug> journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ; <S2SV_EndBug> if ( offset == 0 ) ClearPageChecked ( page ) ; if ( journal ) jbd2_journal_invalidatepage ( journal , page , offset ) ; else block_invalidatepage ( page , offset ) ; }
","<S2SV_ModStart> mapping -> host ) ; if ( ext4_should_dioread_nolock ( page -> mapping -> host ) ) ext4_invalidatepage_free_endio ( page , offset
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,<S2SV_StartBug> journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ; <S2SV_EndBug>
2701,CWE-000,"static int aiptek_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct usb_endpoint_descriptor * endpoint ; struct aiptek * aiptek ; struct input_dev * inputdev ; int i ; int speeds [ ] = { 0 , AIPTEK_PROGRAMMABLE_DELAY_50 , AIPTEK_PROGRAMMABLE_DELAY_400 , AIPTEK_PROGRAMMABLE_DELAY_25 , AIPTEK_PROGRAMMABLE_DELAY_100 , AIPTEK_PROGRAMMABLE_DELAY_200 , AIPTEK_PROGRAMMABLE_DELAY_300 } ; int err = - ENOMEM ; speeds [ 0 ] = programmableDelay ; aiptek = kzalloc ( sizeof ( struct aiptek ) , GFP_KERNEL ) ; inputdev = input_allocate_device ( ) ; if ( ! aiptek || ! inputdev ) { dev_warn ( & intf -> dev , ""cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>or<S2SV_blank>input<S2SV_blank>device\\n"" ) ; goto fail1 ; } aiptek -> data = usb_alloc_coherent ( usbdev , AIPTEK_PACKET_LENGTH , GFP_ATOMIC , & aiptek -> data_dma ) ; if ( ! aiptek -> data ) { dev_warn ( & intf -> dev , ""cannot<S2SV_blank>allocate<S2SV_blank>usb<S2SV_blank>buffer\\n"" ) ; goto fail1 ; } aiptek -> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! aiptek -> urb ) { dev_warn ( & intf -> dev , ""cannot<S2SV_blank>allocate<S2SV_blank>urb\\n"" ) ; goto fail2 ; } aiptek -> inputdev = inputdev ; aiptek -> usbdev = usbdev ; aiptek -> intf = intf ; aiptek -> ifnum = intf -> altsetting [ 0 ] . desc . bInterfaceNumber ; aiptek -> inDelay = 0 ; aiptek -> endDelay = 0 ; aiptek -> previousJitterable = 0 ; aiptek -> lastMacro = - 1 ; aiptek -> curSetting . pointerMode = AIPTEK_POINTER_EITHER_MODE ; aiptek -> curSetting . coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE ; aiptek -> curSetting . toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE ; aiptek -> curSetting . xTilt = AIPTEK_TILT_DISABLE ; aiptek -> curSetting . yTilt = AIPTEK_TILT_DISABLE ; aiptek -> curSetting . mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON ; aiptek -> curSetting . mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON ; aiptek -> curSetting . mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON ; aiptek -> curSetting . stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON ; aiptek -> curSetting . stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON ; aiptek -> curSetting . jitterDelay = jitterDelay ; aiptek -> curSetting . programmableDelay = programmableDelay ; aiptek -> newSetting = aiptek -> curSetting ; usb_make_path ( usbdev , aiptek -> features . usbPath , sizeof ( aiptek -> features . usbPath ) ) ; strlcat ( aiptek -> features . usbPath , ""/input0"" , sizeof ( aiptek -> features . usbPath ) ) ; inputdev -> name = ""Aiptek"" ; inputdev -> phys = aiptek -> features . usbPath ; usb_to_input_id ( usbdev , & inputdev -> id ) ; inputdev -> dev . parent = & intf -> dev ; input_set_drvdata ( inputdev , aiptek ) ; inputdev -> open = aiptek_open ; inputdev -> close = aiptek_close ; for ( i = 0 ; i < ARRAY_SIZE ( eventTypes ) ; ++ i ) __set_bit ( eventTypes [ i ] , inputdev -> evbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( absEvents ) ; ++ i ) __set_bit ( absEvents [ i ] , inputdev -> absbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( relEvents ) ; ++ i ) __set_bit ( relEvents [ i ] , inputdev -> relbit ) ; __set_bit ( MSC_SERIAL , inputdev -> mscbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( buttonEvents ) ; ++ i ) __set_bit ( buttonEvents [ i ] , inputdev -> keybit ) ; for ( i = 0 ; i < ARRAY_SIZE ( macroKeyEvents ) ; ++ i ) __set_bit ( macroKeyEvents [ i ] , inputdev -> keybit ) ; input_set_abs_params ( inputdev , ABS_X , 0 , 2999 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_Y , 0 , 2249 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_PRESSURE , 0 , 511 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_TILT_X , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_TILT_Y , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_WHEEL , AIPTEK_WHEEL_MIN , AIPTEK_WHEEL_MAX - 1 , 0 , 0 ) ; <S2SV_StartBug> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ; aiptek -> urb -> transfer_dma = aiptek -> data_dma ; aiptek -> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; for ( i = 0 ; i < ARRAY_SIZE ( speeds ) ; ++ i ) { aiptek -> curSetting . programmableDelay = speeds [ i ] ; ( void ) aiptek_program_tablet ( aiptek ) ; if ( input_abs_get_max ( aiptek -> inputdev , ABS_X ) > 0 ) { dev_info ( & intf -> dev , ""Aiptek<S2SV_blank>using<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>programming<S2SV_blank>speed\\n"" , aiptek -> curSetting . programmableDelay ) ; break ; } } if ( i == ARRAY_SIZE ( speeds ) ) { dev_info ( & intf -> dev , ""Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n"" ) ; <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> } usb_set_intfdata ( intf , aiptek ) ; err = sysfs_create_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; if ( err ) { dev_warn ( & intf -> dev , ""cannot<S2SV_blank>create<S2SV_blank>sysfs<S2SV_blank>group<S2SV_blank>err:<S2SV_blank>%d\\n"" , err ) ; goto fail3 ; } err = input_register_device ( aiptek -> inputdev ) ; if ( err ) { dev_warn ( & intf -> dev , ""input_register_device<S2SV_blank>returned<S2SV_blank>err:<S2SV_blank>%d\\n"" , err ) ; goto fail4 ; } return 0 ; fail4 : sysfs_remove_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; fail3 : usb_free_urb ( aiptek -> urb ) ; fail2 : usb_free_coherent ( usbdev , AIPTEK_PACKET_LENGTH , aiptek -> data , aiptek -> data_dma ) ; fail1 : usb_set_intfdata ( intf , NULL ) ; input_free_device ( inputdev ) ; kfree ( aiptek ) ; return err ; }
","<S2SV_ModStart> 0 ) ; if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n"" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> ""Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n"" ) ; err = - EINVAL ;
",torvalds@linux/8e20cf2bce122ce9262d6034ee5d5b76fbb92f96,CVE-2015-7515,https://github.com/torvalds/linux/commit/8e20cf2bce122ce9262d6034ee5d5b76fbb92f96,2016-04-27T17:59Z,<S2SV_StartBug> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> <S2SV_StartBug> goto fail3 ; <S2SV_EndBug>
7788,CWE-125,"mod_ty PyAST_FromNodeObject ( const node * n , PyCompilerFlags * flags , PyObject * filename , PyArena * arena ) { int i , j , k , num ; asdl_seq * stmts = NULL ; <S2SV_StartBug> stmt_ty s ; <S2SV_EndBug> node * ch ; struct compiling c ; <S2SV_StartBug> mod_ty res = NULL ; <S2SV_EndBug> c . c_arena = arena ; c . c_filename = filename ; c . c_normalize = NULL ; if ( TYPE ( n ) == encoding_decl ) n = CHILD ( n , 0 ) ; k = 0 ; switch ( TYPE ( n ) ) { case file_input : stmts = _Py_asdl_seq_new ( num_stmts ( n ) , arena ) ; if ( ! stmts ) goto out ; for ( i = 0 ; i < NCH ( n ) - 1 ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == NEWLINE ) continue ; REQ ( ch , stmt ) ; num = num_stmts ( ch ) ; if ( num == 1 ) { s = ast_for_stmt ( & c , ch ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , k ++ , s ) ; } else { ch = CHILD ( ch , 0 ) ; REQ ( ch , simple_stmt ) ; for ( j = 0 ; j < num ; j ++ ) { s = ast_for_stmt ( & c , CHILD ( ch , j * 2 ) ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , k ++ , s ) ; } } } <S2SV_StartBug> res = Module ( stmts , arena ) ; <S2SV_EndBug> break ; case eval_input : { expr_ty testlist_ast ; testlist_ast = ast_for_testlist ( & c , CHILD ( n , 0 ) ) ; if ( ! testlist_ast ) goto out ; res = Expression ( testlist_ast , arena ) ; break ; } case single_input : if ( TYPE ( CHILD ( n , 0 ) ) == NEWLINE ) { stmts = _Py_asdl_seq_new ( 1 , arena ) ; if ( ! stmts ) goto out ; asdl_seq_SET ( stmts , 0 , Pass ( n -> n_lineno , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , arena ) ) ; if ( ! asdl_seq_GET ( stmts , 0 ) ) goto out ; res = Interactive ( stmts , arena ) ; } else { n = CHILD ( n , 0 ) ; num = num_stmts ( n ) ; stmts = _Py_asdl_seq_new ( num , arena ) ; if ( ! stmts ) goto out ; if ( num == 1 ) { s = ast_for_stmt ( & c , n ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , 0 , s ) ; } else { REQ ( n , simple_stmt ) ; for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { if ( TYPE ( CHILD ( n , i ) ) == NEWLINE ) break ; s = ast_for_stmt ( & c , CHILD ( n , i ) ) ; if ( ! s ) goto out ; asdl_seq_SET ( stmts , i / 2 , s ) ; } } res = Interactive ( stmts , arena ) ; } break ; <S2SV_StartBug> default : <S2SV_EndBug> PyErr_Format ( PyExc_SystemError , ""invalid<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>PyAST_FromNode"" , TYPE ( n ) ) ; goto out ; } out : if ( c . c_normalize ) { Py_DECREF ( c . c_normalize ) ; } return res ; }
","<S2SV_ModStart> = NULL ; asdl_seq * type_ignores = NULL ; <S2SV_ModStart> res = NULL ; asdl_seq * argtypes = NULL ; expr_ty ret , arg <S2SV_ModStart> } } } ch = CHILD ( n , NCH ( n ) - 1 ) ; REQ ( ch , ENDMARKER ) ; num = NCH ( ch ) ; type_ignores = _Py_asdl_seq_new ( num , arena ) ; if ( ! type_ignores ) goto out ; for ( i = 0 ; i < num ; i ++ ) { type_ignore_ty ti = TypeIgnore ( LINENO ( CHILD ( ch , i ) ) , arena ) ; if ( ! ti ) goto out ; asdl_seq_SET ( type_ignores , i , ti ) ; } <S2SV_ModStart> Module ( stmts , type_ignores <S2SV_ModStart> } break ; case func_type_input : n = CHILD ( n , 0 ) ; REQ ( n , func_type ) ; if ( TYPE ( CHILD ( n , 1 ) ) == typelist ) { ch = CHILD ( n , 1 ) ; num = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { num ++ ; } } argtypes = _Py_asdl_seq_new ( num , arena ) ; if ( ! argtypes ) goto out ; j = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { arg = ast_for_expr ( & c , CHILD ( ch , i ) ) ; if ( ! arg ) goto out ; asdl_seq_SET ( argtypes , j ++ , arg ) ; } } } else { argtypes = _Py_asdl_seq_new ( 0 , arena ) ; if ( ! argtypes ) goto out ; } ret = ast_for_expr ( & c , CHILD ( n , NCH ( n ) - 1 ) ) ; if ( ! ret ) goto out ; res = FunctionType ( argtypes , ret , arena ) ; break ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> stmt_ty s ; <S2SV_EndBug> <S2SV_StartBug> mod_ty res = NULL ; <S2SV_EndBug> <S2SV_StartBug> res = Module ( stmts , arena ) ; <S2SV_EndBug> <S2SV_StartBug> default : <S2SV_EndBug>"
6482,CWE-310,"static void read_conf ( FILE * conffile ) { char * buffer , * line , * val ; buffer = loadfile ( conffile ) ; for ( line = strtok ( buffer , ""\\r\\n"" ) ; line ; line = strtok ( NULL , ""\\r\\n"" ) ) { if ( ! strncmp ( line , ""export<S2SV_blank>"" , 7 ) ) continue ; val = strchr ( line , '=' ) ; if ( ! val ) { printf ( ""invalid<S2SV_blank>configuration<S2SV_blank>line\\n"" ) ; break ; } * val ++ = '\\0' ; if ( ! strcmp ( line , ""JSON_INDENT"" ) ) conf . indent = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_COMPACT"" ) ) conf . compact = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_ENSURE_ASCII"" ) ) conf . ensure_ascii = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_PRESERVE_ORDER"" ) ) conf . preserve_order = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_SORT_KEYS"" ) ) conf . sort_keys = atoi ( val ) ; if ( ! strcmp ( line , ""STRIP"" ) ) conf . strip = atoi ( val ) ; <S2SV_StartBug> } <S2SV_EndBug> free ( buffer ) ; }
","<S2SV_ModStart> val ) ; if ( ! strcmp ( line , ""HASHSEED"" ) ) { conf . have_hashseed = 1 ; conf . hashseed = atoi ( val ) ; } else { conf . have_hashseed = 0 ; }
",akheron@jansson/8f80c2d83808150724d31793e6ade92749b1faa4,CVE-2013-6401,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,2014-03-21T01:04Z,<S2SV_StartBug> } <S2SV_EndBug>
2298,CWE-119,"static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
",torvalds@linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,CVE-2016-4998,https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,2016-07-03T21:59Z,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug>
7642,CWE-190,"int ras_validate ( jas_stream_t * in ) { <S2SV_StartBug> uchar buf [ RAS_MAGICLEN ] ; <S2SV_EndBug> int i ; int n ; uint_fast32_t magic ; assert ( JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN ) ; if ( ( n = jas_stream_read ( in , buf , RAS_MAGICLEN ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < RAS_MAGICLEN ) { return - 1 ; } magic = ( JAS_CAST ( uint_fast32_t , buf [ 0 ] ) << 24 ) | ( JAS_CAST ( uint_fast32_t , buf [ 1 ] ) << 16 ) | ( JAS_CAST ( uint_fast32_t , buf [ 2 ] ) << 8 ) | buf [ 3 ] ; if ( magic != RAS_MAGIC ) { return - 1 ; } return 0 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ RAS_MAGICLEN
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> uchar buf [ RAS_MAGICLEN ] ; <S2SV_EndBug>
3388,CWE-78,"static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) { static char cmd [ BUF_SIZE ] ; <S2SV_StartBug> char * method = manager -> method ; <S2SV_EndBug> int i ; <S2SV_StartBug> build_config ( working_dir , server ) ; <S2SV_EndBug> if ( server -> method ) method = server -> method ; memset ( cmd , 0 , BUF_SIZE ) ; snprintf ( cmd , BUF_SIZE , <S2SV_StartBug> ""%s<S2SV_blank>-m<S2SV_blank>%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%s.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%s.conf"" , <S2SV_EndBug> <S2SV_StartBug> executable , method , manager -> manager_address , <S2SV_EndBug> <S2SV_StartBug> working_dir , server -> port , working_dir , server -> port ) ; <S2SV_EndBug> if ( manager -> acl != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--acl<S2SV_blank>%s"" , manager -> acl ) ; } if ( manager -> timeout != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-t<S2SV_blank>%s"" , manager -> timeout ) ; } # ifdef HAVE_SETRLIMIT if ( manager -> nofile ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-n<S2SV_blank>%d"" , manager -> nofile ) ; } # endif if ( manager -> user != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-a<S2SV_blank>%s"" , manager -> user ) ; } if ( manager -> verbose ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-v"" ) ; } if ( server -> mode == NULL && manager -> mode == UDP_ONLY ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-U"" ) ; } if ( server -> mode == NULL && manager -> mode == TCP_AND_UDP ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-u"" ) ; } if ( server -> fast_open [ 0 ] == 0 && manager -> fast_open ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--fast-open"" ) ; } if ( manager -> ipv6first ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-6"" ) ; } if ( manager -> mtu ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--mtu<S2SV_blank>%d"" , manager -> mtu ) ; } if ( server -> plugin == NULL && manager -> plugin ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--plugin<S2SV_blank>\\""%s\\"""" , manager -> plugin ) ; } if ( server -> plugin_opts == NULL && manager -> plugin_opts ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--plugin-opts<S2SV_blank>\\""%s\\"""" , manager -> plugin_opts ) ; } for ( i = 0 ; i < manager -> nameserver_num ; i ++ ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-d<S2SV_blank>%s"" , manager -> nameservers [ i ] ) ; } for ( i = 0 ; i < manager -> host_num ; i ++ ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>-s<S2SV_blank>%s"" , manager -> hosts [ i ] ) ; } { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""<S2SV_blank>--reuse-port"" ) ; } if ( verbose ) { LOGI ( ""cmd:<S2SV_blank>%s"" , cmd ) ; } return cmd ; }
","<S2SV_ModStart> BUF_SIZE ] ; int i ; int port ; port = atoi ( server -> port ) <S2SV_ModEnd> ; build_config ( <S2SV_ModStart> ( working_dir , manager , server ) <S2SV_ModEnd> ; memset ( <S2SV_ModStart> , BUF_SIZE , ""%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf"" <S2SV_ModEnd> , executable , <S2SV_ModStart> , executable , <S2SV_ModEnd> manager -> manager_address <S2SV_ModStart> , working_dir , <S2SV_ModEnd> port , working_dir <S2SV_ModStart> , working_dir , <S2SV_ModEnd> port ) ;
",shadowsocks@shadowsocks-libev/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3,CVE-2017-15924,https://github.com/shadowsocks/shadowsocks-libev/commit/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3,2017-10-27T16:29Z,"<S2SV_StartBug> char * method = manager -> method ; <S2SV_EndBug> <S2SV_StartBug> build_config ( working_dir , server ) ; <S2SV_EndBug> <S2SV_StartBug> ""%s<S2SV_blank>-m<S2SV_blank>%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%s.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%s.conf"" , <S2SV_EndBug> <S2SV_StartBug> executable , method , manager -> manager_address , <S2SV_EndBug> <S2SV_StartBug> working_dir , server -> port , working_dir , server -> port ) ; <S2SV_EndBug>"
2999,CWE-119,"WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } <S2SV_StartBug> } <S2SV_EndBug> else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; <S2SV_StartBug> ps_dec -> u2_cur_slice_num ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic != 0 ) <S2SV_EndBug> ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> } } } ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_ModStart> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; <S2SV_ModStart> u2_cur_slice_num ++ ; } <S2SV_ModEnd> ps_dec -> i2_prev_slice_mbx
",external@libavc/a78887bcffbc2995cf9ed72e0697acf560875e9e,CVE-2016-3820,https://android.googlesource.com/platform/external/libavc/+/a78887bcffbc2995cf9ed72e0697acf560875e9e,2016-08-05T20:59Z,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u2_cur_slice_num ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic != 0 ) <S2SV_EndBug>
6345,CWE-772,"generic_ret * modify_policy_2_svc ( mpol_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> rec . policy ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_MODIFY , NULL , NULL ) ) { log_unauth ( ""kadm5_modify_policy"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_MODIFY ; } else { ret . code = kadm5_modify_policy ( ( void * ) handle , & arg -> rec , arg -> mask ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_modify_policy"" , ( ( prime_arg == NULL ) ? ""(null)"" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug>"
1929,CWE-119,"static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ; <S2SV_EndBug> if ( frame != NULL ) { <S2SV_StartBug> YV12_BUFFER_CONFIG * fb ; <S2SV_EndBug> <S2SV_StartBug> vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ; <S2SV_EndBug> yuvconfig2image ( & frame -> img , fb , NULL ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> { vp9_ref_frame_t * const <S2SV_ModStart> YV12_BUFFER_CONFIG * fb = get_ref_frame ( & <S2SV_ModEnd> ctx -> cpi <S2SV_ModStart> ctx -> cpi -> common <S2SV_ModStart> frame -> idx ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ; yuvconfig2image (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ; <S2SV_EndBug> <S2SV_StartBug> YV12_BUFFER_CONFIG * fb ; <S2SV_EndBug> <S2SV_StartBug> vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ; <S2SV_EndBug>"
5878,CWE-400,"static void exif_data_load_data_content ( ExifData * data , ExifIfd ifd , const unsigned char * d , <S2SV_StartBug> unsigned int ds , unsigned int offset , unsigned int recursion_depth ) <S2SV_EndBug> { ExifLong o , thumbnail_offset = 0 , thumbnail_length = 0 ; ExifShort n ; ExifEntry * entry ; unsigned int i ; ExifTag tag ; if ( ! data || ! data -> priv ) return ; if ( ( ( ( int ) ifd ) < 0 ) || ( ( ( int ) ifd ) >= EXIF_IFD_COUNT ) ) return ; <S2SV_StartBug> if ( recursion_depth > 12 ) { <S2SV_EndBug> exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , <S2SV_StartBug> ""Deep<S2SV_blank>recursion<S2SV_blank>detected!"" ) ; <S2SV_EndBug> return ; } if ( ( offset + 2 < offset ) || ( offset + 2 < 2 ) || ( offset + 2 > ds ) ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , offset + 2 , ds ) ; return ; } n = exif_get_short ( d + offset , data -> priv -> order ) ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Loading<S2SV_blank>%hu<S2SV_blank>entries..."" , n ) ; offset += 2 ; if ( offset + 12 * n > ds ) { n = ( ds - offset ) / 12 ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Short<S2SV_blank>data;<S2SV_blank>only<S2SV_blank>loading<S2SV_blank>%hu<S2SV_blank>entries..."" , n ) ; } for ( i = 0 ; i < n ; i ++ ) { tag = exif_get_short ( d + offset + 12 * i , data -> priv -> order ) ; switch ( tag ) { case EXIF_TAG_EXIF_IFD_POINTER : case EXIF_TAG_GPS_INFO_IFD_POINTER : case EXIF_TAG_INTEROPERABILITY_IFD_POINTER : case EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH : case EXIF_TAG_JPEG_INTERCHANGE_FORMAT : o = exif_get_long ( d + offset + 12 * i + 8 , data -> priv -> order ) ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Sub-IFD<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')<S2SV_blank>at<S2SV_blank>%u."" , tag , exif_tag_get_name ( tag ) , o ) ; switch ( tag ) { case EXIF_TAG_EXIF_IFD_POINTER : CHECK_REC ( EXIF_IFD_EXIF ) ; <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_EXIF , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug> break ; case EXIF_TAG_GPS_INFO_IFD_POINTER : CHECK_REC ( EXIF_IFD_GPS ) ; <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_GPS , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug> break ; case EXIF_TAG_INTEROPERABILITY_IFD_POINTER : CHECK_REC ( EXIF_IFD_INTEROPERABILITY ) ; <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_INTEROPERABILITY , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug> break ; case EXIF_TAG_JPEG_INTERCHANGE_FORMAT : thumbnail_offset = o ; if ( thumbnail_offset && thumbnail_length ) exif_data_load_data_thumbnail ( data , d , ds , thumbnail_offset , thumbnail_length ) ; break ; case EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH : thumbnail_length = o ; if ( thumbnail_offset && thumbnail_length ) exif_data_load_data_thumbnail ( data , d , ds , thumbnail_offset , thumbnail_length ) ; break ; default : return ; } break ; default : if ( ! exif_tag_get_name_in_ifd ( tag , ifd ) ) { if ( ! memcmp ( d + offset + 12 * i , ""\\0\\0\\0\\0"" , 4 ) ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Skipping<S2SV_blank>empty<S2SV_blank>entry<S2SV_blank>at<S2SV_blank>position<S2SV_blank>%u<S2SV_blank>in<S2SV_blank>\'%s\'."" , i , exif_ifd_get_name ( ifd ) ) ; break ; } exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Unknown<S2SV_blank>tag<S2SV_blank>0x%04x<S2SV_blank>(entry<S2SV_blank>%u<S2SV_blank>in<S2SV_blank>\'%s\').<S2SV_blank>Please<S2SV_blank>report<S2SV_blank>this<S2SV_blank>tag<S2SV_blank>"" ""to<S2SV_blank><libexif-devel@lists.sourceforge.net>."" , tag , i , exif_ifd_get_name ( ifd ) ) ; if ( data -> priv -> options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS ) break ; } entry = exif_entry_new_mem ( data -> priv -> mem ) ; if ( ! entry ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_NO_MEMORY , ""ExifData"" , ""Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>memory"" ) ; return ; } if ( exif_data_load_data_entry ( data , entry , d , ds , offset + 12 * i ) ) exif_content_add_entry ( data -> ifd [ ifd ] , entry ) ; exif_entry_unref ( entry ) ; break ; } } }
","<S2SV_ModStart> , unsigned int recursion_cost <S2SV_ModEnd> ) { ExifLong <S2SV_ModStart> ; if ( recursion_cost > 170 <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , ""ExifData"" , ""Deep/expensive<S2SV_blank>recursion<S2SV_blank>detected!"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> , o , recursion_cost + level_cost ( n ) <S2SV_ModEnd> ) ; break <S2SV_ModStart> , o , recursion_cost + level_cost ( n ) <S2SV_ModEnd> ) ; break <S2SV_ModStart> , o , recursion_cost + level_cost ( n ) <S2SV_ModEnd> ) ; break
",libexif@libexif/6aa11df549114ebda520dde4cdaea2f9357b2c89,CVE-2018-20030,https://github.com/libexif/libexif/commit/6aa11df549114ebda520dde4cdaea2f9357b2c89,2019-02-20T17:29Z,"<S2SV_StartBug> unsigned int ds , unsigned int offset , unsigned int recursion_depth ) <S2SV_EndBug> <S2SV_StartBug> if ( recursion_depth > 12 ) { <S2SV_EndBug> <S2SV_StartBug> ""Deep<S2SV_blank>recursion<S2SV_blank>detected!"" ) ; <S2SV_EndBug> <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_EXIF , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_GPS , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_INTEROPERABILITY , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug>"
6303,CWE-000,"static void SaltTextAway ( XtermWidget xw , int which , CELL * cellc , CELL * cell ) { TScreen * screen = TScreenOf ( xw ) ; SelectedCells * scp ; int i ; int eol ; <S2SV_StartBug> int need = 0 ; <S2SV_EndBug> Char * line ; Char * lp ; CELL first = * cellc ; CELL last = * cell ; if ( which < 0 || which >= MAX_SELECTIONS ) { TRACE ( ( ""SaltTextAway<S2SV_blank>-<S2SV_blank>which<S2SV_blank>selection?\\n"" ) ) ; return ; } scp = & ( screen -> selected_cells [ which ] ) ; TRACE ( ( ""SaltTextAway<S2SV_blank>which=%d,<S2SV_blank>first=%d,%d,<S2SV_blank>last=%d,%d\\n"" , which , first . row , first . col , last . row , last . col ) ) ; if ( isSameRow ( & first , & last ) && first . col > last . col ) { int tmp ; EXCHANGE ( first . col , last . col , tmp ) ; } -- last . col ; if ( isSameRow ( & last , & first ) ) { need = Length ( screen , first . row , first . col , last . col ) ; } else { need += Length ( screen , first . row , first . col , screen -> max_col ) + 1 ; for ( i = first . row + 1 ; i < last . row ; i ++ ) need += Length ( screen , i , 0 , screen -> max_col ) + 1 ; if ( last . col >= 0 ) need += Length ( screen , last . row , 0 , last . col ) ; } if_OPT_WIDE_CHARS ( screen , { <S2SV_StartBug> need *= 4 ; <S2SV_EndBug> } ) ; if ( need < 0 ) return ; if ( scp -> data_limit <= ( unsigned ) need ) { if ( ( line = ( Char * ) malloc ( ( size_t ) need + 1 ) ) == 0 ) SysError ( ERROR_BMALLOC2 ) ; free ( scp -> data_buffer ) ; scp -> data_buffer = line ; scp -> data_limit = ( size_t ) ( need + 1 ) ; } else { line = scp -> data_buffer ; } if ( line == 0 ) return ; line [ need ] = '\\0' ; lp = line ; if ( isSameRow ( & last , & first ) ) { lp = SaveText ( screen , last . row , first . col , last . col , lp , & eol ) ; } else { lp = SaveText ( screen , first . row , first . col , screen -> max_col , lp , & eol ) ; if ( eol ) * lp ++ = '\\n' ; for ( i = first . row + 1 ; i < last . row ; i ++ ) { lp = SaveText ( screen , i , 0 , screen -> max_col , lp , & eol ) ; if ( eol ) * lp ++ = '\\n' ; } if ( last . col >= 0 ) lp = SaveText ( screen , last . row , 0 , last . col , lp , & eol ) ; } * lp = '\\0' ; <S2SV_StartBug> TRACE ( ( ""Salted<S2SV_blank>TEXT:%u:%s\\n"" , ( unsigned ) ( lp - line ) , <S2SV_EndBug> <S2SV_StartBug> visibleChars ( line , ( unsigned ) ( lp - line ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> scp -> data_length = ( size_t ) ( lp - line ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; int need = 0 ; size_t have <S2SV_ModStart> screen , { if ( need > 0 ) { if ( screen -> max_combining > 0 ) need += screen -> max_combining ; need *= 6 ; } <S2SV_ModEnd> } ) ; <S2SV_ModStart> = '\\0' ; have = ( size_t ) ( lp - line ) ; if ( ( have * 2 ) < ( size_t ) need ) { scp -> data_limit = have + 1 ; line = realloc ( line , scp -> data_limit ) ; } <S2SV_ModStart> ( unsigned ) have <S2SV_ModEnd> , visibleChars ( <S2SV_ModStart> ( unsigned ) have <S2SV_ModEnd> ) ) ) <S2SV_ModStart> -> data_length = have <S2SV_ModEnd> ; } <S2SV_null>
",ThomasDickey@xterm-snapshots/82ba55b8f994ab30ff561a347b82ea340ba7075c,CVE-2021-27135,https://github.com/ThomasDickey/xterm-snapshots/commit/82ba55b8f994ab30ff561a347b82ea340ba7075c,2021-02-10T16:15Z,"<S2SV_StartBug> int need = 0 ; <S2SV_EndBug> <S2SV_StartBug> need *= 4 ; <S2SV_EndBug> <S2SV_StartBug> TRACE ( ( ""Salted<S2SV_blank>TEXT:%u:%s\\n"" , ( unsigned ) ( lp - line ) , <S2SV_EndBug> <S2SV_StartBug> visibleChars ( line , ( unsigned ) ( lp - line ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> scp -> data_length = ( size_t ) ( lp - line ) ; <S2SV_EndBug>"
3333,CWE-835,"static const u_char * ikev1_nonce_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct isakmp_gen e ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & e , ext , sizeof ( e ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%d"" , ntohs ( e . len ) - 4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , ntohs ( e . len ) - 4 ) ) goto trunc ; <S2SV_StartBug> } else if ( 1 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( const uint8_t * ) ( ext + 1 ) , ep ) ) <S2SV_EndBug> goto trunc ; } <S2SV_StartBug> return ( const u_char * ) ext + ntohs ( e . len ) ; <S2SV_EndBug> trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ; return NULL ; }
","<S2SV_ModStart> ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%u"" <S2SV_ModEnd> , ntohs ( <S2SV_ModStart> ; if ( ntohs ( e . len ) > 4 ) { if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 2 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> else if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 1 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> * ) ( <S2SV_ModEnd> ext + 1 <S2SV_ModStart> trunc ; } }
",the-tcpdump-group@tcpdump/c2ef693866beae071a24b45c49f9674af1df4028,CVE-2017-12990,https://github.com/the-tcpdump-group/tcpdump/commit/c2ef693866beae071a24b45c49f9674af1df4028,2017-09-14T06:29Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%d"" , ntohs ( e . len ) - 4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( 1 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( const uint8_t * ) ( ext + 1 ) , ep ) ) <S2SV_EndBug> <S2SV_StartBug> return ( const u_char * ) ext + ntohs ( e . len ) ; <S2SV_EndBug>"
5447,CWE-787,"void process_bitmap_updates ( STREAM s ) { <S2SV_StartBug> uint16 num_updates ; <S2SV_EndBug> uint16 left , top , right , bottom , width , height ; uint16 cx , cy , bpp , Bpp , compress , bufsize , size ; uint8 * data , * bmpdata ; int i ; <S2SV_StartBug> logger ( Protocol , Debug , ""%s()"" , __func__ ) ; <S2SV_EndBug> in_uint16_le ( s , num_updates ) ; for ( i = 0 ; i < num_updates ; i ++ ) { <S2SV_StartBug> in_uint16_le ( s , left ) ; <S2SV_EndBug> in_uint16_le ( s , top ) ; in_uint16_le ( s , right ) ; in_uint16_le ( s , bottom ) ; in_uint16_le ( s , width ) ; in_uint16_le ( s , height ) ; in_uint16_le ( s , bpp ) ; Bpp = ( bpp + 7 ) / 8 ; in_uint16_le ( s , compress ) ; in_uint16_le ( s , bufsize ) ; cx = right - left + 1 ; cy = bottom - top + 1 ; logger ( Graphics , Debug , ""process_bitmap_updates(),<S2SV_blank>[%d,%d,%d,%d],<S2SV_blank>[%d,%d],<S2SV_blank>bpp=%d,<S2SV_blank>compression=%d"" , left , top , right , bottom , width , height , Bpp , compress ) ; if ( ! compress ) { int y ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; for ( y = 0 ; y < height ; y ++ ) { in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width * Bpp ) ; } ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; xfree ( bmpdata ) ; continue ; } if ( compress & 0x400 ) { size = bufsize ; } else { in_uint8s ( s , 2 ) ; in_uint16_le ( s , size ) ; in_uint8s ( s , 4 ) ; } in_uint8p ( s , data , size ) ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; if ( bitmap_decompress ( bmpdata , width , height , data , size , Bpp ) ) { ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; } else { logger ( Graphics , Warning , ""process_bitmap_updates(),<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>bitmap"" ) ; } xfree ( bmpdata ) ; } }
","<S2SV_ModStart> s ) { <S2SV_ModEnd> int i ; <S2SV_ModStart> int i ; uint16 num_updates <S2SV_ModEnd> ; in_uint16_le ( <S2SV_ModStart> ++ ) { process_bitmap_data ( s <S2SV_ModEnd> ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,"<S2SV_StartBug> uint16 num_updates ; <S2SV_EndBug> <S2SV_StartBug> logger ( Protocol , Debug , ""%s()"" , __func__ ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint16_le ( s , left ) ; <S2SV_EndBug>"
3804,CWE-119,"static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { PadContext * s = inlink -> dst -> priv ; AVFrame * out ; int needs_copy = frame_needs_copy ( s , in ) ; if ( needs_copy ) { av_log ( inlink -> dst , AV_LOG_DEBUG , ""Direct<S2SV_blank>padding<S2SV_blank>impossible<S2SV_blank>allocating<S2SV_blank>new<S2SV_blank>frame\\n"" ) ; out = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , FFMAX ( inlink -> w , s -> w ) , FFMAX ( inlink -> h , s -> h ) ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } else { int i ; out = in ; <S2SV_StartBug> for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) { <S2SV_EndBug> int hsub = s -> draw . hsub [ i ] ; int vsub = s -> draw . vsub [ i ] ; out -> data [ i ] -= ( s -> x >> hsub ) * s -> draw . pixelstep [ i ] + ( s -> y >> vsub ) * out -> linesize [ i ] ; } } if ( s -> y ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , 0 , s -> w , s -> y ) ; } if ( s -> h > s -> y + s -> in_h ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y + s -> in_h , s -> w , s -> h - s -> y - s -> in_h ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y , s -> x , in -> height ) ; if ( needs_copy ) { ff_copy_rectangle2 ( & s -> draw , out -> data , out -> linesize , in -> data , in -> linesize , s -> x , s -> y , 0 , 0 , in -> width , in -> height ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , s -> x + s -> in_w , s -> y , s -> w - s -> x - s -> in_w , in -> height ) ; out -> width = s -> w ; out -> height = s -> h ; if ( in != out ) av_frame_free ( & in ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , out ) ; }
","<S2SV_ModStart> [ i ] && out -> linesize [ i ]
",FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,CVE-2013-4263,https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,2013-11-23T17:55Z,<S2SV_StartBug> for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) { <S2SV_EndBug>
5885,CWE-125,"static UINT drive_process_irp_write ( DRIVE_DEVICE * drive , IRP * irp ) { DRIVE_FILE * file ; UINT32 Length ; UINT64 Offset ; <S2SV_StartBug> if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete ) <S2SV_EndBug> return ERROR_INVALID_PARAMETER ; if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ; Stream_Read_UINT32 ( irp -> input , Length ) ; Stream_Read_UINT64 ( irp -> input , Offset ) ; Stream_Seek ( irp -> input , 20 ) ; <S2SV_StartBug> file = drive_get_file_by_id ( drive , irp -> FileId ) ; <S2SV_EndBug> if ( ! file ) { irp -> IoStatus = STATUS_UNSUCCESSFUL ; Length = 0 ; } else if ( ! drive_file_seek ( file , Offset ) ) { irp -> IoStatus = drive_map_windows_err ( GetLastError ( ) ) ; Length = 0 ; } <S2SV_StartBug> else if ( ! drive_file_write ( file , Stream_Pointer ( irp -> input ) , Length ) ) <S2SV_EndBug> { irp -> IoStatus = drive_map_windows_err ( GetLastError ( ) ) ; Length = 0 ; } Stream_Write_UINT32 ( irp -> output , Length ) ; Stream_Write_UINT8 ( irp -> output , 0 ) ; return irp -> Complete ( irp ) ; }
","<S2SV_ModStart> UINT64 Offset ; void * ptr ; <S2SV_ModStart> 20 ) ; ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ( file , ptr <S2SV_ModEnd> , Length )
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,"<S2SV_StartBug> if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete ) <S2SV_EndBug> <S2SV_StartBug> file = drive_get_file_by_id ( drive , irp -> FileId ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( ! drive_file_write ( file , Stream_Pointer ( irp -> input ) , Length ) ) <S2SV_EndBug>"
2635,CWE-119,"void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) { long unsigned int i ; unsigned char c ; char buf2 [ 15 ] ; mowgli_string_t * s = mowgli_string_create ( ) ; * buf2 = '\\0' ; * outbuffer = '\\0' ; if ( ( ! ( s1 ) || ( * ( s1 ) == '\\0' ) ) ) { return ; } for ( i = 0 ; s1 [ i ] != '\\0' ; i ++ ) { c = s1 [ i ] ; if ( c > 127 ) { snprintf ( buf2 , sizeof buf2 , ""&#%d;"" , c ) ; s -> append ( s , buf2 , strlen ( buf2 ) ) ; } else if ( c == '&' ) { s -> append ( s , ""&amp;"" , 5 ) ; } else if ( c == '<' ) { s -> append ( s , ""&lt;"" , 4 ) ; } else if ( c == '>' ) { s -> append ( s , ""&gt;"" , 4 ) ; } else if ( c == \'""\' ) { s -> append ( s , ""&quot;"" , 6 ) ; } else { s -> append_char ( s , c ) ; } } <S2SV_StartBug> memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; } } s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> ( outbuffer ,
",atheme@atheme/87580d767868360d2fed503980129504da84b63e,CVE-2016-4478,https://github.com/atheme/atheme/commit/87580d767868360d2fed503980129504da84b63e,2016-06-13T19:59Z,"<S2SV_StartBug> memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ; <S2SV_EndBug>"
580,CWE-399,"static int dcbnl_ieee_fill ( struct sk_buff * skb , struct net_device * netdev ) { struct nlattr * ieee , * app ; struct dcb_app_type * itr ; const struct dcbnl_rtnl_ops * ops = netdev -> dcbnl_ops ; int dcbx ; int err ; if ( nla_put_string ( skb , DCB_ATTR_IFNAME , netdev -> name ) ) return - EMSGSIZE ; ieee = nla_nest_start ( skb , DCB_ATTR_IEEE ) ; if ( ! ieee ) return - EMSGSIZE ; if ( ops -> ieee_getets ) { struct ieee_ets ets ; <S2SV_StartBug> err = ops -> ieee_getets ( netdev , & ets ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ; } if ( ops -> ieee_getmaxrate ) { struct ieee_maxrate maxrate ; <S2SV_StartBug> err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ; <S2SV_EndBug> if ( ! err ) { err = nla_put ( skb , DCB_ATTR_IEEE_MAXRATE , sizeof ( maxrate ) , & maxrate ) ; if ( err ) return - EMSGSIZE ; } } if ( ops -> ieee_getpfc ) { <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> err = ops -> ieee_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PFC , sizeof ( pfc ) , & pfc ) ) return - EMSGSIZE ; } app = nla_nest_start ( skb , DCB_ATTR_IEEE_APP_TABLE ) ; if ( ! app ) return - EMSGSIZE ; spin_lock ( & dcb_lock ) ; list_for_each_entry ( itr , & dcb_app_list , list ) { if ( itr -> ifindex == netdev -> ifindex ) { err = nla_put ( skb , DCB_ATTR_IEEE_APP , sizeof ( itr -> app ) , & itr -> app ) ; if ( err ) { spin_unlock ( & dcb_lock ) ; return - EMSGSIZE ; } } } if ( netdev -> dcbnl_ops -> getdcbx ) dcbx = netdev -> dcbnl_ops -> getdcbx ( netdev ) ; else dcbx = - EOPNOTSUPP ; spin_unlock ( & dcb_lock ) ; nla_nest_end ( skb , app ) ; if ( ops -> ieee_peer_getets ) { struct ieee_ets ets ; <S2SV_StartBug> err = ops -> ieee_peer_getets ( netdev , & ets ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ; } if ( ops -> ieee_peer_getpfc ) { <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> err = ops -> ieee_peer_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_PFC , sizeof ( pfc ) , & pfc ) ) return - EMSGSIZE ; } if ( ops -> peer_getappinfo && ops -> peer_getapptable ) { err = dcbnl_build_peer_app ( netdev , skb , DCB_ATTR_IEEE_PEER_APP , DCB_ATTR_IEEE_APP_UNSPEC , DCB_ATTR_IEEE_APP ) ; if ( err ) return - EMSGSIZE ; } nla_nest_end ( skb , ieee ) ; if ( dcbx >= 0 ) { err = nla_put_u8 ( skb , DCB_ATTR_DCBX , dcbx ) ; if ( err ) return - EMSGSIZE ; } return 0 ; }
","<S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> ieee_maxrate maxrate ; memset ( & maxrate , 0 , sizeof ( maxrate ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) ) <S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )
",torvalds@linux/29cd8ae0e1a39e239a3a7b67da1986add1199fc0,CVE-2013-2634,https://github.com/torvalds/linux/commit/29cd8ae0e1a39e239a3a7b67da1986add1199fc0,2013-03-22T11:59Z,"<S2SV_StartBug> err = ops -> ieee_getets ( netdev , & ets ) ; <S2SV_EndBug> <S2SV_StartBug> err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ; <S2SV_EndBug> <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> <S2SV_StartBug> err = ops -> ieee_peer_getets ( netdev , & ets ) ; <S2SV_EndBug> <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug>"
1966,CWE-119,"static vpx_codec_err_t decoder_set_fb_fn ( vpx_codec_alg_priv_t * ctx , vpx_get_frame_buffer_cb_fn_t cb_get , vpx_release_frame_buffer_cb_fn_t cb_release , void * cb_priv ) { if ( cb_get == NULL || cb_release == NULL ) { return VPX_CODEC_INVALID_PARAM ; <S2SV_StartBug> } else if ( ctx -> pbi == NULL ) { <S2SV_EndBug> ctx -> get_ext_fb_cb = cb_get ; ctx -> release_ext_fb_cb = cb_release ; ctx -> ext_priv = cb_priv ; return VPX_CODEC_OK ; } return VPX_CODEC_ERROR ; }
","<S2SV_ModStart> ( ctx -> frame_workers <S2SV_ModEnd> == NULL )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> } else if ( ctx -> pbi == NULL ) { <S2SV_EndBug>
4125,CWE-20,"void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> u32 data ; <S2SV_EndBug> void * vapic ; if ( test_bit ( KVM_APIC_PV_EOI_PENDING , & vcpu -> arch . apic_attention ) ) apic_sync_pv_eoi_from_guest ( vcpu , vcpu -> arch . apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ; kunmap_atomic ( vapic ) ; apic_set_tpr ( vcpu -> arch . apic , data & 0xff ) ; }
","<S2SV_ModStart> { u32 data <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; kvm_read_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; apic_set_tpr
",torvalds@linux/fda4e2e85589191b123d31cdc21fd33ee70f50fd,CVE-2013-6368,https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd,2013-12-14T18:08Z,<S2SV_StartBug> u32 data ; <S2SV_EndBug> <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug>
4250,CWE-401,"struct clock_source * dcn20_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dcn20_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> base ; } kfree ( clk_src ) ;
",torvalds@linux/055e547478a11a6360c7ce05e2afc3e366968a12,CVE-2019-19083,https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12,2019-11-18T06:15Z,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug>
121,CWE-285,"static int __jfs_set_acl ( tid_t tid , struct inode * inode , int type , struct posix_acl * acl ) { char * ea_name ; int rc ; int size = 0 ; char * value = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : ea_name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( rc < 0 ) <S2SV_StartBug> return rc ; <S2SV_EndBug> inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; if ( rc == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( rc < 0 ) goto out ; } rc = __jfs_setxattr ( tid , inode , ea_name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! rc ) set_cached_acl ( inode , type , acl ) ; return rc ; }
","<S2SV_ModStart> { rc = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( rc ) return rc ; inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size <S2SV_ModStart> < 0 ) <S2SV_ModEnd> goto out ;
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug>"
1897,CWE-119,"static int temporal_filter_find_matching_mb_c ( VP9_COMP * cpi , uint8_t * arf_frame_buf , uint8_t * frame_ptr_buf , int stride ) { <S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> int step_param ; <S2SV_EndBug> int sadpb = x -> sadperbit16 ; <S2SV_StartBug> int bestsme = INT_MAX ; <S2SV_EndBug> MV best_ref_mv1 = { 0 , 0 } ; MV best_ref_mv1_full ; MV * ref_mv = & x -> e_mbd . mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv ; struct buf_2d src = x -> plane [ 0 ] . src ; struct buf_2d pre = xd -> plane [ 0 ] . pre [ 0 ] ; best_ref_mv1_full . col = best_ref_mv1 . col >> 3 ; best_ref_mv1_full . row = best_ref_mv1 . row >> 3 ; x -> plane [ 0 ] . src . buf = arf_frame_buf ; x -> plane [ 0 ] . src . stride = stride ; xd -> plane [ 0 ] . pre [ 0 ] . buf = frame_ptr_buf ; xd -> plane [ 0 ] . pre [ 0 ] . stride = stride ; <S2SV_StartBug> if ( cpi -> speed < 8 ) <S2SV_EndBug> step_param = cpi -> sf . reduce_first_step_size + ( ( cpi -> speed > 5 ) ? 1 : 0 ) ; else step_param = cpi -> sf . reduce_first_step_size + 2 ; <S2SV_StartBug> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ; <S2SV_EndBug> vp9_hex_search ( x , & best_ref_mv1_full , step_param , sadpb , 1 , <S2SV_StartBug> & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> int distortion ; unsigned int sse ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion , & sse ) ; } x -> plane [ 0 ] . src = src ; xd -> plane [ 0 ] . pre [ 0 ] = pre ; return bestsme ; }
","<S2SV_ModStart> { MACROBLOCK * const x = & cpi -> td . <S2SV_ModEnd> mb ; MACROBLOCKD <S2SV_ModStart> -> e_mbd ; const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; <S2SV_ModStart> bestsme = INT_MAX ; int distortion ; unsigned int sse ; int cost_list [ 5 ] <S2SV_ModStart> = stride ; step_param = mv_sf -> reduce_first_step_size ; step_param = MIN ( step_param , MAX_MVSEARCH_STEPS <S2SV_ModEnd> - 2 ) <S2SV_ModStart> - 2 ) <S2SV_ModEnd> ; vp9_hex_search ( <S2SV_ModStart> , 1 , cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> ref_mv ) ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ; <S2SV_ModEnd> x -> plane
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> int step_param ; <S2SV_EndBug> <S2SV_StartBug> int bestsme = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> speed < 8 ) <S2SV_EndBug> <S2SV_StartBug> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug>"
7,CWE-200,"void * vips_malloc ( VipsObject * object , size_t size ) { void * buf ; <S2SV_StartBug> buf = g_malloc ( size ) ; <S2SV_EndBug> if ( object ) { g_signal_connect ( object , ""postclose"" , G_CALLBACK ( vips_malloc_cb ) , buf ) ; object -> local_memory += size ; } return ( buf ) ; }
","<S2SV_ModStart> ; buf = g_malloc0 <S2SV_ModEnd> ( size )
",libvips@libvips/00622428bda8d7521db8d74260b519fa41d69d0a,CVE-2019-6976,https://github.com/libvips/libvips/commit/00622428bda8d7521db8d74260b519fa41d69d0a,2019-01-26T23:29Z,<S2SV_StartBug> buf = g_malloc ( size ) ; <S2SV_EndBug>
204,CWE-787,"int main ( int argc , char * * argv ) { int i , n_valid , do_write , do_scrub ; char * c , * dname , * name ; DIR * dir ; FILE * fp ; pdf_t * pdf ; pdf_flag_t flags ; if ( argc < 2 ) usage ( ) ; do_write = do_scrub = flags = 0 ; name = NULL ; for ( i = 1 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , ""-w"" , 2 ) == 0 ) do_write = 1 ; else if ( strncmp ( argv [ i ] , ""-i"" , 2 ) == 0 ) flags |= PDF_FLAG_DISP_CREATOR ; else if ( strncmp ( argv [ i ] , ""-q"" , 2 ) == 0 ) flags |= PDF_FLAG_QUIET ; else if ( strncmp ( argv [ i ] , ""-s"" , 2 ) == 0 ) do_scrub = 1 ; else if ( argv [ i ] [ 0 ] != '-' ) name = argv [ i ] ; else if ( argv [ i ] [ 0 ] == '-' ) usage ( ) ; } if ( ! name ) usage ( ) ; if ( ! ( fp = fopen ( name , ""r"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , argv [ 1 ] ) ; return - 1 ; } else if ( ! pdf_is_pdf ( fp ) ) { ERR ( ""\'%s\'<S2SV_blank>specified<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>PDF\\n"" , name ) ; fclose ( fp ) ; return - 1 ; } if ( ! ( pdf = init_pdf ( fp , name ) ) ) { fclose ( fp ) ; return - 1 ; } for ( i = 0 , n_valid = 0 ; i < pdf -> n_xrefs ; i ++ ) if ( pdf -> xrefs [ i ] . version ) ++ n_valid ; if ( n_valid < 2 ) { if ( ! ( flags & ( PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR ) ) ) printf ( ""%s:<S2SV_blank>There<S2SV_blank>is<S2SV_blank>only<S2SV_blank>one<S2SV_blank>version<S2SV_blank>of<S2SV_blank>this<S2SV_blank>PDF\\n"" , pdf -> name ) ; if ( do_write ) { fclose ( fp ) ; pdf_delete ( pdf ) ; return 0 ; } } dname = NULL ; if ( do_write ) { if ( ( c = strrchr ( name , '/' ) ) ) name = c + 1 ; if ( ( c = strrchr ( name , '.' ) ) ) * c = '\\0' ; <S2SV_StartBug> dname = malloc ( strlen ( name ) + 16 ) ; <S2SV_EndBug> sprintf ( dname , ""%s-versions"" , name ) ; if ( ! ( dir = opendir ( dname ) ) ) mkdir ( dname , S_IRWXU ) ; else { ERR ( ""This<S2SV_blank>directory<S2SV_blank>already<S2SV_blank>exists,<S2SV_blank>PDF<S2SV_blank>version<S2SV_blank>extraction<S2SV_blank>will<S2SV_blank>"" ""not<S2SV_blank>occur.\\n"" ) ; fclose ( fp ) ; closedir ( dir ) ; free ( dname ) ; pdf_delete ( pdf ) ; return - 1 ; } for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) if ( pdf -> xrefs [ i ] . version ) write_version ( fp , name , dname , & pdf -> xrefs [ i ] ) ; } pdf_summarize ( fp , pdf , dname , flags ) ; if ( do_scrub ) scrub_document ( fp , pdf ) ; if ( flags & PDF_FLAG_DISP_CREATOR ) display_creator ( fp , pdf ) ; fclose ( fp ) ; free ( dname ) ; pdf_delete ( pdf ) ; return 0 ; }
","<S2SV_ModStart> ; dname = safe_calloc <S2SV_ModEnd> ( strlen (
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,<S2SV_StartBug> dname = malloc ( strlen ( name ) + 16 ) ; <S2SV_EndBug>
5076,CWE-400,"static int nghttp2_session_upgrade_internal ( nghttp2_session * session , const uint8_t * settings_payload , size_t settings_payloadlen , void * stream_user_data ) { nghttp2_stream * stream ; nghttp2_frame frame ; nghttp2_settings_entry * iv ; size_t niv ; int rv ; nghttp2_priority_spec pri_spec ; nghttp2_mem * mem ; mem = & session -> mem ; if ( ( ! session -> server && session -> next_stream_id != 1 ) || ( session -> server && session -> last_recv_stream_id >= 1 ) ) { return NGHTTP2_ERR_PROTO ; } if ( settings_payloadlen % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) { <S2SV_StartBug> return NGHTTP2_ERR_INVALID_ARGUMENT ; <S2SV_EndBug> } rv = nghttp2_frame_unpack_settings_payload2 ( & iv , & niv , settings_payload , settings_payloadlen , mem ) ; if ( rv != 0 ) { return rv ; } if ( session -> server ) { nghttp2_frame_hd_init ( & frame . hd , settings_payloadlen , NGHTTP2_SETTINGS , NGHTTP2_FLAG_NONE , 0 ) ; frame . settings . iv = iv ; frame . settings . niv = niv ; rv = nghttp2_session_on_settings_received ( session , & frame , 1 ) ; } else { rv = nghttp2_submit_settings ( session , NGHTTP2_FLAG_NONE , iv , niv ) ; } nghttp2_mem_free ( mem , iv ) ; if ( rv != 0 ) { return rv ; } nghttp2_priority_spec_default_init ( & pri_spec ) ; stream = nghttp2_session_open_stream ( session , 1 , NGHTTP2_STREAM_FLAG_NONE , & pri_spec , NGHTTP2_STREAM_OPENING , session -> server ? NULL : stream_user_data ) ; if ( stream == NULL ) { return NGHTTP2_ERR_NOMEM ; } if ( session -> server ) { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_RD ) ; session -> last_recv_stream_id = 1 ; session -> last_proc_stream_id = 1 ; } else { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_WR ) ; session -> last_sent_stream_id = 1 ; session -> next_stream_id += 2 ; } return 0 ; }
","<S2SV_ModStart> { return NGHTTP2_ERR_INVALID_ARGUMENT ; } if ( settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH > session -> max_settings ) { return NGHTTP2_ERR_TOO_MANY_SETTINGS
",nghttp2@nghttp2/336a98feb0d56b9ac54e12736b18785c27f75090,CVE-2020-11080,https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090,2020-06-03T23:15Z,<S2SV_StartBug> return NGHTTP2_ERR_INVALID_ARGUMENT ; <S2SV_EndBug>
3211,CWE-399,"static int archive_read_format_zip_cleanup ( struct archive_read * a ) { struct zip * zip ; struct zip_entry * zip_entry , * next_zip_entry ; zip = ( struct zip * ) ( a -> format -> data ) ; # ifdef HAVE_ZLIB_H if ( zip -> stream_valid ) inflateEnd ( & zip -> stream ) ; # endif <S2SV_StartBug> # if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndBug> if ( zip -> zipx_lzma_valid ) { lzma_end ( & zip -> zipx_lzma_stream ) ; } # endif # ifdef HAVE_BZLIB_H if ( zip -> bzstream_valid ) { BZ2_bzDecompressEnd ( & zip -> bzstream ) ; } # endif free ( zip -> uncompressed_buffer ) ; if ( zip -> ppmd8_valid ) __archive_ppmd8_functions . Ppmd8_Free ( & zip -> ppmd8 ) ; if ( zip -> zip_entries ) { zip_entry = zip -> zip_entries ; while ( zip_entry != NULL ) { next_zip_entry = zip_entry -> next ; archive_string_free ( & zip_entry -> rsrcname ) ; free ( zip_entry ) ; zip_entry = next_zip_entry ; } } free ( zip -> decrypted_buffer ) ; if ( zip -> cctx_valid ) archive_decrypto_aes_ctr_release ( & zip -> cctx ) ; if ( zip -> hctx_valid ) archive_hmac_sha1_cleanup ( & zip -> hctx ) ; free ( zip -> iv ) ; free ( zip -> erd ) ; free ( zip -> v_data ) ; archive_string_free ( & zip -> format_name ) ; free ( zip ) ; ( a -> format -> data ) = NULL ; return ( ARCHIVE_OK ) ; }
","<S2SV_ModStart> endif # if HAVE_LZMA_H <S2SV_ModEnd> && HAVE_LIBLZMA if
",libarchive@libarchive/ba641f73f3d758d9032b3f0e5597a9c6e593a505,CVE-2019-11463,https://github.com/libarchive/libarchive/commit/ba641f73f3d758d9032b3f0e5597a9c6e593a505,2019-04-23T03:29Z,<S2SV_StartBug> # if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndBug>
1645,CWE-119,"<S2SV_StartBug> static void encode_segmentation ( VP9_COMP * cpi , <S2SV_EndBug> struct vp9_write_bit_buffer * wb ) { int i , j ; <S2SV_StartBug> struct segmentation * seg = & cpi -> common . seg ; <S2SV_EndBug> vp9_wb_write_bit ( wb , seg -> enabled ) ; if ( ! seg -> enabled ) return ; <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> update_map ) ; <S2SV_EndBug> if ( seg -> update_map ) { <S2SV_StartBug> vp9_choose_segmap_coding_method ( cpi ) ; <S2SV_EndBug> for ( i = 0 ; i < SEG_TREE_PROBS ; i ++ ) { const int prob = seg -> tree_probs [ i ] ; const int update = prob != MAX_PROB ; <S2SV_StartBug> vp9_wb_write_bit ( wb , update ) ; <S2SV_EndBug> if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; } <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> temporal_update ) ; <S2SV_EndBug> if ( seg -> temporal_update ) { for ( i = 0 ; i < PREDICTION_PROBS ; i ++ ) { const int prob = seg -> pred_probs [ i ] ; const int update = prob != MAX_PROB ; <S2SV_StartBug> vp9_wb_write_bit ( wb , update ) ; <S2SV_EndBug> if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; } } } <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> update_data ) ; <S2SV_EndBug> if ( seg -> update_data ) { <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> abs_delta ) ; <S2SV_EndBug> for ( i = 0 ; i < MAX_SEGMENTS ; i ++ ) { for ( j = 0 ; j < SEG_LVL_MAX ; j ++ ) { <S2SV_StartBug> const int active = vp9_segfeature_active ( seg , i , j ) ; <S2SV_EndBug> vp9_wb_write_bit ( wb , active ) ; if ( active ) { <S2SV_StartBug> const int data = vp9_get_segdata ( seg , i , j ) ; <S2SV_EndBug> const int data_max = vp9_seg_feature_data_max ( j ) ; if ( vp9_is_segfeature_signed ( j ) ) { encode_unsigned_max ( wb , abs ( data ) , data_max ) ; <S2SV_StartBug> vp9_wb_write_bit ( wb , data < 0 ) ; <S2SV_EndBug> } else { encode_unsigned_max ( wb , data , data_max ) ; } } } } } }
","<S2SV_ModStart> void encode_segmentation ( VP9_COMMON * cm , MACROBLOCKD * xd , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> , j ; const <S2SV_ModStart> seg = & cm -> seg ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> ) return ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> { vp9_choose_segmap_coding_method ( cm , xd <S2SV_ModEnd> ) ; for <S2SV_ModStart> != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> ) ; } vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> } } } vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> update_data ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> int active = segfeature_active ( seg , i , j ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> int data = get_segdata <S2SV_ModEnd> ( seg , <S2SV_ModStart> data_max ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void encode_segmentation ( VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> struct segmentation * seg = & cpi -> common . seg ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> update_map ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_choose_segmap_coding_method ( cpi ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , update ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> temporal_update ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , update ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> update_data ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> abs_delta ) ; <S2SV_EndBug> <S2SV_StartBug> const int active = vp9_segfeature_active ( seg , i , j ) ; <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_get_segdata ( seg , i , j ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , data < 0 ) ; <S2SV_EndBug>"
3300,CWE-125,"void qedi_dbg_info ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , u32 level , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & level ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
",torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc,CVE-2019-15090,https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc,2019-08-16T00:15Z,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug>"
1164,CWE-264,"SYSCALL_DEFINE6 ( sendto , int , fd , void __user * , buff , size_t , len , unsigned int , flags , struct sockaddr __user * , addr , int , addr_len ) { struct socket * sock ; struct sockaddr_storage address ; int err ; struct msghdr msg ; struct iovec iov ; int fput_needed ; if ( len > INT_MAX ) <S2SV_StartBug> len = INT_MAX ; <S2SV_EndBug> sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; iov . iov_base = buff ; iov . iov_len = len ; msg . msg_name = NULL ; iov_iter_init ( & msg . msg_iter , WRITE , & iov , 1 , len ) ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_namelen = 0 ; if ( addr ) { err = move_addr_to_kernel ( addr , addr_len , & address ) ; if ( err < 0 ) goto out_put ; msg . msg_name = ( struct sockaddr * ) & address ; msg . msg_namelen = addr_len ; } if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; msg . msg_flags = flags ; err = sock_sendmsg ( sock , & msg , len ) ; out_put : fput_light ( sock -> file , fput_needed ) ; out : return err ; }
","<S2SV_ModStart> len = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT
",torvalds@linux/4de930efc23b92ddf88ce91c405ee645fe6e27ea,CVE-2015-2686,https://github.com/torvalds/linux/commit/4de930efc23b92ddf88ce91c405ee645fe6e27ea,2016-05-02T10:59Z,<S2SV_StartBug> len = INT_MAX ; <S2SV_EndBug>
1410,CWE-119,"void vp8_denoiser_denoise_mb ( VP8_DENOISER * denoiser , MACROBLOCK * x , unsigned int best_sse , unsigned int zero_mv_sse , int recon_yoffset , <S2SV_StartBug> int recon_uvoffset ) <S2SV_EndBug> { int mv_row ; int mv_col ; <S2SV_StartBug> unsigned int motion_magnitude2 ; <S2SV_EndBug> MV_REFERENCE_FRAME frame = x -> best_reference_frame ; MV_REFERENCE_FRAME zero_frame = x -> best_zeromv_reference_frame ; enum vp8_denoiser_decision decision = FILTER_BLOCK ; <S2SV_StartBug> if ( zero_frame ) <S2SV_EndBug> { YV12_BUFFER_CONFIG * src = & denoiser -> yv12_running_avg [ frame ] ; YV12_BUFFER_CONFIG * dst = & denoiser -> yv12_mc_running_avg ; YV12_BUFFER_CONFIG saved_pre , saved_dst ; MB_MODE_INFO saved_mbmi ; MACROBLOCKD * filter_xd = & x -> e_mbd ; MB_MODE_INFO * mbmi = & filter_xd -> mode_info_context -> mbmi ; <S2SV_StartBug> int sse_diff = zero_mv_sse - best_sse ; <S2SV_EndBug> saved_mbmi = * mbmi ; mbmi -> ref_frame = x -> best_reference_frame ; mbmi -> mode = x -> best_sse_inter_mode ; mbmi -> mv = x -> best_sse_mv ; mbmi -> need_to_clamp_mvs = x -> need_to_clamp_best_mvs ; mv_col = x -> best_sse_mv . as_mv . col ; mv_row = x -> best_sse_mv . as_mv . row ; <S2SV_StartBug> if ( frame == INTRA_FRAME || <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned int ) ( mv_row * mv_row + mv_col * mv_col ) <S2SV_EndBug> <= NOISE_MOTION_THRESHOLD && sse_diff < ( int ) SSE_DIFF_THRESHOLD ) ) { mbmi -> ref_frame = x -> best_zeromv_reference_frame ; src = & denoiser -> yv12_running_avg [ zero_frame ] ; mbmi -> mode = ZEROMV ; mbmi -> mv . as_int = 0 ; x -> best_sse_inter_mode = ZEROMV ; x -> best_sse_mv . as_int = 0 ; best_sse = zero_mv_sse ; } saved_pre = filter_xd -> pre ; saved_dst = filter_xd -> dst ; filter_xd -> pre . y_buffer = src -> y_buffer + recon_yoffset ; filter_xd -> pre . u_buffer = src -> u_buffer + recon_uvoffset ; filter_xd -> pre . v_buffer = src -> v_buffer + recon_uvoffset ; filter_xd -> dst . y_buffer = dst -> y_buffer + recon_yoffset ; filter_xd -> dst . u_buffer = dst -> u_buffer + recon_uvoffset ; filter_xd -> dst . v_buffer = dst -> v_buffer + recon_uvoffset ; if ( ! x -> skip ) { vp8_build_inter_predictors_mb ( filter_xd ) ; } else { vp8_build_inter16x16_predictors_mb ( filter_xd , filter_xd -> dst . y_buffer , filter_xd -> dst . u_buffer , filter_xd -> dst . v_buffer , filter_xd -> dst . y_stride , filter_xd -> dst . uv_stride ) ; } filter_xd -> pre = saved_pre ; filter_xd -> dst = saved_dst ; * mbmi = saved_mbmi ; } mv_row = x -> best_sse_mv . as_mv . row ; mv_col = x -> best_sse_mv . as_mv . col ; motion_magnitude2 = mv_row * mv_row + mv_col * mv_col ; <S2SV_StartBug> if ( best_sse > SSE_THRESHOLD || motion_magnitude2 <S2SV_EndBug> <S2SV_StartBug> > 8 * NOISE_MOTION_THRESHOLD ) <S2SV_EndBug> { decision = COPY_BLOCK ; <S2SV_StartBug> } <S2SV_EndBug> if ( decision == FILTER_BLOCK ) { <S2SV_StartBug> decision = vp8_denoiser_filter ( & denoiser -> yv12_mc_running_avg , <S2SV_EndBug> & denoiser -> yv12_running_avg [ INTRA_FRAME ] , x , motion_magnitude2 , recon_yoffset , recon_uvoffset ) ; } if ( decision == COPY_BLOCK ) { <S2SV_StartBug> vp8_copy_mem16x16 ( <S2SV_EndBug> x -> thismb , 16 , denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ) ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> , int recon_uvoffset , loop_filter_info_n * lfi_n , int mb_row , int mb_col , int block_index <S2SV_ModStart> ; unsigned int motion_threshold ; unsigned int motion_magnitude2 ; unsigned int sse_thresh ; int sse_diff_thresh = 0 ; int apply_spatial_loop_filter = 1 <S2SV_ModEnd> ; MV_REFERENCE_FRAME frame <S2SV_ModStart> = FILTER_BLOCK ; enum vp8_denoiser_decision decision_u = COPY_BLOCK ; enum vp8_denoiser_decision decision_v = COPY_BLOCK ; <S2SV_ModStart> mbmi ; int sse_diff = 0 ; const int zero_bias = denoiser -> denoise_pars . denoise_mv_bias ; zero_mv_sse = ( unsigned int ) ( ( int64_t ) zero_mv_sse * zero_bias / 100 ) ; <S2SV_ModStart> ; if ( ( unsigned int ) ( mv_row * mv_row + mv_col * mv_col ) <= NOISE_MOTION_THRESHOLD ) sse_diff_thresh = ( int ) SSE_DIFF_THRESHOLD ; if ( <S2SV_ModStart> == INTRA_FRAME || sse_diff <= sse_diff_thresh ) { x -> denoise_zeromv = 1 ; mbmi -> ref_frame = x -> best_zeromv_reference_frame ; src = & denoiser -> yv12_running_avg [ zero_frame ] ; mbmi -> mode = ZEROMV ; mbmi -> mv . as_int = 0 ; x -> best_sse_inter_mode = ZEROMV ; x -> best_sse_mv . as_int = 0 ; best_sse = zero_mv_sse ; } saved_pre = filter_xd -> pre ; saved_dst = filter_xd -> dst ; filter_xd -> pre . y_buffer = src -> y_buffer + recon_yoffset ; filter_xd -> pre . u_buffer = src -> u_buffer + recon_uvoffset ; filter_xd -> pre . v_buffer = src -> v_buffer + recon_uvoffset ; filter_xd -> dst . y_buffer = dst -> y_buffer + recon_yoffset ; filter_xd -> dst . u_buffer = dst -> u_buffer + recon_uvoffset ; filter_xd -> dst . v_buffer = dst -> v_buffer + recon_uvoffset ; if ( ! x -> skip ) { vp8_build_inter_predictors_mb ( filter_xd ) ; } else { vp8_build_inter16x16_predictors_mb ( filter_xd , filter_xd -> dst . y_buffer , filter_xd -> dst . u_buffer , filter_xd -> dst . v_buffer , filter_xd -> dst . y_stride , filter_xd -> dst . uv_stride ) ; } filter_xd -> pre = saved_pre ; filter_xd -> dst = saved_dst ; * mbmi = saved_mbmi ; } mv_row = x -> best_sse_mv . as_mv . row ; mv_col = x -> best_sse_mv . as_mv . col ; motion_magnitude2 = mv_row * mv_row <S2SV_ModEnd> + mv_col * <S2SV_ModStart> mv_col * mv_col ; motion_threshold = denoiser -> denoise_pars . scale_motion_thresh * NOISE_MOTION_THRESHOLD ; if ( x -> is_skin ) motion_threshold = 1 ; if ( motion_magnitude2 < denoiser -> denoise_pars . scale_increase_filter * NOISE_MOTION_THRESHOLD ) x -> increase_denoising = 1 ; sse_thresh = denoiser -> denoise_pars . scale_sse_thresh * SSE_THRESHOLD ; if ( x -> increase_denoising ) sse_thresh = denoiser -> denoise_pars . scale_sse_thresh * SSE_THRESHOLD_HIGH <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( best_sse > sse_thresh <S2SV_ModEnd> || motion_magnitude2 > <S2SV_ModStart> || motion_magnitude2 > motion_threshold ) <S2SV_ModEnd> decision = COPY_BLOCK <S2SV_ModStart> = COPY_BLOCK ; <S2SV_ModEnd> if ( decision <S2SV_ModStart> FILTER_BLOCK ) { unsigned char * mc_running_avg_y = denoiser -> yv12_mc_running_avg . y_buffer + recon_yoffset ; int mc_avg_y_stride = denoiser -> yv12_mc_running_avg . y_stride ; unsigned char * running_avg_y = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset ; int avg_y_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ; <S2SV_ModStart> = vp8_denoiser_filter ( mc_running_avg_y , mc_avg_y_stride , running_avg_y , avg_y_stride , x -> thismb , 16 , motion_magnitude2 , x -> increase_denoising ) ; denoiser -> denoise_state [ block_index ] = motion_magnitude2 > 0 ? kFilterNonZeroMV : kFilterZeroMV ; if ( denoiser -> denoiser_mode != kDenoiserOnYOnly && motion_magnitude2 == 0 && decision == FILTER_BLOCK ) { unsigned char * mc_running_avg_u = <S2SV_ModEnd> denoiser -> yv12_mc_running_avg <S2SV_ModStart> denoiser -> yv12_mc_running_avg . u_buffer + recon_uvoffset ; unsigned char * running_avg_u = denoiser -> yv12_running_avg [ INTRA_FRAME ] . u_buffer + recon_uvoffset ; unsigned char * mc_running_avg_v = denoiser -> yv12_mc_running_avg . v_buffer + recon_uvoffset ; unsigned char * running_avg_v = denoiser -> yv12_running_avg [ INTRA_FRAME ] . v_buffer + recon_uvoffset ; int mc_avg_uv_stride = denoiser -> yv12_mc_running_avg . uv_stride ; int avg_uv_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ; int signal_stride = x -> block [ 16 ] . src_stride ; decision_u = vp8_denoiser_filter_uv ( mc_running_avg_u , mc_avg_uv_stride , running_avg_u , avg_uv_stride , x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src , signal_stride , motion_magnitude2 , 0 ) ; decision_v = vp8_denoiser_filter_uv ( mc_running_avg_v , mc_avg_uv_stride , running_avg_v , avg_uv_stride , x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src , signal_stride , motion_magnitude2 , 0 ) ; } <S2SV_ModEnd> } if ( <S2SV_ModStart> COPY_BLOCK ) { x -> denoise_zeromv = 0 ; <S2SV_ModStart> y_stride ) ; denoiser -> denoise_state [ block_index ] = kNoFilter ; } if ( denoiser -> denoiser_mode != kDenoiserOnYOnly ) { if ( decision_u == COPY_BLOCK ) { vp8_copy_mem8x8 ( x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src , x -> block [ 16 ] . src_stride , denoiser -> yv12_running_avg [ INTRA_FRAME ] . u_buffer + recon_uvoffset , denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ) ; } if ( decision_v == COPY_BLOCK ) { vp8_copy_mem8x8 ( x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src , x -> block [ 16 ] . src_stride , denoiser -> yv12_running_avg [ INTRA_FRAME ] . v_buffer + recon_uvoffset , denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ) ; } } if ( apply_spatial_loop_filter ) { loop_filter_info lfi ; int apply_filter_col = 0 ; int apply_filter_row = 0 ; int apply_filter = 0 ; int y_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ; int uv_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ; int filter_level = 48 ; int hev_index = lfi_n -> hev_thr_lut [ INTER_FRAME ] [ filter_level ] ; lfi . mblim = lfi_n -> mblim [ filter_level ] ; lfi . blim = lfi_n -> blim [ filter_level ] ; lfi . lim = lfi_n -> lim [ filter_level ] ; lfi . hev_thr = lfi_n -> hev_thr [ hev_index ] ; if ( mb_col > 0 ) { apply_filter_col = ! ( ( denoiser -> denoise_state [ block_index ] == denoiser -> denoise_state [ block_index - 1 ] ) && denoiser -> denoise_state [ block_index ] != kFilterNonZeroMV ) ; if ( apply_filter_col ) { apply_filter = 1 ; vp8_loop_filter_mbv ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , NULL , NULL , y_stride , uv_stride , & lfi ) ; } } if ( mb_row > 0 ) { apply_filter_row = ! ( ( denoiser -> denoise_state [ block_index ] == denoiser -> denoise_state [ block_index - denoiser -> num_mb_cols ] ) && denoiser -> denoise_state [ block_index ] != kFilterNonZeroMV ) ; if ( apply_filter_row ) { apply_filter = 1 ; vp8_loop_filter_mbh ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , NULL , NULL , y_stride , uv_stride , & lfi ) ; } } if ( apply_filter ) { vp8_copy_mem16x16 ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , y_stride , x -> thismb , 16 ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int recon_uvoffset ) <S2SV_EndBug> <S2SV_StartBug> unsigned int motion_magnitude2 ; <S2SV_EndBug> <S2SV_StartBug> if ( zero_frame ) <S2SV_EndBug> <S2SV_StartBug> int sse_diff = zero_mv_sse - best_sse ; <S2SV_EndBug> <S2SV_StartBug> if ( frame == INTRA_FRAME || <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned int ) ( mv_row * mv_row + mv_col * mv_col ) <S2SV_EndBug> <S2SV_StartBug> if ( best_sse > SSE_THRESHOLD || motion_magnitude2 <S2SV_EndBug> <S2SV_StartBug> > 8 * NOISE_MOTION_THRESHOLD ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> decision = vp8_denoiser_filter ( & denoiser -> yv12_mc_running_avg , <S2SV_EndBug> <S2SV_StartBug> vp8_copy_mem16x16 ( <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
3121,CWE-119,"int usbip_recv_xbuff ( struct usbip_device * ud , struct urb * urb ) { int ret ; int size ; if ( ud -> side == USBIP_STUB ) { if ( usb_pipein ( urb -> pipe ) ) return 0 ; size = urb -> transfer_buffer_length ; } else { if ( usb_pipeout ( urb -> pipe ) ) return 0 ; size = urb -> actual_length ; } if ( ! ( size > 0 ) ) return 0 ; <S2SV_StartBug> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; <S2SV_EndBug> if ( ret != size ) { dev_err ( & urb -> dev -> dev , ""recv<S2SV_blank>xbuf,<S2SV_blank>%d\\n"" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; <S2SV_StartBug> } else { <S2SV_EndBug> usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } } <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> return 0 ; if ( size > urb -> transfer_buffer_length ) { <S2SV_ModEnd> if ( ud <S2SV_ModStart> SDEV_EVENT_ERROR_TCP ) ; return 0 ; <S2SV_ModStart> ; } } ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , ""recv<S2SV_blank>xbuf,<S2SV_blank>%d\\n"" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; } else { usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } }
",torvalds@linux/b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb,CVE-2016-3955,https://github.com/torvalds/linux/commit/b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb,2016-07-03T21:59Z,"<S2SV_StartBug> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug>"
4083,CWE-189,"static int sgi_timer_set ( struct k_itimer * timr , int flags , struct itimerspec * new_setting , struct itimerspec * old_setting ) { unsigned long when , period , irqflags ; int err = 0 ; cnodeid_t nodeid ; struct mmtimer * base ; struct rb_node * n ; if ( old_setting ) sgi_timer_get ( timr , old_setting ) ; sgi_timer_del ( timr ) ; <S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> if ( when == 0 ) return 0 ; base = kmalloc ( sizeof ( struct mmtimer ) , GFP_KERNEL ) ; if ( base == NULL ) return - ENOMEM ; if ( flags & TIMER_ABSTIME ) { struct timespec n ; unsigned long now ; getnstimeofday ( & n ) ; <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug> if ( when > now ) when -= now ; else when = 0 ; } when = ( when + sgi_clock_period - 1 ) / sgi_clock_period + rtc_time ( ) ; period = ( period + sgi_clock_period - 1 ) / sgi_clock_period ; preempt_disable ( ) ; nodeid = cpu_to_node ( smp_processor_id ( ) ) ; spin_lock_irqsave ( & timers [ nodeid ] . lock , irqflags ) ; base -> timer = timr ; base -> cpu = smp_processor_id ( ) ; timr -> it . mmtimer . clock = TIMER_SET ; timr -> it . mmtimer . node = nodeid ; timr -> it . mmtimer . incr = period ; timr -> it . mmtimer . expires = when ; n = timers [ nodeid ] . next ; mmtimer_add_list ( base ) ; if ( timers [ nodeid ] . next == n ) { spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; } if ( n ) mmtimer_disable_int ( cnodeid_to_nasid ( nodeid ) , COMPARATOR ) ; mmtimer_set_next_timer ( nodeid ) ; spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; }
","<S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( &
",torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d,CVE-2011-3209,https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d,2012-10-03T11:02Z,<S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug>
4109,CWE-399,"long video_ioctl2 ( struct file * file , unsigned int cmd , unsigned long arg ) { <S2SV_StartBug> char sbuf [ 128 ] ; <S2SV_EndBug> void * mbuf = NULL ; void * parg = ( void * ) arg ; long err = - EINVAL ; bool has_array_args ; size_t array_size = 0 ; void __user * user_ptr = NULL ; void * * kernel_ptr = NULL ; if ( _IOC_DIR ( cmd ) != _IOC_NONE ) { if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { unsigned long n = cmd_input_size ( cmd ) ; if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ; if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ; } else { memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ; } } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { mbuf = kmalloc ( array_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_array_args ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ; * kernel_ptr = mbuf ; } <S2SV_StartBug> err = __video_do_ioctl ( file , cmd , parg ) ; <S2SV_EndBug> if ( err == - ENOIOCTLCMD ) err = - EINVAL ; if ( has_array_args ) { * kernel_ptr = user_ptr ; if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ; goto out_array_args ; } if ( err < 0 ) goto out ; out_array_args : switch ( _IOC_DIR ( cmd ) ) { case _IOC_READ : case ( _IOC_WRITE | _IOC_READ ) : if ( copy_to_user ( ( void __user * ) arg , parg , _IOC_SIZE ( cmd ) ) ) err = - EFAULT ; break ; } out : kfree ( mbuf ) ; return err ; }
","<S2SV_ModStart> arg ) { return video_usercopy <S2SV_ModEnd> ( file , <S2SV_ModStart> , cmd , arg , __video_do_ioctl ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/fc0a80798576f80ca10b3f6c9c7097f12fd1d64e,CVE-2010-5329,https://github.com/torvalds/linux/commit/fc0a80798576f80ca10b3f6c9c7097f12fd1d64e,2017-04-24T06:59Z,"<S2SV_StartBug> char sbuf [ 128 ] ; <S2SV_EndBug> <S2SV_StartBug> err = __video_do_ioctl ( file , cmd , parg ) ; <S2SV_EndBug>"
7053,CWE-476,"void AV1_RewriteESDescriptorEx ( GF_MPEGVisualSampleEntryBox * av1 , GF_MediaBox * mdia ) { GF_BitRateBox * btrt = gf_isom_sample_entry_get_bitrate ( ( GF_SampleEntryBox * ) av1 , GF_FALSE ) ; if ( av1 -> emul_esd ) gf_odf_desc_del ( ( GF_Descriptor * ) av1 -> emul_esd ) ; av1 -> emul_esd = gf_odf_desc_esd_new ( 2 ) ; av1 -> emul_esd -> decoderConfig -> streamType = GF_STREAM_VISUAL ; av1 -> emul_esd -> decoderConfig -> objectTypeIndication = GF_CODECID_AV1 ; if ( btrt ) { av1 -> emul_esd -> decoderConfig -> bufferSizeDB = btrt -> bufferSizeDB ; av1 -> emul_esd -> decoderConfig -> avgBitrate = btrt -> avgBitrate ; av1 -> emul_esd -> decoderConfig -> maxBitrate = btrt -> maxBitrate ; } <S2SV_StartBug> if ( av1 -> av1_config ) { <S2SV_EndBug> GF_AV1Config * av1_cfg = AV1_DuplicateConfig ( av1 -> av1_config -> config ) ; if ( av1_cfg ) { gf_odf_av1_cfg_write ( av1_cfg , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> data , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> dataLength ) ; gf_odf_av1_cfg_del ( av1_cfg ) ; } } }
","<S2SV_ModStart> av1 -> av1_config && av1 -> av1_config -> config
",gpac@gpac/b2eab95e07cb5819375a50358d4806a8813b6e50,CVE-2021-31262,https://github.com/gpac/gpac/commit/b2eab95e07cb5819375a50358d4806a8813b6e50,2021-04-19T19:15Z,<S2SV_StartBug> if ( av1 -> av1_config ) { <S2SV_EndBug>
3907,CWE-119,"GPLOT * gplotCreate ( const char * rootname , l_int32 outformat , const char * title , const char * xlabel , const char * ylabel ) { char * newroot ; <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 badchar ; GPLOT * gplot ; PROCNAME ( ""gplotCreate"" ) ; if ( ! rootname ) return ( GPLOT * ) ERROR_PTR ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( outformat != GPLOT_PNG && outformat != GPLOT_PS && outformat != GPLOT_EPS && outformat != GPLOT_LATEX ) return ( GPLOT * ) ERROR_PTR ( ""outformat<S2SV_blank>invalid"" , procName , NULL ) ; stringCheckForChars ( rootname , ""`;&|><\\""?*"" , & badchar ) ; if ( badchar ) return ( GPLOT * ) ERROR_PTR ( ""invalid<S2SV_blank>rootname"" , procName , NULL ) ; if ( ( gplot = ( GPLOT * ) LEPT_CALLOC ( 1 , sizeof ( GPLOT ) ) ) == NULL ) return ( GPLOT * ) ERROR_PTR ( ""gplot<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; gplot -> cmddata = sarrayCreate ( 0 ) ; gplot -> datanames = sarrayCreate ( 0 ) ; gplot -> plotdata = sarrayCreate ( 0 ) ; gplot -> plottitles = sarrayCreate ( 0 ) ; gplot -> plotstyles = numaCreate ( 0 ) ; newroot = genPathname ( rootname , NULL ) ; gplot -> rootname = newroot ; gplot -> outformat = outformat ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.cmd"" , rootname ) ; <S2SV_EndBug> gplot -> cmdname = stringNew ( buf ) ; if ( outformat == GPLOT_PNG ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.png"" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_PS ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.ps"" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_EPS ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.eps"" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_LATEX ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.tex"" , newroot ) ; <S2SV_EndBug> gplot -> outname = stringNew ( buf ) ; if ( title ) gplot -> title = stringNew ( title ) ; if ( xlabel ) gplot -> xlabel = stringNew ( xlabel ) ; if ( ylabel ) gplot -> ylabel = stringNew ( ylabel ) ; return gplot ; }
","<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.cmd"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.png"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.ps"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.eps"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.tex"" ,
",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.cmd"" , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.png"" , newroot ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.ps"" , newroot ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.eps"" , newroot ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.tex"" , newroot ) ; <S2SV_EndBug>"
910,CWE-399,"static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ; if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > MAX_RECURSION_LEVEL ) ) return - ETOOMANYREFS ; UNIXCB ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! UNIXCB ( skb ) . fp ) return - ENOMEM ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <S2SV_StartBug> unix_inflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug> return max_level ; }
","<S2SV_ModStart> -> fp -> user , scm -> fp ->
",torvalds@linux/415e3d3e90ce9e18727e8843ae343eda5a58fad6,CVE-2016-2550,https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6,2016-04-27T17:59Z,<S2SV_StartBug> unix_inflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug>
595,CWE-20,"static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { <S2SV_StartBug> u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; <S2SV_EndBug> switch ( mode ) { case PSR_AA32_MODE_USR : <S2SV_StartBug> case PSR_AA32_MODE_FIQ : <S2SV_EndBug> case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : <S2SV_StartBug> case PSR_MODE_EL0t : <S2SV_EndBug> case PSR_MODE_EL1t : <S2SV_StartBug> case PSR_MODE_EL1h : <S2SV_EndBug> break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }
","<S2SV_ModStart> ) ) { u64 <S2SV_ModEnd> mode = ( <S2SV_ModStart> ( * ( u64 <S2SV_ModEnd> * ) valp <S2SV_ModStart> case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;
",torvalds@linux/2a3f93459d689d990b3ecfbe782fec89b97d3279,CVE-2018-18021,https://github.com/torvalds/linux/commit/2a3f93459d689d990b3ecfbe782fec89b97d3279,2018-10-07T06:29Z,<S2SV_StartBug> u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; <S2SV_EndBug> <S2SV_StartBug> case PSR_AA32_MODE_FIQ : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL0t : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL1h : <S2SV_EndBug>
2905,CWE-399,"static int kvm_vm_ioctl_create_vcpu ( struct kvm * kvm , u32 id ) { int r ; struct kvm_vcpu * vcpu , * v ; vcpu = kvm_arch_vcpu_create ( kvm , id ) ; if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ; preempt_notifier_init ( & vcpu -> preempt_notifier , & kvm_preempt_ops ) ; r = kvm_arch_vcpu_setup ( vcpu ) ; if ( r ) goto vcpu_destroy ; mutex_lock ( & kvm -> lock ) ; <S2SV_StartBug> if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { <S2SV_EndBug> r = - EINVAL ; goto unlock_vcpu_destroy ; } kvm_for_each_vcpu ( r , v , kvm ) if ( v -> vcpu_id == id ) { r = - EEXIST ; goto unlock_vcpu_destroy ; } BUG_ON ( kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] ) ; kvm_get_kvm ( kvm ) ; r = create_vcpu_fd ( vcpu ) ; if ( r < 0 ) { kvm_put_kvm ( kvm ) ; goto unlock_vcpu_destroy ; } kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] = vcpu ; smp_wmb ( ) ; atomic_inc ( & kvm -> online_vcpus ) ; mutex_unlock ( & kvm -> lock ) ; return r ; unlock_vcpu_destroy : mutex_unlock ( & kvm -> lock ) ; vcpu_destroy : kvm_arch_vcpu_destroy ( vcpu ) ; return r ; }
","<S2SV_ModStart> ; if ( ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if (
",torvalds@linux/9c895160d25a76c21b65bad141b08e8d4f99afef,CVE-2012-1601,https://github.com/torvalds/linux/commit/9c895160d25a76c21b65bad141b08e8d4f99afef,2012-05-17T11:00Z,<S2SV_StartBug> if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { <S2SV_EndBug>
1503,CWE-119,"static vpx_codec_err_t vp8e_mr_alloc_mem ( const vpx_codec_enc_cfg_t * cfg , void * * mem_loc ) { vpx_codec_err_t res = 0 ; # if CONFIG_MULTI_RES_ENCODING LOWER_RES_FRAME_INFO * shared_mem_loc ; int mb_rows = ( ( cfg -> g_w + 15 ) >> 4 ) ; int mb_cols = ( ( cfg -> g_h + 15 ) >> 4 ) ; shared_mem_loc = calloc ( 1 , sizeof ( LOWER_RES_FRAME_INFO ) ) ; if ( ! shared_mem_loc ) { res = VPX_CODEC_MEM_ERROR ; } shared_mem_loc -> mb_info = calloc ( mb_rows * mb_cols , sizeof ( LOWER_RES_MB_INFO ) ) ; if ( ! ( shared_mem_loc -> mb_info ) ) { res = VPX_CODEC_MEM_ERROR ; } else { * mem_loc = ( void * ) shared_mem_loc ; res = VPX_CODEC_OK ; } <S2SV_StartBug> # endif <S2SV_EndBug> return res ; }
","<S2SV_ModStart> ; } # else ( void ) cfg ; ( void ) mem_loc ; #
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> # endif <S2SV_EndBug>
2903,CWE-000,"static int powermate_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( intf ) ; struct usb_host_interface * interface ; struct usb_endpoint_descriptor * endpoint ; struct powermate_device * pm ; struct input_dev * input_dev ; int pipe , maxp ; int error = - ENOMEM ; <S2SV_StartBug> interface = intf -> cur_altsetting ; <S2SV_EndBug> endpoint = & interface -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_int_in ( endpoint ) ) return - EIO ; usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , 0x0a , USB_TYPE_CLASS | USB_RECIP_INTERFACE , 0 , interface -> desc . bInterfaceNumber , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; pm = kzalloc ( sizeof ( struct powermate_device ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! pm || ! input_dev ) goto fail1 ; if ( powermate_alloc_buffers ( udev , pm ) ) goto fail2 ; pm -> irq = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! pm -> irq ) goto fail2 ; pm -> config = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! pm -> config ) goto fail3 ; pm -> udev = udev ; pm -> intf = intf ; pm -> input = input_dev ; usb_make_path ( udev , pm -> phys , sizeof ( pm -> phys ) ) ; strlcat ( pm -> phys , ""/input0"" , sizeof ( pm -> phys ) ) ; spin_lock_init ( & pm -> lock ) ; switch ( le16_to_cpu ( udev -> descriptor . idProduct ) ) { case POWERMATE_PRODUCT_NEW : input_dev -> name = pm_name_powermate ; break ; case POWERMATE_PRODUCT_OLD : input_dev -> name = pm_name_soundknob ; break ; default : input_dev -> name = pm_name_soundknob ; printk ( KERN_WARNING ""powermate:<S2SV_blank>unknown<S2SV_blank>product<S2SV_blank>id<S2SV_blank>%04x\\n"" , le16_to_cpu ( udev -> descriptor . idProduct ) ) ; } input_dev -> phys = pm -> phys ; usb_to_input_id ( udev , & input_dev -> id ) ; input_dev -> dev . parent = & intf -> dev ; input_set_drvdata ( input_dev , pm ) ; input_dev -> event = powermate_input_event ; input_dev -> evbit [ 0 ] = BIT_MASK ( EV_KEY ) | BIT_MASK ( EV_REL ) | BIT_MASK ( EV_MSC ) ; input_dev -> keybit [ BIT_WORD ( BTN_0 ) ] = BIT_MASK ( BTN_0 ) ; input_dev -> relbit [ BIT_WORD ( REL_DIAL ) ] = BIT_MASK ( REL_DIAL ) ; input_dev -> mscbit [ BIT_WORD ( MSC_PULSELED ) ] = BIT_MASK ( MSC_PULSELED ) ; pipe = usb_rcvintpipe ( udev , endpoint -> bEndpointAddress ) ; maxp = usb_maxpacket ( udev , pipe , usb_pipeout ( pipe ) ) ; if ( maxp < POWERMATE_PAYLOAD_SIZE_MIN || maxp > POWERMATE_PAYLOAD_SIZE_MAX ) { printk ( KERN_WARNING ""powermate:<S2SV_blank>Expected<S2SV_blank>payload<S2SV_blank>of<S2SV_blank>%d--%d<S2SV_blank>bytes,<S2SV_blank>found<S2SV_blank>%d<S2SV_blank>bytes!\\n"" , POWERMATE_PAYLOAD_SIZE_MIN , POWERMATE_PAYLOAD_SIZE_MAX , maxp ) ; maxp = POWERMATE_PAYLOAD_SIZE_MAX ; } usb_fill_int_urb ( pm -> irq , udev , pipe , pm -> data , maxp , powermate_irq , pm , endpoint -> bInterval ) ; pm -> irq -> transfer_dma = pm -> data_dma ; pm -> irq -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; if ( usb_submit_urb ( pm -> irq , GFP_KERNEL ) ) { error = - EIO ; goto fail4 ; } error = input_register_device ( pm -> input ) ; if ( error ) goto fail5 ; pm -> requires_update = UPDATE_PULSE_ASLEEP | UPDATE_PULSE_AWAKE | UPDATE_PULSE_MODE | UPDATE_STATIC_BRIGHTNESS ; powermate_pulse_led ( pm , 0x80 , 255 , 0 , 1 , 0 ) ; usb_set_intfdata ( intf , pm ) ; return 0 ; fail5 : usb_kill_urb ( pm -> irq ) ; fail4 : usb_free_urb ( pm -> config ) ; fail3 : usb_free_urb ( pm -> irq ) ; fail2 : powermate_free_buffers ( udev , pm ) ; fail1 : input_free_device ( input_dev ) ; kfree ( pm ) ; return error ; }
","<S2SV_ModStart> intf -> cur_altsetting ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL
",torvalds@linux/9c6ba456711687b794dcf285856fc14e2c76074f,CVE-2016-2186,https://github.com/torvalds/linux/commit/9c6ba456711687b794dcf285856fc14e2c76074f,2016-05-02T10:59Z,<S2SV_StartBug> interface = intf -> cur_altsetting ; <S2SV_EndBug>
3036,CWE-835,"static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MaxTextExtent ] , text [ MaxTextExtent ] ; Image * image ; IndexPacket * indexes ; long x_offset , y_offset ; MagickBooleanType status ; MagickPixelPacket pixel ; QuantumAny range ; register ssize_t i , x ; register PixelPacket * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = width ; image -> rows = height ; for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> matte = MagickFalse ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> matte = MagickTrue ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> colorspace = ( ColorspaceType ) type ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; ( void ) SetImageBackgroundColor ( image ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double blue , green , index , opacity , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; index = 0.0 ; opacity = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & opacity ) ; green = red ; blue = red ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & index , & opacity ) ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & index ) ; break ; } default : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & opacity ) ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; index *= 0.01 * range ; opacity *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . index = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( index + 0.5 ) , range ) ; pixel . opacity = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( opacity + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) continue ; SetPixelRed ( q , pixel . red ) ; SetPixelGreen ( q , pixel . green ) ; SetPixelBlue ( q , pixel . blue ) ; if ( image -> colorspace == CMYKColorspace ) { indexes = GetAuthenticIndexQueue ( image ) ; SetPixelIndex ( indexes , pixel . index ) ; } if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , pixel . opacity ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } <S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug> if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; }
",ImageMagick@ImageMagick/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78,CVE-2017-11523,https://github.com/ImageMagick/ImageMagick/commit/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78,2017-07-22T21:29Z,"<S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug>"
5103,CWE-119,"hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( ""HIVEX_DEBUG"" ) ; if ( debug && STREQ ( debug , ""1"" ) ) h -> msglvl = 2 ; DEBUG ( 2 , ""created<S2SV_blank>handle<S2SV_blank>%p"" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; <S2SV_StartBug> h -> size = statbuf . st_size ; <S2SV_EndBug> if ( ! h -> writable ) { h -> addr = mmap ( NULL , h -> size , PROT_READ , MAP_SHARED , h -> fd , 0 ) ; if ( h -> addr == MAP_FAILED ) goto error ; DEBUG ( 2 , ""mapped<S2SV_blank>file<S2SV_blank>at<S2SV_blank>%p"" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == NULL ) goto error ; if ( full_read ( h -> fd , h -> addr , h -> size ) < h -> size ) goto error ; if ( close ( h -> fd ) == - 1 ) goto error ; h -> fd = - 1 ; } if ( h -> hdr -> magic [ 0 ] != 'r' || h -> hdr -> magic [ 1 ] != 'e' || h -> hdr -> magic [ 2 ] != 'g' || h -> hdr -> magic [ 3 ] != 'f' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } uint32_t major_ver = le32toh ( h -> hdr -> major_ver ) ; if ( major_ver != 1 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>hive<S2SV_blank>file<S2SV_blank>major<S2SV_blank>version<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(expected<S2SV_blank>1)"" , filename , major_ver ) ; goto error ; } h -> bitmap = calloc ( 1 + h -> size / 32 , 1 ) ; if ( h -> bitmap == NULL ) goto error ; uint32_t sum = header_checksum ( h ) ; if ( sum != le32toh ( h -> hdr -> csum ) ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>hive<S2SV_blank>header"" , filename ) ; goto error ; } h -> last_modified = le64toh ( ( int64_t ) h -> hdr -> last_modified ) ; if ( h -> msglvl >= 2 ) { char * name = _hivex_windows_utf16_to_utf8 ( h -> hdr -> name , 64 ) ; fprintf ( stderr , ""hivex_open:<S2SV_blank>header<S2SV_blank>fields:\\n"" ""<S2SV_blank><S2SV_blank>file<S2SV_blank>version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 "".%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank>sequence<S2SV_blank>nos<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 ""<S2SV_blank>%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(sequences<S2SV_blank>nos<S2SV_blank>should<S2SV_blank>match<S2SV_blank>if<S2SV_blank>hive<S2SV_blank>was<S2SV_blank>synched<S2SV_blank>at<S2SV_blank>shutdown)\\n"" ""<S2SV_blank><S2SV_blank>last<S2SV_blank>modified<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu64 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Windows<S2SV_blank>filetime,<S2SV_blank>x<S2SV_blank>100<S2SV_blank>ns<S2SV_blank>since<S2SV_blank>1601-01-01)\\n"" ""<S2SV_blank><S2SV_blank>original<S2SV_blank>file<S2SV_blank>name<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(only<S2SV_blank>32<S2SV_blank>chars<S2SV_blank>are<S2SV_blank>stored,<S2SV_blank>name<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>truncated)\\n"" ""<S2SV_blank><S2SV_blank>root<S2SV_blank>offset<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000\\n"" ""<S2SV_blank><S2SV_blank>end<S2SV_blank>of<S2SV_blank>last<S2SV_blank>page<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000<S2SV_blank>(total<S2SV_blank>file<S2SV_blank>size<S2SV_blank>0x%zx)\\n"" ""<S2SV_blank><S2SV_blank>checksum<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>(calculated<S2SV_blank>0x%x)\\n"" , major_ver , le32toh ( h -> hdr -> minor_ver ) , le32toh ( h -> hdr -> sequence1 ) , le32toh ( h -> hdr -> sequence2 ) , h -> last_modified , name ? name : ""(conversion<S2SV_blank>failed)"" , le32toh ( h -> hdr -> offset ) , le32toh ( h -> hdr -> blocks ) , h -> size , le32toh ( h -> hdr -> csum ) , sum ) ; free ( name ) ; } h -> rootoffs = le32toh ( h -> hdr -> offset ) + 0x1000 ; h -> endpages = le32toh ( h -> hdr -> blocks ) + 0x1000 ; DEBUG ( 2 , ""root<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>0x%zx"" , h -> rootoffs ) ; int seen_root_block = 0 , bad_root_block = 0 ; size_t pages = 0 ; size_t smallest_page = SIZE_MAX , largest_page = 0 ; size_t blocks = 0 ; size_t smallest_block = SIZE_MAX , largest_block = 0 , blocks_bytes = 0 ; size_t used_blocks = 0 ; size_t used_size = 0 ; size_t off ; struct ntreg_hbin_page * page ; for ( off = 0x1000 ; off < h -> size ; off += le32toh ( page -> page_size ) ) { if ( off >= h -> endpages ) break ; page = ( struct ntreg_hbin_page * ) ( ( char * ) h -> addr + off ) ; if ( page -> magic [ 0 ] != 'h' || page -> magic [ 1 ] != 'b' || page -> magic [ 2 ] != 'i' || page -> magic [ 3 ] != 'n' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>"" ""(at<S2SV_blank>0x%zx,<S2SV_blank>after<S2SV_blank>%zu<S2SV_blank>pages)"" , filename , off , pages ) ; goto error ; } size_t page_size = le32toh ( page -> page_size ) ; DEBUG ( 2 , ""page<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>size<S2SV_blank>%zu"" , off , page_size ) ; pages ++ ; if ( page_size < smallest_page ) smallest_page = page_size ; if ( page_size > largest_page ) largest_page = page_size ; if ( page_size <= sizeof ( struct ntreg_hbin_page ) || ( page_size & 0x0fff ) != 0 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , page_size , off ) ; goto error ; } size_t blkoff ; struct ntreg_hbin_block * block ; size_t seg_len ; for ( blkoff = off + 0x20 ; blkoff < off + page_size ; blkoff += seg_len ) { blocks ++ ; int is_root = blkoff == h -> rootoffs ; if ( is_root ) seen_root_block = 1 ; block = ( struct ntreg_hbin_block * ) ( ( char * ) h -> addr + blkoff ) ; int used ; seg_len = block_len ( h , blkoff , & used ) ; if ( seg_len <= 4 || ( seg_len & 3 ) != 0 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%"" PRIu32 ""<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , le32toh ( block -> seg_len ) , blkoff ) ; goto error ; } if ( h -> msglvl >= 2 ) { unsigned char * id = ( unsigned char * ) block -> id ; int id0 = id [ 0 ] , id1 = id [ 1 ] ; fprintf ( stderr , ""%s:<S2SV_blank>%s:<S2SV_blank>"" ""%s<S2SV_blank>block<S2SV_blank>id<S2SV_blank>%d,%d<S2SV_blank>(%c%c)<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>size<S2SV_blank>%zu%s\\n"" , ""hivex"" , __func__ , used ? ""used"" : ""free"" , id0 , id1 , c_isprint ( id0 ) ? id0 : '.' , c_isprint ( id1 ) ? id1 : '.' , blkoff , seg_len , is_root ? ""<S2SV_blank>(root)"" : """" ) ; } blocks_bytes += seg_len ; if ( seg_len < smallest_block ) smallest_block = seg_len ; if ( seg_len > largest_block ) largest_block = seg_len ; if ( is_root && ! used ) bad_root_block = 1 ; if ( used ) { used_blocks ++ ; used_size += seg_len ; if ( is_root && ( block -> id [ 0 ] != 'n' || block -> id [ 1 ] != 'k' ) ) bad_root_block = 1 ; BITMAP_SET ( h -> bitmap , blkoff ) ; } } } if ( ! seen_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>no<S2SV_blank>root<S2SV_blank>block<S2SV_blank>found"" , filename ) ; goto error ; } if ( bad_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>bad<S2SV_blank>root<S2SV_blank>block<S2SV_blank>(free<S2SV_blank>or<S2SV_blank>not<S2SV_blank>nk)"" , filename ) ; goto error ; } DEBUG ( 1 , ""successfully<S2SV_blank>read<S2SV_blank>Windows<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file:\\n"" ""<S2SV_blank><S2SV_blank>pages:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>avg:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu\\n"" ""<S2SV_blank><S2SV_blank>bytes<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu"" , pages , smallest_page , largest_page , blocks , smallest_block , blocks_bytes / blocks , largest_block , used_blocks , used_size ) ; return h ; error : ; int err = errno ; if ( h ) { free ( h -> bitmap ) ; if ( h -> addr && h -> size && h -> addr != MAP_FAILED ) { if ( ! h -> writable ) munmap ( h -> addr , h -> size ) ; else free ( h -> addr ) ; } if ( h -> fd >= 0 ) close ( h -> fd ) ; free ( h -> filename ) ; free ( h ) ; } errno = err ; return NULL ; }
","<S2SV_ModStart> . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; }
",libguestfs@hivex/357f26fa64fd1d9ccac2331fe174a8ee9c607adb,CVE-2014-9273,https://github.com/libguestfs/hivex/commit/357f26fa64fd1d9ccac2331fe174a8ee9c607adb,2014-12-08T16:59Z,<S2SV_StartBug> h -> size = statbuf . st_size ; <S2SV_EndBug>
1817,CWE-119,"<S2SV_StartBug> int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) { <S2SV_EndBug> int start_index = rc -> worst_quality ; int target_index = rc -> worst_quality ; int i ; for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { start_index = i ; <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qstart ) <S2SV_EndBug> break ; } for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { target_index = i ; <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qtarget ) <S2SV_EndBug> break ; } return target_index - start_index ; }
","<S2SV_ModStart> , double qtarget , vpx_bit_depth_t bit_depth <S2SV_ModStart> vp9_convert_qindex_to_q ( i , bit_depth <S2SV_ModStart> vp9_convert_qindex_to_q ( i , bit_depth
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qstart ) <S2SV_EndBug> <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qtarget ) <S2SV_EndBug>"
2470,CWE-125,"static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) iris_info . name ) ; iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; ( void ) count ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; } <S2SV_StartBug> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <S2SV_EndBug> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> } if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if (
",ImageMagick@ImageMagick/7afcf9f71043df15508e46f079387bd4689a738d,CVE-2016-7101,https://github.com/ImageMagick/ImageMagick/commit/7afcf9f71043df15508e46f079387bd4689a738d,2017-01-18T17:59Z,<S2SV_StartBug> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <S2SV_EndBug>
689,CWE-189,"Pairs * hstoreArrayToPairs ( ArrayType * a , int * npairs ) { Datum * key_datums ; bool * key_nulls ; int key_count ; Pairs * key_pairs ; int bufsiz ; int i , j ; deconstruct_array ( a , TEXTOID , - 1 , false , 'i' , & key_datums , & key_nulls , & key_count ) ; if ( key_count == 0 ) { * npairs = 0 ; return NULL ; } <S2SV_StartBug> key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ; <S2SV_EndBug> for ( i = 0 , j = 0 ; i < key_count ; i ++ ) { if ( ! key_nulls [ i ] ) { key_pairs [ j ] . key = VARDATA ( key_datums [ i ] ) ; key_pairs [ j ] . keylen = VARSIZE ( key_datums [ i ] ) - VARHDRSZ ; key_pairs [ j ] . val = NULL ; key_pairs [ j ] . vallen = 0 ; key_pairs [ j ] . needfree = 0 ; key_pairs [ j ] . isnull = 1 ; j ++ ; } } * npairs = hstoreUniquePairs ( key_pairs , j , & bufsiz ) ; return key_pairs ; }
","<S2SV_ModStart> NULL ; } if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,<S2SV_StartBug> key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ; <S2SV_EndBug>
1156,CWE-119,"RD_BOOL cssp_read_tsrequest ( STREAM token , STREAM pubkey ) { STREAM s ; int length ; int tagval ; <S2SV_StartBug> s = tcp_recv ( NULL , 4 ) ; <S2SV_EndBug> if ( s == NULL ) return False ; if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) { logger ( Protocol , Error , ""cssp_read_tsrequest(),<S2SV_blank>expected<S2SV_blank>BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED,<S2SV_blank>got<S2SV_blank>%x"" , s -> p [ 0 ] ) ; return False ; } if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ; else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ; else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ; else return False ; s = tcp_recv ( s , length ) ; <S2SV_StartBug> if ( ! ber_in_header ( s , & tagval , & length ) || <S2SV_EndBug> tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; <S2SV_StartBug> in_uint8s ( s , length ) ; <S2SV_EndBug> if ( token ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; <S2SV_StartBug> token -> end = token -> p = token -> data ; <S2SV_EndBug> out_uint8p ( token , s -> p , length ) ; s_mark_end ( token ) ; } if ( pubkey ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; pubkey -> data = pubkey -> p = s -> p ; pubkey -> end = pubkey -> data + length ; pubkey -> size = length ; } return True ; }
","<S2SV_ModStart> int tagval ; struct stream packet ; <S2SV_ModStart> length ) ; packet = * s ; <S2SV_ModStart> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>version<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <S2SV_ModEnd> ; out_uint8p (
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-20182,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-03-15T18:29Z,"<S2SV_StartBug> s = tcp_recv ( NULL , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ber_in_header ( s , & tagval , & length ) || <S2SV_EndBug> <S2SV_StartBug> in_uint8s ( s , length ) ; <S2SV_EndBug> <S2SV_StartBug> token -> end = token -> p = token -> data ; <S2SV_EndBug>"
3720,CWE-362,"static int ext4_split_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_map_blocks * map , int split_flag , int flags ) { ext4_lblk_t ee_block ; struct ext4_extent * ex ; unsigned int ee_len , depth ; int err = 0 ; int uninitialized ; int split_flag1 , flags1 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; uninitialized = ext4_ext_is_uninitialized ( ex ) ; if ( map -> m_lblk + map -> m_len < ee_block + ee_len ) { <S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> EXT4_EXT_MAY_ZEROOUT : 0 ; flags1 = flags | EXT4_GET_BLOCKS_PRE_IO ; if ( uninitialized ) split_flag1 |= EXT4_EXT_MARK_UNINIT1 | EXT4_EXT_MARK_UNINIT2 ; <S2SV_StartBug> err = ext4_split_extent_at ( handle , inode , path , <S2SV_EndBug> map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ; if ( err ) goto out ; } ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) return PTR_ERR ( path ) ; if ( map -> m_lblk >= ee_block ) { <S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> EXT4_EXT_MAY_ZEROOUT : 0 ; if ( uninitialized ) split_flag1 |= EXT4_EXT_MARK_UNINIT1 ; if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) split_flag1 |= EXT4_EXT_MARK_UNINIT2 ; err = ext4_split_extent_at ( handle , inode , path , map -> m_lblk , split_flag1 , flags ) ; if ( err ) goto out ; } ext4_ext_show_leaf ( inode , path ) ; out : return err ? err : map -> m_len ; }
","<S2SV_ModStart> split_flag & EXT4_EXT_MAY_ZEROOUT <S2SV_ModEnd> ; flags1 = <S2SV_ModStart> | EXT4_EXT_MARK_UNINIT2 ; if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ; <S2SV_ModStart> = split_flag & ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) <S2SV_ModEnd> ; if (
",torvalds@linux/dee1f973ca341c266229faa5a1a5bb268bed3531,CVE-2012-4508,https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531,2012-12-21T11:47Z,"<S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> <S2SV_StartBug> err = ext4_split_extent_at ( handle , inode , path , <S2SV_EndBug> <S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug>"
284,CWE-416,"static ssize_t bsg_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos ) { struct bsg_device * bd = file -> private_data ; ssize_t bytes_written ; int ret ; <S2SV_StartBug> dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n"" , bd -> name , count ) ; <S2SV_EndBug> bsg_set_block ( bd , file ) ; bytes_written = 0 ; ret = __bsg_write ( bd , buf , count , & bytes_written , file -> f_mode & FMODE_WRITE ) ; * ppos = bytes_written ; if ( ! bytes_written || err_block_err ( ret ) ) bytes_written = ret ; dprintk ( ""%s:<S2SV_blank>returning<S2SV_blank>%Zd\\n"" , bd -> name , bytes_written ) ; return bytes_written ; }
","<S2SV_ModStart> , count ) ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL
",torvalds@linux/128394eff343fc6d2f32172f03e24829539c5835,CVE-2016-10088,https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835,2016-12-30T18:59Z,"<S2SV_StartBug> dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n"" , bd -> name , count ) ; <S2SV_EndBug>"
2754,CWE-000,"static Curves16Data * CurvesAlloc ( cmsContext ContextID , int nCurves , int nElements , cmsToneCurve * * G ) { int i , j ; Curves16Data * c16 ; c16 = _cmsMallocZero ( ContextID , sizeof ( Curves16Data ) ) ; if ( c16 == NULL ) return NULL ; c16 -> nCurves = nCurves ; c16 -> nElements = nElements ; c16 -> Curves = _cmsCalloc ( ContextID , nCurves , sizeof ( cmsUInt16Number * ) ) ; if ( c16 -> Curves == NULL ) return NULL ; for ( i = 0 ; i < nCurves ; i ++ ) { <S2SV_StartBug> c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ; <S2SV_EndBug> if ( nElements == 256 ) { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , FROM_8_TO_16 ( j ) ) ; } } else { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , ( cmsUInt16Number ) j ) ; } } } return c16 ; }
","<S2SV_ModStart> ) ) ; if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; }
",mm2@Little-CMS/91c2db7f2559be504211b283bc3a2c631d6f06d9,CVE-2013-4160,https://github.com/mm2/Little-CMS/commit/91c2db7f2559be504211b283bc3a2c631d6f06d9,2014-01-21T18:55Z,"<S2SV_StartBug> c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ; <S2SV_EndBug>"
1257,CWE-264,"static void bond_setup ( struct net_device * bond_dev ) { struct bonding * bond = netdev_priv ( bond_dev ) ; rwlock_init ( & bond -> lock ) ; rwlock_init ( & bond -> curr_slave_lock ) ; bond -> params = bonding_defaults ; bond -> dev = bond_dev ; INIT_LIST_HEAD ( & bond -> vlan_list ) ; ether_setup ( bond_dev ) ; bond_dev -> netdev_ops = & bond_netdev_ops ; bond_dev -> ethtool_ops = & bond_ethtool_ops ; bond_set_mode_ops ( bond , bond -> params . mode ) ; bond_dev -> destructor = bond_destructor ; bond_dev -> tx_queue_len = 0 ; bond_dev -> flags |= IFF_MASTER | IFF_MULTICAST ; bond_dev -> priv_flags |= IFF_BONDING ; <S2SV_StartBug> bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> bond_dev -> features |= NETIF_F_VLAN_CHALLENGED ; bond_dev -> features |= NETIF_F_LLTX ; bond_dev -> hw_features = BOND_VLAN_FEATURES | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER ; bond_dev -> hw_features &= ~ ( NETIF_F_ALL_CSUM & ~ NETIF_F_NO_CSUM ) ; bond_dev -> features |= bond_dev -> hw_features ; }
","<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; bond_dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,<S2SV_StartBug> bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug>
1424,CWE-119,"void vp8_optimize_mby ( MACROBLOCK * x ) { int b ; int type ; int has_2nd_order ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; if ( ! x -> e_mbd . above_context ) return ; if ( ! x -> e_mbd . left_context ) return ; <S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; has_2nd_order = ( x -> e_mbd . mode_info_context -> mbmi . mode != B_PRED && x -> e_mbd . mode_info_context -> mbmi . mode != SPLITMV ) ; type = has_2nd_order ? PLANE_TYPE_Y_NO_DC : PLANE_TYPE_Y_WITH_DC ; for ( b = 0 ; b < 16 ; b ++ ) { optimize_b ( x , b , type , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } if ( has_2nd_order ) { b = 24 ; optimize_b ( x , b , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; check_reset_2nd_coeffs ( & x -> e_mbd , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } }
","<S2SV_ModStart> ) return ; memcpy <S2SV_ModEnd> ( & t_above <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & t_left
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug>"
652,CWE-200,"<S2SV_StartBug> static bool tailmatch ( const char * little , const char * bigone ) <S2SV_EndBug> { <S2SV_StartBug> size_t littlelen = strlen ( little ) ; <S2SV_EndBug> <S2SV_StartBug> size_t biglen = strlen ( bigone ) ; <S2SV_EndBug> <S2SV_StartBug> if ( littlelen > biglen ) <S2SV_EndBug> return FALSE ; <S2SV_StartBug> return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ; <S2SV_EndBug> }
","<S2SV_ModStart> const char * cooke_domain <S2SV_ModEnd> , const char <S2SV_ModStart> const char * hostname <S2SV_ModEnd> ) { size_t <S2SV_ModStart> ) { size_t cookie_domain_len <S2SV_ModEnd> = strlen ( <S2SV_ModStart> = strlen ( cooke_domain <S2SV_ModEnd> ) ; size_t <S2SV_ModStart> ) ; size_t hostname_len <S2SV_ModEnd> = strlen ( <S2SV_ModStart> = strlen ( hostname <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( hostname_len < cookie_domain_len <S2SV_ModEnd> ) return FALSE <S2SV_ModStart> return FALSE ; if ( ! Curl_raw_equal ( cooke_domain , hostname + hostname_len - cookie_domain_len ) ) return FALSE ; if ( hostname_len == cookie_domain_len ) return TRUE ; if ( '.' == * ( hostname + hostname_len - cookie_domain_len - 1 ) ) return TRUE ; return <S2SV_ModEnd> FALSE ; }
",bagder@curl/2eb8dcf26cb37f09cffe26909a646e702dbcab66,CVE-2013-1944,https://github.com/bagder/curl/commit/2eb8dcf26cb37f09cffe26909a646e702dbcab66,2013-04-29T22:55Z,"<S2SV_StartBug> static bool tailmatch ( const char * little , const char * bigone ) <S2SV_EndBug> <S2SV_StartBug> size_t littlelen = strlen ( little ) ; <S2SV_EndBug> <S2SV_StartBug> size_t biglen = strlen ( bigone ) ; <S2SV_EndBug> <S2SV_StartBug> if ( littlelen > biglen ) <S2SV_EndBug> <S2SV_StartBug> return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ; <S2SV_EndBug>"
6530,CWE-119,"cJSON * cJSON_CreateTrue ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_True ; return item ; }
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,
3760,CWE-20,"static void mpeg4_encode_gop_header ( MpegEncContext * s ) { <S2SV_StartBug> int hours , minutes , seconds ; <S2SV_EndBug> int64_t time ; put_bits ( & s -> pb , 16 , 0 ) ; put_bits ( & s -> pb , 16 , GOP_STARTCODE ) ; time = s -> current_picture_ptr -> f -> pts ; if ( s -> reordered_input_picture [ 1 ] ) time = FFMIN ( time , s -> reordered_input_picture [ 1 ] -> f -> pts ) ; time = time * s -> avctx -> time_base . num ; s -> last_time_base = FFUDIV ( time , s -> avctx -> time_base . den ) ; seconds = FFUDIV ( time , s -> avctx -> time_base . den ) ; minutes = FFUDIV ( seconds , 60 ) ; seconds = FFUMOD ( seconds , 60 ) ; hours = FFUDIV ( minutes , 60 ) ; minutes = FFUMOD ( minutes , 60 ) ; hours = FFUMOD ( hours , 24 ) ; put_bits ( & s -> pb , 5 , hours ) ; put_bits ( & s -> pb , 6 , minutes ) ; put_bits ( & s -> pb , 1 , 1 ) ; put_bits ( & s -> pb , 6 , seconds ) ; put_bits ( & s -> pb , 1 , ! ! ( s -> avctx -> flags & AV_CODEC_FLAG_CLOSED_GOP ) ) ; put_bits ( & s -> pb , 1 , 0 ) ; ff_mpeg4_stuffing ( & s -> pb ) ; }
","<S2SV_ModStart> s ) { int64_t <S2SV_ModEnd> hours , minutes
",FFmpeg@FFmpeg/e1182fac1afba92a4975917823a5f644bee7e6e8,CVE-2018-12458,https://github.com/FFmpeg/FFmpeg/commit/e1182fac1afba92a4975917823a5f644bee7e6e8,2018-06-15T15:29Z,"<S2SV_StartBug> int hours , minutes , seconds ; <S2SV_EndBug>"
1198,CWE-190,"static void addArgumentToVtab ( Parse * pParse ) { if ( pParse -> sArg . z && pParse -> pNewTable ) { const char * z = ( const char * ) pParse -> sArg . z ; int n = pParse -> sArg . n ; sqlite3 * db = pParse -> db ; <S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pParse ->
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z,"<S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug>"
2817,CWE-119,"static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ; uint32 strip , nstrips = TIFFNumberOfStrips ( in ) ; uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( """" , ""TIFF<S2SV_blank>scanline<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero!"" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( """" , ""Strip<S2SV_blank>%d:<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes,<S2SV_blank>strip<S2SV_blank>size<S2SV_blank>%lu"" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( """" , ""Error<S2SV_blank>reading<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>after<S2SV_blank>%lu<S2SV_blank>rows"" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } <S2SV_StartBug> bufp += bytes_read ; <S2SV_EndBug> } return 1 ; }
","<S2SV_ModStart> } bufp += stripsize <S2SV_ModEnd> ; } return
",vadz@libtiff/9657bbe3cdce4aaa90e07d50c1c70ae52da0ba6a,CVE-2016-10272,https://github.com/vadz/libtiff/commit/9657bbe3cdce4aaa90e07d50c1c70ae52da0ba6a,2017-03-24T19:59Z,<S2SV_StartBug> bufp += bytes_read ; <S2SV_EndBug>
1042,CWE-284,"void btsnoop_net_write ( const void * data , size_t length ) { # if ( ! defined ( BT_NET_DEBUG ) || ( BT_NET_DEBUG != TRUE ) ) return ; # endif pthread_mutex_lock ( & client_socket_lock_ ) ; if ( client_socket_ != - 1 ) { <S2SV_StartBug> if ( send ( client_socket_ , data , length , 0 ) == - 1 && errno == ECONNRESET ) { <S2SV_EndBug> safe_close_ ( & client_socket_ ) ; } } pthread_mutex_unlock ( & client_socket_lock_ ) ; }
","<S2SV_ModStart> { if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> length , 0 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> if ( send ( client_socket_ , data , length , 0 ) == - 1 && errno == ECONNRESET ) { <S2SV_EndBug>"
118,CWE-285,"int __gfs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; int len ; char * data ; const char * name = gfs2_acl_name ( type ) ; if ( acl && acl -> a_count > GFS2_ACL_MAX_ENTRIES ( GFS2_SB ( inode ) ) ) return - E2BIG ; if ( type == ACL_TYPE_ACCESS ) { umode_t mode = inode -> i_mode ; <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; if ( error == 0 ) acl = NULL ; <S2SV_StartBug> if ( mode != inode -> i_mode ) { <S2SV_EndBug> inode -> i_mode = mode ; mark_inode_dirty ( inode ) ; <S2SV_StartBug> } <S2SV_EndBug> } if ( acl ) { len = posix_acl_to_xattr ( & init_user_ns , acl , NULL , 0 ) ; if ( len == 0 ) return 0 ; data = kmalloc ( len , GFP_NOFS ) ; if ( data == NULL ) return - ENOMEM ; error = posix_acl_to_xattr ( & init_user_ns , acl , data , len ) ; if ( error < 0 ) goto out ; } else { data = NULL ; len = 0 ; } error = __gfs2_xattr_set ( inode , name , data , len , 0 , GFS2_EATYPE_SYS ) ; if ( error ) goto out ; set_cached_acl ( inode , type , acl ) ; out : kfree ( data ) ; return error ; }
","<S2SV_ModStart> ; error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> i_mode ) <S2SV_ModEnd> mark_inode_dirty ( inode <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } if (
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mode != inode -> i_mode ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
447,CWE-476,"static int mailimf_group_parse ( const char * message , size_t length , size_t * indx , struct mailimf_group * * result ) { size_t cur_token ; char * display_name ; struct mailimf_mailbox_list * mailbox_list ; struct mailimf_group * group ; int r ; int res ; <S2SV_StartBug> cur_token = * indx ; <S2SV_EndBug> mailbox_list = NULL ; r = mailimf_display_name_parse ( message , length , & cur_token , & display_name ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto err ; } r = mailimf_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_display_name ; } r = mailimf_mailbox_list_parse ( message , length , & cur_token , & mailbox_list ) ; switch ( r ) { case MAILIMF_NO_ERROR : break ; case MAILIMF_ERROR_PARSE : r = mailimf_cfws_parse ( message , length , & cur_token ) ; if ( ( r != MAILIMF_NO_ERROR ) && ( r != MAILIMF_ERROR_PARSE ) ) { <S2SV_StartBug> res = r ; <S2SV_EndBug> goto free_display_name ; } break ; default : res = r ; goto free_display_name ; } r = mailimf_semi_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_mailbox_list ; } group = mailimf_group_new ( display_name , mailbox_list ) ; if ( group == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_mailbox_list ; } * indx = cur_token ; * result = group ; return MAILIMF_NO_ERROR ; free_mailbox_list : if ( mailbox_list != NULL ) { mailimf_mailbox_list_free ( mailbox_list ) ; } free_display_name : mailimf_display_name_free ( display_name ) ; err : return res ; }
","<S2SV_ModStart> int res ; clist * list ; <S2SV_ModStart> res = r ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list )
",dinhviethoa@libetpan/1fe8fbc032ccda1db9af66d93016b49c16c1f22d,CVE-2017-8825,https://github.com/dinhviethoa/libetpan/commit/1fe8fbc032ccda1db9af66d93016b49c16c1f22d,2017-05-08T16:29Z,<S2SV_StartBug> cur_token = * indx ; <S2SV_EndBug> <S2SV_StartBug> res = r ; <S2SV_EndBug>
2961,CWE-399,"int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = X86EMUL_CONTINUE ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = OP_NONE ; ctxt -> memopp = NULL ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; } switch ( mode ) { case X86EMUL_MODE_REAL : case X86EMUL_MODE_VM86 : case X86EMUL_MODE_PROT16 : def_op_bytes = def_ad_bytes = 2 ; break ; case X86EMUL_MODE_PROT32 : def_op_bytes = def_ad_bytes = 4 ; break ; # ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ; # endif default : return EMULATION_FAILED ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> ad_bytes = def_ad_bytes ^ 12 ; else ctxt -> ad_bytes = def_ad_bytes ^ 6 ; break ; case 0x26 : case 0x2e : case 0x36 : case 0x3e : has_seg_override = true ; ctxt -> seg_override = ( ctxt -> b >> 3 ) & 3 ; break ; case 0x64 : case 0x65 : has_seg_override = true ; ctxt -> seg_override = ctxt -> b & 7 ; break ; case 0x40 ... 0x4f : if ( mode != X86EMUL_MODE_PROT64 ) goto done_prefixes ; ctxt -> rex_prefix = ctxt -> b ; continue ; case 0xf0 : ctxt -> lock_prefix = 1 ; break ; case 0xf2 : case 0xf3 : ctxt -> rep_prefix = ctxt -> b ; break ; default : goto done_prefixes ; } ctxt -> rex_prefix = 0 ; } done_prefixes : if ( ctxt -> rex_prefix & 8 ) ctxt -> op_bytes = 8 ; opcode = opcode_table [ ctxt -> b ] ; if ( ctxt -> b == 0x0f ) { ctxt -> opcode_len = 2 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = twobyte_table [ ctxt -> b ] ; if ( ctxt -> b == 0x38 ) { ctxt -> opcode_len = 3 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = opcode_map_0f_38 [ ctxt -> b ] ; } } ctxt -> d = opcode . flags ; if ( ctxt -> d & ModRM ) ctxt -> modrm = insn_fetch ( u8 , ctxt ) ; if ( ctxt -> opcode_len == 1 && ( ctxt -> b == 0xc5 || ctxt -> b == 0xc4 ) && ( mode == X86EMUL_MODE_PROT64 || ( mode >= X86EMUL_MODE_PROT16 && ( ctxt -> modrm & 0x80 ) ) ) ) { ctxt -> d = NotImpl ; } while ( ctxt -> d & GroupMask ) { switch ( ctxt -> d & GroupMask ) { case Group : goffset = ( ctxt -> modrm >> 3 ) & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case GroupDual : goffset = ( ctxt -> modrm >> 3 ) & 7 ; if ( ( ctxt -> modrm >> 6 ) == 3 ) opcode = opcode . u . gdual -> mod3 [ goffset ] ; else opcode = opcode . u . gdual -> mod012 [ goffset ] ; break ; case RMExt : goffset = ctxt -> modrm & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case Prefix : if ( ctxt -> rep_prefix && op_prefix ) return EMULATION_FAILED ; simd_prefix = op_prefix ? 0x66 : ctxt -> rep_prefix ; switch ( simd_prefix ) { case 0x00 : opcode = opcode . u . gprefix -> pfx_no ; break ; case 0x66 : opcode = opcode . u . gprefix -> pfx_66 ; break ; case 0xf2 : opcode = opcode . u . gprefix -> pfx_f2 ; break ; case 0xf3 : opcode = opcode . u . gprefix -> pfx_f3 ; break ; } break ; case Escape : if ( ctxt -> modrm > 0xbf ) opcode = opcode . u . esc -> high [ ctxt -> modrm - 0xc0 ] ; else opcode = opcode . u . esc -> op [ ( ctxt -> modrm >> 3 ) & 7 ] ; break ; default : return EMULATION_FAILED ; } ctxt -> d &= ~ ( u64 ) GroupMask ; ctxt -> d |= opcode . flags ; } if ( ctxt -> d == 0 ) return EMULATION_FAILED ; ctxt -> execute = opcode . u . execute ; if ( unlikely ( ctxt -> ud ) && likely ( ! ( ctxt -> d & EmulateOnUD ) ) ) return EMULATION_FAILED ; if ( unlikely ( ctxt -> d & ( NotImpl | Stack | Op3264 | Sse | Mmx | Intercept | CheckPerm ) ) ) { ctxt -> check_perm = opcode . check_perm ; ctxt -> intercept = opcode . intercept ; if ( ctxt -> d & NotImpl ) return EMULATION_FAILED ; if ( mode == X86EMUL_MODE_PROT64 && ( ctxt -> d & Stack ) ) ctxt -> op_bytes = 8 ; if ( ctxt -> d & Op3264 ) { if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> op_bytes = 8 ; else ctxt -> op_bytes = 4 ; } if ( ctxt -> d & Sse ) ctxt -> op_bytes = 16 ; else if ( ctxt -> d & Mmx ) ctxt -> op_bytes = 8 ; } if ( ctxt -> d & ModRM ) { rc = decode_modrm ( ctxt , & ctxt -> memop ) ; if ( ! has_seg_override ) { has_seg_override = true ; ctxt -> seg_override = ctxt -> modrm_seg ; } } else if ( ctxt -> d & MemAbs ) rc = decode_abs ( ctxt , & ctxt -> memop ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; if ( ! has_seg_override ) ctxt -> seg_override = VCPU_SREG_DS ; ctxt -> memop . addr . mem . seg = ctxt -> seg_override ; rc = decode_operand ( ctxt , & ctxt -> src , ( ctxt -> d >> SrcShift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> Src2Shift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ; <S2SV_StartBug> done : <S2SV_EndBug> if ( ctxt -> rip_relative ) <S2SV_StartBug> ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; <S2SV_EndBug> return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ; }
","<S2SV_ModStart> OpMask ) ; <S2SV_ModEnd> if ( ctxt <S2SV_ModStart> -> _eip ; done :
",torvalds@linux/a430c9166312e1aa3d80bce32374233bdbfeba32,CVE-2014-8481,https://github.com/torvalds/linux/commit/a430c9166312e1aa3d80bce32374233bdbfeba32,2014-11-10T11:55Z,<S2SV_StartBug> done : <S2SV_EndBug> <S2SV_StartBug> ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; <S2SV_EndBug>
1579,CWE-119,"void vp9_rtcd ( ) { <S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> once ( setup_rtcd_internal ) ; }
","<S2SV_ModStart> ( ) { <S2SV_ModEnd> once ( setup_rtcd_internal
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug>
2081,CWE-125,"static int cfm_network_addr_print ( netdissect_options * ndo , <S2SV_StartBug> register const u_char * tptr ) <S2SV_EndBug> { u_int network_addr_type ; <S2SV_StartBug> u_int hexdump = FALSE ; <S2SV_EndBug> network_addr_type = * tptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown"" , network_addr_type ) , network_addr_type ) ) ; switch ( network_addr_type ) { case AFNUM_INET : <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> break ; case AFNUM_INET6 : <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> break ; default : hexdump = TRUE ; break ; } return hexdump ; }
","<S2SV_ModStart> u_char * tptr , const u_int length ) { u_int network_addr_type ; u_int <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> = FALSE ; if ( length < 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data"" ) ) ; return hexdump ; } <S2SV_ModStart> case AFNUM_INET : if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET6 : if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; }
",the-tcpdump-group@tcpdump/5d340a5ca6e420a70297cdbdf777333f18bfdab7,CVE-2017-13052,https://github.com/the-tcpdump-group/tcpdump/commit/5d340a5ca6e420a70297cdbdf777333f18bfdab7,2017-09-14T06:29Z,"<S2SV_StartBug> register const u_char * tptr ) <S2SV_EndBug> <S2SV_StartBug> u_int hexdump = FALSE ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug>"
4004,CWE-20,"static int pfkey_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct pfkey_sock * pfk = pfkey_sk ( sk ) ; struct sk_buff * skb ; int copied , err ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT ) ) goto out ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; err = ( flags & MSG_TRUNC ) ? skb -> len : copied ; if ( pfk -> dump . dump != NULL && 3 * atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf ) pfkey_do_dump ( pfk ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }
","<S2SV_ModStart> goto out ; <S2SV_ModEnd> skb = skb_recv_datagram
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug>
509,CWE-125,"int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ; unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> * nexthdr = & exthdr -> nexthdr ; <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug> offset ) ; } return offset ; }
","<S2SV_ModStart> ( struct ipv6hdr <S2SV_ModEnd> ) ; unsigned <S2SV_ModStart> while ( offset <S2SV_ModEnd> <= packet_len ) <S2SV_ModStart> packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> -> nexthdr ; } return - EINVAL <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z,<S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug>
241,CWE-189,"MagickExport const char * GetMagickFeatures ( void ) { return ""DPC"" <S2SV_StartBug> # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) <S2SV_EndBug> ""<S2SV_blank>Modules"" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) <S2SV_StartBug> ""<S2SV_blank>HDRI"" <S2SV_EndBug> # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) ""<S2SV_blank>OpenCL"" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) ""<S2SV_blank>OpenMP"" # endif <S2SV_StartBug> ; <S2SV_EndBug> }
","<S2SV_ModStart> if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) ""<S2SV_blank>Debug"" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) ""<S2SV_blank>Cipher"" <S2SV_ModEnd> # endif # <S2SV_ModStart> MAGICKCORE_HDRI_SUPPORT ) ""<S2SV_blank>HDRI"" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) ""<S2SV_blank>Modules"" <S2SV_ModStart> ""<S2SV_blank>OpenMP"" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) ""<S2SV_blank>Zero-configuration"" # endif
",ImageMagick@ImageMagick/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,CVE-2015-8896,https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,2017-03-15T19:59Z,"<S2SV_StartBug> # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) <S2SV_EndBug> <S2SV_StartBug> ""<S2SV_blank>HDRI"" <S2SV_EndBug> <S2SV_StartBug> ; <S2SV_EndBug>"
6940,CWE-400,"static void perf_event_read_event ( struct perf_event * event , struct task_struct * task ) { struct perf_output_handle handle ; struct perf_sample_data sample ; struct perf_read_event read_event = { . header = { . type = PERF_RECORD_READ , . misc = 0 , . size = sizeof ( read_event ) + event -> read_size , } , . pid = perf_event_pid ( event , task ) , . tid = perf_event_tid ( event , task ) , } ; int ret ; perf_event_header__init_id ( & read_event . header , & sample , event ) ; <S2SV_StartBug> ret = perf_output_begin ( & handle , event , read_event . header . size , 0 , 0 ) ; <S2SV_EndBug> if ( ret ) return ; perf_output_put ( & handle , read_event ) ; perf_output_read ( & handle , event ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; }
","<S2SV_ModStart> size , 0 <S2SV_ModEnd> ) ; if
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> ret = perf_output_begin ( & handle , event , read_event . header . size , 0 , 0 ) ; <S2SV_EndBug>"
2573,CWE-000,"OM_uint32 kg_seal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int conf_req_flag , gss_qop_t qop_req , int * conf_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; krb5_error_code code ; krb5_context context ; if ( qop_req != 0 ) { * minor_status = ( OM_uint32 ) G_UNKNOWN_QOP ; return GSS_S_FAILURE ; } ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( conf_req_flag && kg_integ_only_iov ( iov , iov_count ) ) { conf_req_flag = FALSE ; } context = ctx -> k5_context ; switch ( ctx -> proto ) { case 0 : code = make_seal_token_v1_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; case 1 : code = gss_krb5int_make_seal_token_v3_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; default : code = G_UNKNOWN_QOP ; break ; } if ( code != 0 ) { * minor_status = code ; save_error_info ( * minor_status , context ) ; return GSS_S_FAILURE ; } * minor_status = 0 ; return GSS_S_COMPLETE ; }
","<S2SV_ModStart> ; if ( ctx -> terminated ||
",krb5@krb5/82dc33da50338ac84c7b4102dc6513d897d0506a,CVE-2014-5352,https://github.com/krb5/krb5/commit/82dc33da50338ac84c7b4102dc6513d897d0506a,2015-02-19T11:59Z,<S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug>
3756,CWE-200,"static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { bool disconnect ; p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; <S2SV_StartBug> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_EndBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } change_mnt_propagation ( p , MS_PRIVATE ) ; } }
","<S2SV_ModStart> disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || <S2SV_ModStart> IS_MNT_LOCKED_AND_LAZY ( p )
",torvalds@linux/e0c9c0afd2fc958ffa34b697972721d81df8a56f,CVE-2015-4176,https://github.com/torvalds/linux/commit/e0c9c0afd2fc958ffa34b697972721d81df8a56f,2016-05-02T10:59Z,<S2SV_StartBug> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_EndBug>
7382,CWE-401,"static int mlx5_fw_fatal_reporter_dump ( struct devlink_health_reporter * reporter , struct devlink_fmsg * fmsg , void * priv_ctx ) { struct mlx5_core_dev * dev = devlink_health_reporter_priv ( reporter ) ; u32 crdump_size = dev -> priv . health . crdump_size ; u32 * cr_data ; u32 data_size ; u32 offset ; int err ; if ( ! mlx5_core_is_pf ( dev ) ) return - EPERM ; cr_data = kvmalloc ( crdump_size , GFP_KERNEL ) ; if ( ! cr_data ) return - ENOMEM ; err = mlx5_crdump_collect ( dev , cr_data ) ; if ( err ) <S2SV_StartBug> return err ; <S2SV_EndBug> if ( priv_ctx ) { struct mlx5_fw_reporter_ctx * fw_reporter_ctx = priv_ctx ; err = mlx5_fw_reporter_ctx_pairs_put ( fmsg , fw_reporter_ctx ) ; if ( err ) goto free_data ; } err = devlink_fmsg_arr_pair_nest_start ( fmsg , ""crdump_data"" ) ; if ( err ) goto free_data ; for ( offset = 0 ; offset < crdump_size ; offset += data_size ) { if ( crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE ) data_size = crdump_size - offset ; else data_size = MLX5_CR_DUMP_CHUNK_SIZE ; err = devlink_fmsg_binary_put ( fmsg , ( char * ) cr_data + offset , data_size ) ; if ( err ) goto free_data ; } err = devlink_fmsg_arr_pair_nest_end ( fmsg ) ; free_data : kvfree ( cr_data ) ; return err ; }
","<S2SV_ModStart> ( err ) goto free_data <S2SV_ModEnd> ; if (
",torvalds@linux/c7ed6d0183d5ea9bc31bcaeeba4070bd62546471,CVE-2019-19047,https://github.com/torvalds/linux/commit/c7ed6d0183d5ea9bc31bcaeeba4070bd62546471,2019-11-18T06:15Z,<S2SV_StartBug> return err ; <S2SV_EndBug>
3137,CWE-119,"static ssize_t bat_socket_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct socket_client * socket_client = file -> private_data ; struct socket_packet * socket_packet ; size_t packet_len ; int error ; if ( ( file -> f_flags & O_NONBLOCK ) && ( socket_client -> queue_len == 0 ) ) return - EAGAIN ; if ( ( ! buf ) || ( count < sizeof ( struct icmp_packet ) ) ) return - EINVAL ; if ( ! access_ok ( VERIFY_WRITE , buf , count ) ) return - EFAULT ; error = wait_event_interruptible ( socket_client -> queue_wait , socket_client -> queue_len ) ; if ( error ) return error ; spin_lock_bh ( & socket_client -> lock ) ; socket_packet = list_first_entry ( & socket_client -> queue_list , struct socket_packet , list ) ; list_del ( & socket_packet -> list ) ; socket_client -> queue_len -- ; spin_unlock_bh ( & socket_client -> lock ) ; <S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> packet_len = socket_packet -> icmp_len ; kfree ( socket_packet ) ; if ( error ) return - EFAULT ; return packet_len ; }
","<S2SV_ModStart> lock ) ; packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> -> icmp_packet , packet_len ) <S2SV_ModEnd> ; kfree (
",torvalds@linux/b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c,CVE-2011-4604,https://github.com/torvalds/linux/commit/b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c,2013-06-07T14:03Z,"<S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug>"
2364,CWE-119,"static SCSIRequest * scsi_new_request ( SCSIDevice * d , uint32_t tag , uint32_t lun , void * hba_private ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , d ) ; SCSIRequest * req ; <S2SV_StartBug> SCSIDiskReq * r ; <S2SV_EndBug> req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ; <S2SV_StartBug> r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_EndBug> r -> iov . iov_base = qemu_blockalign ( s -> bs , SCSI_DMA_BUF_SIZE ) ; return req ; }
","<S2SV_ModStart> * req ; <S2SV_ModEnd> req = scsi_req_alloc <S2SV_ModStart> hba_private ) ; <S2SV_ModEnd> return req ;
",bonzini@qemu/7285477ab11831b1cf56e45878a89170dd06d9b9,CVE-2011-3346,https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9,2014-04-01T06:35Z,"<S2SV_StartBug> SCSIDiskReq * r ; <S2SV_EndBug> <S2SV_StartBug> r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_EndBug>"
5873,CWE-125,"int ImagingPcxDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , Py_ssize_t bytes ) { UINT8 n ; UINT8 * ptr ; <S2SV_StartBug> if ( strcmp ( im -> mode , ""1"" ) == 0 && state -> xsize > state -> bytes * 8 ) { <S2SV_EndBug> state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; <S2SV_StartBug> } else if ( strcmp ( im -> mode , ""P"" ) == 0 && state -> xsize > state -> bytes ) { <S2SV_EndBug> state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } <S2SV_StartBug> ptr = buf ; <S2SV_EndBug> for ( ; ; ) { if ( bytes < 1 ) return ptr - buf ; if ( ( * ptr & 0xC0 ) == 0xC0 ) { if ( bytes < 2 ) return ptr - buf ; n = ptr [ 0 ] & 0x3F ; while ( n > 0 ) { if ( state -> x >= state -> bytes ) { state -> errcode = IMAGING_CODEC_OVERRUN ; break ; } state -> buffer [ state -> x ++ ] = ptr [ 1 ] ; n -- ; } ptr += 2 ; bytes -= 2 ; } else { state -> buffer [ state -> x ++ ] = ptr [ 0 ] ; ptr ++ ; bytes -- ; } if ( state -> x >= state -> bytes ) { if ( state -> bytes % state -> xsize && state -> bytes > state -> xsize ) { int bands = state -> bytes / state -> xsize ; int stride = state -> bytes / bands ; int i ; for ( i = 1 ; i < bands ; i ++ ) { memmove ( & state -> buffer [ i * state -> xsize ] , & state -> buffer [ i * stride ] , state -> xsize ) ; } } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y + state -> yoff ] + state -> xoff * im -> pixelsize , state -> buffer , state -> xsize ) ; state -> x = 0 ; if ( ++ state -> y >= state -> ysize ) { return - 1 ; } } } }
","<S2SV_ModStart> ; if ( ( state -> xsize * state -> bits + 7 ) / 8 <S2SV_ModEnd> > state -> <S2SV_ModStart> state -> bytes <S2SV_ModEnd> ) { state <S2SV_ModStart> 1 ; } ptr = buf ; for ( ; ; ) { if ( bytes < 1 ) return ptr - buf ; if ( ( * ptr & 0xC0 ) == 0xC0 ) { if ( bytes < 2 ) return ptr - buf ; n = ptr [ 0 ] & 0x3F ; while ( n > 0 ) { if ( state -> x >= state -> bytes ) { state -> errcode = IMAGING_CODEC_OVERRUN ; break ; } state -> buffer [ state -> x ++ ] = ptr [ 1 ] ; n -- ; } ptr += 2 ; bytes -= 2 ; } else { state -> buffer [ state -> x ++ ] = ptr [ 0 ] ; ptr ++ ; bytes -- ; } if ( state -> x >= state -> bytes ) { if ( state -> bytes % state -> xsize && state -> bytes > state -> xsize ) { int bands = state -> bytes / state -> xsize ; int stride = state -> bytes / bands ; int i ; for ( i = 1 ; i < bands ; i ++ ) { memmove ( & state -> buffer [ i * state -> xsize ] , & state -> buffer [ i * stride ] , state -> xsize ) ; } } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y + state -> yoff ] + state -> xoff * im -> pixelsize , state -> buffer , state -> xsize ) ; state -> x = 0 ; if ( ++ state -> y >= state -> ysize ) { <S2SV_ModEnd> return - 1 <S2SV_ModStart> 1 ; } <S2SV_ModEnd> } } }
",python-pillow@Pillow/6a83e4324738bb0452fbe8074a995b1c73f08de7,CVE-2020-10378,https://github.com/python-pillow/Pillow/commit/6a83e4324738bb0452fbe8074a995b1c73f08de7,2020-06-25T19:15Z,"<S2SV_StartBug> if ( strcmp ( im -> mode , ""1"" ) == 0 && state -> xsize > state -> bytes * 8 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( im -> mode , ""P"" ) == 0 && state -> xsize > state -> bytes ) { <S2SV_EndBug> <S2SV_StartBug> ptr = buf ; <S2SV_EndBug>"
611,CWE-416,"static struct mm_struct * mm_init ( struct mm_struct * mm , struct task_struct * p , struct user_namespace * user_ns ) { mm -> mmap = NULL ; mm -> mm_rb = RB_ROOT ; mm -> vmacache_seqnum = 0 ; atomic_set ( & mm -> mm_users , 1 ) ; atomic_set ( & mm -> mm_count , 1 ) ; init_rwsem ( & mm -> mmap_sem ) ; INIT_LIST_HEAD ( & mm -> mmlist ) ; mm -> core_state = NULL ; atomic_long_set ( & mm -> nr_ptes , 0 ) ; mm_nr_pmds_init ( mm ) ; mm -> map_count = 0 ; mm -> locked_vm = 0 ; mm -> pinned_vm = 0 ; memset ( & mm -> rss_stat , 0 , sizeof ( mm -> rss_stat ) ) ; spin_lock_init ( & mm -> page_table_lock ) ; mm_init_cpumask ( mm ) ; mm_init_aio ( mm ) ; mm_init_owner ( mm , p ) ; <S2SV_StartBug> mmu_notifier_mm_init ( mm ) ; <S2SV_EndBug> init_tlb_flush_pending ( mm ) ; # if defined ( CONFIG_TRANSPARENT_HUGEPAGE ) && ! USE_SPLIT_PMD_PTLOCKS mm -> pmd_huge_pte = NULL ; # endif if ( current -> mm ) { mm -> flags = current -> mm -> flags & MMF_INIT_MASK ; mm -> def_flags = current -> mm -> def_flags & VM_INIT_DEF_MASK ; } else { mm -> flags = default_dump_filter ; mm -> def_flags = 0 ; } if ( mm_alloc_pgd ( mm ) ) goto fail_nopgd ; if ( init_new_context ( p , mm ) ) goto fail_nocontext ; mm -> user_ns = get_user_ns ( user_ns ) ; return mm ; fail_nocontext : mm_free_pgd ( mm ) ; fail_nopgd : free_mm ( mm ) ; return NULL ; }
","<S2SV_ModStart> p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;
",torvalds@linux/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a,CVE-2017-17052,https://github.com/torvalds/linux/commit/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a,2017-11-29T03:29Z,<S2SV_StartBug> mmu_notifier_mm_init ( mm ) ; <S2SV_EndBug>
285,CWE-416,"static ssize_t sg_write ( struct file * filp , const char __user * buf , size_t count , loff_t * ppos ) { int mxsize , cmd_size , k ; int input_size , blocking ; unsigned char opcode ; Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; struct sg_header old_hdr ; sg_io_hdr_t * hp ; unsigned char cmnd [ SG_MAX_CDB_SIZE ] ; <S2SV_StartBug> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) <S2SV_EndBug> return - ENXIO ; SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sdp , ""sg_write:<S2SV_blank>count=%d\\n"" , ( int ) count ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( ! ( ( filp -> f_flags & O_NONBLOCK ) || scsi_block_when_processing_errors ( sdp -> device ) ) ) return - ENXIO ; if ( ! access_ok ( VERIFY_READ , buf , count ) ) return - EFAULT ; if ( count < SZ_SG_HEADER ) return - EIO ; if ( __copy_from_user ( & old_hdr , buf , SZ_SG_HEADER ) ) return - EFAULT ; blocking = ! ( filp -> f_flags & O_NONBLOCK ) ; if ( old_hdr . reply_len < 0 ) return sg_new_write ( sfp , filp , buf , count , blocking , 0 , 0 , NULL ) ; if ( count < ( SZ_SG_HEADER + 6 ) ) return - EIO ; if ( ! ( srp = sg_add_request ( sfp ) ) ) { SCSI_LOG_TIMEOUT ( 1 , sg_printk ( KERN_INFO , sdp , ""sg_write:<S2SV_blank>queue<S2SV_blank>full\\n"" ) ) ; return - EDOM ; } buf += SZ_SG_HEADER ; __get_user ( opcode , buf ) ; if ( sfp -> next_cmd_len > 0 ) { cmd_size = sfp -> next_cmd_len ; sfp -> next_cmd_len = 0 ; } else { cmd_size = COMMAND_SIZE ( opcode ) ; if ( ( opcode >= 0xc0 ) && old_hdr . twelve_byte ) cmd_size = 12 ; } SCSI_LOG_TIMEOUT ( 4 , sg_printk ( KERN_INFO , sdp , ""sg_write:<S2SV_blank><S2SV_blank><S2SV_blank>scsi<S2SV_blank>opcode=0x%02x,<S2SV_blank>cmd_size=%d\\n"" , ( int ) opcode , cmd_size ) ) ; input_size = count - cmd_size ; mxsize = ( input_size > old_hdr . reply_len ) ? input_size : old_hdr . reply_len ; mxsize -= SZ_SG_HEADER ; input_size -= SZ_SG_HEADER ; if ( input_size < 0 ) { sg_remove_request ( sfp , srp ) ; return - EIO ; } hp = & srp -> header ; hp -> interface_id = '\\0' ; hp -> cmd_len = ( unsigned char ) cmd_size ; hp -> iovec_count = 0 ; hp -> mx_sb_len = 0 ; if ( input_size > 0 ) hp -> dxfer_direction = ( old_hdr . reply_len > SZ_SG_HEADER ) ? SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV ; else hp -> dxfer_direction = ( mxsize > 0 ) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE ; hp -> dxfer_len = mxsize ; if ( ( hp -> dxfer_direction == SG_DXFER_TO_DEV ) || ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) ) hp -> dxferp = ( char __user * ) buf + cmd_size ; else hp -> dxferp = NULL ; hp -> sbp = NULL ; hp -> timeout = old_hdr . reply_len ; hp -> flags = input_size ; hp -> pack_id = old_hdr . pack_id ; hp -> usr_ptr = NULL ; if ( __copy_from_user ( cmnd , buf , cmd_size ) ) return - EFAULT ; if ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) { static char cmd [ TASK_COMM_LEN ] ; if ( strcmp ( current -> comm , cmd ) ) { printk_ratelimited ( KERN_WARNING ""sg_write:<S2SV_blank>data<S2SV_blank>in/out<S2SV_blank>%d/%d<S2SV_blank>bytes<S2SV_blank>"" ""for<S2SV_blank>SCSI<S2SV_blank>command<S2SV_blank>0x%x--<S2SV_blank>guessing<S2SV_blank>"" ""data<S2SV_blank>in;\\n<S2SV_blank><S2SV_blank><S2SV_blank>program<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>setting<S2SV_blank>"" ""count<S2SV_blank>and/or<S2SV_blank>reply_len<S2SV_blank>properly\\n"" , old_hdr . reply_len - ( int ) SZ_SG_HEADER , input_size , ( unsigned int ) cmnd [ 0 ] , current -> comm ) ; strcpy ( cmd , current -> comm ) ; } } k = sg_common_write ( sfp , srp , cmnd , sfp -> timeout , blocking ) ; return ( k < 0 ) ? k : count ; }
","<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if (
",torvalds@linux/128394eff343fc6d2f32172f03e24829539c5835,CVE-2016-10088,https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835,2016-12-30T18:59Z,<S2SV_StartBug> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) <S2SV_EndBug>
2439,CWE-399,"long vhost_dev_ioctl ( struct vhost_dev * d , unsigned int ioctl , void __user * argp ) { struct file * eventfp , * filep = NULL ; struct eventfd_ctx * ctx = NULL ; u64 p ; long r ; int i , fd ; if ( ioctl == VHOST_SET_OWNER ) { r = vhost_dev_set_owner ( d ) ; goto done ; } r = vhost_dev_check_owner ( d ) ; if ( r ) goto done ; switch ( ioctl ) { case VHOST_SET_MEM_TABLE : r = vhost_set_memory ( d , argp ) ; break ; case VHOST_SET_LOG_BASE : if ( copy_from_user ( & p , argp , sizeof p ) ) { r = - EFAULT ; break ; } if ( ( u64 ) ( unsigned long ) p != p ) { r = - EFAULT ; break ; } for ( i = 0 ; i < d -> nvqs ; ++ i ) { struct vhost_virtqueue * vq ; void __user * base = ( void __user * ) ( unsigned long ) p ; vq = d -> vqs [ i ] ; mutex_lock ( & vq -> mutex ) ; if ( vq -> private_data && ! vq_log_access_ok ( vq , base ) ) r = - EFAULT ; else vq -> log_base = base ; mutex_unlock ( & vq -> mutex ) ; } break ; case VHOST_SET_LOG_FD : r = get_user ( fd , ( int __user * ) argp ) ; if ( r < 0 ) break ; eventfp = fd == - 1 ? NULL : eventfd_fget ( fd ) ; if ( IS_ERR ( eventfp ) ) { r = PTR_ERR ( eventfp ) ; break ; } if ( eventfp != d -> log_file ) { filep = d -> log_file ; <S2SV_StartBug> ctx = d -> log_ctx ; <S2SV_EndBug> d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ; } else filep = eventfp ; for ( i = 0 ; i < d -> nvqs ; ++ i ) { mutex_lock ( & d -> vqs [ i ] -> mutex ) ; d -> vqs [ i ] -> log_ctx = d -> log_ctx ; mutex_unlock ( & d -> vqs [ i ] -> mutex ) ; } if ( ctx ) eventfd_ctx_put ( ctx ) ; if ( filep ) fput ( filep ) ; break ; default : r = - ENOIOCTLCMD ; break ; } done : return r ; }
","<S2SV_ModStart> -> log_file ; d -> log_file = eventfp ;
",torvalds@linux/7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5,CVE-2015-6252,https://github.com/torvalds/linux/commit/7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5,2015-10-19T10:59Z,<S2SV_StartBug> ctx = d -> log_ctx ; <S2SV_EndBug>
1660,CWE-119,"<S2SV_StartBug> static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) { <S2SV_EndBug> if ( delta_q != 0 ) { <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta_q < 0 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> write_delta_q ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb , <S2SV_ModStart> 0 ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> 1 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 4 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> } else { vpx_wb_write_bit <S2SV_ModEnd> ( wb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta_q < 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug>"
7616,CWE-190,"<S2SV_StartBug> jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) <S2SV_EndBug> { jas_matrix_t * matrix ; <S2SV_StartBug> int i ; <S2SV_EndBug> size_t size ; matrix = 0 ; if ( numrows < 0 || numcols < 0 ) { goto error ; } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { goto error ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { goto error ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { goto error ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ; }
","<S2SV_ModStart> * jas_matrix_create ( jas_matind_t numrows , jas_matind_t <S2SV_ModEnd> numcols ) { <S2SV_ModStart> * matrix ; jas_matind_t <S2SV_ModEnd> i ; size_t
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,"<S2SV_StartBug> jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug>"
5334,CWE-401,"static int sof_set_get_large_ctrl_data ( struct snd_sof_dev * sdev , struct sof_ipc_ctrl_data * cdata , struct sof_ipc_ctrl_data_params * sparams , bool send ) { struct sof_ipc_ctrl_data * partdata ; size_t send_bytes ; size_t offset = 0 ; size_t msg_bytes ; size_t pl_size ; int err ; int i ; partdata = kzalloc ( SOF_IPC_MSG_MAX_SIZE , GFP_KERNEL ) ; if ( ! partdata ) return - ENOMEM ; if ( send ) err = sof_get_ctrl_copy_params ( cdata -> type , cdata , partdata , sparams ) ; else err = sof_get_ctrl_copy_params ( cdata -> type , partdata , cdata , sparams ) ; <S2SV_StartBug> if ( err < 0 ) <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> msg_bytes = sparams -> msg_bytes ; pl_size = sparams -> pl_size ; memcpy ( partdata , cdata , sparams -> hdr_bytes ) ; mutex_lock ( & sdev -> ipc -> tx_mutex ) ; for ( i = 0 ; i < sparams -> num_msg ; i ++ ) { send_bytes = min ( msg_bytes , pl_size ) ; partdata -> num_elems = send_bytes ; partdata -> rhdr . hdr . size = sparams -> hdr_bytes + send_bytes ; partdata -> msg_index = i ; msg_bytes -= send_bytes ; partdata -> elems_remaining = msg_bytes ; if ( send ) memcpy ( sparams -> dst , sparams -> src + offset , send_bytes ) ; err = sof_ipc_tx_message_unlocked ( sdev -> ipc , partdata -> rhdr . hdr . cmd , partdata , partdata -> rhdr . hdr . size , partdata , partdata -> rhdr . hdr . size ) ; if ( err < 0 ) break ; if ( ! send ) memcpy ( sparams -> dst + offset , sparams -> src , send_bytes ) ; offset += pl_size ; } mutex_unlock ( & sdev -> ipc -> tx_mutex ) ; kfree ( partdata ) ; return err ; }
","<S2SV_ModStart> < 0 ) { kfree ( partdata ) ; <S2SV_ModStart> return err ; }
",torvalds@linux/45c1380358b12bf2d1db20a5874e9544f56b34ab,CVE-2019-18811,https://github.com/torvalds/linux/commit/45c1380358b12bf2d1db20a5874e9544f56b34ab,2019-11-07T16:15Z,<S2SV_StartBug> if ( err < 0 ) <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug>
3027,CWE-399,"int do_fpu_inst ( unsigned short inst , struct pt_regs * regs ) { struct task_struct * tsk = current ; struct sh_fpu_soft_struct * fpu = & ( tsk -> thread . xstate -> softfpu ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> if ( ! ( task_thread_info ( tsk ) -> status & TS_USEDFPU ) ) { fpu_init ( fpu ) ; task_thread_info ( tsk ) -> status |= TS_USEDFPU ; } return fpu_emulate ( inst , fpu , regs ) ; }
","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug>"
1576,CWE-119,"void vp9_setup_pre_planes ( MACROBLOCKD * xd , int idx , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col , const struct scale_factors * sf ) { if ( src != NULL ) { int i ; <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { struct macroblockd_plane * const pd = & xd -> plane [ i ] ; setup_pred_plane ( & pd -> pre [ idx ] , buffers [ i ] , strides [ i ] , mi_row , mi_col , sf , pd -> subsampling_x , pd -> subsampling_y ) ; } } }
","<S2SV_ModStart> const buffers [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> v_buffer <S2SV_ModEnd> } ; const <S2SV_ModStart> int strides [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> uv_stride <S2SV_ModEnd> } ; for
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug>"
194,CWE-119,"static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; <S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
",radare@radare2/0b973e28166636e0ff1fad80baa0385c9c09c53a,CVE-2017-16357,https://github.com/radare/radare2/commit/0b973e28166636e0ff1fad80baa0385c9c09c53a,2017-11-01T17:29Z,<S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug>
1842,CWE-119,"<S2SV_StartBug> static void dist_block ( int plane , int block , TX_SIZE tx_size , <S2SV_EndBug> <S2SV_StartBug> struct rdcost_block_args * args ) { <S2SV_EndBug> <S2SV_StartBug> const int ss_txfrm_size = tx_size << 1 ; <S2SV_EndBug> MACROBLOCK * const x = args -> x ; MACROBLOCKD * const xd = & x -> e_mbd ; const struct macroblock_plane * const p = & x -> plane [ plane ] ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; int64_t this_sse ; int shift = tx_size == TX_32X32 ? 0 : 2 ; <S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> args -> dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , <S2SV_EndBug> <S2SV_StartBug> & this_sse ) >> shift ; <S2SV_EndBug> args -> sse = this_sse >> shift ; if ( x -> skip_encode && ! is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ) { int64_t p = ( pd -> dequant [ 1 ] * pd -> dequant [ 1 ] * <S2SV_StartBug> ( 1 << ss_txfrm_size ) ) >> ( shift + 2 ) ; <S2SV_EndBug> args -> dist += ( p >> 4 ) ; <S2SV_StartBug> args -> sse += p ; <S2SV_EndBug> } }
","<S2SV_ModStart> void dist_block ( MACROBLOCK * x , <S2SV_ModStart> TX_SIZE tx_size , int64_t * out_dist , int64_t * out_sse <S2SV_ModEnd> ) { const <S2SV_ModStart> tx_size << 1 <S2SV_ModEnd> ; MACROBLOCKD * <S2SV_ModStart> : 2 ; tran_low_t <S2SV_ModEnd> * const coeff <S2SV_ModStart> block ) ; tran_low_t <S2SV_ModEnd> * const dqcoeff <S2SV_ModStart> block ) ; # if CONFIG_VP9_HIGHBITDEPTH const int bd = ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd : 8 ; * out_dist = vp9_highbd_block_error <S2SV_ModEnd> ( coeff , <S2SV_ModStart> , & this_sse , bd ) >> shift ; # else * out_dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , & this_sse ) >> shift ; # endif * out_sse <S2SV_ModEnd> = this_sse >> <S2SV_ModStart> ) ) >> # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> shift + 2 + ( bd - 8 ) * 2 ) ; # else ( shift + 2 ) ; # endif * out_dist <S2SV_ModEnd> += ( p <S2SV_ModStart> 4 ) ; * out_sse <S2SV_ModEnd> += p ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void dist_block ( int plane , int block , TX_SIZE tx_size , <S2SV_EndBug> <S2SV_StartBug> struct rdcost_block_args * args ) { <S2SV_EndBug> <S2SV_StartBug> const int ss_txfrm_size = tx_size << 1 ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> args -> dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , <S2SV_EndBug> <S2SV_StartBug> & this_sse ) >> shift ; <S2SV_EndBug> <S2SV_StartBug> ( 1 << ss_txfrm_size ) ) >> ( shift + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> args -> sse += p ; <S2SV_EndBug>"
3850,CWE-476,"jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; <S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; box -> info = boxinfo ; box -> len = len ; JAS_DBGLOG ( 10 , ( <S2SV_StartBug> ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , <S2SV_EndBug> \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ) ; <S2SV_StartBug> if ( box -> len == 1 ) { <S2SV_EndBug> if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( ""warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\n"" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto error ; } jas_stream_rewind ( tmpstream ) ; box -> ops = & boxinfo -> ops ; if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( ""cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }
","<S2SV_ModStart> ( box = jp2_box_create0 ( ) ) ) { goto error ; } <S2SV_ModEnd> if ( jp2_getuint32 <S2SV_ModStart> 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>"" ""type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%"" PRIuFAST32 ""\\n"" <S2SV_ModEnd> , \'""\' , <S2SV_ModStart> 1 ) { JAS_DBGLOG ( 10 , ( ""big<S2SV_blank>length\\n"" ) ) ;
",mdadams@jasper/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,CVE-2017-6850,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,2017-03-15T14:59Z,"<S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( box -> len == 1 ) { <S2SV_EndBug>"
8325,CWE-125,"static BOOL autodetect_recv_bandwidth_measure_results ( rdpRdp * rdp , wStream * s , AUTODETECT_RSP_PDU * autodetectRspPdu ) { BOOL success = TRUE ; if ( autodetectRspPdu -> headerLength != 0x0E ) return FALSE ; <S2SV_StartBug> WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; <S2SV_EndBug> Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ; Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureByteCount ) ; if ( rdp -> autodetect -> bandwidthMeasureTimeDelta > 0 ) rdp -> autodetect -> netCharBandwidth = rdp -> autodetect -> bandwidthMeasureByteCount * 8 / rdp -> autodetect -> bandwidthMeasureTimeDelta ; else rdp -> autodetect -> netCharBandwidth = 0 ; IFCALLRET ( rdp -> autodetect -> BandwidthMeasureResults , success , rdp -> context , autodetectRspPdu -> sequenceNumber ) ; return success ; }
","<S2SV_ModStart> , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1
",FreeRDP@FreeRDP/f5e73cc7c9cd973b516a618da877c87b80950b65,CVE-2020-11047,https://github.com/FreeRDP/FreeRDP/commit/f5e73cc7c9cd973b516a618da877c87b80950b65,2020-05-07T20:15Z,"<S2SV_StartBug> WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; <S2SV_EndBug>"
761,CWE-20,"static int __key_instantiate_and_link ( struct key * key , struct key_preparsed_payload * prep , struct key * keyring , struct key * authkey , struct assoc_array_edit * * _edit ) { int ret , awaken ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; mutex_lock ( & key_construction_mutex ) ; <S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> ret = key -> type -> instantiate ( key , prep ) ; if ( ret == 0 ) { atomic_inc ( & key -> user -> nikeys ) ; <S2SV_StartBug> set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; <S2SV_EndBug> if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; if ( keyring ) { if ( test_bit ( KEY_FLAG_KEEP , & keyring -> flags ) ) set_bit ( KEY_FLAG_KEEP , & key -> flags ) ; __key_link ( key , _edit ) ; } if ( authkey ) key_revoke ( authkey ) ; if ( prep -> expiry != TIME_T_MAX ) { key -> expiry = prep -> expiry ; key_schedule_gc ( prep -> expiry + key_gc_delay ) ; } } } mutex_unlock ( & key_construction_mutex ) ; if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; return ret ; }
","<S2SV_ModStart> ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { ret <S2SV_ModStart> nikeys ) ; mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; if
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> <S2SV_StartBug> set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; <S2SV_EndBug>"
2358,CWE-000,"static int handle_vmon ( struct kvm_vcpu * vcpu ) { int ret ; gpa_t vmptr ; struct page * page ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; const u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED | FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX ; <S2SV_StartBug> if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) { <S2SV_EndBug> kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx -> nested . vmxon ) { nested_vmx_failValid ( vcpu , VMXERR_VMXON_IN_VMX_ROOT_OPERATION ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } if ( ( vmx -> msr_ia32_feature_control & VMXON_NEEDED_FEATURES ) != VMXON_NEEDED_FEATURES ) { kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } if ( nested_vmx_get_vmptr ( vcpu , & vmptr ) ) return 1 ; if ( ! PAGE_ALIGNED ( vmptr ) || ( vmptr >> cpuid_maxphyaddr ( vcpu ) ) ) { nested_vmx_failInvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } page = kvm_vcpu_gpa_to_page ( vcpu , vmptr ) ; if ( is_error_page ( page ) ) { nested_vmx_failInvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } if ( * ( u32 * ) kmap ( page ) != VMCS12_REVISION ) { kunmap ( page ) ; kvm_release_page_clean ( page ) ; nested_vmx_failInvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } kunmap ( page ) ; kvm_release_page_clean ( page ) ; vmx -> nested . vmxon_ptr = vmptr ; ret = enter_vmx_operation ( vcpu ) ; if ( ret ) return ret ; nested_vmx_succeed ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; }
","<S2SV_ModStart> vcpu , X86_CR4_VMXE ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx_get_cpl ( vcpu
",torvalds@linux/727ba748e110b4de50d142edca9d6a9b7e6111d8,CVE-2018-12904,https://github.com/torvalds/linux/commit/727ba748e110b4de50d142edca9d6a9b7e6111d8,2018-06-27T11:29Z,"<S2SV_StartBug> if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) { <S2SV_EndBug>"
4533,CWE-125,"PyObject * ast2obj_type_ignore ( void * _o ) { type_ignore_ty o = ( type_ignore_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case TypeIgnore_kind : result = PyType_GenericNew ( TypeIgnore_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_int ( o -> v . TypeIgnore . lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug>
596,CWE-476,"int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ; if ( s -> codec_tag == AV_RL32 ( ""WV1F"" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( ""QMP4"" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , ""frame<S2SV_blank>skip<S2SV_blank>%d\\n"" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , ""startcode:<S2SV_blank>%3X<S2SV_blank>"" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Video<S2SV_blank>Object<S2SV_blank>Start"" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Video<S2SV_blank>Object<S2SV_blank>Layer<S2SV_blank>Start"" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Reserved"" ) ; else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FGS<S2SV_blank>bp<S2SV_blank>start"" ) ; else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Reserved"" ) ; else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>Start"" ) ; else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>End"" ) ; else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""User<S2SV_blank>Data"" ) ; else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Group<S2SV_blank>of<S2SV_blank>VOP<S2SV_blank>start"" ) ; else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Video<S2SV_blank>Session<S2SV_blank>Error"" ) ; else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Visual<S2SV_blank>Object<S2SV_blank>Start"" ) ; else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Video<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start"" ) ; else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""slice<S2SV_blank>start"" ) ; else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""extension<S2SV_blank>start"" ) ; else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""fgs<S2SV_blank>start"" ) ; else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FBA<S2SV_blank>Object<S2SV_blank>start"" ) ; else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FBA<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start"" ) ; else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Mesh<S2SV_blank>Object<S2SV_blank>start"" ) ; else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Mesh<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start"" ) ; else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Still<S2SV_blank>Texture<S2SV_blank>Object<S2SV_blank>start"" ) ; else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Texture<S2SV_blank>Spatial<S2SV_blank>Layer<S2SV_blank>start"" ) ; else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Texture<S2SV_blank>SNR<S2SV_blank>Layer<S2SV_blank>start"" ) ; else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Texture<S2SV_blank>Tile<S2SV_blank>start"" ) ; else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Texture<S2SV_blank>Shape<S2SV_blank>Layer<S2SV_blank>start"" ) ; else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""stuffing<S2SV_blank>start"" ) ; else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""reserved"" ) ; else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""System<S2SV_blank>start"" ) ; av_log ( s -> avctx , AV_LOG_DEBUG , ""<S2SV_blank>at<S2SV_blank>%d\\n"" , get_bits_count ( gb ) ) ; } if ( startcode >= 0x120 && startcode <= 0x12F ) { if ( vol ) { av_log ( s -> avctx , AV_LOG_WARNING , ""Ignoring<S2SV_blank>multiple<S2SV_blank>VOL<S2SV_blank>headers\\n"" ) ; continue ; } vol ++ ; if ( ( ret = decode_vol_header ( ctx , gb ) ) < 0 ) return ret ; } else if ( startcode == USER_DATA_STARTCODE ) { decode_user_data ( ctx , gb ) ; } else if ( startcode == GOP_STARTCODE ) { mpeg4_decode_gop_header ( s , gb ) ; } else if ( startcode == VOS_STARTCODE ) { <S2SV_StartBug> mpeg4_decode_profile_level ( s , gb ) ; <S2SV_EndBug> if ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && <S2SV_StartBug> ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { <S2SV_EndBug> s -> studio_profile = 1 ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( startcode == VISUAL_OBJ_STARTCODE ) { if ( s -> studio_profile ) { if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ; } else mpeg4_decode_visual_object ( s , gb ) ; } else if ( startcode == VOP_STARTCODE ) { break ; } align_get_bits ( gb ) ; startcode = 0xff ; } end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; s -> avctx -> has_b_frames = ! s -> low_delay ; if ( s -> studio_profile ) { <S2SV_StartBug> if ( ! s -> avctx -> bits_per_raw_sample ) { <S2SV_EndBug> av_log ( s -> avctx , AV_LOG_ERROR , ""Missing<S2SV_blank>VOL<S2SV_blank>header\\n"" ) ; return AVERROR_INVALIDDATA ; } return decode_studio_vop_header ( ctx , gb ) ; } else return decode_vop_header ( ctx , gb ) ; }
","<S2SV_ModStart> VOS_STARTCODE ) { int profile , level ; <S2SV_ModStart> s , gb , & profile , & level ) ; if ( <S2SV_ModEnd> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO <S2SV_ModStart> FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( <S2SV_ModEnd> level > 0 <S2SV_ModStart> > 0 && <S2SV_ModEnd> level < 9 <S2SV_ModStart> ) ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , ""Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\n"" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> studio_profile ) { av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;
",FFmpeg@FFmpeg/2aa9047486dbff12d9e040f917e5f799ed2fd78b,CVE-2018-13301,https://github.com/FFmpeg/FFmpeg/commit/2aa9047486dbff12d9e040f917e5f799ed2fd78b,2018-07-05T17:29Z,"<S2SV_StartBug> mpeg4_decode_profile_level ( s , gb ) ; <S2SV_EndBug> <S2SV_StartBug> ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! s -> avctx -> bits_per_raw_sample ) { <S2SV_EndBug>"
870,CWE-200,"static void sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) { Sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > SG_MAX_QUEUE ) break ; <S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }
","<S2SV_ModStart> ) break ; <S2SV_ModEnd> rinfo [ val
",torvalds@linux/3e0097499839e0fe3af380410eababe5a47c4cf9,CVE-2017-14991,https://github.com/torvalds/linux/commit/3e0097499839e0fe3af380410eababe5a47c4cf9,2017-10-04T01:29Z,"<S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug>"
6706,CWE-787,"static int xdp_umem_reg ( struct xdp_umem * umem , struct xdp_umem_reg * mr ) { bool unaligned_chunks = mr -> flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG ; u32 chunk_size = mr -> chunk_size , headroom = mr -> headroom ; unsigned int chunks , chunks_per_page ; u64 addr = mr -> addr , size = mr -> len ; <S2SV_StartBug> int size_chk , err ; <S2SV_EndBug> if ( chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE ) { return - EINVAL ; } if ( mr -> flags & ~ ( XDP_UMEM_UNALIGNED_CHUNK_FLAG | XDP_UMEM_USES_NEED_WAKEUP ) ) return - EINVAL ; if ( ! unaligned_chunks && ! is_power_of_2 ( chunk_size ) ) return - EINVAL ; if ( ! PAGE_ALIGNED ( addr ) ) { return - EINVAL ; } if ( ( addr + size ) < addr ) return - EINVAL ; chunks = ( unsigned int ) div_u64 ( size , chunk_size ) ; if ( chunks == 0 ) return - EINVAL ; if ( ! unaligned_chunks ) { chunks_per_page = PAGE_SIZE / chunk_size ; if ( chunks < chunks_per_page || chunks % chunks_per_page ) return - EINVAL ; } <S2SV_StartBug> size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM ; <S2SV_EndBug> if ( size_chk < 0 ) return - EINVAL ; umem -> address = ( unsigned long ) addr ; umem -> chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK : ~ ( ( u64 ) chunk_size - 1 ) ; umem -> size = size ; umem -> headroom = headroom ; umem -> chunk_size_nohr = chunk_size - headroom ; umem -> npgs = size / PAGE_SIZE ; umem -> pgs = NULL ; umem -> user = NULL ; umem -> flags = mr -> flags ; INIT_LIST_HEAD ( & umem -> xsk_list ) ; spin_lock_init ( & umem -> xsk_list_lock ) ; refcount_set ( & umem -> users , 1 ) ; err = xdp_umem_account_pages ( umem ) ; if ( err ) return err ; err = xdp_umem_pin_pages ( umem ) ; if ( err ) goto out_account ; umem -> pages = kvcalloc ( umem -> npgs , sizeof ( * umem -> pages ) , GFP_KERNEL_ACCOUNT ) ; if ( ! umem -> pages ) { err = - ENOMEM ; goto out_pin ; } err = xdp_umem_map_pages ( umem ) ; if ( ! err ) return 0 ; kvfree ( umem -> pages ) ; out_pin : xdp_umem_unpin_pages ( umem ) ; out_account : xdp_umem_unaccount_pages ( umem ) ; return err ; }
","<S2SV_ModStart> len ; int <S2SV_ModEnd> err ; if <S2SV_ModStart> EINVAL ; } if ( headroom >= chunk_size - XDP_PACKET_HEADROOM <S2SV_ModEnd> ) return -
",torvalds@linux/99e3a236dd43d06c65af0a2ef9cb44306aef6e02,CVE-2020-12659,https://github.com/torvalds/linux/commit/99e3a236dd43d06c65af0a2ef9cb44306aef6e02,2020-05-05T07:15Z,"<S2SV_StartBug> int size_chk , err ; <S2SV_EndBug> <S2SV_StartBug> size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM ; <S2SV_EndBug>"
106,CWE-264,"int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; <S2SV_StartBug> fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; <S2SV_EndBug> if ( fd < 0 ) return - errno ; if ( mode != MODE_INVALID ) { r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }
","<S2SV_ModStart> | O_NOCTTY , ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode <S2SV_ModEnd> ) ; if
",systemd@systemd/06eeacb6fe029804f296b065b3ce91e796e1cd0e,CVE-2016-10156,https://github.com/systemd/systemd/commit/06eeacb6fe029804f296b065b3ce91e796e1cd0e,2017-01-23T07:59Z,"<S2SV_StartBug> fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; <S2SV_EndBug>"
2319,CWE-787,"int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels , chansSpecified , chanMask = 0 ; uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( eptr - cptr >= dff_chunk_header . ckDataSize ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) { total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
",dbry@WavPack/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,CVE-2018-10540,https://github.com/dbry/WavPack/commit/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,2018-04-29T15:29Z,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug>
7171,CWE-552,"static ssize_t _consolefs_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <S2SV_StartBug> if ( ! file || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }
","<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,"<S2SV_StartBug> if ( ! file || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug>"
5467,CWE-362,"int my_redel ( const char * org_name , const char * tmp_name , myf MyFlags ) { int error = 1 ; DBUG_ENTER ( ""my_redel"" ) ; DBUG_PRINT ( ""my"" , ( ""org_name:<S2SV_blank>\'%s\'<S2SV_blank>tmp_name:<S2SV_blank>\'%s\'<S2SV_blank><S2SV_blank>MyFlags:<S2SV_blank>%d"" , org_name , tmp_name , MyFlags ) ) ; <S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto end ; <S2SV_EndBug> if ( MyFlags & MY_REDEL_MAKE_BACKUP ) { char name_buff [ FN_REFLEN + 20 ] ; char ext [ 20 ] ; ext [ 0 ] = '-' ; get_date ( ext + 1 , 2 + 4 , ( time_t ) 0 ) ; strmov ( strend ( ext ) , REDEL_EXT ) ; if ( my_rename ( org_name , fn_format ( name_buff , org_name , """" , ext , 2 ) , MyFlags ) ) goto end ; } else if ( my_delete_allow_opened ( org_name , MyFlags ) ) goto end ; if ( my_rename ( tmp_name , org_name , MyFlags ) ) goto end ; error = 0 ; end : DBUG_RETURN ( error ) ; }
","<S2SV_ModStart> ; if ( ! ( MyFlags & MY_REDEL_NO_COPY_STAT ) ) { if ( <S2SV_ModStart> goto end ; }
",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z,"<S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto end ; <S2SV_EndBug>"
3838,CWE-190,"static int read_SubStreamsInfo ( struct archive_read * a , struct _7z_substream_info * ss , struct _7z_folder * f , size_t numFolders ) { const unsigned char * p ; uint64_t * usizes ; size_t unpack_streams ; int type ; unsigned i ; uint32_t numDigests ; memset ( ss , 0 , sizeof ( * ss ) ) ; for ( i = 0 ; i < numFolders ; i ++ ) f [ i ] . numUnpackStreams = 1 ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; if ( type == kNumUnPackStream ) { unpack_streams = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( parse_7zip_uint64 ( a , & ( f [ i ] . numUnpackStreams ) ) < 0 ) return ( - 1 ) ; if ( UMAX_ENTRY < f [ i ] . numUnpackStreams ) return ( - 1 ) ; <S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug> } if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } else unpack_streams = numFolders ; ss -> unpack_streams = unpack_streams ; if ( unpack_streams ) { ss -> unpackSizes = calloc ( unpack_streams , sizeof ( * ss -> unpackSizes ) ) ; ss -> digestsDefined = calloc ( unpack_streams , sizeof ( * ss -> digestsDefined ) ) ; ss -> digests = calloc ( unpack_streams , sizeof ( * ss -> digests ) ) ; if ( ss -> unpackSizes == NULL || ss -> digestsDefined == NULL || ss -> digests == NULL ) return ( - 1 ) ; } usizes = ss -> unpackSizes ; for ( i = 0 ; i < numFolders ; i ++ ) { unsigned pack ; uint64_t sum ; if ( f [ i ] . numUnpackStreams == 0 ) continue ; sum = 0 ; if ( type == kSize ) { for ( pack = 1 ; pack < f [ i ] . numUnpackStreams ; pack ++ ) { if ( parse_7zip_uint64 ( a , usizes ) < 0 ) return ( - 1 ) ; sum += * usizes ++ ; } } * usizes ++ = folder_uncompressed_size ( & f [ i ] ) - sum ; } if ( type == kSize ) { if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } for ( i = 0 ; i < unpack_streams ; i ++ ) { ss -> digestsDefined [ i ] = 0 ; ss -> digests [ i ] = 0 ; } numDigests = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams != 1 || ! f [ i ] . digest_defined ) numDigests += ( uint32_t ) f [ i ] . numUnpackStreams ; } if ( type == kCRC ) { struct _7z_digests tmpDigests ; unsigned char * digestsDefined = ss -> digestsDefined ; uint32_t * digests = ss -> digests ; int di = 0 ; memset ( & tmpDigests , 0 , sizeof ( tmpDigests ) ) ; if ( read_Digests ( a , & ( tmpDigests ) , numDigests ) < 0 ) { free_Digest ( & tmpDigests ) ; return ( - 1 ) ; } for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams == 1 && f [ i ] . digest_defined ) { * digestsDefined ++ = 1 ; * digests ++ = f [ i ] . digest ; } else { unsigned j ; for ( j = 0 ; j < f [ i ] . numUnpackStreams ; j ++ , di ++ ) { * digestsDefined ++ = tmpDigests . defineds [ di ] ; * digests ++ = tmpDigests . digests [ di ] ; } } } free_Digest ( & tmpDigests ) ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } if ( type != kEnd ) return ( - 1 ) ; return ( 0 ) ; }
","<S2SV_ModStart> 1 ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }
",libarchive@libarchive/e79ef306afe332faf22e9b442a2c6b59cb175573,CVE-2016-4300,https://github.com/libarchive/libarchive/commit/e79ef306afe332faf22e9b442a2c6b59cb175573,2016-09-21T14:25Z,<S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug>
3611,CWE-200,"int equalizer_get_parameter ( effect_context_t * context , effect_param_t * p , uint32_t * size ) { equalizer_context_t * eq_ctxt = ( equalizer_context_t * ) context ; int voffset = ( ( p -> psize - 1 ) / sizeof ( int32_t ) + 1 ) * sizeof ( int32_t ) ; int32_t * param_tmp = ( int32_t * ) p -> data ; int32_t param = * param_tmp ++ ; int32_t param2 ; char * name ; void * value = p -> data + voffset ; int i ; ALOGV ( ""%s"" , __func__ ) ; p -> status = 0 ; switch ( param ) { case EQ_PARAM_NUM_BANDS : case EQ_PARAM_CUR_PRESET : case EQ_PARAM_GET_NUM_OF_PRESETS : case EQ_PARAM_BAND_LEVEL : case EQ_PARAM_GET_BAND : if ( p -> vsize < sizeof ( int16_t ) ) p -> status = - EINVAL ; p -> vsize = sizeof ( int16_t ) ; break ; case EQ_PARAM_LEVEL_RANGE : if ( p -> vsize < 2 * sizeof ( int16_t ) ) p -> status = - EINVAL ; p -> vsize = 2 * sizeof ( int16_t ) ; break ; case EQ_PARAM_BAND_FREQ_RANGE : if ( p -> vsize < 2 * sizeof ( int32_t ) ) p -> status = - EINVAL ; p -> vsize = 2 * sizeof ( int32_t ) ; break ; case EQ_PARAM_CENTER_FREQ : if ( p -> vsize < sizeof ( int32_t ) ) p -> status = - EINVAL ; p -> vsize = sizeof ( int32_t ) ; break ; case EQ_PARAM_GET_PRESET_NAME : break ; case EQ_PARAM_PROPERTIES : if ( p -> vsize < ( 2 + NUM_EQ_BANDS ) * sizeof ( uint16_t ) ) p -> status = - EINVAL ; p -> vsize = ( 2 + NUM_EQ_BANDS ) * sizeof ( uint16_t ) ; break ; default : p -> status = - EINVAL ; } * size = sizeof ( effect_param_t ) + voffset + p -> vsize ; if ( p -> status != 0 ) return 0 ; switch ( param ) { case EQ_PARAM_NUM_BANDS : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_NUM_BANDS"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) NUM_EQ_BANDS ; break ; case EQ_PARAM_LEVEL_RANGE : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_LEVEL_RANGE"" , __func__ ) ; * ( int16_t * ) value = - 1500 ; * ( ( int16_t * ) value + 1 ) = 1500 ; break ; case EQ_PARAM_BAND_LEVEL : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_BAND_LEVEL"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> p -> status = - EINVAL ; <S2SV_StartBug> break ; <S2SV_EndBug> } * ( int16_t * ) value = ( int16_t ) equalizer_get_band_level ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_CENTER_FREQ : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_CENTER_FREQ"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> p -> status = - EINVAL ; <S2SV_StartBug> break ; <S2SV_EndBug> } * ( int32_t * ) value = equalizer_get_center_frequency ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_BAND_FREQ_RANGE : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> p -> status = - EINVAL ; <S2SV_EndBug> break ; } equalizer_get_band_freq_range ( eq_ctxt , param2 , ( uint32_t * ) value , ( ( uint32_t * ) value + 1 ) ) ; break ; case EQ_PARAM_GET_BAND : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_BAND"" , __func__ ) ; param2 = * param_tmp ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_band ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_CUR_PRESET : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_CUR_PRESET"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_preset ( eq_ctxt ) ; break ; case EQ_PARAM_GET_NUM_OF_PRESETS : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_NUM_OF_PRESETS"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_num_presets ( eq_ctxt ) ; break ; case EQ_PARAM_GET_PRESET_NAME : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_PRESET_NAME"" , __func__ ) ; param2 = * param_tmp ; ALOGV ( ""param2:<S2SV_blank>%d"" , param2 ) ; if ( param2 >= equalizer_get_num_presets ( eq_ctxt ) ) { p -> status = - EINVAL ; break ; } name = ( char * ) value ; strlcpy ( name , equalizer_get_preset_name ( eq_ctxt , param2 ) , p -> vsize - 1 ) ; name [ p -> vsize - 1 ] = 0 ; p -> vsize = strlen ( name ) + 1 ; break ; case EQ_PARAM_PROPERTIES : { ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_PROPERTIES"" , __func__ ) ; int16_t * prop = ( int16_t * ) value ; prop [ 0 ] = ( int16_t ) equalizer_get_preset ( eq_ctxt ) ; prop [ 1 ] = ( int16_t ) NUM_EQ_BANDS ; for ( i = 0 ; i < NUM_EQ_BANDS ; i ++ ) { prop [ 2 + i ] = ( int16_t ) equalizer_get_band_level ( eq_ctxt , i ) ; } } break ; default : p -> status = - EINVAL ; break ; } return 0 ; }
","<S2SV_ModStart> if ( param2 < 0 || param2 <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32438598"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> ; if ( param2 < 0 || <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32436341"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> ; if ( param2 < 0 || <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32247948"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; }
",hardware@qcom@audio/d72ea85c78a1a68bf99fd5804ad9784b4102fe57,CVE-2017-0402,https://android.googlesource.com/platform/hardware/qcom/audio/+/d72ea85c78a1a68bf99fd5804ad9784b4102fe57,2017-01-12T20:59Z,<S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> p -> status = - EINVAL ; <S2SV_EndBug>
7228,CWE-19,"static int <S2SV_StartBug> ext2_xattr_cache_insert ( struct buffer_head * bh ) <S2SV_EndBug> { __u32 hash = le32_to_cpu ( HDR ( bh ) -> h_hash ) ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> int error ; <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext2_xattr_cache , GFP_NOFS ) ; <S2SV_EndBug> if ( ! ce ) return - ENOMEM ; <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> if ( error ) { <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> if ( error == - EBUSY ) { ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache<S2SV_blank>(%d<S2SV_blank>cache<S2SV_blank>entries)"" , atomic_read ( & ext2_xattr_cache -> c_entry_count ) ) ; error = 0 ; } <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]<S2SV_blank>(%d<S2SV_blank>cache<S2SV_blank>entries)"" , ( int ) hash , <S2SV_EndBug> atomic_read ( & ext2_xattr_cache -> c_entry_count ) ) ; mb_cache_entry_release ( ce ) ; } return error ; }
","<S2SV_ModStart> int ext2_xattr_cache_insert ( struct mb2_cache * cache , <S2SV_ModStart> h_hash ) ; <S2SV_ModEnd> int error ; <S2SV_ModStart> int error ; error = mb2_cache_entry_create ( cache , GFP_NOFS , hash <S2SV_ModEnd> , bh -> <S2SV_ModStart> bh -> b_blocknr <S2SV_ModEnd> ) ; if <S2SV_ModStart> error ) { <S2SV_ModEnd> if ( error <S2SV_ModStart> } } else <S2SV_ModEnd> ea_bdebug ( bh <S2SV_ModStart> ( bh , ""inserting<S2SV_blank>[%x]"" <S2SV_ModEnd> , ( int <S2SV_ModStart> int ) hash ) ; <S2SV_ModEnd> return error ;
",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z,"<S2SV_StartBug> ext2_xattr_cache_insert ( struct buffer_head * bh ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext2_xattr_cache , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]<S2SV_blank>(%d<S2SV_blank>cache<S2SV_blank>entries)"" , ( int ) hash , <S2SV_EndBug>"
295,CWE-264,"int propagate_mnt ( struct mount * dest_mnt , struct dentry * dest_dentry , struct mount * source_mnt , struct list_head * tree_list ) { <S2SV_StartBug> struct mount * m , * child ; <S2SV_EndBug> int ret = 0 ; struct mount * prev_dest_mnt = dest_mnt ; struct mount * prev_src_mnt = source_mnt ; LIST_HEAD ( tmp_list ) ; LIST_HEAD ( umount_list ) ; for ( m = propagation_next ( dest_mnt , dest_mnt ) ; m ; m = propagation_next ( m , dest_mnt ) ) { int type ; struct mount * source ; if ( IS_MNT_NEW ( m ) ) continue ; <S2SV_StartBug> source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; <S2SV_EndBug> child = copy_tree ( source , source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) { ret = PTR_ERR ( child ) ; list_splice ( tree_list , tmp_list . prev ) ; goto out ; } if ( is_subdir ( dest_dentry , m -> mnt . mnt_root ) ) { mnt_set_mountpoint ( m , dest_dentry , child ) ; list_add_tail ( & child -> mnt_hash , tree_list ) ; } else { list_add_tail ( & child -> mnt_hash , & tmp_list ) ; } prev_dest_mnt = m ; prev_src_mnt = child ; } out : br_write_lock ( & vfsmount_lock ) ; while ( ! list_empty ( & tmp_list ) ) { child = list_first_entry ( & tmp_list , struct mount , mnt_hash ) ; umount_tree ( child , 0 , & umount_list ) ; } br_write_unlock ( & vfsmount_lock ) ; release_mounts ( & umount_list ) ; return ret ; }
","<S2SV_ModStart> ) { struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <S2SV_ModStart> & type ) ; if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED
",torvalds@linux/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,CVE-2013-1957,https://github.com/torvalds/linux/commit/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,2013-04-24T19:55Z,"<S2SV_StartBug> struct mount * m , * child ; <S2SV_EndBug> <S2SV_StartBug> source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; <S2SV_EndBug>"
8402,CWE-125,"static ssize_t parse8BIM ( Image * ifile , Image * ofile ) { char brkused , quoted , * line , * token , * newstr , * name ; int state , next ; unsigned char dataset ; unsigned int recnum ; int inputlen = MagickPathExtent ; MagickOffsetType savedpos , currentpos ; ssize_t savedolen = 0L , outputlen = 0L ; TokenInfo * token_info ; dataset = 0 ; recnum = 0 ; line = ( char * ) AcquireQuantumMemory ( ( size_t ) inputlen , sizeof ( * line ) ) ; if ( line == ( char * ) NULL ) return ( - 1 ) ; newstr = name = token = ( char * ) NULL ; savedpos = 0 ; token_info = AcquireTokenInfo ( ) ; while ( super_fgets ( & line , & inputlen , ifile ) != NULL ) { state = 0 ; next = 0 ; token = ( char * ) AcquireQuantumMemory ( ( size_t ) inputlen , sizeof ( * token ) ) ; if ( token == ( char * ) NULL ) break ; newstr = ( char * ) AcquireQuantumMemory ( ( size_t ) inputlen , sizeof ( * newstr ) ) ; if ( newstr == ( char * ) NULL ) break ; while ( Tokenizer ( token_info , 0 , token , ( size_t ) inputlen , line , """" , ""="" , ""\\"""" , 0 , & brkused , & next , & quoted ) == 0 ) { if ( state == 0 ) { int state , next ; char brkused , quoted ; state = 0 ; next = 0 ; while ( Tokenizer ( token_info , 0 , newstr , ( size_t ) inputlen , token , """" , ""#"" , """" , 0 , & brkused , & next , & quoted ) == 0 ) { switch ( state ) { case 0 : if ( strcmp ( newstr , ""8BIM"" ) == 0 ) dataset = 255 ; else dataset = ( unsigned char ) StringToLong ( newstr ) ; break ; case 1 : recnum = ( unsigned int ) StringToUnsignedLong ( newstr ) ; break ; case 2 : name = ( char * ) AcquireQuantumMemory ( strlen ( newstr ) + MagickPathExtent , sizeof ( * name ) ) ; if ( name ) ( void ) strcpy ( name , newstr ) ; break ; } state ++ ; } } else if ( state == 1 ) { int next ; ssize_t len ; char brkused , quoted ; next = 0 ; len = ( ssize_t ) strlen ( token ) ; while ( Tokenizer ( token_info , 0 , newstr , ( size_t ) inputlen , token , """" , ""&"" , """" , 0 , & brkused , & next , & quoted ) == 0 ) { if ( brkused && next > 0 ) { char * s = & token [ next - 1 ] ; len -= ( ssize_t ) convertHTMLcodes ( s , ( int ) strlen ( s ) ) ; } } if ( dataset == 255 ) { unsigned char nlen = 0 ; int i ; if ( savedolen > 0 ) { MagickOffsetType offset ; ssize_t diff = outputlen - savedolen ; currentpos = TellBlob ( ofile ) ; if ( currentpos < 0 ) return ( - 1 ) ; offset = SeekBlob ( ofile , savedpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; ( void ) WriteBlobMSBLong ( ofile , ( unsigned int ) diff ) ; offset = SeekBlob ( ofile , currentpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; savedolen = 0L ; } if ( outputlen & 1 ) { ( void ) WriteBlobByte ( ofile , 0x00 ) ; outputlen ++ ; } ( void ) WriteBlobString ( ofile , ""8BIM"" ) ; ( void ) WriteBlobMSBShort ( ofile , ( unsigned short ) recnum ) ; outputlen += 6 ; if ( name ) nlen = ( unsigned char ) strlen ( name ) ; ( void ) WriteBlobByte ( ofile , nlen ) ; outputlen ++ ; for ( i = 0 ; i < nlen ; i ++ ) ( void ) WriteBlobByte ( ofile , ( unsigned char ) name [ i ] ) ; outputlen += nlen ; if ( ( nlen & 0x01 ) == 0 ) { ( void ) WriteBlobByte ( ofile , 0x00 ) ; outputlen ++ ; } if ( recnum != IPTC_ID ) { ( void ) WriteBlobMSBLong ( ofile , ( unsigned int ) len ) ; outputlen += 4 ; next = 0 ; outputlen += len ; <S2SV_StartBug> while ( len -- ) <S2SV_EndBug> ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ; if ( outputlen & 1 ) { ( void ) WriteBlobByte ( ofile , 0x00 ) ; outputlen ++ ; } } else { savedpos = TellBlob ( ofile ) ; if ( savedpos < 0 ) return ( - 1 ) ; ( void ) WriteBlobMSBLong ( ofile , 0xFFFFFFFFU ) ; outputlen += 4 ; savedolen = outputlen ; } } else { if ( len <= 0x7FFF ) { ( void ) WriteBlobByte ( ofile , 0x1c ) ; ( void ) WriteBlobByte ( ofile , ( unsigned char ) dataset ) ; ( void ) WriteBlobByte ( ofile , ( unsigned char ) ( recnum & 0xff ) ) ; ( void ) WriteBlobMSBShort ( ofile , ( unsigned short ) len ) ; outputlen += 5 ; next = 0 ; outputlen += len ; <S2SV_StartBug> while ( len -- ) <S2SV_EndBug> ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ; } } } state ++ ; } if ( token != ( char * ) NULL ) token = DestroyString ( token ) ; if ( newstr != ( char * ) NULL ) newstr = DestroyString ( newstr ) ; if ( name != ( char * ) NULL ) name = DestroyString ( name ) ; } token_info = DestroyTokenInfo ( token_info ) ; if ( token != ( char * ) NULL ) token = DestroyString ( token ) ; if ( newstr != ( char * ) NULL ) newstr = DestroyString ( newstr ) ; if ( name != ( char * ) NULL ) name = DestroyString ( name ) ; line = DestroyString ( line ) ; if ( savedolen > 0 ) { MagickOffsetType offset ; ssize_t diff = outputlen - savedolen ; currentpos = TellBlob ( ofile ) ; if ( currentpos < 0 ) return ( - 1 ) ; offset = SeekBlob ( ofile , savedpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; ( void ) WriteBlobMSBLong ( ofile , ( unsigned int ) diff ) ; offset = SeekBlob ( ofile , currentpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; savedolen = 0L ; } return outputlen ; }
","<S2SV_ModStart> ( len -- > 0 <S2SV_ModStart> ( len -- > 0
",ImageMagick@ImageMagick/f8c318d462270b03e77f082e2a3a32867cacd3c6,CVE-2016-7524,https://github.com/ImageMagick/ImageMagick/commit/f8c318d462270b03e77f082e2a3a32867cacd3c6,2020-02-06T14:15Z,<S2SV_StartBug> while ( len -- ) <S2SV_EndBug> <S2SV_StartBug> while ( len -- ) <S2SV_EndBug>
3006,CWE-119,"void impeg2d_dec_hdr ( void * pv_dec , impeg2d_video_decode_ip_t * ps_ip , impeg2d_video_decode_op_t * ps_op ) { UWORD32 u4_bits_read ; dec_state_t * ps_dec ; ps_dec = ( dec_state_t * ) pv_dec ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = 0 ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , ps_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer , ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) ; { { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_process_video_header ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } if ( ps_op -> s_ivd_video_decode_op_t . u4_error_code == 0 ) ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; <S2SV_StartBug> impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; <S2SV_EndBug> return ; } } ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_vertical_size ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_horizontal_size ; ps_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } ps_op -> s_ivd_video_decode_op_t . u4_frame_decoded_flag = 0 ; ps_dec -> u2_header_done = 1 ; } }
","<S2SV_ModStart> = e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; }
",external@libmpeg2/a86eb798d077b9b25c8f8c77e3c02c2f287c1ce7,CVE-2017-0587,https://android.googlesource.com/platform/external/libmpeg2/+/a86eb798d077b9b25c8f8c77e3c02c2f287c1ce7,2017-05-12T15:29Z,"<S2SV_StartBug> impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; <S2SV_EndBug>"
6254,CWE-863,"static int do_misc_fixups ( struct bpf_verifier_env * env ) { struct bpf_prog * prog = env -> prog ; bool expect_blinding = bpf_jit_blinding_enabled ( prog ) ; struct bpf_insn * insn = prog -> insnsi ; const struct bpf_func_proto * fn ; const int insn_cnt = prog -> len ; const struct bpf_map_ops * ops ; struct bpf_insn_aux_data * aux ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_prog * new_prog ; struct bpf_map * map_ptr ; int i , ret , cnt , delta = 0 ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( insn -> code == ( BPF_ALU64 | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) { bool is64 = BPF_CLASS ( insn -> code ) == BPF_ALU64 ; bool isdiv = BPF_OP ( insn -> code ) == BPF_DIV ; struct bpf_insn * patchlet ; struct bpf_insn chk_and_div [ ] = { BPF_RAW_INSN ( ( is64 ? BPF_JMP : BPF_JMP32 ) | BPF_JNE | BPF_K , insn -> src_reg , 0 , 2 , 0 ) , BPF_ALU32_REG ( BPF_XOR , insn -> dst_reg , insn -> dst_reg ) , BPF_JMP_IMM ( BPF_JA , 0 , 0 , 1 ) , * insn , } ; struct bpf_insn chk_and_mod [ ] = { BPF_RAW_INSN ( ( is64 ? BPF_JMP : BPF_JMP32 ) | BPF_JEQ | BPF_K , insn -> src_reg , 0 , 1 + ( is64 ? 0 : 1 ) , 0 ) , * insn , BPF_JMP_IMM ( BPF_JA , 0 , 0 , 1 ) , BPF_MOV32_REG ( insn -> dst_reg , insn -> dst_reg ) , } ; patchlet = isdiv ? chk_and_div : chk_and_mod ; cnt = isdiv ? ARRAY_SIZE ( chk_and_div ) : ARRAY_SIZE ( chk_and_mod ) - ( is64 ? 2 : 0 ) ; new_prog = bpf_patch_insn_data ( env , i + delta , patchlet , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( BPF_CLASS ( insn -> code ) == BPF_LD && ( BPF_MODE ( insn -> code ) == BPF_ABS || BPF_MODE ( insn -> code ) == BPF_IND ) ) { cnt = env -> ops -> gen_ld_abs ( insn , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ; struct bpf_insn * patch = & insn_buf [ 0 ] ; <S2SV_StartBug> bool issrc , isneg ; <S2SV_EndBug> u32 off_reg ; aux = & env -> insn_aux_data [ i + delta ] ; if ( ! aux -> alu_state || aux -> alu_state == BPF_ALU_NON_POINTER ) continue ; isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ; issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ; <S2SV_StartBug> off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; <S2SV_EndBug> <S2SV_StartBug> if ( isneg ) <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> if ( ! issrc ) * patch ++ = BPF_MOV64_REG ( insn -> dst_reg , insn -> src_reg ) ; insn -> src_reg = BPF_REG_AX ; if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; <S2SV_StartBug> if ( issrc && isneg ) <S2SV_EndBug> * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; cnt = patch - insn_buf ; new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> src_reg == BPF_PSEUDO_KFUNC_CALL ) { ret = fixup_kfunc_call ( env , insn ) ; if ( ret ) return ret ; continue ; } if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; if ( ! allow_tail_call_in_subprogs ( env ) ) prog -> aux -> stack_depth = MAX_BPF_STACK ; prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; aux = & env -> insn_aux_data [ i + delta ] ; if ( env -> bpf_capable && ! expect_blinding && prog -> jit_requested && ! bpf_map_key_poisoned ( aux ) && ! bpf_map_ptr_poisoned ( aux ) && ! bpf_map_ptr_unpriv ( aux ) ) { struct bpf_jit_poke_descriptor desc = { . reason = BPF_POKE_REASON_TAIL_CALL , . tail_call . map = BPF_MAP_PTR ( aux -> map_ptr_state ) , . tail_call . key = bpf_map_key_immediate ( aux ) , . insn_idx = i + delta , } ; ret = bpf_jit_add_poke_descriptor ( prog , & desc ) ; if ( ret < 0 ) { verbose ( env , ""adding<S2SV_blank>tail<S2SV_blank>call<S2SV_blank>poke<S2SV_blank>descriptor<S2SV_blank>failed\\n"" ) ; return ret ; } insn -> imm = ret + 1 ; continue ; } if ( ! bpf_map_ptr_unpriv ( aux ) ) continue ; if ( bpf_map_ptr_poisoned ( aux ) ) { verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\n"" ) ; return - EINVAL ; } map_ptr = BPF_MAP_PTR ( aux -> map_ptr_state ) ; insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem || insn -> imm == BPF_FUNC_redirect_map ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = BPF_MAP_PTR ( aux -> map_ptr_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == - EOPNOTSUPP ) goto patch_map_ops_generic ; if ( cnt <= 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem , ( void * ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_delete_elem , ( int ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_update_elem , ( int ( * ) ( struct bpf_map * map , void * key , void * value , u64 flags ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_push_elem , ( int ( * ) ( struct bpf_map * map , void * value , u64 flags ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_pop_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_peek_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_redirect , ( int ( * ) ( struct bpf_map * map , u32 ifindex , u64 flags ) ) NULL ) ) ; patch_map_ops_generic : switch ( insn -> imm ) { case BPF_FUNC_map_lookup_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_lookup_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_update_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_update_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_delete_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_delete_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_push_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_push_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_pop_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_pop_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_peek_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_peek_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_redirect_map : insn -> imm = BPF_CAST_CALL ( ops -> map_redirect ) - __bpf_call_base ; continue ; } goto patch_call_imm ; } if ( prog -> jit_requested && BITS_PER_LONG == 64 && insn -> imm == BPF_FUNC_jiffies64 ) { struct bpf_insn ld_jiffies_addr [ 2 ] = { BPF_LD_IMM64 ( BPF_REG_0 , ( unsigned long ) & jiffies ) , } ; insn_buf [ 0 ] = ld_jiffies_addr [ 0 ] ; insn_buf [ 1 ] = ld_jiffies_addr [ 1 ] ; insn_buf [ 2 ] = BPF_LDX_MEM ( BPF_DW , BPF_REG_0 , BPF_REG_0 , 0 ) ; cnt = 3 ; new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } patch_call_imm : fn = env -> ops -> get_func_proto ( insn -> imm , env -> prog ) ; if ( ! fn -> func ) { verbose ( env , ""kernel<S2SV_blank>subsystem<S2SV_blank>misconfigured<S2SV_blank>func<S2SV_blank>%s#%d\\n"" , func_id_name ( insn -> imm ) , insn -> imm ) ; return - EFAULT ; } insn -> imm = fn -> func - __bpf_call_base ; } for ( i = 0 ; i < prog -> aux -> size_poke_tab ; i ++ ) { map_ptr = prog -> aux -> poke_tab [ i ] . tail_call . map ; if ( ! map_ptr -> ops -> map_poke_track || ! map_ptr -> ops -> map_poke_untrack || ! map_ptr -> ops -> map_poke_run ) { verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n"" ) ; return - EINVAL ; } ret = map_ptr -> ops -> map_poke_track ( map_ptr , prog -> aux ) ; if ( ret < 0 ) { verbose ( env , ""tracking<S2SV_blank>tail<S2SV_blank>call<S2SV_blank>prog<S2SV_blank>failed\\n"" ) ; return ret ; } } sort_kfunc_descs_by_imm ( env -> prog ) ; return 0 ; }
","<S2SV_ModStart> issrc , isneg , isimm <S2SV_ModStart> == BPF_ALU_SANITIZE_SRC ; isimm = aux -> alu_state & BPF_ALU_IMMEDIATE ; <S2SV_ModStart> ; if ( isimm ) { <S2SV_ModEnd> * patch ++ <S2SV_ModStart> patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ; } else { if ( isneg ) <S2SV_ModEnd> * patch ++ <S2SV_ModStart> patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 <S2SV_ModEnd> ) ; * <S2SV_ModStart> patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit <S2SV_ModEnd> ) ; * <S2SV_ModStart> = BPF_ALU64_REG ( BPF_SUB <S2SV_ModEnd> , BPF_REG_AX , <S2SV_ModStart> patch ++ = BPF_ALU64_REG ( BPF_OR <S2SV_ModEnd> , BPF_REG_AX , <S2SV_ModStart> , BPF_REG_AX , off_reg <S2SV_ModEnd> ) ; * <S2SV_ModStart> = BPF_ALU64_IMM ( BPF_NEG <S2SV_ModEnd> , BPF_REG_AX , <S2SV_ModStart> , BPF_REG_AX , 0 <S2SV_ModEnd> ) ; * <S2SV_ModStart> patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; * patch ++ = <S2SV_ModStart> off_reg ) ; } <S2SV_ModStart> issrc && isneg && ! isimm
",torvalds@linux/801c6058d14a82179a7ee17a4b532cac6fad067f,CVE-2021-31829,https://github.com/torvalds/linux/commit/801c6058d14a82179a7ee17a4b532cac6fad067f,2021-05-06T16:15Z,"<S2SV_StartBug> bool issrc , isneg ; <S2SV_EndBug> <S2SV_StartBug> off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; <S2SV_EndBug> <S2SV_StartBug> if ( isneg ) <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> if ( issrc && isneg ) <S2SV_EndBug>"
5847,CWE-59,"int mingw_rmdir ( const char * pathname ) { int ret , tries = 0 ; wchar_t wpathname [ MAX_PATH ] ; if ( xutftowcs_path ( wpathname , pathname ) < 0 ) return - 1 ; while ( ( ret = _wrmdir ( wpathname ) ) == - 1 && tries < ARRAY_SIZE ( delay ) ) { if ( ! is_file_in_use_error ( GetLastError ( ) ) ) errno = err_win_to_posix ( GetLastError ( ) ) ; if ( errno != EACCES ) break ; if ( ! is_dir_empty ( wpathname ) ) { errno = ENOTEMPTY ; break ; } Sleep ( delay [ tries ] ) ; tries ++ ; } while ( ret == - 1 && errno == EACCES && is_file_in_use_error ( GetLastError ( ) ) && ask_yes_no_if_possible ( ""Deletion<S2SV_blank>of<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>failed.<S2SV_blank>"" ""Should<S2SV_blank>I<S2SV_blank>try<S2SV_blank>again?"" , pathname ) ) ret = _wrmdir ( wpathname ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> wpathname ) ; if ( ! ret ) invalidate_lstat_cache ( ) ;
",git@git/684dd4c2b414bcf648505e74498a608f28de4592,CVE-2021-21300,https://github.com/git/git/commit/684dd4c2b414bcf648505e74498a608f28de4592,2021-03-09T20:15Z,<S2SV_StartBug> return ret ; <S2SV_EndBug>
1314,CWE-59,"static int mount_entry_on_relative_rootfs ( struct mntent * mntent , const char * rootfs ) { char path [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/%s"" , rootfs , mntent -> mnt_dir ) ; if ( ret >= sizeof ( path ) ) { ERROR ( ""path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } <S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> }
","<S2SV_ModStart> mntent , path , rootfs
",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug>"
2062,CWE-119,"static copyFunc pickCopyFunc ( TIFF * in , TIFF * out , uint16 bitspersample , uint16 samplesperpixel ) { uint16 shortv ; uint32 w , l , tw , tl ; int bychunk ; <S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug> if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>different<S2SV_blank>planar<S2SV_blank>configuration<S2SV_blank>w/<S2SV_blank>bits/sample<S2SV_blank>!=<S2SV_blank>8\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & w ) ; TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & l ) ; if ( ! ( TIFFIsTiled ( out ) || TIFFIsTiled ( in ) ) ) { uint32 irps = ( uint32 ) - 1L ; TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & irps ) ; bychunk = ! bias && ( rowsperstrip == irps ) ; } else { if ( bias ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>tiled<S2SV_blank>configuration<S2SV_blank>w/bias<S2SV_blank>image\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } if ( TIFFIsTiled ( out ) ) { if ( ! TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ) tw = w ; if ( ! TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ) tl = l ; bychunk = ( tw == tilewidth && tl == tilelength ) ; } else { TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; bychunk = ( tw == w && tl == rowsperstrip ) ; } } # define T 1 # define F 0 # define pack ( a , b , c , d , e ) ( ( long ) ( ( ( a ) << 11 ) | ( ( b ) << 3 ) | ( ( c ) << 2 ) | ( ( d ) << 1 ) | ( e ) ) ) switch ( pack ( shortv , config , TIFFIsTiled ( in ) , TIFFIsTiled ( out ) , bychunk ) ) { case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , T ) : return cpContigStrips2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , T ) : return cpContigStrips2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , T ) : return cpSeparateStrips2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , T ) : return cpSeparateStrips2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , T ) : return cpContigTiles2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , T ) : return cpContigTiles2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , T ) : return cpSeparateTiles2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , T ) : return cpSeparateTiles2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , T ) : return cpContigTiles2ContigStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , T ) : return cpContigTiles2SeparateStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , T ) : return cpSeparateTiles2ContigStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , T ) : return cpSeparateTiles2SeparateStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , F ) : return bias ? cpBiasedContig2Contig : cpContig2ContigByRow ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , T ) : return cpDecodedStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , T ) : return cpContig2SeparateByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , T ) : return cpSeparate2ContigByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , T ) : return cpSeparate2SeparateByRow ; } # undef pack # undef F # undef T fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>copy/convert<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; }
","<S2SV_ModStart> ( void ) TIFFGetFieldDefaulted <S2SV_ModEnd> ( in ,
",vadz@libtiff/5c080298d59efa53264d7248bbe3a04660db6ef7,CVE-2017-5225,https://github.com/vadz/libtiff/commit/5c080298d59efa53264d7248bbe3a04660db6ef7,2017-01-12T11:59Z,"<S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug>"
7308,CWE-125,"static void parse_sec_attr_44 ( sc_file_t * file , const u8 * buf , size_t len ) { const int df_idx [ 8 ] = { SC_AC_OP_DELETE , SC_AC_OP_CREATE , SC_AC_OP_CREATE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , SC_AC_OP_LOCK , SC_AC_OP_DELETE , - 1 } ; const int ef_idx [ 8 ] = { SC_AC_OP_READ , SC_AC_OP_UPDATE , SC_AC_OP_WRITE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , - 1 , SC_AC_OP_ERASE , - 1 } ; const int efi_idx [ 8 ] = { SC_AC_OP_READ , SC_AC_OP_ERASE , SC_AC_OP_UPDATE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , - 1 , SC_AC_OP_ERASE , - 1 } ; u8 bValue ; int i ; int iKeyRef = 0 ; int iMethod ; int iPinCount ; int iOffset = 0 ; int iOperation ; const int * p_idx ; while ( len > 1 ) { size_t iACLen = buf [ iOffset ] & 0x0F ; if ( iACLen > len ) break ; iMethod = SC_AC_NONE ; if ( buf [ iOffset ] & 0X80 ) { size_t iParmLen = 1 ; size_t iKeyLen = 0 ; if ( buf [ iOffset ] & 0x20 ) iKeyLen ++ ; if ( buf [ iOffset + 1 ] & 0x40 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x20 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x10 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x08 ) iParmLen ++ ; if ( iKeyLen ) { int iSC ; if ( len < 1 + ( size_t ) iACLen ) break ; iSC = buf [ iOffset + iACLen ] ; switch ( ( iSC >> 5 ) & 0x03 ) { case 0 : iMethod = SC_AC_TERM ; break ; case 1 : iMethod = SC_AC_AUT ; break ; case 2 : case 3 : iMethod = SC_AC_PRO ; break ; } iKeyRef = iSC & 0x1F ; } if ( iACLen > ( 1 + iParmLen + iKeyLen ) ) { if ( len < 1 + 1 + 1 + ( size_t ) iParmLen ) break ; iKeyRef = buf [ iOffset + 1 + 1 + iParmLen ] ; iMethod = SC_AC_CHV ; } if ( len < 1 + 2 ) break ; switch ( buf [ iOffset + 2 ] ) { case 0x2A : iOperation = SC_AC_OP_CRYPTO ; break ; case 0x46 : iOperation = SC_AC_OP_UPDATE ; break ; default : iOperation = SC_AC_OP_SELECT ; break ; } sc_file_add_acl_entry ( file , iOperation , iMethod , iKeyRef ) ; } else { switch ( file -> type ) { case SC_FILE_TYPE_DF : p_idx = df_idx ; break ; case SC_FILE_TYPE_INTERNAL_EF : p_idx = efi_idx ; break ; default : p_idx = ef_idx ; break ; } <S2SV_StartBug> iPinCount = iACLen - 1 ; <S2SV_EndBug> if ( buf [ iOffset ] & 0x20 ) { int iSC ; if ( len < 1 + ( size_t ) iACLen ) break ; iSC = buf [ iOffset + iACLen ] ; switch ( ( iSC >> 5 ) & 0x03 ) { case 0 : iMethod = SC_AC_TERM ; break ; case 1 : iMethod = SC_AC_AUT ; break ; case 2 : case 3 : iMethod = SC_AC_PRO ; break ; } iKeyRef = iSC & 0x1F ; iPinCount -- ; } if ( iPinCount > 0 ) { if ( len < 1 + 2 ) break ; iKeyRef = buf [ iOffset + 2 ] ; iMethod = SC_AC_CHV ; } bValue = buf [ iOffset + 1 ] ; for ( i = 0 ; i < 8 ; i ++ ) { if ( ( bValue & 1 ) && ( p_idx [ i ] >= 0 ) ) sc_file_add_acl_entry ( file , p_idx [ i ] , iMethod , iKeyRef ) ; bValue >>= 1 ; } } iOffset += iACLen + 1 ; len -= iACLen + 1 ; } }
","<S2SV_ModStart> iPinCount = iACLen > 0 ? iACLen - 1 : 0 <S2SV_ModEnd> ; if (
",OpenSC@OpenSC/c3f23b836e5a1766c36617fe1da30d22f7b63de2,CVE-2019-19479,https://github.com/OpenSC/OpenSC/commit/c3f23b836e5a1766c36617fe1da30d22f7b63de2,2019-12-01T23:15Z,<S2SV_StartBug> iPinCount = iACLen - 1 ; <S2SV_EndBug>
1766,CWE-119,"static void first_pass_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const MV * ref_mv , MV * best_mv , int * best_motion_err ) { MACROBLOCKD * const xd = & x -> e_mbd ; MV tmp_mv = { 0 , 0 } ; MV ref_mv_full = { ref_mv -> row >> 3 , ref_mv -> col >> 3 } ; <S2SV_StartBug> int num00 , tmp_err , n , sr = 0 ; <S2SV_EndBug> int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ bsize ] ; <S2SV_StartBug> int new_mv_mode_penalty = 256 ; <S2SV_EndBug> <S2SV_StartBug> const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ; <S2SV_EndBug> while ( ( quart_frm << sr ) < MAX_FULL_PEL_VAL ) ++ sr ; step_param += sr ; further_steps -= sr ; v_fn_ptr . vf = get_block_variance_fn ( bsize ) ; <S2SV_StartBug> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <S2SV_EndBug> step_param , <S2SV_StartBug> x -> sadperbit16 , & num00 , & v_fn_ptr , <S2SV_EndBug> x -> nmvjointcost , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; <S2SV_StartBug> best_mv -> row = tmp_mv . row ; <S2SV_EndBug> best_mv -> col = tmp_mv . col ; } n = num00 ; num00 = 0 ; while ( n < further_steps ) { ++ n ; if ( num00 ) { -- num00 ; } else { <S2SV_StartBug> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <S2SV_EndBug> step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , <S2SV_StartBug> x -> nmvjointcost , <S2SV_EndBug> x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; <S2SV_StartBug> best_mv -> row = tmp_mv . row ; <S2SV_EndBug> best_mv -> col = tmp_mv . col ; } } } }
","<S2SV_ModStart> tmp_err , n <S2SV_ModEnd> ; const BLOCK_SIZE <S2SV_ModStart> bsize ] ; const <S2SV_ModStart> int new_mv_mode_penalty = NEW_MV_MODE_PENALTY ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param <S2SV_ModEnd> ; const int <S2SV_ModStart> ; const int sr = get_search_range ( cpi ) <S2SV_ModEnd> ; step_param += <S2SV_ModStart> bsize ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { v_fn_ptr . vf = highbd_get_block_variance_fn ( bsize , xd -> bd ) ; } # endif <S2SV_ModStart> x , & cpi -> ss_cfg , & <S2SV_ModStart> , & v_fn_ptr <S2SV_ModEnd> , ref_mv ) <S2SV_ModStart> = tmp_err ; * best_mv = tmp_mv <S2SV_ModEnd> ; } n <S2SV_ModStart> diamond_search_sad ( x , & cpi -> ss_cfg <S2SV_ModStart> & v_fn_ptr , <S2SV_ModEnd> ref_mv ) ; <S2SV_ModStart> = tmp_err ; * best_mv = tmp_mv <S2SV_ModEnd> ; } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int num00 , tmp_err , n , sr = 0 ; <S2SV_EndBug> <S2SV_StartBug> int new_mv_mode_penalty = 256 ; <S2SV_EndBug> <S2SV_StartBug> const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ; <S2SV_EndBug> <S2SV_StartBug> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <S2SV_EndBug> <S2SV_StartBug> x -> sadperbit16 , & num00 , & v_fn_ptr , <S2SV_EndBug> <S2SV_StartBug> best_mv -> row = tmp_mv . row ; <S2SV_EndBug> <S2SV_StartBug> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <S2SV_EndBug> <S2SV_StartBug> x -> nmvjointcost , <S2SV_EndBug> <S2SV_StartBug> best_mv -> row = tmp_mv . row ; <S2SV_EndBug>"
7829,CWE-20,"error_t coapClientSetTxBlockSize ( CoapClientRequest * request , uint_t blockSize ) { if ( request == NULL ) return ERROR_INVALID_PARAMETER ; osAcquireMutex ( & request -> context -> mutex ) ; if ( blockSize == 16 ) <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> if ( request -> txBlockSzx > coapClientGetMaxBlockSize ( ) ) <S2SV_StartBug> request -> txBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug> osReleaseMutex ( & request -> context -> mutex ) ; return NO_ERROR ; }
","<S2SV_ModStart> == 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_16 ; } <S2SV_ModStart> == 32 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> == 64 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_64 ; } <S2SV_ModStart> == 128 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_128 ; } <S2SV_ModStart> == 256 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_256 ; } <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_512 ; } else { <S2SV_ModEnd> request -> txBlockSzx <S2SV_ModStart> = COAP_BLOCK_SIZE_1024 ; } <S2SV_ModStart> ( ) ) { <S2SV_ModStart> ( ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug>
6636,CWE-119,"int commonio_sort ( struct commonio_db * db , int ( * cmp ) ( const void * , const void * ) ) { struct commonio_entry * * entries , * ptr ; size_t n = 0 , i ; # if KEEP_NIS_AT_END struct commonio_entry * nis = NULL ; # endif for ( ptr = db -> head ; ( NULL != ptr ) # if KEEP_NIS_AT_END <S2SV_StartBug> && ( NULL != ptr -> line ) <S2SV_EndBug> <S2SV_StartBug> && ( ( '+' != ptr -> line [ 0 ] ) <S2SV_EndBug> <S2SV_StartBug> && ( '-' != ptr -> line [ 0 ] ) ) <S2SV_EndBug> # endif ; ptr = ptr -> next ) { n ++ ; } # if KEEP_NIS_AT_END <S2SV_StartBug> if ( ( NULL != ptr ) && ( NULL != ptr -> line ) ) { <S2SV_EndBug> nis = ptr ; } # endif if ( n <= 1 ) { return 0 ; } entries = malloc ( n * sizeof ( struct commonio_entry * ) ) ; if ( entries == NULL ) { return - 1 ; } n = 0 ; for ( ptr = db -> head ; # if KEEP_NIS_AT_END nis != ptr ; # else NULL != ptr ; # endif ptr = ptr -> next ) { entries [ n ] = ptr ; n ++ ; } qsort ( entries , n , sizeof ( struct commonio_entry * ) , cmp ) ; db -> head = entries [ 0 ] ; n -- ; # if KEEP_NIS_AT_END if ( NULL == nis ) # endif { db -> tail = entries [ n ] ; } db -> head -> prev = NULL ; db -> head -> next = entries [ 1 ] ; entries [ n ] -> prev = entries [ n - 1 ] ; # if KEEP_NIS_AT_END entries [ n ] -> next = nis ; # else entries [ n ] -> next = NULL ; # endif for ( i = 1 ; i < n ; i ++ ) { entries [ i ] -> prev = entries [ i - 1 ] ; entries [ i ] -> next = entries [ i + 1 ] ; } free ( entries ) ; db -> changed = true ; return 0 ; }
","<S2SV_ModStart> KEEP_NIS_AT_END && ( ( NULL == <S2SV_ModEnd> ptr -> line <S2SV_ModStart> -> line ) || ( ( '+' != ptr -> line [ 0 ] ) && ( '-' <S2SV_ModEnd> != ptr -> <S2SV_ModStart> 0 ] ) <S2SV_ModEnd> ) ) # <S2SV_ModStart> KEEP_NIS_AT_END if ( NULL != ptr <S2SV_ModEnd> ) { nis
",shadow-maint@shadow/954e3d2e7113e9ac06632aee3c69b8d818cc8952,CVE-2017-12424,https://github.com/shadow-maint/shadow/commit/954e3d2e7113e9ac06632aee3c69b8d818cc8952,2017-08-04T09:29Z,<S2SV_StartBug> && ( NULL != ptr -> line ) <S2SV_EndBug> <S2SV_StartBug> && ( ( '+' != ptr -> line [ 0 ] ) <S2SV_EndBug> <S2SV_StartBug> && ( '-' != ptr -> line [ 0 ] ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( NULL != ptr ) && ( NULL != ptr -> line ) ) { <S2SV_EndBug>
5415,CWE-401,"static int __ipmi_bmc_register ( struct ipmi_smi * intf , struct ipmi_device_id * id , bool guid_set , guid_t * guid , int intf_num ) { int rv ; struct bmc_device * bmc ; struct bmc_device * old_bmc ; intf -> in_bmc_register = true ; mutex_unlock ( & intf -> bmc_reg_mutex ) ; mutex_lock ( & ipmidriver_mutex ) ; if ( guid_set ) old_bmc = ipmi_find_bmc_guid ( & ipmidriver . driver , guid ) ; else old_bmc = ipmi_find_bmc_prod_dev_id ( & ipmidriver . driver , id -> product_id , id -> device_id ) ; if ( old_bmc ) { bmc = old_bmc ; intf -> bmc = old_bmc ; mutex_lock ( & bmc -> dyn_mutex ) ; list_add_tail ( & intf -> bmc_link , & bmc -> intfs ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; dev_info ( intf -> si_dev , ""interfacing<S2SV_blank>existing<S2SV_blank>BMC<S2SV_blank>(man_id:<S2SV_blank>0x%6.6x,<S2SV_blank>prod_id:<S2SV_blank>0x%4.4x,<S2SV_blank>dev_id:<S2SV_blank>0x%2.2x)\\n"" , bmc -> id . manufacturer_id , bmc -> id . product_id , bmc -> id . device_id ) ; } else { bmc = kzalloc ( sizeof ( * bmc ) , GFP_KERNEL ) ; if ( ! bmc ) { rv = - ENOMEM ; goto out ; } INIT_LIST_HEAD ( & bmc -> intfs ) ; mutex_init ( & bmc -> dyn_mutex ) ; INIT_WORK ( & bmc -> remove_work , cleanup_bmc_work ) ; bmc -> id = * id ; bmc -> dyn_id_set = 1 ; bmc -> dyn_guid_set = guid_set ; bmc -> guid = * guid ; bmc -> dyn_id_expiry = jiffies + IPMI_DYN_DEV_ID_EXPIRY ; bmc -> pdev . name = ""ipmi_bmc"" ; rv = ida_simple_get ( & ipmi_bmc_ida , 0 , 0 , GFP_KERNEL ) ; <S2SV_StartBug> if ( rv < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> bmc -> pdev . dev . driver = & ipmidriver . driver ; bmc -> pdev . id = rv ; bmc -> pdev . dev . release = release_bmc_device ; bmc -> pdev . dev . type = & bmc_device_type ; kref_init ( & bmc -> usecount ) ; intf -> bmc = bmc ; mutex_lock ( & bmc -> dyn_mutex ) ; list_add_tail ( & intf -> bmc_link , & bmc -> intfs ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; rv = platform_device_register ( & bmc -> pdev ) ; if ( rv ) { dev_err ( intf -> si_dev , ""Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>bmc<S2SV_blank>device:<S2SV_blank>%d\\n"" , rv ) ; goto out_list_del ; } dev_info ( intf -> si_dev , ""Found<S2SV_blank>new<S2SV_blank>BMC<S2SV_blank>(man_id:<S2SV_blank>0x%6.6x,<S2SV_blank>prod_id:<S2SV_blank>0x%4.4x,<S2SV_blank>dev_id:<S2SV_blank>0x%2.2x)\\n"" , bmc -> id . manufacturer_id , bmc -> id . product_id , bmc -> id . device_id ) ; } rv = sysfs_create_link ( & intf -> si_dev -> kobj , & bmc -> pdev . dev . kobj , ""bmc"" ) ; if ( rv ) { dev_err ( intf -> si_dev , ""Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>bmc<S2SV_blank>symlink:<S2SV_blank>%d\\n"" , rv ) ; goto out_put_bmc ; } if ( intf_num == - 1 ) intf_num = intf -> intf_num ; intf -> my_dev_name = kasprintf ( GFP_KERNEL , ""ipmi%d"" , intf_num ) ; if ( ! intf -> my_dev_name ) { rv = - ENOMEM ; dev_err ( intf -> si_dev , ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>link<S2SV_blank>from<S2SV_blank>BMC:<S2SV_blank>%d\\n"" , rv ) ; goto out_unlink1 ; } rv = sysfs_create_link ( & bmc -> pdev . dev . kobj , & intf -> si_dev -> kobj , intf -> my_dev_name ) ; if ( rv ) { kfree ( intf -> my_dev_name ) ; intf -> my_dev_name = NULL ; dev_err ( intf -> si_dev , ""Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>to<S2SV_blank>bmc:<S2SV_blank>%d\\n"" , rv ) ; goto out_free_my_dev_name ; } intf -> bmc_registered = true ; out : mutex_unlock ( & ipmidriver_mutex ) ; mutex_lock ( & intf -> bmc_reg_mutex ) ; intf -> in_bmc_register = false ; return rv ; out_free_my_dev_name : kfree ( intf -> my_dev_name ) ; intf -> my_dev_name = NULL ; out_unlink1 : sysfs_remove_link ( & intf -> si_dev -> kobj , ""bmc"" ) ; out_put_bmc : mutex_lock ( & bmc -> dyn_mutex ) ; list_del ( & intf -> bmc_link ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; intf -> bmc = & intf -> tmp_bmc ; kref_put ( & bmc -> usecount , cleanup_bmc_device ) ; goto out ; out_list_del : mutex_lock ( & bmc -> dyn_mutex ) ; list_del ( & intf -> bmc_link ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; intf -> bmc = & intf -> tmp_bmc ; put_device ( & bmc -> pdev . dev ) ; goto out ; }
","<S2SV_ModStart> < 0 ) { kfree ( bmc ) ; <S2SV_ModStart> goto out ; }
",torvalds@linux/4aa7afb0ee20a97fbf0c5bab3df028d5fb85fdab,CVE-2019-19046,https://github.com/torvalds/linux/commit/4aa7afb0ee20a97fbf0c5bab3df028d5fb85fdab,2019-11-18T06:15Z,<S2SV_StartBug> if ( rv < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug>
3391,CWE-404,"static int lockd ( void * vrqstp ) { int err = 0 ; <S2SV_StartBug> struct svc_rqst * rqstp = vrqstp ; <S2SV_EndBug> set_freezable ( ) ; allow_signal ( SIGKILL ) ; dprintk ( ""NFS<S2SV_blank>locking<S2SV_blank>service<S2SV_blank>started<S2SV_blank>(ver<S2SV_blank>"" LOCKD_VERSION "").\\n"" ) ; while ( ! kthread_should_stop ( ) ) { long timeout = MAX_SCHEDULE_TIMEOUT ; RPC_IFDEBUG ( char buf [ RPC_MAX_ADDRBUFLEN ] ) ; rqstp -> rq_server -> sv_maxconn = nlm_max_connections ; if ( signalled ( ) ) { flush_signals ( current ) ; restart_grace ( ) ; continue ; } timeout = nlmsvc_retry_blocked ( ) ; err = svc_recv ( rqstp , timeout ) ; if ( err == - EAGAIN || err == - EINTR ) continue ; dprintk ( ""lockd:<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s\\n"" , svc_print_addr ( rqstp , buf , sizeof ( buf ) ) ) ; svc_process ( rqstp ) ; } flush_signals ( current ) ; if ( nlmsvc_ops ) nlmsvc_invalidate_all ( ) ; nlm_shutdown_hosts ( ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> rqstp = vrqstp ; struct net * net = & init_net ; struct lockd_net * ln = net_generic ( net , lockd_net_id ) <S2SV_ModStart> ( ) ; cancel_delayed_work_sync ( & ln -> grace_period_end ) ; locks_end_grace ( & ln -> lockd_manager ) ;
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z,<S2SV_StartBug> struct svc_rqst * rqstp = vrqstp ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>
7902,CWE-20,"error_t ssiProcessExecCommand ( HttpConnection * connection , const char_t * tag , size_t length ) { char_t * separator ; char_t * attribute ; char_t * value ; if ( connection -> settings -> cgiCallback == NULL ) return ERROR_INVALID_TAG ; if ( length < 4 || length >= HTTP_SERVER_BUFFER_SIZE ) return ERROR_INVALID_TAG ; osMemcpy ( connection -> buffer , tag + 4 , length - 4 ) ; connection -> buffer [ length - 4 ] = '\\0' ; <S2SV_StartBug> separator = strchr ( connection -> buffer , '=' ) ; <S2SV_EndBug> if ( ! separator ) return ERROR_INVALID_TAG ; * separator = '\\0' ; attribute = strTrimWhitespace ( connection -> buffer ) ; value = strTrimWhitespace ( separator + 1 ) ; if ( value [ 0 ] == '\\'' || value [ 0 ] == \'\\""\' ) value ++ ; length = osStrlen ( value ) ; if ( length > 0 ) { if ( value [ length - 1 ] == '\\'' || value [ length - 1 ] == \'\\""\' ) value [ length - 1 ] = '\\0' ; } if ( osStrcasecmp ( attribute , ""cgi"" ) && osStrcasecmp ( attribute , ""cmd"" ) && osStrcasecmp ( attribute , ""cmd_argument"" ) ) return ERROR_INVALID_TAG ; if ( osStrlen ( value ) > HTTP_SERVER_CGI_PARAM_MAX_LEN ) return ERROR_INVALID_TAG ; osStrcpy ( connection -> cgiParam , value ) ; return connection -> settings -> cgiCallback ( connection , connection -> cgiParam ) ; }
","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( connection ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> separator = strchr ( connection -> buffer , '=' ) ; <S2SV_EndBug>"
3297,CWE-399,"static int nlmsg_populate_mdb_fill ( struct sk_buff * skb , struct net_device * dev , struct br_mdb_entry * entry , u32 pid , u32 seq , int type , unsigned int flags ) { struct nlmsghdr * nlh ; struct br_port_msg * bpm ; struct nlattr * nest , * nest2 ; nlh = nlmsg_put ( skb , pid , seq , type , sizeof ( * bpm ) , NLM_F_MULTI ) ; if ( ! nlh ) return - EMSGSIZE ; bpm = nlmsg_data ( nlh ) ; <S2SV_StartBug> bpm -> family = AF_BRIDGE ; <S2SV_EndBug> bpm -> ifindex = dev -> ifindex ; nest = nla_nest_start ( skb , MDBA_MDB ) ; if ( nest == NULL ) goto cancel ; nest2 = nla_nest_start ( skb , MDBA_MDB_ENTRY ) ; if ( nest2 == NULL ) goto end ; if ( nla_put ( skb , MDBA_MDB_ENTRY_INFO , sizeof ( * entry ) , entry ) ) goto end ; nla_nest_end ( skb , nest2 ) ; nla_nest_end ( skb , nest ) ; return nlmsg_end ( skb , nlh ) ; end : nla_nest_end ( skb , nest ) ; cancel : nlmsg_cancel ( skb , nlh ) ; return - EMSGSIZE ; }
","<S2SV_ModStart> nlh ) ; memset ( bpm , 0 , sizeof ( * bpm ) ) ;
",torvalds@linux/c085c49920b2f900ba716b4ca1c1a55ece9872cc,CVE-2013-2636,https://github.com/torvalds/linux/commit/c085c49920b2f900ba716b4ca1c1a55ece9872cc,2013-03-22T11:59Z,<S2SV_StartBug> bpm -> family = AF_BRIDGE ; <S2SV_EndBug>
1837,CWE-119,"static int check_best_zero_mv ( const VP9_COMP * cpi , const uint8_t mode_context [ MAX_REF_FRAMES ] , int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] , <S2SV_StartBug> int disable_inter_mode_mask , int this_mode , int ref_frame , <S2SV_EndBug> int second_ref_frame ) { if ( ! ( disable_inter_mode_mask & ( 1 << INTER_OFFSET ( ZEROMV ) ) ) && ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frame ] . as_int == 0 && ( second_ref_frame == NONE || <S2SV_StartBug> frame_mv [ this_mode ] [ second_ref_frame ] . as_int == 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> int rfc = mode_context [ ref_frame ] ; <S2SV_EndBug> int c1 = cost_mv_ref ( cpi , NEARMV , rfc ) ; int c2 = cost_mv_ref ( cpi , NEARESTMV , rfc ) ; int c3 = cost_mv_ref ( cpi , ZEROMV , rfc ) ; if ( this_mode == NEARMV ) { if ( c1 > c3 ) return 0 ; } else if ( this_mode == NEARESTMV ) { if ( c2 > c3 ) return 0 ; } else { assert ( this_mode == ZEROMV ) ; <S2SV_StartBug> if ( second_ref_frame == NONE ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 ) || <S2SV_EndBug> <S2SV_StartBug> ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 ) ) <S2SV_EndBug> return 0 ; } else { <S2SV_StartBug> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 && <S2SV_EndBug> frame_mv [ NEARESTMV ] [ second_ref_frame ] . as_int == 0 ) || <S2SV_StartBug> ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 && <S2SV_EndBug> frame_mv [ NEARMV ] [ second_ref_frame ] . as_int == 0 ) ) return 0 ; } } } return 1 ; }
","<S2SV_ModStart> MAX_REF_FRAMES ] , int this_mode , const MV_REFERENCE_FRAME ref_frames [ 2 ] ) { if ( ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frames [ 0 ] ] . as_int == 0 && ( ref_frames [ 1 ] <S2SV_ModEnd> == NONE || <S2SV_ModStart> this_mode ] [ ref_frames [ 1 ] <S2SV_ModEnd> ] . as_int <S2SV_ModStart> = mode_context [ ref_frames [ 0 ] <S2SV_ModEnd> ] ; int <S2SV_ModStart> ; if ( ref_frames [ 1 ] <S2SV_ModEnd> == NONE ) <S2SV_ModStart> NEARESTMV ] [ ref_frames [ 0 ] <S2SV_ModEnd> ] . as_int <S2SV_ModStart> NEARMV ] [ ref_frames [ 0 ] <S2SV_ModEnd> ] . as_int <S2SV_ModStart> NEARESTMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARESTMV ] [ ref_frames [ 1 ] <S2SV_ModEnd> ] . as_int <S2SV_ModStart> NEARMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARMV ] [ ref_frames [ 1 ] <S2SV_ModEnd> ] . as_int
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int disable_inter_mode_mask , int this_mode , int ref_frame , <S2SV_EndBug> <S2SV_StartBug> frame_mv [ this_mode ] [ second_ref_frame ] . as_int == 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> int rfc = mode_context [ ref_frame ] ; <S2SV_EndBug> <S2SV_StartBug> if ( second_ref_frame == NONE ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 ) || <S2SV_EndBug> <S2SV_StartBug> ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 && <S2SV_EndBug> <S2SV_StartBug> ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 && <S2SV_EndBug>"
2157,CWE-362,"void sctp_generate_t3_rtx_event ( unsigned long peer ) { int error ; struct sctp_transport * transport = ( struct sctp_transport * ) peer ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> T3_rtx_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_T3_RTX ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_transport_put ( transport ) ; }
","<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
",torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e,CVE-2015-8767,https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e,2016-02-08T03:59Z,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug>
944,CWE-264,"static int rd_build_device_space ( struct rd_dev * rd_dev ) { <S2SV_StartBug> u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ; <S2SV_EndBug> u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / sizeof ( struct scatterlist ) ) ; <S2SV_StartBug> struct rd_dev_sg_table * sg_table ; <S2SV_EndBug> struct page * pg ; struct scatterlist * sg ; if ( rd_dev -> rd_page_count <= 0 ) { pr_err ( ""Illegal<S2SV_blank>page<S2SV_blank>count:<S2SV_blank>%u<S2SV_blank>for<S2SV_blank>Ramdisk<S2SV_blank>device\\n"" , rd_dev -> rd_page_count ) ; return - EINVAL ; } if ( rd_dev -> rd_flags & RDF_NULLIO ) return 0 ; total_sg_needed = rd_dev -> rd_page_count ; sg_tables = ( total_sg_needed / max_sg_per_table ) + 1 ; sg_table = kzalloc ( sg_tables * sizeof ( struct rd_dev_sg_table ) , GFP_KERNEL ) ; if ( ! sg_table ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Ramdisk"" ""<S2SV_blank>scatterlist<S2SV_blank>tables\\n"" ) ; return - ENOMEM ; } rd_dev -> sg_table_array = sg_table ; rd_dev -> sg_table_count = sg_tables ; <S2SV_StartBug> while ( total_sg_needed ) { <S2SV_EndBug> sg_per_table = ( total_sg_needed > max_sg_per_table ) ? max_sg_per_table : total_sg_needed ; sg = kzalloc ( sg_per_table * sizeof ( struct scatterlist ) , GFP_KERNEL ) ; if ( ! sg ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist<S2SV_blank>array"" ""<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev\\n"" ) ; return - ENOMEM ; } sg_init_table ( sg , sg_per_table ) ; sg_table [ i ] . sg_table = sg ; sg_table [ i ] . rd_sg_count = sg_per_table ; sg_table [ i ] . page_start_offset = page_offset ; sg_table [ i ++ ] . page_end_offset = ( page_offset + sg_per_table ) - 1 ; for ( j = 0 ; j < sg_per_table ; j ++ ) { pg = alloc_pages ( GFP_KERNEL , 0 ) ; if ( ! pg ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist"" ""<S2SV_blank>pages<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev_sg_table\\n"" ) ; return - ENOMEM ; } sg_assign_page ( & sg [ j ] , pg ) ; sg [ j ] . length = PAGE_SIZE ; } page_offset += sg_per_table ; total_sg_needed -= sg_per_table ; } pr_debug ( ""CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Built<S2SV_blank>Ramdisk<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>space<S2SV_blank>of"" ""<S2SV_blank>%u<S2SV_blank>pages<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>tables\\n"" , rd_dev -> rd_host -> rd_host_id , rd_dev -> rd_dev_id , rd_dev -> rd_page_count , rd_dev -> sg_table_count ) ; return 0 ; }
","<S2SV_ModStart> rd_dev ) { struct rd_dev_sg_table * sg_table ; u32 <S2SV_ModEnd> sg_tables , total_sg_needed <S2SV_ModStart> ) ) ; int rc <S2SV_ModEnd> ; if ( <S2SV_ModStart> = sg_tables ; rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ; if ( rc ) return rc ; <S2SV_ModEnd> pr_debug ( ""CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Built<S2SV_blank>Ramdisk<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>space<S2SV_blank>of""
",torvalds@linux/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,CVE-2014-4027,https://github.com/torvalds/linux/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,2014-06-23T11:21Z,"<S2SV_StartBug> u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ; <S2SV_EndBug> <S2SV_StartBug> struct rd_dev_sg_table * sg_table ; <S2SV_EndBug> <S2SV_StartBug> while ( total_sg_needed ) { <S2SV_EndBug>"
1425,CWE-119,"static void accumulate_frame_motion_stats ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame , double * this_frame_mv_in_out , double * mv_in_out_accumulator , double * abs_mv_in_out_accumulator , double * mv_ratio_accumulator ) { double this_frame_mvr_ratio ; double this_frame_mvc_ratio ; double motion_pct ; <S2SV_StartBug> motion_pct = this_frame -> pcnt_motion ; <S2SV_EndBug> * this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ; * mv_in_out_accumulator += this_frame -> mv_in_out_count * motion_pct ; * abs_mv_in_out_accumulator += fabs ( this_frame -> mv_in_out_count * motion_pct ) ; if ( motion_pct > 0.05 ) { this_frame_mvr_ratio = fabs ( this_frame -> mvr_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVr ) ) ; this_frame_mvc_ratio = fabs ( this_frame -> mvc_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVc ) ) ; * mv_ratio_accumulator += ( this_frame_mvr_ratio < this_frame -> mvr_abs ) ? ( this_frame_mvr_ratio * motion_pct ) : this_frame -> mvr_abs * motion_pct ; * mv_ratio_accumulator += ( this_frame_mvc_ratio < this_frame -> mvc_abs ) ? ( this_frame_mvc_ratio * motion_pct ) : this_frame -> mvc_abs * motion_pct ; } }
","<S2SV_ModStart> double motion_pct ; ( void ) cpi ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> motion_pct = this_frame -> pcnt_motion ; <S2SV_EndBug>
5860,CWE-20,"int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown<S2SV_blank>command<S2SV_blank>\'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation<S2SV_blank>not<S2SV_blank>permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>when<S2SV_blank>used<S2SV_blank>memory<S2SV_blank>><S2SV_blank>\'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only<S2SV_blank>(P)SUBSCRIBE<S2SV_blank>/<S2SV_blank>(P)UNSUBSCRIBE<S2SV_blank>/<S2SV_blank>QUIT<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link<S2SV_blank>with<S2SV_blank>MASTER<S2SV_blank>is<S2SV_blank>down<S2SV_blank>and<S2SV_blank>slave-serve-stale-data<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { <S2SV_StartBug> if ( server . vm_enabled && server . vm_max_threads > 0 && <S2SV_EndBug> blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
","<S2SV_ModStart> ( server . ds_enabled && <S2SV_ModEnd> blockClientOnSwappedKeys ( c
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,<S2SV_StartBug> if ( server . vm_enabled && server . vm_max_threads > 0 && <S2SV_EndBug>
2355,CWE-119,"static void * load_bytes ( RBinFile * arch , const ut8 * buf , ut64 sz , ut64 loaddr , Sdb * sdb ) { if ( ! buf || ! sz || sz == UT64_MAX ) { return NULL ; } RBuffer * tbuf = r_buf_new ( ) ; <S2SV_StartBug> r_buf_set_bytes ( tbuf , buf , sz ) ; <S2SV_EndBug> struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ; r_buf_free ( tbuf ) ; return res ? res : NULL ; }
","<S2SV_ModStart> ( ) ; if ( ! tbuf ) { return NULL ; }
",radare@radare2/72794dc3523bbd5bb370de3c5857cb736c387e18,CVE-2017-6194,https://github.com/radare/radare2/commit/72794dc3523bbd5bb370de3c5857cb736c387e18,2017-04-03T05:59Z,"<S2SV_StartBug> r_buf_set_bytes ( tbuf , buf , sz ) ; <S2SV_EndBug>"
306,CWE-000,"SYSCALL_DEFINE4 ( epoll_ctl , int , epfd , int , op , int , fd , struct epoll_event __user * , event ) { int error ; int did_lock_epmutex = 0 ; struct file * file , * tfile ; struct eventpoll * ep ; struct epitem * epi ; struct epoll_event epds ; error = - EFAULT ; if ( ep_op_has_event ( op ) && copy_from_user ( & epds , event , sizeof ( struct epoll_event ) ) ) goto error_return ; error = - EBADF ; file = fget ( epfd ) ; if ( ! file ) goto error_return ; tfile = fget ( fd ) ; if ( ! tfile ) goto error_fput ; error = - EPERM ; if ( ! tfile -> f_op || ! tfile -> f_op -> poll ) goto error_tgt_fput ; error = - EINVAL ; if ( file == tfile || ! is_file_epoll ( file ) ) goto error_tgt_fput ; ep = file -> private_data ; if ( op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL ) { mutex_lock ( & epmutex ) ; did_lock_epmutex = 1 ; } if ( op == EPOLL_CTL_ADD ) { if ( is_file_epoll ( tfile ) ) { error = - ELOOP ; <S2SV_StartBug> if ( ep_loop_check ( ep , tfile ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> goto error_tgt_fput ; <S2SV_EndBug> } else list_add ( & tfile -> f_tfile_llink , & tfile_check_list ) ; } mutex_lock_nested ( & ep -> mtx , 0 ) ; epi = ep_find ( ep , tfile , fd ) ; error = - EINVAL ; switch ( op ) { case EPOLL_CTL_ADD : if ( ! epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_insert ( ep , & epds , tfile , fd ) ; } else error = - EEXIST ; clear_tfile_check_list ( ) ; break ; case EPOLL_CTL_DEL : if ( epi ) error = ep_remove ( ep , epi ) ; else error = - ENOENT ; break ; case EPOLL_CTL_MOD : if ( epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_modify ( ep , epi , & epds ) ; } else error = - ENOENT ; break ; } mutex_unlock ( & ep -> mtx ) ; error_tgt_fput : if ( did_lock_epmutex ) mutex_unlock ( & epmutex ) ; fput ( tfile ) ; error_fput : fput ( file ) ; error_return : return error ; }
","<S2SV_ModStart> != 0 ) { clear_tfile_check_list ( ) ; <S2SV_ModStart> goto error_tgt_fput ; }
",torvalds@linux/13d518074a952d33d47c428419693f63389547e9,CVE-2012-3375,https://github.com/torvalds/linux/commit/13d518074a952d33d47c428419693f63389547e9,2012-10-03T11:02Z,"<S2SV_StartBug> if ( ep_loop_check ( ep , tfile ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> goto error_tgt_fput ; <S2SV_EndBug>"
3867,CWE-362,"int ext4_insert_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; handle_t * handle ; struct ext4_ext_path * path ; struct ext4_extent * extent ; ext4_lblk_t offset_lblk , len_lblk , ee_start_lblk = 0 ; unsigned int credits , ee_len ; int ret = 0 , depth , split_flag = 0 ; loff_t ioffset ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_insert_range ( inode , offset , len ) ; offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; len_lblk = len >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( inode -> i_size + len > inode -> i_sb -> s_maxbytes ) { ret = - EFBIG ; goto out_mutex ; } if ( offset >= i_size_read ( inode ) ) { ret = - EINVAL ; goto out_mutex ; } <S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; credits = ext4_writepage_trans_blocks ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> } inode -> i_size += len ; EXT4_I ( inode ) -> i_disksize += len ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ret = ext4_mark_inode_dirty ( handle , inode ) ; if ( ret ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; path = ext4_find_extent ( inode , offset_lblk , NULL , 0 ) ; if ( IS_ERR ( path ) ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } depth = ext_depth ( inode ) ; extent = path [ depth ] . p_ext ; if ( extent ) { ee_start_lblk = le32_to_cpu ( extent -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( extent ) ; if ( ( offset_lblk > ee_start_lblk ) && ( offset_lblk < ( ee_start_lblk + ee_len ) ) ) { if ( ext4_ext_is_unwritten ( extent ) ) split_flag = EXT4_EXT_MARK_UNWRIT1 | EXT4_EXT_MARK_UNWRIT2 ; ret = ext4_split_extent_at ( handle , inode , & path , offset_lblk , split_flag , EXT4_EX_NOCACHE | EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_METADATA_NOFAIL ) ; } ext4_ext_drop_refs ( path ) ; kfree ( path ) ; if ( ret < 0 ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } } ret = ext4_es_remove_extent ( inode , offset_lblk , EXT_MAX_BLOCKS - offset_lblk ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ret = ext4_ext_shift_extents ( inode , handle , ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk , len_lblk , SHIFT_RIGHT ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; out_stop : ext4_journal_stop ( handle ) ; <S2SV_StartBug> out_dio : <S2SV_EndBug> ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }
","<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ioffset ) ; <S2SV_ModEnd> credits = ext4_writepage_trans_blocks <S2SV_ModStart> ) ; goto out_mmap <S2SV_ModEnd> ; } inode <S2SV_ModStart> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ext4_inode_resume_unlocked_dio ( inode
",torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,CVE-2015-8839,https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,2016-05-02T10:59Z,"<S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> <S2SV_StartBug> out_dio : <S2SV_EndBug>"
3851,CWE-476,"int jp2_box_put ( jp2_box_t * box , jas_stream_t * out ) { jas_stream_t * tmpstream ; bool extlen ; bool dataflag ; tmpstream = 0 ; dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( box -> ops -> putdata ) { if ( ( * box -> ops -> putdata ) ( box , tmpstream ) ) { goto error ; } } box -> len = jas_stream_tell ( tmpstream ) + JP2_BOX_HDRLEN ( false ) ; jas_stream_rewind ( tmpstream ) ; } extlen = ( box -> len >= ( ( ( uint_fast64_t ) 1 ) << 32 ) ) != 0 ; if ( jp2_putuint32 ( out , extlen ? 1 : box -> len ) ) { goto error ; } if ( jp2_putuint32 ( out , box -> type ) ) { goto error ; } if ( extlen ) { if ( jp2_putuint64 ( out , box -> len ) ) { goto error ; } } if ( dataflag ) { <S2SV_StartBug> if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) { <S2SV_EndBug> goto error ; } jas_stream_close ( tmpstream ) ; } return 0 ; error : if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return - 1 ; }
","<S2SV_ModStart> ) ) { jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ;
",mdadams@jasper/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,CVE-2017-6850,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,2017-03-15T14:59Z,"<S2SV_StartBug> if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) { <S2SV_EndBug>"
8315,CWE-120,"int parse_sym_line ( buf , which_set ) char * buf ; int which_set ; { int val , i ; struct symparse * symp ; <S2SV_StartBug> char * bufp , * commentp , * altp ; <S2SV_EndBug> mungspaces ( buf ) ; if ( ( commentp = rindex ( buf , '#' ) ) != 0 && commentp [ - 1 ] == '<S2SV_blank>' ) commentp [ - 1 ] = '\\0' ; bufp = index ( buf , '=' ) ; altp = index ( buf , ':' ) ; if ( ! bufp || ( altp && altp < bufp ) ) bufp = altp ; if ( ! bufp ) { if ( strncmpi ( buf , ""finish"" , 6 ) == 0 ) { if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; return 1 ; } config_error_add ( ""No<S2SV_blank>\\""finish\\"""" ) ; return 0 ; } ++ bufp ; if ( * bufp == '<S2SV_blank>' ) ++ bufp ; symp = match_sym ( buf ) ; if ( ! symp ) { config_error_add ( ""Unknown<S2SV_blank>sym<S2SV_blank>keyword"" ) ; return 0 ; } if ( ! symset [ which_set ] . name ) { if ( symp -> range == SYM_CONTROL ) { struct symsetentry * tmpsp , * lastsp ; for ( lastsp = symset_list ; lastsp ; lastsp = lastsp -> next ) if ( ! lastsp -> next ) break ; switch ( symp -> idx ) { case 0 : tmpsp = ( struct symsetentry * ) alloc ( sizeof * tmpsp ) ; tmpsp -> next = ( struct symsetentry * ) 0 ; if ( ! lastsp ) symset_list = tmpsp ; else lastsp -> next = tmpsp ; tmpsp -> idx = symset_count ++ ; tmpsp -> name = dupstr ( bufp ) ; tmpsp -> desc = ( char * ) 0 ; tmpsp -> handling = H_UNK ; tmpsp -> nocolor = 0 ; tmpsp -> primary = 0 ; tmpsp -> rogue = 0 ; break ; case 2 : tmpsp = lastsp ; for ( i = 0 ; known_handling [ i ] ; ++ i ) if ( ! strcmpi ( known_handling [ i ] , bufp ) ) { tmpsp -> handling = i ; break ; } break ; case 3 : tmpsp = lastsp ; if ( tmpsp && ! tmpsp -> desc ) tmpsp -> desc = dupstr ( bufp ) ; break ; case 5 : tmpsp = lastsp ; for ( i = 0 ; known_restrictions [ i ] ; ++ i ) { if ( ! strcmpi ( known_restrictions [ i ] , bufp ) ) { switch ( i ) { case 0 : tmpsp -> primary = 1 ; break ; case 1 : tmpsp -> rogue = 1 ; break ; } break ; } } break ; } } return 1 ; } if ( symp -> range ) { if ( symp -> range == SYM_CONTROL ) { switch ( symp -> idx ) { case 0 : if ( ! strcmpi ( bufp , symset [ which_set ] . name ) ) { chosen_symset_start = TRUE ; if ( which_set == ROGUESET ) init_rogue_symbols ( ) ; else if ( which_set == PRIMARY ) init_primary_symbols ( ) ; } break ; case 1 : if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; break ; case 2 : if ( chosen_symset_start ) set_symhandling ( bufp , which_set ) ; break ; case 4 : if ( chosen_symset_start ) { if ( bufp ) { if ( ! strcmpi ( bufp , ""true"" ) || ! strcmpi ( bufp , ""yes"" ) || ! strcmpi ( bufp , ""on"" ) ) symset [ which_set ] . nocolor = 0 ; else if ( ! strcmpi ( bufp , ""false"" ) || ! strcmpi ( bufp , ""no"" ) || ! strcmpi ( bufp , ""off"" ) ) symset [ which_set ] . nocolor = 1 ; } } break ; case 5 : if ( chosen_symset_start ) { int n = 0 ; while ( known_restrictions [ n ] ) { if ( ! strcmpi ( known_restrictions [ n ] , bufp ) ) { switch ( n ) { case 0 : symset [ which_set ] . primary = 1 ; break ; case 1 : symset [ which_set ] . rogue = 1 ; break ; } break ; } n ++ ; } } break ; } } else { val = sym_val ( bufp ) ; if ( chosen_symset_start ) { if ( which_set == PRIMARY ) { update_primary_symset ( symp , val ) ; } else if ( which_set == ROGUESET ) { update_rogue_symset ( symp , val ) ; } } } } return 1 ; }
","<S2SV_ModStart> , * altp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\0'
",NetHack@NetHack/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,CVE-2019-19905,https://github.com/NetHack/NetHack/commit/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,2019-12-19T18:15Z,"<S2SV_StartBug> char * bufp , * commentp , * altp ; <S2SV_EndBug>"
1881,CWE-119,"<S2SV_StartBug> static void encode_uniform ( vp9_writer * w , int v ) { <S2SV_EndBug> const int l = 8 ; const int m = ( 1 << l ) - 191 ; if ( v < m ) { <S2SV_StartBug> vp9_write_literal ( w , v , l - 1 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> vp9_write_literal ( w , m + ( ( v - m ) >> 1 ) , l - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , ( v - m ) & 1 , 1 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> void encode_uniform ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> m ) { vpx_write_literal <S2SV_ModEnd> ( w , <S2SV_ModStart> } else { vpx_write_literal <S2SV_ModEnd> ( w , <S2SV_ModStart> 1 ) ; vpx_write_literal <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void encode_uniform ( vp9_writer * w , int v ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , v , l - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , m + ( ( v - m ) >> 1 ) , l - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , ( v - m ) & 1 , 1 ) ; <S2SV_EndBug>"
8250,CWE-787,"static int l2cap_sock_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_l2 la ; int len , err = 0 ; BT_DBG ( ""sk<S2SV_blank>%p"" , sk ) ; if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ; memset ( & la , 0 , sizeof ( la ) ) ; len = min_t ( unsigned int , sizeof ( la ) , alen ) ; memcpy ( & la , addr , len ) ; if ( la . l2_cid ) return - EINVAL ; lock_sock ( sk ) ; if ( sk -> sk_type == SOCK_SEQPACKET && ! la . l2_psm ) { err = - EINVAL ; goto done ; } switch ( l2cap_pi ( sk ) -> mode ) { case L2CAP_MODE_BASIC : break ; case L2CAP_MODE_ERTM : <S2SV_StartBug> if ( enable_ertm ) <S2SV_EndBug> break ; default : err = - ENOTSUPP ; goto done ; } switch ( sk -> sk_state ) { case BT_CONNECT : case BT_CONNECT2 : case BT_CONFIG : goto wait ; case BT_CONNECTED : goto done ; case BT_OPEN : case BT_BOUND : break ; default : err = - EBADFD ; goto done ; } bacpy ( & bt_sk ( sk ) -> dst , & la . l2_bdaddr ) ; l2cap_pi ( sk ) -> psm = la . l2_psm ; err = l2cap_do_connect ( sk ) ; if ( err ) goto done ; wait : err = bt_sock_wait_state ( sk , BT_CONNECTED , sock_sndtimeo ( sk , flags & O_NONBLOCK ) ) ; done : release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING :
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z,<S2SV_StartBug> if ( enable_ertm ) <S2SV_EndBug>
7833,CWE-20,"void rawSocketProcessEthPacket ( NetInterface * interface , EthHeader * header , const uint8_t * data , size_t length , NetRxAncillary * ancillary ) { uint_t i ; Socket * socket ; SocketQueueItem * queueItem ; NetBuffer * p ; for ( i = 0 ; i < SOCKET_MAX_COUNT ; i ++ ) { socket = socketTable + i ; if ( socket -> type != SOCKET_TYPE_RAW_ETH ) continue ; if ( socket -> interface && socket -> interface != interface ) continue ; if ( socket -> protocol == SOCKET_ETH_PROTO_ALL ) { } else if ( socket -> protocol == SOCKET_ETH_PROTO_LLC ) { if ( ntohs ( header -> type ) > ETH_MTU ) continue ; } else { if ( ntohs ( header -> type ) != socket -> protocol ) continue ; } break ; } if ( i >= SOCKET_MAX_COUNT ) return ; if ( socket -> receiveQueue == NULL ) { p = netBufferAlloc ( sizeof ( SocketQueueItem ) + sizeof ( EthHeader ) + length ) ; if ( p != NULL ) { queueItem = netBufferAt ( p , 0 ) ; queueItem -> buffer = p ; socket -> receiveQueue = queueItem ; } else { queueItem = NULL ; } } else { queueItem = socket -> receiveQueue ; for ( i = 1 ; queueItem -> next ; i ++ ) { queueItem = queueItem -> next ; } if ( i >= RAW_SOCKET_RX_QUEUE_SIZE ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ; } p = netBufferAlloc ( sizeof ( SocketQueueItem ) + sizeof ( EthHeader ) + length ) ; if ( p != NULL ) { queueItem -> next = netBufferAt ( p , 0 ) ; queueItem = queueItem -> next ; queueItem -> buffer = p ; } else { queueItem = NULL ; } } if ( queueItem == NULL ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ; } queueItem -> next = NULL ; <S2SV_StartBug> queueItem -> srcPort = 0 ; <S2SV_EndBug> queueItem -> srcIpAddr = IP_ADDR_ANY ; queueItem -> destIpAddr = IP_ADDR_ANY ; queueItem -> offset = sizeof ( SocketQueueItem ) ; netBufferWrite ( queueItem -> buffer , queueItem -> offset , header , sizeof ( EthHeader ) ) ; netBufferWrite ( queueItem -> buffer , queueItem -> offset + sizeof ( EthHeader ) , data , length ) ; queueItem -> ancillary = * ancillary ; rawSocketUpdateEvents ( socket ) ; }
","<S2SV_ModStart> ; queueItem -> interface = interface ; queueItem ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> queueItem -> srcPort = 0 ; <S2SV_EndBug>
681,CWE-125,"static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x03 ) & 0x03 ) ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0xff ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x0f ) & 0xff ) ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( unsigned char ) pixel ; break ; } } } continue ; } length ++ ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ; * pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( * compact_pixels >> 4 ) & 0xff ; * pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( * compact_pixels ) ; break ; } } <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> compact_pixels ++ ; } } return ( i ) ; }
","<S2SV_ModStart> ++ ) { CheckNumberCompactPixels ; <S2SV_ModStart> ; } } <S2SV_ModEnd> compact_pixels ++ ;
",ImageMagick@ImageMagick/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,CVE-2016-7521,https://github.com/ImageMagick/ImageMagick/commit/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,2017-04-20T18:59Z,<S2SV_StartBug> switch ( depth ) <S2SV_EndBug> <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug>
2676,CWE-125,"void lcdSetPixels_ArrayBuffer_flat ( JsGraphics * gfx , short x , short y , short pixelCount , unsigned int col ) { unsigned char * ptr = ( unsigned char * ) gfx -> backendData ; unsigned int idx = lcdGetPixelIndex_ArrayBuffer ( gfx , x , y , pixelCount ) ; ptr += idx >> 3 ; unsigned int whiteMask = ( 1U << gfx -> data . bpp ) - 1 ; bool shortCut = ( col == 0 || ( col & whiteMask ) == whiteMask ) && ( ! ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ) ; while ( pixelCount -- ) { if ( gfx -> data . bpp & 7 ) { idx = idx & 7 ; if ( shortCut && idx == 0 ) { int wholeBytes = ( gfx -> data . bpp * ( pixelCount + 1 ) ) >> 3 ; if ( wholeBytes ) { char c = ( char ) ( col ? 0xFF : 0 ) ; pixelCount = ( short ) ( pixelCount + 1 - ( wholeBytes * 8 / gfx -> data . bpp ) ) ; while ( wholeBytes -- ) { * ptr = c ; ptr ++ ; } continue ; } } unsigned int mask = ( unsigned int ) ( 1 << gfx -> data . bpp ) - 1 ; unsigned int existing = ( unsigned int ) * ptr ; unsigned int bitIdx = ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ? 8 - ( idx + gfx -> data . bpp ) : idx ; <S2SV_StartBug> * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ; <S2SV_EndBug> if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) { ptr ++ ; } else { idx += gfx -> data . bpp ; if ( idx >= 8 ) ptr ++ ; } } else { int i ; for ( i = 0 ; i < gfx -> data . bpp ; i += 8 ) { * ptr = ( char ) ( col >> i ) ; ptr ++ ; } } } }
","<S2SV_ModStart> : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;
",espruino@Espruino/8a44b04b584b3d3ab1cb68fed410f7ecb165e50e,CVE-2018-11592,https://github.com/espruino/Espruino/commit/8a44b04b584b3d3ab1cb68fed410f7ecb165e50e,2018-05-31T16:29Z,<S2SV_StartBug> * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ; <S2SV_EndBug>
1485,CWE-119,"static int rd_pick_intra4x4block ( MACROBLOCK * x , BLOCK * be , BLOCKD * b , B_PREDICTION_MODE * best_mode , const int * bmode_costs , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l , int * bestrate , int * bestratey , int * bestdistortion ) { B_PREDICTION_MODE mode ; int best_rd = INT_MAX ; int rate = 0 ; int distortion ; ENTROPY_CONTEXT ta = * a , tempa = * a ; ENTROPY_CONTEXT tl = * l , templ = * l ; <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , best_predictor , 16 * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff , 16 ) ; <S2SV_EndBug> int dst_stride = x -> e_mbd . dst . y_stride ; unsigned char * dst = x -> e_mbd . dst . y_buffer + b -> offset ; unsigned char * Above = dst - dst_stride ; unsigned char * yleft = dst - 1 ; unsigned char top_left = Above [ - 1 ] ; for ( mode = B_DC_PRED ; mode <= B_HU_PRED ; mode ++ ) { int this_rd ; int ratey ; rate = bmode_costs [ mode ] ; vp8_intra4x4_predict ( Above , yleft , dst_stride , mode , b -> predictor , 16 , top_left ) ; vp8_subtract_b ( be , b , 16 ) ; x -> short_fdct4x4 ( be -> src_diff , be -> coeff , 32 ) ; x -> quantize_b ( be , b ) ; tempa = ta ; templ = tl ; ratey = cost_coeffs ( x , b , PLANE_TYPE_Y_WITH_DC , & tempa , & templ ) ; rate += ratey ; distortion = vp8_block_error ( be -> coeff , b -> dqcoeff ) >> 2 ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( this_rd < best_rd ) { * bestrate = rate ; * bestratey = ratey ; * bestdistortion = distortion ; best_rd = this_rd ; * best_mode = mode ; * a = tempa ; * l = templ ; copy_predictor ( best_predictor , b -> predictor ) ; <S2SV_StartBug> vpx_memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ; <S2SV_EndBug> } } b -> bmi . as_mode = * best_mode ; vp8_short_idct4x4llm ( best_dqcoeff , best_predictor , 16 , dst , dst_stride ) ; return best_rd ; }
","<S2SV_ModStart> * l ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> char , best_predictor [ <S2SV_ModEnd> 16 * 4 <S2SV_ModStart> 16 * 4 ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> short , best_dqcoeff [ 16 ] <S2SV_ModEnd> ) ; int <S2SV_ModStart> predictor ) ; memcpy <S2SV_ModEnd> ( best_dqcoeff ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , best_predictor , 16 * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ; <S2SV_EndBug>"
4571,CWE-125,"static PyObject * decode_bytes_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { <S2SV_StartBug> return PyBytes_DecodeEscape ( s , len , NULL , 0 , NULL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> len ) { const char * first_invalid_escape ; PyObject * result = _PyBytes_DecodeEscape <S2SV_ModEnd> ( s , <S2SV_ModStart> 0 , NULL , & first_invalid_escape ) ; if ( result == NULL ) return NULL ; if ( first_invalid_escape != NULL ) { if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) { Py_DECREF ( result ) ; return NULL ; } } return result <S2SV_ModEnd> ; } <S2SV_null>
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> return PyBytes_DecodeEscape ( s , len , NULL , 0 , NULL ) ; <S2SV_EndBug>"
6527,CWE-119,"cJSON * cJSON_CreateObject ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_Object ; return item ; }
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,
560,CWE-189,"PHP_FUNCTION ( imagecrop ) { zval * IM ; gdImagePtr im ; gdImagePtr im_crop ; gdRect rect ; zval * z_rect ; zval * * tmp ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""ra"" , & IM , & z_rect ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; if ( zend_hash_find ( HASH_OF ( z_rect ) , ""x"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""y"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""width"" , sizeof ( ""width"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""height"" , sizeof ( ""height"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>height"" ) ; RETURN_FALSE ; } im_crop = gdImageCrop ( im , & rect ) ; if ( im_crop == NULL ) { RETURN_FALSE ; } else { ZEND_REGISTER_RESOURCE ( return_value , im_crop , le_gd ) ; } }
","<S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . x = Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . y = Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . width = Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . height = Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> tmp ) ; }
",php@php-src/2938329ce19cb8c4197dec146c3ec887c6f61d01,CVE-2014-2020,https://github.com/php/php-src/commit/2938329ce19cb8c4197dec146c3ec887c6f61d01,2014-02-18T11:55Z,<S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug>
3114,CWE-20,"static int cma_req_handler ( struct ib_cm_id * cm_id , struct ib_cm_event * ib_event ) { struct rdma_id_private * listen_id , * conn_id ; struct rdma_cm_event event ; int offset , ret ; <S2SV_StartBug> u8 smac [ ETH_ALEN ] ; <S2SV_EndBug> u8 alt_smac [ ETH_ALEN ] ; u8 * psmac = smac ; u8 * palt_smac = alt_smac ; int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == RDMA_TRANSPORT_IB ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == IB_LINK_LAYER_ETHERNET ) ) ; listen_id = cm_id -> context ; if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) ) return - EINVAL ; if ( cma_disable_callback ( listen_id , RDMA_CM_LISTEN ) ) return - ECONNABORTED ; memset ( & event , 0 , sizeof event ) ; offset = cma_user_data_offset ( listen_id ) ; event . event = RDMA_CM_EVENT_CONNECT_REQUEST ; if ( ib_event -> event == IB_CM_SIDR_REQ_RECEIVED ) { conn_id = cma_new_udp_id ( & listen_id -> id , ib_event ) ; event . param . ud . private_data = ib_event -> private_data + offset ; event . param . ud . private_data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset ; } else { conn_id = cma_new_conn_id ( & listen_id -> id , ib_event ) ; cma_set_req_event_data ( & event , & ib_event -> param . req_rcvd , ib_event -> private_data , offset ) ; } if ( ! conn_id ) { ret = - ENOMEM ; goto err1 ; } mutex_lock_nested ( & conn_id -> handler_mutex , SINGLE_DEPTH_NESTING ) ; ret = cma_acquire_dev ( conn_id , listen_id ) ; if ( ret ) goto err2 ; conn_id -> cm_id . ib = cm_id ; cm_id -> context = conn_id ; cm_id -> cm_handler = cma_ib_handler ; atomic_inc ( & conn_id -> refcount ) ; ret = conn_id -> id . event_handler ( & conn_id -> id , & event ) ; if ( ret ) goto err3 ; <S2SV_StartBug> if ( is_iboe ) { <S2SV_EndBug> if ( ib_event -> param . req_rcvd . primary_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . primary_path -> sgid , psmac , NULL ) ; else psmac = NULL ; if ( ib_event -> param . req_rcvd . alternate_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . alternate_path -> sgid , palt_smac , NULL ) ; else palt_smac = NULL ; } <S2SV_StartBug> mutex_lock ( & lock ) ; <S2SV_EndBug> if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ; if ( cma_comp ( conn_id , RDMA_CM_CONNECT ) && ( conn_id -> id . qp_type != IB_QPT_UD ) ) ib_send_cm_mra ( cm_id , CMA_CM_MRA_SETTING , NULL , 0 ) ; mutex_unlock ( & lock ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; mutex_unlock ( & listen_id -> handler_mutex ) ; cma_deref_id ( conn_id ) ; return 0 ; err3 : cma_deref_id ( conn_id ) ; conn_id -> cm_id . ib = NULL ; err2 : cma_exch ( conn_id , RDMA_CM_DESTROYING ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; err1 : mutex_unlock ( & listen_id -> handler_mutex ) ; if ( conn_id ) rdma_destroy_id ( & conn_id -> id ) ; return ret ; }
","<S2SV_ModStart> , ret ; <S2SV_ModEnd> listen_id = cm_id <S2SV_ModStart> goto err3 ; <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> ( & lock <S2SV_ModEnd> ) ; if
",torvalds@linux/b2853fd6c2d0f383dbdf7427e263eb576a633867,CVE-2014-2739,https://github.com/torvalds/linux/commit/b2853fd6c2d0f383dbdf7427e263eb576a633867,2014-04-14T23:55Z,<S2SV_StartBug> u8 smac [ ETH_ALEN ] ; <S2SV_EndBug> <S2SV_StartBug> if ( is_iboe ) { <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & lock ) ; <S2SV_EndBug>
2327,CWE-416,"int __mdiobus_register ( struct mii_bus * bus , struct module * owner ) { struct mdio_device * mdiodev ; int i , err ; struct gpio_desc * gpiod ; if ( NULL == bus || NULL == bus -> name || NULL == bus -> read || NULL == bus -> write ) return - EINVAL ; BUG_ON ( bus -> state != MDIOBUS_ALLOCATED && bus -> state != MDIOBUS_UNREGISTERED ) ; bus -> owner = owner ; bus -> dev . parent = bus -> parent ; bus -> dev . class = & mdio_bus_class ; bus -> dev . groups = NULL ; dev_set_name ( & bus -> dev , ""%s"" , bus -> id ) ; err = device_register ( & bus -> dev ) ; if ( err ) { pr_err ( ""mii_bus<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register\\n"" , bus -> id ) ; <S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug> return - EINVAL ; } mutex_init ( & bus -> mdio_lock ) ; gpiod = devm_gpiod_get_optional ( & bus -> dev , ""reset"" , GPIOD_OUT_LOW ) ; if ( IS_ERR ( gpiod ) ) { dev_err ( & bus -> dev , ""mii_bus<S2SV_blank>%s<S2SV_blank>couldn\'t<S2SV_blank>get<S2SV_blank>reset<S2SV_blank>GPIO\\n"" , bus -> id ) ; device_del ( & bus -> dev ) ; return PTR_ERR ( gpiod ) ; } else if ( gpiod ) { bus -> reset_gpiod = gpiod ; gpiod_set_value_cansleep ( gpiod , 1 ) ; udelay ( bus -> reset_delay_us ) ; gpiod_set_value_cansleep ( gpiod , 0 ) ; } if ( bus -> reset ) bus -> reset ( bus ) ; for ( i = 0 ; i < PHY_MAX_ADDR ; i ++ ) { if ( ( bus -> phy_mask & ( 1 << i ) ) == 0 ) { struct phy_device * phydev ; phydev = mdiobus_scan ( bus , i ) ; if ( IS_ERR ( phydev ) && ( PTR_ERR ( phydev ) != - ENODEV ) ) { err = PTR_ERR ( phydev ) ; goto error ; } } } mdiobus_setup_mdiodev_from_board_info ( bus , mdiobus_create_device ) ; bus -> state = MDIOBUS_REGISTERED ; pr_info ( ""%s:<S2SV_blank>probed\\n"" , bus -> name ) ; return 0 ; error : while ( -- i >= 0 ) { mdiodev = bus -> mdio_map [ i ] ; if ( ! mdiodev ) continue ; mdiodev -> device_remove ( mdiodev ) ; mdiodev -> device_free ( mdiodev ) ; } if ( bus -> reset_gpiod ) gpiod_set_value_cansleep ( bus -> reset_gpiod , 1 ) ; device_del ( & bus -> dev ) ; return err ; }
","<S2SV_ModStart> id ) ; <S2SV_ModEnd> return - EINVAL
",torvalds@linux/6ff7b060535e87c2ae14dd8548512abfdda528fb,CVE-2019-12819,https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb,2019-06-14T02:29Z,<S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug>
3916,CWE-264,"int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; if ( fd < 0 ) return - errno ; <S2SV_StartBug> if ( mode > 0 ) { <S2SV_EndBug> r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }
","<S2SV_ModStart> if ( mode != MODE_INVALID <S2SV_ModEnd> ) { r
",systemd@systemd/ee735086f8670be1591fa9593e80dd60163a7a2f,CVE-2016-10156,https://github.com/systemd/systemd/commit/ee735086f8670be1591fa9593e80dd60163a7a2f,2017-01-23T07:59Z,<S2SV_StartBug> if ( mode > 0 ) { <S2SV_EndBug>
534,CWE-399,"struct sctp_chunk * sctp_inq_pop ( struct sctp_inq * queue ) { struct sctp_chunk * chunk ; sctp_chunkhdr_t * ch = NULL ; if ( ( chunk = queue -> in_progress ) ) { if ( chunk -> singleton || chunk -> end_of_packet || chunk -> pdiscard ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } else { ch = ( sctp_chunkhdr_t * ) chunk -> chunk_end ; skb_pull ( chunk -> skb , chunk -> chunk_end - chunk -> skb -> data ) ; <S2SV_StartBug> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <S2SV_EndBug> sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } } } if ( ! chunk ) { struct list_head * entry ; if ( list_empty ( & queue -> in_chunk_list ) ) return NULL ; entry = queue -> in_chunk_list . next ; chunk = queue -> in_progress = list_entry ( entry , struct sctp_chunk , list ) ; list_del_init ( entry ) ; chunk -> singleton = 1 ; ch = ( sctp_chunkhdr_t * ) chunk -> skb -> data ; chunk -> data_accepted = 0 ; } chunk -> chunk_hdr = ch ; chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ; if ( unlikely ( skb_is_nonlinear ( chunk -> skb ) ) ) { if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ; chunk -> subh . v = NULL ; <S2SV_StartBug> if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) { <S2SV_EndBug> chunk -> singleton = 0 ; } else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) { <S2SV_StartBug> sctp_chunk_free ( chunk ) ; <S2SV_EndBug> chunk = queue -> in_progress = NULL ; return NULL ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n"" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return chunk ; }
","<S2SV_ModStart> data ) ; <S2SV_ModEnd> } } if <S2SV_ModStart> chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> ) ) { chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n"" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> chunk ; }
",torvalds@linux/26b87c7881006311828bb0ab271a551a62dcceb4,CVE-2014-3688,https://github.com/torvalds/linux/commit/26b87c7881006311828bb0ab271a551a62dcceb4,2014-11-30T01:59Z,<S2SV_StartBug> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) { <S2SV_EndBug> <S2SV_StartBug> sctp_chunk_free ( chunk ) ; <S2SV_EndBug>
1937,CWE-119,"static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> VP9_COMP * const cpi = ctx -> cpi ; <S2SV_StartBug> vpx_svc_parameters_t * const params = va_arg ( args , vpx_svc_parameters_t * ) ; <S2SV_EndBug> <S2SV_StartBug> if ( params == NULL ) <S2SV_EndBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_StartBug> cpi -> svc . spatial_layer_id = params -> spatial_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> svc . temporal_layer_id = params -> temporal_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> lst_fb_idx = params -> lst_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> gld_fb_idx = params -> gld_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> alt_fb_idx = params -> alt_fb_idx ; <S2SV_EndBug> if ( vp9_set_size_literal ( ctx -> cpi , params -> width , params -> height ) != 0 ) return VPX_CODEC_INVALID_PARAM ; ctx -> cfg . rc_max_quantizer = params -> max_quantizer ; ctx -> cfg . rc_min_quantizer = params -> min_quantizer ; set_encoder_config ( & ctx -> oxcf , & ctx -> cfg , & ctx -> extra_cfg ) ; vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> -> cpi ; vpx_svc_extra_cfg_t <S2SV_ModEnd> * const params <S2SV_ModStart> ( args , vpx_svc_extra_cfg_t <S2SV_ModEnd> * ) ; <S2SV_ModStart> * ) ; int sl , tl ; for ( sl = 0 ; sl < <S2SV_ModEnd> cpi -> svc <S2SV_ModStart> -> svc . number_spatial_layers ; ++ sl ) { for ( tl = 0 ; tl < <S2SV_ModEnd> cpi -> svc <S2SV_ModStart> -> svc . number_temporal_layers ; ++ tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cpi -> svc . number_temporal_layers ) ; LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; lc -> max_q <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> max_quantizers [ sl ] ; lc -> min_q <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> min_quantizers [ sl ] ; lc -> scaling_factor_num <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> scaling_factor_num [ sl ] ; lc -> scaling_factor_den <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> scaling_factor_den [ sl ] ; } } <S2SV_ModEnd> return VPX_CODEC_OK ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vpx_svc_parameters_t * const params = va_arg ( args , vpx_svc_parameters_t * ) ; <S2SV_EndBug> <S2SV_StartBug> if ( params == NULL ) <S2SV_EndBug> <S2SV_StartBug> cpi -> svc . spatial_layer_id = params -> spatial_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> svc . temporal_layer_id = params -> temporal_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> lst_fb_idx = params -> lst_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> gld_fb_idx = params -> gld_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> alt_fb_idx = params -> alt_fb_idx ; <S2SV_EndBug>"
4945,CWE-617,"static void update_bar_address ( struct vmctx * ctx , struct pci_vdev * dev , uint64_t addr , int idx , int type , bool ignore_reg_unreg ) { bool decode = false ; uint64_t orig_addr = dev -> bar [ idx ] . addr ; if ( ! ignore_reg_unreg ) { if ( dev -> bar [ idx ] . type == PCIBAR_IO ) decode = porten ( dev ) ; else decode = memen ( dev ) ; } if ( decode ) unregister_bar ( dev , idx ) ; switch ( type ) { case PCIBAR_IO : case PCIBAR_MEM32 : dev -> bar [ idx ] . addr = addr ; break ; case PCIBAR_MEM64 : dev -> bar [ idx ] . addr &= ~ 0xffffffffUL ; dev -> bar [ idx ] . addr |= addr ; break ; case PCIBAR_MEMHI64 : dev -> bar [ idx ] . addr &= 0xffffffff ; dev -> bar [ idx ] . addr |= addr ; break ; default : <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> } if ( decode ) register_bar ( dev , idx ) ; if ( dev -> dev_ops -> vdev_update_bar_map && decode ) dev -> dev_ops -> vdev_update_bar_map ( ctx , dev , idx , orig_addr ) ; }
","<S2SV_ModStart> ; default : pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , type ) ; return <S2SV_ModEnd> ; } if
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug>
7768,CWE-125,"static int tok_get ( struct tok_state * tok , char * * p_start , char * * p_end ) { int c ; int blankline , nonascii ; * p_start = * p_end = NULL ; nextline : tok -> start = NULL ; blankline = 0 ; if ( tok -> atbol ) { int col = 0 ; int altcol = 0 ; tok -> atbol = 0 ; for ( ; ; ) { c = tok_nextc ( tok ) ; if ( c == '<S2SV_blank>' ) { col ++ , altcol ++ ; } else if ( c == '\\t' ) { col = ( col / tok -> tabsize + 1 ) * tok -> tabsize ; altcol = ( altcol / ALTTABSIZE + 1 ) * ALTTABSIZE ; } else if ( c == '\\014' ) { col = altcol = 0 ; } else { break ; } } tok_backup ( tok , c ) ; if ( c == '#' || c == '\\n' ) { if ( col == 0 && c == '\\n' && tok -> prompt != NULL ) { blankline = 0 ; } else { blankline = 1 ; } } if ( ! blankline && tok -> level == 0 ) { if ( col == tok -> indstack [ tok -> indent ] ) { if ( altcol != tok -> altindstack [ tok -> indent ] ) { return indenterror ( tok ) ; } } else if ( col > tok -> indstack [ tok -> indent ] ) { if ( tok -> indent + 1 >= MAXINDENT ) { tok -> done = E_TOODEEP ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( altcol <= tok -> altindstack [ tok -> indent ] ) { return indenterror ( tok ) ; } tok -> pendin ++ ; tok -> indstack [ ++ tok -> indent ] = col ; tok -> altindstack [ tok -> indent ] = altcol ; } else { while ( tok -> indent > 0 && col < tok -> indstack [ tok -> indent ] ) { tok -> pendin -- ; tok -> indent -- ; } if ( col != tok -> indstack [ tok -> indent ] ) { tok -> done = E_DEDENT ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( altcol != tok -> altindstack [ tok -> indent ] ) { return indenterror ( tok ) ; } } } } tok -> start = tok -> cur ; if ( tok -> pendin != 0 ) { if ( tok -> pendin < 0 ) { tok -> pendin ++ ; return DEDENT ; } else { tok -> pendin -- ; return INDENT ; } } again : tok -> start = NULL ; do { c = tok_nextc ( tok ) ; } while ( c == '<S2SV_blank>' || c == '\\t' || c == '\\014' ) ; tok -> start = tok -> cur - 1 ; if ( c == '#' ) { <S2SV_StartBug> while ( c != EOF && c != '\\n' ) { <S2SV_EndBug> <S2SV_StartBug> c = tok_nextc ( tok ) ; <S2SV_EndBug> } } if ( c == EOF ) { return tok -> done == E_EOF ? ENDMARKER : ERRORTOKEN ; } nonascii = 0 ; if ( is_potential_identifier_start ( c ) ) { int saw_b = 0 , saw_r = 0 , saw_u = 0 , saw_f = 0 ; while ( 1 ) { if ( ! ( saw_b || saw_u || saw_f ) && ( c == 'b' || c == 'B' ) ) saw_b = 1 ; else if ( ! ( saw_b || saw_u || saw_r || saw_f ) && ( c == 'u' || c == 'U' ) ) { saw_u = 1 ; } else if ( ! ( saw_r || saw_u ) && ( c == 'r' || c == 'R' ) ) { saw_r = 1 ; } else if ( ! ( saw_f || saw_b || saw_u ) && ( c == 'f' || c == 'F' ) ) { saw_f = 1 ; } else { break ; } c = tok_nextc ( tok ) ; if ( c == \'""\' || c == '\\'' ) { goto letter_quote ; } } while ( is_potential_identifier_char ( c ) ) { if ( c >= 128 ) { nonascii = 1 ; } c = tok_nextc ( tok ) ; } tok_backup ( tok , c ) ; if ( nonascii && ! verify_identifier ( tok ) ) { return ERRORTOKEN ; } * p_start = tok -> start ; * p_end = tok -> cur ; return NAME ; } if ( c == '\\n' ) { tok -> atbol = 1 ; if ( blankline || tok -> level > 0 ) { goto nextline ; } * p_start = tok -> start ; * p_end = tok -> cur - 1 ; tok -> cont_line = 0 ; return NEWLINE ; } if ( c == '.' ) { c = tok_nextc ( tok ) ; if ( isdigit ( c ) ) { goto fraction ; } else if ( c == '.' ) { c = tok_nextc ( tok ) ; if ( c == '.' ) { * p_start = tok -> start ; * p_end = tok -> cur ; return ELLIPSIS ; } else { tok_backup ( tok , c ) ; } tok_backup ( tok , '.' ) ; } else { tok_backup ( tok , c ) ; } * p_start = tok -> start ; * p_end = tok -> cur ; return DOT ; } if ( isdigit ( c ) ) { if ( c == '0' ) { c = tok_nextc ( tok ) ; if ( c == 'x' || c == 'X' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( ! isxdigit ( c ) ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""invalid<S2SV_blank>hexadecimal<S2SV_blank>literal"" ) ; } do { c = tok_nextc ( tok ) ; } while ( isxdigit ( c ) ) ; } while ( c == '_' ) ; } else if ( c == 'o' || c == 'O' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( c < '0' || c >= '8' ) { tok_backup ( tok , c ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<S2SV_blank>digit<S2SV_blank>\'%c\'<S2SV_blank>in<S2SV_blank>octal<S2SV_blank>literal"" , c ) ; } else { return syntaxerror ( tok , ""invalid<S2SV_blank>octal<S2SV_blank>literal"" ) ; } } do { c = tok_nextc ( tok ) ; } while ( '0' <= c && c < '8' ) ; } while ( c == '_' ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<S2SV_blank>digit<S2SV_blank>\'%c\'<S2SV_blank>in<S2SV_blank>octal<S2SV_blank>literal"" , c ) ; } } else if ( c == 'b' || c == 'B' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( c != '0' && c != '1' ) { tok_backup ( tok , c ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<S2SV_blank>digit<S2SV_blank>\'%c\'<S2SV_blank>in<S2SV_blank>binary<S2SV_blank>literal"" , c ) ; } else { return syntaxerror ( tok , ""invalid<S2SV_blank>binary<S2SV_blank>literal"" ) ; } } do { c = tok_nextc ( tok ) ; } while ( c == '0' || c == '1' ) ; } while ( c == '_' ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<S2SV_blank>digit<S2SV_blank>\'%c\'<S2SV_blank>in<S2SV_blank>binary<S2SV_blank>literal"" , c ) ; } } else { int nonzero = 0 ; while ( 1 ) { if ( c == '_' ) { c = tok_nextc ( tok ) ; if ( ! isdigit ( c ) ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""invalid<S2SV_blank>decimal<S2SV_blank>literal"" ) ; } } if ( c != '0' ) { break ; } c = tok_nextc ( tok ) ; } if ( isdigit ( c ) ) { nonzero = 1 ; c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } } if ( c == '.' ) { c = tok_nextc ( tok ) ; goto fraction ; } else if ( c == 'e' || c == 'E' ) { goto exponent ; } else if ( c == 'j' || c == 'J' ) { goto imaginary ; } else if ( nonzero ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""leading<S2SV_blank>zeros<S2SV_blank>in<S2SV_blank>decimal<S2SV_blank>integer<S2SV_blank>"" ""literals<S2SV_blank>are<S2SV_blank>not<S2SV_blank>permitted;<S2SV_blank>"" ""use<S2SV_blank>an<S2SV_blank>0o<S2SV_blank>prefix<S2SV_blank>for<S2SV_blank>octal<S2SV_blank>integers"" ) ; } } } else { c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } { if ( c == '.' ) { c = tok_nextc ( tok ) ; fraction : if ( isdigit ( c ) ) { c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } } } if ( c == 'e' || c == 'E' ) { int e ; exponent : e = c ; c = tok_nextc ( tok ) ; if ( c == '+' || c == '-' ) { c = tok_nextc ( tok ) ; if ( ! isdigit ( c ) ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""invalid<S2SV_blank>decimal<S2SV_blank>literal"" ) ; } } else if ( ! isdigit ( c ) ) { tok_backup ( tok , c ) ; tok_backup ( tok , e ) ; * p_start = tok -> start ; * p_end = tok -> cur ; return NUMBER ; } c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } } if ( c == 'j' || c == 'J' ) { imaginary : c = tok_nextc ( tok ) ; } } } tok_backup ( tok , c ) ; * p_start = tok -> start ; * p_end = tok -> cur ; return NUMBER ; } letter_quote : if ( c == '\\'' || c == \'""\' ) { int quote = c ; int quote_size = 1 ; int end_quote_size = 0 ; tok -> first_lineno = tok -> lineno ; tok -> multi_line_start = tok -> line_start ; c = tok_nextc ( tok ) ; if ( c == quote ) { c = tok_nextc ( tok ) ; if ( c == quote ) { quote_size = 3 ; } else { end_quote_size = 1 ; } } if ( c != quote ) { tok_backup ( tok , c ) ; } while ( end_quote_size != quote_size ) { c = tok_nextc ( tok ) ; if ( c == EOF ) { if ( quote_size == 3 ) { tok -> done = E_EOFS ; } else { tok -> done = E_EOLS ; } tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( quote_size == 1 && c == '\\n' ) { tok -> done = E_EOLS ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( c == quote ) { end_quote_size += 1 ; } else { end_quote_size = 0 ; if ( c == '\\\\' ) { tok_nextc ( tok ) ; } } } * p_start = tok -> start ; * p_end = tok -> cur ; return STRING ; } if ( c == '\\\\' ) { c = tok_nextc ( tok ) ; if ( c != '\\n' ) { tok -> done = E_LINECONT ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } tok -> cont_line = 1 ; goto again ; } { int c2 = tok_nextc ( tok ) ; int token = PyToken_TwoChars ( c , c2 ) ; if ( token != OP ) { int c3 = tok_nextc ( tok ) ; int token3 = PyToken_ThreeChars ( c , c2 , c3 ) ; if ( token3 != OP ) { token = token3 ; } else { tok_backup ( tok , c3 ) ; } * p_start = tok -> start ; * p_end = tok -> cur ; return token ; } tok_backup ( tok , c2 ) ; } switch ( c ) { case '(' : case '[' : case '{' : # ifndef PGEN if ( tok -> level >= MAXLEVEL ) { return syntaxerror ( tok , ""too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>parentheses"" ) ; } tok -> parenstack [ tok -> level ] = c ; tok -> parenlinenostack [ tok -> level ] = tok -> lineno ; # endif tok -> level ++ ; break ; case ')' : case ']' : case '}' : # ifndef PGEN if ( ! tok -> level ) { return syntaxerror ( tok , ""unmatched<S2SV_blank>\'%c\'"" , c ) ; } # endif tok -> level -- ; # ifndef PGEN int opening = tok -> parenstack [ tok -> level ] ; if ( ! ( ( opening == '(' && c == ')' ) || ( opening == '[' && c == ']' ) || ( opening == '{' && c == '}' ) ) ) { if ( tok -> parenlinenostack [ tok -> level ] != tok -> lineno ) { return syntaxerror ( tok , ""closing<S2SV_blank>parenthesis<S2SV_blank>\'%c\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""opening<S2SV_blank>parenthesis<S2SV_blank>\'%c\'<S2SV_blank>on<S2SV_blank>line<S2SV_blank>%d"" , c , opening , tok -> parenlinenostack [ tok -> level ] ) ; } else { return syntaxerror ( tok , ""closing<S2SV_blank>parenthesis<S2SV_blank>\'%c\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""opening<S2SV_blank>parenthesis<S2SV_blank>\'%c\'"" , c , opening ) ; } } # endif break ; } * p_start = tok -> start ; * p_end = tok -> cur ; return PyToken_OneChar ( c ) ; }
","<S2SV_ModStart> '#' ) { const char * prefix , * p , * type_start ; <S2SV_ModStart> tok ) ; } if ( tok -> type_comments ) { p = tok -> start ; prefix = type_comment_prefix ; while ( * prefix && p < tok -> cur ) { if ( * prefix == '<S2SV_blank>' ) { while ( * p == '<S2SV_blank>' || * p == '\\t' ) { p ++ ; } } else if ( * prefix == * p ) { p ++ ; } else { break ; } prefix ++ ; } if ( ! * prefix ) { int is_type_ignore = 1 ; tok_backup ( tok , c ) ; type_start = p ; is_type_ignore = tok -> cur >= p + 6 && memcmp ( p , ""ignore"" , 6 ) == 0 ; p += 6 ; while ( is_type_ignore && p < tok -> cur ) { if ( * p == '#' ) break ; is_type_ignore = is_type_ignore && ( * p == '<S2SV_blank>' || * p == '\\t' ) ; p ++ ; } if ( is_type_ignore ) { if ( blankline ) { tok_nextc ( tok ) ; tok -> atbol = 1 ; } return TYPE_IGNORE ; } else { * p_start = ( char * ) type_start ; * p_end = tok -> cur ; return TYPE_COMMENT ; } }
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,<S2SV_StartBug> while ( c != EOF && c != '\\n' ) { <S2SV_EndBug> <S2SV_StartBug> c = tok_nextc ( tok ) ; <S2SV_EndBug>
1885,CWE-119,"int vp9_prob_diff_update_savings_search_model ( const unsigned int * ct , <S2SV_StartBug> const vp9_prob * oldp , <S2SV_EndBug> vp9_prob * bestp , <S2SV_StartBug> vp9_prob upd ) { <S2SV_EndBug> int i , old_b , new_b , update_b , savings , bestsavings , step ; int newp ; <S2SV_StartBug> vp9_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ; <S2SV_EndBug> vp9_model_to_full_probs ( oldp , oldplist ) ; <S2SV_StartBug> vpx_memcpy ( newplist , oldp , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ; <S2SV_EndBug> for ( i = UNCONSTRAINED_NODES , old_b = 0 ; i < ENTROPY_NODES ; ++ i ) old_b += cost_branch256 ( ct + 2 * i , oldplist [ i ] ) ; old_b += cost_branch256 ( ct + 2 * PIVOT_NODE , oldplist [ PIVOT_NODE ] ) ; bestsavings = 0 ; bestnewp = oldp [ PIVOT_NODE ] ; <S2SV_StartBug> step = ( * bestp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ; <S2SV_EndBug> for ( newp = * bestp ; newp != oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } <S2SV_StartBug> * bestp = bestnewp ; <S2SV_EndBug> return bestsavings ; }
","<S2SV_ModStart> ct , const vpx_prob * oldp , vpx_prob <S2SV_ModEnd> * bestp , <S2SV_ModStart> * bestp , vpx_prob upd , int stepsize ) { int <S2SV_ModEnd> i , old_b <S2SV_ModStart> int newp ; vpx_prob <S2SV_ModEnd> bestnewp , newplist <S2SV_ModStart> oldplist ) ; memcpy <S2SV_ModEnd> ( newplist , <S2SV_ModStart> , sizeof ( vpx_prob <S2SV_ModEnd> ) * UNCONSTRAINED_NODES <S2SV_ModStart> PIVOT_NODE ] ; if ( * bestp > oldp [ PIVOT_NODE ] ) { step = - stepsize ; for ( newp = * bestp ; newp > <S2SV_ModEnd> oldp [ PIVOT_NODE <S2SV_ModStart> ; } } } else { step = stepsize ; for ( newp = * bestp ; newp < oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } } * bestp = bestnewp <S2SV_ModEnd> ; return bestsavings
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> const vp9_prob * oldp , <S2SV_EndBug> <S2SV_StartBug> vp9_prob upd ) { <S2SV_EndBug> <S2SV_StartBug> vp9_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( newplist , oldp , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ; <S2SV_EndBug> <S2SV_StartBug> step = ( * bestp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ; <S2SV_EndBug> <S2SV_StartBug> * bestp = bestnewp ; <S2SV_EndBug>"
3222,CWE-125,"int WavpackVerifySingleBlock ( unsigned char * buffer , int verify_checksum ) { WavpackHeader * wphdr = ( WavpackHeader * ) buffer ; uint32_t checksum_passed = 0 , bcount , meta_bc ; unsigned char * dp , meta_id , c1 , c2 ; if ( strncmp ( wphdr -> ckID , ""wvpk"" , 4 ) || wphdr -> ckSize + 8 < sizeof ( WavpackHeader ) ) return FALSE ; bcount = wphdr -> ckSize - sizeof ( WavpackHeader ) + 8 ; dp = ( unsigned char * ) ( wphdr + 1 ) ; while ( bcount >= 2 ) { meta_id = * dp ++ ; c1 = * dp ++ ; meta_bc = c1 << 1 ; bcount -= 2 ; if ( meta_id & ID_LARGE ) { if ( bcount < 2 ) return FALSE ; c1 = * dp ++ ; c2 = * dp ++ ; meta_bc += ( ( uint32_t ) c1 << 9 ) + ( ( uint32_t ) c2 << 17 ) ; bcount -= 2 ; } if ( bcount < meta_bc ) return FALSE ; if ( verify_checksum && ( meta_id & ID_UNIQUE ) == ID_BLOCK_CHECKSUM ) { # ifdef BITSTREAM_SHORTS uint16_t * csptr = ( uint16_t * ) buffer ; # else unsigned char * csptr = buffer ; # endif int wcount = ( int ) ( dp - 2 - buffer ) >> 1 ; uint32_t csum = ( uint32_t ) - 1 ; if ( ( meta_id & ID_ODD_SIZE ) || meta_bc < 2 || meta_bc > 4 ) return FALSE ; # ifdef BITSTREAM_SHORTS while ( wcount -- ) csum = ( csum * 3 ) + * csptr ++ ; # else WavpackNativeToLittleEndian ( ( WavpackHeader * ) buffer , WavpackHeaderFormat ) ; while ( wcount -- ) { csum = ( csum * 3 ) + csptr [ 0 ] + ( csptr [ 1 ] << 8 ) ; csptr += 2 ; } WavpackLittleEndianToNative ( ( WavpackHeader * ) buffer , WavpackHeaderFormat ) ; # endif if ( meta_bc == 4 ) { <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) ) <S2SV_EndBug> return FALSE ; } else { csum ^= csum >> 16 ; <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) ) <S2SV_EndBug> return FALSE ; } checksum_passed ++ ; } bcount -= meta_bc ; dp += meta_bc ; } return ( bcount == 0 ) && ( ! verify_checksum || ! ( wphdr -> flags & HAS_CHECKSUM ) || checksum_passed ) ; }
","<S2SV_ModStart> ( * dp <S2SV_ModEnd> != ( csum <S2SV_ModStart> 0xff ) || dp [ 1 ] <S2SV_ModEnd> != ( ( <S2SV_ModStart> 0xff ) || dp [ 2 ] <S2SV_ModEnd> != ( ( <S2SV_ModStart> 0xff ) || dp [ 3 ] <S2SV_ModEnd> != ( ( <S2SV_ModStart> ( * dp <S2SV_ModEnd> != ( csum <S2SV_ModStart> 0xff ) || dp [ 1 ] <S2SV_ModEnd> != ( (
",dbry@WavPack/bba5389dc598a92bdf2b297c3ea34620b6679b5b,CVE-2018-19841,https://github.com/dbry/WavPack/commit/bba5389dc598a92bdf2b297c3ea34620b6679b5b,2018-12-04T09:29Z,<S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) ) <S2SV_EndBug>
1683,CWE-119,"<S2SV_StartBug> static void fadst16 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s10 , s11 , s12 , s13 , s14 , s15 ; <S2SV_EndBug> <S2SV_StartBug> int x0 = input [ 15 ] ; <S2SV_EndBug> <S2SV_StartBug> int x1 = input [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int x2 = input [ 13 ] ; <S2SV_EndBug> <S2SV_StartBug> int x3 = input [ 2 ] ; <S2SV_EndBug> <S2SV_StartBug> int x4 = input [ 11 ] ; <S2SV_EndBug> <S2SV_StartBug> int x5 = input [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int x6 = input [ 9 ] ; <S2SV_EndBug> <S2SV_StartBug> int x7 = input [ 6 ] ; <S2SV_EndBug> <S2SV_StartBug> int x8 = input [ 7 ] ; <S2SV_EndBug> <S2SV_StartBug> int x9 = input [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int x10 = input [ 5 ] ; <S2SV_EndBug> <S2SV_StartBug> int x11 = input [ 10 ] ; <S2SV_EndBug> <S2SV_StartBug> int x12 = input [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> int x13 = input [ 12 ] ; <S2SV_EndBug> <S2SV_StartBug> int x14 = input [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int x15 = input [ 14 ] ; <S2SV_EndBug> s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ; s1 = x0 * cospi_31_64 - x1 * cospi_1_64 ; s2 = x2 * cospi_5_64 + x3 * cospi_27_64 ; s3 = x2 * cospi_27_64 - x3 * cospi_5_64 ; s4 = x4 * cospi_9_64 + x5 * cospi_23_64 ; s5 = x4 * cospi_23_64 - x5 * cospi_9_64 ; s6 = x6 * cospi_13_64 + x7 * cospi_19_64 ; s7 = x6 * cospi_19_64 - x7 * cospi_13_64 ; s8 = x8 * cospi_17_64 + x9 * cospi_15_64 ; s9 = x8 * cospi_15_64 - x9 * cospi_17_64 ; s10 = x10 * cospi_21_64 + x11 * cospi_11_64 ; s11 = x10 * cospi_11_64 - x11 * cospi_21_64 ; s12 = x12 * cospi_25_64 + x13 * cospi_7_64 ; s13 = x12 * cospi_7_64 - x13 * cospi_25_64 ; s14 = x14 * cospi_29_64 + x15 * cospi_3_64 ; s15 = x14 * cospi_3_64 - x15 * cospi_29_64 ; x0 = fdct_round_shift ( s0 + s8 ) ; x1 = fdct_round_shift ( s1 + s9 ) ; x2 = fdct_round_shift ( s2 + s10 ) ; x3 = fdct_round_shift ( s3 + s11 ) ; x4 = fdct_round_shift ( s4 + s12 ) ; x5 = fdct_round_shift ( s5 + s13 ) ; x6 = fdct_round_shift ( s6 + s14 ) ; x7 = fdct_round_shift ( s7 + s15 ) ; x8 = fdct_round_shift ( s0 - s8 ) ; x9 = fdct_round_shift ( s1 - s9 ) ; x10 = fdct_round_shift ( s2 - s10 ) ; x11 = fdct_round_shift ( s3 - s11 ) ; x12 = fdct_round_shift ( s4 - s12 ) ; x13 = fdct_round_shift ( s5 - s13 ) ; x14 = fdct_round_shift ( s6 - s14 ) ; x15 = fdct_round_shift ( s7 - s15 ) ; s0 = x0 ; s1 = x1 ; s2 = x2 ; s3 = x3 ; s4 = x4 ; s5 = x5 ; s6 = x6 ; s7 = x7 ; s8 = x8 * cospi_4_64 + x9 * cospi_28_64 ; s9 = x8 * cospi_28_64 - x9 * cospi_4_64 ; s10 = x10 * cospi_20_64 + x11 * cospi_12_64 ; s11 = x10 * cospi_12_64 - x11 * cospi_20_64 ; s12 = - x12 * cospi_28_64 + x13 * cospi_4_64 ; s13 = x12 * cospi_4_64 + x13 * cospi_28_64 ; s14 = - x14 * cospi_12_64 + x15 * cospi_20_64 ; s15 = x14 * cospi_20_64 + x15 * cospi_12_64 ; x0 = s0 + s4 ; x1 = s1 + s5 ; x2 = s2 + s6 ; x3 = s3 + s7 ; x4 = s0 - s4 ; x5 = s1 - s5 ; x6 = s2 - s6 ; x7 = s3 - s7 ; x8 = fdct_round_shift ( s8 + s12 ) ; x9 = fdct_round_shift ( s9 + s13 ) ; x10 = fdct_round_shift ( s10 + s14 ) ; x11 = fdct_round_shift ( s11 + s15 ) ; x12 = fdct_round_shift ( s8 - s12 ) ; x13 = fdct_round_shift ( s9 - s13 ) ; x14 = fdct_round_shift ( s10 - s14 ) ; x15 = fdct_round_shift ( s11 - s15 ) ; s0 = x0 ; s1 = x1 ; s2 = x2 ; s3 = x3 ; s4 = x4 * cospi_8_64 + x5 * cospi_24_64 ; s5 = x4 * cospi_24_64 - x5 * cospi_8_64 ; s6 = - x6 * cospi_24_64 + x7 * cospi_8_64 ; s7 = x6 * cospi_8_64 + x7 * cospi_24_64 ; s8 = x8 ; s9 = x9 ; s10 = x10 ; s11 = x11 ; s12 = x12 * cospi_8_64 + x13 * cospi_24_64 ; s13 = x12 * cospi_24_64 - x13 * cospi_8_64 ; s14 = - x14 * cospi_24_64 + x15 * cospi_8_64 ; s15 = x14 * cospi_8_64 + x15 * cospi_24_64 ; x0 = s0 + s2 ; x1 = s1 + s3 ; x2 = s0 - s2 ; x3 = s1 - s3 ; x4 = fdct_round_shift ( s4 + s6 ) ; x5 = fdct_round_shift ( s5 + s7 ) ; x6 = fdct_round_shift ( s4 - s6 ) ; x7 = fdct_round_shift ( s5 - s7 ) ; x8 = s8 + s10 ; x9 = s9 + s11 ; x10 = s8 - s10 ; x11 = s9 - s11 ; x12 = fdct_round_shift ( s12 + s14 ) ; x13 = fdct_round_shift ( s13 + s15 ) ; x14 = fdct_round_shift ( s12 - s14 ) ; x15 = fdct_round_shift ( s13 - s15 ) ; s2 = ( - cospi_16_64 ) * ( x2 + x3 ) ; s3 = cospi_16_64 * ( x2 - x3 ) ; s6 = cospi_16_64 * ( x6 + x7 ) ; s7 = cospi_16_64 * ( - x6 + x7 ) ; s10 = cospi_16_64 * ( x10 + x11 ) ; s11 = cospi_16_64 * ( - x10 + x11 ) ; s14 = ( - cospi_16_64 ) * ( x14 + x15 ) ; s15 = cospi_16_64 * ( x14 - x15 ) ; x2 = fdct_round_shift ( s2 ) ; x3 = fdct_round_shift ( s3 ) ; x6 = fdct_round_shift ( s6 ) ; x7 = fdct_round_shift ( s7 ) ; x10 = fdct_round_shift ( s10 ) ; x11 = fdct_round_shift ( s11 ) ; x14 = fdct_round_shift ( s14 ) ; x15 = fdct_round_shift ( s15 ) ; <S2SV_StartBug> output [ 0 ] = x0 ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = - x8 ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = x12 ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = - x4 ; <S2SV_EndBug> <S2SV_StartBug> output [ 4 ] = x6 ; <S2SV_EndBug> <S2SV_StartBug> output [ 5 ] = x14 ; <S2SV_EndBug> <S2SV_StartBug> output [ 6 ] = x10 ; <S2SV_EndBug> <S2SV_StartBug> output [ 7 ] = x2 ; <S2SV_EndBug> <S2SV_StartBug> output [ 8 ] = x3 ; <S2SV_EndBug> <S2SV_StartBug> output [ 9 ] = x11 ; <S2SV_EndBug> <S2SV_StartBug> output [ 10 ] = x15 ; <S2SV_EndBug> <S2SV_StartBug> output [ 11 ] = x7 ; <S2SV_EndBug> <S2SV_StartBug> output [ 12 ] = x5 ; <S2SV_EndBug> <S2SV_StartBug> output [ 13 ] = - x13 ; <S2SV_EndBug> <S2SV_StartBug> output [ 14 ] = x9 ; <S2SV_EndBug> <S2SV_StartBug> output [ 15 ] = - x1 ; <S2SV_EndBug> }
","<S2SV_ModStart> fadst16 ( const tran_low_t <S2SV_ModEnd> * input , <S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output ) <S2SV_ModStart> output ) { tran_high_t <S2SV_ModEnd> s0 , s1 <S2SV_ModStart> s7 , s8 ; tran_high_t <S2SV_ModEnd> s9 , s10 <S2SV_ModStart> , s15 ; tran_high_t <S2SV_ModEnd> x0 = input <S2SV_ModStart> 15 ] ; tran_high_t <S2SV_ModEnd> x1 = input <S2SV_ModStart> 0 ] ; tran_high_t <S2SV_ModEnd> x2 = input <S2SV_ModStart> 13 ] ; tran_high_t <S2SV_ModEnd> x3 = input <S2SV_ModStart> 2 ] ; tran_high_t <S2SV_ModEnd> x4 = input <S2SV_ModStart> 11 ] ; tran_high_t <S2SV_ModEnd> x5 = input <S2SV_ModStart> 4 ] ; tran_high_t <S2SV_ModEnd> x6 = input <S2SV_ModStart> 9 ] ; tran_high_t <S2SV_ModEnd> x7 = input <S2SV_ModStart> 6 ] ; tran_high_t <S2SV_ModEnd> x8 = input <S2SV_ModStart> 7 ] ; tran_high_t <S2SV_ModEnd> x9 = input <S2SV_ModStart> 8 ] ; tran_high_t <S2SV_ModEnd> x10 = input <S2SV_ModStart> 5 ] ; tran_high_t <S2SV_ModEnd> x11 = input <S2SV_ModStart> 10 ] ; tran_high_t <S2SV_ModEnd> x12 = input <S2SV_ModStart> 3 ] ; tran_high_t <S2SV_ModEnd> x13 = input <S2SV_ModStart> 12 ] ; tran_high_t <S2SV_ModEnd> x14 = input <S2SV_ModStart> 1 ] ; tran_high_t <S2SV_ModEnd> x15 = input <S2SV_ModStart> 0 ] = ( tran_low_t ) <S2SV_ModStart> 1 ] = ( tran_low_t ) <S2SV_ModStart> 2 ] = ( tran_low_t ) <S2SV_ModStart> 3 ] = ( tran_low_t ) <S2SV_ModStart> 4 ] = ( tran_low_t ) <S2SV_ModStart> 5 ] = ( tran_low_t ) <S2SV_ModStart> 6 ] = ( tran_low_t ) <S2SV_ModStart> 7 ] = ( tran_low_t ) <S2SV_ModStart> 8 ] = ( tran_low_t ) <S2SV_ModStart> 9 ] = ( tran_low_t ) <S2SV_ModStart> 10 ] = ( tran_low_t ) <S2SV_ModStart> 11 ] = ( tran_low_t ) <S2SV_ModStart> 12 ] = ( tran_low_t ) <S2SV_ModStart> 13 ] = ( tran_low_t ) <S2SV_ModStart> 14 ] = ( tran_low_t ) <S2SV_ModStart> 15 ] = ( tran_low_t )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void fadst16 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s10 , s11 , s12 , s13 , s14 , s15 ; <S2SV_EndBug> <S2SV_StartBug> int x0 = input [ 15 ] ; <S2SV_EndBug> <S2SV_StartBug> int x1 = input [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int x2 = input [ 13 ] ; <S2SV_EndBug> <S2SV_StartBug> int x3 = input [ 2 ] ; <S2SV_EndBug> <S2SV_StartBug> int x4 = input [ 11 ] ; <S2SV_EndBug> <S2SV_StartBug> int x5 = input [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int x6 = input [ 9 ] ; <S2SV_EndBug> <S2SV_StartBug> int x7 = input [ 6 ] ; <S2SV_EndBug> <S2SV_StartBug> int x8 = input [ 7 ] ; <S2SV_EndBug> <S2SV_StartBug> int x9 = input [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int x10 = input [ 5 ] ; <S2SV_EndBug> <S2SV_StartBug> int x11 = input [ 10 ] ; <S2SV_EndBug> <S2SV_StartBug> int x12 = input [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> int x13 = input [ 12 ] ; <S2SV_EndBug> <S2SV_StartBug> int x14 = input [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int x15 = input [ 14 ] ; <S2SV_EndBug> <S2SV_StartBug> output [ 0 ] = x0 ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = - x8 ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = x12 ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = - x4 ; <S2SV_EndBug> <S2SV_StartBug> output [ 4 ] = x6 ; <S2SV_EndBug> <S2SV_StartBug> output [ 5 ] = x14 ; <S2SV_EndBug> <S2SV_StartBug> output [ 6 ] = x10 ; <S2SV_EndBug> <S2SV_StartBug> output [ 7 ] = x2 ; <S2SV_EndBug> <S2SV_StartBug> output [ 8 ] = x3 ; <S2SV_EndBug> <S2SV_StartBug> output [ 9 ] = x11 ; <S2SV_EndBug> <S2SV_StartBug> output [ 10 ] = x15 ; <S2SV_EndBug> <S2SV_StartBug> output [ 11 ] = x7 ; <S2SV_EndBug> <S2SV_StartBug> output [ 12 ] = x5 ; <S2SV_EndBug> <S2SV_StartBug> output [ 13 ] = - x13 ; <S2SV_EndBug> <S2SV_StartBug> output [ 14 ] = x9 ; <S2SV_EndBug> <S2SV_StartBug> output [ 15 ] = - x1 ; <S2SV_EndBug>"
3286,CWE-20,"static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <S2SV_StartBug> return 1 ; <S2SV_EndBug> case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return 1 ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_PREEMPTION_TIMER : return vmcs12 -> pin_based_vm_exec_control & PIN_BASED_VMX_PREEMPTION_TIMER ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }
","<S2SV_ModStart> case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :
",torvalds@linux/bfd0a56b90005f8c8a004baf407ad90045c2b11e,CVE-2014-3645,https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e,2014-11-10T11:55Z,<S2SV_StartBug> return 1 ; <S2SV_EndBug>
8375,CWE-362,"int tcp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; __be16 orig_sport , orig_dport ; __be32 daddr , nexthop ; struct flowi4 fl4 ; struct rtable * rt ; <S2SV_StartBug> int err ; <S2SV_EndBug> if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) return - EAFNOSUPPORT ; nexthop = daddr = usin -> sin_addr . s_addr ; <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) { <S2SV_EndBug> if ( ! daddr ) return - EINVAL ; <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> } orig_sport = inet -> inet_sport ; orig_dport = usin -> sin_port ; rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , IPPROTO_TCP , orig_sport , orig_dport , sk , true ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; if ( err == - ENETUNREACH ) IP_INC_STATS_BH ( sock_net ( sk ) , IPSTATS_MIB_OUTNOROUTES ) ; return err ; } if ( rt -> rt_flags & ( RTCF_MULTICAST | RTCF_BROADCAST ) ) { ip_rt_put ( rt ) ; return - ENETUNREACH ; } <S2SV_StartBug> if ( ! inet -> opt || ! inet -> opt -> srr ) <S2SV_EndBug> daddr = rt -> rt_dst ; if ( ! inet -> inet_saddr ) inet -> inet_saddr = rt -> rt_src ; inet -> inet_rcv_saddr = inet -> inet_saddr ; if ( tp -> rx_opt . ts_recent_stamp && inet -> inet_daddr != daddr ) { tp -> rx_opt . ts_recent = 0 ; tp -> rx_opt . ts_recent_stamp = 0 ; tp -> write_seq = 0 ; } if ( tcp_death_row . sysctl_tw_recycle && ! tp -> rx_opt . ts_recent_stamp && rt -> rt_dst == daddr ) { struct inet_peer * peer = rt_get_peer ( rt ) ; if ( peer ) { inet_peer_refcheck ( peer ) ; if ( ( u32 ) get_seconds ( ) - peer -> tcp_ts_stamp <= TCP_PAWS_MSL ) { tp -> rx_opt . ts_recent_stamp = peer -> tcp_ts_stamp ; tp -> rx_opt . ts_recent = peer -> tcp_ts ; } } } inet -> inet_dport = usin -> sin_port ; inet -> inet_daddr = daddr ; inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ; <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug> inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; tp -> rx_opt . mss_clamp = TCP_MSS_DEFAULT ; tcp_set_state ( sk , TCP_SYN_SENT ) ; err = inet_hash_connect ( & tcp_death_row , sk ) ; if ( err ) goto failure ; rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , inet -> inet_sport , inet -> inet_dport , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; goto failure ; } sk -> sk_gso_type = SKB_GSO_TCPV4 ; sk_setup_caps ( sk , & rt -> dst ) ; if ( ! tp -> write_seq ) tp -> write_seq = secure_tcp_sequence_number ( inet -> inet_saddr , inet -> inet_daddr , inet -> inet_sport , usin -> sin_port ) ; inet -> inet_id = tp -> write_seq ^ jiffies ; err = tcp_connect ( sk ) ; rt = NULL ; if ( err ) goto failure ; return 0 ; failure : tcp_set_state ( sk , TCP_CLOSE ) ; ip_rt_put ( rt ) ; sk -> sk_route_caps = 0 ; inet -> inet_dport = 0 ; return err ; }
","<S2SV_ModStart> ; int err ; struct ip_options_rcu * inet_opt <S2SV_ModStart> . s_addr ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> srr ) { <S2SV_ModStart> ; nexthop = inet_opt -> opt . <S2SV_ModEnd> faddr ; } <S2SV_ModStart> if ( ! inet_opt || ! inet_opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> ; if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> optlen ; tp
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> if ( ! inet -> opt || ! inet -> opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug>
4089,CWE-399,"static int br_parse_ip_options ( struct sk_buff * skb ) { struct ip_options * opt ; struct iphdr * iph ; struct net_device * dev = skb -> dev ; u32 len ; iph = ip_hdr ( skb ) ; opt = & ( IPCB ( skb ) -> opt ) ; if ( iph -> ihl < 5 || iph -> version != 4 ) goto inhdr_error ; if ( ! pskb_may_pull ( skb , iph -> ihl * 4 ) ) goto inhdr_error ; iph = ip_hdr ( skb ) ; if ( unlikely ( ip_fast_csum ( ( u8 * ) iph , iph -> ihl ) ) ) goto inhdr_error ; len = ntohs ( iph -> tot_len ) ; if ( skb -> len < len ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INTRUNCATEDPKTS ) ; goto drop ; } else if ( len < ( iph -> ihl * 4 ) ) goto inhdr_error ; if ( pskb_trim_rcsum ( skb , len ) ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INDISCARDS ) ; goto drop ; } <S2SV_StartBug> if ( iph -> ihl == 5 ) { <S2SV_EndBug> memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ; if ( ip_options_compile ( dev_net ( dev ) , opt , skb ) ) goto inhdr_error ; if ( unlikely ( opt -> srr ) ) { struct in_device * in_dev = __in_dev_get_rcu ( dev ) ; if ( in_dev && ! IN_DEV_SOURCE_ROUTE ( in_dev ) ) goto drop ; if ( ip_options_rcv_srr ( skb ) ) goto drop ; } return 0 ; inhdr_error : IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INHDRERRORS ) ; drop : return - 1 ; }
","<S2SV_ModStart> drop ; } memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <S2SV_ModStart> == 5 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> opt -> optlen
",torvalds@linux/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,CVE-2011-4087,https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,2013-06-08T13:05Z,<S2SV_StartBug> if ( iph -> ihl == 5 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
193,CWE-399,"static void kvmclock_reset ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( vcpu -> arch . time_page ) { <S2SV_EndBug> kvm_release_page_dirty ( vcpu -> arch . time_page ) ; vcpu -> arch . time_page = NULL ; } }
","<S2SV_ModStart> vcpu ) { <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> -> arch . pv_time_enabled = false ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/0b79459b482e85cb7426aa7da683a9f2c97aeae1,CVE-2013-1797,https://github.com/torvalds/linux/commit/0b79459b482e85cb7426aa7da683a9f2c97aeae1,2013-03-22T11:59Z,<S2SV_StartBug> if ( vcpu -> arch . time_page ) { <S2SV_EndBug>
3396,CWE-404,"int nfs3svc_decode_readargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readargs * args ) { unsigned int len ; int v ; u32 max_blocksize = svc_max_payload ( rqstp ) ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; <S2SV_StartBug> args -> count = ntohl ( * p ++ ) ; <S2SV_EndBug> len = min ( args -> count , max_blocksize ) ; v = 0 ; while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; rqstp -> rq_vec [ v ] . iov_base = page_address ( p ) ; rqstp -> rq_vec [ v ] . iov_len = min_t ( unsigned int , len , PAGE_SIZE ) ; len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; } args -> vlen = v ; <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
","<S2SV_ModStart> p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> v ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z,"<S2SV_StartBug> args -> count = ntohl ( * p ++ ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug>"
355,CWE-200,"int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; int openasuser ; int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; int should_free_authpending_file = 0 ; parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name"" ) ; goto done ; } DBG ( ""Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\""%s\\"""" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( ""Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)"" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( ""Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)"" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s"" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( ""Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s"" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)"" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( ""Found<S2SV_blank>user<S2SV_blank>%s"" , user ) ; DBG ( ""Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s"" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)"" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( ""/.config"" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ; } DBG ( ""Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; cfg -> auth_file = buf ; should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; } openasuser = geteuid ( ) == 0 && cfg -> openasuser ; if ( openasuser ) { if ( seteuid ( pw_s . pw_uid ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { if ( seteuid ( 0 ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication"" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting."" ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted"" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( ""authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled"" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( ""Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications"" , cfg -> authpending_file ) ; <S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> if ( authpending_file_descriptor < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( ""do_authentication<S2SV_blank>returned<S2SV_blank>%d"" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( ""alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)"" , retval ) ; retval = PAM_SUCCESS ; } DBG ( ""done.<S2SV_blank>[%s]"" , pam_strerror ( pamh , retval ) ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }
","<S2SV_ModStart> O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; }
",Yubico@pam-u2f/18b1914e32b74ff52000f10e97067e841e5fff62,CVE-2019-12210,https://github.com/Yubico/pam-u2f/commit/18b1914e32b74ff52000f10e97067e841e5fff62,2019-06-04T21:29Z,"<S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug>"
871,CWE-200,"static long sg_ioctl ( struct file * filp , unsigned int cmd_in , unsigned long arg ) { void __user * p = ( void __user * ) arg ; int __user * ip = p ; int result , val , read_only ; Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; unsigned long iflags ; if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) return - ENXIO ; SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sdp , ""sg_ioctl:<S2SV_blank>cmd=0x%x\\n"" , ( int ) cmd_in ) ) ; read_only = ( O_RDWR != ( filp -> f_flags & O_ACCMODE ) ) ; switch ( cmd_in ) { case SG_IO : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( ! scsi_block_when_processing_errors ( sdp -> device ) ) return - ENXIO ; if ( ! access_ok ( VERIFY_WRITE , p , SZ_SG_IO_HDR ) ) return - EFAULT ; result = sg_new_write ( sfp , filp , p , SZ_SG_IO_HDR , 1 , read_only , 1 , & srp ) ; if ( result < 0 ) return result ; result = wait_event_interruptible ( sfp -> read_wait , ( srp_done ( sfp , srp ) || atomic_read ( & sdp -> detaching ) ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; write_lock_irq ( & sfp -> rq_list_lock ) ; if ( srp -> done ) { srp -> done = 2 ; write_unlock_irq ( & sfp -> rq_list_lock ) ; result = sg_new_read ( sfp , p , SZ_SG_IO_HDR , srp ) ; return ( result < 0 ) ? result : 0 ; } srp -> orphan = 1 ; write_unlock_irq ( & sfp -> rq_list_lock ) ; return result ; case SG_SET_TIMEOUT : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val < 0 ) return - EIO ; if ( val >= mult_frac ( ( s64 ) INT_MAX , USER_HZ , HZ ) ) val = min_t ( s64 , mult_frac ( ( s64 ) INT_MAX , USER_HZ , HZ ) , INT_MAX ) ; sfp -> timeout_user = val ; sfp -> timeout = mult_frac ( val , HZ , USER_HZ ) ; return 0 ; case SG_GET_TIMEOUT : return sfp -> timeout_user ; case SG_SET_FORCE_LOW_DMA : return 0 ; case SG_GET_LOW_DMA : return put_user ( ( int ) sdp -> device -> host -> unchecked_isa_dma , ip ) ; case SG_GET_SCSI_ID : if ( ! access_ok ( VERIFY_WRITE , p , sizeof ( sg_scsi_id_t ) ) ) return - EFAULT ; else { sg_scsi_id_t __user * sg_idp = p ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; __put_user ( ( int ) sdp -> device -> host -> host_no , & sg_idp -> host_no ) ; __put_user ( ( int ) sdp -> device -> channel , & sg_idp -> channel ) ; __put_user ( ( int ) sdp -> device -> id , & sg_idp -> scsi_id ) ; __put_user ( ( int ) sdp -> device -> lun , & sg_idp -> lun ) ; __put_user ( ( int ) sdp -> device -> type , & sg_idp -> scsi_type ) ; __put_user ( ( short ) sdp -> device -> host -> cmd_per_lun , & sg_idp -> h_cmd_per_lun ) ; __put_user ( ( short ) sdp -> device -> queue_depth , & sg_idp -> d_queue_depth ) ; __put_user ( 0 , & sg_idp -> unused [ 0 ] ) ; __put_user ( 0 , & sg_idp -> unused [ 1 ] ) ; return 0 ; } case SG_SET_FORCE_PACK_ID : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> force_packid = val ? 1 : 0 ; return 0 ; case SG_GET_PACK_ID : if ( ! access_ok ( VERIFY_WRITE , ip , sizeof ( int ) ) ) return - EFAULT ; read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( ( 1 == srp -> done ) && ( ! srp -> sg_io_owned ) ) { read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; __put_user ( srp -> header . pack_id , ip ) ; return 0 ; } } read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; __put_user ( - 1 , ip ) ; return 0 ; case SG_GET_NUM_WAITING : read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( ( 1 == srp -> done ) && ( ! srp -> sg_io_owned ) ) ++ val ; } read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; return put_user ( val , ip ) ; case SG_GET_SG_TABLESIZE : return put_user ( sdp -> sg_tablesize , ip ) ; case SG_SET_RESERVED_SIZE : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val < 0 ) return - EINVAL ; val = min_t ( int , val , max_sectors_bytes ( sdp -> device -> request_queue ) ) ; mutex_lock ( & sfp -> f_mutex ) ; if ( val != sfp -> reserve . bufflen ) { if ( sfp -> mmap_called || sfp -> res_in_use ) { mutex_unlock ( & sfp -> f_mutex ) ; return - EBUSY ; } sg_remove_scat ( sfp , & sfp -> reserve ) ; sg_build_reserve ( sfp , val ) ; } mutex_unlock ( & sfp -> f_mutex ) ; return 0 ; case SG_GET_RESERVED_SIZE : val = min_t ( int , sfp -> reserve . bufflen , max_sectors_bytes ( sdp -> device -> request_queue ) ) ; return put_user ( val , ip ) ; case SG_SET_COMMAND_Q : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> cmd_q = val ? 1 : 0 ; return 0 ; case SG_GET_COMMAND_Q : return put_user ( ( int ) sfp -> cmd_q , ip ) ; case SG_SET_KEEP_ORPHAN : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> keep_orphan = val ; return 0 ; case SG_GET_KEEP_ORPHAN : return put_user ( ( int ) sfp -> keep_orphan , ip ) ; case SG_NEXT_CMD_LEN : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val > SG_MAX_CDB_SIZE ) return - ENOMEM ; sfp -> next_cmd_len = ( val > 0 ) ? val : 0 ; return 0 ; case SG_GET_VERSION_NUM : return put_user ( sg_version_num , ip ) ; case SG_GET_ACCESS_COUNT : val = ( sdp -> device ? 1 : 0 ) ; return put_user ( val , ip ) ; case SG_GET_REQUEST_TABLE : if ( ! access_ok ( VERIFY_WRITE , p , SZ_SG_REQ_INFO * SG_MAX_QUEUE ) ) return - EFAULT ; else { sg_req_info_t * rinfo ; <S2SV_StartBug> rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , <S2SV_EndBug> GFP_KERNEL ) ; if ( ! rinfo ) return - ENOMEM ; read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; sg_fill_request_table ( sfp , rinfo ) ; read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; result = __copy_to_user ( p , rinfo , SZ_SG_REQ_INFO * SG_MAX_QUEUE ) ; result = result ? - EFAULT : 0 ; kfree ( rinfo ) ; return result ; } case SG_EMULATED_HOST : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; return put_user ( sdp -> device -> host -> hostt -> emulated , ip ) ; case SCSI_IOCTL_SEND_COMMAND : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( read_only ) { unsigned char opcode = WRITE_6 ; Scsi_Ioctl_Command __user * siocp = p ; if ( copy_from_user ( & opcode , siocp -> data , 1 ) ) return - EFAULT ; if ( sg_allow_access ( filp , & opcode ) ) return - EPERM ; } return sg_scsi_ioctl ( sdp -> device -> request_queue , NULL , filp -> f_mode , p ) ; case SG_SET_DEBUG : result = get_user ( val , ip ) ; if ( result ) return result ; sdp -> sgdebug = ( char ) val ; return 0 ; case BLKSECTGET : return put_user ( max_sectors_bytes ( sdp -> device -> request_queue ) , ip ) ; case BLKTRACESETUP : return blk_trace_setup ( sdp -> device -> request_queue , sdp -> disk -> disk_name , MKDEV ( SCSI_GENERIC_MAJOR , sdp -> index ) , NULL , p ) ; case BLKTRACESTART : return blk_trace_startstop ( sdp -> device -> request_queue , 1 ) ; case BLKTRACESTOP : return blk_trace_startstop ( sdp -> device -> request_queue , 0 ) ; case BLKTRACETEARDOWN : return blk_trace_remove ( sdp -> device -> request_queue ) ; case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : case SCSI_IOCTL_PROBE_HOST : case SG_GET_TRANSFORM : case SG_SCSI_RESET : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; break ; default : if ( read_only ) return - EPERM ; break ; } result = scsi_ioctl_block_when_processing_errors ( sdp -> device , cmd_in , filp -> f_flags & O_NDELAY ) ; if ( result ) return result ; return scsi_ioctl ( sdp -> device , cmd_in , p ) ; }
","<S2SV_ModStart> ; rinfo = kzalloc <S2SV_ModEnd> ( SZ_SG_REQ_INFO *
",torvalds@linux/3e0097499839e0fe3af380410eababe5a47c4cf9,CVE-2017-14991,https://github.com/torvalds/linux/commit/3e0097499839e0fe3af380410eababe5a47c4cf9,2017-10-04T01:29Z,"<S2SV_StartBug> rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , <S2SV_EndBug>"
2440,CWE-000,"static int ax25_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; ax25_cb * ax25 ; <S2SV_StartBug> if ( ! net_eq ( net , & init_net ) ) <S2SV_EndBug> return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_DGRAM : if ( protocol == 0 || protocol == PF_AX25 ) protocol = AX25_P_TEXT ; break ; case SOCK_SEQPACKET : switch ( protocol ) { case 0 : case PF_AX25 : protocol = AX25_P_TEXT ; break ; case AX25_P_SEGMENT : # ifdef CONFIG_INET case AX25_P_ARP : case AX25_P_IP : # endif # ifdef CONFIG_NETROM case AX25_P_NETROM : # endif # ifdef CONFIG_ROSE case AX25_P_ROSE : # endif return - ESOCKTNOSUPPORT ; # ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM : if ( ax25_protocol_is_registered ( AX25_P_NETROM ) ) return - ESOCKTNOSUPPORT ; break ; # endif # ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE : if ( ax25_protocol_is_registered ( AX25_P_ROSE ) ) return - ESOCKTNOSUPPORT ; # endif default : break ; } break ; case SOCK_RAW : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_AX25 , GFP_ATOMIC , & ax25_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; ax25 = ax25_sk ( sk ) -> cb = ax25_create_cb ( ) ; if ( ! ax25 ) { sk_free ( sk ) ; return - ENOMEM ; } sock_init_data ( sock , sk ) ; sk -> sk_destruct = ax25_free_sock ; sock -> ops = & ax25_proto_ops ; sk -> sk_protocol = protocol ; ax25 -> sk = sk ; return 0 ; }
","<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
",torvalds@linux/79462ad02e861803b3840cc782248c7359451cd9,CVE-2015-8543,https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9,2015-12-28T11:59Z,"<S2SV_StartBug> if ( ! net_eq ( net , & init_net ) ) <S2SV_EndBug>"
5995,CWE-119,"int psf_binheader_writef ( SF_PRIVATE * psf , const char * format , ... ) { va_list argptr ; sf_count_t countdata ; unsigned long longdata ; unsigned int data ; float floatdata ; double doubledata ; void * bindata ; size_t size ; char c , * strptr ; int count = 0 , trunc_8to4 ; trunc_8to4 = SF_FALSE ; va_start ( argptr , format ) ; while ( ( c = * format ++ ) ) <S2SV_StartBug> { switch ( c ) <S2SV_EndBug> { case '<S2SV_blank>' : break ; case 'e' : psf -> rwf_endian = SF_ENDIAN_LITTLE ; break ; case 'E' : psf -> rwf_endian = SF_ENDIAN_BIG ; break ; case 't' : trunc_8to4 = SF_TRUE ; break ; case 'T' : trunc_8to4 = SF_FALSE ; break ; case 'm' : data = va_arg ( argptr , unsigned int ) ; header_put_marker ( psf , data ) ; count += 4 ; break ; case '1' : data = va_arg ( argptr , unsigned int ) ; header_put_byte ( psf , data ) ; count += 1 ; break ; case '2' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) { header_put_be_short ( psf , data ) ; } else { header_put_le_short ( psf , data ) ; } ; count += 2 ; break ; case '3' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) { header_put_be_3byte ( psf , data ) ; } else { header_put_le_3byte ( psf , data ) ; } ; count += 3 ; break ; case '4' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) { header_put_be_int ( psf , data ) ; } else { header_put_le_int ( psf , data ) ; } ; count += 4 ; break ; case '8' : countdata = va_arg ( argptr , sf_count_t ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE ) { header_put_be_8byte ( psf , countdata ) ; count += 8 ; } else if ( psf -> rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE ) { header_put_le_8byte ( psf , countdata ) ; count += 8 ; } else if ( psf -> rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE ) { longdata = countdata & 0xFFFFFFFF ; header_put_be_int ( psf , longdata ) ; count += 4 ; } else if ( psf -> rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE ) { longdata = countdata & 0xFFFFFFFF ; header_put_le_int ( psf , longdata ) ; count += 4 ; } break ; case 'f' : floatdata = ( float ) va_arg ( argptr , double ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) <S2SV_StartBug> float32_be_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> else <S2SV_StartBug> float32_le_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> psf -> headindex += 4 ; count += 4 ; break ; case 'd' : doubledata = va_arg ( argptr , double ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) <S2SV_StartBug> double64_be_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> else <S2SV_StartBug> double64_le_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> psf -> headindex += 8 ; count += 8 ; break ; case 's' : strptr = va_arg ( argptr , char * ) ; size = strlen ( strptr ) + 1 ; <S2SV_StartBug> size += ( size & 1 ) ; <S2SV_EndBug> if ( psf -> rwf_endian == SF_ENDIAN_BIG ) header_put_be_int ( psf , size ) ; else header_put_le_int ( psf , size ) ; <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex - 1 ] = 0 ; <S2SV_EndBug> count += 4 + size ; break ; case 'S' : strptr = va_arg ( argptr , char * ) ; size = strlen ( strptr ) ; <S2SV_StartBug> if ( psf -> rwf_endian == SF_ENDIAN_BIG ) <S2SV_EndBug> header_put_be_int ( psf , size ) ; else header_put_le_int ( psf , size ) ; <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size + 1 ) ; <S2SV_EndBug> size += ( size & 1 ) ; <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ] = 0 ; <S2SV_EndBug> count += 4 + size ; break ; case 'p' : strptr = va_arg ( argptr , char * ) ; size = strlen ( strptr ) ; size = ( size & 1 ) ? size : size + 1 ; size = ( size > 254 ) ? 254 : size ; <S2SV_StartBug> header_put_byte ( psf , size ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> count += 1 + size ; break ; case 'b' : bindata = va_arg ( argptr , void * ) ; size = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( psf -> headindex + size < sizeof ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> { memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , size ) ; <S2SV_EndBug> psf -> headindex += size ; count += size ; } ; break ; case 'z' : size = va_arg ( argptr , size_t ) ; count += size ; while ( size ) { psf -> header [ psf -> headindex ] = 0 ; <S2SV_StartBug> psf -> headindex ++ ; <S2SV_EndBug> size -- ; } ; break ; case 'h' : bindata = va_arg ( argptr , void * ) ; <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += 16 ; <S2SV_EndBug> count += 16 ; break ; case 'j' : size = va_arg ( argptr , size_t ) ; <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> count += size ; break ; case 'o' : size = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( size < sizeof ( psf -> header ) ) <S2SV_EndBug> { psf -> headindex = size ; count = 0 ; } ; break ; default : psf_log_printf ( psf , ""***<S2SV_blank>Invalid<S2SV_blank>format<S2SV_blank>specifier<S2SV_blank>`%c\'\\n"" , c ) ; psf -> error = SFE_INTERNAL ; break ; } ; } ; va_end ( argptr ) ; return count ; }
","<S2SV_ModStart> ) ) { if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> psf -> header . ptr + psf -> header . indx <S2SV_ModEnd> ) ; else <S2SV_ModStart> psf -> header . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> += 4 ; <S2SV_ModStart> psf -> header . ptr + psf -> header . indx <S2SV_ModEnd> ) ; else <S2SV_ModStart> psf -> header . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> += 8 ; <S2SV_ModStart> & 1 ) ; if ( psf -> header . indx + ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> - 1 ] <S2SV_ModStart> ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; if ( psf -> <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] = 0 <S2SV_ModStart> : size ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> += size ; <S2SV_ModStart> ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; memcpy ( & ( psf -> header . ptr [ psf -> header . indx ] ) , bindata , size ) ; psf -> header . indx += size ; count += size ; break ; case 'z' : size = va_arg ( argptr , size_t ) ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; count += size ; while ( size ) { psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx ] <S2SV_ModEnd> = 0 ; <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> ++ ; size <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> += 16 ; <S2SV_ModStart> size_t ) ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx <S2SV_ModEnd> += size ; <S2SV_ModStart> ; if ( ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx = size <S2SV_ModEnd> ; break ;
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,"<S2SV_StartBug> { switch ( c ) <S2SV_EndBug> <S2SV_StartBug> float32_be_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> float32_le_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> double64_be_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> double64_le_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> size += ( size & 1 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex - 1 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> rwf_endian == SF_ENDIAN_BIG ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> header_put_byte ( psf , size ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + size < sizeof ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> { memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex ++ ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += 16 ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> if ( size < sizeof ( psf -> header ) ) <S2SV_EndBug>"
1446,CWE-119,"static void cyclic_background_refresh ( VP8_COMP * cpi , int Q , int lf_adjustment ) { unsigned char * seg_map = cpi -> segmentation_map ; signed char feature_data [ MB_LVL_MAX ] [ MAX_MB_SEGMENTS ] ; int i ; int block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; int mbs_in_frame = cpi -> common . mb_rows * cpi -> common . mb_cols ; cpi -> cyclic_refresh_q = Q / 2 ; <S2SV_StartBug> vpx_memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . frame_type != KEY_FRAME ) <S2SV_EndBug> { i = cpi -> cyclic_refresh_mode_index ; assert ( i < mbs_in_frame ) ; do { if ( cpi -> cyclic_refresh_map [ i ] == 0 ) { seg_map [ i ] = 1 ; block_count -- ; } else if ( cpi -> cyclic_refresh_map [ i ] < 0 ) cpi -> cyclic_refresh_map [ i ] ++ ; i ++ ; if ( i == mbs_in_frame ) i = 0 ; } while ( block_count && i != cpi -> cyclic_refresh_mode_index ) ; <S2SV_StartBug> cpi -> cyclic_refresh_mode_index = i ; <S2SV_EndBug> } cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; enable_segmentation ( cpi ) ; feature_data [ MB_LVL_ALT_Q ] [ 0 ] = 0 ; feature_data [ MB_LVL_ALT_Q ] [ 1 ] = ( cpi -> cyclic_refresh_q - Q ) ; feature_data [ MB_LVL_ALT_Q ] [ 2 ] = 0 ; feature_data [ MB_LVL_ALT_Q ] [ 3 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 0 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 1 ] = lf_adjustment ; feature_data [ MB_LVL_ALT_LF ] [ 2 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 3 ] = 0 ; set_segment_data ( cpi , & feature_data [ 0 ] [ 0 ] , SEGMENT_DELTADATA ) ; }
","<S2SV_ModStart> / 2 ; if ( cpi -> oxcf . screen_content_mode ) { int qp_thresh = ( cpi -> oxcf . screen_content_mode == 2 ) ? 80 : 100 ; if ( Q >= qp_thresh ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } else if ( cpi -> frames_since_key > 250 && Q < 20 && cpi -> mb . skip_true_count > ( int ) ( 0.95 * mbs_in_frame ) ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = 0 ; } else { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; } memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> frame_type != KEY_FRAME && block_count > 0 <S2SV_ModStart> = i ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { if ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive && Q < ( int ) cpi -> denoiser . denoise_pars . qp_thresh && ( cpi -> frames_since_key > 2 * cpi -> denoiser . denoise_pars . consec_zerolast ) ) { cpi -> cyclic_refresh_q = Q ; lf_adjustment = - 40 ; for ( i = 0 ; i < mbs_in_frame ; ++ i ) { seg_map [ i ] = ( cpi -> consec_zero_last [ i ] > cpi -> denoiser . denoise_pars . consec_zerolast ) ? 1 : 0 ; } } } # endif
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . frame_type != KEY_FRAME ) <S2SV_EndBug> <S2SV_StartBug> cpi -> cyclic_refresh_mode_index = i ; <S2SV_EndBug>"
7606,CWE-190,"static jas_image_cmpt_t * jas_image_cmpt_create ( int_fast32_t tlx , int_fast32_t tly , int_fast32_t hstep , int_fast32_t vstep , int_fast32_t width , int_fast32_t height , uint_fast16_t depth , bool sgnd , uint_fast32_t inmem ) { jas_image_cmpt_t * cmpt ; size_t size ; <S2SV_StartBug> cmpt = 0 ; <S2SV_EndBug> if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) { goto error ; } if ( ! jas_safe_intfast32_add ( tlx , width , 0 ) || <S2SV_StartBug> ! jas_safe_intfast32_add ( tly , height , 0 ) ) { <S2SV_EndBug> goto error ; } if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) { goto error ; } cmpt -> type_ = JAS_IMAGE_CT_UNKNOWN ; cmpt -> tlx_ = tlx ; cmpt -> tly_ = tly ; cmpt -> hstep_ = hstep ; cmpt -> vstep_ = vstep ; cmpt -> width_ = width ; cmpt -> height_ = height ; cmpt -> prec_ = depth ; cmpt -> sgnd_ = sgnd ; cmpt -> stream_ = 0 ; cmpt -> cps_ = ( depth + 7 ) / 8 ; <S2SV_StartBug> if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) || <S2SV_EndBug> ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) { goto error ; } cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 ( 0 , size ) : jas_stream_tmpfile ( ) ; if ( ! cmpt -> stream_ ) { goto error ; } if ( size > 0 ) { if ( size - 1 > LONG_MAX ) { goto error ; } if ( jas_stream_seek ( cmpt -> stream_ , size - 1 , SEEK_SET ) < 0 || jas_stream_putc ( cmpt -> stream_ , 0 ) == EOF || jas_stream_seek ( cmpt -> stream_ , 0 , SEEK_SET ) < 0 ) { goto error ; } } return cmpt ; error : if ( cmpt ) { jas_image_cmpt_destroy ( cmpt ) ; } return 0 ; }
","<S2SV_ModStart> size_t size ; JAS_DBGLOG ( 100 , ( ""jas_image_cmpt_create(%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d)\\n"" , JAS_CAST ( long , tlx ) , JAS_CAST ( long , tly ) , JAS_CAST ( long , hstep ) , JAS_CAST ( long , vstep ) , JAS_CAST ( long , width ) , JAS_CAST ( long , height ) , JAS_CAST ( int , depth ) , sgnd , inmem ) ) ; <S2SV_ModStart> tly , height , 0 ) ) { goto error ; } if ( ! jas_safe_intfast32_mul3 ( width , height , depth <S2SV_ModStart> if ( ! jas_safe_size_mul3 <S2SV_ModEnd> ( cmpt -> <S2SV_ModStart> cmpt -> height_ <S2SV_ModEnd> , cmpt ->
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,"<S2SV_StartBug> cmpt = 0 ; <S2SV_EndBug> <S2SV_StartBug> ! jas_safe_intfast32_add ( tly , height , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) || <S2SV_EndBug>"
1266,CWE-264,"void bnep_net_setup ( struct net_device * dev ) { memset ( dev -> broadcast , 0xff , ETH_ALEN ) ; dev -> addr_len = ETH_ALEN ; ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & bnep_netdev_ops ; <S2SV_EndBug> dev -> watchdog_timeo = HZ * 2 ; }
","<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,<S2SV_StartBug> dev -> netdev_ops = & bnep_netdev_ops ; <S2SV_EndBug>
2741,CWE-399,"int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; <S2SV_StartBug> if ( vm_flags & VM_NORESERVE ) <S2SV_EndBug> return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 ) return chg ; <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> return - ENOSPC ; ret = hugetlb_acct_memory ( h , chg ) ; if ( ret < 0 ) { <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> return ret ; } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; }
","<S2SV_ModStart> inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> ; if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> 0 ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg )
",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z,"<S2SV_StartBug> if ( vm_flags & VM_NORESERVE ) <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug>"
1182,CWE-125,"void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; if ( skb_is_err_queue ( skb ) && skb -> len && <S2SV_StartBug> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; } }
","<S2SV_ModStart> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> ) put_cmsg (
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,<S2SV_StartBug> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug>
461,CWE-125,"static int dccp_print_option ( netdissect_options * ndo , const u_char * option , u_int hlen ) { uint8_t optlen , i ; ND_TCHECK ( * option ) ; if ( * option >= 32 ) { ND_TCHECK ( * ( option + 1 ) ) ; optlen = * ( option + 1 ) ; if ( optlen < 2 ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , ""CCID<S2SV_blank>option<S2SV_blank>%u<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short"" , * option ) ) ; else ND_PRINT ( ( ndo , ""%s<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short"" , tok2str ( dccp_option_values , ""Option<S2SV_blank>%u"" , * option ) ) ) ; return 0 ; } } else optlen = 1 ; if ( hlen < optlen ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , ""CCID<S2SV_blank>option<S2SV_blank>%u<S2SV_blank>optlen<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>header<S2SV_blank>length"" , * option ) ) ; else ND_PRINT ( ( ndo , ""%s<S2SV_blank>optlen<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>header<S2SV_blank>length"" , tok2str ( dccp_option_values , ""Option<S2SV_blank>%u"" , * option ) ) ) ; return 0 ; } ND_TCHECK2 ( * option , optlen ) ; if ( * option >= 128 ) { ND_PRINT ( ( ndo , ""CCID<S2SV_blank>option<S2SV_blank>%d"" , * option ) ) ; switch ( optlen ) { case 4 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_16BITS ( option + 2 ) ) ) ; break ; case 6 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; default : break ; } } else { ND_PRINT ( ( ndo , ""%s"" , tok2str ( dccp_option_values , ""Option<S2SV_blank>%u"" , * option ) ) ) ; switch ( * option ) { case 32 : case 33 : case 34 : case 35 : if ( optlen < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short"" ) ) ; return optlen ; } if ( * ( option + 2 ) < 10 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , dccp_feature_nums [ * ( option + 2 ) ] ) ) ; for ( i = 0 ; i < optlen - 3 ; i ++ ) ND_PRINT ( ( ndo , ""<S2SV_blank>%d"" , * ( option + 3 + i ) ) ) ; } break ; case 36 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 37 : for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""<S2SV_blank>%d"" , * ( option + 2 + i ) ) ) ; break ; case 38 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 39 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 40 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 41 : <S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; else <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ; <S2SV_EndBug> break ; case 42 : <S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; <S2SV_EndBug> else <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ; <S2SV_EndBug> break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; else if ( optlen == 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_16BITS ( option + 2 ) ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>or<S2SV_blank>6"" ) ) ; break ; case 44 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; } } return optlen ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return 0 ; }
","<S2SV_ModStart> ( optlen == 6 <S2SV_ModEnd> ) ND_PRINT ( <S2SV_ModStart> ( ndo , ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6]"" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> case 42 : switch ( optlen ) { case 6 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; case 8 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)"" , EXTRACT_16BITS ( option + 6 ) ) ) ; break ; case 10 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)"" , EXTRACT_32BITS ( option + 6 ) ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6<S2SV_blank>or<S2SV_blank>8<S2SV_blank>or<S2SV_blank>10]"" ) ) ; break ; } break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; else <S2SV_ModStart> , ""<S2SV_blank>%u"" , EXTRACT_16BITS <S2SV_ModEnd> ( option + <S2SV_ModStart> ( ndo , ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>or<S2SV_blank>6]"" <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/211124b972e74f0da66bc8b16f181f78793e2f66,CVE-2018-16229,https://github.com/the-tcpdump-group/tcpdump/commit/211124b972e74f0da66bc8b16f181f78793e2f66,2019-10-03T16:15Z,"<S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ; <S2SV_EndBug>"
3836,CWE-264,"static ssize_t hfi1_file_write ( struct file * fp , const char __user * data , size_t count , loff_t * offset ) { const struct hfi1_cmd __user * ucmd ; struct hfi1_filedata * fd = fp -> private_data ; struct hfi1_ctxtdata * uctxt = fd -> uctxt ; struct hfi1_cmd cmd ; struct hfi1_user_info uinfo ; struct hfi1_tid_info tinfo ; unsigned long addr ; ssize_t consumed = 0 , copy = 0 , ret = 0 ; void * dest = NULL ; __u64 user_val = 0 ; int uctxt_required = 1 ; int must_be_root = 0 ; <S2SV_StartBug> if ( count < sizeof ( cmd ) ) { <S2SV_EndBug> ret = - EINVAL ; goto bail ; } ucmd = ( const struct hfi1_cmd __user * ) data ; if ( copy_from_user ( & cmd , ucmd , sizeof ( cmd ) ) ) { ret = - EFAULT ; goto bail ; } consumed = sizeof ( cmd ) ; switch ( cmd . type ) { case HFI1_CMD_ASSIGN_CTXT : uctxt_required = 0 ; copy = sizeof ( uinfo ) ; dest = & uinfo ; break ; case HFI1_CMD_SDMA_STATUS_UPD : case HFI1_CMD_CREDIT_UPD : copy = 0 ; break ; case HFI1_CMD_TID_UPDATE : case HFI1_CMD_TID_FREE : case HFI1_CMD_TID_INVAL_READ : copy = sizeof ( tinfo ) ; dest = & tinfo ; break ; case HFI1_CMD_USER_INFO : case HFI1_CMD_RECV_CTRL : case HFI1_CMD_POLL_TYPE : case HFI1_CMD_ACK_EVENT : case HFI1_CMD_CTXT_INFO : case HFI1_CMD_SET_PKEY : case HFI1_CMD_CTXT_RESET : copy = 0 ; user_val = cmd . addr ; break ; case HFI1_CMD_EP_INFO : case HFI1_CMD_EP_ERASE_CHIP : case HFI1_CMD_EP_ERASE_RANGE : case HFI1_CMD_EP_READ_RANGE : case HFI1_CMD_EP_WRITE_RANGE : uctxt_required = 0 ; must_be_root = 1 ; copy = 0 ; break ; default : ret = - EINVAL ; goto bail ; } if ( copy ) { if ( copy_from_user ( dest , ( void __user * ) cmd . addr , copy ) ) { ret = - EFAULT ; goto bail ; } consumed += copy ; } if ( uctxt_required && ! uctxt ) { ret = - EINVAL ; goto bail ; } if ( must_be_root && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto bail ; } switch ( cmd . type ) { case HFI1_CMD_ASSIGN_CTXT : ret = assign_ctxt ( fp , & uinfo ) ; if ( ret < 0 ) goto bail ; ret = setup_ctxt ( fp ) ; if ( ret ) goto bail ; ret = user_init ( fp ) ; break ; case HFI1_CMD_CTXT_INFO : ret = get_ctxt_info ( fp , ( void __user * ) ( unsigned long ) user_val , cmd . len ) ; break ; case HFI1_CMD_USER_INFO : ret = get_base_info ( fp , ( void __user * ) ( unsigned long ) user_val , cmd . len ) ; break ; case HFI1_CMD_SDMA_STATUS_UPD : break ; case HFI1_CMD_CREDIT_UPD : if ( uctxt && uctxt -> sc ) sc_return_credits ( uctxt -> sc ) ; break ; case HFI1_CMD_TID_UPDATE : ret = hfi1_user_exp_rcv_setup ( fp , & tinfo ) ; if ( ! ret ) { addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) + sizeof ( tinfo . length ) ) ) ret = - EFAULT ; } break ; case HFI1_CMD_TID_INVAL_READ : ret = hfi1_user_exp_rcv_invalid ( fp , & tinfo ) ; if ( ret ) break ; addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) ) ) ret = - EFAULT ; break ; case HFI1_CMD_TID_FREE : ret = hfi1_user_exp_rcv_clear ( fp , & tinfo ) ; if ( ret ) break ; addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) ) ) ret = - EFAULT ; break ; case HFI1_CMD_RECV_CTRL : ret = manage_rcvq ( uctxt , fd -> subctxt , ( int ) user_val ) ; break ; case HFI1_CMD_POLL_TYPE : uctxt -> poll_type = ( typeof ( uctxt -> poll_type ) ) user_val ; break ; case HFI1_CMD_ACK_EVENT : ret = user_event_ack ( uctxt , fd -> subctxt , user_val ) ; break ; case HFI1_CMD_SET_PKEY : if ( HFI1_CAP_IS_USET ( PKEY_CHECK ) ) ret = set_ctxt_pkey ( uctxt , fd -> subctxt , user_val ) ; else ret = - EPERM ; break ; case HFI1_CMD_CTXT_RESET : { struct send_context * sc ; struct hfi1_devdata * dd ; if ( ! uctxt || ! uctxt -> dd || ! uctxt -> sc ) { ret = - EINVAL ; break ; } dd = uctxt -> dd ; sc = uctxt -> sc ; wait_event_interruptible_timeout ( sc -> halt_wait , ( sc -> flags & SCF_HALTED ) , msecs_to_jiffies ( SEND_CTXT_HALT_TIMEOUT ) ) ; if ( ! ( sc -> flags & SCF_HALTED ) ) { ret = - ENOLCK ; break ; } if ( sc -> flags & SCF_FROZEN ) { wait_event_interruptible_timeout ( dd -> event_queue , ! ( ACCESS_ONCE ( dd -> flags ) & HFI1_FROZEN ) , msecs_to_jiffies ( SEND_CTXT_HALT_TIMEOUT ) ) ; if ( dd -> flags & HFI1_FROZEN ) { ret = - ENOLCK ; break ; } if ( dd -> flags & HFI1_FORCED_FREEZE ) { ret = - ENODEV ; break ; } sc_disable ( sc ) ; ret = sc_enable ( sc ) ; hfi1_rcvctrl ( dd , HFI1_RCVCTRL_CTXT_ENB , uctxt -> ctxt ) ; } else { ret = sc_restart ( sc ) ; } if ( ! ret ) sc_return_credits ( sc ) ; break ; } case HFI1_CMD_EP_INFO : case HFI1_CMD_EP_ERASE_CHIP : case HFI1_CMD_EP_ERASE_RANGE : case HFI1_CMD_EP_READ_RANGE : case HFI1_CMD_EP_WRITE_RANGE : ret = handle_eprom_command ( fp , & cmd ) ; break ; } if ( ret >= 0 ) ret = consumed ; bail : return ret ; }
","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
",torvalds@linux/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,CVE-2016-4565,https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,2016-05-23T10:59Z,<S2SV_StartBug> if ( count < sizeof ( cmd ) ) { <S2SV_EndBug>
7624,CWE-190,"int jas_seq2d_output ( jas_matrix_t * matrix , FILE * out ) { # define MAXLINELEN 80 <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t x ; char buf [ MAXLINELEN + 1 ] ; char sbuf [ MAXLINELEN + 1 ] ; int n ; fprintf ( out , ""%"" PRIiFAST32 ""<S2SV_blank>%"" PRIiFAST32 ""\\n"" , jas_seq2d_xstart ( matrix ) , jas_seq2d_ystart ( matrix ) ) ; fprintf ( out , ""%"" PRIiFAST32 ""<S2SV_blank>%"" PRIiFAST32 ""\\n"" , jas_matrix_numcols ( matrix ) , jas_matrix_numrows ( matrix ) ) ; buf [ 0 ] = '\\0' ; for ( i = 0 ; i < jas_matrix_numrows ( matrix ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( matrix ) ; ++ j ) { x = jas_matrix_get ( matrix , i , j ) ; sprintf ( sbuf , ""%s%4ld"" , ( strlen ( buf ) > 0 ) ? ""<S2SV_blank>"" : """" , JAS_CAST ( long , x ) ) ; n = JAS_CAST ( int , strlen ( buf ) ) ; if ( n + JAS_CAST ( int , strlen ( sbuf ) ) > MAXLINELEN ) { fputs ( buf , out ) ; fputs ( ""\\n"" , out ) ; buf [ 0 ] = '\\0' ; } strcat ( buf , sbuf ) ; if ( j == jas_matrix_numcols ( matrix ) - 1 ) { fputs ( buf , out ) ; fputs ( ""\\n"" , out ) ; buf [ 0 ] = '\\0' ; } } } fputs ( buf , out ) ; return 0 ; }
","<S2SV_ModStart> define MAXLINELEN 80 jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> int i ; <S2SV_EndBug>
2069,CWE-119,"WORD32 ih264d_decode_gaps_in_frame_num ( dec_struct_t * ps_dec , UWORD16 u2_frame_num ) { UWORD32 u4_next_frm_num , u4_start_frm_num ; UWORD32 u4_max_frm_num ; pocstruct_t s_tmp_poc ; WORD32 i4_poc ; dec_slice_params_t * ps_cur_slice ; dec_pic_params_t * ps_pic_params ; WORD8 i1_gap_idx ; WORD32 * i4_gaps_start_frm_num ; dpb_manager_t * ps_dpb_mgr ; WORD32 i4_frame_gaps ; WORD8 * pi1_gaps_per_seq ; WORD32 ret ; ps_cur_slice = ps_dec -> ps_cur_slice ; if ( ps_cur_slice -> u1_field_pic_flag ) { if ( ps_dec -> u2_prev_ref_frame_num == u2_frame_num ) return 0 ; } u4_next_frm_num = ps_dec -> u2_prev_ref_frame_num + 1 ; u4_max_frm_num = ps_dec -> ps_cur_sps -> u2_u4_max_pic_num_minus1 + 1 ; if ( u4_next_frm_num >= u4_max_frm_num ) { u4_next_frm_num -= u4_max_frm_num ; } if ( u4_next_frm_num == u2_frame_num ) { return ( 0 ) ; } if ( ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) && ( u4_next_frm_num >= u2_frame_num ) ) { return ( 0 ) ; } u4_start_frm_num = u4_next_frm_num ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_pic_params = ps_dec -> ps_cur_pps ; <S2SV_StartBug> ps_cur_slice -> u1_field_pic_flag = 0 ; <S2SV_EndBug> i4_frame_gaps = 0 ; ps_dpb_mgr = ps_dec -> ps_dpb_mgr ; i4_gaps_start_frm_num = ps_dpb_mgr -> ai4_gaps_start_frm_num ; for ( i1_gap_idx = 0 ; i1_gap_idx < MAX_FRAMES ; i1_gap_idx ++ ) { if ( INVALID_FRAME_NUM == i4_gaps_start_frm_num [ i1_gap_idx ] ) break ; } if ( MAX_FRAMES == i1_gap_idx ) { UWORD32 i4_error_code ; i4_error_code = ERROR_DBP_MANAGER_T ; return i4_error_code ; } i4_poc = 0 ; i4_gaps_start_frm_num [ i1_gap_idx ] = u4_start_frm_num ; ps_dpb_mgr -> ai4_gaps_end_frm_num [ i1_gap_idx ] = u2_frame_num - 1 ; pi1_gaps_per_seq = ps_dpb_mgr -> ai1_gaps_per_seq ; pi1_gaps_per_seq [ i1_gap_idx ] = 0 ; while ( u4_next_frm_num != u2_frame_num ) { ih264d_delete_nonref_nondisplay_pics ( ps_dpb_mgr ) ; if ( ps_pic_params -> ps_sps -> u1_pic_order_cnt_type ) { ret = ih264d_decode_pic_order_cnt ( 0 , u4_next_frm_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pic_params , 1 , 0 , 0 , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } ps_cur_slice -> u1_mmco_equalto5 = 0 ; ps_cur_slice -> u2_frame_num = u4_next_frm_num ; } if ( ps_dpb_mgr -> i1_poc_buf_id_entries >= ps_dec -> u1_max_dec_frame_buffering ) { ret = ih264d_assign_display_seq ( ps_dec ) ; if ( ret != OK ) return ret ; } ret = ih264d_insert_pic_in_display_list ( ps_dec -> ps_dpb_mgr , ( WORD8 ) DO_NOT_DISP , ( WORD32 ) ( ps_dec -> i4_prev_max_display_seq + i4_poc ) , u4_next_frm_num ) ; if ( ret != OK ) return ret ; pi1_gaps_per_seq [ i1_gap_idx ] ++ ; ret = ih264d_do_mmco_for_gaps ( ps_dpb_mgr , ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ; if ( ret != OK ) return ret ; ih264d_delete_nonref_nondisplay_pics ( ps_dpb_mgr ) ; u4_next_frm_num ++ ; if ( u4_next_frm_num >= u4_max_frm_num ) { u4_next_frm_num -= u4_max_frm_num ; } i4_frame_gaps ++ ; } return OK ; }
","<S2SV_ModStart> -> ps_cur_pps ; <S2SV_ModEnd> i4_frame_gaps = 0
",external@libavc/5c3fd5d93a268abb20ff22f26009535b40db3c7d,CVE-2017-0591,https://android.googlesource.com/platform/external/libavc/+/5c3fd5d93a268abb20ff22f26009535b40db3c7d,2017-05-12T15:29Z,<S2SV_StartBug> ps_cur_slice -> u1_field_pic_flag = 0 ; <S2SV_EndBug>
7232,CWE-19,"static int ext2_xattr_set2 ( struct inode * inode , struct buffer_head * old_bh , struct ext2_xattr_header * header ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; int error ; <S2SV_StartBug> if ( header ) { <S2SV_EndBug> new_bh = ext2_xattr_cache_find ( inode , header ) ; if ( new_bh ) { if ( new_bh == old_bh ) { ea_bdebug ( new_bh , ""keeping<S2SV_blank>this<S2SV_blank>block"" ) ; } else { ea_bdebug ( new_bh , ""reusing<S2SV_blank>block"" ) ; error = dquot_alloc_block ( inode , 1 ) ; if ( error ) { unlock_buffer ( new_bh ) ; goto cleanup ; } le32_add_cpu ( & HDR ( new_bh ) -> h_refcount , 1 ) ; ea_bdebug ( new_bh , ""refcount<S2SV_blank>now=%d"" , le32_to_cpu ( HDR ( new_bh ) -> h_refcount ) ) ; } unlock_buffer ( new_bh ) ; } else if ( old_bh && header == HDR ( old_bh ) ) { new_bh = old_bh ; get_bh ( new_bh ) ; <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> } else { ext2_fsblk_t goal = ext2_group_first_block_no ( sb , EXT2_I ( inode ) -> i_block_group ) ; int block = ext2_new_block ( inode , goal , & error ) ; if ( error ) goto cleanup ; ea_idebug ( inode , ""creating<S2SV_blank>block<S2SV_blank>%d"" , block ) ; new_bh = sb_getblk ( sb , block ) ; if ( unlikely ( ! new_bh ) ) { ext2_free_blocks ( inode , block , 1 ) ; mark_inode_dirty ( inode ) ; error = - ENOMEM ; goto cleanup ; } lock_buffer ( new_bh ) ; memcpy ( new_bh -> b_data , header , new_bh -> b_size ) ; set_buffer_uptodate ( new_bh ) ; unlock_buffer ( new_bh ) ; <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> ext2_xattr_update_super_block ( sb ) ; } mark_buffer_dirty ( new_bh ) ; if ( IS_SYNC ( inode ) ) { sync_dirty_buffer ( new_bh ) ; error = - EIO ; if ( buffer_req ( new_bh ) && ! buffer_uptodate ( new_bh ) ) goto cleanup ; } } EXT2_I ( inode ) -> i_file_acl = new_bh ? new_bh -> b_blocknr : 0 ; inode -> i_ctime = CURRENT_TIME_SEC ; if ( IS_SYNC ( inode ) ) { error = sync_inode_metadata ( inode , 1 ) ; if ( error && error != - ENOSPC ) { if ( new_bh && new_bh != old_bh ) { dquot_free_block_nodirty ( inode , 1 ) ; mark_inode_dirty ( inode ) ; } goto cleanup ; } } else mark_inode_dirty ( inode ) ; error = 0 ; if ( old_bh && old_bh != new_bh ) { <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> ce = mb_cache_entry_get ( ext2_xattr_cache , old_bh -> b_bdev , old_bh -> b_blocknr ) ; lock_buffer ( old_bh ) ; if ( HDR ( old_bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; ea_bdebug ( old_bh , ""freeing"" ) ; ext2_free_blocks ( inode , old_bh -> b_blocknr , 1 ) ; mark_inode_dirty ( inode ) ; get_bh ( old_bh ) ; bforget ( old_bh ) ; } else { le32_add_cpu ( & HDR ( old_bh ) -> h_refcount , - 1 ) ; <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_release ( ce ) ; dquot_free_block_nodirty ( inode , 1 ) ; mark_inode_dirty ( inode ) ; mark_buffer_dirty ( old_bh ) ; ea_bdebug ( old_bh , ""refcount<S2SV_blank>now=%d"" , le32_to_cpu ( HDR ( old_bh ) -> h_refcount ) ) ; } unlock_buffer ( old_bh ) ; } cleanup : brelse ( new_bh ) ; return error ; }
","<S2SV_ModStart> int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( sb ) -> s_mb_cache ; <S2SV_ModStart> ; ext2_xattr_cache_insert ( ext2_mb_cache , <S2SV_ModStart> ; ext2_xattr_cache_insert ( ext2_mb_cache , <S2SV_ModStart> new_bh ) { <S2SV_ModEnd> lock_buffer ( old_bh <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( HDR ( old_bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext2_mb_cache , hash , old_bh -> b_blocknr <S2SV_ModEnd> ) ; ea_bdebug <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> dquot_free_block_nodirty ( inode
",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z,<S2SV_StartBug> if ( header ) { <S2SV_EndBug> <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug>
554,CWE-189,"static int sysMapFD ( int fd , MemMapping * pMap ) { off_t start ; size_t length ; void * memPtr ; assert ( pMap != NULL ) ; if ( getFileStartAndLength ( fd , & start , & length ) < 0 ) return - 1 ; memPtr = mmap ( NULL , length , PROT_READ , MAP_PRIVATE , fd , start ) ; if ( memPtr == MAP_FAILED ) { LOGW ( ""mmap(%d,<S2SV_blank>R,<S2SV_blank>PRIVATE,<S2SV_blank>%d,<S2SV_blank>%d)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( int ) length , fd , ( int ) start , strerror ( errno ) ) ; return - 1 ; } pMap -> addr = memPtr ; pMap -> length = length ; pMap -> range_count = 1 ; <S2SV_StartBug> pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ; <S2SV_EndBug> pMap -> ranges [ 0 ] . addr = memPtr ; pMap -> ranges [ 0 ] . length = length ; return 0 ; }
","<S2SV_ModStart> ) ) ; if ( pMap -> ranges == NULL ) { LOGE ( ""malloc<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; munmap ( memPtr , length ) ; return - 1 ; }
",bootable@recovery/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,CVE-2016-0849,https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,2016-04-18T00:59Z,<S2SV_StartBug> pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ; <S2SV_EndBug>
2939,CWE-77,"static int do_hidp_sock_ioctl ( struct socket * sock , unsigned int cmd , void __user * argp ) { struct hidp_connadd_req ca ; struct hidp_conndel_req cd ; struct hidp_connlist_req cl ; struct hidp_conninfo ci ; struct socket * csock ; struct socket * isock ; int err ; BT_DBG ( ""cmd<S2SV_blank>%x<S2SV_blank>arg<S2SV_blank>%p"" , cmd , argp ) ; switch ( cmd ) { case HIDPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; csock = sockfd_lookup ( ca . ctrl_sock , & err ) ; if ( ! csock ) return err ; isock = sockfd_lookup ( ca . intr_sock , & err ) ; if ( ! isock ) { sockfd_put ( csock ) ; return err ; <S2SV_StartBug> } <S2SV_EndBug> err = hidp_connection_add ( & ca , csock , isock ) ; if ( ! err && copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; sockfd_put ( csock ) ; sockfd_put ( isock ) ; return err ; case HIDPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return hidp_connection_del ( & cd ) ; case HIDPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <= 0 ) return - EINVAL ; err = hidp_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - EFAULT ; return err ; case HIDPGETCONNINFO : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - EFAULT ; err = hidp_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - EFAULT ; return err ; } return - EINVAL ; }
","<S2SV_ModStart> err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;
",torvalds@linux/a1616a5ac99ede5d605047a9012481ce7ff18b16,CVE-2019-11884,https://github.com/torvalds/linux/commit/a1616a5ac99ede5d605047a9012481ce7ff18b16,2019-05-10T22:29Z,<S2SV_StartBug> } <S2SV_EndBug>
3620,CWE-125,"static void icmp6_nodeinfo_print ( netdissect_options * ndo , u_int icmp6len , const u_char * bp , const u_char * ep ) { const struct icmp6_nodeinfo * ni6 ; const struct icmp6_hdr * dp ; const u_char * cp ; size_t siz , i ; int needcomma ; if ( ep < bp ) return ; dp = ( const struct icmp6_hdr * ) bp ; ni6 = ( const struct icmp6_nodeinfo * ) bp ; siz = ep - bp ; switch ( ni6 -> ni_type ) { case ICMP6_NI_QUERY : if ( siz == sizeof ( * dp ) + 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>who-are-you<S2SV_blank>request"" ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>query"" ) ) ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : ND_PRINT ( ( ndo , ""noop"" ) ) ; break ; case NI_QTYPE_SUPTYPES : ND_PRINT ( ( ndo , ""supported<S2SV_blank>qtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : ND_PRINT ( ( ndo , ""DNS<S2SV_blank>name"" ) ) ; break ; case NI_QTYPE_NODEADDR : ND_PRINT ( ( ndo , ""node<S2SV_blank>addresses"" ) ) ; i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>[%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" ) ) ; break ; default : ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } if ( ni6 -> ni_qtype == NI_QTYPE_NOOP || ni6 -> ni_qtype == NI_QTYPE_SUPTYPES ) { if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>len"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } if ( siz == sizeof ( * ni6 ) ) { ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( ni6 -> ni_code ) { case ICMP6_NI_SUBJ_IPV6 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , "",<S2SV_blank>subject=%s"" , ip6addr_string ( ndo , ni6 + 1 ) ) ) ; break ; case ICMP6_NI_SUBJ_FQDN : ND_PRINT ( ( ndo , "",<S2SV_blank>subject=DNS<S2SV_blank>name"" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; break ; case ICMP6_NI_SUBJ_IPV4 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , "",<S2SV_blank>subject=%s"" , ipaddr_string ( ndo , ni6 + 1 ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>unknown<S2SV_blank>subject"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case ICMP6_NI_REPLY : if ( icmp6len > siz ) { ND_PRINT ( ( ndo , ""[|icmp6:<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply]"" ) ) ; break ; } needcomma = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; switch ( ni6 -> ni_code ) { case ICMP6_NI_SUCCESS : if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""success"" ) ) ; needcomma ++ ; } break ; case ICMP6_NI_REFUSED : ND_PRINT ( ( ndo , ""refused"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; case ICMP6_NI_UNKNOWN : ND_PRINT ( ( ndo , ""unknown"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; } if ( ni6 -> ni_code != ICMP6_NI_SUCCESS ) { ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""noop"" ) ) ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; case NI_QTYPE_SUPTYPES : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""supported<S2SV_blank>qtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""DNS<S2SV_blank>name"" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) + 4 ; ND_TCHECK ( cp [ 0 ] ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; if ( ( EXTRACT_16BITS ( & ni6 -> ni_flags ) & 0x01 ) != 0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[TTL=%u]"" , EXTRACT_32BITS ( ni6 + 1 ) ) ) ; break ; case NI_QTYPE_NODEADDR : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""node<S2SV_blank>addresses"" ) ) ; i = sizeof ( * ni6 ) ; while ( i < siz ) { if ( i + sizeof ( struct in6_addr ) + sizeof ( int32_t ) > siz ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , bp + i ) ) ) ; i += sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , ""(%d)"" , ( int32_t ) EXTRACT_32BITS ( bp + i ) ) ) ; i += sizeof ( int32_t ) ; } i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>[%s%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" , ( i & NI_NODEADDR_FLAG_TRUNCATE ) ? ""T"" : """" ) ) ; break ; default : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ndo , ""%s"" , icmp6_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug>"
765,CWE-20,"long keyctl_chown_key ( key_serial_t id , uid_t user , gid_t group ) { struct key_user * newowner , * zapowner = NULL ; struct key * key ; key_ref_t key_ref ; long ret ; kuid_t uid ; kgid_t gid ; uid = make_kuid ( current_user_ns ( ) , user ) ; gid = make_kgid ( current_user_ns ( ) , group ) ; ret = - EINVAL ; if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) goto error ; if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) goto error ; ret = 0 ; if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) goto error ; key_ref = lookup_user_key ( id , KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL , KEY_NEED_SETATTR ) ; if ( IS_ERR ( key_ref ) ) { ret = PTR_ERR ( key_ref ) ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = - EACCES ; down_write ( & key -> sem ) ; if ( ! capable ( CAP_SYS_ADMIN ) ) { if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) goto error_put ; if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) goto error_put ; } if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) { ret = - ENOMEM ; newowner = key_user_lookup ( uid ) ; if ( ! newowner ) goto error_put ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ; unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ; spin_lock ( & newowner -> lock ) ; if ( newowner -> qnkeys + 1 >= maxkeys || newowner -> qnbytes + key -> quotalen >= maxbytes || newowner -> qnbytes + key -> quotalen < newowner -> qnbytes ) goto quota_overrun ; newowner -> qnkeys ++ ; newowner -> qnbytes += key -> quotalen ; spin_unlock ( & newowner -> lock ) ; spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; atomic_inc ( & newowner -> nkeys ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> atomic_dec ( & key -> user -> nikeys ) ; atomic_inc ( & newowner -> nikeys ) ; } zapowner = key -> user ; key -> user = newowner ; key -> uid = uid ; } if ( group != ( gid_t ) - 1 ) key -> gid = gid ; ret = 0 ; error_put : up_write ( & key -> sem ) ; key_put ( key ) ; if ( zapowner ) key_user_put ( zapowner ) ; error : return ret ; quota_overrun : spin_unlock ( & newowner -> lock ) ; zapowner = newowner ; ret = - EDQUOT ; goto error_put ; }
","<S2SV_ModStart> ; if ( key -> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_dec
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug>"
176,CWE-200,"WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; ps_dec -> process_called = 1 ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; ps_dec -> u4_stop_threads = 0 ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; <S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 2 ; <S2SV_EndBug> ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; pu1_bitstrm_buf = ps_dec -> ps_mem_tab [ MEM_REC_BITSBUF ] . pv_base ; u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , ( WORD32 ) ( ps_dec -> ps_mem_tab [ MEM_REC_BITSBUF ] . u4_mem_size - 8 ) ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; if ( buflen >= MAX_NAL_UNIT_SIZE ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; H264_DEC_DEBUG_PRINT ( ""\\nNal<S2SV_blank>Size<S2SV_blank>exceeded<S2SV_blank>%d,<S2SV_blank>Processing<S2SV_blank>Stopped..\\n"" , MAX_NAL_UNIT_SIZE ) ; ps_dec -> i4_error_code = 1 << IVD_CORRUPTEDDATA ; ps_dec_op -> e_pic_type = - 1 ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_pic_buf_got == 0 ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return IV_FAIL ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; header_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; WORD32 ht_in_mbs ; ht_in_mbs = ps_dec -> u2_pic_ht >> ( 4 + ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ; num_mb_skipped = ( ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) || ( ret1 == ERROR_INV_SPS_PPS_T ) ) { ret = ret1 ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) && ( ps_dec -> u4_pic_buf_got == 1 ) ) { ret = ih264d_deblock_display ( ps_dec ) ; } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( 0 == ps_dec -> u4_num_reorder_frames_at_init ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } if ( ps_dec -> u4_pic_buf_got == 1 ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } else { ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }
","<S2SV_ModStart> -> u4_first_slice_in_pic = 1 <S2SV_ModEnd> ; ps_dec ->
",external@libavc/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,CVE-2017-0555,https://android.googlesource.com/platform/external/libavc/+/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,2017-04-07T22:59Z,<S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 2 ; <S2SV_EndBug>
1463,CWE-119,"void vp8_loopfilter_frame ( VP8_COMP * cpi , VP8_COMMON * cm ) { <S2SV_StartBug> const FRAME_TYPE frame_type = cm -> frame_type ; <S2SV_EndBug> if ( cm -> no_lpf ) { cm -> filter_level = 0 ; } else { struct vpx_usec_timer timer ; vp8_clear_system_state ( ) ; vpx_usec_timer_start ( & timer ) ; <S2SV_StartBug> if ( cpi -> sf . auto_filter == 0 ) <S2SV_EndBug> vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; <S2SV_EndBug> if ( cm -> filter_level > 0 ) { vp8cx_set_alt_lf_level ( cpi , cm -> filter_level ) ; } vpx_usec_timer_mark ( & timer ) ; cpi -> time_pick_lpf += vpx_usec_timer_elapsed ( & timer ) ; } # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) sem_post ( & cpi -> h_event_end_lpf ) ; # endif <S2SV_StartBug> if ( cm -> filter_level > 0 ) <S2SV_EndBug> { vp8_loop_filter_frame ( cm , & cpi -> mb . e_mbd , frame_type ) ; } vp8_yv12_extend_frame_borders ( cm -> frame_to_show ) ; }
","<S2SV_ModStart> -> frame_type ; int update_any_ref_buffers = 1 ; if ( cpi -> common . refresh_last_frame == 0 && cpi -> common . refresh_golden_frame == 0 && cpi -> common . refresh_alt_ref_frame == 0 ) { update_any_ref_buffers = 0 ; } <S2SV_ModStart> == 0 ) { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level_fast ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level_fast ( <S2SV_ModEnd> cpi -> Source <S2SV_ModStart> cpi ) ; } # else vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ; # endif } else { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level ( <S2SV_ModEnd> cpi -> Source <S2SV_ModStart> cpi ) ; } # else vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; # endif } <S2SV_ModStart> filter_level > 0 && update_any_ref_buffers
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> const FRAME_TYPE frame_type = cm -> frame_type ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . auto_filter == 0 ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> filter_level > 0 ) <S2SV_EndBug>"
3929,CWE-125,"static void ip_optprint ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int option_len ; const char * sep = """" ; for ( ; length > 0 ; cp += option_len , length -= option_len ) { u_int option_code ; ND_PRINT ( ( ndo , ""%s"" , sep ) ) ; sep = "","" ; ND_TCHECK ( * cp ) ; option_code = * cp ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( ip_option_values , ""unknown<S2SV_blank>%u"" , option_code ) ) ) ; if ( option_code == IPOPT_NOP || option_code == IPOPT_EOL ) option_len = 1 ; else { ND_TCHECK ( cp [ 1 ] ) ; option_len = cp [ 1 ] ; if ( option_len < 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; return ; } } if ( option_len > length ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; return ; } ND_TCHECK2 ( * cp , option_len ) ; switch ( option_code ) { case IPOPT_EOL : return ; case IPOPT_TS : ip_printts ( ndo , cp , option_len ) ; break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : <S2SV_StartBug> ip_printroute ( ndo , cp , option_len ) ; <S2SV_EndBug> break ; case IPOPT_RA : if ( option_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; break ; } ND_TCHECK ( cp [ 3 ] ) ; if ( EXTRACT_16BITS ( & cp [ 2 ] ) != 0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>value<S2SV_blank>%u"" , EXTRACT_16BITS ( & cp [ 2 ] ) ) ) ; break ; case IPOPT_NOP : case IPOPT_SECURITY : default : break ; } } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> case IPOPT_LSRR : if ( <S2SV_ModStart> , option_len ) == - 1 ) goto trunc
",the-tcpdump-group@tcpdump/eee0b04bcfdae319c242b0b8fc3d07029ee65b8c,CVE-2017-13022,https://github.com/the-tcpdump-group/tcpdump/commit/eee0b04bcfdae319c242b0b8fc3d07029ee65b8c,2017-09-14T06:29Z,"<S2SV_StartBug> ip_printroute ( ndo , cp , option_len ) ; <S2SV_EndBug>"
6832,CWE-190,"static PyObject * <S2SV_StartBug> _Unpickler_MemoGet ( UnpicklerObject * self , Py_ssize_t idx ) <S2SV_EndBug> { <S2SV_StartBug> if ( idx < 0 || idx >= self -> memo_size ) <S2SV_EndBug> return NULL ; return self -> memo [ idx ] ; }
","<S2SV_ModStart> * self , size_t <S2SV_ModEnd> idx ) { <S2SV_ModStart> { if ( <S2SV_ModEnd> idx >= self
",python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z,"<S2SV_StartBug> _Unpickler_MemoGet ( UnpicklerObject * self , Py_ssize_t idx ) <S2SV_EndBug> <S2SV_StartBug> if ( idx < 0 || idx >= self -> memo_size ) <S2SV_EndBug>"
1878,CWE-119,"static void set_good_speed_feature ( VP9_COMP * cpi , VP9_COMMON * cm , SPEED_FEATURES * sf , int speed ) { <S2SV_StartBug> sf -> adaptive_rd_thresh = 1 ; <S2SV_EndBug> sf -> recode_loop = ( speed < 1 ) ? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ; sf -> allow_skip_recode = 1 ; if ( speed >= 1 ) { <S2SV_StartBug> sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> less_rectangular_check = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> : USE_LARGESTALL ; if ( MIN ( cm -> width , cm -> height ) >= 720 ) sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = DISABLE_COMPOUND_SPLIT ; sf -> use_rd_breakout = 1 ; sf -> adaptive_motion_search = 1 ; <S2SV_StartBug> sf -> auto_mv_step_size = 1 ; <S2SV_EndBug> sf -> adaptive_rd_thresh = 2 ; <S2SV_StartBug> sf -> subpel_iters_per_step = 1 ; <S2SV_EndBug> sf -> mode_skip_start = 10 ; sf -> adaptive_pred_interp_filter = 1 ; sf -> recode_loop = ALLOW_RECODE_KFARFGF ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <S2SV_StartBug> sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <S2SV_EndBug> } if ( speed >= 2 ) { <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> : USE_LARGESTALL ; <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = LAST_AND_INTRA_SPLIT_ONLY ; sf -> adaptive_pred_interp_filter = 2 ; sf -> reference_masking = 1 ; sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ; sf -> disable_filter_search_var_thresh = 100 ; sf -> comp_inter_joint_search_thresh = BLOCK_SIZES ; sf -> auto_min_max_partition_size = RELAXED_NEIGHBORING_MIN_MAX ; <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ; <S2SV_EndBug> sf -> adjust_partitioning_from_last_frame = 1 ; sf -> last_partitioning_redo_frequency = 3 ; } if ( speed >= 3 ) { <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> sf -> disable_split_mask = DISABLE_ALL_SPLIT ; else sf -> disable_split_mask = DISABLE_ALL_INTER_SPLIT ; sf -> recode_loop = ALLOW_RECODE_KFMAXBW ; sf -> adaptive_rd_thresh = 3 ; sf -> mode_skip_start = 6 ; <S2SV_StartBug> sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; <S2SV_EndBug> sf -> use_fast_coef_costing = 1 ; } if ( speed >= 4 ) { sf -> use_square_partition_only = 1 ; sf -> tx_size_search_method = USE_LARGESTALL ; <S2SV_StartBug> sf -> disable_split_mask = DISABLE_ALL_SPLIT ; <S2SV_EndBug> <S2SV_StartBug> sf -> adaptive_rd_thresh = 4 ; <S2SV_EndBug> <S2SV_StartBug> sf -> mode_search_skip_flags |= FLAG_SKIP_COMP_REFMISMATCH | <S2SV_EndBug> FLAG_EARLY_TERMINATE ; sf -> disable_filter_search_var_thresh = 200 ; <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_ALL ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_lp32x32fdct = 1 ; <S2SV_EndBug> } if ( speed >= 5 ) { int i ; <S2SV_StartBug> sf -> partition_search_type = FIXED_PARTITION ; <S2SV_EndBug> sf -> optimize_coefficients = 0 ; <S2SV_StartBug> sf -> search_method = HEX ; <S2SV_EndBug> sf -> disable_filter_search_var_thresh = 500 ; for ( i = 0 ; i < TX_SIZES ; ++ i ) { <S2SV_StartBug> sf -> intra_y_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_uv_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> } cpi -> allow_encode_breakout = ENCODE_BREAKOUT_ENABLED ; } }
","<S2SV_ModStart> speed ) { const int boosted = frame_is_boosted ( cpi ) ; <S2SV_ModStart> adaptive_rd_thresh = 1 <S2SV_ModEnd> ; sf -> <S2SV_ModStart> 1 ) { if ( ( cpi -> twopass . fr_content_type == FC_GRAPHICS_ANIMATION ) || vp9_internal_image_edge ( cpi ) ) { sf -> use_square_partition_only = ! frame_is_boosted ( cpi ) ; } else { <S2SV_ModStart> cm ) ; } <S2SV_ModStart> ; sf -> <S2SV_ModEnd> use_rd_breakout = 1 <S2SV_ModStart> ; sf -> mv . <S2SV_ModStart> ; sf -> mv . <S2SV_ModStart> ] = INTRA_DC_H_V ; sf -> tx_size_search_breakout = 1 ; sf -> partition_search_breakout_rate_thr = 80 <S2SV_ModStart> -> tx_size_search_method = frame_is_boosted <S2SV_ModEnd> ( cpi ) <S2SV_ModStart> : USE_LARGESTALL ; sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ; sf -> mode_search_skip_flags = <S2SV_ModEnd> ( cm -> <S2SV_ModStart> ( cm -> frame_type == KEY_FRAME ) ? 0 : <S2SV_ModEnd> FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER <S2SV_ModStart> ; sf -> allow_partition_search_skip = 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> 3 ) { sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; sf -> tx_size_search_method = frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED ; sf -> adaptive_pred_interp_filter = 0 ; sf -> adaptive_mode_search = 1 ; sf -> cb_partition_search = ! boosted ; sf -> cb_pred_filter_search = 1 ; sf -> alt_ref_search_fp = 1 <S2SV_ModEnd> ; sf -> <S2SV_ModStart> ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> adaptive_interp_filter_search <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ; sf -> mv . search_method = BIGDIA ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE <S2SV_ModEnd> ; sf -> <S2SV_ModStart> = 4 ; if ( cm -> frame_type != KEY_FRAME ) <S2SV_ModStart> -> mode_search_skip_flags |= <S2SV_ModEnd> FLAG_EARLY_TERMINATE ; sf <S2SV_ModStart> ; sf -> <S2SV_ModEnd> use_lp32x32fdct = 1 <S2SV_ModStart> use_lp32x32fdct = 1 ; sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; sf -> use_fast_coef_costing = 1 ; sf -> motion_field_mode_search = ! boosted ; sf -> partition_search_breakout_rate_thr = 300 <S2SV_ModStart> ; sf -> <S2SV_ModEnd> optimize_coefficients = 0 <S2SV_ModStart> ; sf -> mv . <S2SV_ModStart> i ] = INTRA_DC <S2SV_ModEnd> ; sf -> <S2SV_ModStart> i ] = INTRA_DC ; } sf -> partition_search_breakout_rate_thr = 500 ; sf -> mv . reduce_first_step_size = 1 ; sf -> simple_model_rd_from_var = 1 <S2SV_ModEnd> ; } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> sf -> adaptive_rd_thresh = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> less_rectangular_check = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> <S2SV_StartBug> sf -> auto_mv_step_size = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> subpel_iters_per_step = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <S2SV_EndBug> <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ; <S2SV_EndBug> <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> <S2SV_StartBug> sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; <S2SV_EndBug> <S2SV_StartBug> sf -> disable_split_mask = DISABLE_ALL_SPLIT ; <S2SV_EndBug> <S2SV_StartBug> sf -> adaptive_rd_thresh = 4 ; <S2SV_EndBug> <S2SV_StartBug> sf -> mode_search_skip_flags |= FLAG_SKIP_COMP_REFMISMATCH | <S2SV_EndBug> <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_ALL ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_lp32x32fdct = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> partition_search_type = FIXED_PARTITION ; <S2SV_EndBug> <S2SV_StartBug> sf -> search_method = HEX ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_y_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_uv_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug>"
3619,CWE-20,"static inline void VectorClamp ( DDSVector4 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> w = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,
",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z,"<S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ; <S2SV_EndBug>"
2712,CWE-264,"int cg_write ( const char * path , const char * buf , size_t size , off_t offset , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; char * localbuf = NULL ; struct cgfs_files * k = NULL ; struct file_info * f = ( struct file_info * ) fi -> fh ; bool r ; if ( f -> type != LXC_TYPE_CGFILE ) { fprintf ( stderr , ""Internal<S2SV_blank>error:<S2SV_blank>directory<S2SV_blank>cache<S2SV_blank>info<S2SV_blank>used<S2SV_blank>in<S2SV_blank>cg_write\\n"" ) ; return - EIO ; } if ( offset ) return 0 ; if ( ! fc ) return - EIO ; localbuf = alloca ( size + 1 ) ; localbuf [ size ] = '\\0' ; memcpy ( localbuf , buf , size ) ; if ( ( k = cgfs_get_key ( f -> controller , f -> cgroup , f -> file ) ) == NULL ) { size = - EINVAL ; goto out ; } if ( ! fc_may_access ( fc , f -> controller , f -> cgroup , f -> file , O_WRONLY ) ) { size = - EACCES ; goto out ; } if ( strcmp ( f -> file , ""tasks"" ) == 0 || strcmp ( f -> file , ""/tasks"" ) == 0 || strcmp ( f -> file , ""/cgroup.procs"" ) == 0 || strcmp ( f -> file , ""cgroup.procs"" ) == 0 ) <S2SV_StartBug> r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ; <S2SV_EndBug> else r = cgfs_set_value ( f -> controller , f -> cgroup , f -> file , localbuf ) ; if ( ! r ) size = - EINVAL ; out : free_key ( k ) ; return size ; }
","<S2SV_ModStart> -> pid , fc -> uid ,
",lxc@lxcfs/8ee2a503e102b1a43ec4d83113dc275ab20a869a,CVE-2015-1344,https://github.com/lxc/lxcfs/commit/8ee2a503e102b1a43ec4d83113dc275ab20a869a,2015-12-07T20:59Z,"<S2SV_StartBug> r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ; <S2SV_EndBug>"
2214,CWE-200,"static void * __dma_alloc_coherent ( struct device * dev , size_t size , dma_addr_t * dma_handle , gfp_t flags , struct dma_attrs * attrs ) { if ( dev == NULL ) { WARN_ONCE ( 1 , ""Use<S2SV_blank>an<S2SV_blank>actual<S2SV_blank>device<S2SV_blank>structure<S2SV_blank>for<S2SV_blank>DMA<S2SV_blank>allocation\\n"" ) ; return NULL ; } if ( IS_ENABLED ( CONFIG_ZONE_DMA ) && dev -> coherent_dma_mask <= DMA_BIT_MASK ( 32 ) ) flags |= GFP_DMA ; if ( IS_ENABLED ( CONFIG_DMA_CMA ) && ( flags & __GFP_WAIT ) ) { struct page * page ; void * addr ; size = PAGE_ALIGN ( size ) ; page = dma_alloc_from_contiguous ( dev , size >> PAGE_SHIFT , get_order ( size ) ) ; if ( ! page ) return NULL ; * dma_handle = phys_to_dma ( dev , page_to_phys ( page ) ) ; addr = page_address ( page ) ; <S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> memset ( addr , 0 , size ) ; return addr ; } else { return swiotlb_alloc_coherent ( dev , size , dma_handle , flags ) ; } }
","<S2SV_ModStart> page ) ; <S2SV_ModEnd> memset ( addr
",torvalds@linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5,CVE-2015-8950,https://github.com/torvalds/linux/commit/6829e274a623187c24f7cfc0e3d35f25d087fcc5,2016-10-10T10:59Z,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug>
1092,CWE-200,"static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rose_sock * rose = rose_sk ( sk ) ; struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( srose != NULL ) { <S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug> srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }
","<S2SV_ModStart> NULL ) { memset ( srose , 0 , msg -> msg_namelen ) ;
",torvalds@linux/4a184233f21645cf0b719366210ed445d1024d72,CVE-2013-3234,https://github.com/torvalds/linux/commit/4a184233f21645cf0b719366210ed445d1024d72,2013-04-22T11:41Z,<S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug>
7853,CWE-20,"uint16_t dm9000ReadPhyReg ( uint8_t address ) { <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> { } <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> usleep ( 5 ) ; <S2SV_StartBug> return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> { dm9000WriteReg ( DM9000_EPAR <S2SV_ModEnd> , 0x40 | <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> ) != 0 <S2SV_ModStart> } dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPDRH <S2SV_ModEnd> ) << 8 <S2SV_ModStart> | dm9000ReadReg ( DM9000_EPDRL <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> <S2SV_StartBug> return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ; <S2SV_EndBug>"
3161,CWE-787,"static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) { ExceptionInfo * exception ; int bit ; ssize_t x ; register PixelPacket * q ; IndexPacket index ; register IndexPacket * indexes ; exception = ( & image -> exception ) ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; <S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }
","<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index
",ImageMagick@ImageMagick/b6ae2f9e0ab13343c0281732d479757a8e8979c7,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/b6ae2f9e0ab13343c0281732d479757a8e8979c7,2017-04-20T18:59Z,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug>
1149,CWE-189,"static png_size_t png_inflate ( png_structp png_ptr , const png_byte * data , png_size_t size , png_bytep output , png_size_t output_size ) { png_size_t count = 0 ; png_ptr -> zstream . next_in = ( png_bytep ) data ; png_ptr -> zstream . avail_in = size ; while ( 1 ) { int ret , avail ; png_ptr -> zstream . next_out = png_ptr -> zbuf ; png_ptr -> zstream . avail_out = png_ptr -> zbuf_size ; ret = inflate ( & png_ptr -> zstream , Z_NO_FLUSH ) ; avail = png_ptr -> zbuf_size - png_ptr -> zstream . avail_out ; if ( ( ret == Z_OK || ret == Z_STREAM_END ) && avail > 0 ) { if ( output != 0 && output_size > count ) { <S2SV_StartBug> int copy = output_size - count ; <S2SV_EndBug> <S2SV_StartBug> if ( avail < copy ) copy = avail ; <S2SV_EndBug> png_memcpy ( output + count , png_ptr -> zbuf , copy ) ; } count += avail ; } if ( ret == Z_OK ) continue ; png_ptr -> zstream . avail_in = 0 ; inflateReset ( & png_ptr -> zstream ) ; if ( ret == Z_STREAM_END ) return count ; { PNG_CONST char * msg ; if ( png_ptr -> zstream . msg != 0 ) msg = png_ptr -> zstream . msg ; else { # if defined ( PNG_STDIO_SUPPORTED ) && ! defined ( _WIN32_WCE ) char umsg [ 52 ] ; switch ( ret ) { case Z_BUF_ERROR : msg = ""Buffer<S2SV_blank>error<S2SV_blank>in<S2SV_blank>compressed<S2SV_blank>datastream<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>chunk"" ; break ; case Z_DATA_ERROR : msg = ""Data<S2SV_blank>error<S2SV_blank>in<S2SV_blank>compressed<S2SV_blank>datastream<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>chunk"" ; break ; default : msg = ""Incomplete<S2SV_blank>compressed<S2SV_blank>datastream<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>chunk"" ; break ; } png_snprintf ( umsg , sizeof umsg , msg , png_ptr -> chunk_name ) ; msg = umsg ; # else msg = ""Damaged<S2SV_blank>compressed<S2SV_blank>datastream<S2SV_blank>in<S2SV_blank>chunk<S2SV_blank>other<S2SV_blank>than<S2SV_blank>IDAT"" ; # endif } png_warning ( png_ptr , msg ) ; } return 0 ; } }
","<S2SV_ModStart> count ) { png_size_t <S2SV_ModEnd> copy = output_size <S2SV_ModStart> ; if ( ( png_size_t ) <S2SV_ModStart> ) copy = ( png_size_t )
",chromium@chromium/4cf106cdb83dd6b35d3b26d06cc67d1d2d99041e,CVE-2011-3045,https://github.com/chromium/chromium/commit/4cf106cdb83dd6b35d3b26d06cc67d1d2d99041e,2012-03-22T16:55Z,<S2SV_StartBug> int copy = output_size - count ; <S2SV_EndBug> <S2SV_StartBug> if ( avail < copy ) copy = avail ; <S2SV_EndBug>
2166,CWE-119,"static int gfs2_bmap_alloc ( struct inode * inode , const sector_t lblock , struct buffer_head * bh_map , struct metapath * mp , const unsigned int sheight , const unsigned int height , const unsigned int maxlen ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; <S2SV_StartBug> struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; <S2SV_EndBug> u64 bn , dblock = 0 ; unsigned n , i , blks , alloced = 0 , iblks = 0 , branch_start = 0 ; unsigned dblks = 0 ; unsigned ptrs_per_blk ; <S2SV_StartBug> const unsigned end_of_metadata = height - 1 ; <S2SV_EndBug> int eob = 0 ; enum alloc_state state ; __be64 * ptr ; __be64 zero_bn = 0 ; BUG_ON ( sheight < 1 ) ; BUG_ON ( dibh == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( height == sheight ) { struct buffer_head * bh ; ptr = metapointer ( end_of_metadata , mp ) ; bh = mp -> mp_bh [ end_of_metadata ] ; dblks = gfs2_extent_length ( bh -> b_data , bh -> b_size , ptr , maxlen , & eob ) ; BUG_ON ( dblks < 1 ) ; state = ALLOC_DATA ; } else { ptrs_per_blk = height > 1 ? sdp -> sd_inptrs : sdp -> sd_diptrs ; dblks = min ( maxlen , ptrs_per_blk - mp -> mp_list [ end_of_metadata ] ) ; if ( height == ip -> i_height ) { iblks = height - sheight ; state = ALLOC_GROW_DEPTH ; } else { state = ALLOC_GROW_HEIGHT ; iblks = height - ip -> i_height ; branch_start = metapath_branch_start ( mp ) ; iblks += ( height - branch_start ) ; } } blks = dblks + iblks ; i = sheight ; do { int error ; n = blks - alloced ; error = gfs2_alloc_block ( ip , & bn , & n ) ; if ( error ) return error ; alloced += n ; if ( state != ALLOC_DATA || gfs2_is_jdata ( ip ) ) gfs2_trans_add_unrevoke ( sdp , bn , n ) ; switch ( state ) { case ALLOC_GROW_HEIGHT : if ( i == 1 ) { ptr = ( __be64 * ) ( dibh -> b_data + sizeof ( struct gfs2_dinode ) ) ; zero_bn = * ptr ; } for ( ; i - 1 < height - ip -> i_height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , 0 , bn ++ ) ; if ( i - 1 == height - ip -> i_height ) { i -- ; gfs2_buffer_copy_tail ( mp -> mp_bh [ i ] , sizeof ( struct gfs2_meta_header ) , dibh , sizeof ( struct gfs2_dinode ) ) ; gfs2_buffer_clear_tail ( dibh , sizeof ( struct gfs2_dinode ) + sizeof ( __be64 ) ) ; ptr = ( __be64 * ) ( mp -> mp_bh [ i ] -> b_data + sizeof ( struct gfs2_meta_header ) ) ; * ptr = zero_bn ; state = ALLOC_GROW_DEPTH ; for ( i = branch_start ; i < height ; i ++ ) { if ( mp -> mp_bh [ i ] == NULL ) break ; brelse ( mp -> mp_bh [ i ] ) ; mp -> mp_bh [ i ] = NULL ; } i = branch_start ; } if ( n == 0 ) break ; case ALLOC_GROW_DEPTH : if ( i > 1 && i < height ) gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ i - 1 ] , 1 ) ; for ( ; i < height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , mp -> mp_list [ i - 1 ] , bn ++ ) ; if ( i == height ) state = ALLOC_DATA ; if ( n == 0 ) break ; case ALLOC_DATA : BUG_ON ( n > dblks ) ; BUG_ON ( mp -> mp_bh [ end_of_metadata ] == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ end_of_metadata ] , 1 ) ; dblks = n ; ptr = metapointer ( end_of_metadata , mp ) ; dblock = bn ; while ( n -- > 0 ) * ptr ++ = cpu_to_be64 ( bn ++ ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } } while ( ( state != ALLOC_DATA ) || ! dblock ) ; ip -> i_height = height ; gfs2_add_inode_blocks ( & ip -> i_inode , alloced ) ; gfs2_dinode_out ( ip , mp -> mp_bh [ 0 ] -> b_data ) ; map_bh ( bh_map , inode -> i_sb , dblock ) ; bh_map -> b_size = dblks << inode -> i_blkbits ; set_buffer_new ( bh_map ) ; return 0 ; }
","<S2SV_ModStart> ) ; struct super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> height - 1 ; int ret <S2SV_ModStart> ++ ) ; if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n"" ) ; clear_buffer_zeronew ( bh_map ) ; } }
",torvalds@linux/64dd153c83743af81f20924c6343652d731eeecb,CVE-2011-4098,https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb,2013-06-08T13:05Z,<S2SV_StartBug> struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const unsigned end_of_metadata = height - 1 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug>
4104,CWE-399,"void fib_del_ifaddr ( struct in_ifaddr * ifa , struct in_ifaddr * iprim ) { struct in_device * in_dev = ifa -> ifa_dev ; struct net_device * dev = in_dev -> dev ; struct in_ifaddr * ifa1 ; struct in_ifaddr * prim = ifa , * prim1 = NULL ; __be32 brd = ifa -> ifa_address | ~ ifa -> ifa_mask ; __be32 any = ifa -> ifa_address & ifa -> ifa_mask ; # define LOCAL_OK 1 # define BRD_OK 2 # define BRD0_OK 4 # define BRD1_OK 8 unsigned int ok = 0 ; int subnet = 0 ; int gone = 1 ; int same_prefsrc = 0 ; if ( ifa -> ifa_flags & IFA_F_SECONDARY ) { prim = inet_ifa_byprefix ( in_dev , any , ifa -> ifa_mask ) ; if ( ! prim ) { pr_warn ( ""%s:<S2SV_blank>bug:<S2SV_blank>prim<S2SV_blank>==<S2SV_blank>NULL\\n"" , __func__ ) ; return ; } if ( iprim && iprim != prim ) { pr_warn ( ""%s:<S2SV_blank>bug:<S2SV_blank>iprim<S2SV_blank>!=<S2SV_blank>prim\\n"" , __func__ ) ; return ; } } else if ( ! ipv4_is_zeronet ( any ) && ( any != ifa -> ifa_local || ifa -> ifa_prefixlen < 32 ) ) { if ( ! ( ifa -> ifa_flags & IFA_F_NOPREFIXROUTE ) ) fib_magic ( RTM_DELROUTE , dev -> flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST , any , ifa -> ifa_prefixlen , prim ) ; subnet = 1 ; } <S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> if ( ifa1 == ifa ) { gone = 0 ; continue ; } if ( iprim && ifa1 -> ifa_mask == iprim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , iprim ) ) continue ; if ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) { if ( ifa1 -> ifa_mask == prim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , prim ) ) prim1 = prim ; else { if ( ! same_prefsrc ) continue ; if ( ! prim1 || ifa1 -> ifa_mask != prim1 -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , prim1 ) ) prim1 = inet_ifa_byprefix ( in_dev , ifa1 -> ifa_address , ifa1 -> ifa_mask ) ; if ( ! prim1 ) continue ; if ( prim1 -> ifa_local != prim -> ifa_local ) continue ; } } else { if ( prim -> ifa_local != ifa1 -> ifa_local ) continue ; prim1 = ifa1 ; if ( prim != prim1 ) same_prefsrc = 1 ; } if ( ifa -> ifa_local == ifa1 -> ifa_local ) ok |= LOCAL_OK ; if ( ifa -> ifa_broadcast == ifa1 -> ifa_broadcast ) ok |= BRD_OK ; if ( brd == ifa1 -> ifa_broadcast ) ok |= BRD1_OK ; if ( any == ifa1 -> ifa_broadcast ) ok |= BRD0_OK ; if ( prim1 == ifa1 && ifa1 -> ifa_prefixlen < 31 ) { __be32 brd1 = ifa1 -> ifa_address | ~ ifa1 -> ifa_mask ; __be32 any1 = ifa1 -> ifa_address & ifa1 -> ifa_mask ; if ( ! ipv4_is_zeronet ( any1 ) ) { if ( ifa -> ifa_broadcast == brd1 || ifa -> ifa_broadcast == any1 ) ok |= BRD_OK ; if ( brd == brd1 || brd == any1 ) ok |= BRD1_OK ; if ( any == brd1 || any == any1 ) ok |= BRD0_OK ; } } <S2SV_StartBug> } <S2SV_EndBug> if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ; if ( subnet && ifa -> ifa_prefixlen < 31 ) { if ( ! ( ok & BRD1_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , brd , 32 , prim ) ; if ( ! ( ok & BRD0_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , any , 32 , prim ) ; } if ( ! ( ok & LOCAL_OK ) ) { unsigned int addr_type ; fib_magic ( RTM_DELROUTE , RTN_LOCAL , ifa -> ifa_local , 32 , prim ) ; addr_type = inet_addr_type_dev_table ( dev_net ( dev ) , dev , ifa -> ifa_local ) ; if ( gone && addr_type != RTN_LOCAL ) { if ( fib_sync_down_addr ( dev_net ( dev ) , ifa -> ifa_local ) ) fib_flush ( dev_net ( dev ) ) ; } } # undef LOCAL_OK # undef BRD_OK # undef BRD0_OK # undef BRD1_OK }
","<S2SV_ModStart> 1 ; } if ( in_dev -> dead ) goto no_promotions ; <S2SV_ModStart> } } } no_promotions :
",torvalds@linux/fbd40ea0180a2d328c5adc61414dc8bab9335ce2,CVE-2016-3156,https://github.com/torvalds/linux/commit/fbd40ea0180a2d328c5adc61414dc8bab9335ce2,2016-04-27T17:59Z,<S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
208,CWE-787,"static char * get_object ( FILE * fp , int obj_id , const xref_t * xref , size_t * size , int * is_stream ) { static const int blk_sz = 256 ; int i , total_sz , read_sz , n_blks , search , stream ; size_t obj_sz ; char * c , * data ; long start ; const xref_entry_t * entry ; if ( size ) * size = 0 ; if ( is_stream ) * is_stream = 0 ; start = ftell ( fp ) ; entry = NULL ; for ( i = 0 ; i < xref -> n_entries ; i ++ ) if ( xref -> entries [ i ] . obj_id == obj_id ) { entry = & xref -> entries [ i ] ; break ; } if ( ! entry ) return NULL ; fseek ( fp , entry -> offset , SEEK_SET ) ; obj_sz = 0 ; total_sz = 0 ; n_blks = 1 ; <S2SV_StartBug> data = malloc ( blk_sz * n_blks ) ; <S2SV_EndBug> memset ( data , 0 , blk_sz * n_blks ) ; stream = 0 ; while ( ( read_sz = fread ( data + total_sz , 1 , blk_sz - 1 , fp ) ) && ! ferror ( fp ) ) { total_sz += read_sz ; * ( data + total_sz ) = '\\0' ; if ( total_sz + blk_sz >= ( blk_sz * n_blks ) ) data = realloc ( data , blk_sz * ( ++ n_blks ) ) ; search = total_sz - read_sz ; if ( search < 0 ) search = 0 ; if ( ( c = strstr ( data + search , ""endobj"" ) ) ) { * ( c + strlen ( ""endobj"" ) + 1 ) = '\\0' ; obj_sz = ( void * ) strstr ( data + search , ""endobj"" ) - ( void * ) data ; obj_sz += strlen ( ""endobj"" ) + 1 ; break ; } else if ( strstr ( data , ""stream"" ) ) stream = 1 ; } clearerr ( fp ) ; fseek ( fp , start , SEEK_SET ) ; if ( size ) * size = obj_sz ; if ( is_stream ) * is_stream = stream ; return data ; }
","<S2SV_ModStart> ; data = safe_calloc ( <S2SV_ModEnd> blk_sz * n_blks
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,<S2SV_StartBug> data = malloc ( blk_sz * n_blks ) ; <S2SV_EndBug>
2495,CWE-399,"static int xen_netbk_tx_check_gop ( struct xen_netbk * netbk , struct sk_buff * skb , struct gnttab_copy * * gopp ) { struct gnttab_copy * gop = * gopp ; u16 pending_idx = * ( ( u16 * ) skb -> data ) ; <S2SV_StartBug> struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ; <S2SV_EndBug> struct xenvif * vif = pending_tx_info [ pending_idx ] . vif ; struct xen_netif_tx_request * txp ; struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i , err , start ; err = gop -> status ; <S2SV_StartBug> if ( unlikely ( err ) ) { <S2SV_EndBug> pending_ring_idx_t index ; index = pending_index ( netbk -> pending_prod ++ ) ; txp = & pending_tx_info [ pending_idx ] . req ; make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ; <S2SV_StartBug> netbk -> pending_ring [ index ] = pending_idx ; <S2SV_EndBug> xenvif_put ( vif ) ; } start = ( frag_get_pending_idx ( & shinfo -> frags [ 0 ] ) == pending_idx ) ; for ( i = start ; i < nr_frags ; i ++ ) { int j , newerr ; <S2SV_StartBug> pending_ring_idx_t index ; <S2SV_EndBug> pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ; newerr = ( ++ gop ) -> status ; if ( likely ( ! newerr ) ) { if ( unlikely ( err ) ) <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> continue ; } <S2SV_StartBug> txp = & netbk -> pending_tx_info [ pending_idx ] . req ; <S2SV_EndBug> make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ; <S2SV_StartBug> index = pending_index ( netbk -> pending_prod ++ ) ; <S2SV_EndBug> netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; if ( err ) continue ; pending_idx = * ( ( u16 * ) skb -> data ) ; <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> for ( j = start ; j < i ; j ++ ) { pending_idx = frag_get_pending_idx ( & shinfo -> frags [ j ] ) ; <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } err = newerr ; } * gopp = gop + 1 ; return err ; }
","<S2SV_ModStart> ) ; struct <S2SV_ModEnd> skb_shared_info * shinfo <S2SV_ModStart> err ) ) xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> , XEN_NETIF_RSP_ERROR ) <S2SV_ModStart> XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> start = ( <S2SV_ModStart> , newerr ; <S2SV_ModEnd> pending_idx = frag_get_pending_idx <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> continue ; } xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> , XEN_NETIF_RSP_ERROR ) <S2SV_ModStart> XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> if ( err <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
",torvalds@linux/7d5145d8eb2b9791533ffe4dc003b129b9696c48,CVE-2013-0217,https://github.com/torvalds/linux/commit/7d5145d8eb2b9791533ffe4dc003b129b9696c48,2013-02-18T04:41Z,"<S2SV_StartBug> struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err ) ) { <S2SV_EndBug> <S2SV_StartBug> netbk -> pending_ring [ index ] = pending_idx ; <S2SV_EndBug> <S2SV_StartBug> pending_ring_idx_t index ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> txp = & netbk -> pending_tx_info [ pending_idx ] . req ; <S2SV_EndBug> <S2SV_StartBug> index = pending_index ( netbk -> pending_prod ++ ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug>"
2889,CWE-415,"int blkcg_init_queue ( struct request_queue * q ) { struct blkcg_gq * new_blkg , * blkg ; bool preloaded ; int ret ; new_blkg = blkg_alloc ( & blkcg_root , q , GFP_KERNEL ) ; if ( ! new_blkg ) return - ENOMEM ; preloaded = ! radix_tree_preload ( GFP_KERNEL ) ; rcu_read_lock ( ) ; spin_lock_irq ( q -> queue_lock ) ; blkg = blkg_create ( & blkcg_root , q , new_blkg ) ; spin_unlock_irq ( q -> queue_lock ) ; rcu_read_unlock ( ) ; if ( preloaded ) radix_tree_preload_end ( ) ; <S2SV_StartBug> if ( IS_ERR ( blkg ) ) { <S2SV_EndBug> blkg_free ( new_blkg ) ; return PTR_ERR ( blkg ) ; <S2SV_StartBug> } <S2SV_EndBug> q -> root_blkg = blkg ; q -> root_rl . blkg = blkg ; ret = blk_throtl_init ( q ) ; if ( ret ) { spin_lock_irq ( q -> queue_lock ) ; blkg_destroy_all ( q ) ; spin_unlock_irq ( q -> queue_lock ) ; } return ret ; }
","<S2SV_ModStart> blkg ) ) <S2SV_ModEnd> return PTR_ERR ( <S2SV_ModStart> blkg ) ; <S2SV_ModEnd> q -> root_blkg
",torvalds@linux/9b54d816e00425c3a517514e0d677bb3cec49258,CVE-2018-7480,https://github.com/torvalds/linux/commit/9b54d816e00425c3a517514e0d677bb3cec49258,2018-02-25T20:29Z,<S2SV_StartBug> if ( IS_ERR ( blkg ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
7989,CWE-120,"SecureElementStatus_t SecureElementProcessJoinAccept ( JoinReqIdentifier_t joinReqType , uint8_t * joinEui , uint16_t devNonce , uint8_t * encJoinAccept , uint8_t encJoinAcceptSize , uint8_t * decJoinAccept , uint8_t * versionMinor ) { SecureElementStatus_t status = SECURE_ELEMENT_ERROR ; if ( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) ) { <S2SV_StartBug> return SECURE_ELEMENT_ERROR_NPE ; <S2SV_EndBug> } KeyIdentifier_t encKeyID = NWK_KEY ; if ( joinReqType != JOIN_REQ ) { encKeyID = J_S_ENC_KEY ; } uint8_t micHeader10 [ 1 ] = { 0x20 } ; lr1110_crypto_process_join_accept ( & LR1110 , ( lr1110_crypto_status_t * ) & status , convert_key_id_from_se_to_lr1110 ( encKeyID ) , convert_key_id_from_se_to_lr1110 ( NWK_KEY ) , ( lr1110_crypto_lorawan_version_t ) 0 , micHeader10 , encJoinAccept + 1 , encJoinAcceptSize - 1 , decJoinAccept + 1 ) ; if ( status == SECURE_ELEMENT_SUCCESS ) { * versionMinor = ( ( decJoinAccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; if ( * versionMinor == 0 ) { return SECURE_ELEMENT_SUCCESS ; } } # if ( USE_LRWAN_1_1_X_CRYPTO == 1 ) uint8_t micHeader11 [ JOIN_ACCEPT_MIC_COMPUTATION_OFFSET ] = { 0 } ; uint16_t bufItr = 0 ; micHeader11 [ bufItr ++ ] = ( uint8_t ) joinReqType ; memcpyr ( micHeader11 + bufItr , joinEui , LORAMAC_JOIN_EUI_FIELD_SIZE ) ; bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE ; micHeader11 [ bufItr ++ ] = devNonce & 0xFF ; micHeader11 [ bufItr ++ ] = ( devNonce >> 8 ) & 0xFF ; micHeader11 [ bufItr ++ ] = 0x20 ; lr1110_crypto_process_join_accept ( & LR1110 , ( lr1110_crypto_status_t * ) & status , convert_key_id_from_se_to_lr1110 ( encKeyID ) , convert_key_id_from_se_to_lr1110 ( J_S_INT_KEY ) , ( lr1110_crypto_lorawan_version_t ) 1 , micHeader11 , encJoinAccept + 1 , encJoinAcceptSize - 1 , decJoinAccept + 1 ) ; if ( status == SECURE_ELEMENT_SUCCESS ) { * versionMinor = ( ( decJoinAccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; if ( * versionMinor == 1 ) { return SECURE_ELEMENT_SUCCESS ; } } # endif return status ; }
","<S2SV_ModStart> { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE
",Lora-net@LoRaMac-node/e3063a91daa7ad8a687223efa63079f0c24568e4,CVE-2020-11068,https://github.com/Lora-net/LoRaMac-node/commit/e3063a91daa7ad8a687223efa63079f0c24568e4,2020-06-23T17:15Z,<S2SV_StartBug> return SECURE_ELEMENT_ERROR_NPE ; <S2SV_EndBug>
2240,CWE-119,"static int PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = ""PredictorEncodeTile"" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , ""Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>allocating<S2SV_blank>"" TIFF_SSIZE_FORMAT ""<S2SV_blank>byte<S2SV_blank>temp<S2SV_blank>buffer."" , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; if ( ( cc0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }
","<S2SV_ModStart> ""(cc0%rowsize)!=0"" ) ; _TIFFfree ( working_copy ) ;
",vadz@libtiff/6a984bf7905c6621281588431f384e79d11a2e33,CVE-2016-9535,https://github.com/vadz/libtiff/commit/6a984bf7905c6621281588431f384e79d11a2e33,2016-11-22T19:59Z,<S2SV_StartBug> return 0 ; <S2SV_EndBug>
5715,CWE-415,"static struct usmStateReference * usm_malloc_usmStateReference ( void ) { <S2SV_StartBug> struct usmStateReference * retval = ( struct usmStateReference * ) <S2SV_EndBug> calloc ( 1 , sizeof ( struct usmStateReference ) ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }
","<S2SV_ModStart> usmStateReference * retval ; retval = <S2SV_ModEnd> calloc ( 1 <S2SV_ModStart> ) ) ; if ( retval ) retval -> refcnt = 1 ;
",net-snmp@net-snmp/5f881d3bf24599b90d67a45cae7a3eb099cd71c9,CVE-2019-20892,https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9,2020-06-25T10:15Z,<S2SV_StartBug> struct usmStateReference * retval = ( struct usmStateReference * ) <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug>
3559,CWE-400,"static struct mnt_namespace * alloc_mnt_ns ( struct user_namespace * user_ns ) { struct mnt_namespace * new_ns ; struct ucounts * ucounts ; int ret ; ucounts = inc_mnt_namespaces ( user_ns ) ; if ( ! ucounts ) return ERR_PTR ( - ENOSPC ) ; new_ns = kmalloc ( sizeof ( struct mnt_namespace ) , GFP_KERNEL ) ; if ( ! new_ns ) { dec_mnt_namespaces ( ucounts ) ; return ERR_PTR ( - ENOMEM ) ; } ret = ns_alloc_inum ( & new_ns -> ns ) ; if ( ret ) { kfree ( new_ns ) ; dec_mnt_namespaces ( ucounts ) ; return ERR_PTR ( ret ) ; } new_ns -> ns . ops = & mntns_operations ; new_ns -> seq = atomic64_add_return ( 1 , & mnt_ns_seq ) ; atomic_set ( & new_ns -> count , 1 ) ; new_ns -> root = NULL ; INIT_LIST_HEAD ( & new_ns -> list ) ; init_waitqueue_head ( & new_ns -> poll ) ; new_ns -> event = 0 ; new_ns -> user_ns = get_user_ns ( user_ns ) ; new_ns -> ucounts = ucounts ; <S2SV_StartBug> return new_ns ; <S2SV_EndBug> }
","<S2SV_ModStart> = ucounts ; new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ;
",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z,<S2SV_StartBug> return new_ns ; <S2SV_EndBug>
1835,CWE-119,"<S2SV_StartBug> void vp9_rc_update_rate_correction_factors ( VP9_COMP * cpi , int damp_var ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; int correction_factor = 100 ; double rate_correction_factor = get_rate_correction_factor ( cpi ) ; double adjustment_limit ; int projected_size_based_on_q = 0 ; <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> projected_size_based_on_q = estimate_bits_at_q ( cm -> frame_type , cm -> base_qindex , cm -> MBs , <S2SV_StartBug> rate_correction_factor ) ; <S2SV_EndBug> <S2SV_StartBug> if ( projected_size_based_on_q > 0 ) <S2SV_EndBug> correction_factor = ( 100 * cpi -> rc . projected_frame_size ) / projected_size_based_on_q ; switch ( damp_var ) { case 0 : adjustment_limit = 0.75 ; break ; case 1 : adjustment_limit = 0.375 ; break ; case 2 : default : adjustment_limit = 0.25 ; break ; } if ( correction_factor > 102 ) { correction_factor = ( int ) ( 100 + ( ( correction_factor - 100 ) * adjustment_limit ) ) ; rate_correction_factor = ( rate_correction_factor * correction_factor ) / 100 ; if ( rate_correction_factor > MAX_BPB_FACTOR ) rate_correction_factor = MAX_BPB_FACTOR ; } else if ( correction_factor < 99 ) { correction_factor = ( int ) ( 100 - ( ( 100 - correction_factor ) * adjustment_limit ) ) ; rate_correction_factor = ( rate_correction_factor * correction_factor ) / 100 ; if ( rate_correction_factor < MIN_BPB_FACTOR ) rate_correction_factor = MIN_BPB_FACTOR ; } set_rate_correction_factor ( cpi , rate_correction_factor ) ; }
","<S2SV_ModStart> VP9_COMP * cpi <S2SV_ModEnd> ) { const <S2SV_ModStart> = 0 ; if ( cpi -> rc . is_src_frame_alt_ref ) return ; vpx_clear_system_state ( ) ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cpi -> common . seg . enabled ) { projected_size_based_on_q = vp9_cyclic_refresh_estimate_bits_at_q ( cpi , rate_correction_factor ) ; } else { projected_size_based_on_q = vp9_estimate_bits_at_q ( cpi -> common . <S2SV_ModEnd> frame_type , cm <S2SV_ModStart> MBs , rate_correction_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> if ( projected_size_based_on_q <S2SV_ModStart> ( projected_size_based_on_q > FRAME_OVERHEAD_BITS ) correction_factor = ( int ) ( ( 100 * ( int64_t ) cpi -> rc . projected_frame_size ) / projected_size_based_on_q ) ; adjustment_limit = 0.25 + 0.5 * MIN ( 1 , fabs ( log10 ( 0.01 * correction_factor ) ) ) ; cpi -> rc . q_2_frame = cpi -> rc . q_1_frame ; cpi -> rc . q_1_frame = cm -> base_qindex ; cpi -> rc . rc_2_frame = cpi -> rc . rc_1_frame ; if ( correction_factor > 110 ) cpi -> rc . rc_1_frame = - 1 ; else if ( correction_factor < 90 ) cpi -> rc . rc_1_frame = 1 ; else cpi -> rc . rc_1_frame = 0 ; <S2SV_ModEnd> if ( correction_factor
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> void vp9_rc_update_rate_correction_factors ( VP9_COMP * cpi , int damp_var ) { <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> rate_correction_factor ) ; <S2SV_EndBug> <S2SV_StartBug> if ( projected_size_based_on_q > 0 ) <S2SV_EndBug>"
405,CWE-362,"struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , const u8 * addr , gfp_t gfp ) { struct ieee80211_local * local = sdata -> local ; struct sta_info * sta ; struct timespec uptime ; struct ieee80211_tx_latency_bin_ranges * tx_latency ; int i ; sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; if ( ! sta ) return NULL ; rcu_read_lock ( ) ; tx_latency = rcu_dereference ( local -> tx_latency ) ; if ( tx_latency ) { sta -> tx_lat = kzalloc ( IEEE80211_NUM_TIDS * sizeof ( struct ieee80211_tx_latency_stat ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat ) { rcu_read_unlock ( ) ; goto free ; } if ( tx_latency -> n_ranges ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> tx_lat [ i ] . bin_count = tx_latency -> n_ranges + 1 ; sta -> tx_lat [ i ] . bins = kcalloc ( sta -> tx_lat [ i ] . bin_count , sizeof ( u32 ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat [ i ] . bins ) { rcu_read_unlock ( ) ; goto free ; } } } } rcu_read_unlock ( ) ; <S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ; INIT_WORK ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; mutex_init ( & sta -> ampdu_mlme . mtx ) ; # ifdef CONFIG_MAC80211_MESH if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && ! sdata -> u . mesh . user_mpm ) init_timer ( & sta -> plink_timer ) ; sta -> nonpeer_pm = NL80211_MESH_POWER_ACTIVE ; # endif memcpy ( sta -> sta . addr , addr , ETH_ALEN ) ; sta -> local = local ; sta -> sdata = sdata ; sta -> last_rx = jiffies ; sta -> sta_state = IEEE80211_STA_NONE ; do_posix_clock_monotonic_gettime ( & uptime ) ; sta -> last_connected = uptime . tv_sec ; ewma_init ( & sta -> avg_signal , 1024 , 8 ) ; for ( i = 0 ; i < ARRAY_SIZE ( sta -> chain_signal_avg ) ; i ++ ) ewma_init ( & sta -> chain_signal_avg [ i ] , 1024 , 8 ) ; if ( sta_prepare_rate_control ( local , sta , gfp ) ) goto free ; for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> timer_to_tid [ i ] = i ; } for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { skb_queue_head_init ( & sta -> ps_tx_buf [ i ] ) ; skb_queue_head_init ( & sta -> tx_filtered [ i ] ) ; } for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) sta -> last_seq_ctrl [ i ] = cpu_to_le16 ( USHRT_MAX ) ; sta -> sta . smps_mode = IEEE80211_SMPS_OFF ; if ( sdata -> vif . type == NL80211_IFTYPE_AP || sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) { struct ieee80211_supported_band * sband = local -> hw . wiphy -> bands [ ieee80211_get_sdata_band ( sdata ) ] ; u8 smps = ( sband -> ht_cap . cap & IEEE80211_HT_CAP_SM_PS ) >> IEEE80211_HT_CAP_SM_PS_SHIFT ; switch ( smps ) { case WLAN_HT_SMPS_CONTROL_DISABLED : sta -> known_smps_mode = IEEE80211_SMPS_OFF ; break ; case WLAN_HT_SMPS_CONTROL_STATIC : sta -> known_smps_mode = IEEE80211_SMPS_STATIC ; break ; case WLAN_HT_SMPS_CONTROL_DYNAMIC : sta -> known_smps_mode = IEEE80211_SMPS_DYNAMIC ; break ; default : WARN_ON ( 1 ) ; } } sta_dbg ( sdata , ""Allocated<S2SV_blank>STA<S2SV_blank>%pM\\n"" , sta -> sta . addr ) ; return sta ; free : if ( sta -> tx_lat ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) kfree ( sta -> tx_lat [ i ] . bins ) ; kfree ( sta -> tx_lat ) ; } kfree ( sta ) ; return NULL ; }
","<S2SV_ModStart> sta -> lock ) ; spin_lock_init ( & sta -> ps_lock
",torvalds@linux/1d147bfa64293b2723c4fec50922168658e613ba,CVE-2014-2706,https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba,2014-04-14T23:55Z,<S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug>
878,CWE-20,"static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ; if ( len < sizeof ( * prep ) ) { return ( - 1 ) ; } n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; <S2SV_StartBug> while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) { <S2SV_EndBug> const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( struct id_off * ) ( ps + 1 ) ; <S2SV_StartBug> for ( ie = io + ps -> nid ; io < ie && ! ND_TTEST ( * io ) ; ++ io ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( struct pgstate * ) io ; } return ( ( u_char * ) ps <= ep ? 0 : - 1 ) ; }
","<S2SV_ModStart> >= 0 && <S2SV_ModEnd> ND_TTEST ( * <S2SV_ModStart> < ie && <S2SV_ModEnd> ND_TTEST ( *
",the-tcpdump-group@tcpdump/3ed82f4ed0095768529afc22b923c8f7171fff70,CVE-2015-3138,https://github.com/the-tcpdump-group/tcpdump/commit/3ed82f4ed0095768529afc22b923c8f7171fff70,2017-09-28T01:29Z,<S2SV_StartBug> while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( ie = io + ps -> nid ; io < ie && ! ND_TTEST ( * io ) ; ++ io ) { <S2SV_EndBug>
3471,CWE-416,"static int updateDevice ( const struct header * headers , time_t t ) { struct device * * pp = & devlist ; struct device * p = * pp ; while ( p ) { if ( p -> headers [ HEADER_NT ] . l == headers [ HEADER_NT ] . l && ( 0 == memcmp ( p -> headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . l ) ) && p -> headers [ HEADER_USN ] . l == headers [ HEADER_USN ] . l && ( 0 == memcmp ( p -> headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . l ) ) ) { syslog ( LOG_DEBUG , ""device<S2SV_blank>updated<S2SV_blank>:<S2SV_blank>%.*s"" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; p -> t = t ; if ( headers [ HEADER_LOCATION ] . l > p -> headers [ HEADER_LOCATION ] . l ) { struct device * tmp ; tmp = realloc ( p , sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! tmp ) { syslog ( LOG_ERR , ""updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; <S2SV_StartBug> free ( p ) ; <S2SV_EndBug> return 0 ; } p = tmp ; * pp = p ; } memcpy ( p -> data + p -> headers [ 0 ] . l + p -> headers [ 1 ] . l , headers [ 2 ] . p , headers [ 2 ] . l ) ; return 0 ; } pp = & p -> next ; p = * pp ; } syslog ( LOG_INFO , ""new<S2SV_blank>device<S2SV_blank>discovered<S2SV_blank>:<S2SV_blank>%.*s"" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; { char * pc ; int i ; p = malloc ( sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! p ) { syslog ( LOG_ERR , ""updateDevice():<S2SV_blank>cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; return - 1 ; } p -> next = devlist ; p -> t = t ; pc = p -> data ; for ( i = 0 ; i < 3 ; i ++ ) { p -> headers [ i ] . p = pc ; p -> headers [ i ] . l = headers [ i ] . l ; memcpy ( pc , headers [ i ] . p , headers [ i ] . l ) ; pc += headers [ i ] . l ; } devlist = p ; sendNotifications ( NOTIF_NEW , p , NULL ) ; } return 1 ; }
","<S2SV_ModStart> ""updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; * pp = p -> next ;
",miniupnp@miniupnp/cd506a67e174a45c6a202eff182a712955ed6d6f,CVE-2019-12106,https://github.com/miniupnp/miniupnp/commit/cd506a67e174a45c6a202eff182a712955ed6d6f,2019-05-15T23:29Z,<S2SV_StartBug> free ( p ) ; <S2SV_EndBug>
1181,CWE-125,"void skb_complete_tx_timestamp ( struct sk_buff * skb , struct skb_shared_hwtstamps * hwtstamps ) { struct sock * sk = skb -> sk ; if ( ! skb_may_tx_timestamp ( sk , false ) ) return ; if ( likely ( atomic_inc_not_zero ( & sk -> sk_refcnt ) ) ) { * skb_hwtstamps ( skb ) = * hwtstamps ; <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug> sock_put ( sk ) ; } }
","<S2SV_ModStart> sk , SCM_TSTAMP_SND , false
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,"<S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug>"
1753,CWE-119,"<S2SV_StartBug> static void write_mv_update ( const vp9_tree_index * tree , <S2SV_EndBug> <S2SV_StartBug> vp9_prob probs [ ] , <S2SV_EndBug> const unsigned int counts [ ] , <S2SV_StartBug> int n , vp9_writer * w ) { <S2SV_EndBug> int i ; unsigned int branch_ct [ 32 ] [ 2 ] ; assert ( n <= 32 ) ; vp9_tree_probs_from_distribution ( tree , branch_ct , counts ) ; for ( i = 0 ; i < n - 1 ; ++ i ) update_mv ( w , branch_ct [ i ] , & probs [ i ] , MV_UPDATE_PROB ) ; }
","<S2SV_ModStart> write_mv_update ( const vpx_tree_index <S2SV_ModEnd> * tree , <S2SV_ModStart> * tree , vpx_prob <S2SV_ModEnd> probs [ ] <S2SV_ModStart> int n , vpx_writer <S2SV_ModEnd> * w )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void write_mv_update ( const vp9_tree_index * tree , <S2SV_EndBug> <S2SV_StartBug> vp9_prob probs [ ] , <S2SV_EndBug> <S2SV_StartBug> int n , vp9_writer * w ) { <S2SV_EndBug>"
4530,CWE-125,"PyObject * ast2obj_mod ( void * _o ) { mod_ty o = ( mod_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case Module_kind : result = PyType_GenericNew ( Module_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Module . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Module . type_ignores , ast2obj_type_ignore ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_ignores , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Interactive_kind : result = PyType_GenericNew ( Interactive_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Interactive . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expression_kind : result = PyType_GenericNew ( Expression_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expression . body ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case FunctionType_kind : result = PyType_GenericNew ( FunctionType_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . FunctionType . argtypes , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_argtypes , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionType . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Suite_kind : result = PyType_GenericNew ( Suite_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Suite . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug>
686,CWE-189,"Datum hstore_from_arrays ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; Datum * key_datums ; bool * key_nulls ; int key_count ; Datum * value_datums ; bool * value_nulls ; int value_count ; ArrayType * key_array ; ArrayType * value_array ; int i ; if ( PG_ARGISNULL ( 0 ) ) PG_RETURN_NULL ( ) ; key_array = PG_GETARG_ARRAYTYPE_P ( 0 ) ; Assert ( ARR_ELEMTYPE ( key_array ) == TEXTOID ) ; if ( ARR_NDIM ( key_array ) > 1 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts"" ) ) ) ; deconstruct_array ( key_array , TEXTOID , - 1 , false , 'i' , <S2SV_StartBug> & key_datums , & key_nulls , & key_count ) ; <S2SV_EndBug> if ( PG_ARGISNULL ( 1 ) ) { value_array = NULL ; value_count = key_count ; value_datums = NULL ; value_nulls = NULL ; } else { value_array = PG_GETARG_ARRAYTYPE_P ( 1 ) ; Assert ( ARR_ELEMTYPE ( value_array ) == TEXTOID ) ; if ( ARR_NDIM ( value_array ) > 1 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts"" ) ) ) ; if ( ( ARR_NDIM ( key_array ) > 0 || ARR_NDIM ( value_array ) > 0 ) && ( ARR_NDIM ( key_array ) != ARR_NDIM ( value_array ) || ARR_DIMS ( key_array ) [ 0 ] != ARR_DIMS ( value_array ) [ 0 ] || ARR_LBOUND ( key_array ) [ 0 ] != ARR_LBOUND ( value_array ) [ 0 ] ) ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""arrays<S2SV_blank>must<S2SV_blank>have<S2SV_blank>same<S2SV_blank>bounds"" ) ) ) ; deconstruct_array ( value_array , TEXTOID , - 1 , false , 'i' , & value_datums , & value_nulls , & value_count ) ; Assert ( key_count == value_count ) ; } pairs = palloc ( key_count * sizeof ( Pairs ) ) ; for ( i = 0 ; i < key_count ; ++ i ) { if ( key_nulls [ i ] ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( ""null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key"" ) ) ) ; if ( ! value_nulls || value_nulls [ i ] ) { pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; pairs [ i ] . val = NULL ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; pairs [ i ] . vallen = 4 ; pairs [ i ] . isnull = true ; pairs [ i ] . needfree = false ; } else { pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; pairs [ i ] . val = VARDATA_ANY ( value_datums [ i ] ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; pairs [ i ] . vallen = hstoreCheckValLen ( VARSIZE_ANY_EXHDR ( value_datums [ i ] ) ) ; pairs [ i ] . isnull = false ; pairs [ i ] . needfree = false ; } } key_count = hstoreUniquePairs ( pairs , key_count , & buflen ) ; out = hstorePairs ( pairs , key_count , buflen ) ; PG_RETURN_POINTER ( out ) ; }
","<S2SV_ModStart> , & key_count ) ; if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) )
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,"<S2SV_StartBug> & key_datums , & key_nulls , & key_count ) ; <S2SV_EndBug>"
1211,CWE-190,"static int vdbePmaReadBlob ( PmaReader * p , int nByte , u8 * * ppOut ) { int iBuf ; int nAvail ; if ( p -> aMap ) { * ppOut = & p -> aMap [ p -> iReadOff ] ; p -> iReadOff += nByte ; return SQLITE_OK ; } assert ( p -> aBuffer ) ; iBuf = p -> iReadOff % p -> nBuffer ; if ( iBuf == 0 ) { int nRead ; int rc ; if ( ( p -> iEof - p -> iReadOff ) > ( i64 ) p -> nBuffer ) { nRead = p -> nBuffer ; } else { nRead = ( int ) ( p -> iEof - p -> iReadOff ) ; } assert ( nRead > 0 ) ; rc = sqlite3OsRead ( p -> pFd , p -> aBuffer , nRead , p -> iReadOff ) ; assert ( rc != SQLITE_IOERR_SHORT_READ ) ; if ( rc != SQLITE_OK ) return rc ; } nAvail = p -> nBuffer - iBuf ; if ( nByte <= nAvail ) { * ppOut = & p -> aBuffer [ iBuf ] ; p -> iReadOff += nByte ; } else { int nRem ; if ( p -> nAlloc < nByte ) { u8 * aNew ; <S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug> while ( nByte > nNew ) nNew = nNew * 2 ; aNew = sqlite3Realloc ( p -> aAlloc , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; p -> nAlloc = nNew ; p -> aAlloc = aNew ; } memcpy ( p -> aAlloc , & p -> aBuffer [ iBuf ] , nAvail ) ; p -> iReadOff += nAvail ; nRem = nByte - nAvail ; while ( nRem > 0 ) { int rc ; int nCopy ; u8 * aNext ; nCopy = nRem ; if ( nRem > p -> nBuffer ) nCopy = p -> nBuffer ; rc = vdbePmaReadBlob ( p , nCopy , & aNext ) ; if ( rc != SQLITE_OK ) return rc ; assert ( aNext != p -> aAlloc ) ; memcpy ( & p -> aAlloc [ nByte - nRem ] , aNext , nCopy ) ; nRem -= nCopy ; } * ppOut = p -> aAlloc ; } return SQLITE_OK ; }
","<S2SV_ModStart> * aNew ; sqlite3_int64 <S2SV_ModEnd> nNew = MAX <S2SV_ModStart> ( 128 , 2 * ( sqlite3_int64 ) <S2SV_ModStart> p -> nAlloc <S2SV_ModEnd> ) ; while
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z,"<S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug>"
7021,CWE-787,"static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { EXRContext * s = avctx -> priv_data ; ThreadFrame frame = { . f = data } ; AVFrame * picture = data ; uint8_t * ptr ; int i , y , ret , ymax ; int planes ; int out_line_size ; int nb_blocks ; uint64_t start_offset_table ; uint64_t start_next_scanline ; PutByteContext offset_table_writer ; bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ; if ( ( ret = decode_header ( s , picture ) ) < 0 ) return ret ; switch ( s -> pixel_type ) { case EXR_FLOAT : case EXR_HALF : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_GBRAPF32 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GBRAPF32 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_GBRPF32 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GRAYF32 ; } } break ; case EXR_UINT : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_RGBA64 ; } else { avctx -> pix_fmt = AV_PIX_FMT_YA16 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_RGB48 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GRAY16 ; } } break ; default : av_log ( avctx , AV_LOG_ERROR , ""Missing<S2SV_blank>channel<S2SV_blank>list.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> apply_trc_type != AVCOL_TRC_UNSPECIFIED ) avctx -> color_trc = s -> apply_trc_type ; switch ( s -> compression ) { case EXR_RAW : case EXR_RLE : case EXR_ZIP1 : s -> scan_lines_per_block = 1 ; break ; case EXR_PXR24 : case EXR_ZIP16 : s -> scan_lines_per_block = 16 ; break ; case EXR_PIZ : case EXR_B44 : case EXR_B44A : s -> scan_lines_per_block = 32 ; break ; default : avpriv_report_missing_feature ( avctx , ""Compression<S2SV_blank>%d"" , s -> compression ) ; return AVERROR_PATCHWELCOME ; } if ( s -> xmin > s -> xmax || s -> ymin > s -> ymax || s -> ydelta == 0xFFFFFFFF || s -> xdelta == 0xFFFFFFFF ) { av_log ( avctx , AV_LOG_ERROR , ""Wrong<S2SV_blank>or<S2SV_blank>missing<S2SV_blank>size<S2SV_blank>information.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = ff_set_dimensions ( avctx , s -> w , s -> h ) ) < 0 ) return ret ; s -> desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; if ( ! s -> desc ) return AVERROR_INVALIDDATA ; if ( s -> desc -> flags & AV_PIX_FMT_FLAG_FLOAT ) { planes = s -> desc -> nb_components ; out_line_size = avctx -> width * 4 ; } else { planes = 1 ; out_line_size = avctx -> width * 2 * s -> desc -> nb_components ; } if ( s -> is_tile ) { nb_blocks = ( ( s -> xdelta + s -> tile_attr . xSize - 1 ) / s -> tile_attr . xSize ) * ( ( s -> ydelta + s -> tile_attr . ySize - 1 ) / s -> tile_attr . ySize ) ; } else { nb_blocks = ( s -> ydelta + s -> scan_lines_per_block - 1 ) / s -> scan_lines_per_block ; } if ( ( ret = ff_thread_get_buffer ( avctx , & frame , 0 ) ) < 0 ) return ret ; if ( bytestream2_get_bytes_left ( & s -> gb ) / 8 < nb_blocks ) return AVERROR_INVALIDDATA ; if ( ! s -> is_tile && bytestream2_peek_le64 ( & s -> gb ) == 0 ) { av_log ( s -> avctx , AV_LOG_DEBUG , ""recreating<S2SV_blank>invalid<S2SV_blank>scanline<S2SV_blank>offset<S2SV_blank>table\\n"" ) ; start_offset_table = bytestream2_tell ( & s -> gb ) ; start_next_scanline = start_offset_table + nb_blocks * 8 ; bytestream2_init_writer ( & offset_table_writer , & avpkt -> data [ start_offset_table ] , nb_blocks * 8 ) ; for ( y = 0 ; y < nb_blocks ; y ++ ) { bytestream2_put_le64 ( & offset_table_writer , start_next_scanline ) ; bytestream2_seek ( & s -> gb , start_next_scanline + 4 , SEEK_SET ) ; start_next_scanline += ( bytestream2_get_le32 ( & s -> gb ) + 8 ) ; } bytestream2_seek ( & s -> gb , start_offset_table , SEEK_SET ) ; } s -> buf = avpkt -> data ; s -> buf_size = avpkt -> size ; for ( i = 0 ; i < planes ; i ++ ) { ptr = picture -> data [ i ] ; for ( y = 0 ; y < FFMIN ( s -> ymin , s -> h ) ; y ++ ) { memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } s -> picture = picture ; avctx -> execute2 ( avctx , decode_block , s -> thread_data , NULL , nb_blocks ) ; ymax = FFMAX ( 0 , s -> ymax + 1 ) ; <S2SV_StartBug> for ( i = 0 ; i < planes ; i ++ ) { <S2SV_EndBug> ptr = picture -> data [ i ] + ( ymax * picture -> linesize [ i ] ) ; for ( y = ymax ; y < avctx -> height ; y ++ ) { memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } picture -> pict_type = AV_PICTURE_TYPE_I ; * got_frame = 1 ; return avpkt -> size ; }
","<S2SV_ModStart> 1 ) ; if ( ymax < avctx -> height )
",FFmpeg@FFmpeg/b0a8b40294ea212c1938348ff112ef1b9bf16bb3,CVE-2020-35965,https://github.com/FFmpeg/FFmpeg/commit/b0a8b40294ea212c1938348ff112ef1b9bf16bb3,2021-01-04T02:15Z,<S2SV_StartBug> for ( i = 0 ; i < planes ; i ++ ) { <S2SV_EndBug>
2952,CWE-362,"static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) { int r = EMULATE_DONE ; ++ vcpu -> stat . insn_emulation_fail ; trace_kvm_emulate_insn_failed ( vcpu ) ; <S2SV_StartBug> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_EndBug> vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_EMULATION ; vcpu -> run -> internal . ndata = 0 ; r = EMULATE_FAIL ; } kvm_queue_exception ( vcpu , UD_VECTOR ) ; return r ; }
","<S2SV_ModStart> ( vcpu ) && kvm_x86_ops -> get_cpl ( vcpu ) == 0
",torvalds@linux/a2b9e6c1a35afcc0973acb72e591c714e78885ff,CVE-2014-7842,https://github.com/torvalds/linux/commit/a2b9e6c1a35afcc0973acb72e591c714e78885ff,2014-11-30T01:59Z,<S2SV_StartBug> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_EndBug>
4873,CWE-362,"static int <S2SV_StartBug> mptctl_getiocinfo ( unsigned long arg , unsigned int data_size ) <S2SV_EndBug> { struct mpt_ioctl_iocinfo __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_iocinfo * karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> struct pci_dev * pdev ; <S2SV_EndBug> int iocnum ; unsigned int port ; int cim_rev ; struct scsi_device * sdev ; VirtDevice * vdevice ; if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev0 ) ) cim_rev = 0 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev1 ) ) cim_rev = 1 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo ) ) cim_rev = 2 ; else if ( data_size == ( sizeof ( struct mpt_ioctl_iocinfo_rev0 ) + 12 ) ) cim_rev = 0 ; else return - EFAULT ; karg = memdup_user ( uarg , data_size ) ; if ( IS_ERR ( karg ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mpt_ioctl_iocinfo()<S2SV_blank>-<S2SV_blank>memdup_user<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>[%ld]\\n"" , __FILE__ , __LINE__ , PTR_ERR ( karg ) ) ; <S2SV_StartBug> return PTR_ERR ( karg ) ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg -> hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_getiocinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; kfree ( karg ) ; return - ENODEV ; } if ( karg -> hdr . maxDataSize != data_size ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_getiocinfo<S2SV_blank>-<S2SV_blank>"" ""Structure<S2SV_blank>size<S2SV_blank>mismatch.<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>completed.\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; kfree ( karg ) ; return - EFAULT ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_getiocinfo<S2SV_blank>called.\\n"" , ioc -> name ) ) ; if ( ioc -> bus_type == SAS ) karg -> adapterType = MPT_IOCTL_INTERFACE_SAS ; else if ( ioc -> bus_type == FC ) karg -> adapterType = MPT_IOCTL_INTERFACE_FC ; else karg -> adapterType = MPT_IOCTL_INTERFACE_SCSI ; if ( karg -> hdr . port > 1 ) { kfree ( karg ) ; return - EINVAL ; } port = karg -> hdr . port ; karg -> port = port ; pdev = ( struct pci_dev * ) ioc -> pcidev ; karg -> pciId = pdev -> device ; karg -> hwRev = pdev -> revision ; karg -> subSystemDevice = pdev -> subsystem_device ; karg -> subSystemVendor = pdev -> subsystem_vendor ; if ( cim_rev == 1 ) { karg -> pciInfo . u . bits . busNumber = pdev -> bus -> number ; karg -> pciInfo . u . bits . deviceNumber = PCI_SLOT ( pdev -> devfn ) ; karg -> pciInfo . u . bits . functionNumber = PCI_FUNC ( pdev -> devfn ) ; } else if ( cim_rev == 2 ) { karg -> pciInfo . u . bits . busNumber = pdev -> bus -> number ; karg -> pciInfo . u . bits . deviceNumber = PCI_SLOT ( pdev -> devfn ) ; karg -> pciInfo . u . bits . functionNumber = PCI_FUNC ( pdev -> devfn ) ; karg -> pciInfo . segmentID = pci_domain_nr ( pdev -> bus ) ; } karg -> numDevices = 0 ; if ( ioc -> sh ) { shost_for_each_device ( sdev , ioc -> sh ) { vdevice = sdev -> hostdata ; if ( vdevice == NULL || vdevice -> vtarget == NULL ) continue ; if ( vdevice -> vtarget -> tflags & MPT_TARGET_FLAGS_RAID_COMPONENT ) continue ; karg -> numDevices ++ ; } } karg -> FWVersion = ioc -> facts . FWVersion . Word ; karg -> BIOSVersion = ioc -> biosVersion ; strncpy ( karg -> driverVersion , MPT_LINUX_PACKAGE_NAME , MPT_IOCTL_VERSION_LENGTH ) ; karg -> driverVersion [ MPT_IOCTL_VERSION_LENGTH - 1 ] = '\\0' ; karg -> busChangeEvent = 0 ; karg -> hostId = ioc -> pfacts [ port ] . PortSCSIID ; karg -> rsvd [ 0 ] = karg -> rsvd [ 1 ] = 0 ; if ( copy_to_user ( ( char __user * ) arg , karg , data_size ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_getiocinfo<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_iocinfo<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; kfree ( karg ) ; return - EFAULT ; } kfree ( karg ) ; return 0 ; }
","<S2SV_ModStart> int mptctl_getiocinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> * karg ; <S2SV_ModEnd> struct pci_dev * <S2SV_ModStart> pci_dev * pdev <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> ( karg ) <S2SV_ModEnd> ; } if
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,"<S2SV_StartBug> mptctl_getiocinfo ( unsigned long arg , unsigned int data_size ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> struct pci_dev * pdev ; <S2SV_EndBug> <S2SV_StartBug> return PTR_ERR ( karg ) ; <S2SV_EndBug>"
1912,CWE-119,"<S2SV_StartBug> void vp9_tree_probs_from_distribution ( vp9_tree tree , <S2SV_EndBug> unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }
","<S2SV_ModStart> void vp9_tree_probs_from_distribution ( vpx_tree <S2SV_ModEnd> tree , unsigned
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> void vp9_tree_probs_from_distribution ( vp9_tree tree , <S2SV_EndBug>"
2320,CWE-787,"int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( ""can\'t<S2SV_blank>handle<S2SV_blank>.WAV<S2SV_blank>files<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>4<S2SV_blank>GB<S2SV_blank>(non-standard)!"" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , ""WAVE"" , 4 ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , ""ds64"" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || bcount != sizeof ( DS64Chunk ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( ""DS64:<S2SV_blank>riffSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>dataSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>sampleCount<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>table_length<S2SV_blank>=<S2SV_blank>%d"" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , ""fmt<S2SV_blank>"" , 4 ) ) { int supported = TRUE , format ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.WAV<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>WAV<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else if ( config -> float_norm_exp ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point<S2SV_blank>(Audition<S2SV_blank>%d:%d<S2SV_blank>float<S2SV_blank>type<S2SV_blank>1)"" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , ""data"" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
",dbry@WavPack/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,CVE-2018-10540,https://github.com/dbry/WavPack/commit/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,2018-04-29T15:29Z,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug>
1948,CWE-119,"static vpx_codec_err_t validate_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg , const struct vp9_extracfg * extra_cfg ) { RANGE_CHECK ( cfg , g_w , 1 , 65535 ) ; RANGE_CHECK ( cfg , g_h , 1 , 65535 ) ; RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ; RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ; RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ; RANGE_CHECK_BOOL ( extra_cfg , lossless ) ; RANGE_CHECK ( extra_cfg , aq_mode , 0 , AQ_MODE_COUNT - 1 ) ; RANGE_CHECK ( extra_cfg , frame_periodic_boost , 0 , 1 ) ; RANGE_CHECK_HI ( cfg , g_threads , 64 ) ; RANGE_CHECK_HI ( cfg , g_lag_in_frames , MAX_LAG_BUFFERS ) ; RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ; <S2SV_StartBug> RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; <S2SV_EndBug> RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ; RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ; RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ; RANGE_CHECK_HI ( cfg , rc_dropframe_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_up_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_down_thresh , 100 ) ; RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ; <S2SV_StartBug> RANGE_CHECK ( cfg , ss_number_layers , 1 , VPX_SS_MAX_LAYERS ) ; <S2SV_EndBug> RANGE_CHECK ( cfg , ts_number_layers , 1 , VPX_TS_MAX_LAYERS ) ; <S2SV_StartBug> if ( cfg -> ts_number_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 1 ; i < cfg -> ts_number_layers ; ++ i ) <S2SV_EndBug> if ( cfg -> ts_target_bitrate [ i ] < cfg -> ts_target_bitrate [ i - 1 ] ) <S2SV_StartBug> ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing"" ) ; <S2SV_EndBug> RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ; <S2SV_StartBug> for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; -- i ) <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; <S2SV_EndBug> } if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( ""kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>"" ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ; <S2SV_StartBug> RANGE_CHECK_BOOL ( extra_cfg , enable_auto_alt_ref ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( extra_cfg , cpu_used , - 16 , 16 ) ; <S2SV_EndBug> RANGE_CHECK_HI ( extra_cfg , noise_sensitivity , 6 ) ; RANGE_CHECK ( extra_cfg , tile_columns , 0 , 6 ) ; RANGE_CHECK ( extra_cfg , tile_rows , 0 , 2 ) ; RANGE_CHECK_HI ( extra_cfg , sharpness , 7 ) ; RANGE_CHECK ( extra_cfg , arnr_max_frames , 0 , 15 ) ; RANGE_CHECK_HI ( extra_cfg , arnr_strength , 6 ) ; <S2SV_StartBug> RANGE_CHECK ( extra_cfg , arnr_type , 1 , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( extra_cfg , cq_level , 0 , 63 ) ; <S2SV_EndBug> if ( extra_cfg -> tuning == VP8_TUNE_SSIM ) ERROR ( ""Option<S2SV_blank>--tune=ssim<S2SV_blank>is<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>VP9."" ) ; if ( cfg -> g_pass == VPX_RC_LAST_PASS ) { <S2SV_StartBug> size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; <S2SV_EndBug> <S2SV_StartBug> int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; <S2SV_EndBug> const FIRSTPASS_STATS * stats ; if ( cfg -> rc_twopass_stats_in . buf == NULL ) ERROR ( ""rc_twopass_stats_in.buf<S2SV_blank>not<S2SV_blank>set."" ) ; if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) ERROR ( ""rc_twopass_stats_in.sz<S2SV_blank>indicates<S2SV_blank>truncated<S2SV_blank>packet."" ) ; <S2SV_StartBug> if ( cfg -> ss_number_layers > 1 ) { <S2SV_EndBug> int i ; unsigned int n_packets_per_layer [ VPX_SS_MAX_LAYERS ] = { 0 } ; stats = cfg -> rc_twopass_stats_in . buf ; for ( i = 0 ; i < n_packets ; ++ i ) { const int layer_id = ( int ) stats [ i ] . spatial_layer_id ; if ( layer_id >= 0 && layer_id < ( int ) cfg -> ss_number_layers ) { ++ n_packets_per_layer [ layer_id ] ; } } for ( i = 0 ; i < ( int ) cfg -> ss_number_layers ; ++ i ) { unsigned int layer_id ; if ( n_packets_per_layer [ i ] < 2 ) { ERROR ( ""rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets<S2SV_blank>for<S2SV_blank>each<S2SV_blank>"" ""layer."" ) ; } stats = ( const FIRSTPASS_STATS * ) cfg -> rc_twopass_stats_in . buf + n_packets - cfg -> ss_number_layers + i ; layer_id = ( int ) stats -> spatial_layer_id ; if ( layer_id >= cfg -> ss_number_layers <S2SV_StartBug> || ( int ) ( stats -> count + 0.5 ) != n_packets_per_layer [ layer_id ] - 1 ) <S2SV_EndBug> ERROR ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ; } } else { if ( cfg -> rc_twopass_stats_in . sz < 2 * packet_sz ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets."" ) ; stats = ( const FIRSTPASS_STATS * ) cfg -> rc_twopass_stats_in . buf + n_packets - 1 ; if ( ( int ) ( stats -> count + 0.5 ) != n_packets - 1 ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ; } } <S2SV_StartBug> if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && <S2SV_EndBug> <S2SV_StartBug> extra_cfg -> bit_depth > BITS_8 ) <S2SV_EndBug> ERROR ( ""High<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ; <S2SV_StartBug> if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && <S2SV_EndBug> <S2SV_StartBug> extra_cfg -> bit_depth == BITS_8 ) <S2SV_EndBug> ERROR ( ""Bit-depth<S2SV_blank>8<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>><S2SV_blank>1"" ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> , rc_undershoot_pct , 100 <S2SV_ModEnd> ) ; RANGE_CHECK_HI <S2SV_ModStart> , rc_overshoot_pct , 100 <S2SV_ModEnd> ) ; RANGE_CHECK_HI <S2SV_ModStart> ; RANGE_CHECK ( extra_cfg , min_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; RANGE_CHECK ( extra_cfg , max_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; if ( extra_cfg -> max_gf_interval > 0 ) { RANGE_CHECK ( extra_cfg , max_gf_interval , 2 , ( MAX_LAG_BUFFERS - 1 ) ) ; } if ( extra_cfg -> min_gf_interval > 0 && extra_cfg -> max_gf_interval > 0 ) { RANGE_CHECK ( extra_cfg , max_gf_interval , extra_cfg -> min_gf_interval , ( MAX_LAG_BUFFERS - 1 ) ) ; } if ( cfg -> rc_resize_allowed == 1 ) { RANGE_CHECK ( cfg , rc_scaled_width , 0 , cfg -> g_w ) ; RANGE_CHECK ( cfg , rc_scaled_height , 0 , cfg -> g_h ) ; } RANGE_CHECK ( <S2SV_ModStart> ( cfg -> ss_number_layers * cfg -> ts_number_layers > VPX_MAX_LAYERS ) ERROR ( ""ss_number_layers<S2SV_blank>*<S2SV_blank>ts_number_layers<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ; if ( cfg -> ts_number_layers > <S2SV_ModEnd> 1 ) { <S2SV_ModStart> { unsigned int sl , tl <S2SV_ModEnd> ; for ( <S2SV_ModStart> ; for ( sl = 1 ; sl <S2SV_ModEnd> < cfg -> <S2SV_ModStart> < cfg -> ss_number_layers ; ++ sl ) { for ( tl = 1 ; tl < cfg -> <S2SV_ModStart> ts_number_layers ; ++ tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cfg -> ts_number_layers ) ; if ( cfg -> layer_target_bitrate [ layer ] < cfg -> layer_target_bitrate [ layer <S2SV_ModEnd> - 1 ] <S2SV_ModStart> ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing"" ) ; } } <S2SV_ModStart> ; for ( tl <S2SV_ModEnd> = cfg -> <S2SV_ModStart> - 2 ; tl <S2SV_ModEnd> > 0 ; <S2SV_ModStart> 0 ; -- tl <S2SV_ModEnd> ) if ( <S2SV_ModStart> -> ts_rate_decimator [ tl <S2SV_ModEnd> - 1 ] <S2SV_ModStart> -> ts_rate_decimator [ tl ] ) ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; } # if CONFIG_SPATIAL_SVC if ( ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) && cfg -> g_pass == VPX_RC_LAST_PASS ) { unsigned int i , alt_ref_sum = 0 ; for ( i = 0 ; i < cfg -> ss_number_layers ; ++ i ) { if ( cfg -> ss_enable_auto_alt_ref [ <S2SV_ModStart> i ] ) ++ alt_ref_sum ; } if ( alt_ref_sum > REF_FRAMES - cfg -> ss_number_layers ) ERROR ( ""Not<S2SV_blank>enough<S2SV_blank>ref<S2SV_blank>buffers<S2SV_blank>for<S2SV_blank>svc<S2SV_blank>alt<S2SV_blank>ref<S2SV_blank>frames"" ) ; if ( cfg -> ss_number_layers * cfg -> ts_number_layers > 3 && cfg -> g_error_resilient == 0 ) ERROR ( ""Multiple<S2SV_blank>frame<S2SV_blank>context<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>more<S2SV_blank>than<S2SV_blank>3<S2SV_blank>layers"" ) ; } # endif <S2SV_ModEnd> if ( cfg <S2SV_ModStart> ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ; RANGE_CHECK <S2SV_ModEnd> ( extra_cfg , <S2SV_ModStart> extra_cfg , enable_auto_alt_ref , 0 , 2 <S2SV_ModStart> cpu_used , - 8 , 8 <S2SV_ModEnd> ) ; RANGE_CHECK_HI <S2SV_ModStart> ( extra_cfg , <S2SV_ModEnd> cq_level , 0 <S2SV_ModStart> 0 , 63 ) ; RANGE_CHECK ( cfg , g_bit_depth , VPX_BITS_8 , VPX_BITS_12 ) ; RANGE_CHECK ( cfg , g_input_bit_depth , 8 , 12 ) ; RANGE_CHECK ( extra_cfg , content , VP9E_CONTENT_DEFAULT , VP9E_CONTENT_INVALID - 1 <S2SV_ModStart> VPX_RC_LAST_PASS ) { const <S2SV_ModStart> FIRSTPASS_STATS ) ; const <S2SV_ModStart> cfg -> ss_number_layers > 1 || cfg -> ts_number_layers <S2SV_ModStart> ss_number_layers || ( unsigned <S2SV_ModStart> ; } } # if ! CONFIG_VP9_HIGHBITDEPTH if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 ) { ERROR ( ""Profile<S2SV_blank>><S2SV_blank>1<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build<S2SV_blank>configuration"" ) ; } # endif <S2SV_ModStart> ) PROFILE_1 && cfg -> g_bit_depth > VPX_BITS_8 ) { ERROR ( ""Codec<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ; } <S2SV_ModEnd> if ( cfg <S2SV_ModStart> cfg -> g_profile <= <S2SV_ModEnd> ( unsigned int <S2SV_ModStart> ) PROFILE_1 && cfg -> g_input_bit_depth > 8 ) { ERROR ( ""Source<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ; } if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && cfg -> g_bit_depth == VPX_BITS_8 ) { ERROR ( ""Codec<S2SV_blank>bit-depth<S2SV_blank>8<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>><S2SV_blank>1"" ) ; } RANGE_CHECK ( extra_cfg , color_space , VPX_CS_UNKNOWN , VPX_CS_SRGB <S2SV_ModEnd> ) ; return
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( cfg , ss_number_layers , 1 , VPX_SS_MAX_LAYERS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ts_number_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 1 ; i < cfg -> ts_number_layers ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing"" ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; -- i ) <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK_BOOL ( extra_cfg , enable_auto_alt_ref ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( extra_cfg , cpu_used , - 16 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( extra_cfg , arnr_type , 1 , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( extra_cfg , cq_level , 0 , 63 ) ; <S2SV_EndBug> <S2SV_StartBug> size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; <S2SV_EndBug> <S2SV_StartBug> int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ss_number_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> || ( int ) ( stats -> count + 0.5 ) != n_packets_per_layer [ layer_id ] - 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && <S2SV_EndBug> <S2SV_StartBug> extra_cfg -> bit_depth > BITS_8 ) <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && <S2SV_EndBug> <S2SV_StartBug> extra_cfg -> bit_depth == BITS_8 ) <S2SV_EndBug>"
1597,CWE-119,"static size_t read_uncompressed_header ( VP9Decoder * pbi , <S2SV_StartBug> struct vp9_read_bit_buffer * rb ) { <S2SV_EndBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_StartBug> size_t sz ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> cm -> last_frame_type = cm -> frame_type ; <S2SV_StartBug> if ( vp9_rb_read_literal ( rb , 2 ) != VP9_FRAME_MARKER ) <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>marker"" ) ; <S2SV_StartBug> cm -> profile = read_profile ( rb ) ; <S2SV_EndBug> if ( cm -> profile >= MAX_PROFILES ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ; <S2SV_StartBug> cm -> show_existing_frame = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> if ( cm -> show_existing_frame ) { <S2SV_StartBug> const int frame_to_show = cm -> ref_frame_map [ vp9_rb_read_literal ( rb , 3 ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_bufs [ frame_to_show ] . ref_count < 1 ) <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Buffer<S2SV_blank>%d<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>decoded<S2SV_blank>frame"" , frame_to_show ) ; <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , & cm -> new_fb_idx , frame_to_show ) ; <S2SV_EndBug> pbi -> refresh_frame_flags = 0 ; cm -> lf . filter_level = 0 ; cm -> show_frame = 1 ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } <S2SV_StartBug> cm -> frame_type = ( FRAME_TYPE ) vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> show_frame = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> error_resilient_mode = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> if ( cm -> frame_type == KEY_FRAME ) { <S2SV_StartBug> check_sync_code ( cm , rb ) ; <S2SV_EndBug> if ( cm -> profile > PROFILE_1 ) cm -> bit_depth = vp9_rb_read_bit ( rb ) ? BITS_12 : BITS_10 ; cm -> color_space = ( COLOR_SPACE ) vp9_rb_read_literal ( rb , 3 ) ; if ( cm -> color_space != SRGB ) { vp9_rb_read_bit ( rb ) ; if ( cm -> profile >= PROFILE_1 ) { cm -> subsampling_x = vp9_rb_read_bit ( rb ) ; cm -> subsampling_y = vp9_rb_read_bit ( rb ) ; vp9_rb_read_bit ( rb ) ; } else { cm -> subsampling_y = cm -> subsampling_x = 1 ; } } else { if ( cm -> profile >= PROFILE_1 ) { cm -> subsampling_y = cm -> subsampling_x = 0 ; vp9_rb_read_bit ( rb ) ; } else { vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , <S2SV_StartBug> ""RGB<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>0"" ) ; <S2SV_EndBug> } } pbi -> refresh_frame_flags = ( 1 << REF_FRAMES ) - 1 ; for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { <S2SV_StartBug> cm -> frame_refs [ i ] . idx = cm -> new_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . buf = get_frame_new_buffer ( cm ) ; <S2SV_EndBug> } <S2SV_StartBug> setup_frame_size ( cm , rb ) ; <S2SV_EndBug> } else { <S2SV_StartBug> cm -> intra_only = cm -> show_frame ? 0 : vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> cm -> reset_frame_context = cm -> error_resilient_mode ? <S2SV_StartBug> 0 : vp9_rb_read_literal ( rb , 2 ) ; <S2SV_EndBug> if ( cm -> intra_only ) { <S2SV_StartBug> check_sync_code ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; <S2SV_EndBug> setup_frame_size ( cm , rb ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; <S2SV_EndBug> for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { <S2SV_StartBug> const int ref = vp9_rb_read_literal ( rb , REF_FRAMES_LOG2 ) ; <S2SV_EndBug> const int idx = cm -> ref_frame_map [ ref ] ; <S2SV_StartBug> cm -> frame_refs [ i ] . idx = idx ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . buf = & cm -> frame_bufs [ idx ] . buf ; <S2SV_EndBug> <S2SV_StartBug> cm -> ref_frame_sign_bias [ LAST_FRAME + i ] = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> } setup_frame_size_with_refs ( cm , rb ) ; <S2SV_StartBug> cm -> allow_high_precision_mv = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> cm -> interp_filter = read_interp_filter ( rb ) ; for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { RefBuffer * const ref_buf = & cm -> frame_refs [ i ] ; <S2SV_StartBug> vp9_setup_scale_factors_for_frame ( & ref_buf -> sf , <S2SV_EndBug> ref_buf -> buf -> y_crop_width , ref_buf -> buf -> y_crop_height , <S2SV_StartBug> cm -> width , cm -> height ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_is_scaled ( & ref_buf -> sf ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_extend_frame_borders ( ref_buf -> buf ) ; <S2SV_EndBug> } } } if ( ! cm -> error_resilient_mode ) { <S2SV_StartBug> cm -> coding_use_prev_mi = 1 ; <S2SV_EndBug> <S2SV_StartBug> cm -> refresh_frame_context = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> cm -> frame_parallel_decoding_mode = vp9_rb_read_bit ( rb ) ; } else { <S2SV_StartBug> cm -> coding_use_prev_mi = 0 ; <S2SV_EndBug> cm -> refresh_frame_context = 0 ; cm -> frame_parallel_decoding_mode = 1 ; <S2SV_StartBug> } <S2SV_EndBug> cm -> frame_context_idx = vp9_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ; if ( frame_is_intra_only ( cm ) || cm -> error_resilient_mode ) vp9_setup_past_independence ( cm ) ; setup_loopfilter ( & cm -> lf , rb ) ; setup_quantization ( cm , & pbi -> mb , rb ) ; setup_segmentation ( & cm -> seg , rb ) ; <S2SV_StartBug> setup_tile_info ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> sz = vp9_rb_read_literal ( rb , 16 ) ; <S2SV_EndBug> if ( sz == 0 ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return sz ; }
","<S2SV_ModStart> pbi , struct vpx_read_bit_buffer <S2SV_ModEnd> * rb ) <S2SV_ModStart> -> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = pool -> frame_bufs ; int i , mask , ref_index = 0 ; <S2SV_ModStart> size_t sz ; <S2SV_ModEnd> cm -> last_frame_type <S2SV_ModStart> -> frame_type ; cm -> last_intra_only = cm -> intra_only ; if ( vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> -> profile = vp9_read_profile ( rb ) ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModEnd> if ( cm <S2SV_ModStart> ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ; # else if ( cm -> profile >= PROFILE_2 ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ; # endif <S2SV_ModStart> -> show_existing_frame = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> ref_frame_map [ vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> ) ] ; lock_buffer_pool ( pool ) ; if ( frame_to_show < 0 || <S2SV_ModEnd> frame_bufs [ frame_to_show <S2SV_ModStart> < 1 ) { unlock_buffer_pool ( pool ) ; <S2SV_ModStart> frame_to_show ) ; } ref_cnt_fb ( <S2SV_ModEnd> frame_bufs , & <S2SV_ModStart> new_fb_idx , frame_to_show ) ; unlock_buffer_pool ( pool <S2SV_ModStart> = 1 ; if ( pbi -> frame_parallel_decode ) { for ( i = 0 ; i < REF_FRAMES ; ++ i ) cm -> next_ref_frame_map [ i ] = cm -> ref_frame_map [ i ] ; } <S2SV_ModStart> ( FRAME_TYPE ) vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> show_frame = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> error_resilient_mode = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> KEY_FRAME ) { if ( ! vp9_read_sync_code ( rb ) ) <S2SV_ModEnd> vpx_internal_error ( & <S2SV_ModStart> , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code"" ) ; read_bitdepth_colorspace_sampling ( cm , rb ) ; <S2SV_ModEnd> pbi -> refresh_frame_flags <S2SV_ModStart> . idx = INVALID_IDX <S2SV_ModEnd> ; cm -> <S2SV_ModStart> . buf = NULL <S2SV_ModEnd> ; } setup_frame_size <S2SV_ModStart> rb ) ; if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } <S2SV_ModStart> ? 0 : vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> ? 0 : vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> intra_only ) { if ( ! vp9_read_sync_code ( rb ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code"" ) ; if ( cm -> profile > PROFILE_0 ) { read_bitdepth_colorspace_sampling ( cm , rb ) ; } else { cm -> color_space = VPX_CS_BT_601 ; cm -> subsampling_y = cm -> subsampling_x = 1 ; cm -> bit_depth = VPX_BITS_8 ; # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth = 0 ; # endif } <S2SV_ModEnd> pbi -> refresh_frame_flags <S2SV_ModStart> -> refresh_frame_flags = vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> rb ) ; if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } } else if ( pbi -> need_resync != 1 ) <S2SV_ModEnd> { pbi -> <S2SV_ModStart> -> refresh_frame_flags = vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> int ref = vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> ref ] ; RefBuffer * const ref_frame = & <S2SV_ModStart> [ i ] ; ref_frame -> <S2SV_ModEnd> idx = idx <S2SV_ModStart> = idx ; ref_frame -> buf = & frame_bufs [ idx <S2SV_ModEnd> ] . buf <S2SV_ModStart> ] . buf <S2SV_ModEnd> ; cm -> <S2SV_ModStart> i ] = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> allow_high_precision_mv = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> i ] ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> cm -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame <S2SV_ModEnd> ( & ref_buf <S2SV_ModStart> ref_buf -> sf , <S2SV_ModEnd> ref_buf -> buf <S2SV_ModStart> ref_buf -> buf -> y_crop_width , ref_buf -> buf -> y_crop_height , cm -> width , cm -> height ) ; # endif } } } # if CONFIG_VP9_HIGHBITDEPTH get_frame_new_buffer ( cm ) -> bit_depth = cm -> bit_depth ; # endif get_frame_new_buffer ( cm ) -> color_space = cm -> color_space ; if ( pbi -> need_resync ) { vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Keyframe<S2SV_blank>/<S2SV_blank>intra-only<S2SV_blank>frame<S2SV_blank>required<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>decoder"" ""<S2SV_blank>state"" ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> { cm -> refresh_frame_context = vpx_rb_read_bit ( rb ) ; cm -> frame_parallel_decoding_mode = vpx_rb_read_bit ( rb ) ; } else { cm -> refresh_frame_context = 0 ; cm -> frame_parallel_decoding_mode <S2SV_ModEnd> = 1 ; <S2SV_ModStart> = 1 ; } cm -> frame_context_idx = vpx_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ; lock_buffer_pool ( pool ) ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { if ( mask & 1 ) { cm -> next_ref_frame_map [ ref_index ] = cm -> new_fb_idx ; ++ frame_bufs [ cm -> new_fb_idx ] . ref_count <S2SV_ModEnd> ; } else <S2SV_ModStart> { cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; } if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES ; ++ ref_index ) { cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf <S2SV_ModEnd> = 1 ; <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( frame_is_intra_only <S2SV_ModStart> rb ) ; setup_segmentation_dequant ( cm ) ; <S2SV_ModStart> ; sz = vpx_rb_read_literal <S2SV_ModEnd> ( rb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> struct vp9_read_bit_buffer * rb ) { <S2SV_EndBug> <S2SV_StartBug> size_t sz ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_rb_read_literal ( rb , 2 ) != VP9_FRAME_MARKER ) <S2SV_EndBug> <S2SV_StartBug> cm -> profile = read_profile ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> show_existing_frame = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> const int frame_to_show = cm -> ref_frame_map [ vp9_rb_read_literal ( rb , 3 ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_bufs [ frame_to_show ] . ref_count < 1 ) <S2SV_EndBug> <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , & cm -> new_fb_idx , frame_to_show ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_type = ( FRAME_TYPE ) vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> show_frame = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> error_resilient_mode = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> check_sync_code ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> ""RGB<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>0"" ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . idx = cm -> new_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . buf = get_frame_new_buffer ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> setup_frame_size ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> intra_only = cm -> show_frame ? 0 : vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> 0 : vp9_rb_read_literal ( rb , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> check_sync_code ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; <S2SV_EndBug> <S2SV_StartBug> const int ref = vp9_rb_read_literal ( rb , REF_FRAMES_LOG2 ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . idx = idx ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . buf = & cm -> frame_bufs [ idx ] . buf ; <S2SV_EndBug> <S2SV_StartBug> cm -> ref_frame_sign_bias [ LAST_FRAME + i ] = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> allow_high_precision_mv = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_scale_factors_for_frame ( & ref_buf -> sf , <S2SV_EndBug> <S2SV_StartBug> cm -> width , cm -> height ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_is_scaled ( & ref_buf -> sf ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_extend_frame_borders ( ref_buf -> buf ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> coding_use_prev_mi = 1 ; <S2SV_EndBug> <S2SV_StartBug> cm -> refresh_frame_context = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> coding_use_prev_mi = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> setup_tile_info ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> sz = vp9_rb_read_literal ( rb , 16 ) ; <S2SV_EndBug>"
1481,CWE-119,"static void rd_check_segment ( VP8_COMP * cpi , MACROBLOCK * x , BEST_SEG_INFO * bsi , unsigned int segmentation ) { int i ; int const * labels ; int br = 0 ; int bd = 0 ; B_PREDICTION_MODE this_mode ; int label_count ; int this_segment_rd = 0 ; int label_mv_thresh ; int rate = 0 ; int sbr = 0 ; int sbd = 0 ; int segmentyrate = 0 ; vp8_variance_fn_ptr_t * v_fn_ptr ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; ENTROPY_CONTEXT_PLANES t_above_b , t_left_b ; ENTROPY_CONTEXT * ta_b ; ENTROPY_CONTEXT * tl_b ; <S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; ta_b = ( ENTROPY_CONTEXT * ) & t_above_b ; tl_b = ( ENTROPY_CONTEXT * ) & t_left_b ; br = 0 ; bd = 0 ; v_fn_ptr = & cpi -> fn_ptr [ segmentation ] ; labels = vp8_mbsplits [ segmentation ] ; label_count = vp8_mbsplit_count [ segmentation ] ; label_mv_thresh = 1 * bsi -> mvthresh / label_count ; rate = vp8_cost_token ( vp8_mbsplit_tree , vp8_mbsplit_probs , vp8_mbsplit_encodings + segmentation ) ; rate += vp8_cost_mv_ref ( SPLITMV , bsi -> mdcounts ) ; this_segment_rd += RDCOST ( x -> rdmult , x -> rddiv , rate , 0 ) ; br += rate ; for ( i = 0 ; i < label_count ; i ++ ) { int_mv mode_mv [ B_MODE_COUNT ] ; int best_label_rd = INT_MAX ; B_PREDICTION_MODE mode_selected = ZERO4X4 ; int bestlabelyrate = 0 ; for ( this_mode = LEFT4X4 ; this_mode <= NEW4X4 ; this_mode ++ ) { int this_rd ; int distortion ; int labelyrate ; ENTROPY_CONTEXT_PLANES t_above_s , t_left_s ; ENTROPY_CONTEXT * ta_s ; ENTROPY_CONTEXT * tl_s ; <S2SV_StartBug> vpx_memcpy ( & t_above_s , & t_above , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left_s , & t_left , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta_s = ( ENTROPY_CONTEXT * ) & t_above_s ; tl_s = ( ENTROPY_CONTEXT * ) & t_left_s ; if ( this_mode == NEW4X4 ) { int sseshift ; int num00 ; int step_param = 0 ; int further_steps ; int n ; int thissme ; int bestsme = INT_MAX ; int_mv temp_mv ; BLOCK * c ; BLOCKD * e ; if ( best_label_rd < label_mv_thresh ) break ; if ( cpi -> compressor_speed ) { if ( segmentation == BLOCK_8X16 || segmentation == BLOCK_16X8 ) { bsi -> mvp . as_int = bsi -> sv_mvp [ i ] . as_int ; if ( i == 1 && segmentation == BLOCK_16X8 ) bsi -> mvp . as_int = bsi -> sv_mvp [ 2 ] . as_int ; step_param = bsi -> sv_istep [ i ] ; } if ( segmentation == BLOCK_4X4 && i > 0 ) { bsi -> mvp . as_int = x -> e_mbd . block [ i - 1 ] . bmi . mv . as_int ; if ( i == 4 || i == 8 || i == 12 ) bsi -> mvp . as_int = x -> e_mbd . block [ i - 4 ] . bmi . mv . as_int ; step_param = 2 ; } } further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; { int sadpb = x -> sadperbit4 ; int_mv mvp_full ; mvp_full . as_mv . row = bsi -> mvp . as_mv . row >> 3 ; mvp_full . as_mv . col = bsi -> mvp . as_mv . col >> 3 ; n = vp8_mbsplit_offset [ segmentation ] [ i ] ; c = & x -> block [ n ] ; e = & x -> e_mbd . block [ n ] ; { bestsme = cpi -> diamond_search_sad ( x , c , e , & mvp_full , & mode_mv [ NEW4X4 ] , step_param , sadpb , & num00 , v_fn_ptr , x -> mvcost , bsi -> ref_mv ) ; n = num00 ; num00 = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { thissme = cpi -> diamond_search_sad ( x , c , e , & mvp_full , & temp_mv , step_param + n , sadpb , & num00 , v_fn_ptr , x -> mvcost , bsi -> ref_mv ) ; if ( thissme < bestsme ) { bestsme = thissme ; mode_mv [ NEW4X4 ] . as_int = temp_mv . as_int ; } } } } sseshift = segmentation_to_sseshift [ segmentation ] ; if ( ( cpi -> compressor_speed == 0 ) && ( bestsme >> sseshift ) > 4000 ) { vp8_clamp_mv ( & mvp_full , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; thissme = cpi -> full_search_sad ( x , c , e , & mvp_full , sadpb , 16 , v_fn_ptr , x -> mvcost , bsi -> ref_mv ) ; if ( thissme < bestsme ) { bestsme = thissme ; mode_mv [ NEW4X4 ] . as_int = e -> bmi . mv . as_int ; } else { e -> bmi . mv . as_int = mode_mv [ NEW4X4 ] . as_int ; } } } if ( bestsme < INT_MAX ) { int disto ; unsigned int sse ; cpi -> find_fractional_mv_step ( x , c , e , & mode_mv [ NEW4X4 ] , bsi -> ref_mv , x -> errorperbit , v_fn_ptr , x -> mvcost , & disto , & sse ) ; } } rate = labels2mode ( x , labels , i , this_mode , & mode_mv [ this_mode ] , bsi -> ref_mv , x -> mvcost ) ; if ( ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) < x -> mv_row_min ) || ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) > x -> mv_row_max ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) < x -> mv_col_min ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) > x -> mv_col_max ) ) { continue ; } distortion = vp8_encode_inter_mb_segment ( x , labels , i ) / 4 ; labelyrate = rdcost_mbsegment_y ( x , labels , i , ta_s , tl_s ) ; rate += labelyrate ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( this_rd < best_label_rd ) { sbr = rate ; sbd = distortion ; bestlabelyrate = labelyrate ; mode_selected = this_mode ; best_label_rd = this_rd ; <S2SV_StartBug> vpx_memcpy ( ta_b , ta_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( tl_b , tl_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> } } <S2SV_StartBug> vpx_memcpy ( ta , ta_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( tl , tl_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> labels2mode ( x , labels , i , mode_selected , & mode_mv [ mode_selected ] , bsi -> ref_mv , x -> mvcost ) ; br += sbr ; bd += sbd ; segmentyrate += bestlabelyrate ; this_segment_rd += best_label_rd ; if ( this_segment_rd >= bsi -> segment_rd ) break ; } if ( this_segment_rd < bsi -> segment_rd ) { bsi -> r = br ; bsi -> d = bd ; bsi -> segment_yrate = segmentyrate ; bsi -> segment_rd = this_segment_rd ; bsi -> segment_num = segmentation ; for ( i = 0 ; i < 16 ; i ++ ) { bsi -> mvs [ i ] . as_mv = x -> partition_info -> bmi [ i ] . mv . as_mv ; bsi -> modes [ i ] = x -> partition_info -> bmi [ i ] . mode ; bsi -> eobs [ i ] = x -> e_mbd . eobs [ i ] ; } } }
","<S2SV_ModStart> * tl_b ; memcpy <S2SV_ModEnd> ( & t_above <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & t_left <S2SV_ModStart> * tl_s ; memcpy <S2SV_ModEnd> ( & t_above_s <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & t_left_s <S2SV_ModStart> = this_rd ; memcpy <S2SV_ModEnd> ( ta_b , <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( tl_b , <S2SV_ModStart> ; } } memcpy <S2SV_ModEnd> ( ta , <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( tl ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_above_s , & t_above , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left_s , & t_left , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ta_b , ta_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( tl_b , tl_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ta , ta_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( tl , tl_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug>"
5542,CWE-434,"static int zipfileUpdate ( sqlite3_vtab * pVtab , int nVal , sqlite3_value * * apVal , sqlite_int64 * pRowid ) { ZipfileTab * pTab = ( ZipfileTab * ) pVtab ; int rc = SQLITE_OK ; ZipfileEntry * pNew = 0 ; u32 mode = 0 ; u32 mTime = 0 ; i64 sz = 0 ; const char * zPath = 0 ; int nPath = 0 ; const u8 * pData = 0 ; int nData = 0 ; int iMethod = 0 ; u8 * pFree = 0 ; char * zFree = 0 ; ZipfileEntry * pOld = 0 ; ZipfileEntry * pOld2 = 0 ; int bUpdate = 0 ; int bIsDir = 0 ; u32 iCrc32 = 0 ; if ( pTab -> pWriteFd == 0 ) { rc = zipfileBegin ( pVtab ) ; if ( rc != SQLITE_OK ) return rc ; } if ( sqlite3_value_type ( apVal [ 0 ] ) != SQLITE_NULL ) { const char * zDelete = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nDelete = ( int ) strlen ( zDelete ) ; if ( nVal > 1 ) { const char * zUpdate = ( const char * ) sqlite3_value_text ( apVal [ 1 ] ) ; if ( zUpdate && zipfileComparePath ( zUpdate , zDelete , nDelete ) != 0 ) { bUpdate = 1 ; } } for ( pOld = pTab -> pFirstEntry ; 1 ; pOld = pOld -> pNext ) { if ( zipfileComparePath ( pOld -> cds . zFile , zDelete , nDelete ) == 0 ) { break ; } assert ( pOld -> pNext ) ; } } if ( nVal > 1 ) { if ( sqlite3_value_type ( apVal [ 5 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , ""sz<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL"" ) ; rc = SQLITE_CONSTRAINT ; } if ( sqlite3_value_type ( apVal [ 6 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , ""rawdata<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL"" ) ; rc = SQLITE_CONSTRAINT ; } if ( rc == SQLITE_OK ) { if ( sqlite3_value_type ( apVal [ 7 ] ) == SQLITE_NULL ) { bIsDir = 1 ; } else { const u8 * aIn = sqlite3_value_blob ( apVal [ 7 ] ) ; int nIn = sqlite3_value_bytes ( apVal [ 7 ] ) ; int bAuto = sqlite3_value_type ( apVal [ 8 ] ) == SQLITE_NULL ; iMethod = sqlite3_value_int ( apVal [ 8 ] ) ; sz = nIn ; pData = aIn ; nData = nIn ; if ( iMethod != 0 && iMethod != 8 ) { zipfileTableErr ( pTab , ""unknown<S2SV_blank>compression<S2SV_blank>method:<S2SV_blank>%d"" , iMethod ) ; rc = SQLITE_CONSTRAINT ; } else { if ( bAuto || iMethod ) { int nCmp ; rc = zipfileDeflate ( aIn , nIn , & pFree , & nCmp , & pTab -> base . zErrMsg ) ; if ( rc == SQLITE_OK ) { if ( iMethod || nCmp < nIn ) { iMethod = 8 ; pData = pFree ; nData = nCmp ; } } } iCrc32 = crc32 ( 0 , aIn , nIn ) ; } } } if ( rc == SQLITE_OK ) { rc = zipfileGetMode ( apVal [ 3 ] , bIsDir , & mode , & pTab -> base . zErrMsg ) ; } if ( rc == SQLITE_OK ) { zPath = ( const char * ) sqlite3_value_text ( apVal [ 2 ] ) ; <S2SV_StartBug> nPath = ( int ) strlen ( zPath ) ; <S2SV_EndBug> mTime = zipfileGetTime ( apVal [ 4 ] ) ; } if ( rc == SQLITE_OK && bIsDir ) { if ( zPath [ nPath - 1 ] != '/' ) { zFree = sqlite3_mprintf ( ""%s/"" , zPath ) ; if ( zFree == 0 ) { rc = SQLITE_NOMEM ; } zPath = ( const char * ) zFree ; nPath ++ ; } } if ( ( pOld == 0 || bUpdate ) && rc == SQLITE_OK ) { ZipfileEntry * p ; for ( p = pTab -> pFirstEntry ; p ; p = p -> pNext ) { if ( zipfileComparePath ( p -> cds . zFile , zPath , nPath ) == 0 ) { switch ( sqlite3_vtab_on_conflict ( pTab -> db ) ) { case SQLITE_IGNORE : { goto zipfile_update_done ; } case SQLITE_REPLACE : { pOld2 = p ; break ; } default : { zipfileTableErr ( pTab , ""duplicate<S2SV_blank>name:<S2SV_blank>\\""%s\\"""" , zPath ) ; rc = SQLITE_CONSTRAINT ; break ; } } break ; } } } if ( rc == SQLITE_OK ) { pNew = zipfileNewEntry ( zPath ) ; if ( pNew == 0 ) { rc = SQLITE_NOMEM ; } else { pNew -> cds . iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY ; pNew -> cds . iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED ; pNew -> cds . flags = ZIPFILE_NEWENTRY_FLAGS ; pNew -> cds . iCompression = ( u16 ) iMethod ; zipfileMtimeToDos ( & pNew -> cds , mTime ) ; pNew -> cds . crc32 = iCrc32 ; pNew -> cds . szCompressed = nData ; pNew -> cds . szUncompressed = ( u32 ) sz ; pNew -> cds . iExternalAttr = ( mode << 16 ) ; pNew -> cds . iOffset = ( u32 ) pTab -> szCurrent ; pNew -> cds . nFile = ( u16 ) nPath ; pNew -> mUnixTime = ( u32 ) mTime ; rc = zipfileAppendEntry ( pTab , pNew , pData , nData ) ; zipfileAddEntry ( pTab , pOld , pNew ) ; } } } if ( rc == SQLITE_OK && ( pOld || pOld2 ) ) { ZipfileCsr * pCsr ; for ( pCsr = pTab -> pCsrList ; pCsr ; pCsr = pCsr -> pCsrNext ) { if ( pCsr -> pCurrent && ( pCsr -> pCurrent == pOld || pCsr -> pCurrent == pOld2 ) ) { pCsr -> pCurrent = pCsr -> pCurrent -> pNext ; pCsr -> bNoop = 1 ; } } zipfileRemoveEntryFromList ( pTab , pOld ) ; zipfileRemoveEntryFromList ( pTab , pOld2 ) ; } zipfile_update_done : sqlite3_free ( pFree ) ; sqlite3_free ( zFree ) ; return rc ; }
","<S2SV_ModStart> ] ) ; if ( zPath == 0 ) zPath = """" ;
",sqlite@sqlite/54d501092d88c0cf89bec4279951f548fb0b8618,CVE-2019-19925,https://github.com/sqlite/sqlite/commit/54d501092d88c0cf89bec4279951f548fb0b8618,2019-12-24T17:15Z,<S2SV_StartBug> nPath = ( int ) strlen ( zPath ) ; <S2SV_EndBug>
8061,CWE-476,"int writefile ( const char * name , struct string * s ) { FILE * f ; int ret ; f = fopen ( name , ""w"" ) ; if ( ! f ) { warn ( ""open<S2SV_blank>%s:"" , name ) ; return - 1 ; } ret = 0 ; <S2SV_StartBug> if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) { <S2SV_EndBug> warn ( ""write<S2SV_blank>%s:"" , name ) ; ret = - 1 ; } fclose ( f ) ; return ret ; }
","<S2SV_ModStart> ; if ( s && ( <S2SV_ModStart> ) != 0 )
",michaelforney@samurai/e84b6d99c85043fa1ba54851ee500540ec206918,CVE-2021-30218,https://github.com/michaelforney/samurai/commit/e84b6d99c85043fa1ba54851ee500540ec206918,2021-04-29T15:15Z,"<S2SV_StartBug> if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) { <S2SV_EndBug>"
4991,CWE-200,"int parse_config ( char * filename , bridge_t * * bridges ) { dictionary * ubridge_config = NULL ; const char * value ; const char * bridge_name ; int i , nsec ; <S2SV_StartBug> if ( ( ubridge_config = iniparser_load ( filename ) ) == NULL ) { <S2SV_EndBug> return FALSE ; } nsec = iniparser_getnsec ( ubridge_config ) ; for ( i = 0 ; i < nsec ; i ++ ) { bridge_t * bridge ; nio_t * source_nio = NULL ; nio_t * destination_nio = NULL ; bridge_name = iniparser_getsecname ( ubridge_config , i ) ; printf ( ""Parsing<S2SV_blank>%s\\n"" , bridge_name ) ; if ( getstr ( ubridge_config , bridge_name , ""source_udp"" , & value ) ) source_nio = create_udp_tunnel ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_unix"" , & value ) ) source_nio = create_unix_socket ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_ethernet"" , & value ) ) source_nio = open_ethernet_device ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_tap"" , & value ) ) source_nio = open_tap_device ( value ) ; # ifdef LINUX_RAW else if ( getstr ( ubridge_config , bridge_name , ""source_linux_raw"" , & value ) ) source_nio = open_linux_raw ( value ) ; # endif # ifdef __APPLE__ else if ( getstr ( ubridge_config , bridge_name , ""source_fusion_vmnet"" , & value ) ) source_nio = open_fusion_vmnet ( value ) ; # endif else fprintf ( stderr , ""source<S2SV_blank>NIO<S2SV_blank>not<S2SV_blank>found\\n"" ) ; if ( getstr ( ubridge_config , bridge_name , ""destination_udp"" , & value ) ) destination_nio = create_udp_tunnel ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_unix"" , & value ) ) destination_nio = create_unix_socket ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_ethernet"" , & value ) ) destination_nio = open_ethernet_device ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_tap"" , & value ) ) destination_nio = open_tap_device ( value ) ; # ifdef LINUX_RAW else if ( getstr ( ubridge_config , bridge_name , ""destination_linux_raw"" , & value ) ) source_nio = open_linux_raw ( value ) ; # endif # ifdef __APPLE__ else if ( getstr ( ubridge_config , bridge_name , ""destination_fusion_vmnet"" , & value ) ) destination_nio = open_fusion_vmnet ( value ) ; # endif else fprintf ( stderr , ""destination<S2SV_blank>NIO<S2SV_blank>not<S2SV_blank>found\\n"" ) ; if ( source_nio && destination_nio ) { bridge = add_bridge ( bridges ) ; bridge -> source_nio = source_nio ; bridge -> destination_nio = destination_nio ; if ( ! ( bridge -> name = strdup ( bridge_name ) ) ) { fprintf ( stderr , ""bridge<S2SV_blank>creation:<S2SV_blank>insufficient<S2SV_blank>memory\\n"" ) ; return FALSE ; } parse_capture ( ubridge_config , bridge_name , bridge ) ; parse_filter ( ubridge_config , bridge_name , bridge ) ; } else if ( source_nio != NULL ) free_nio ( source_nio ) ; else if ( destination_nio != NULL ) free_nio ( destination_nio ) ; } iniparser_freedict ( ubridge_config ) ; return TRUE ; }
","<S2SV_ModStart> iniparser_load ( filename , HIDE_ERRORED_LINE_CONTENT
",GNS3@ubridge/2eb0d1dab6a6de76cf3556130a2d52af101077db,CVE-2020-14976,https://github.com/GNS3/ubridge/commit/2eb0d1dab6a6de76cf3556130a2d52af101077db,2020-06-23T20:15Z,<S2SV_StartBug> if ( ( ubridge_config = iniparser_load ( filename ) ) == NULL ) { <S2SV_EndBug>
2667,CWE-772,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; quantum_info = ( QuantumInfo * ) NULL ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) <S2SV_StartBug> MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_EndBug> filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( MATLAB_HDR . ObjectSize + filepos > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> 6 ) ) { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> ""ImproperImageHeader"" ) ; }
",ImageMagick@ImageMagick/8985ed08f01d465ee65ab5a106186b3868b6f601,CVE-2017-12667,https://github.com/ImageMagick/ImageMagick/commit/8985ed08f01d465ee65ab5a106186b3868b6f601,2017-08-07T21:29Z,"<S2SV_StartBug> MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_EndBug>"
3140,CWE-20,"int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; <S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> open_list ) { <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
","<S2SV_ModStart> timer ) ; spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart> open_list ) { <S2SV_ModEnd> list_move_tail ( & <S2SV_ModStart> = NULL ; list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart> slave_active_lock ) ; <S2SV_ModEnd> mutex_unlock ( &
",torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z,"<S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
201,CWE-119,"static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , ""BPF_NEG<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , ""BPF_END<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ; } else { if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , ""R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\n"" , insn -> src_reg ) ; return - EACCES ; } mark_reg_unknown ( env , regs , insn -> dst_reg ) ; <S2SV_StartBug> regs [ insn -> dst_reg ] . var_off = tnum_cast ( <S2SV_EndBug> regs [ insn -> dst_reg ] . var_off , 4 ) ; <S2SV_StartBug> __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; <S2SV_EndBug> } } else { regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } } } else if ( opcode > BPF_END ) { verbose ( env , ""invalid<S2SV_blank>BPF_ALU<S2SV_blank>opcode<S2SV_blank>%x\\n"" , opcode ) ; return - EINVAL ; } else { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , ""BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , ""BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( ( opcode == BPF_MOD || opcode == BPF_DIV ) && BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 ) { verbose ( env , ""div<S2SV_blank>by<S2SV_blank>zero\\n"" ) ; return - EINVAL ; } if ( ( opcode == BPF_LSH || opcode == BPF_RSH || opcode == BPF_ARSH ) && BPF_SRC ( insn -> code ) == BPF_K ) { int size = BPF_CLASS ( insn -> code ) == BPF_ALU64 ? 64 : 32 ; if ( insn -> imm < 0 || insn -> imm >= size ) { verbose ( env , ""invalid<S2SV_blank>shift<S2SV_blank>%d\\n"" , insn -> imm ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; return adjust_reg_min_max_vals ( env , insn ) ; } return 0 ; }
","<S2SV_ModStart> dst_reg ) ; coerce_reg_to_size <S2SV_ModEnd> ( & regs <S2SV_ModStart> -> dst_reg ] , 4
",torvalds@linux/0c17d1d2c61936401f4702e1846e2c19b200f958,CVE-2017-16996,https://github.com/torvalds/linux/commit/0c17d1d2c61936401f4702e1846e2c19b200f958,2017-12-27T17:08Z,<S2SV_StartBug> regs [ insn -> dst_reg ] . var_off = tnum_cast ( <S2SV_EndBug> <S2SV_StartBug> __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; <S2SV_EndBug>
1480,CWE-119,"static int evaluate_inter_mode_rd ( int mdcounts [ 4 ] , RATE_DISTORTION * rd , int * disable_skip , VP8_COMP * cpi , MACROBLOCK * x ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; int distortion ; vp8_build_inter16x16_predictors_mby ( & x -> e_mbd , x -> e_mbd . predictor , 16 ) ; if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) { x -> skip = 1 ; } else if ( x -> encode_breakout ) { unsigned int sse ; unsigned int var ; unsigned int threshold = ( xd -> block [ 0 ] . dequant [ 1 ] * xd -> block [ 0 ] . dequant [ 1 ] >> 4 ) ; if ( threshold < x -> encode_breakout ) threshold = x -> encode_breakout ; <S2SV_StartBug> var = vp8_variance16x16 <S2SV_EndBug> ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ; if ( sse < threshold ) { unsigned int q2dc = xd -> block [ 24 ] . dequant [ 0 ] ; if ( ( sse - var < q2dc * q2dc >> 4 ) || ( sse / 2 > var && sse - var < 64 ) ) { unsigned int sse2 = VP8_UVSSE ( x ) ; if ( sse2 * 2 < threshold ) { x -> skip = 1 ; rd -> distortion2 = sse + sse2 ; rd -> rate2 = 500 ; rd -> rate_uv = 0 ; rd -> distortion_uv = sse2 ; * disable_skip = 1 ; return RDCOST ( x -> rdmult , x -> rddiv , rd -> rate2 , rd -> distortion2 ) ; } } } } rd -> rate2 += vp8_cost_mv_ref ( this_mode , mdcounts ) ; macro_block_yrd ( x , & rd -> rate_y , & distortion ) ; rd -> rate2 += rd -> rate_y ; rd -> distortion2 += distortion ; rd_inter16x16_uv ( cpi , x , & rd -> rate_uv , & rd -> distortion_uv , cpi -> common . full_pixel ) ; rd -> rate2 += rd -> rate_uv ; rd -> distortion2 += rd -> distortion_uv ; return INT_MAX ; }
","<S2SV_ModStart> ; var = vpx_variance16x16 <S2SV_ModEnd> ( * (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> var = vp8_variance16x16 <S2SV_EndBug>
1062,CWE-284,"static void uipc_flush_ch_locked ( tUIPC_CH_ID ch_id ) { char buf [ UIPC_FLUSH_BUFFER_SIZE ] ; struct pollfd pfd ; int ret ; pfd . events = POLLIN ; pfd . fd = uipc_main . ch [ ch_id ] . fd ; if ( uipc_main . ch [ ch_id ] . fd == UIPC_DISCONNECTED ) { BTIF_TRACE_EVENT ( ""%s()<S2SV_blank>-<S2SV_blank>fd<S2SV_blank>disconnected.<S2SV_blank>Exiting"" , __FUNCTION__ ) ; return ; } while ( 1 ) { <S2SV_StartBug> ret = poll ( & pfd , 1 , 1 ) ; <S2SV_EndBug> BTIF_TRACE_VERBOSE ( ""%s()<S2SV_blank>-<S2SV_blank>polling<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>revents:<S2SV_blank>0x%x,<S2SV_blank>ret<S2SV_blank>%d"" , __FUNCTION__ , pfd . fd , pfd . revents , ret ) ; if ( pfd . revents & ( POLLERR | POLLHUP ) ) { BTIF_TRACE_EVENT ( ""%s()<S2SV_blank>-<S2SV_blank>POLLERR<S2SV_blank>or<S2SV_blank>POLLHUP.<S2SV_blank>Exiting"" , __FUNCTION__ ) ; return ; } if ( ret <= 0 ) { BTIF_TRACE_EVENT ( ""%s()<S2SV_blank>-<S2SV_blank>error<S2SV_blank>(%d).<S2SV_blank>Exiting"" , __FUNCTION__ , ret ) ; return ; } <S2SV_StartBug> read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1 , 1 ) <S2SV_ModStart> return ; } TEMP_FAILURE_RETRY ( <S2SV_ModStart> , UIPC_FLUSH_BUFFER_SIZE ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> ret = poll ( & pfd , 1 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ; <S2SV_EndBug>"
1735,CWE-119,"void vp9_encode_frame ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; if ( ! frame_is_intra_only ( cm ) ) { if ( ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) || ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ LAST_FRAME ] ) ) { <S2SV_StartBug> cm -> allow_comp_inter_inter = 0 ; <S2SV_EndBug> } else { <S2SV_StartBug> cm -> allow_comp_inter_inter = 1 ; <S2SV_EndBug> cm -> comp_fixed_ref = ALTREF_FRAME ; cm -> comp_var_ref [ 0 ] = LAST_FRAME ; cm -> comp_var_ref [ 1 ] = GOLDEN_FRAME ; } } if ( cpi -> sf . frame_parameter_update ) { <S2SV_StartBug> int i ; <S2SV_EndBug> const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ; <S2SV_StartBug> const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter ) <S2SV_EndBug> cm -> reference_mode = SINGLE_REFERENCE ; <S2SV_StartBug> else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] && <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ COMPOUND_REFERENCE ] > <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ REFERENCE_MODE_SELECT ] && <S2SV_EndBug> check_dual_ref_flags ( cpi ) && cpi -> static_mb_pct == 100 ) cm -> reference_mode = COMPOUND_REFERENCE ; <S2SV_StartBug> else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] ) <S2SV_EndBug> cm -> reference_mode = SINGLE_REFERENCE ; else cm -> reference_mode = REFERENCE_MODE_SELECT ; <S2SV_StartBug> if ( cm -> interp_filter == SWITCHABLE ) { <S2SV_EndBug> if ( frame_type != ALTREF_FRAME && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP_SHARP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ SWITCHABLE - 1 ] ) { <S2SV_StartBug> cm -> interp_filter = EIGHTTAP_SMOOTH ; <S2SV_EndBug> } else if ( filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP_SHARP ; } else if ( filter_thresh [ EIGHTTAP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP ; } } encode_frame_internal ( cpi ) ; <S2SV_StartBug> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ; <S2SV_EndBug> cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] >>= 1 ; } <S2SV_StartBug> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ; <S2SV_EndBug> cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ; <S2SV_StartBug> } <S2SV_EndBug> for ( i = 0 ; i < TX_MODES ; ++ i ) { int64_t pd = cpi -> rd_tx_select_diff [ i ] ; int diff ; if ( i == TX_MODE_SELECT ) pd -= RDCOST ( cpi -> mb . rdmult , cpi -> mb . rddiv , 2048 * ( TX_SIZES - 1 ) , 0 ) ; diff = ( int ) ( pd / cm -> MBs ) ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] /= 2 ; } if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { int single_count_zero = 0 ; int comp_count_zero = 0 ; for ( i = 0 ; i < COMP_INTER_CONTEXTS ; i ++ ) { <S2SV_StartBug> single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ; <S2SV_EndBug> } if ( comp_count_zero == 0 ) { cm -> reference_mode = SINGLE_REFERENCE ; <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> } else if ( single_count_zero == 0 ) { cm -> reference_mode = COMPOUND_REFERENCE ; <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> } } if ( cm -> tx_mode == TX_MODE_SELECT ) { int count4x4 = 0 ; int count8x8_lp = 0 , count8x8_8x8p = 0 ; int count16x16_16x16p = 0 , count16x16_lp = 0 ; int count32x32 = 0 ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; ++ i ) { <S2SV_StartBug> count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ; <S2SV_EndBug> } if ( count4x4 == 0 && count16x16_lp == 0 && count16x16_16x16p == 0 && count32x32 == 0 ) { cm -> tx_mode = ALLOW_8X8 ; <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_8X8 ) ; <S2SV_EndBug> } else if ( count8x8_8x8p == 0 && count16x16_16x16p == 0 && count8x8_lp == 0 && count16x16_lp == 0 && count32x32 == 0 ) { cm -> tx_mode = ONLY_4X4 ; <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_4X4 ) ; <S2SV_EndBug> } else if ( count8x8_lp == 0 && count16x16_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_32X32 ; } else if ( count32x32 == 0 && count8x8_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_16X16 ; <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_16X16 ) ; <S2SV_EndBug> } } } else { cm -> reference_mode = SINGLE_REFERENCE ; <S2SV_StartBug> cm -> interp_filter = SWITCHABLE ; <S2SV_EndBug> encode_frame_internal ( cpi ) ; } }
","<S2SV_ModStart> ) ) { cpi <S2SV_ModEnd> -> allow_comp_inter_inter = <S2SV_ModStart> } else { cpi <S2SV_ModEnd> -> allow_comp_inter_inter = <S2SV_ModStart> { int i ; RD_OPT * const rd_opt = & cpi -> rd ; FRAME_COUNTS * counts = cpi -> td . counts ; RD_COUNTS * const rdc = & cpi -> td . rd_counts <S2SV_ModStart> cpi ) ; int64_t * const mode_thrs = rd_opt -> prediction_type_threshes <S2SV_ModEnd> [ frame_type ] <S2SV_ModStart> frame_type ] ; int64_t * const filter_thrs = rd_opt -> filter_threshes <S2SV_ModEnd> [ frame_type ] <S2SV_ModStart> frame_type ] ; const int is_alt_ref = <S2SV_ModEnd> frame_type == ALTREF_FRAME <S2SV_ModStart> frame_type == ALTREF_FRAME ; if ( is_alt_ref || ! cpi <S2SV_ModEnd> -> allow_comp_inter_inter ) <S2SV_ModStart> else if ( mode_thrs <S2SV_ModEnd> [ COMPOUND_REFERENCE ] <S2SV_ModStart> COMPOUND_REFERENCE ] > mode_thrs <S2SV_ModEnd> [ SINGLE_REFERENCE ] <S2SV_ModStart> SINGLE_REFERENCE ] && mode_thrs <S2SV_ModEnd> [ COMPOUND_REFERENCE ] <S2SV_ModStart> COMPOUND_REFERENCE ] > mode_thrs <S2SV_ModEnd> [ REFERENCE_MODE_SELECT ] <S2SV_ModStart> else if ( mode_thrs <S2SV_ModEnd> [ SINGLE_REFERENCE ] <S2SV_ModStart> SINGLE_REFERENCE ] > mode_thrs <S2SV_ModEnd> [ REFERENCE_MODE_SELECT ] <S2SV_ModStart> == SWITCHABLE ) <S2SV_ModEnd> cm -> interp_filter <S2SV_ModStart> -> interp_filter = get_interp_filter ( filter_thrs , is_alt_ref ) ; <S2SV_ModEnd> encode_frame_internal ( cpi <S2SV_ModStart> ++ i ) mode_thrs [ i ] = ( mode_thrs [ i ] + rdc -> comp_pred_diff <S2SV_ModEnd> [ i ] <S2SV_ModStart> -> MBs ) / 2 ; <S2SV_ModEnd> for ( i <S2SV_ModStart> < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_thrs [ i ] = ( filter_thrs [ i ] + rdc -> filter_diff <S2SV_ModEnd> [ i ] <S2SV_ModStart> cm -> MBs <S2SV_ModEnd> ) / 2 <S2SV_ModStart> / 2 ; <S2SV_ModEnd> if ( cm <S2SV_ModStart> { single_count_zero += counts -> <S2SV_ModEnd> comp_inter [ i <S2SV_ModStart> ; comp_count_zero += counts -> <S2SV_ModEnd> comp_inter [ i <S2SV_ModStart> ; vp9_zero ( counts -> <S2SV_ModEnd> comp_inter ) ; <S2SV_ModStart> ; vp9_zero ( counts -> <S2SV_ModEnd> comp_inter ) ; <S2SV_ModStart> { count4x4 += counts -> <S2SV_ModEnd> tx . p32x32 <S2SV_ModStart> ; count4x4 += counts -> <S2SV_ModEnd> tx . p16x16 <S2SV_ModStart> ; count4x4 += counts -> <S2SV_ModEnd> tx . p8x8 <S2SV_ModStart> ; count8x8_lp += counts -> <S2SV_ModEnd> tx . p32x32 <S2SV_ModStart> ; count8x8_lp += counts -> <S2SV_ModEnd> tx . p16x16 <S2SV_ModStart> ; count8x8_8x8p += counts -> <S2SV_ModEnd> tx . p8x8 <S2SV_ModStart> ; count16x16_16x16p += counts -> <S2SV_ModEnd> tx . p16x16 <S2SV_ModStart> ; count16x16_lp += counts -> <S2SV_ModEnd> tx . p32x32 <S2SV_ModStart> ; count32x32 += counts -> <S2SV_ModEnd> tx . p32x32 <S2SV_ModStart> = ALLOW_8X8 ; reset_skip_tx_size <S2SV_ModEnd> ( cm , <S2SV_ModStart> = ONLY_4X4 ; reset_skip_tx_size <S2SV_ModEnd> ( cm , <S2SV_ModStart> = ALLOW_16X16 ; reset_skip_tx_size <S2SV_ModEnd> ( cm , <S2SV_ModStart> = SINGLE_REFERENCE ; <S2SV_ModEnd> encode_frame_internal ( cpi
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> cm -> allow_comp_inter_inter = 0 ; <S2SV_EndBug> <S2SV_StartBug> cm -> allow_comp_inter_inter = 1 ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter ) <S2SV_EndBug> <S2SV_StartBug> else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] && <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ COMPOUND_REFERENCE ] > <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ REFERENCE_MODE_SELECT ] && <S2SV_EndBug> <S2SV_StartBug> else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] ) <S2SV_EndBug> <S2SV_StartBug> if ( cm -> interp_filter == SWITCHABLE ) { <S2SV_EndBug> <S2SV_StartBug> cm -> interp_filter = EIGHTTAP_SMOOTH ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ; <S2SV_EndBug> <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_8X8 ) ; <S2SV_EndBug> <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_4X4 ) ; <S2SV_EndBug> <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_16X16 ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> interp_filter = SWITCHABLE ; <S2SV_EndBug>"
2917,CWE-617,"static bool access_pmu_evcntr ( struct kvm_vcpu * vcpu , struct sys_reg_params * p , const struct sys_reg_desc * r ) { u64 idx ; if ( ! kvm_arm_pmu_v3_ready ( vcpu ) ) return trap_raz_wi ( vcpu , p , r ) ; if ( r -> CRn == 9 && r -> CRm == 13 ) { if ( r -> Op2 == 2 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = vcpu_sys_reg ( vcpu , PMSELR_EL0 ) & ARMV8_PMU_COUNTER_MASK ; } else if ( r -> Op2 == 0 ) { if ( pmu_access_cycle_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } } else if ( r -> CRn == 14 && ( r -> CRm & 12 ) == 8 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ( ( r -> CRm & 3 ) << 3 ) | ( r -> Op2 & 7 ) ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } if ( ! pmu_counter_idx_valid ( vcpu , idx ) ) return false ; if ( p -> is_write ) { if ( pmu_access_el0_disabled ( vcpu ) ) return false ; kvm_pmu_set_counter_value ( vcpu , idx , p -> regval ) ; } else { p -> regval = kvm_pmu_get_counter_value ( vcpu , idx ) ; } return true ; }
","<S2SV_ModStart> } else { return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> } else if <S2SV_ModStart> } else { return false <S2SV_ModEnd> ; } if
",torvalds@linux/9e3f7a29694049edd728e2400ab57ad7553e5aa9,CVE-2017-12168,https://github.com/torvalds/linux/commit/9e3f7a29694049edd728e2400ab57ad7553e5aa9,2017-09-20T08:29Z,<S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug>
7861,CWE-20,"uint16_t enc28j60ReadPhyReg ( NetInterface * interface , uint16_t address ) { uint16_t data ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , MICMD_MIIRD ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> { } <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> data = enc28j60ReadReg ( interface , ENC28J60_REG_MIRDL ) ; <S2SV_EndBug> <S2SV_StartBug> data |= enc28j60ReadReg ( interface , ENC28J60_REG_MIRDH ) << 8 ; <S2SV_EndBug> return data ; }
","<S2SV_ModStart> ( interface , ENC28J60_MIREGADR <S2SV_ModEnd> , address & <S2SV_ModStart> ( interface , ENC28J60_MICMD , ENC28J60_MICMD_MIIRD <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_MICMD <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ( interface , ENC28J60_MIRDL <S2SV_ModEnd> ) ; data <S2SV_ModStart> ( interface , ENC28J60_MIRDH <S2SV_ModEnd> ) << 8
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , MICMD_MIIRD ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> data = enc28j60ReadReg ( interface , ENC28J60_REG_MIRDL ) ; <S2SV_EndBug> <S2SV_StartBug> data |= enc28j60ReadReg ( interface , ENC28J60_REG_MIRDH ) << 8 ; <S2SV_EndBug>"
7370,CWE-835,"int dwg_encode_add_object ( Dwg_Object * restrict obj , Bit_Chain * restrict dat , unsigned long address ) { int error = 0 ; unsigned long oldpos ; unsigned long end_address = address + obj -> size ; oldpos = bit_position ( dat ) ; assert ( address ) ; dat -> byte = address ; dat -> bit = 0 ; LOG_INFO ( ""Object<S2SV_blank>number:<S2SV_blank>%lu"" , ( unsigned long ) obj -> index ) ; if ( obj -> size > 0x100000 ) { LOG_ERROR ( ""Object<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>overflow"" , obj -> size ) ; return DWG_ERR_VALUEOUTOFBOUNDS ; } while ( dat -> byte + obj -> size >= dat -> size ) bit_chain_alloc ( dat ) ; bit_write_MS ( dat , obj -> size ) ; obj -> address = dat -> byte ; PRE ( R_2010 ) { bit_write_BS ( dat , obj -> type ) ; LOG_INFO ( "",<S2SV_blank>Size:<S2SV_blank>%d<S2SV_blank>[MS],<S2SV_blank>Type:<S2SV_blank>%d<S2SV_blank>[BS]\\n"" , obj -> size , obj -> type ) } LATER_VERSIONS { if ( ! obj -> handlestream_size && obj -> bitsize ) obj -> handlestream_size = obj -> size * 8 - obj -> bitsize ; bit_write_UMC ( dat , obj -> handlestream_size ) ; obj -> address = dat -> byte ; bit_write_BOT ( dat , obj -> type ) ; LOG_INFO ( "",<S2SV_blank>Size:<S2SV_blank>%d<S2SV_blank>[MS],<S2SV_blank>Hdlsize:<S2SV_blank>%lu<S2SV_blank>[UMC],<S2SV_blank>Type:<S2SV_blank>%d<S2SV_blank>[BOT]\\n"" , obj -> size , ( unsigned long ) obj -> handlestream_size , obj -> type ) } switch ( obj -> type ) { case DWG_TYPE_TEXT : error = dwg_encode_TEXT ( dat , obj ) ; break ; case DWG_TYPE_ATTRIB : error = dwg_encode_ATTRIB ( dat , obj ) ; break ; case DWG_TYPE_ATTDEF : error = dwg_encode_ATTDEF ( dat , obj ) ; break ; case DWG_TYPE_BLOCK : error = dwg_encode_BLOCK ( dat , obj ) ; break ; case DWG_TYPE_ENDBLK : error = dwg_encode_ENDBLK ( dat , obj ) ; break ; case DWG_TYPE_SEQEND : error = dwg_encode_SEQEND ( dat , obj ) ; break ; case DWG_TYPE_INSERT : error = dwg_encode_INSERT ( dat , obj ) ; break ; case DWG_TYPE_MINSERT : error = dwg_encode_MINSERT ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_2D : error = dwg_encode_VERTEX_2D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_3D : error = dwg_encode_VERTEX_3D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_MESH : error = dwg_encode_VERTEX_MESH ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE : error = dwg_encode_VERTEX_PFACE ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE_FACE : error = dwg_encode_VERTEX_PFACE_FACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_2D : error = dwg_encode_POLYLINE_2D ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_3D : error = dwg_encode_POLYLINE_3D ( dat , obj ) ; break ; case DWG_TYPE_ARC : error = dwg_encode_ARC ( dat , obj ) ; break ; case DWG_TYPE_CIRCLE : error = dwg_encode_CIRCLE ( dat , obj ) ; break ; case DWG_TYPE_LINE : error = dwg_encode_LINE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ORDINATE : error = dwg_encode_DIMENSION_ORDINATE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_LINEAR : error = dwg_encode_DIMENSION_LINEAR ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ALIGNED : error = dwg_encode_DIMENSION_ALIGNED ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG3PT : error = dwg_encode_DIMENSION_ANG3PT ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG2LN : error = dwg_encode_DIMENSION_ANG2LN ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_RADIUS : error = dwg_encode_DIMENSION_RADIUS ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_DIAMETER : error = dwg_encode_DIMENSION_DIAMETER ( dat , obj ) ; break ; case DWG_TYPE_POINT : error = dwg_encode_POINT ( dat , obj ) ; break ; case DWG_TYPE__3DFACE : error = dwg_encode__3DFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_PFACE : error = dwg_encode_POLYLINE_PFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_MESH : error = dwg_encode_POLYLINE_MESH ( dat , obj ) ; break ; case DWG_TYPE_SOLID : error = dwg_encode_SOLID ( dat , obj ) ; break ; case DWG_TYPE_TRACE : error = dwg_encode_TRACE ( dat , obj ) ; break ; case DWG_TYPE_SHAPE : error = dwg_encode_SHAPE ( dat , obj ) ; break ; case DWG_TYPE_VIEWPORT : error = dwg_encode_VIEWPORT ( dat , obj ) ; break ; case DWG_TYPE_ELLIPSE : error = dwg_encode_ELLIPSE ( dat , obj ) ; break ; case DWG_TYPE_SPLINE : error = dwg_encode_SPLINE ( dat , obj ) ; break ; case DWG_TYPE_REGION : error = dwg_encode_REGION ( dat , obj ) ; break ; case DWG_TYPE__3DSOLID : error = dwg_encode__3DSOLID ( dat , obj ) ; break ; case DWG_TYPE_BODY : error = dwg_encode_BODY ( dat , obj ) ; break ; case DWG_TYPE_RAY : error = dwg_encode_RAY ( dat , obj ) ; break ; case DWG_TYPE_XLINE : error = dwg_encode_XLINE ( dat , obj ) ; break ; case DWG_TYPE_DICTIONARY : error = dwg_encode_DICTIONARY ( dat , obj ) ; break ; case DWG_TYPE_MTEXT : error = dwg_encode_MTEXT ( dat , obj ) ; break ; case DWG_TYPE_LEADER : error = dwg_encode_LEADER ( dat , obj ) ; break ; case DWG_TYPE_TOLERANCE : error = dwg_encode_TOLERANCE ( dat , obj ) ; break ; case DWG_TYPE_MLINE : error = dwg_encode_MLINE ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_CONTROL : error = dwg_encode_BLOCK_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_HEADER : error = dwg_encode_BLOCK_HEADER ( dat , obj ) ; break ; case DWG_TYPE_LAYER_CONTROL : error = dwg_encode_LAYER_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LAYER : error = dwg_encode_LAYER ( dat , obj ) ; break ; case DWG_TYPE_STYLE_CONTROL : error = dwg_encode_STYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_STYLE : error = dwg_encode_STYLE ( dat , obj ) ; break ; case DWG_TYPE_LTYPE_CONTROL : error = dwg_encode_LTYPE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LTYPE : error = dwg_encode_LTYPE ( dat , obj ) ; break ; case DWG_TYPE_VIEW_CONTROL : error = dwg_encode_VIEW_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VIEW : error = dwg_encode_VIEW ( dat , obj ) ; break ; case DWG_TYPE_UCS_CONTROL : error = dwg_encode_UCS_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_UCS : error = dwg_encode_UCS ( dat , obj ) ; break ; case DWG_TYPE_VPORT_CONTROL : error = dwg_encode_VPORT_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT : error = dwg_encode_VPORT ( dat , obj ) ; break ; case DWG_TYPE_APPID_CONTROL : error = dwg_encode_APPID_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_APPID : error = dwg_encode_APPID ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE_CONTROL : error = dwg_encode_DIMSTYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE : error = dwg_encode_DIMSTYLE ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_CONTROL : error = dwg_encode_VPORT_ENTITY_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_HEADER : error = dwg_encode_VPORT_ENTITY_HEADER ( dat , obj ) ; break ; case DWG_TYPE_GROUP : error = dwg_encode_GROUP ( dat , obj ) ; break ; case DWG_TYPE_MLINESTYLE : error = dwg_encode_MLINESTYLE ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_OLE2FRAME : error = dwg_encode_OLE2FRAME ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_DUMMY : error = dwg_encode_DUMMY ( dat , obj ) ; break ; case DWG_TYPE_LONG_TRANSACTION : error = dwg_encode_LONG_TRANSACTION ( dat , obj ) ; break ; case DWG_TYPE_LWPOLYLINE : error = dwg_encode_LWPOLYLINE ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_HATCH : error = dwg_encode_HATCH ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_XRECORD : error = dwg_encode_XRECORD ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_PLACEHOLDER : error = dwg_encode_PLACEHOLDER ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_OLEFRAME : error = dwg_encode_OLEFRAME ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_VBA_PROJECT : LOG_ERROR ( ""Unhandled<S2SV_blank>Object<S2SV_blank>VBA_PROJECT.<S2SV_blank>Has<S2SV_blank>its<S2SV_blank>own<S2SV_blank>section"" ) ; break ; case DWG_TYPE_LAYOUT : error |= dwg_encode_LAYOUT ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_PROXY_ENTITY : error = dwg_encode_PROXY_ENTITY ( dat , obj ) ; break ; case DWG_TYPE_PROXY_OBJECT : error = dwg_encode_PROXY_OBJECT ( dat , obj ) ; break ; default : if ( obj -> type == obj -> parent -> layout_type && obj -> fixedtype == DWG_TYPE_LAYOUT ) { error = dwg_encode_LAYOUT ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; } else if ( ( error = dwg_encode_variable_type ( obj -> parent , dat , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) { Dwg_Data * dwg = obj -> parent ; int is_entity ; int i = obj -> type - 500 ; Dwg_Class * klass = dwg_encode_get_class ( dwg , obj ) ; assert ( address ) ; dat -> byte = address ; dat -> bit = 0 ; bit_write_MS ( dat , obj -> size ) ; if ( dat -> version >= R_2010 ) { bit_write_UMC ( dat , obj -> handlestream_size ) ; bit_write_BOT ( dat , obj -> type ) ; } else bit_write_BS ( dat , obj -> type ) ; if ( klass && obj -> supertype == DWG_SUPERTYPE_UNKNOWN ) is_entity = dwg_class_is_entity ( klass ) ; else is_entity = obj -> supertype == DWG_SUPERTYPE_ENTITY ; <S2SV_StartBug> if ( klass && ! is_entity ) <S2SV_EndBug> <S2SV_StartBug> error = dwg_encode_UNKNOWN_OBJ ( dat , obj ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( klass ) <S2SV_EndBug> error = dwg_encode_UNKNOWN_ENT ( dat , obj ) ; else { LOG_WARN ( ""Unknown<S2SV_blank>object,<S2SV_blank>skipping<S2SV_blank>eed/reactors/xdic"" ) ; error = DWG_ERR_UNHANDLEDCLASS ; SINCE ( R_2000 ) { bit_write_RL ( dat , obj -> bitsize ) ; LOG_INFO ( ""bitsize:<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>[RL]<S2SV_blank>(@%lu.%u)\\n"" , obj -> bitsize , dat -> byte - 4 , dat -> bit ) ; } bit_write_H ( dat , & obj -> handle ) ; LOG_INFO ( ""handle:<S2SV_blank>"" FORMAT_H ""<S2SV_blank>[H<S2SV_blank>5]\\n"" , ARGS_H ( obj -> handle ) ) ; bit_write_TF ( dat , obj -> tio . unknown , obj -> size ) ; } } } if ( ! obj -> size ) { BITCODE_BL pos = bit_position ( dat ) ; assert ( address ) ; obj -> size = dat -> byte - address - 2 ; if ( dat -> bit ) obj -> size ++ ; if ( ! obj -> bitsize ) { LOG_TRACE ( ""-bitsize<S2SV_blank>calc<S2SV_blank>from<S2SV_blank>address<S2SV_blank>(no<S2SV_blank>handle)<S2SV_blank>@%lu.%u\\n"" , dat -> byte , dat -> bit ) ; obj -> bitsize = pos - ( obj -> address * 8 ) ; } bit_set_position ( dat , address * 8 ) ; if ( obj -> size > 0x7fff ) LOG_ERROR ( ""Unhandled<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>><S2SV_blank>0x7fff"" , ( unsigned ) obj -> size ) ; bit_write_MS ( dat , obj -> size ) ; LOG_TRACE ( ""-size:<S2SV_blank>%u<S2SV_blank>[MS]<S2SV_blank>@%lu\\n"" , obj -> size , address ) ; SINCE ( R_2013 ) { if ( ! obj -> handlestream_size && obj -> bitsize ) obj -> handlestream_size = obj -> size * 8 - obj -> bitsize ; bit_write_UMC ( dat , obj -> handlestream_size ) ; LOG_TRACE ( ""-handlestream_size:<S2SV_blank>%lu<S2SV_blank>[UMC]\\n"" , obj -> handlestream_size ) ; } SINCE ( R_2000 ) { if ( obj -> bitsize_pos && obj -> bitsize ) { bit_set_position ( dat , obj -> bitsize_pos ) ; bit_write_RL ( dat , obj -> bitsize ) ; LOG_TRACE ( ""-bitsize:<S2SV_blank>%u<S2SV_blank>[RL]<S2SV_blank>@%lu.%lu\\n"" , obj -> bitsize , obj -> bitsize_pos / 8 , obj -> bitsize_pos % 8 ) ; } } bit_set_position ( dat , pos ) ; } if ( dat -> bit ) LOG_TRACE ( ""padding:<S2SV_blank>+%d<S2SV_blank>[*B]\\n"" , 8 - dat -> bit ) while ( dat -> bit ) bit_write_B ( dat , 1 ) ; end_address = obj -> address + obj -> size ; if ( end_address != dat -> byte ) { if ( obj -> size ) LOG_WARN ( ""Wrong<S2SV_blank>object<S2SV_blank>size:<S2SV_blank>%lu<S2SV_blank>+<S2SV_blank>%u<S2SV_blank>=<S2SV_blank>%lu<S2SV_blank>!=<S2SV_blank>%lu:<S2SV_blank>%ld<S2SV_blank>off"" , obj -> address , obj -> size , end_address , dat -> byte , ( long ) ( end_address - dat -> byte ) ) ; dat -> byte = end_address ; } assert ( ! dat -> bit ) ; bit_write_CRC ( dat , address , 0xC0C1 ) ; return error ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> is_entity ) error <S2SV_ModStart> ) error = dwg_encode_UNKNOWN_ENT ( dat , obj ) ; else error = <S2SV_ModStart> obj ) ; <S2SV_ModEnd> } } if
",LibreDWG@libredwg/c6f6668b82bfe595899cc820279ac37bb9ef16f5,CVE-2019-20911,https://github.com/LibreDWG/libredwg/commit/c6f6668b82bfe595899cc820279ac37bb9ef16f5,2020-07-16T18:15Z,"<S2SV_StartBug> if ( klass && ! is_entity ) <S2SV_EndBug> <S2SV_StartBug> error = dwg_encode_UNKNOWN_OBJ ( dat , obj ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( klass ) <S2SV_EndBug>"
1440,CWE-119,"int vp8_full_search_sadx3 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ; unsigned int sad_array [ 3 ] ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( col_min < x -> mv_col_min ) col_min = x -> mv_col_min ; if ( col_max > x -> mv_col_max ) col_max = x -> mv_col_max ; if ( row_min < x -> mv_row_min ) row_min = x -> mv_row_min ; if ( row_max > x -> mv_row_max ) row_max = x -> mv_row_max ; for ( r = row_min ; r < row_max ; r ++ ) { this_mv . as_mv . row = r ; check_here = r * mv_stride + in_what + col_min ; c = col_min ; while ( ( c + 2 ) < col_max ) { int i ; fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ; for ( i = 0 ; i < 3 ; i ++ ) { thissad = sad_array [ i ] ; if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } while ( c < col_max ) { <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , bestaddress , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
","<S2SV_ModStart> bestaddress , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> check_here , in_what_stride <S2SV_ModEnd> ) ; if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug>"
2888,CWE-119,"bt_status_t btif_dm_pin_reply ( const bt_bdaddr_t * bd_addr , uint8_t accept , uint8_t pin_len , bt_pin_code_t * pin_code ) { BTIF_TRACE_EVENT ( ""%s:<S2SV_blank>accept=%d"" , __FUNCTION__ , accept ) ; <S2SV_StartBug> if ( pin_code == NULL ) <S2SV_EndBug> return BT_STATUS_FAIL ; # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) if ( pairing_cb . is_le_only ) { int i ; UINT32 passkey = 0 ; int multi [ ] = { 100000 , 10000 , 1000 , 100 , 10 , 1 } ; BD_ADDR remote_bd_addr ; bdcpy ( remote_bd_addr , bd_addr -> address ) ; for ( i = 0 ; i < 6 ; i ++ ) { passkey += ( multi [ i ] * ( pin_code -> pin [ i ] - '0' ) ) ; } BTIF_TRACE_DEBUG ( ""btif_dm_pin_reply:<S2SV_blank>passkey:<S2SV_blank>%d"" , passkey ) ; BTA_DmBlePasskeyReply ( remote_bd_addr , accept , passkey ) ; } else { BTA_DmPinReply ( ( UINT8 * ) bd_addr -> address , accept , pin_len , pin_code -> pin ) ; if ( accept ) pairing_cb . pin_code_len = pin_len ; } # else BTA_DmPinReply ( ( UINT8 * ) bd_addr -> address , accept , pin_len , pin_code -> pin ) ; if ( accept ) pairing_cb . pin_code_len = pin_len ; # endif return BT_STATUS_SUCCESS ; }
","<S2SV_ModStart> pin_code == NULL || pin_len > PIN_CODE_LEN
",system@bt/9b534de2aca5d790c2a1c4d76b545f16137d95dd,CVE-2016-2439,https://android.googlesource.com/platform/system/bt/+/9b534de2aca5d790c2a1c4d76b545f16137d95dd,2016-05-09T10:59Z,<S2SV_StartBug> if ( pin_code == NULL ) <S2SV_EndBug>
3659,CWE-000,"SYSCALL_DEFINE3 ( rt_sigqueueinfo , pid_t , pid , int , sig , siginfo_t __user * , uinfo ) { siginfo_t info ; if ( copy_from_user ( & info , uinfo , sizeof ( siginfo_t ) ) ) return - EFAULT ; <S2SV_StartBug> if ( info . si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> info . si_signo = sig ; return kill_proc_info ( sig , & info , pid ) ; }
","<S2SV_ModStart> info . si_code != SI_QUEUE ) { WARN_ON_ONCE ( info . si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
",torvalds@linux/da48524eb20662618854bb3df2db01fc65f3070c,CVE-2011-1182,https://github.com/torvalds/linux/commit/da48524eb20662618854bb3df2db01fc65f3070c,2013-03-01T12:37Z,<S2SV_StartBug> if ( info . si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug>
3789,CWE-264,"static void pkinit_server_verify_padata ( krb5_context context , krb5_data * req_pkt , krb5_kdc_req * request , krb5_enc_tkt_part * enc_tkt_reply , krb5_pa_data * data , krb5_kdcpreauth_callbacks cb , krb5_kdcpreauth_rock rock , krb5_kdcpreauth_moddata moddata , krb5_kdcpreauth_verify_respond_fn respond , void * arg ) { krb5_error_code retval = 0 ; krb5_data authp_data = { 0 , 0 , NULL } , krb5_authz = { 0 , 0 , NULL } ; krb5_pa_pk_as_req * reqp = NULL ; krb5_pa_pk_as_req_draft9 * reqp9 = NULL ; krb5_auth_pack * auth_pack = NULL ; krb5_auth_pack_draft9 * auth_pack9 = NULL ; pkinit_kdc_context plgctx = NULL ; pkinit_kdc_req_context reqctx = NULL ; krb5_checksum cksum = { 0 , 0 , 0 , NULL } ; krb5_data * der_req = NULL ; int valid_eku = 0 , valid_san = 0 ; krb5_data k5data ; int is_signed = 1 ; krb5_pa_data * * e_data = NULL ; krb5_kdcpreauth_modreq modreq = NULL ; pkiDebug ( ""pkinit_verify_padata:<S2SV_blank>entered!\\n"" ) ; if ( data == NULL || data -> length <= 0 || data -> contents == NULL ) { <S2SV_StartBug> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <S2SV_EndBug> return ; } if ( moddata == NULL ) { ( * respond ) ( arg , EINVAL , NULL , NULL , NULL ) ; return ; } plgctx = pkinit_find_realm_context ( context , moddata , request -> server ) ; if ( plgctx == NULL ) { <S2SV_StartBug> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <S2SV_EndBug> return ; } # ifdef DEBUG_ASN1 print_buffer_bin ( data -> contents , data -> length , ""/tmp/kdc_as_req"" ) ; # endif retval = pkinit_init_kdc_req_context ( context , & reqctx ) ; if ( retval ) goto cleanup ; reqctx -> pa_type = data -> pa_type ; PADATA_TO_KRB5DATA ( data , & k5data ) ; switch ( ( int ) data -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : pkiDebug ( ""processing<S2SV_blank>KRB5_PADATA_PK_AS_REQ\\n"" ) ; retval = k5int_decode_krb5_pa_pk_as_req ( & k5data , & reqp ) ; if ( retval ) { pkiDebug ( ""decode_krb5_pa_pk_as_req<S2SV_blank>failed\\n"" ) ; goto cleanup ; } # ifdef DEBUG_ASN1 print_buffer_bin ( reqp -> signedAuthPack . data , reqp -> signedAuthPack . length , ""/tmp/kdc_signed_data"" ) ; # endif retval = cms_signeddata_verify ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , CMS_SIGN_CLIENT , plgctx -> opts -> require_crl_checking , ( unsigned char * ) reqp -> signedAuthPack . data , reqp -> signedAuthPack . length , ( unsigned char * * ) & authp_data . data , & authp_data . length , ( unsigned char * * ) & krb5_authz . data , & krb5_authz . length , & is_signed ) ; break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : pkiDebug ( ""processing<S2SV_blank>KRB5_PADATA_PK_AS_REQ_OLD\\n"" ) ; retval = k5int_decode_krb5_pa_pk_as_req_draft9 ( & k5data , & reqp9 ) ; if ( retval ) { pkiDebug ( ""decode_krb5_pa_pk_as_req_draft9<S2SV_blank>failed\\n"" ) ; goto cleanup ; } # ifdef DEBUG_ASN1 print_buffer_bin ( reqp9 -> signedAuthPack . data , reqp9 -> signedAuthPack . length , ""/tmp/kdc_signed_data_draft9"" ) ; # endif retval = cms_signeddata_verify ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , CMS_SIGN_DRAFT9 , plgctx -> opts -> require_crl_checking , ( unsigned char * ) reqp9 -> signedAuthPack . data , reqp9 -> signedAuthPack . length , ( unsigned char * * ) & authp_data . data , & authp_data . length , ( unsigned char * * ) & krb5_authz . data , & krb5_authz . length , NULL ) ; break ; default : pkiDebug ( ""unrecognized<S2SV_blank>pa_type<S2SV_blank>=<S2SV_blank>%d\\n"" , data -> pa_type ) ; retval = EINVAL ; goto cleanup ; } if ( retval ) { pkiDebug ( ""pkcs7_signeddata_verify<S2SV_blank>failed\\n"" ) ; goto cleanup ; } if ( is_signed ) { retval = verify_client_san ( context , plgctx , reqctx , request -> client , & valid_san ) ; if ( retval ) goto cleanup ; if ( ! valid_san ) { pkiDebug ( ""%s:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>an<S2SV_blank>acceptable<S2SV_blank>SAN<S2SV_blank>in<S2SV_blank>user<S2SV_blank>"" ""certificate\\n"" , __FUNCTION__ ) ; retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH ; goto cleanup ; } retval = verify_client_eku ( context , plgctx , reqctx , & valid_eku ) ; if ( retval ) goto cleanup ; if ( ! valid_eku ) { pkiDebug ( ""%s:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>an<S2SV_blank>acceptable<S2SV_blank>EKU<S2SV_blank>in<S2SV_blank>user<S2SV_blank>"" ""certificate\\n"" , __FUNCTION__ ) ; retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE ; goto cleanup ; } } else { if ( ! krb5_principal_compare ( context , request -> client , krb5_anonymous_principal ( ) ) ) { retval = KRB5KDC_ERR_PREAUTH_FAILED ; krb5_set_error_message ( context , retval , _ ( ""Pkinit<S2SV_blank>request<S2SV_blank>not<S2SV_blank>signed,<S2SV_blank>but<S2SV_blank>client<S2SV_blank>"" ""not<S2SV_blank>anonymous."" ) ) ; goto cleanup ; } } # ifdef DEBUG_ASN1 print_buffer_bin ( authp_data . data , authp_data . length , ""/tmp/kdc_auth_pack"" ) ; # endif OCTETDATA_TO_KRB5DATA ( & authp_data , & k5data ) ; switch ( ( int ) data -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : retval = k5int_decode_krb5_auth_pack ( & k5data , & auth_pack ) ; if ( retval ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>krb5_auth_pack\\n"" ) ; goto cleanup ; } retval = krb5_check_clockskew ( context , auth_pack -> pkAuthenticator . ctime ) ; if ( retval ) goto cleanup ; if ( auth_pack -> clientPublicValue != NULL ) { retval = server_check_dh ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , & auth_pack -> clientPublicValue -> algorithm . parameters , plgctx -> opts -> dh_min_bits ) ; if ( retval ) { pkiDebug ( ""bad<S2SV_blank>dh<S2SV_blank>parameters\\n"" ) ; goto cleanup ; } } else if ( ! is_signed ) { retval = KRB5KDC_ERR_PREAUTH_FAILED ; krb5_set_error_message ( context , retval , _ ( ""Anonymous<S2SV_blank>pkinit<S2SV_blank>without<S2SV_blank>DH<S2SV_blank>public<S2SV_blank>"" ""value<S2SV_blank>not<S2SV_blank>supported."" ) ) ; goto cleanup ; } der_req = cb -> request_body ( context , rock ) ; retval = krb5_c_make_checksum ( context , CKSUMTYPE_NIST_SHA , NULL , 0 , der_req , & cksum ) ; if ( retval ) { pkiDebug ( ""unable<S2SV_blank>to<S2SV_blank>calculate<S2SV_blank>AS<S2SV_blank>REQ<S2SV_blank>checksum\\n"" ) ; goto cleanup ; } if ( cksum . length != auth_pack -> pkAuthenticator . paChecksum . length || k5_bcmp ( cksum . contents , auth_pack -> pkAuthenticator . paChecksum . contents , cksum . length ) != 0 ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>match<S2SV_blank>the<S2SV_blank>checksum\\n"" ) ; # ifdef DEBUG_CKSUM pkiDebug ( ""calculating<S2SV_blank>checksum<S2SV_blank>on<S2SV_blank>buf<S2SV_blank>size<S2SV_blank>(%d)\\n"" , req_pkt -> length ) ; print_buffer ( req_pkt -> data , req_pkt -> length ) ; pkiDebug ( ""received<S2SV_blank>checksum<S2SV_blank>type=%d<S2SV_blank>size=%d<S2SV_blank>"" , auth_pack -> pkAuthenticator . paChecksum . checksum_type , auth_pack -> pkAuthenticator . paChecksum . length ) ; print_buffer ( auth_pack -> pkAuthenticator . paChecksum . contents , auth_pack -> pkAuthenticator . paChecksum . length ) ; pkiDebug ( ""expected<S2SV_blank>checksum<S2SV_blank>type=%d<S2SV_blank>size=%d<S2SV_blank>"" , cksum . checksum_type , cksum . length ) ; print_buffer ( cksum . contents , cksum . length ) ; # endif retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED ; goto cleanup ; } if ( reqp -> kdcPkId . data != NULL ) { int valid_kdcPkId = 0 ; retval = pkinit_check_kdc_pkid ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , ( unsigned char * ) reqp -> kdcPkId . data , reqp -> kdcPkId . length , & valid_kdcPkId ) ; if ( retval ) goto cleanup ; if ( ! valid_kdcPkId ) pkiDebug ( ""kdcPkId<S2SV_blank>in<S2SV_blank>AS_REQ<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>KDC\'s<S2SV_blank>cert"" ""RFC<S2SV_blank>says<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>and<S2SV_blank>proceed\\n"" ) ; } reqctx -> rcv_auth_pack = auth_pack ; auth_pack = NULL ; break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : retval = k5int_decode_krb5_auth_pack_draft9 ( & k5data , & auth_pack9 ) ; if ( retval ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>krb5_auth_pack_draft9\\n"" ) ; goto cleanup ; } if ( auth_pack9 -> clientPublicValue != NULL ) { retval = server_check_dh ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , & auth_pack9 -> clientPublicValue -> algorithm . parameters , plgctx -> opts -> dh_min_bits ) ; if ( retval ) { pkiDebug ( ""bad<S2SV_blank>dh<S2SV_blank>parameters\\n"" ) ; goto cleanup ; } } reqctx -> rcv_auth_pack9 = auth_pack9 ; auth_pack9 = NULL ; break ; } enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; modreq = ( krb5_kdcpreauth_modreq ) reqctx ; reqctx = NULL ; cleanup : if ( retval && data -> pa_type == KRB5_PADATA_PK_AS_REQ ) { pkiDebug ( ""pkinit_verify_padata<S2SV_blank>failed:<S2SV_blank>creating<S2SV_blank>e-data\\n"" ) ; if ( pkinit_create_edata ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , plgctx -> opts , retval , & e_data ) ) pkiDebug ( ""pkinit_create_edata<S2SV_blank>failed\\n"" ) ; } switch ( ( int ) data -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : free_krb5_pa_pk_as_req ( & reqp ) ; free ( cksum . contents ) ; break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : free_krb5_pa_pk_as_req_draft9 ( & reqp9 ) ; } free ( authp_data . data ) ; free ( krb5_authz . data ) ; if ( reqctx != NULL ) pkinit_fini_kdc_req_context ( context , reqctx ) ; free_krb5_auth_pack ( & auth_pack ) ; free_krb5_auth_pack_draft9 ( context , & auth_pack9 ) ; ( * respond ) ( arg , retval , modreq , e_data , NULL ) ; }
","<S2SV_ModStart> ( arg , EINVAL <S2SV_ModEnd> , NULL , <S2SV_ModStart> ( arg , EINVAL <S2SV_ModEnd> , NULL ,
",krb5@krb5/e3b5a5e5267818c97750b266df50b6a3d4649604,CVE-2015-2694,https://github.com/krb5/krb5/commit/e3b5a5e5267818c97750b266df50b6a3d4649604,2015-05-25T19:59Z,"<S2SV_StartBug> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <S2SV_EndBug>"
5922,CWE-74,"gboolean flatpak_run_app ( FlatpakDecomposed * app_ref , FlatpakDeploy * app_deploy , FlatpakContext * extra_context , const char * custom_runtime , const char * custom_runtime_version , const char * custom_runtime_commit , int parent_pid , FlatpakRunFlags flags , const char * cwd , const char * custom_command , char * args [ ] , int n_args , int instance_id_fd , char * * instance_dir_out , GCancellable * cancellable , GError * * error ) { g_autoptr ( FlatpakDeploy ) runtime_deploy = NULL ; g_autoptr ( GBytes ) runtime_deploy_data = NULL ; g_autoptr ( GBytes ) app_deploy_data = NULL ; g_autoptr ( GFile ) app_files = NULL ; g_autoptr ( GFile ) runtime_files = NULL ; g_autoptr ( GFile ) bin_ldconfig = NULL ; g_autoptr ( GFile ) app_id_dir = NULL ; g_autoptr ( GFile ) real_app_id_dir = NULL ; g_autofree char * default_runtime_pref = NULL ; g_autoptr ( FlatpakDecomposed ) default_runtime = NULL ; g_autofree char * default_command = NULL ; g_autoptr ( GKeyFile ) metakey = NULL ; g_autoptr ( GKeyFile ) runtime_metakey = NULL ; g_autoptr ( FlatpakBwrap ) bwrap = NULL ; const char * command = ""/bin/sh"" ; g_autoptr ( GError ) my_error = NULL ; g_autoptr ( FlatpakDecomposed ) runtime_ref = NULL ; int i ; g_autoptr ( GPtrArray ) previous_app_id_dirs = NULL ; g_autofree char * app_id = NULL ; g_autofree char * app_arch = NULL ; g_autofree char * app_info_path = NULL ; g_autofree char * instance_id_host_dir = NULL ; g_autoptr ( FlatpakContext ) app_context = NULL ; g_autoptr ( FlatpakContext ) overrides = NULL ; g_autoptr ( FlatpakExports ) exports = NULL ; g_autofree char * commandline = NULL ; g_autofree char * doc_mount_path = NULL ; g_autofree char * app_extensions = NULL ; g_autofree char * runtime_extensions = NULL ; g_autofree char * checksum = NULL ; int ld_so_fd = - 1 ; g_autoptr ( GFile ) runtime_ld_so_conf = NULL ; gboolean generate_ld_so_conf = TRUE ; gboolean use_ld_so_cache = TRUE ; gboolean sandboxed = ( flags & FLATPAK_RUN_FLAG_SANDBOX ) != 0 ; gboolean parent_expose_pids = ( flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS ) != 0 ; gboolean parent_share_pids = ( flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS ) != 0 ; struct stat s ; if ( ! check_sudo ( error ) ) return FALSE ; app_id = flatpak_decomposed_dup_id ( app_ref ) ; app_arch = flatpak_decomposed_dup_arch ( app_ref ) ; if ( ! check_parental_controls ( app_ref , app_deploy , cancellable , error ) ) return FALSE ; bwrap = flatpak_bwrap_new ( NULL ) ; flatpak_bwrap_add_arg ( bwrap , flatpak_get_bwrap ( ) ) ; if ( app_deploy == NULL ) { g_assert ( flatpak_decomposed_is_runtime ( app_ref ) ) ; default_runtime_pref = flatpak_decomposed_dup_pref ( app_ref ) ; } else { const gchar * key ; app_deploy_data = flatpak_deploy_get_deploy_data ( app_deploy , FLATPAK_DEPLOY_VERSION_ANY , cancellable , error ) ; if ( app_deploy_data == NULL ) return FALSE ; if ( ( flags & FLATPAK_RUN_FLAG_DEVEL ) != 0 ) key = FLATPAK_METADATA_KEY_SDK ; else key = FLATPAK_METADATA_KEY_RUNTIME ; metakey = flatpak_deploy_get_metadata ( app_deploy ) ; default_runtime_pref = g_key_file_get_string ( metakey , FLATPAK_METADATA_GROUP_APPLICATION , key , & my_error ) ; if ( my_error ) { g_propagate_error ( error , g_steal_pointer ( & my_error ) ) ; return FALSE ; } } default_runtime = flatpak_decomposed_new_from_pref ( FLATPAK_KINDS_RUNTIME , default_runtime_pref , error ) ; if ( default_runtime == NULL ) return FALSE ; if ( custom_runtime != NULL || custom_runtime_version != NULL ) { g_auto ( GStrv ) custom_runtime_parts = NULL ; const char * custom_runtime_id = NULL ; const char * custom_runtime_arch = NULL ; if ( custom_runtime ) { custom_runtime_parts = g_strsplit ( custom_runtime , ""/"" , 0 ) ; for ( i = 0 ; i < 3 && custom_runtime_parts [ i ] != NULL ; i ++ ) { if ( strlen ( custom_runtime_parts [ i ] ) > 0 ) { if ( i == 0 ) custom_runtime_id = custom_runtime_parts [ i ] ; if ( i == 1 ) custom_runtime_arch = custom_runtime_parts [ i ] ; if ( i == 2 && custom_runtime_version == NULL ) custom_runtime_version = custom_runtime_parts [ i ] ; } } } runtime_ref = flatpak_decomposed_new_from_decomposed ( default_runtime , FLATPAK_KINDS_RUNTIME , custom_runtime_id , custom_runtime_arch , custom_runtime_version , error ) ; if ( runtime_ref == NULL ) return FALSE ; } else runtime_ref = flatpak_decomposed_ref ( default_runtime ) ; runtime_deploy = flatpak_find_deploy_for_ref ( flatpak_decomposed_get_ref ( runtime_ref ) , custom_runtime_commit , NULL , cancellable , error ) ; if ( runtime_deploy == NULL ) return FALSE ; runtime_deploy_data = flatpak_deploy_get_deploy_data ( runtime_deploy , FLATPAK_DEPLOY_VERSION_ANY , cancellable , error ) ; if ( runtime_deploy_data == NULL ) return FALSE ; runtime_metakey = flatpak_deploy_get_metadata ( runtime_deploy ) ; app_context = flatpak_app_compute_permissions ( metakey , runtime_metakey , error ) ; if ( app_context == NULL ) return FALSE ; if ( app_deploy != NULL ) { overrides = flatpak_deploy_get_overrides ( app_deploy ) ; flatpak_context_merge ( app_context , overrides ) ; } if ( sandboxed ) flatpak_context_make_sandboxed ( app_context ) ; if ( extra_context ) flatpak_context_merge ( app_context , extra_context ) ; runtime_files = flatpak_deploy_get_files ( runtime_deploy ) ; bin_ldconfig = g_file_resolve_relative_path ( runtime_files , ""bin/ldconfig"" ) ; if ( ! g_file_query_exists ( bin_ldconfig , NULL ) ) use_ld_so_cache = FALSE ; if ( app_deploy != NULL ) { g_autofree const char * * previous_ids = NULL ; gsize len = 0 ; gboolean do_migrate ; real_app_id_dir = flatpak_get_data_dir ( app_id ) ; app_files = flatpak_deploy_get_files ( app_deploy ) ; previous_app_id_dirs = g_ptr_array_new_with_free_func ( g_object_unref ) ; previous_ids = flatpak_deploy_data_get_previous_ids ( app_deploy_data , & len ) ; do_migrate = ! g_file_query_exists ( real_app_id_dir , cancellable ) ; for ( i = len - 1 ; i >= 0 ; i -- ) { g_autoptr ( GFile ) previous_app_id_dir = NULL ; g_autoptr ( GFileInfo ) previous_app_id_dir_info = NULL ; g_autoptr ( GError ) local_error = NULL ; previous_app_id_dir = flatpak_get_data_dir ( previous_ids [ i ] ) ; previous_app_id_dir_info = g_file_query_info ( previous_app_id_dir , G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK "","" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , cancellable , & local_error ) ; if ( previous_app_id_dir_info == NULL ) { if ( ! g_error_matches ( local_error , G_IO_ERROR , G_IO_ERROR_NOT_FOUND ) && do_migrate ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>migrate<S2SV_blank>from<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , local_error -> message ) ; do_migrate = FALSE ; } g_clear_error ( & local_error ) ; continue ; } if ( do_migrate ) { do_migrate = FALSE ; if ( ! flatpak_file_rename ( previous_app_id_dir , real_app_id_dir , cancellable , & local_error ) ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>migrate<S2SV_blank>old<S2SV_blank>app<S2SV_blank>data<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>new<S2SV_blank>name<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , app_id , local_error -> message ) ; } else { if ( ! g_file_make_symbolic_link ( previous_app_id_dir , app_id , cancellable , & local_error ) ) { g_warning ( _ ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>while<S2SV_blank>migrating<S2SV_blank>%s:<S2SV_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , local_error -> message ) ; } } } g_ptr_array_add ( previous_app_id_dirs , g_steal_pointer ( & previous_app_id_dir ) ) ; } if ( ! flatpak_ensure_data_dir ( real_app_id_dir , cancellable , error ) ) return FALSE ; if ( ! sandboxed ) app_id_dir = g_object_ref ( real_app_id_dir ) ; } flatpak_run_apply_env_default ( bwrap , use_ld_so_cache ) ; flatpak_run_apply_env_vars ( bwrap , app_context ) ; flatpak_run_apply_env_prompt ( bwrap , app_id ) ; if ( real_app_id_dir ) { g_autoptr ( GFile ) sandbox_dir = g_file_get_child ( real_app_id_dir , ""sandbox"" ) ; flatpak_bwrap_set_env ( bwrap , ""FLATPAK_SANDBOX_DIR"" , flatpak_file_get_path_cached ( sandbox_dir ) , TRUE ) ; } flatpak_bwrap_add_args ( bwrap , ""--ro-bind"" , flatpak_file_get_path_cached ( runtime_files ) , ""/usr"" , ""--lock-file"" , ""/usr/.ref"" , NULL ) ; if ( app_files != NULL ) flatpak_bwrap_add_args ( bwrap , ""--ro-bind"" , flatpak_file_get_path_cached ( app_files ) , ""/app"" , ""--lock-file"" , ""/app/.ref"" , NULL ) ; else flatpak_bwrap_add_args ( bwrap , ""--dir"" , ""/app"" , NULL ) ; if ( metakey != NULL && ! flatpak_run_add_extension_args ( bwrap , metakey , app_ref , use_ld_so_cache , & app_extensions , cancellable , error ) ) return FALSE ; if ( ! flatpak_run_add_extension_args ( bwrap , runtime_metakey , runtime_ref , use_ld_so_cache , & runtime_extensions , cancellable , error ) ) return FALSE ; runtime_ld_so_conf = g_file_resolve_relative_path ( runtime_files , ""etc/ld.so.conf"" ) ; if ( lstat ( flatpak_file_get_path_cached ( runtime_ld_so_conf ) , & s ) == 0 ) generate_ld_so_conf = S_ISREG ( s . st_mode ) && s . st_size == 0 ; if ( use_ld_so_cache ) { checksum = calculate_ld_cache_checksum ( app_deploy_data , runtime_deploy_data , app_extensions , runtime_extensions ) ; ld_so_fd = regenerate_ld_cache ( bwrap -> argv , bwrap -> fds , app_id_dir , checksum , runtime_files , generate_ld_so_conf , cancellable , error ) ; if ( ld_so_fd == - 1 ) return FALSE ; flatpak_bwrap_add_fd ( bwrap , ld_so_fd ) ; } flags |= flatpak_context_get_run_flags ( app_context ) ; if ( ! flatpak_run_setup_base_argv ( bwrap , runtime_files , app_id_dir , app_arch , flags , error ) ) return FALSE ; if ( generate_ld_so_conf ) { if ( ! add_ld_so_conf ( bwrap , error ) ) return FALSE ; } if ( ld_so_fd != - 1 ) { flatpak_bwrap_add_arg ( bwrap , ""--ro-bind-data"" ) ; flatpak_bwrap_add_arg_printf ( bwrap , ""%d"" , ld_so_fd ) ; flatpak_bwrap_add_arg ( bwrap , ""/etc/ld.so.cache"" ) ; } if ( ! flatpak_run_add_app_info_args ( bwrap , app_files , app_deploy_data , app_extensions , runtime_files , runtime_deploy_data , runtime_extensions , app_id , flatpak_decomposed_get_branch ( app_ref ) , runtime_ref , app_id_dir , app_context , extra_context , sandboxed , FALSE , flags & FLATPAK_RUN_FLAG_DEVEL , & app_info_path , instance_id_fd , & instance_id_host_dir , error ) ) return FALSE ; if ( ! flatpak_run_add_dconf_args ( bwrap , app_id , metakey , error ) ) return FALSE ; if ( ! sandboxed && ! ( flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL ) ) add_document_portal_args ( bwrap , app_id , & doc_mount_path ) ; if ( ! flatpak_run_add_environment_args ( bwrap , app_info_path , flags , app_id , app_context , app_id_dir , previous_app_id_dirs , & exports , cancellable , error ) ) return FALSE ; if ( ( app_context -> shares & FLATPAK_CONTEXT_SHARED_NETWORK ) != 0 ) flatpak_run_add_resolved_args ( bwrap ) ; flatpak_run_add_journal_args ( bwrap ) ; add_font_path_args ( bwrap ) ; add_icon_path_args ( bwrap ) ; flatpak_bwrap_add_args ( bwrap , ""--symlink"" , ""/app/lib/debug/source"" , ""/run/build"" , ""--symlink"" , ""/usr/lib/debug/source"" , ""/run/build-runtime"" , NULL ) ; if ( cwd ) flatpak_bwrap_add_args ( bwrap , ""--chdir"" , cwd , NULL ) ; if ( parent_expose_pids || parent_share_pids ) { g_autofree char * userns_path = NULL ; g_autofree char * pidns_path = NULL ; g_autofree char * userns2_path = NULL ; int userns_fd , userns2_fd , pidns_fd ; if ( parent_pid == 0 ) return flatpak_fail ( error , ""No<S2SV_blank>parent<S2SV_blank>pid<S2SV_blank>specified"" ) ; userns_path = g_strdup_printf ( ""/proc/%d/root/run/.userns"" , parent_pid ) ; userns_fd = open_namespace_fd_if_needed ( userns_path , ""/proc/self/ns/user"" ) ; if ( userns_fd != - 1 ) { flatpak_bwrap_add_args_data_fd ( bwrap , ""--userns"" , userns_fd , NULL ) ; userns2_path = g_strdup_printf ( ""/proc/%d/ns/user"" , parent_pid ) ; userns2_fd = open_namespace_fd_if_needed ( userns2_path , userns_path ) ; if ( userns2_fd != - 1 ) flatpak_bwrap_add_args_data_fd ( bwrap , ""--userns2"" , userns2_fd , NULL ) ; } pidns_path = g_strdup_printf ( ""/proc/%d/ns/pid"" , parent_pid ) ; pidns_fd = open ( pidns_path , O_RDONLY | O_CLOEXEC ) ; if ( pidns_fd != - 1 ) flatpak_bwrap_add_args_data_fd ( bwrap , ""--pidns"" , pidns_fd , NULL ) ; } if ( custom_command ) { command = custom_command ; } else if ( metakey ) { default_command = g_key_file_get_string ( metakey , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_COMMAND , & my_error ) ; if ( my_error ) { g_propagate_error ( error , g_steal_pointer ( & my_error ) ) ; return FALSE ; } command = default_command ; } <S2SV_StartBug> if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) ) <S2SV_EndBug> return FALSE ; flatpak_bwrap_add_arg ( bwrap , command ) ; if ( ! add_rest_args ( bwrap , app_id , exports , ( flags & FLATPAK_RUN_FLAG_FILE_FORWARDING ) != 0 , doc_mount_path , args , n_args , error ) ) return FALSE ; flatpak_bwrap_finish ( bwrap ) ; commandline = flatpak_quote_argv ( ( const char * * ) bwrap -> argv -> pdata , - 1 ) ; g_debug ( ""Running<S2SV_blank>\'%s\'"" , commandline ) ; if ( ( flags & FLATPAK_RUN_FLAG_BACKGROUND ) != 0 ) { GPid child_pid ; char pid_str [ 64 ] ; g_autofree char * pid_path = NULL ; GSpawnFlags spawn_flags ; spawn_flags = G_SPAWN_SEARCH_PATH ; if ( flags & FLATPAK_RUN_FLAG_DO_NOT_REAP ) spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD ; spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN ; <S2SV_StartBug> if ( ! g_spawn_async ( NULL , <S2SV_EndBug> ( char * * ) bwrap -> argv -> pdata , bwrap -> envp , spawn_flags , flatpak_bwrap_child_setup_cb , bwrap -> fds , & child_pid , error ) ) return FALSE ; g_snprintf ( pid_str , sizeof ( pid_str ) , ""%d"" , child_pid ) ; pid_path = g_build_filename ( instance_id_host_dir , ""pid"" , NULL ) ; g_file_set_contents ( pid_path , pid_str , - 1 , NULL ) ; } else { char pid_str [ 64 ] ; g_autofree char * pid_path = NULL ; g_snprintf ( pid_str , sizeof ( pid_str ) , ""%d"" , getpid ( ) ) ; pid_path = g_build_filename ( instance_id_host_dir , ""pid"" , NULL ) ; g_file_set_contents ( pid_path , pid_str , - 1 , NULL ) ; flatpak_bwrap_child_setup ( bwrap -> fds , FALSE ) ; <S2SV_StartBug> if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 ) <S2SV_EndBug> { g_set_error_literal ( error , G_IO_ERROR , g_io_error_from_errno ( errno ) , _ ( ""Unable<S2SV_blank>to<S2SV_blank>start<S2SV_blank>app"" ) ) ; return FALSE ; } } if ( instance_dir_out ) * instance_dir_out = g_steal_pointer ( & instance_id_host_dir ) ; return TRUE ; }
","<S2SV_ModStart> default_command ; } flatpak_bwrap_envp_to_args ( bwrap ) ; <S2SV_ModStart> |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN ; g_assert ( bwrap -> envp != NULL ) ; g_assert ( bwrap -> envp [ 0 ] == NULL ) ; <S2SV_ModStart> FALSE ) ; g_assert ( bwrap -> envp != NULL ) ; g_assert ( bwrap -> envp [ 0 ] == NULL ) ;
",flatpak@flatpak/6d1773d2a54dde9b099043f07a2094a4f1c2f486,CVE-2021-21261,https://github.com/flatpak/flatpak/commit/6d1773d2a54dde9b099043f07a2094a4f1c2f486,2021-01-14T20:15Z,"<S2SV_StartBug> if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! g_spawn_async ( NULL , <S2SV_EndBug> <S2SV_StartBug> if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 ) <S2SV_EndBug>"
7656,CWE-401,"static int rsi_send_beacon ( struct rsi_common * common ) { struct sk_buff * skb = NULL ; u8 dword_align_bytes = 0 ; skb = dev_alloc_skb ( MAX_MGMT_PKT_SIZE ) ; if ( ! skb ) return - ENOMEM ; memset ( skb -> data , 0 , MAX_MGMT_PKT_SIZE ) ; dword_align_bytes = ( ( unsigned long ) skb -> data & 0x3f ) ; if ( dword_align_bytes ) skb_pull ( skb , ( 64 - dword_align_bytes ) ) ; if ( rsi_prepare_beacon ( common , skb ) ) { rsi_dbg ( ERR_ZONE , ""Failed<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>beacon\\n"" ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> } skb_queue_tail ( & common -> tx_queue [ MGMT_BEACON_Q ] , skb ) ; rsi_set_event ( & common -> tx_thread . event ) ; rsi_dbg ( DATA_TX_ZONE , ""%s:<S2SV_blank>Added<S2SV_blank>to<S2SV_blank>beacon<S2SV_blank>queue\\n"" , __func__ ) ; return 0 ; }
","<S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>beacon\\n"" ) ; dev_kfree_skb ( skb ) ;
",torvalds@linux/d563131ef23cbc756026f839a82598c8445bc45f,CVE-2019-19071,https://github.com/torvalds/linux/commit/d563131ef23cbc756026f839a82598c8445bc45f,2019-11-18T06:15Z,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug>
7865,CWE-20,"error_t enc28j60UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint8_t hashTable [ 8 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""Updating<S2SV_blank>MAC<S2SV_blank>filter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = enc28j60CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 23 ) & 0x3F ; hashTable [ k / 8 ] |= ( 1 << ( k % 8 ) ) ; } } <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT0 , hashTable [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT1 , hashTable [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT2 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT3 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT4 , hashTable [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT5 , hashTable [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT6 , hashTable [ 6 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT7 , hashTable [ 7 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT6 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT7 ) ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC28J60_EHT0 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT1 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT5 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT6 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT7 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT0 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT4 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT5 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT6 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT7 <S2SV_ModEnd> ) ) ;
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT0 , hashTable [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT1 , hashTable [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT2 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT3 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT4 , hashTable [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT5 , hashTable [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT6 , hashTable [ 6 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT7 , hashTable [ 7 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT6 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT7 ) ) ; <S2SV_EndBug>"
3972,CWE-59,"int rpmPackageFilesInstall ( rpmts ts , rpmte te , rpmfiles files , rpmpsm psm , char * * failedFile ) { FD_t payload = rpmtePayload ( te ) ; rpmfi fi = rpmfiNewArchiveReader ( payload , files , RPMFI_ITER_READ_ARCHIVE ) ; rpmfs fs = rpmteGetFileStates ( te ) ; rpmPlugins plugins = rpmtsPlugins ( ts ) ; struct stat sb ; int saveerrno = errno ; int rc = 0 ; int nodigest = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOFILEDIGEST ) ? 1 : 0 ; int nofcaps = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOCAPS ) ? 1 : 0 ; int firsthardlink = - 1 ; int skip ; rpmFileAction action ; char * tid = NULL ; const char * suffix ; char * fpath = NULL ; if ( fi == NULL ) { rc = RPMERR_BAD_MAGIC ; goto exit ; } rasprintf ( & tid , "";%08x"" , ( unsigned ) rpmtsGetTid ( ts ) ) ; rc = fsmMkdirs ( files , fs , plugins ) ; while ( ! rc ) { rc = rpmfiNext ( fi ) ; if ( rc < 0 ) { if ( rc == RPMERR_ITER_END ) rc = 0 ; break ; } action = rpmfsGetAction ( fs , rpmfiFX ( fi ) ) ; skip = XFA_SKIPPING ( action ) ; suffix = S_ISDIR ( rpmfiFMode ( fi ) ) ? NULL : tid ; if ( action != FA_TOUCH ) { fpath = fsmFsPath ( fi , suffix ) ; } else { fpath = fsmFsPath ( fi , """" ) ; } rc = rpmfiStat ( fi , 1 , & sb ) ; fsmDebug ( fpath , action , & sb ) ; if ( rc ) break ; rc = rpmpluginsCallFsmFilePre ( plugins , fi , fpath , sb . st_mode , action ) ; if ( rc ) { skip = 1 ; } else { setFileState ( fs , rpmfiFX ( fi ) ) ; } if ( ! skip ) { int setmeta = 1 ; if ( ! suffix ) { rc = fsmBackup ( fi , action ) ; } if ( ! suffix ) { <S2SV_StartBug> rc = fsmVerify ( fpath , fi ) ; <S2SV_EndBug> } else { rc = ( action == FA_TOUCH ) ? 0 : RPMERR_ENOENT ; } if ( S_ISREG ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ; } } else if ( S_ISDIR ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { mode_t mode = sb . st_mode ; mode &= ~ 07777 ; mode |= 00700 ; rc = fsmMkdir ( fpath , mode ) ; } } else if ( S_ISLNK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmSymlink ( rpmfiFLink ( fi ) , fpath ) ; } } else if ( S_ISFIFO ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfifo ( fpath , 0000 ) ; } } else if ( S_ISCHR ( sb . st_mode ) || S_ISBLK ( sb . st_mode ) || S_ISSOCK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMknod ( fpath , sb . st_mode , sb . st_rdev ) ; } } else { if ( ! IS_DEV_LOG ( fpath ) ) rc = RPMERR_UNKNOWN_FILETYPE ; } if ( ! rc && setmeta ) { rc = fsmSetmeta ( fpath , fi , plugins , action , & sb , nofcaps ) ; } } else if ( firsthardlink >= 0 && rpmfiArchiveHasContent ( fi ) ) { char * fn = rpmfilesFN ( files , firsthardlink ) ; rc = expandRegular ( fi , fn , psm , 0 , nodigest , 0 ) ; firsthardlink = - 1 ; free ( fn ) ; } if ( rc ) { if ( ! skip ) { if ( suffix && ( action != FA_TOUCH ) ) { ( void ) fsmRemove ( fpath , sb . st_mode ) ; } errno = saveerrno ; } } else { rpmpsmNotify ( psm , RPMCALLBACK_INST_PROGRESS , rpmfiArchiveTell ( fi ) ) ; if ( ! skip ) { if ( suffix ) rc = fsmBackup ( fi , action ) ; if ( ! rc ) rc = fsmCommit ( & fpath , fi , action , suffix ) ; } } if ( rc ) * failedFile = xstrdup ( fpath ) ; rpmpluginsCallFsmFilePost ( plugins , fi , fpath , sb . st_mode , action , rc ) ; fpath = _free ( fpath ) ; } rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_UNCOMPRESS ) , fdOp ( payload , FDSTAT_READ ) ) ; rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_DIGEST ) , fdOp ( payload , FDSTAT_DIGEST ) ) ; exit : rpmfiArchiveClose ( fi ) ; rpmfiFree ( fi ) ; Fclose ( payload ) ; free ( tid ) ; free ( fpath ) ; return rc ; }
","<S2SV_ModStart> fpath , fi , & sb
",rpm-software-management@rpm/f2d3be2a8741234faaa96f5fd05fdfdc75779a79,CVE-2017-7500,https://github.com/rpm-software-management/rpm/commit/f2d3be2a8741234faaa96f5fd05fdfdc75779a79,2018-08-13T17:29Z,"<S2SV_StartBug> rc = fsmVerify ( fpath , fi ) ; <S2SV_EndBug>"
2875,CWE-310,"static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; <S2SV_StartBug> snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ; <S2SV_EndBug> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher . <S2SV_ModStart> . type , ""cipher"" , sizeof ( rcipher . type ) <S2SV_ModEnd> ) ; rcipher
",torvalds@linux/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,CVE-2013-2548,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,2013-03-15T20:55Z,"<S2SV_StartBug> snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ; <S2SV_EndBug>"
3626,CWE-125,"static void rpl_dao_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dao * dao = ( const struct nd_rpl_dao * ) bp ; const char * dagid_str = ""<elided>"" ; ND_TCHECK ( * dao ) ; if ( length < ND_RPL_DAO_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAO_MIN_LEN ; length -= ND_RPL_DAO_MIN_LEN ; if ( RPL_DAO_D ( dao -> rpl_flags ) ) { ND_TCHECK2 ( dao -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , dao -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u%s%s,%02x]"" , dagid_str , dao -> rpl_daoseq , dao -> rpl_instanceid , RPL_DAO_K ( dao -> rpl_flags ) ? "",acK"" : """" , RPL_DAO_D ( dao -> rpl_flags ) ? "",Dagid"" : """" , dao -> rpl_flags ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , ""<S2SV_blank>[|length<S2SV_blank>too<S2SV_blank>short]"" ) ) ; return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug>"
3741,CWE-119,"static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; one = 1 ; image = AcquireImage ( image_info ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; Rec2 . RecordLength = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> x_resolution = BitmapHeader1 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > <S2SV_StartBug> ( Rec2 . RecordLength - 2 - 2 ) / 3 ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> x_resolution = BitmapHeader2 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp <= 16 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ReplaceImageInList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( BImgBuff , i , image , bpp ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }
","<S2SV_ModStart> ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
",ImageMagick@ImageMagick/e04cf3e9524f50ca336253513d977224e083b816,CVE-2017-16546,https://github.com/ImageMagick/ImageMagick/commit/e04cf3e9524f50ca336253513d977224e083b816,2017-11-05T22:29Z,<S2SV_StartBug> ( Rec2 . RecordLength - 2 - 2 ) / 3 ) <S2SV_EndBug>
839,CWE-369,"tdata_t _TIFFmalloc ( tsize_t s ) <S2SV_StartBug> { <S2SV_EndBug> return ( malloc ( ( size_t ) s ) ) ; }
","<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
",vadz@libtiff/3c5eb8b1be544e41d2c336191bc4936300ad7543,CVE-2014-8130,https://github.com/vadz/libtiff/commit/3c5eb8b1be544e41d2c336191bc4936300ad7543,2018-03-12T02:29Z,<S2SV_StartBug> { <S2SV_EndBug>
2705,CWE-125,"int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( ""%s:<S2SV_blank>can\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!"" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; if ( ! strncmp ( caf_chunk_header . mChunkType , ""desc"" , 4 ) ) { int supported = TRUE ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; if ( debug_logging_mode ) { char formatstr [ 5 ] ; memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; formatstr [ 4 ] = 0 ; error_line ( ""format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g"" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; error_line ( ""packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames"" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; error_line ( ""channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d"" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; } if ( strncmp ( caf_audio_format . mFormatID , ""lpcm"" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ; else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ; else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ; else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ; else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; config -> num_channels = caf_audio_format . mChannelsPerFrame ; config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ; if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ; if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point"" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" , config -> bytes_per_sample ) ; } } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""chan"" , 4 ) ) { <S2SV_StartBug> CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; <S2SV_EndBug> if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || <S2SV_StartBug> ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || <S2SV_EndBug> bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; chan_chunk = 1 ; if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { error_line ( ""this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } switch ( caf_channel_layout -> mChannelLayoutTag ) { case kCAFChannelLayoutTag_UseChannelDescriptions : { CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; int label , cindex = 0 , idents = 0 ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) { error_line ( ""channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\'chan\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } if ( num_descriptions >= 256 ) { error_line ( ""%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!"" ) ; break ; } channel_reorder = malloc ( num_descriptions ) ; memset ( channel_reorder , - 1 , num_descriptions ) ; channel_identities = malloc ( num_descriptions + 1 ) ; for ( i = 0 ; i < num_descriptions ; ++ i ) { WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; if ( debug_logging_mode ) error_line ( ""chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d"" , i + 1 , descriptions [ i ] . mChannelLabel ) ; } for ( label = 1 ; label <= 18 ; ++ label ) for ( i = 0 ; i < num_descriptions ; ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) { config -> channel_mask |= 1 << ( label - 1 ) ; channel_reorder [ i ] = cindex ++ ; break ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { uint32_t clabel = descriptions [ i ] . mChannelLabel ; if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ; else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; else { error_line ( ""warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d"" , clabel ) ; channel_identities [ idents ++ ] = 0xff ; } channel_reorder [ i ] = cindex ++ ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] != i ) break ; if ( i == num_descriptions ) { free ( channel_reorder ) ; channel_reorder = NULL ; } else { config -> qmode |= QMODE_REORDERED_CHANS ; channel_layout = num_descriptions ; } if ( ! idents ) { free ( channel_identities ) ; channel_identities = NULL ; } else channel_identities [ idents ] = 0 ; if ( debug_logging_mode ) { error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS"" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ; if ( channel_reorder && num_descriptions <= 8 ) { char reorder_string [ ] = ""12345678"" ; for ( i = 0 ; i < num_descriptions ; ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ; reorder_string [ i ] = 0 ; error_line ( ""reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\""%s\\""\\n"" , reorder_string ) ; } } } break ; case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ; if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x"" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; break ; default : for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { config -> channel_mask = layouts [ i ] . mChannelBitmap ; channel_layout = layouts [ i ] . mChannelLayoutTag ; if ( layouts [ i ] . mChannelReorder ) { channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; config -> qmode |= QMODE_REORDERED_CHANS ; } if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s"" , channel_layout , config -> channel_mask , channel_reorder ? ""yes"" : ""no"" , channel_identities ? ""yes"" : ""no"" ) ; break ; } if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned"" , caf_channel_layout -> mChannelLayoutTag ) ; break ; } free ( caf_channel_layout ) ; } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""data"" , 4 ) ) { uint32_t mEditCount ; if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } break ; } else { <S2SV_StartBug> int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; <S2SV_EndBug> <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_identities ) free ( channel_identities ) ; if ( channel_layout || channel_reorder ) { if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { error_line ( ""problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)"" ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_reorder ) free ( channel_reorder ) ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> CAFChannelLayout * caf_channel_layout <S2SV_ModEnd> ; if ( <S2SV_ModStart> CAFChannelLayout ) || caf_chunk_header . mChunkSize > 1024 ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( <S2SV_ModStart> } else { uint32_t <S2SV_ModEnd> bytes_to_copy = ( <S2SV_ModStart> ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
",dbry@WavPack/8e3fe45a7bac31d9a3b558ae0079e2d92a04799e,CVE-2018-7254,https://github.com/dbry/WavPack/commit/8e3fe45a7bac31d9a3b558ae0079e2d92a04799e,2018-02-19T23:29Z,"<S2SV_StartBug> CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; <S2SV_EndBug> <S2SV_StartBug> ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || <S2SV_EndBug> <S2SV_StartBug> int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; <S2SV_EndBug> <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug>"
1179,CWE-125,"static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , <S2SV_StartBug> int tstype ) <S2SV_EndBug> { struct sock_exterr_skb * serr ; <S2SV_StartBug> int err ; <S2SV_EndBug> serr = SKB_EXT_ERR ( skb ) ; memset ( serr , 0 , sizeof ( * serr ) ) ; serr -> ee . ee_errno = ENOMSG ; serr -> ee . ee_origin = SO_EE_ORIGIN_TIMESTAMPING ; <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug> if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) { serr -> ee . ee_data = skb_shinfo ( skb ) -> tskey ; if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) serr -> ee . ee_data -= sk -> sk_tskey ; } err = sock_queue_err_skb ( sk , skb ) ; if ( err ) kfree_skb ( skb ) ; }
","<S2SV_ModStart> , int tstype , bool opt_stats <S2SV_ModStart> ; int err ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ee_info = tstype ; serr -> opt_stats = opt_stats
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,<S2SV_StartBug> int tstype ) <S2SV_EndBug> <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug>
227,CWE-17,"static int udf_readdir ( struct file * file , struct dir_context * ctx ) { struct inode * dir = file_inode ( file ) ; struct udf_inode_info * iinfo = UDF_I ( dir ) ; struct udf_fileident_bh fibh = { . sbh = NULL , . ebh = NULL } ; struct fileIdentDesc * fi = NULL ; struct fileIdentDesc cfi ; int block , iblock ; loff_t nf_pos ; int flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint16_t liu ; uint8_t lfi ; loff_t size = udf_ext0_offset ( dir ) + dir -> i_size ; struct buffer_head * tmp , * bha [ 16 ] ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; int i , num , ret = 0 ; struct extent_position epos = { NULL , 0 , { 0 , 0 } } ; if ( ctx -> pos == 0 ) { if ( ! dir_emit_dot ( file , ctx ) ) return 0 ; ctx -> pos = 1 ; } nf_pos = ( ctx -> pos - 1 ) << 2 ; if ( nf_pos >= size ) goto out ; fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) { ret = - ENOMEM ; goto out ; } if ( nf_pos == 0 ) nf_pos = udf_ext0_offset ( dir ) ; fibh . soffset = fibh . eoffset = nf_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( iinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { if ( inode_bmap ( dir , nf_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) { ret = - ENOENT ; goto out ; } block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) epos . offset -= sizeof ( struct short_ad ) ; else if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) epos . offset -= sizeof ( struct long_ad ) ; } else { offset = 0 ; } if ( ! ( fibh . sbh = fibh . ebh = udf_tread ( dir -> i_sb , block ) ) ) { ret = - EIO ; goto out ; } if ( ! ( offset & ( ( 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ) - 1 ) ) ) { i = 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ; if ( i + offset > ( elen >> dir -> i_sb -> s_blocksize_bits ) ) i = ( elen >> dir -> i_sb -> s_blocksize_bits ) - offset ; for ( num = 0 ; i > 0 ; i -- ) { block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset + i ) ; tmp = udf_tgetblk ( dir -> i_sb , block ) ; if ( tmp && ! buffer_uptodate ( tmp ) && ! buffer_locked ( tmp ) ) bha [ num ++ ] = tmp ; else brelse ( tmp ) ; } if ( num ) { ll_rw_block ( READA , num , bha ) ; for ( i = 0 ; i < num ; i ++ ) brelse ( bha [ i ] ) ; } } } while ( nf_pos < size ) { struct kernel_lb_addr tloc ; ctx -> pos = ( nf_pos >> 2 ) + 1 ; fi = udf_fileident_read ( dir , & nf_pos , & fibh , & cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out ; liu = le16_to_cpu ( cfi . lengthOfImpUse ) ; lfi = cfi . lengthFileIdent ; if ( fibh . sbh == fibh . ebh ) { nameptr = fi -> fileIdent + liu ; } else { int poffset ; poffset = fibh . soffset + sizeof ( struct fileIdentDesc ) + liu + lfi ; if ( poffset >= lfi ) { nameptr = ( char * ) ( fibh . ebh -> b_data + poffset - lfi ) ; } else { nameptr = fname ; memcpy ( nameptr , fi -> fileIdent + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh . ebh -> b_data , poffset ) ; } } if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) continue ; } if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) continue ; } if ( cfi . fileCharacteristics & FID_FILE_CHAR_PARENT ) { if ( ! dir_emit_dotdot ( file , ctx ) ) goto out ; continue ; } <S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> if ( ! flen ) continue ; tloc = lelb_to_cpu ( cfi . icb . extLocation ) ; iblock = udf_get_lb_pblock ( dir -> i_sb , & tloc , 0 ) ; if ( ! dir_emit ( ctx , fname , flen , iblock , DT_UNKNOWN ) ) goto out ; } ctx -> pos = ( nf_pos >> 2 ) + 1 ; out : if ( fibh . sbh != fibh . ebh ) brelse ( fibh . ebh ) ; brelse ( fibh . sbh ) ; brelse ( epos . bh ) ; kfree ( fname ) ; return ret ; }
","<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z,"<S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug>"
2033,CWE-119,"<S2SV_StartBug> void open_input_file ( struct VpxInputContext * input ) { <S2SV_EndBug> input -> file = strcmp ( input -> filename , ""-"" ) ? fopen ( input -> filename , ""rb"" ) : set_binary_mode ( stdin ) ; if ( ! input -> file ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>input<S2SV_blank>file"" ) ; if ( ! fseeko ( input -> file , 0 , SEEK_END ) ) { input -> length = ftello ( input -> file ) ; rewind ( input -> file ) ; } <S2SV_StartBug> input -> detect . buf_read = fread ( input -> detect . buf , 1 , 4 , input -> file ) ; <S2SV_EndBug> input -> detect . position = 0 ; if ( input -> detect . buf_read == 4 && file_is_y4m ( input -> detect . buf ) ) { if ( y4m_input_open ( & input -> y4m , input -> file , input -> detect . buf , 4 , input -> only_i420 ) >= 0 ) { input -> file_type = FILE_TYPE_Y4M ; input -> width = input -> y4m . pic_w ; input -> height = input -> y4m . pic_h ; <S2SV_StartBug> input -> framerate . numerator = input -> y4m . fps_n ; <S2SV_EndBug> input -> framerate . denominator = input -> y4m . fps_d ; <S2SV_StartBug> input -> use_i420 = 0 ; <S2SV_EndBug> } else fatal ( ""Unsupported<S2SV_blank>Y4M<S2SV_blank>stream."" ) ; } else if ( input -> detect . buf_read == 4 && fourcc_is_ivf ( input -> detect . buf ) ) { fatal ( ""IVF<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>as<S2SV_blank>input."" ) ; } else { input -> file_type = FILE_TYPE_RAW ; } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> } input -> pixel_aspect_ratio . numerator = 1 ; input -> pixel_aspect_ratio . denominator = 1 ; input -> <S2SV_ModStart> ; input -> pixel_aspect_ratio . numerator = input -> y4m . par_n ; input -> pixel_aspect_ratio . denominator = input -> y4m . par_d ; input -> <S2SV_ModStart> ; input -> fmt = input -> y4m . vpx_fmt ; input -> bit_depth = input -> y4m . bit_depth <S2SV_ModEnd> ; } else
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> void open_input_file ( struct VpxInputContext * input ) { <S2SV_EndBug> <S2SV_StartBug> input -> detect . buf_read = fread ( input -> detect . buf , 1 , 4 , input -> file ) ; <S2SV_EndBug> <S2SV_StartBug> input -> framerate . numerator = input -> y4m . fps_n ; <S2SV_EndBug> <S2SV_StartBug> input -> use_i420 = 0 ; <S2SV_EndBug>"
2007,CWE-119,"void vpx_scale_frame ( YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst , unsigned char * temp_area , unsigned char temp_height , unsigned int hscale , unsigned int hratio , unsigned int vscale , unsigned int vratio , unsigned int interlaced ) { int i ; int dw = ( hscale - 1 + src -> y_width * hratio ) / hscale ; int dh = ( vscale - 1 + src -> y_height * vratio ) / vscale ; Scale2D ( ( unsigned char * ) src -> y_buffer , src -> y_stride , src -> y_width , src -> y_height , ( unsigned char * ) dst -> y_buffer , dst -> y_stride , dw , dh , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ; if ( dw < ( int ) dst -> y_width ) for ( i = 0 ; i < dh ; i ++ ) <S2SV_StartBug> vpx_memset ( dst -> y_buffer + i * dst -> y_stride + dw - 1 , dst -> y_buffer [ i * dst -> y_stride + dw - 2 ] , dst -> y_width - dw + 1 ) ; <S2SV_EndBug> if ( dh < ( int ) dst -> y_height ) for ( i = dh - 1 ; i < ( int ) dst -> y_height ; i ++ ) <S2SV_StartBug> vpx_memcpy ( dst -> y_buffer + i * dst -> y_stride , dst -> y_buffer + ( dh - 2 ) * dst -> y_stride , dst -> y_width + 1 ) ; <S2SV_EndBug> Scale2D ( ( unsigned char * ) src -> u_buffer , src -> uv_stride , src -> uv_width , src -> uv_height , ( unsigned char * ) dst -> u_buffer , dst -> uv_stride , dw / 2 , dh / 2 , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ; if ( dw / 2 < ( int ) dst -> uv_width ) for ( i = 0 ; i < dst -> uv_height ; i ++ ) <S2SV_StartBug> vpx_memset ( dst -> u_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> u_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ; <S2SV_EndBug> if ( dh / 2 < ( int ) dst -> uv_height ) for ( i = dh / 2 - 1 ; i < ( int ) dst -> y_height / 2 ; i ++ ) <S2SV_StartBug> vpx_memcpy ( dst -> u_buffer + i * dst -> uv_stride , dst -> u_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ; <S2SV_EndBug> Scale2D ( ( unsigned char * ) src -> v_buffer , src -> uv_stride , src -> uv_width , src -> uv_height , ( unsigned char * ) dst -> v_buffer , dst -> uv_stride , dw / 2 , dh / 2 , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ; if ( dw / 2 < ( int ) dst -> uv_width ) for ( i = 0 ; i < dst -> uv_height ; i ++ ) <S2SV_StartBug> vpx_memset ( dst -> v_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> v_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ; <S2SV_EndBug> if ( dh / 2 < ( int ) dst -> uv_height ) for ( i = dh / 2 - 1 ; i < ( int ) dst -> y_height / 2 ; i ++ ) <S2SV_StartBug> vpx_memcpy ( dst -> v_buffer + i * dst -> uv_stride , dst -> v_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ; <S2SV_EndBug> }
","<S2SV_ModStart> i ++ ) memset <S2SV_ModEnd> ( dst -> <S2SV_ModStart> i ++ ) memcpy <S2SV_ModEnd> ( dst -> <S2SV_ModStart> i ++ ) memset <S2SV_ModEnd> ( dst -> <S2SV_ModStart> i ++ ) memcpy <S2SV_ModEnd> ( dst -> <S2SV_ModStart> i ++ ) memset <S2SV_ModEnd> ( dst -> <S2SV_ModStart> i ++ ) memcpy <S2SV_ModEnd> ( dst ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( dst -> y_buffer + i * dst -> y_stride + dw - 1 , dst -> y_buffer [ i * dst -> y_stride + dw - 2 ] , dst -> y_width - dw + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst -> y_buffer + i * dst -> y_stride , dst -> y_buffer + ( dh - 2 ) * dst -> y_stride , dst -> y_width + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dst -> u_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> u_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst -> u_buffer + i * dst -> uv_stride , dst -> u_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dst -> v_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> v_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst -> v_buffer + i * dst -> uv_stride , dst -> v_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ; <S2SV_EndBug>"
4851,CWE-252,"void vsyslog ( pri , fmt , ap ) int pri ; register const char * fmt ; va_list ap ; { struct tm now_tm ; time_t now ; int fd ; FILE * f ; char * buf = 0 ; size_t bufsize = 0 ; size_t prioff , msgoff ; struct sigaction action , oldaction ; struct sigaction * oldaction_ptr = NULL ; int sigpipe ; int saved_errno = errno ; # define INTERNALLOG LOG_ERR | LOG_CONS | LOG_PERROR | LOG_PID if ( pri & ~ ( LOG_PRIMASK | LOG_FACMASK ) ) { syslog ( INTERNALLOG , ""syslog:<S2SV_blank>unknown<S2SV_blank>facility/priority:<S2SV_blank>%x"" , pri ) ; pri &= LOG_PRIMASK | LOG_FACMASK ; } if ( ( LOG_MASK ( LOG_PRI ( pri ) ) & LogMask ) == 0 ) return ; if ( ( pri & LOG_FACMASK ) == 0 ) pri |= LogFacility ; f = open_memstream ( & buf , & bufsize ) ; prioff = fprintf ( f , ""<%d>"" , pri ) ; ( void ) time ( & now ) ; # ifdef USE_IN_LIBIO f -> _IO_write_ptr += strftime ( f -> _IO_write_ptr , f -> _IO_write_end - f -> _IO_write_ptr , ""%h<S2SV_blank>%e<S2SV_blank>%T<S2SV_blank>"" , __localtime_r ( & now , & now_tm ) ) ; # else f -> __bufp += strftime ( f -> __bufp , f -> __put_limit - f -> __bufp , ""%h<S2SV_blank>%e<S2SV_blank>%T<S2SV_blank>"" , __localtime_r ( & now , & now_tm ) ) ; # endif msgoff = ftell ( f ) ; if ( LogTag == NULL ) LogTag = __progname ; if ( LogTag != NULL ) fputs_unlocked ( LogTag , f ) ; if ( LogStat & LOG_PID ) fprintf ( f , ""[%d]"" , __getpid ( ) ) ; if ( LogTag != NULL ) putc_unlocked ( ':' , f ) , putc_unlocked ( '<S2SV_blank>' , f ) ; __set_errno ( saved_errno ) ; vfprintf ( f , fmt , ap ) ; fclose ( f ) ; if ( LogStat & LOG_PERROR ) { struct iovec iov [ 2 ] ; register struct iovec * v = iov ; v -> iov_base = buf + msgoff ; v -> iov_len = bufsize - msgoff ; <S2SV_StartBug> ++ v ; <S2SV_EndBug> v -> iov_base = ( char * ) ""\\n"" ; v -> iov_len = 1 ; <S2SV_StartBug> ( void ) __writev ( STDERR_FILENO , iov , 2 ) ; <S2SV_EndBug> } __libc_cleanup_region_start ( ( void ( * ) ( void * ) ) cancel_handler , & oldaction_ptr ) ; __libc_lock_lock ( syslog_lock ) ; memset ( & action , 0 , sizeof ( action ) ) ; action . sa_handler = sigpipe_handler ; sigemptyset ( & action . sa_mask ) ; sigpipe = __sigaction ( SIGPIPE , & action , & oldaction ) ; if ( sigpipe == 0 ) oldaction_ptr = & oldaction ; if ( ! connected ) openlog_internal ( LogTag , LogStat | LOG_NDELAY , 0 ) ; if ( LogType == SOCK_STREAM ) ++ bufsize ; if ( ! connected || __send ( LogFile , buf , bufsize , 0 ) < 0 ) { closelog_internal ( ) ; if ( LogStat & LOG_CONS && ( fd = __open ( _PATH_CONSOLE , O_WRONLY | O_NOCTTY , 0 ) ) >= 0 ) { dprintf ( fd , ""%s\\r\\n"" , buf + msgoff ) ; ( void ) __close ( fd ) ; } } if ( sigpipe == 0 ) __sigaction ( SIGPIPE , & oldaction , ( struct sigaction * ) NULL ) ; __libc_cleanup_region_end ( 0 ) ; __libc_lock_unlock ( syslog_lock ) ; free ( buf ) ; }
","<S2SV_ModStart> - msgoff ; if ( buf [ bufsize - 1 ] != '\\n' ) { <S2SV_ModStart> = 1 ; } <S2SV_ModStart> , iov , v - iov + 1 <S2SV_ModEnd> ) ; }
",bminor@glibc/2864e767053317538feafa815046fff89e5a16be,CVE-1999-0199,https://github.com/bminor/glibc/commit/2864e767053317538feafa815046fff89e5a16be,2020-10-06T13:15Z,"<S2SV_StartBug> ++ v ; <S2SV_EndBug> <S2SV_StartBug> ( void ) __writev ( STDERR_FILENO , iov , 2 ) ; <S2SV_EndBug>"
1985,CWE-119,"vpx_codec_err_t vpx_codec_decode ( vpx_codec_ctx_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) { vpx_codec_err_t res ; <S2SV_StartBug> if ( ! ctx || ( ! data && data_sz ) ) <S2SV_EndBug> res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { <S2SV_StartBug> res = ctx -> iface -> dec . decode ( ctx -> priv -> alg_priv , data , data_sz , <S2SV_EndBug> user_priv , deadline ) ; } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> && data_sz ) || ( data && ! data_sz ) <S2SV_ModStart> . decode ( get_alg_priv ( ctx ) <S2SV_ModEnd> , data ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> if ( ! ctx || ( ! data && data_sz ) ) <S2SV_EndBug> <S2SV_StartBug> res = ctx -> iface -> dec . decode ( ctx -> priv -> alg_priv , data , data_sz , <S2SV_EndBug>"
307,CWE-125,"static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; <S2SV_StartBug> if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; <S2SV_StartBug> else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }
","<S2SV_ModStart> ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && <S2SV_ModStart> else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) &&
",the-tcpdump-group@tcpdump/13d52e9c0e7caf7e6325b0051bc90a49968be67f,CVE-2018-16230,https://github.com/the-tcpdump-group/tcpdump/commit/13d52e9c0e7caf7e6325b0051bc90a49968be67f,2019-10-03T16:15Z,<S2SV_StartBug> if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) <S2SV_EndBug> <S2SV_StartBug> else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) <S2SV_EndBug>
2841,CWE-835,"static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>syncword\\n"" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>streamid\\n"" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n"" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n"" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ; <S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\n"" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , ""header<S2SV_blank>too<S2SV_blank>short\\n"" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , ""audio<S2SV_blank>data<S2SV_blank>corruption\\n"" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }
","<S2SV_ModStart> ; if ( avio_feof ( pb ) ) { return AVERROR_EOF ; } if (
",FFmpeg@FFmpeg/9807d3976be0e92e4ece3b4b1701be894cd7c2e1,CVE-2018-1999012,https://github.com/FFmpeg/FFmpeg/commit/9807d3976be0e92e4ece3b4b1701be894cd7c2e1,2018-07-23T15:29Z,<S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug>
1268,CWE-264,"static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }
","<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,<S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug>
3512,CWE-125,"static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; <S2SV_StartBug> tunnel_type = * ( tptr + 1 ) ; <S2SV_EndBug> flags = * tptr ; <S2SV_StartBug> tlen = len ; <S2SV_EndBug> ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }
","<S2SV_ModStart> , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <S2SV_ModStart> tlen = len <S2SV_ModEnd> ; ND_PRINT (
",the-tcpdump-group@tcpdump/d10a0f980fe8f9407ab1ffbd612641433ebe175e,CVE-2017-13046,https://github.com/the-tcpdump-group/tcpdump/commit/d10a0f980fe8f9407ab1ffbd612641433ebe175e,2017-09-14T06:29Z,<S2SV_StartBug> tunnel_type = * ( tptr + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> tlen = len ; <S2SV_EndBug>
69,CWE-416,"int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; <S2SV_StartBug> char * identifier ; <S2SV_EndBug> char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) <S2SV_StartBug> return ERROR_INSUFFICIENT_MEMORY ; <S2SV_EndBug> while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif <S2SV_StartBug> break ; <S2SV_EndBug> case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r1 . o = function -> return_obj ; <S2SV_EndBug> push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; } <S2SV_StartBug> yr_modules_unload_all ( context ) ; <S2SV_EndBug> yr_free ( stack ) ; return result ; }
","<S2SV_ModStart> * function ; YR_OBJECT * * obj_ptr ; YR_ARENA * obj_arena ; <S2SV_ModStart> ) return ERROR_INSUFFICIENT_MEMORY ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) <S2SV_ModStart> ; # endif assert ( sp == 0 ) ; <S2SV_ModStart> == ERROR_SUCCESS ) result = yr_object_copy ( function -> return_obj , & <S2SV_ModEnd> r1 . o <S2SV_ModStart> r1 . o ) ; if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ; stop = ( result != ERROR_SUCCESS ) ; push ( r1 ) ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ++ ; } obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ; while ( obj_ptr != NULL ) { yr_object_destroy ( * obj_ptr ) ; obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ; } yr_arena_destroy ( obj_arena ) ;
",VirusTotal@yara/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e,CVE-2017-8929,https://github.com/VirusTotal/yara/commit/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e,2017-05-14T22:29Z,<S2SV_StartBug> char * identifier ; <S2SV_EndBug> <S2SV_StartBug> return ERROR_INSUFFICIENT_MEMORY ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r1 . o = function -> return_obj ; <S2SV_EndBug> <S2SV_StartBug> yr_modules_unload_all ( context ) ; <S2SV_EndBug>
283,CWE-834,"static int ivr_read_header ( AVFormatContext * s ) { unsigned tag , type , len , tlen , value ; int i , j , n , count , nb_streams = 0 , ret ; uint8_t key [ 256 ] , val [ 256 ] ; AVIOContext * pb = s -> pb ; AVStream * st ; int64_t pos , offset , temp ; pos = avio_tell ( pb ) ; tag = avio_rl32 ( pb ) ; if ( tag == MKTAG ( '.' , 'R' , '1' , 'M' ) ) { if ( avio_rb16 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; len = avio_rb32 ( pb ) ; avio_skip ( pb , len ) ; avio_skip ( pb , 5 ) ; temp = avio_rb64 ( pb ) ; while ( ! avio_feof ( pb ) && temp ) { offset = temp ; temp = avio_rb64 ( pb ) ; } avio_skip ( pb , offset - avio_tell ( pb ) ) ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; len = avio_rb32 ( pb ) ; avio_skip ( pb , len ) ; if ( avio_r8 ( pb ) != 2 ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 16 ) ; pos = avio_tell ( pb ) ; tag = avio_rl32 ( pb ) ; } if ( tag != MKTAG ( '.' , 'R' , 'E' , 'C' ) ) return AVERROR_INVALIDDATA ; if ( avio_r8 ( pb ) != 0 ) return AVERROR_INVALIDDATA ; count = avio_rb32 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; type = avio_r8 ( pb ) ; tlen = avio_rb32 ( pb ) ; avio_get_str ( pb , tlen , key , sizeof ( key ) ) ; len = avio_rb32 ( pb ) ; if ( type == 5 ) { avio_get_str ( pb , len , val , sizeof ( val ) ) ; av_log ( s , AV_LOG_DEBUG , ""%s<S2SV_blank>=<S2SV_blank>\'%s\'\\n"" , key , val ) ; } else if ( type == 4 ) { av_log ( s , AV_LOG_DEBUG , ""%s<S2SV_blank>=<S2SV_blank>\'0x"" , key ) ; <S2SV_StartBug> for ( j = 0 ; j < len ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ; <S2SV_EndBug> av_log ( s , AV_LOG_DEBUG , ""\'\\n"" ) ; } else if ( len == 4 && type == 3 && ! strncmp ( key , ""StreamCount"" , tlen ) ) { nb_streams = value = avio_rb32 ( pb ) ; } else if ( len == 4 && type == 3 ) { value = avio_rb32 ( pb ) ; av_log ( s , AV_LOG_DEBUG , ""%s<S2SV_blank>=<S2SV_blank>%d\\n"" , key , value ) ; } else { av_log ( s , AV_LOG_DEBUG , ""Skipping<S2SV_blank>unsupported<S2SV_blank>key:<S2SV_blank>%s\\n"" , key ) ; avio_skip ( pb , len ) ; } } for ( n = 0 ; n < nb_streams ; n ++ ) { st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> priv_data = ff_rm_alloc_rmstream ( ) ; if ( ! st -> priv_data ) return AVERROR ( ENOMEM ) ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; count = avio_rb32 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; type = avio_r8 ( pb ) ; tlen = avio_rb32 ( pb ) ; avio_get_str ( pb , tlen , key , sizeof ( key ) ) ; len = avio_rb32 ( pb ) ; if ( type == 5 ) { avio_get_str ( pb , len , val , sizeof ( val ) ) ; av_log ( s , AV_LOG_DEBUG , ""%s<S2SV_blank>=<S2SV_blank>\'%s\'\\n"" , key , val ) ; } else if ( type == 4 && ! strncmp ( key , ""OpaqueData"" , tlen ) ) { ret = ffio_ensure_seekback ( pb , 4 ) ; if ( ret < 0 ) return ret ; if ( avio_rb32 ( pb ) == MKBETAG ( 'M' , 'L' , 'T' , 'I' ) ) { ret = rm_read_multi ( s , pb , st , NULL ) ; } else { avio_seek ( pb , - 4 , SEEK_CUR ) ; ret = ff_rm_read_mdpr_codecdata ( s , pb , st , st -> priv_data , len , NULL ) ; } if ( ret < 0 ) return ret ; } else if ( type == 4 ) { int j ; av_log ( s , AV_LOG_DEBUG , ""%s<S2SV_blank>=<S2SV_blank>\'0x"" , key ) ; for ( j = 0 ; j < len ; j ++ ) av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ; av_log ( s , AV_LOG_DEBUG , ""\'\\n"" ) ; } else if ( len == 4 && type == 3 && ! strncmp ( key , ""Duration"" , tlen ) ) { st -> duration = avio_rb32 ( pb ) ; } else if ( len == 4 && type == 3 ) { value = avio_rb32 ( pb ) ; av_log ( s , AV_LOG_DEBUG , ""%s<S2SV_blank>=<S2SV_blank>%d\\n"" , key , value ) ; } else { av_log ( s , AV_LOG_DEBUG , ""Skipping<S2SV_blank>unsupported<S2SV_blank>key:<S2SV_blank>%s\\n"" , key ) ; avio_skip ( pb , len ) ; } } } if ( avio_r8 ( pb ) != 6 ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 12 ) ; avio_skip ( pb , avio_rb64 ( pb ) + pos - avio_tell ( s -> pb ) ) ; if ( avio_r8 ( pb ) != 8 ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 8 ) ; return 0 ; }
","<S2SV_ModStart> j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) ; }
",FFmpeg@FFmpeg/124eb202e70678539544f6268efc98131f19fa49,CVE-2017-14054,https://github.com/FFmpeg/FFmpeg/commit/124eb202e70678539544f6268efc98131f19fa49,2017-08-31T15:29Z,"<S2SV_StartBug> for ( j = 0 ; j < len ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ; <S2SV_EndBug>"
2292,CWE-119,"void configSetCommand ( client * c ) { robj * o ; long long ll ; int err ; serverAssertWithInfo ( c , c -> argv [ 2 ] , sdsEncodedObject ( c -> argv [ 2 ] ) ) ; serverAssertWithInfo ( c , c -> argv [ 3 ] , sdsEncodedObject ( c -> argv [ 3 ] ) ) ; o = c -> argv [ 3 ] ; if ( 0 ) { config_set_special_field ( ""dbfilename"" ) { if ( ! pathIsBaseName ( o -> ptr ) ) { addReplyError ( c , ""dbfilename<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>path,<S2SV_blank>just<S2SV_blank>a<S2SV_blank>filename"" ) ; return ; } zfree ( server . rdb_filename ) ; server . rdb_filename = zstrdup ( o -> ptr ) ; } config_set_special_field ( ""requirepass"" ) { if ( sdslen ( o -> ptr ) > CONFIG_AUTHPASS_MAX_LEN ) goto badfmt ; zfree ( server . requirepass ) ; server . requirepass = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""masterauth"" ) { zfree ( server . masterauth ) ; server . masterauth = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""cluster-announce-ip"" ) { zfree ( server . cluster_announce_ip ) ; server . cluster_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""maxclients"" ) { int orig_value = server . maxclients ; if ( getLongLongFromObject ( o , & ll ) == C_ERR || ll < 1 ) goto badfmt ; server . maxclients = ll ; if ( ll > orig_value ) { adjustOpenFilesLimit ( ) ; if ( server . maxclients != ll ) { addReplyErrorFormat ( c , ""The<S2SV_blank>operating<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>number<S2SV_blank>of<S2SV_blank>clients,<S2SV_blank>try<S2SV_blank>with<S2SV_blank>%d"" , server . maxclients ) ; server . maxclients = orig_value ; return ; } if ( ( unsigned int ) aeGetSetSize ( server . el ) < server . maxclients + CONFIG_FDSET_INCR ) { if ( aeResizeSetSize ( server . el , server . maxclients + CONFIG_FDSET_INCR ) == AE_ERR ) { addReplyError ( c , ""The<S2SV_blank>event<S2SV_blank>loop<S2SV_blank>API<S2SV_blank>used<S2SV_blank>by<S2SV_blank>Redis<S2SV_blank>is<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>number<S2SV_blank>of<S2SV_blank>clients"" ) ; server . maxclients = orig_value ; return ; } } } } config_set_special_field ( ""appendonly"" ) { int enable = yesnotoi ( o -> ptr ) ; if ( enable == - 1 ) goto badfmt ; if ( enable == 0 && server . aof_state != AOF_OFF ) { stopAppendOnly ( ) ; } else if ( enable && server . aof_state == AOF_OFF ) { if ( startAppendOnly ( ) == C_ERR ) { addReplyError ( c , ""Unable<S2SV_blank>to<S2SV_blank>turn<S2SV_blank>on<S2SV_blank>AOF.<S2SV_blank>Check<S2SV_blank>server<S2SV_blank>logs."" ) ; return ; } } } config_set_special_field ( ""save"" ) { int vlen , j ; sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , ""<S2SV_blank>"" , 1 , & vlen ) ; if ( vlen & 1 ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } for ( j = 0 ; j < vlen ; j ++ ) { char * eptr ; long val ; val = strtoll ( v [ j ] , & eptr , 10 ) ; if ( eptr [ 0 ] != '\\0' || ( ( j & 1 ) == 0 && val < 1 ) || ( ( j & 1 ) == 1 && val < 0 ) ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } } resetServerSaveParams ( ) ; for ( j = 0 ; j < vlen ; j += 2 ) { time_t seconds ; int changes ; seconds = strtoll ( v [ j ] , NULL , 10 ) ; changes = strtoll ( v [ j + 1 ] , NULL , 10 ) ; appendServerSaveParams ( seconds , changes ) ; } sdsfreesplitres ( v , vlen ) ; } config_set_special_field ( ""dir"" ) { if ( chdir ( ( char * ) o -> ptr ) == - 1 ) { addReplyErrorFormat ( c , ""Changing<S2SV_blank>directory:<S2SV_blank>%s"" , strerror ( errno ) ) ; return ; } } config_set_special_field ( ""client-output-buffer-limit"" ) { int vlen , j ; sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , ""<S2SV_blank>"" , 1 , & vlen ) ; if ( vlen % 4 ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } for ( j = 0 ; j < vlen ; j ++ ) { long val ; if ( ( j % 4 ) == 0 ) { <S2SV_StartBug> if ( getClientTypeByName ( v [ j ] ) == - 1 ) { <S2SV_EndBug> sdsfreesplitres ( v , vlen ) ; goto badfmt ; } } else { val = memtoll ( v [ j ] , & err ) ; if ( err || val < 0 ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } } } for ( j = 0 ; j < vlen ; j += 4 ) { int class ; unsigned long long hard , soft ; int soft_seconds ; class = getClientTypeByName ( v [ j ] ) ; hard = strtoll ( v [ j + 1 ] , NULL , 10 ) ; soft = strtoll ( v [ j + 2 ] , NULL , 10 ) ; soft_seconds = strtoll ( v [ j + 3 ] , NULL , 10 ) ; server . client_obuf_limits [ class ] . hard_limit_bytes = hard ; server . client_obuf_limits [ class ] . soft_limit_bytes = soft ; server . client_obuf_limits [ class ] . soft_limit_seconds = soft_seconds ; } sdsfreesplitres ( v , vlen ) ; } config_set_special_field ( ""notify-keyspace-events"" ) { int flags = keyspaceEventsStringToFlags ( o -> ptr ) ; if ( flags == - 1 ) goto badfmt ; server . notify_keyspace_events = flags ; } config_set_special_field ( ""slave-announce-ip"" ) { zfree ( server . slave_announce_ip ) ; server . slave_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_bool_field ( ""rdbcompression"" , server . rdb_compression ) { } config_set_bool_field ( ""repl-disable-tcp-nodelay"" , server . repl_disable_tcp_nodelay ) { } config_set_bool_field ( ""repl-diskless-sync"" , server . repl_diskless_sync ) { } config_set_bool_field ( ""cluster-require-full-coverage"" , server . cluster_require_full_coverage ) { } config_set_bool_field ( ""aof-rewrite-incremental-fsync"" , server . aof_rewrite_incremental_fsync ) { } config_set_bool_field ( ""aof-load-truncated"" , server . aof_load_truncated ) { } config_set_bool_field ( ""aof-use-rdb-preamble"" , server . aof_use_rdb_preamble ) { } config_set_bool_field ( ""slave-serve-stale-data"" , server . repl_serve_stale_data ) { } config_set_bool_field ( ""slave-read-only"" , server . repl_slave_ro ) { } config_set_bool_field ( ""activerehashing"" , server . activerehashing ) { } config_set_bool_field ( ""protected-mode"" , server . protected_mode ) { } config_set_bool_field ( ""stop-writes-on-bgsave-error"" , server . stop_writes_on_bgsave_err ) { } config_set_bool_field ( ""lazyfree-lazy-eviction"" , server . lazyfree_lazy_eviction ) { } config_set_bool_field ( ""lazyfree-lazy-expire"" , server . lazyfree_lazy_expire ) { } config_set_bool_field ( ""lazyfree-lazy-server-del"" , server . lazyfree_lazy_server_del ) { } config_set_bool_field ( ""slave-lazy-flush"" , server . repl_slave_lazy_flush ) { } config_set_bool_field ( ""no-appendfsync-on-rewrite"" , server . aof_no_fsync_on_rewrite ) { } config_set_numerical_field ( ""tcp-keepalive"" , server . tcpkeepalive , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""maxmemory-samples"" , server . maxmemory_samples , 1 , LLONG_MAX ) { } config_set_numerical_field ( ""lfu-log-factor"" , server . lfu_log_factor , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""lfu-decay-time"" , server . lfu_decay_time , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""timeout"" , server . maxidletime , 0 , LONG_MAX ) { } config_set_numerical_field ( ""auto-aof-rewrite-percentage"" , server . aof_rewrite_perc , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""auto-aof-rewrite-min-size"" , server . aof_rewrite_min_size , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hash-max-ziplist-entries"" , server . hash_max_ziplist_entries , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hash-max-ziplist-value"" , server . hash_max_ziplist_value , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""list-max-ziplist-size"" , server . list_max_ziplist_size , INT_MIN , INT_MAX ) { } config_set_numerical_field ( ""list-compress-depth"" , server . list_compress_depth , 0 , INT_MAX ) { } config_set_numerical_field ( ""set-max-intset-entries"" , server . set_max_intset_entries , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""zset-max-ziplist-entries"" , server . zset_max_ziplist_entries , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""zset-max-ziplist-value"" , server . zset_max_ziplist_value , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hll-sparse-max-bytes"" , server . hll_sparse_max_bytes , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""lua-time-limit"" , server . lua_time_limit , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slowlog-log-slower-than"" , server . slowlog_log_slower_than , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slowlog-max-len"" , ll , 0 , LLONG_MAX ) { server . slowlog_max_len = ( unsigned ) ll ; } config_set_numerical_field ( ""latency-monitor-threshold"" , server . latency_monitor_threshold , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-ping-slave-period"" , server . repl_ping_slave_period , 1 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-timeout"" , server . repl_timeout , 1 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-backlog-ttl"" , server . repl_backlog_time_limit , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-diskless-sync-delay"" , server . repl_diskless_sync_delay , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slave-priority"" , server . slave_priority , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slave-announce-port"" , server . slave_announce_port , 0 , 65535 ) { } config_set_numerical_field ( ""min-slaves-to-write"" , server . repl_min_slaves_to_write , 0 , LLONG_MAX ) { refreshGoodSlavesCount ( ) ; } config_set_numerical_field ( ""min-slaves-max-lag"" , server . repl_min_slaves_max_lag , 0 , LLONG_MAX ) { refreshGoodSlavesCount ( ) ; } config_set_numerical_field ( ""cluster-node-timeout"" , server . cluster_node_timeout , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""cluster-announce-port"" , server . cluster_announce_port , 0 , 65535 ) { } config_set_numerical_field ( ""cluster-announce-bus-port"" , server . cluster_announce_bus_port , 0 , 65535 ) { } config_set_numerical_field ( ""cluster-migration-barrier"" , server . cluster_migration_barrier , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""cluster-slave-validity-factor"" , server . cluster_slave_validity_factor , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hz"" , server . hz , 0 , LLONG_MAX ) { if ( server . hz < CONFIG_MIN_HZ ) server . hz = CONFIG_MIN_HZ ; if ( server . hz > CONFIG_MAX_HZ ) server . hz = CONFIG_MAX_HZ ; } config_set_numerical_field ( ""watchdog-period"" , ll , 0 , LLONG_MAX ) { if ( ll ) enableWatchdog ( ll ) ; else disableWatchdog ( ) ; } config_set_memory_field ( ""maxmemory"" , server . maxmemory ) { if ( server . maxmemory ) { if ( server . maxmemory < zmalloc_used_memory ( ) ) { serverLog ( LL_WARNING , ""WARNING:<S2SV_blank>the<S2SV_blank>new<S2SV_blank>maxmemory<S2SV_blank>value<S2SV_blank>set<S2SV_blank>via<S2SV_blank>CONFIG<S2SV_blank>SET<S2SV_blank>is<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>the<S2SV_blank>current<S2SV_blank>memory<S2SV_blank>usage.<S2SV_blank>This<S2SV_blank>will<S2SV_blank>result<S2SV_blank>in<S2SV_blank>keys<S2SV_blank>eviction<S2SV_blank>and/or<S2SV_blank>inability<S2SV_blank>to<S2SV_blank>accept<S2SV_blank>new<S2SV_blank>write<S2SV_blank>commands<S2SV_blank>depending<S2SV_blank>on<S2SV_blank>the<S2SV_blank>maxmemory-policy."" ) ; } freeMemoryIfNeeded ( ) ; } } config_set_memory_field ( ""repl-backlog-size"" , ll ) { resizeReplicationBacklog ( ll ) ; } config_set_enum_field ( ""loglevel"" , server . verbosity , loglevel_enum ) { } config_set_enum_field ( ""maxmemory-policy"" , server . maxmemory_policy , maxmemory_policy_enum ) { } config_set_enum_field ( ""appendfsync"" , server . aof_fsync , aof_fsync_enum ) { } config_set_else { addReplyErrorFormat ( c , ""Unsupported<S2SV_blank>CONFIG<S2SV_blank>parameter:<S2SV_blank>%s"" , ( char * ) c -> argv [ 2 ] -> ptr ) ; return ; } addReply ( c , shared . ok ) ; return ; badfmt : addReplyErrorFormat ( c , ""Invalid<S2SV_blank>argument<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>CONFIG<S2SV_blank>SET<S2SV_blank>\'%s\'"" , ( char * ) o -> ptr , ( char * ) c -> argv [ 2 ] -> ptr ) ; }
","<S2SV_ModStart> 0 ) { int class = <S2SV_ModEnd> getClientTypeByName ( v <S2SV_ModStart> j ] ) ; if ( class <S2SV_ModStart> == - 1 || class == CLIENT_TYPE_MASTER
",antirez@redis/6d9f8e2462fc2c426d48c941edeb78e5df7d2977,CVE-2016-8339,https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977,2016-10-28T14:59Z,<S2SV_StartBug> if ( getClientTypeByName ( v [ j ] ) == - 1 ) { <S2SV_EndBug>
29,CWE-000,"static av_cold int vqa_decode_init ( AVCodecContext * avctx ) { VqaContext * s = avctx -> priv_data ; int i , j , codebook_index , ret ; s -> avctx = avctx ; avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; if ( s -> avctx -> extradata_size != VQA_HEADER_SIZE ) { av_log ( s -> avctx , AV_LOG_ERROR , ""expected<S2SV_blank>extradata<S2SV_blank>size<S2SV_blank>of<S2SV_blank>%d\\n"" , VQA_HEADER_SIZE ) ; return AVERROR ( EINVAL ) ; } s -> vqa_version = s -> avctx -> extradata [ 0 ] ; switch ( s -> vqa_version ) { case 1 : case 2 : break ; case 3 : avpriv_report_missing_feature ( avctx , ""VQA<S2SV_blank>Version<S2SV_blank>%d"" , s -> vqa_version ) ; return AVERROR_PATCHWELCOME ; default : avpriv_request_sample ( avctx , ""VQA<S2SV_blank>Version<S2SV_blank>%i"" , s -> vqa_version ) ; return AVERROR_PATCHWELCOME ; } s -> width = AV_RL16 ( & s -> avctx -> extradata [ 6 ] ) ; s -> height = AV_RL16 ( & s -> avctx -> extradata [ 8 ] ) ; <S2SV_StartBug> if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) { <S2SV_EndBug> s -> width = s -> height = 0 ; return ret ; } s -> vector_width = s -> avctx -> extradata [ 10 ] ; s -> vector_height = s -> avctx -> extradata [ 11 ] ; s -> partial_count = s -> partial_countdown = s -> avctx -> extradata [ 13 ] ; if ( ( s -> vector_width != 4 ) || ( ( s -> vector_height != 2 ) && ( s -> vector_height != 4 ) ) ) { return AVERROR_INVALIDDATA ; } if ( s -> width % s -> vector_width || s -> height % s -> vector_height ) { av_log ( avctx , AV_LOG_ERROR , ""Image<S2SV_blank>size<S2SV_blank>not<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>block<S2SV_blank>size\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> codebook_size = MAX_CODEBOOK_SIZE ; s -> codebook = av_malloc ( s -> codebook_size ) ; if ( ! s -> codebook ) goto fail ; s -> next_codebook_buffer = av_malloc ( s -> codebook_size ) ; if ( ! s -> next_codebook_buffer ) goto fail ; s -> decode_buffer_size = ( s -> width / s -> vector_width ) * ( s -> height / s -> vector_height ) * 2 ; s -> decode_buffer = av_mallocz ( s -> decode_buffer_size ) ; if ( ! s -> decode_buffer ) goto fail ; if ( s -> vector_height == 4 ) { codebook_index = 0xFF00 * 16 ; for ( i = 0 ; i < 256 ; i ++ ) for ( j = 0 ; j < 16 ; j ++ ) s -> codebook [ codebook_index ++ ] = i ; } else { codebook_index = 0xF00 * 8 ; for ( i = 0 ; i < 256 ; i ++ ) for ( j = 0 ; j < 8 ; j ++ ) s -> codebook [ codebook_index ++ ] = i ; } s -> next_codebook_buffer_index = 0 ; return 0 ; fail : av_freep ( & s -> codebook ) ; av_freep ( & s -> next_codebook_buffer ) ; av_freep ( & s -> decode_buffer ) ; return AVERROR ( ENOMEM ) ; }
","<S2SV_ModStart> ( ret = ff_set_dimensions ( avctx , <S2SV_ModEnd> s -> width <S2SV_ModStart> s -> height <S2SV_ModEnd> ) ) <
",FFmpeg@FFmpeg/02f909dc24b1f05cfbba75077c7707b905e63cd2,CVE-2019-17542,https://github.com/FFmpeg/FFmpeg/commit/02f909dc24b1f05cfbba75077c7707b905e63cd2,2019-10-14T02:15Z,"<S2SV_StartBug> if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) { <S2SV_EndBug>"
7439,CWE-74,"static gboolean handle_spawn ( PortalFlatpak * object , GDBusMethodInvocation * invocation , GUnixFDList * fd_list , const gchar * arg_cwd_path , const gchar * const * arg_argv , GVariant * arg_fds , GVariant * arg_envs , guint arg_flags , GVariant * arg_options ) { g_autoptr ( GError ) error = NULL ; ChildSetupData child_setup_data = { NULL } ; GPid pid ; PidData * pid_data ; InstanceIdReadData * instance_id_read_data = NULL ; gsize i , j , n_fds , n_envs ; const gint * fds = NULL ; gint fds_len = 0 ; g_autofree FdMapEntry * fd_map = NULL ; gchar * * env ; gint32 max_fd ; GKeyFile * app_info ; g_autoptr ( GPtrArray ) flatpak_argv = g_ptr_array_new_with_free_func ( g_free ) ; g_autofree char * app_id = NULL ; g_autofree char * branch = NULL ; g_autofree char * arch = NULL ; g_autofree char * app_commit = NULL ; g_autofree char * runtime_ref = NULL ; g_auto ( GStrv ) runtime_parts = NULL ; g_autofree char * runtime_commit = NULL ; g_autofree char * instance_path = NULL ; g_auto ( GStrv ) extra_args = NULL ; g_auto ( GStrv ) shares = NULL ; g_auto ( GStrv ) sockets = NULL ; g_auto ( GStrv ) devices = NULL ; g_auto ( GStrv ) sandbox_expose = NULL ; g_auto ( GStrv ) sandbox_expose_ro = NULL ; g_autoptr ( GVariant ) sandbox_expose_fd = NULL ; g_autoptr ( GVariant ) sandbox_expose_fd_ro = NULL ; g_autoptr ( GOutputStream ) instance_id_out_stream = NULL ; guint sandbox_flags = 0 ; gboolean sandboxed ; gboolean expose_pids ; gboolean share_pids ; gboolean notify_start ; gboolean devel ; g_autoptr ( GString ) env_string = g_string_new ( """" ) ; child_setup_data . instance_id_fd = - 1 ; child_setup_data . env_fd = - 1 ; if ( fd_list != NULL ) fds = g_unix_fd_list_peek_fds ( fd_list , & fds_len ) ; app_info = g_object_get_data ( G_OBJECT ( invocation ) , ""app-info"" ) ; g_assert ( app_info != NULL ) ; app_id = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_NAME , NULL ) ; g_assert ( app_id != NULL ) ; g_debug ( ""spawn()<S2SV_blank>called<S2SV_blank>from<S2SV_blank>app:<S2SV_blank>\'%s\'"" , app_id ) ; if ( * app_id == 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""org.freedesktop.portal.Flatpak.Spawn<S2SV_blank>only<S2SV_blank>works<S2SV_blank>in<S2SV_blank>a<S2SV_blank>flatpak"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( * arg_cwd_path == 0 ) arg_cwd_path = NULL ; if ( arg_argv == NULL || * arg_argv == NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>command<S2SV_blank>given"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( ( arg_flags & ~ FLATPAK_SPAWN_FLAGS_ALL ) != 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Unsupported<S2SV_blank>flags<S2SV_blank>enabled:<S2SV_blank>0x%x"" , arg_flags & ~ FLATPAK_SPAWN_FLAGS_ALL ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } runtime_ref = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_RUNTIME , NULL ) ; if ( runtime_ref == NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>runtime<S2SV_blank>found"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } runtime_parts = g_strsplit ( runtime_ref , ""/"" , - 1 ) ; branch = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_BRANCH , NULL ) ; instance_path = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_INSTANCE_PATH , NULL ) ; arch = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_ARCH , NULL ) ; extra_args = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_EXTRA_ARGS , NULL , NULL ) ; app_commit = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_APP_COMMIT , NULL ) ; runtime_commit = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_RUNTIME_COMMIT , NULL ) ; shares = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_SHARED , NULL , NULL ) ; sockets = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_SOCKETS , NULL , NULL ) ; devices = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_DEVICES , NULL , NULL ) ; devel = g_key_file_get_boolean ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_DEVEL , NULL ) ; g_variant_lookup ( arg_options , ""sandbox-expose"" , ""^as"" , & sandbox_expose ) ; g_variant_lookup ( arg_options , ""sandbox-expose-ro"" , ""^as"" , & sandbox_expose_ro ) ; g_variant_lookup ( arg_options , ""sandbox-flags"" , ""u"" , & sandbox_flags ) ; sandbox_expose_fd = g_variant_lookup_value ( arg_options , ""sandbox-expose-fd"" , G_VARIANT_TYPE ( ""ah"" ) ) ; sandbox_expose_fd_ro = g_variant_lookup_value ( arg_options , ""sandbox-expose-fd-ro"" , G_VARIANT_TYPE ( ""ah"" ) ) ; if ( ( sandbox_flags & ~ FLATPAK_SPAWN_SANDBOX_FLAGS_ALL ) != 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Unsupported<S2SV_blank>sandbox<S2SV_blank>flags<S2SV_blank>enabled:<S2SV_blank>0x%x"" , arg_flags & ~ FLATPAK_SPAWN_SANDBOX_FLAGS_ALL ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( instance_path == NULL && ( ( sandbox_expose != NULL && sandbox_expose [ 0 ] != NULL ) || ( sandbox_expose_ro != NULL && sandbox_expose_ro [ 0 ] != NULL ) ) ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Invalid<S2SV_blank>sandbox<S2SV_blank>expose,<S2SV_blank>caller<S2SV_blank>has<S2SV_blank>no<S2SV_blank>instance<S2SV_blank>path"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } for ( i = 0 ; sandbox_expose != NULL && sandbox_expose [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose [ i ] ; g_debug ( ""exposing<S2SV_blank>%s"" , expose ) ; if ( ! is_valid_expose ( expose , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose_ro [ i ] ; g_debug ( ""exposing<S2SV_blank>%s"" , expose ) ; if ( ! is_valid_expose ( expose , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } g_debug ( ""Running<S2SV_blank>spawn<S2SV_blank>command<S2SV_blank>%s"" , arg_argv [ 0 ] ) ; n_fds = 0 ; if ( fds != NULL ) n_fds = g_variant_n_children ( arg_fds ) ; fd_map = g_new0 ( FdMapEntry , n_fds ) ; child_setup_data . fd_map = fd_map ; child_setup_data . fd_map_len = n_fds ; max_fd = - 1 ; for ( i = 0 ; i < n_fds ; i ++ ) { gint32 handle , dest_fd ; int handle_fd ; g_variant_get_child ( arg_fds , i , ""{uh}"" , & dest_fd , & handle ) ; if ( handle >= fds_len || handle < 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d"" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } handle_fd = fds [ handle ] ; fd_map [ i ] . to = dest_fd ; fd_map [ i ] . from = handle_fd ; fd_map [ i ] . final = fd_map [ i ] . to ; if ( ( dest_fd == 0 || dest_fd == 1 || dest_fd == 2 ) && ! child_setup_data . set_tty && isatty ( handle_fd ) ) { child_setup_data . set_tty = TRUE ; child_setup_data . tty = handle_fd ; } max_fd = MAX ( max_fd , fd_map [ i ] . to ) ; max_fd = MAX ( max_fd , fd_map [ i ] . from ) ; } for ( i = 0 ; i < n_fds ; i ++ ) { int to_fd = fd_map [ i ] . to ; gboolean conflict = FALSE ; for ( j = i + 1 ; j < n_fds ; j ++ ) { int from_fd = fd_map [ j ] . from ; if ( from_fd == to_fd ) { conflict = TRUE ; break ; } } if ( conflict ) fd_map [ i ] . to = ++ max_fd ; } if ( arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV ) { char * empty [ ] = { NULL } ; env = g_strdupv ( empty ) ; } else env = g_get_environ ( ) ; n_envs = g_variant_n_children ( arg_envs ) ; for ( i = 0 ; i < n_envs ; i ++ ) { const char * var = NULL ; const char * val = NULL ; g_variant_get_child ( arg_envs , i , ""{&s&s}"" , & var , & val ) ; <S2SV_StartBug> env = g_environ_setenv ( env , var , val , TRUE ) ; <S2SV_EndBug> } g_ptr_array_add ( flatpak_argv , g_strdup ( ""flatpak"" ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup ( ""run"" ) ) ; sandboxed = ( arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX ) != 0 ; if ( sandboxed ) { g_ptr_array_add ( flatpak_argv , g_strdup ( ""--sandbox"" ) ) ; if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY ) { if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""wayland"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=wayland"" ) ) ; if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""fallback-x11"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=fallback-x11"" ) ) ; if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""x11"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=x11"" ) ) ; if ( shares != NULL && g_strv_contains ( ( const char * const * ) shares , ""ipc"" ) && sockets != NULL && ( g_strv_contains ( ( const char * const * ) sockets , ""fallback-x11"" ) || g_strv_contains ( ( const char * const * ) sockets , ""x11"" ) ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--share=ipc"" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND ) { if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""pulseaudio"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=pulseaudio"" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU ) { if ( devices != NULL && ( g_strv_contains ( ( const char * const * ) devices , ""dri"" ) || g_strv_contains ( ( const char * const * ) devices , ""all"" ) ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--device=dri"" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--session-bus"" ) ) ; if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--a11y-bus"" ) ) ; } else { for ( i = 0 ; extra_args != NULL && extra_args [ i ] != NULL ; i ++ ) { if ( g_str_has_prefix ( extra_args [ i ] , ""--env="" ) ) { const char * var_val = extra_args [ i ] + strlen ( ""--env="" ) ; if ( var_val [ 0 ] == '\\0' || var_val [ 0 ] == '=' ) { g_warning ( ""Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>empty<S2SV_blank>name"" ) ; continue ; } if ( strchr ( var_val , '=' ) == NULL ) { g_warning ( ""Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>no<S2SV_blank>value"" ) ; continue ; } g_string_append ( env_string , var_val ) ; g_string_append_c ( env_string , '\\0' ) ; } else { g_ptr_array_add ( flatpak_argv , g_strdup ( extra_args [ i ] ) ) ; } } } if ( env_string -> len > 0 ) { g_auto ( GLnxTmpfile ) env_tmpf = { 0 , } ; if ( ! flatpak_buffer_to_sealed_memfd_or_tmpfile ( & env_tmpf , ""environ"" , env_string -> str , env_string -> len , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } child_setup_data . env_fd = glnx_steal_fd ( & env_tmpf . fd ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--env-fd=%d"" , child_setup_data . env_fd ) ) ; } expose_pids = ( arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS ) != 0 ; share_pids = ( arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS ) != 0 ; if ( expose_pids || share_pids ) { g_autofree char * instance_id = NULL ; int sender_pid1 = 0 ; if ( ! ( supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS ) ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_NOT_SUPPORTED , ""Expose<S2SV_blank>pids<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>with<S2SV_blank>setuid<S2SV_blank>bwrap"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } instance_id = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_INSTANCE_ID , NULL ) ; if ( instance_id ) { g_autoptr ( FlatpakInstance ) instance = flatpak_instance_new_for_id ( instance_id ) ; sender_pid1 = flatpak_instance_get_child_pid ( instance ) ; } if ( sender_pid1 == 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>requesting<S2SV_blank>pid"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--parent-pid=%d"" , sender_pid1 ) ) ; if ( share_pids ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--parent-share-pids"" ) ) ; else g_ptr_array_add ( flatpak_argv , g_strdup ( ""--parent-expose-pids"" ) ) ; } notify_start = ( arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START ) != 0 ; if ( notify_start ) { int pipe_fds [ 2 ] ; if ( pipe ( pipe_fds ) == - 1 ) { int errsv = errno ; g_dbus_method_invocation_return_error ( invocation , G_IO_ERROR , g_io_error_from_errno ( errsv ) , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>instance<S2SV_blank>ID<S2SV_blank>pipe:<S2SV_blank>%s"" , g_strerror ( errsv ) ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } GInputStream * in_stream = G_INPUT_STREAM ( g_unix_input_stream_new ( pipe_fds [ 0 ] , TRUE ) ) ; instance_id_out_stream = G_OUTPUT_STREAM ( g_unix_output_stream_new ( pipe_fds [ 1 ] , TRUE ) ) ; instance_id_read_data = g_new0 ( InstanceIdReadData , 1 ) ; g_input_stream_read_async ( in_stream , instance_id_read_data -> buffer , INSTANCE_ID_BUFFER_SIZE - 1 , G_PRIORITY_DEFAULT , NULL , instance_id_read_finish , instance_id_read_data ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--instance-id-fd=%d"" , pipe_fds [ 1 ] ) ) ; child_setup_data . instance_id_fd = pipe_fds [ 1 ] ; } if ( devel ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--devel"" ) ) ; if ( shares != NULL && g_strv_contains ( ( const char * const * ) shares , ""network"" ) && ! ( arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--share=network"" ) ) ; else g_ptr_array_add ( flatpak_argv , g_strdup ( ""--unshare=network"" ) ) ; if ( instance_path ) { for ( i = 0 ; sandbox_expose != NULL && sandbox_expose [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , filesystem_sandbox_arg ( instance_path , sandbox_expose [ i ] , FALSE ) ) ; for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , filesystem_sandbox_arg ( instance_path , sandbox_expose_ro [ i ] , TRUE ) ) ; } for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose_ro [ i ] ; g_debug ( ""exposing<S2SV_blank>%s"" , expose ) ; } if ( sandbox_expose_fd != NULL ) { gsize len = g_variant_n_children ( sandbox_expose_fd ) ; for ( i = 0 ; i < len ; i ++ ) { gint32 handle ; g_variant_get_child ( sandbox_expose_fd , i , ""h"" , & handle ) ; if ( handle >= 0 && handle < fds_len ) { int handle_fd = fds [ handle ] ; g_autofree char * path = NULL ; gboolean writable = FALSE ; path = get_path_for_fd ( handle_fd , & writable , & error ) ; if ( path ) { g_ptr_array_add ( flatpak_argv , filesystem_arg ( path , ! writable ) ) ; } else { g_debug ( ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>path<S2SV_blank>for<S2SV_blank>sandbox-exposed<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>ignoring:<S2SV_blank>%s"" , handle_fd , error -> message ) ; g_clear_error ( & error ) ; } } else { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d"" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } } if ( sandbox_expose_fd_ro != NULL ) { gsize len = g_variant_n_children ( sandbox_expose_fd_ro ) ; for ( i = 0 ; i < len ; i ++ ) { gint32 handle ; g_variant_get_child ( sandbox_expose_fd_ro , i , ""h"" , & handle ) ; if ( handle >= 0 && handle < fds_len ) { int handle_fd = fds [ handle ] ; g_autofree char * path = NULL ; gboolean writable = FALSE ; path = get_path_for_fd ( handle_fd , & writable , & error ) ; if ( path ) { g_ptr_array_add ( flatpak_argv , filesystem_arg ( path , TRUE ) ) ; } else { g_debug ( ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>path<S2SV_blank>for<S2SV_blank>sandbox-exposed<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>ignoring:<S2SV_blank>%s"" , handle_fd , error -> message ) ; g_clear_error ( & error ) ; } } else { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d"" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } } g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime=%s"" , runtime_parts [ 1 ] ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime-version=%s"" , runtime_parts [ 3 ] ) ) ; if ( ( arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION ) == 0 ) { if ( app_commit ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--commit=%s"" , app_commit ) ) ; if ( runtime_commit ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime-commit=%s"" , runtime_commit ) ) ; } if ( arg_cwd_path != NULL ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--cwd=%s"" , arg_cwd_path ) ) ; if ( arg_argv [ 0 ] [ 0 ] != 0 ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--command=%s"" , arg_argv [ 0 ] ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""%s/%s/%s"" , app_id , arch ? arch : """" , branch ? branch : """" ) ) ; for ( i = 1 ; arg_argv [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , g_strdup ( arg_argv [ i ] ) ) ; g_ptr_array_add ( flatpak_argv , NULL ) ; if ( opt_verbose ) { g_autoptr ( GString ) cmd = g_string_new ( """" ) ; for ( i = 0 ; flatpak_argv -> pdata [ i ] != NULL ; i ++ ) { if ( i > 0 ) g_string_append ( cmd , ""<S2SV_blank>"" ) ; g_string_append ( cmd , flatpak_argv -> pdata [ i ] ) ; } g_debug ( ""Starting:<S2SV_blank>%s\\n"" , cmd -> str ) ; } if ( ! g_spawn_async_with_pipes ( NULL , ( char * * ) flatpak_argv -> pdata , env , G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN , child_setup_func , & child_setup_data , & pid , NULL , NULL , NULL , & error ) ) { gint code = G_DBUS_ERROR_FAILED ; if ( g_error_matches ( error , G_SPAWN_ERROR , G_SPAWN_ERROR_ACCES ) ) code = G_DBUS_ERROR_ACCESS_DENIED ; else if ( g_error_matches ( error , G_SPAWN_ERROR , G_SPAWN_ERROR_NOENT ) ) code = G_DBUS_ERROR_FILE_NOT_FOUND ; g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , code , ""Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>command:<S2SV_blank>%s"" , error -> message ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( instance_id_read_data ) instance_id_read_data -> pid = pid ; pid_data = g_new0 ( PidData , 1 ) ; pid_data -> pid = pid ; pid_data -> client = g_strdup ( g_dbus_method_invocation_get_sender ( invocation ) ) ; pid_data -> watch_bus = ( arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS ) != 0 ; pid_data -> expose_or_share_pids = ( expose_pids || share_pids ) ; pid_data -> child_watch = g_child_watch_add_full ( G_PRIORITY_DEFAULT , pid , child_watch_died , pid_data , NULL ) ; g_debug ( ""Client<S2SV_blank>Pid<S2SV_blank>is<S2SV_blank>%d"" , pid_data -> pid ) ; g_hash_table_replace ( client_pid_data_hash , GUINT_TO_POINTER ( pid_data -> pid ) , pid_data ) ; portal_flatpak_complete_spawn ( object , invocation , NULL , pid ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; }
","<S2SV_ModStart> val ) ; if ( var [ 0 ] == '\\0' ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>empty<S2SV_blank>name"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( strchr ( var , '=' ) != NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>name<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\'=\'"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } g_string_append ( env_string , var ) ; g_string_append_c ( env_string , '=' ) ; g_string_append ( env_string , val ) ; g_string_append_c ( env_string , '\\0' <S2SV_ModEnd> ) ; }
",flatpak@flatpak/cc1401043c075268ecc652eac557ef8076b5eaba,CVE-2021-21261,https://github.com/flatpak/flatpak/commit/cc1401043c075268ecc652eac557ef8076b5eaba,2021-01-14T20:15Z,"<S2SV_StartBug> env = g_environ_setenv ( env , var , val , TRUE ) ; <S2SV_EndBug>"
7771,CWE-125,"stmt_ty <S2SV_StartBug> AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int <S2SV_EndBug> lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! target ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>target<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } if ( ! iter ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>iter<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFor_kind ; p -> v . AsyncFor . target = target ; p -> v . AsyncFor . iter = iter ; p -> v . AsyncFor . body = body ; <S2SV_StartBug> p -> v . AsyncFor . orelse = orelse ; <S2SV_EndBug> p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
","<S2SV_ModStart> * orelse , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> orelse = orelse ; p -> v . AsyncFor . type_comment = type_comment
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int <S2SV_EndBug> <S2SV_StartBug> p -> v . AsyncFor . orelse = orelse ; <S2SV_EndBug>"
1493,CWE-119,"void vp8_update_gf_useage_maps ( VP8_COMP * cpi , VP8_COMMON * cm , MACROBLOCK * x ) { int mb_row , mb_col ; MODE_INFO * this_mb_mode_info = cm -> mi ; x -> gf_active_ptr = ( signed char * ) cpi -> gf_active_flags ; if ( ( cm -> frame_type == KEY_FRAME ) || ( cm -> refresh_golden_frame ) ) { <S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; } else { for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( ( this_mb_mode_info -> mbmi . ref_frame == GOLDEN_FRAME ) || ( this_mb_mode_info -> mbmi . ref_frame == ALTREF_FRAME ) ) { if ( * ( x -> gf_active_ptr ) == 0 ) { * ( x -> gf_active_ptr ) = 1 ; cpi -> gf_active_count ++ ; } } else if ( ( this_mb_mode_info -> mbmi . mode != ZEROMV ) && * ( x -> gf_active_ptr ) ) { * ( x -> gf_active_ptr ) = 0 ; cpi -> gf_active_count -- ; } x -> gf_active_ptr ++ ; this_mb_mode_info ++ ; } this_mb_mode_info ++ ; } } }
","<S2SV_ModStart> ) ) { memset <S2SV_ModEnd> ( cpi ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug>"
2848,CWE-190,"void * jas_realloc ( void * ptr , size_t size ) { void * result ; <S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\n"" , ptr , size ) ) ; <S2SV_EndBug> result = realloc ( ptr , size ) ; JAS_DBGLOG ( 100 , ( ""jas_realloc(%p,<S2SV_blank>%zu)<S2SV_blank>-><S2SV_blank>%p\\n"" , ptr , size , result ) ) ; return result ; }
","<S2SV_ModStart> 101 , ( ""jas_realloc(%x,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> , ptr ,
",mdadams@jasper/988f8365f7d8ad8073b6786e433d34c553ecf568,CVE-2016-10249,https://github.com/mdadams/jasper/commit/988f8365f7d8ad8073b6786e433d34c553ecf568,2017-03-15T14:59Z,"<S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\n"" , ptr , size ) ) ; <S2SV_EndBug>"
5074,CWE-400,"const char * nghttp2_strerror ( int error_code ) { switch ( error_code ) { case 0 : return ""Success"" ; case NGHTTP2_ERR_INVALID_ARGUMENT : return ""Invalid<S2SV_blank>argument"" ; case NGHTTP2_ERR_BUFFER_ERROR : return ""Out<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>space"" ; case NGHTTP2_ERR_UNSUPPORTED_VERSION : return ""Unsupported<S2SV_blank>SPDY<S2SV_blank>version"" ; case NGHTTP2_ERR_WOULDBLOCK : return ""Operation<S2SV_blank>would<S2SV_blank>block"" ; case NGHTTP2_ERR_PROTO : return ""Protocol<S2SV_blank>error"" ; case NGHTTP2_ERR_INVALID_FRAME : return ""Invalid<S2SV_blank>frame<S2SV_blank>octets"" ; case NGHTTP2_ERR_EOF : return ""EOF"" ; case NGHTTP2_ERR_DEFERRED : return ""Data<S2SV_blank>transfer<S2SV_blank>deferred"" ; case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE : return ""No<S2SV_blank>more<S2SV_blank>Stream<S2SV_blank>ID<S2SV_blank>available"" ; case NGHTTP2_ERR_STREAM_CLOSED : return ""Stream<S2SV_blank>was<S2SV_blank>already<S2SV_blank>closed<S2SV_blank>or<S2SV_blank>invalid"" ; case NGHTTP2_ERR_STREAM_CLOSING : return ""Stream<S2SV_blank>is<S2SV_blank>closing"" ; case NGHTTP2_ERR_STREAM_SHUT_WR : return ""The<S2SV_blank>transmission<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>this<S2SV_blank>stream"" ; case NGHTTP2_ERR_INVALID_STREAM_ID : return ""Stream<S2SV_blank>ID<S2SV_blank>is<S2SV_blank>invalid"" ; case NGHTTP2_ERR_INVALID_STREAM_STATE : return ""Invalid<S2SV_blank>stream<S2SV_blank>state"" ; case NGHTTP2_ERR_DEFERRED_DATA_EXIST : return ""Another<S2SV_blank>DATA<S2SV_blank>frame<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>deferred"" ; case NGHTTP2_ERR_START_STREAM_NOT_ALLOWED : return ""request<S2SV_blank>HEADERS<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed"" ; case NGHTTP2_ERR_GOAWAY_ALREADY_SENT : return ""GOAWAY<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>sent"" ; case NGHTTP2_ERR_INVALID_HEADER_BLOCK : return ""Invalid<S2SV_blank>header<S2SV_blank>block"" ; case NGHTTP2_ERR_INVALID_STATE : return ""Invalid<S2SV_blank>state"" ; case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE : return ""The<S2SV_blank>user<S2SV_blank>callback<S2SV_blank>function<S2SV_blank>failed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>the<S2SV_blank>temporal<S2SV_blank>error"" ; case NGHTTP2_ERR_FRAME_SIZE_ERROR : return ""The<S2SV_blank>length<S2SV_blank>of<S2SV_blank>the<S2SV_blank>frame<S2SV_blank>is<S2SV_blank>invalid"" ; case NGHTTP2_ERR_HEADER_COMP : return ""Header<S2SV_blank>compression/decompression<S2SV_blank>error"" ; case NGHTTP2_ERR_FLOW_CONTROL : return ""Flow<S2SV_blank>control<S2SV_blank>error"" ; case NGHTTP2_ERR_INSUFF_BUFSIZE : return ""Insufficient<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>given<S2SV_blank>to<S2SV_blank>function"" ; case NGHTTP2_ERR_PAUSE : return ""Callback<S2SV_blank>was<S2SV_blank>paused<S2SV_blank>by<S2SV_blank>the<S2SV_blank>application"" ; case NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS : return ""Too<S2SV_blank>many<S2SV_blank>inflight<S2SV_blank>SETTINGS"" ; case NGHTTP2_ERR_PUSH_DISABLED : return ""Server<S2SV_blank>push<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>peer"" ; case NGHTTP2_ERR_DATA_EXIST : return ""DATA<S2SV_blank>or<S2SV_blank>HEADERS<S2SV_blank>frame<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>submitted<S2SV_blank>for<S2SV_blank>the<S2SV_blank>stream"" ; case NGHTTP2_ERR_SESSION_CLOSING : return ""The<S2SV_blank>current<S2SV_blank>session<S2SV_blank>is<S2SV_blank>closing"" ; case NGHTTP2_ERR_HTTP_HEADER : return ""Invalid<S2SV_blank>HTTP<S2SV_blank>header<S2SV_blank>field<S2SV_blank>was<S2SV_blank>received"" ; case NGHTTP2_ERR_HTTP_MESSAGING : return ""Violation<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>messaging<S2SV_blank>rule"" ; case NGHTTP2_ERR_REFUSED_STREAM : return ""Stream<S2SV_blank>was<S2SV_blank>refused"" ; case NGHTTP2_ERR_INTERNAL : return ""Internal<S2SV_blank>error"" ; case NGHTTP2_ERR_CANCEL : return ""Cancel"" ; case NGHTTP2_ERR_SETTINGS_EXPECTED : return ""When<S2SV_blank>a<S2SV_blank>local<S2SV_blank>endpoint<S2SV_blank>expects<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>SETTINGS<S2SV_blank>frame,<S2SV_blank>it<S2SV_blank>"" ""receives<S2SV_blank>an<S2SV_blank>other<S2SV_blank>type<S2SV_blank>of<S2SV_blank>frame"" ; case NGHTTP2_ERR_NOMEM : return ""Out<S2SV_blank>of<S2SV_blank>memory"" ; case NGHTTP2_ERR_CALLBACK_FAILURE : return ""The<S2SV_blank>user<S2SV_blank>callback<S2SV_blank>function<S2SV_blank>failed"" ; case NGHTTP2_ERR_BAD_CLIENT_MAGIC : return ""Received<S2SV_blank>bad<S2SV_blank>client<S2SV_blank>magic<S2SV_blank>byte<S2SV_blank>string"" ; case NGHTTP2_ERR_FLOODED : return ""Flooding<S2SV_blank>was<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>this<S2SV_blank>HTTP/2<S2SV_blank>session,<S2SV_blank>and<S2SV_blank>it<S2SV_blank>must<S2SV_blank>be<S2SV_blank>"" ""closed"" ; <S2SV_StartBug> default : <S2SV_EndBug> return ""Unknown<S2SV_blank>error<S2SV_blank>code"" ; } }
","<S2SV_ModStart> ""Flooding<S2SV_blank>was<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>this<S2SV_blank>HTTP/2<S2SV_blank>session,<S2SV_blank>and<S2SV_blank>it<S2SV_blank>must<S2SV_blank>be<S2SV_blank>"" ""closed"" ; case NGHTTP2_ERR_TOO_MANY_SETTINGS : return ""SETTINGS<S2SV_blank>frame<S2SV_blank>contained<S2SV_blank>more<S2SV_blank>than<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>entries"" ;
",nghttp2@nghttp2/336a98feb0d56b9ac54e12736b18785c27f75090,CVE-2020-11080,https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090,2020-06-03T23:15Z,<S2SV_StartBug> default : <S2SV_EndBug>
341,CWE-862,"static int rename_in_ns ( int pid , char * oldname , char * * newnamep ) { <S2SV_StartBug> int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ; <S2SV_EndBug> bool grab_newname = false ; ofd = lxc_preserve_ns ( getpid ( ) , ""net"" ) ; if ( ofd < 0 ) { <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , getpid ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } fd = lxc_preserve_ns ( pid , ""net"" ) ; if ( fd < 0 ) { <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , pid ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> if ( setns ( fd , 0 ) < 0 ) { <S2SV_EndBug> fprintf ( stderr , ""setns<S2SV_blank>to<S2SV_blank>container<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; goto out_err ; } <S2SV_StartBug> close ( fd ) ; fd = - 1 ; <S2SV_EndBug> if ( ! * newnamep ) { grab_newname = true ; * newnamep = VETH_DEF_NAME ; <S2SV_StartBug> if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) { <S2SV_EndBug> fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index\\n"" ) ; goto out_err ; } } <S2SV_StartBug> if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) { <S2SV_EndBug> fprintf ( stderr , ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container\\n"" , ret , oldname , * newnamep ) ; goto out_err ; } if ( grab_newname ) { <S2SV_StartBug> char ifname [ IFNAMSIZ ] , * namep = ifname ; <S2SV_EndBug> if ( ! if_indextoname ( ifindex , namep ) ) { <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name\\n"" ) ; <S2SV_EndBug> goto out_err ; } * newnamep = strdup ( namep ) ; if ( ! * newnamep ) <S2SV_StartBug> goto out_err ; <S2SV_EndBug> } <S2SV_StartBug> if ( setns ( ofd , 0 ) < 0 ) { <S2SV_EndBug> fprintf ( stderr , ""Error<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>original<S2SV_blank>netns\\n"" ) ; close ( ofd ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } close ( ofd ) ; return 0 ; out_err : if ( ofd >= 0 ) close ( ofd ) ; if ( setns ( ofd , 0 ) < 0 ) fprintf ( stderr , ""Error<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; if ( fd >= 0 ) close ( fd ) ; return - 1 ; }
","<S2SV_ModStart> newnamep ) { uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex <S2SV_ModEnd> = - 1 <S2SV_ModStart> 1 , ret <S2SV_ModEnd> ; bool grab_newname <S2SV_ModStart> 0 ) { usernic_error ( <S2SV_ModEnd> ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , getpid <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } fd <S2SV_ModStart> 0 ) { usernic_error ( <S2SV_ModEnd> ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , pid <S2SV_ModStart> pid ) ; goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>real,<S2SV_blank>effective,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>"" ""user<S2SV_blank>IDs:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = <S2SV_ModEnd> setns ( fd <S2SV_ModStart> ( fd , CLONE_NEWNET ) ; <S2SV_ModEnd> close ( fd <S2SV_ModStart> fd ) ; fd = - 1 ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>of<S2SV_blank>"" ""the<S2SV_blank>container<S2SV_blank>with<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>and<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>0:<S2SV_blank>%s.\\n"" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> = VETH_DEF_NAME ; ifindex = if_nametoindex ( oldname ) ; <S2SV_ModStart> if ( ! ifindex ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\n"" , ret , <S2SV_ModEnd> oldname , * <S2SV_ModStart> * newnamep ) ; goto do_full_cleanup <S2SV_ModEnd> ; } if <S2SV_ModStart> [ IFNAMSIZ ] ; char <S2SV_ModEnd> * namep = <S2SV_ModStart> ) ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup <S2SV_ModEnd> ; } * <S2SV_ModStart> newnamep ) goto do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret = <S2SV_ModEnd> setns ( ofd <S2SV_ModStart> ( ofd , CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>"" ""of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ; close ( <S2SV_ModEnd> ofd ) ; <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } <S2SV_null>
",lxc@lxc/16af238036a5464ae8f2420ed3af214f0de875f9,CVE-2017-5985,https://github.com/lxc/lxc/commit/16af238036a5464ae8f2420ed3af214f0de875f9,2017-03-14T17:59Z,"<S2SV_StartBug> int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , getpid ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , pid ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( setns ( fd , 0 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> close ( fd ) ; fd = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> char ifname [ IFNAMSIZ ] , * namep = ifname ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_err ; <S2SV_EndBug> <S2SV_StartBug> if ( setns ( ofd , 0 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug>"
6432,CWE-78,"int check_restricted ( void ) { if ( restricted ) { <S2SV_StartBug> emsg ( _ ( ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ) ; <S2SV_EndBug> return TRUE ; } return FALSE ; }
","<S2SV_ModStart> ( _ ( ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>and<S2SV_blank>some<S2SV_blank>functionality<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" <S2SV_ModEnd> ) ) ;
",vim@vim/8c62a08faf89663e5633dc5036cd8695c80f1075,CVE-2019-20807,https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075,2020-05-28T14:15Z,"<S2SV_StartBug> emsg ( _ ( ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ) ; <S2SV_EndBug>"
3743,CWE-119,"static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { <S2SV_StartBug> c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> aligned_height = FFALIGN ( c -> height , 16 ) ; <S2SV_EndBug> av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) { c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3 ; aligned_height = FFALIGN ( c -> tile_height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM ) ; } return 0 ; }
","<S2SV_ModStart> c -> width + 15 <S2SV_ModEnd> , 16 ) <S2SV_ModStart> , 16 ) * 3 ; aligned_height = <S2SV_ModEnd> c -> height <S2SV_ModStart> c -> height + 15 <S2SV_ModEnd> ; av_free (
",FFmpeg@FFmpeg/e07ac727c1cc9eed39e7f9117c97006f719864bd,CVE-2013-7022,https://github.com/FFmpeg/FFmpeg/commit/e07ac727c1cc9eed39e7f9117c97006f719864bd,2013-12-09T16:36Z,"<S2SV_StartBug> c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> aligned_height = FFALIGN ( c -> height , 16 ) ; <S2SV_EndBug>"
3251,CWE-617,"int ff_h263_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; MpegEncContext * s = avctx -> priv_data ; int ret ; int slice_ret = 0 ; AVFrame * pict = data ; if ( buf_size == 0 ) { if ( s -> low_delay == 0 && s -> next_picture_ptr ) { if ( ( ret = av_frame_ref ( pict , s -> next_picture_ptr -> f ) ) < 0 ) return ret ; s -> next_picture_ptr = NULL ; * got_frame = 1 ; } return 0 ; } if ( s -> avctx -> flags & AV_CODEC_FLAG_TRUNCATED ) { int next ; if ( CONFIG_MPEG4_DECODER && s -> codec_id == AV_CODEC_ID_MPEG4 ) { next = ff_mpeg4_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else if ( CONFIG_H263_DECODER && s -> codec_id == AV_CODEC_ID_H263 ) { next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else if ( CONFIG_H263P_DECODER && s -> codec_id == AV_CODEC_ID_H263P ) { next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else { av_log ( s -> avctx , AV_LOG_ERROR , ""this<S2SV_blank>codec<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>truncated<S2SV_blank>bitstreams\\n"" ) ; return AVERROR ( ENOSYS ) ; } if ( ff_combine_frame ( & s -> parse_context , next , ( const uint8_t * * ) & buf , & buf_size ) < 0 ) return buf_size ; } retry : if ( s -> divx_packed && s -> bitstream_buffer_size ) { int i ; for ( i = 0 ; i < buf_size - 3 ; i ++ ) { if ( buf [ i ] == 0 && buf [ i + 1 ] == 0 && buf [ i + 2 ] == 1 ) { if ( buf [ i + 3 ] == 0xB0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>excessive<S2SV_blank>bitstream<S2SV_blank>in<S2SV_blank>packed<S2SV_blank>xvid\\n"" ) ; s -> bitstream_buffer_size = 0 ; } break ; } } } if ( s -> bitstream_buffer_size && ( s -> divx_packed || buf_size <= MAX_NVOP_SIZE ) ) ret = init_get_bits8 ( & s -> gb , s -> bitstream_buffer , s -> bitstream_buffer_size ) ; else ret = init_get_bits8 ( & s -> gb , buf , buf_size ) ; s -> bitstream_buffer_size = 0 ; if ( ret < 0 ) return ret ; if ( ! s -> context_initialized ) ff_mpv_idct_init ( s ) ; if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { ret = ff_wmv2_decode_picture_header ( s ) ; } else if ( CONFIG_MSMPEG4_DECODER && s -> msmpeg4_version ) { ret = ff_msmpeg4_decode_picture_header ( s ) ; } else if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( s -> avctx -> extradata_size && s -> picture_number == 0 ) { GetBitContext gb ; if ( init_get_bits8 ( & gb , s -> avctx -> extradata , s -> avctx -> extradata_size ) >= 0 ) ff_mpeg4_decode_picture_header ( avctx -> priv_data , & gb ) ; } ret = ff_mpeg4_decode_picture_header ( avctx -> priv_data , & s -> gb ) ; } else if ( CONFIG_H263I_DECODER && s -> codec_id == AV_CODEC_ID_H263I ) { ret = ff_intel_h263_decode_picture_header ( s ) ; } else if ( CONFIG_FLV_DECODER && s -> h263_flv ) { ret = ff_flv_decode_picture_header ( s ) ; } else { ret = ff_h263_decode_picture_header ( s ) ; } if ( ret < 0 || ret == FRAME_SKIPPED ) { if ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height ) { av_log ( s -> avctx , AV_LOG_WARNING , ""Reverting<S2SV_blank>picture<S2SV_blank>dimensions<S2SV_blank>change<S2SV_blank>due<S2SV_blank>to<S2SV_blank>header<S2SV_blank>decoding<S2SV_blank>failure\\n"" ) ; s -> width = avctx -> coded_width ; s -> height = avctx -> coded_height ; } } if ( ret == FRAME_SKIPPED ) return get_consumed_bytes ( s , buf_size ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""header<S2SV_blank>damaged\\n"" ) ; return ret ; } if ( ! s -> context_initialized ) { avctx -> pix_fmt = h263_get_format ( avctx ) ; if ( ( ret = ff_mpv_common_init ( s ) ) < 0 ) return ret ; } if ( ! s -> current_picture_ptr || s -> current_picture_ptr -> f -> data [ 0 ] ) { int i = ff_find_unused_picture ( s -> avctx , s -> picture , 0 ) ; if ( i < 0 ) return i ; s -> current_picture_ptr = & s -> picture [ i ] ; } avctx -> has_b_frames = ! s -> low_delay ; if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( ff_mpeg4_workaround_bugs ( avctx ) == 1 ) goto retry ; if ( s -> studio_profile != ( s -> idsp . idct == NULL ) ) ff_mpv_idct_init ( s ) ; } if ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height || s -> context_reinit ) { s -> context_reinit = 0 ; ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ; if ( ret < 0 ) return ret ; ff_set_sar ( avctx , avctx -> sample_aspect_ratio ) ; if ( ( ret = ff_mpv_common_frame_size_change ( s ) ) ) return ret ; if ( avctx -> pix_fmt != h263_get_format ( avctx ) ) { av_log ( avctx , AV_LOG_ERROR , ""format<S2SV_blank>change<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; avctx -> pix_fmt = AV_PIX_FMT_NONE ; return AVERROR_UNKNOWN ; } } if ( s -> codec_id == AV_CODEC_ID_H263 || s -> codec_id == AV_CODEC_ID_H263P || s -> codec_id == AV_CODEC_ID_H263I ) s -> gob_index = H263_GOB_HEIGHT ( s -> height ) ; s -> current_picture . f -> pict_type = s -> pict_type ; s -> current_picture . f -> key_frame = s -> pict_type == AV_PICTURE_TYPE_I ; if ( ! s -> last_picture_ptr && ( s -> pict_type == AV_PICTURE_TYPE_B || s -> droppable ) ) return get_consumed_bytes ( s , buf_size ) ; if ( ( avctx -> skip_frame >= AVDISCARD_NONREF && s -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL ) return get_consumed_bytes ( s , buf_size ) ; if ( s -> next_p_frame_damaged ) { if ( s -> pict_type == AV_PICTURE_TYPE_B ) return get_consumed_bytes ( s , buf_size ) ; else s -> next_p_frame_damaged = 0 ; } if ( ( ! s -> no_rounding ) || s -> pict_type == AV_PICTURE_TYPE_B ) { s -> me . qpel_put = s -> qdsp . put_qpel_pixels_tab ; s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; } else { s -> me . qpel_put = s -> qdsp . put_no_rnd_qpel_pixels_tab ; s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; } if ( ( ret = ff_mpv_frame_start ( s , avctx ) ) < 0 ) return ret ; if ( ! s -> divx_packed ) ff_thread_finish_setup ( avctx ) ; if ( avctx -> hwaccel ) { ret = avctx -> hwaccel -> start_frame ( avctx , s -> gb . buffer , s -> gb . buffer_end - s -> gb . buffer ) ; if ( ret < 0 ) return ret ; } ff_mpeg_er_frame_start ( s ) ; if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { ret = ff_wmv2_decode_secondary_picture_header ( s ) ; if ( ret < 0 ) return ret ; if ( ret == 1 ) goto frame_end ; } s -> mb_x = 0 ; s -> mb_y = 0 ; slice_ret = decode_slice ( s ) ; while ( s -> mb_y < s -> mb_height ) { if ( s -> msmpeg4_version ) { if ( s -> slice_height == 0 || s -> mb_x != 0 || slice_ret < 0 || ( s -> mb_y % s -> slice_height ) != 0 || get_bits_left ( & s -> gb ) < 0 ) break ; } else { int prev_x = s -> mb_x , prev_y = s -> mb_y ; if ( ff_h263_resync ( s ) < 0 ) break ; if ( prev_y * s -> mb_width + prev_x < s -> mb_y * s -> mb_width + s -> mb_x ) s -> er . error_occurred = 1 ; } if ( s -> msmpeg4_version < 4 && s -> h263_pred ) ff_mpeg4_clean_buffers ( s ) ; if ( decode_slice ( s ) < 0 ) slice_ret = AVERROR_INVALIDDATA ; } if ( s -> msmpeg4_version && s -> msmpeg4_version < 4 && s -> pict_type == AV_PICTURE_TYPE_I ) if ( ! CONFIG_MSMPEG4_DECODER || ff_msmpeg4_decode_ext_header ( s , buf_size ) < 0 ) s -> er . error_status_table [ s -> mb_num - 1 ] = ER_MB_ERROR ; av_assert1 ( s -> bitstream_buffer_size == 0 ) ; <S2SV_StartBug> frame_end : <S2SV_EndBug> ff_er_frame_end ( & s -> er ) ; if ( avctx -> hwaccel ) { ret = avctx -> hwaccel -> end_frame ( avctx ) ; if ( ret < 0 ) return ret ; } ff_mpv_frame_end ( s ) ; if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) ff_mpeg4_frame_end ( avctx , buf , buf_size ) ; if ( ! s -> divx_packed && avctx -> hwaccel ) ff_thread_finish_setup ( avctx ) ; av_assert1 ( s -> current_picture . f -> pict_type == s -> current_picture_ptr -> f -> pict_type ) ; av_assert1 ( s -> current_picture . f -> pict_type == s -> pict_type ) ; if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) { if ( ( ret = av_frame_ref ( pict , s -> current_picture_ptr -> f ) ) < 0 ) return ret ; ff_print_debug_info ( s , s -> current_picture_ptr , pict ) ; ff_mpv_export_qp_table ( s , pict , s -> current_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; } else if ( s -> last_picture_ptr ) { if ( ( ret = av_frame_ref ( pict , s -> last_picture_ptr -> f ) ) < 0 ) return ret ; ff_print_debug_info ( s , s -> last_picture_ptr , pict ) ; ff_mpv_export_qp_table ( s , pict , s -> last_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; } if ( s -> last_picture_ptr || s -> low_delay ) { if ( pict -> format == AV_PIX_FMT_YUV420P && ( s -> codec_tag == AV_RL32 ( ""GEOV"" ) || s -> codec_tag == AV_RL32 ( ""GEOX"" ) ) ) { int x , y , p ; av_frame_make_writable ( pict ) ; for ( p = 0 ; p < 3 ; p ++ ) { int w = AV_CEIL_RSHIFT ( pict -> width , ! ! p ) ; int h = AV_CEIL_RSHIFT ( pict -> height , ! ! p ) ; int linesize = pict -> linesize [ p ] ; for ( y = 0 ; y < ( h >> 1 ) ; y ++ ) for ( x = 0 ; x < w ; x ++ ) FFSWAP ( int , pict -> data [ p ] [ x + y * linesize ] , pict -> data [ p ] [ x + ( h - 1 - y ) * linesize ] ) ; } } * got_frame = 1 ; } if ( slice_ret < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) return slice_ret ; else return get_consumed_bytes ( s , buf_size ) ; }
","<S2SV_ModStart> ; frame_end : if ( ! s -> studio_profile )
",FFmpeg@FFmpeg/bd27a9364ca274ca97f1df6d984e88a0700fb235,CVE-2018-13304,https://github.com/FFmpeg/FFmpeg/commit/bd27a9364ca274ca97f1df6d984e88a0700fb235,2018-07-05T17:29Z,<S2SV_StartBug> frame_end : <S2SV_EndBug>
3399,CWE-404,"int nfs3svc_decode_readlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readlinkargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; <S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
","<S2SV_ModStart> return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z,"<S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug>"
2387,CWE-000,"int ext4_ext_insert_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_extent * newext , int flag ) { struct ext4_extent_header * eh ; struct ext4_extent * ex , * fex ; struct ext4_extent * nearex ; struct ext4_ext_path * npath = NULL ; int depth , len , err ; ext4_lblk_t next ; unsigned uninitialized = 0 ; BUG_ON ( ext4_ext_get_actual_len ( newext ) == 0 ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; BUG_ON ( path [ depth ] . p_hdr == NULL ) ; <S2SV_StartBug> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> && ext4_can_extents_be_merged ( inode , ex , newext ) ) { ext_debug ( ""append<S2SV_blank>[%d]%d<S2SV_blank>block<S2SV_blank>to<S2SV_blank>%d:[%d]%d<S2SV_blank>(from<S2SV_blank>%llu)\\n"" , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , le32_to_cpu ( ex -> ee_block ) , ext4_ext_is_uninitialized ( ex ) , ext4_ext_get_actual_len ( ex ) , ext_pblock ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) return err ; if ( ext4_ext_is_uninitialized ( ex ) ) uninitialized = 1 ; ex -> ee_len = cpu_to_le16 ( ext4_ext_get_actual_len ( ex ) + ext4_ext_get_actual_len ( newext ) ) ; if ( uninitialized ) ext4_ext_mark_uninitialized ( ex ) ; eh = path [ depth ] . p_hdr ; nearex = ex ; goto merge ; } repeat : depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) goto has_space ; fex = EXT_LAST_EXTENT ( eh ) ; next = ext4_ext_next_leaf_block ( inode , path ) ; if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( fex -> ee_block ) && next != EXT_MAX_BLOCK ) { ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>block<S2SV_blank>-<S2SV_blank>%d\\n"" , next ) ; BUG_ON ( npath != NULL ) ; npath = ext4_ext_find_extent ( inode , next , NULL ) ; if ( IS_ERR ( npath ) ) return PTR_ERR ( npath ) ; BUG_ON ( npath -> p_depth != path -> p_depth ) ; eh = npath [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) { ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>isnt<S2SV_blank>full(%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) ) ; path = npath ; goto repeat ; } ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>has<S2SV_blank>no<S2SV_blank>free<S2SV_blank>space(%d,%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) , le16_to_cpu ( eh -> eh_max ) ) ; } err = ext4_ext_create_new_leaf ( handle , inode , path , newext ) ; if ( err ) goto cleanup ; depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; has_space : nearex = path [ depth ] . p_ext ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; if ( ! nearex ) { ext_debug ( ""first<S2SV_blank>extent<S2SV_blank>in<S2SV_blank>the<S2SV_blank>leaf:<S2SV_blank>%d:%llu:[%d]%d\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) ) ; path [ depth ] . p_ext = EXT_FIRST_EXTENT ( eh ) ; } else if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( nearex -> ee_block ) ) { if ( nearex != EXT_LAST_EXTENT ( eh ) ) { len = EXT_MAX_EXTENT ( eh ) - nearex ; len = ( len - 1 ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>after:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 2 , nearex + 1 , len ) ; } path [ depth ] . p_ext = nearex + 1 ; } else { BUG_ON ( newext -> ee_block == nearex -> ee_block ) ; len = ( EXT_MAX_EXTENT ( eh ) - nearex ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>before:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 1 , nearex , len ) ; path [ depth ] . p_ext = nearex ; } le16_add_cpu ( & eh -> eh_entries , 1 ) ; nearex = path [ depth ] . p_ext ; nearex -> ee_block = newext -> ee_block ; ext4_ext_store_pblock ( nearex , ext_pblock ( newext ) ) ; nearex -> ee_len = newext -> ee_len ; merge : <S2SV_StartBug> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> ext4_ext_try_to_merge ( inode , path , nearex ) ; err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto cleanup ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; cleanup : if ( npath ) { ext4_ext_drop_refs ( npath ) ; kfree ( npath ) ; } ext4_ext_invalidate_cache ( inode ) ; return err ; }
","<S2SV_ModStart> ( ex && ! ( flag & <S2SV_ModEnd> EXT4_GET_BLOCKS_PRE_IO ) && <S2SV_ModStart> : if ( ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) <S2SV_ModEnd> ) ext4_ext_try_to_merge (
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,<S2SV_StartBug> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> <S2SV_StartBug> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug>
2080,CWE-200,"static int tipc_nl_compat_link_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) { struct nlattr * link [ TIPC_NLA_LINK_MAX + 1 ] ; struct tipc_link_info link_info ; int err ; if ( ! attrs [ TIPC_NLA_LINK ] ) return - EINVAL ; err = nla_parse_nested ( link , TIPC_NLA_LINK_MAX , attrs [ TIPC_NLA_LINK ] , NULL ) ; if ( err ) return err ; link_info . dest = nla_get_flag ( link [ TIPC_NLA_LINK_DEST ] ) ; link_info . up = htonl ( nla_get_flag ( link [ TIPC_NLA_LINK_UP ] ) ) ; <S2SV_StartBug> strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ; <S2SV_EndBug> return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ; }
","<S2SV_ModStart> ) ) ; nla_strlcpy <S2SV_ModEnd> ( link_info . <S2SV_ModStart> TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME
",torvalds@linux/5d2be1422e02ccd697ccfcd45c85b4a26e6178e2,CVE-2016-5243,https://github.com/torvalds/linux/commit/5d2be1422e02ccd697ccfcd45c85b4a26e6178e2,2016-06-27T10:59Z,"<S2SV_StartBug> strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ; <S2SV_EndBug>"
1860,CWE-119,"<S2SV_StartBug> int64_t vp9_block_error_c ( const int16_t * coeff , const int16_t * dqcoeff , <S2SV_EndBug> intptr_t block_size , int64_t * ssz ) { int i ; int64_t error = 0 , sqcoeff = 0 ; for ( i = 0 ; i < block_size ; i ++ ) { const int diff = coeff [ i ] - dqcoeff [ i ] ; error += diff * diff ; sqcoeff += coeff [ i ] * coeff [ i ] ; } * ssz = sqcoeff ; return error ; }
","<S2SV_ModStart> vp9_block_error_c ( const tran_low_t <S2SV_ModEnd> * coeff , <S2SV_ModStart> coeff , const tran_low_t <S2SV_ModEnd> * dqcoeff ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int64_t vp9_block_error_c ( const int16_t * coeff , const int16_t * dqcoeff , <S2SV_EndBug>"
1395,CWE-119,"static void yv12_extend_frame_top_c ( YV12_BUFFER_CONFIG * ybf ) { int i ; unsigned char * src_ptr1 ; unsigned char * dest_ptr1 ; unsigned int Border ; int plane_stride ; Border = ybf -> border ; plane_stride = ybf -> y_stride ; src_ptr1 = ybf -> y_buffer - Border ; dest_ptr1 = src_ptr1 - ( Border * plane_stride ) ; for ( i = 0 ; i < ( int ) Border ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> dest_ptr1 += plane_stride ; } plane_stride = ybf -> uv_stride ; Border /= 2 ; src_ptr1 = ybf -> u_buffer - Border ; dest_ptr1 = src_ptr1 - ( Border * plane_stride ) ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> dest_ptr1 += plane_stride ; } src_ptr1 = ybf -> v_buffer - Border ; dest_ptr1 = src_ptr1 - ( Border * plane_stride ) ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> dest_ptr1 += plane_stride ; } }
","<S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr1 , <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr1 , <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr1 ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug>"
2986,CWE-200,"static int raptor_rss_parse_start ( raptor_parser * rdf_parser ) { raptor_uri * uri = rdf_parser -> base_uri ; raptor_rss_parser * rss_parser = ( raptor_rss_parser * ) rdf_parser -> context ; int n ; if ( ! uri ) return 1 ; for ( n = 0 ; n < RAPTOR_RSS_NAMESPACES_SIZE ; n ++ ) rss_parser -> nspaces_seen [ n ] = 'N' ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_NO_NET , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_NET ) ) ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_NO_FILE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_FILE ) ) ; <S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ; raptor_sax2_parse_start ( rss_parser -> sax2 , uri ) ; return 0 ; }
","<S2SV_ModStart> ) ) ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;
",dajobe@raptor/a676f235309a59d4aa78eeffd2574ae5d341fcb0,CVE-2012-0037,https://github.com/dajobe/raptor/commit/a676f235309a59d4aa78eeffd2574ae5d341fcb0,2012-06-17T03:41Z,<S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug>
2454,CWE-20,"static void icmp6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , const struct in6_addr * force_saddr ) { struct net * net = dev_net ( skb -> dev ) ; struct inet6_dev * idev = NULL ; struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; struct sock * sk ; struct ipv6_pinfo * np ; const struct in6_addr * saddr = NULL ; struct dst_entry * dst ; struct icmp6hdr tmp_hdr ; struct flowi6 fl6 ; struct icmpv6_msg msg ; struct sockcm_cookie sockc_unused = { 0 } ; struct ipcm6_cookie ipc6 ; int iif = 0 ; int addr_type = 0 ; int len ; int err = 0 ; u32 mark = IP6_REPLY_MARK ( net , skb -> mark ) ; if ( ( u8 * ) hdr < skb -> head || ( skb_network_header ( skb ) + sizeof ( * hdr ) ) > skb_tail_pointer ( skb ) ) return ; addr_type = ipv6_addr_type ( & hdr -> daddr ) ; if ( ipv6_chk_addr ( net , & hdr -> daddr , skb -> dev , 0 ) || ipv6_chk_acast_addr_src ( net , skb -> dev , & hdr -> daddr ) ) saddr = & hdr -> daddr ; if ( addr_type & IPV6_ADDR_MULTICAST || skb -> pkt_type != PACKET_HOST ) { if ( type != ICMPV6_PKT_TOOBIG && ! ( type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && ( opt_unrec ( skb , info ) ) ) ) return ; saddr = NULL ; } addr_type = ipv6_addr_type ( & hdr -> saddr ) ; if ( __ipv6_addr_needs_scope_id ( addr_type ) ) iif = skb -> dev -> ifindex ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug> if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) { net_dbg_ratelimited ( ""icmp6_send:<S2SV_blank>addr_any/mcast<S2SV_blank>source<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; return ; } if ( is_ineligible ( skb ) ) { net_dbg_ratelimited ( ""icmp6_send:<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>icmp<S2SV_blank>error<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; return ; } mip6_addr_swap ( skb ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_ICMPV6 ; fl6 . daddr = hdr -> saddr ; if ( force_saddr ) saddr = force_saddr ; if ( saddr ) fl6 . saddr = * saddr ; fl6 . flowi6_mark = mark ; fl6 . flowi6_oif = iif ; fl6 . fl6_icmp_type = type ; fl6 . fl6_icmp_code = code ; security_skb_classify_flow ( skb , flowi6_to_flowi ( & fl6 ) ) ; sk = icmpv6_xmit_lock ( net ) ; if ( ! sk ) return ; sk -> sk_mark = mark ; np = inet6_sk ( sk ) ; if ( ! icmpv6_xrlim_allow ( sk , type , & fl6 ) ) goto out ; tmp_hdr . icmp6_type = type ; tmp_hdr . icmp6_code = code ; tmp_hdr . icmp6_cksum = 0 ; tmp_hdr . icmp6_pointer = htonl ( info ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; ipc6 . tclass = np -> tclass ; fl6 . flowlabel = ip6_make_flowinfo ( ipc6 . tclass , fl6 . flowlabel ) ; dst = icmpv6_route_lookup ( net , skb , sk , & fl6 ) ; if ( IS_ERR ( dst ) ) goto out ; ipc6 . hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; ipc6 . dontfrag = np -> dontfrag ; ipc6 . opt = NULL ; msg . skb = skb ; msg . offset = skb_network_offset ( skb ) ; msg . type = type ; len = skb -> len - msg . offset ; len = min_t ( unsigned int , len , IPV6_MIN_MTU - sizeof ( struct ipv6hdr ) - sizeof ( struct icmp6hdr ) ) ; if ( len < 0 ) { net_dbg_ratelimited ( ""icmp:<S2SV_blank>len<S2SV_blank>problem<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; goto out_dst_release ; } rcu_read_lock ( ) ; idev = __in6_dev_get ( skb -> dev ) ; err = ip6_append_data ( sk , icmpv6_getfrag , & msg , len + sizeof ( struct icmp6hdr ) , sizeof ( struct icmp6hdr ) , & ipc6 , & fl6 , ( struct rt6_info * ) dst , MSG_DONTWAIT , & sockc_unused ) ; if ( err ) { ICMP6_INC_STATS ( net , idev , ICMP6_MIB_OUTERRORS ) ; ip6_flush_pending_frames ( sk ) ; } else { err = icmpv6_push_pending_frames ( sk , & fl6 , & tmp_hdr , len + sizeof ( struct icmp6hdr ) ) ; } rcu_read_unlock ( ) ; out_dst_release : dst_release ( dst ) ; out : icmpv6_xmit_unlock ( sk ) ; }
","<S2SV_ModStart> ifindex ; else { dst = skb_dst ( skb ) ; <S2SV_ModStart> = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ; } <S2SV_ModEnd> if ( (
",torvalds@linux/79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2,CVE-2016-9919,https://github.com/torvalds/linux/commit/79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2,2016-12-08T17:59Z,<S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug>
8126,CWE-295,"NOEXPORT char * base64 ( int encode , const char * in , int len ) { BIO * bio , * b64 ; char * out ; int n ; b64 = BIO_new ( BIO_f_base64 ( ) ) ; if ( ! b64 ) return NULL ; BIO_set_flags ( b64 , BIO_FLAGS_BASE64_NO_NL ) ; bio = BIO_new ( BIO_s_mem ( ) ) ; if ( ! bio ) { <S2SV_StartBug> str_free ( b64 ) ; <S2SV_EndBug> return NULL ; } if ( encode ) bio = BIO_push ( b64 , bio ) ; BIO_write ( bio , in , len ) ; ( void ) BIO_flush ( bio ) ; if ( encode ) { bio = BIO_pop ( bio ) ; BIO_free ( b64 ) ; } else { bio = BIO_push ( b64 , bio ) ; } n = BIO_pending ( bio ) ; out = str_alloc ( n < 32 ? 32 : ( size_t ) n + 1 ) ; n = BIO_read ( bio , out , n ) ; if ( n < 0 ) { BIO_free_all ( bio ) ; str_free ( out ) ; return NULL ; } BIO_free_all ( bio ) ; return out ; }
","<S2SV_ModStart> bio ) { BIO_free <S2SV_ModEnd> ( b64 )
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,<S2SV_StartBug> str_free ( b64 ) ; <S2SV_EndBug>
2549,CWE-189,"static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; aligned_height = FFALIGN ( c -> height , 16 ) ; av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) { <S2SV_StartBug> c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; <S2SV_EndBug> aligned_height = FFALIGN ( c -> tile_height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM ) ; } return 0 ; }
","<S2SV_ModStart> c -> tile_width <S2SV_ModEnd> , 16 ) <S2SV_ModStart> , 16 ) * 3
",FFmpeg@FFmpeg/821a5938d100458f4d09d634041b05c860554ce0,CVE-2013-7013,https://github.com/FFmpeg/FFmpeg/commit/821a5938d100458f4d09d634041b05c860554ce0,2013-12-09T16:36Z,"<S2SV_StartBug> c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; <S2SV_EndBug>"
2773,CWE-200,"static int rfcomm_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; struct sock * sk = sock -> sk ; <S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> sa -> rc_family = AF_BLUETOOTH ; sa -> rc_channel = rfcomm_pi ( sk ) -> channel ; if ( peer ) bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> dst ) ; else bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> src ) ; * len = sizeof ( struct sockaddr_rc ) ; return 0 ; }
","<S2SV_ModStart> sock , sk ) ; memset ( sa , 0 , sizeof ( * sa )
",torvalds@linux/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,CVE-2012-6545,https://github.com/torvalds/linux/commit/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,2013-03-15T20:55Z,"<S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug>"
3629,CWE-125,"static void rpl_dio_printopt ( netdissect_options * ndo , const struct rpl_dio_genoption * opt , u_int length ) { if ( length < RPL_DIO_GENOPTION_LEN ) return ; length -= RPL_DIO_GENOPTION_LEN ; ND_TCHECK ( opt -> rpl_dio_len ) ; while ( ( opt -> rpl_dio_type == RPL_OPT_PAD0 && ( const u_char * ) opt < ndo -> ndo_snapend ) || ND_TTEST2 ( * opt , ( opt -> rpl_dio_len + 2 ) ) ) { unsigned int optlen = opt -> rpl_dio_len + 2 ; if ( opt -> rpl_dio_type == RPL_OPT_PAD0 ) { optlen = 1 ; ND_PRINT ( ( ndo , ""<S2SV_blank>opt:pad0"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>opt:%s<S2SV_blank>len:%u<S2SV_blank>"" , tok2str ( rpl_subopt_values , ""subopt:%u"" , opt -> rpl_dio_type ) , optlen ) ) ; if ( ndo -> ndo_vflag > 2 ) { unsigned int paylen = opt -> rpl_dio_len ; if ( paylen > length ) paylen = length ; hex_print ( ndo , ""<S2SV_blank>"" , ( ( const uint8_t * ) opt ) + RPL_DIO_GENOPTION_LEN , paylen ) ; } } opt = ( const struct rpl_dio_genoption * ) ( ( ( const char * ) opt ) + optlen ) ; length -= optlen ; <S2SV_StartBug> } <S2SV_EndBug> return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> return ; }
","<S2SV_ModStart> -= optlen ; ND_TCHECK ( opt -> rpl_dio_len ) ; <S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug>"
3987,CWE-20,"static int mISDN_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sk_buff * skb ; <S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> struct sockaddr_mISDN * maddr ; int copied , err ; if ( * debug & DEBUG_SOCKET ) printk ( KERN_DEBUG ""%s:<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>flags<S2SV_blank>%x<S2SV_blank>ch.nr<S2SV_blank>%d,<S2SV_blank>proto<S2SV_blank>%x\\n"" , __func__ , ( int ) len , flags , _pms ( sk ) -> ch . nr , sk -> sk_protocol ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; if ( sk -> sk_state == MISDN_CLOSED ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; <S2SV_StartBug> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <S2SV_EndBug> msg -> msg_namelen = sizeof ( struct sockaddr_mISDN ) ; maddr = ( struct sockaddr_mISDN * ) msg -> msg_name ; maddr -> family = AF_ISDN ; maddr -> dev = _pms ( sk ) -> dev -> id ; if ( ( sk -> sk_protocol == ISDN_P_LAPD_TE ) || ( sk -> sk_protocol == ISDN_P_LAPD_NT ) ) { maddr -> channel = ( mISDN_HEAD_ID ( skb ) >> 16 ) & 0xff ; maddr -> tei = ( mISDN_HEAD_ID ( skb ) >> 8 ) & 0xff ; maddr -> sapi = mISDN_HEAD_ID ( skb ) & 0xff ; } else { maddr -> channel = _pms ( sk ) -> ch . nr ; maddr -> sapi = _pms ( sk ) -> ch . addr & 0xFF ; maddr -> tei = ( _pms ( sk ) -> ch . addr >> 8 ) & 0xFF ; } <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen ) <S2SV_EndBug> printk ( KERN_WARNING ""%s:<S2SV_blank>too<S2SV_blank>small<S2SV_blank>namelen<S2SV_blank>%d\\n"" , __func__ , msg -> msg_namelen ) ; msg -> msg_namelen = 0 ; } copied = skb -> len + MISDN_HEADER_LEN ; if ( len < copied ) { if ( flags & MSG_PEEK ) atomic_dec ( & skb -> users ) ; else skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - ENOSPC ; } memcpy ( skb_push ( skb , MISDN_HEADER_LEN ) , mISDN_HEAD_P ( skb ) , MISDN_HEADER_LEN ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; mISDN_sock_cmsg ( sk , msg , skb ) ; skb_free_datagram ( sk , skb ) ; return err ? : copied ; }
","<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; int copied <S2SV_ModStart> ( msg -> msg_name ) { struct sockaddr_mISDN * maddr = <S2SV_ModEnd> msg -> msg_name <S2SV_ModStart> 0xFF ; } <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = sizeof ( * maddr ) <S2SV_ModEnd> ; } copied
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen ) <S2SV_EndBug>
3883,CWE-264,"static int flakey_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct flakey_c * fc = ti -> private ; <S2SV_StartBug> return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> }
","<S2SV_ModStart> -> private ; struct dm_dev * dev = fc -> dev ; int r = 0 ; if <S2SV_ModEnd> ( fc -> <S2SV_ModStart> ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart> -> bdev , <S2SV_ModEnd> dev -> mode
",torvalds@linux/ec8013beddd717d1740cfefb1a9b900deef85462,CVE-2011-4127,https://github.com/torvalds/linux/commit/ec8013beddd717d1740cfefb1a9b900deef85462,2012-07-03T16:40Z,"<S2SV_StartBug> return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug>"
455,CWE-362,"static void * vips_foreign_load_start ( VipsImage * out , void * a , void * b ) { VipsForeignLoad * load = VIPS_FOREIGN_LOAD ( b ) ; <S2SV_StartBug> VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; <S2SV_EndBug> if ( ! load -> real ) { if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ; # ifdef DEBUG printf ( ""vips_foreign_load_start:<S2SV_blank>triggering<S2SV_blank>->load()\\n"" ) ; # endif load -> real -> progress_signal = load -> out ; g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ; if ( class -> load ( load ) || <S2SV_StartBug> vips_image_pio_input ( load -> real ) ) <S2SV_EndBug> return ( NULL ) ; if ( ! vips_foreign_load_iscompat ( load -> real , out ) ) <S2SV_StartBug> return ( NULL ) ; <S2SV_EndBug> vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ; } return ( vips_region_new ( load -> real ) ) ; }
","<S2SV_ModStart> VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; if ( load -> error ) return ( NULL <S2SV_ModStart> -> real ) || <S2SV_ModEnd> vips_foreign_load_iscompat ( load <S2SV_ModStart> out ) ) { vips_operation_invalidate ( VIPS_OPERATION ( load ) ) ; load -> error = TRUE ; return ( NULL ) ; } <S2SV_ModEnd> vips_image_pipelinev ( load
",jcupitt@libvips/20d840e6da15c1574b3ed998bc92f91d1e36c2a5,CVE-2018-7998,https://github.com/jcupitt/libvips/commit/20d840e6da15c1574b3ed998bc92f91d1e36c2a5,2018-03-09T19:29Z,<S2SV_StartBug> VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; <S2SV_EndBug> <S2SV_StartBug> vips_image_pio_input ( load -> real ) ) <S2SV_EndBug> <S2SV_StartBug> return ( NULL ) ; <S2SV_EndBug>
2792,CWE-426,"static void usage ( void ) { fprintf ( stderr , ""usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\n"" <S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n"" <S2SV_EndBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>-k\\n"" ) ; exit ( 1 ) ; }
","<S2SV_ModStart> stderr , ""usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-P<S2SV_blank>pkcs11_whitelist]<S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n"" <S2SV_ModEnd> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>-k\\n"" ) ;
",openbsd@src/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5,CVE-2016-10009,https://github.com/openbsd/src/commit/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5,2017-01-05T02:59Z,"<S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n"" <S2SV_EndBug>"
4042,CWE-834,"static MagickBooleanType ReadPSDLayersInternal ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , const MagickBooleanType skip_layers , ExceptionInfo * exception ) { char type [ 4 ] ; LayerInfo * layer_info ; MagickSizeType size ; MagickBooleanType status ; register ssize_t i ; ssize_t count , j , number_layers ; size = GetPSDSize ( psd_info , image ) ; if ( size == 0 ) { ( void ) ReadBlobLong ( image ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; status = MagickFalse ; if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) return ( MagickTrue ) ; else { count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count != 0 ) && ( LocaleNCompare ( type , ""Lr16"" , 4 ) == 0 ) ) size = GetPSDSize ( psd_info , image ) ; else return ( MagickTrue ) ; } } status = MagickTrue ; if ( size != 0 ) { layer_info = ( LayerInfo * ) NULL ; number_layers = ( short ) ReadBlobShort ( image ) ; if ( number_layers < 0 ) { number_layers = MagickAbsoluteValue ( number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>negative<S2SV_blank>layer<S2SV_blank>count<S2SV_blank>corrected<S2SV_blank>for"" ) ; image -> matte = MagickTrue ; } if ( skip_layers != MagickFalse ) return ( MagickTrue ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>image<S2SV_blank>contains<S2SV_blank>%.20g<S2SV_blank>layers"" , ( double ) number_layers ) ; if ( number_layers == 0 ) ThrowBinaryException ( CorruptImageError , ""InvalidNumberOfLayers"" , image -> filename ) ; layer_info = ( LayerInfo * ) AcquireQuantumMemory ( ( size_t ) number_layers , sizeof ( * layer_info ) ) ; if ( layer_info == ( LayerInfo * ) NULL ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>LayerInfo<S2SV_blank>failed"" ) ; ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; } ( void ) ResetMagickMemory ( layer_info , 0 , ( size_t ) number_layers * sizeof ( * layer_info ) ) ; for ( i = 0 ; i < number_layers ; i ++ ) { ssize_t x , y ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>layer<S2SV_blank>#%.20g"" , ( double ) i + 1 ) ; layer_info [ i ] . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . x = ReadBlobSignedLong ( image ) ; y = ReadBlobSignedLong ( image ) ; x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . width = ( size_t ) ( x - layer_info [ i ] . page . x ) ; layer_info [ i ] . page . height = ( size_t ) ( y - layer_info [ i ] . page . y ) ; layer_info [ i ] . channels = ReadBlobShort ( image ) ; if ( layer_info [ i ] . channels > MaxPSDChannels ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""MaximumChannelsExceeded"" , image -> filename ) ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>channels=%.20g"" , ( double ) layer_info [ i ] . page . x , ( double ) layer_info [ i ] . page . y , ( double ) layer_info [ i ] . page . height , ( double ) layer_info [ i ] . page . width , ( double ) layer_info [ i ] . channels ) ; for ( j = 0 ; j < ( ssize_t ) layer_info [ i ] . channels ; j ++ ) { layer_info [ i ] . channel_info [ j ] . type = ( short ) ReadBlobShort ( image ) ; layer_info [ i ] . channel_info [ j ] . size = ( size_t ) GetPSDSize ( psd_info , image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>channel[%.20g]:<S2SV_blank>type=%.20g,<S2SV_blank>size=%.20g"" , ( double ) j , ( double ) layer_info [ i ] . channel_info [ j ] . type , ( double ) layer_info [ i ] . channel_info [ j ] . size ) ; } count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>layer<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%.4s<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>8BIM"" , type ) ; layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""ImproperImageHeader"" , image -> filename ) ; } ( void ) ReadBlob ( image , 4 , ( unsigned char * ) layer_info [ i ] . blendkey ) ; ReversePSDString ( image , layer_info [ i ] . blendkey , 4 ) ; layer_info [ i ] . opacity = ( Quantum ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; layer_info [ i ] . clipping = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . flags = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . visible = ! ( layer_info [ i ] . flags & 0x02 ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>blend=%.4s,<S2SV_blank>opacity=%.20g,<S2SV_blank>clipping=%s,<S2SV_blank>flags=%d,<S2SV_blank>visible=%s"" , layer_info [ i ] . blendkey , ( double ) layer_info [ i ] . opacity , layer_info [ i ] . clipping ? ""true"" : ""false"" , layer_info [ i ] . flags , layer_info [ i ] . visible ? ""true"" : ""false"" ) ; ( void ) ReadBlobByte ( image ) ; size = ReadBlobLong ( image ) ; if ( size != 0 ) { MagickSizeType combined_length , length ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>contains<S2SV_blank>additional<S2SV_blank>info"" ) ; length = ReadBlobLong ( image ) ; combined_length = length + 4 ; if ( length != 0 ) { layer_info [ i ] . mask . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . height = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . y ) ; layer_info [ i ] . mask . page . width = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . x ) ; layer_info [ i ] . mask . background = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . mask . flags = ( unsigned char ) ReadBlobByte ( image ) ; if ( ! ( layer_info [ i ] . mask . flags & 0x01 ) ) { layer_info [ i ] . mask . page . y = layer_info [ i ] . mask . page . y - layer_info [ i ] . page . y ; layer_info [ i ] . mask . page . x = layer_info [ i ] . mask . page . x - layer_info [ i ] . page . x ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>mask:<S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>length=%.20g"" , ( double ) layer_info [ i ] . mask . page . x , ( double ) layer_info [ i ] . mask . page . y , ( double ) layer_info [ i ] . mask . page . width , ( double ) layer_info [ i ] . mask . page . height , ( double ) ( ( MagickOffsetType ) length ) - 18 ) ; if ( DiscardBlobBytes ( image , ( MagickSizeType ) ( length - 18 ) ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } length = ReadBlobLong ( image ) ; combined_length += length + 4 ; if ( length != 0 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>blending<S2SV_blank>ranges:<S2SV_blank>length=%.20g"" , ( double ) ( ( MagickOffsetType ) length ) ) ; for ( j = 0 ; j < ( ssize_t ) length ; j += 8 ) { size_t blend_source = ReadBlobLong ( image ) ; size_t blend_dest = ReadBlobLong ( image ) ; <S2SV_StartBug> if ( image -> debug != MagickFalse ) <S2SV_EndBug> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)"" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ; } } length = ( MagickSizeType ) ( unsigned char ) ReadBlobByte ( image ) ; combined_length += length + 1 ; if ( length > 0 ) ( void ) ReadBlob ( image , ( size_t ) length ++ , layer_info [ i ] . name ) ; layer_info [ i ] . name [ length ] = '\\0' ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>name:<S2SV_blank>%s"" , layer_info [ i ] . name ) ; if ( ( length % 4 ) != 0 ) { length = 4 - ( length % 4 ) ; combined_length += length ; if ( DiscardBlobBytes ( image , length ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } length = ( MagickSizeType ) size - combined_length ; if ( length > 0 ) { unsigned char * info ; if ( length > GetBlobSize ( image ) ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ; } layer_info [ i ] . info = AcquireStringInfo ( ( const size_t ) length ) ; info = GetStringInfoDatum ( layer_info [ i ] . info ) ; ( void ) ReadBlob ( image , ( const size_t ) length , info ) ; } } } for ( i = 0 ; i < number_layers ; i ++ ) { if ( ( layer_info [ i ] . page . width == 0 ) || ( layer_info [ i ] . page . height == 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>data<S2SV_blank>is<S2SV_blank>empty"" ) ; if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; continue ; } layer_info [ i ] . image = CloneImage ( image , layer_info [ i ] . page . width , layer_info [ i ] . page . height , MagickFalse , exception ) ; if ( layer_info [ i ] . image == ( Image * ) NULL ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>image<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g<S2SV_blank>failed"" , ( double ) i ) ; ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; } if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) { ( void ) SetImageProfile ( layer_info [ i ] . image , ""psd:additional-info"" , layer_info [ i ] . info ) ; layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; } } if ( image_info -> ping == MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = 0 ; j < layer_info [ i ] . channels ; j ++ ) { if ( DiscardBlobBytes ( image , ( MagickSizeType ) layer_info [ i ] . channel_info [ j ] . size ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } continue ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>data<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g"" , ( double ) i ) ; status = ReadPSDLayer ( image , image_info , psd_info , & layer_info [ i ] , exception ) ; if ( status == MagickFalse ) break ; status = SetImageProgress ( image , LoadImagesTag , i , ( MagickSizeType ) number_layers ) ; if ( status == MagickFalse ) break ; } } if ( status != MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = i ; j < number_layers - 1 ; j ++ ) layer_info [ j ] = layer_info [ j + 1 ] ; number_layers -- ; i -- ; } } if ( number_layers > 0 ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( i > 0 ) layer_info [ i ] . image -> previous = layer_info [ i - 1 ] . image ; if ( i < ( number_layers - 1 ) ) layer_info [ i ] . image -> next = layer_info [ i + 1 ] . image ; layer_info [ i ] . image -> page = layer_info [ i ] . page ; } image -> next = layer_info [ 0 ] . image ; layer_info [ 0 ] . image -> previous = image ; } layer_info = ( LayerInfo * ) RelinquishMagickMemory ( layer_info ) ; } else layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; } return ( status ) ; }
","<S2SV_ModStart> ; if ( EOFBlob ( image ) != MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ; } if (
",ImageMagick@ImageMagick/f68a98a9d385838a1c73ec960a14102949940a64,CVE-2017-14174,https://github.com/ImageMagick/ImageMagick/commit/f68a98a9d385838a1c73ec960a14102949940a64,2017-09-07T06:29Z,<S2SV_StartBug> if ( image -> debug != MagickFalse ) <S2SV_EndBug>
6233,CWE-000,"static int parseFileInner ( MaState * state , cchar * path ) { MaDirective * directive ; char * tok , * key , * line , * value ; assert ( state ) ; assert ( path && * path ) ; if ( openConfig ( state , path ) < 0 ) { return MPR_ERR_CANT_OPEN ; } for ( state -> lineNumber = 1 ; state -> file && ( line = mprReadLine ( state -> file , 0 , NULL ) ) != 0 ; state -> lineNumber ++ ) { for ( tok = line ; isspace ( ( uchar ) * tok ) ; tok ++ ) ; if ( * tok == '\\0' || * tok == '#' ) { continue ; } state -> key = 0 ; <S2SV_StartBug> key = getDirective ( line , & value ) ; <S2SV_EndBug> if ( ! state -> enabled ) { if ( key [ 0 ] != '<' ) { continue ; } } if ( ( directive = mprLookupKey ( directives , key ) ) == 0 ) { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Unknown<S2SV_blank>directive<S2SV_blank>\\""%s\\"".<S2SV_blank>At<S2SV_blank>line<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s"" , key , state -> lineNumber , state -> filename ) ; return MPR_ERR_BAD_SYNTAX ; } state -> key = key ; mprPauseGC ( ) ; if ( ( * directive ) ( state , key , value ) < 0 ) { mprResumeGC ( ) ; mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Error<S2SV_blank>with<S2SV_blank>directive<S2SV_blank>\\""%s\\"".<S2SV_blank>At<S2SV_blank>line<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s"" , state -> key , state -> lineNumber , state -> filename ) ; return MPR_ERR_BAD_SYNTAX ; } mprResumeGC ( ) ; mprYield ( 0 ) ; state = state -> top -> current ; } if ( state -> prev && state -> file == state -> prev -> file ) { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Unclosed<S2SV_blank>directives<S2SV_blank>in<S2SV_blank>%s"" , state -> filename ) ; while ( state -> prev && state -> file == state -> prev -> file ) { state = state -> prev ; } } mprCloseFile ( state -> file ) ; return 0 ; }
","<S2SV_ModStart> = 0 ; if ( ( <S2SV_ModStart> & value ) ) == 0 ) { continue ; } <S2SV_ModEnd> if ( !
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,"<S2SV_StartBug> key = getDirective ( line , & value ) ; <S2SV_EndBug>"
3945,CWE-476,"static int tls_construct_cke_dhe ( SSL * s , unsigned char * * p , int * len , int * al ) { # ifndef OPENSSL_NO_DH DH * dh_clnt = NULL ; const BIGNUM * pub_key ; EVP_PKEY * ckey = NULL , * skey = NULL ; skey = s -> s3 -> peer_tmp ; if ( skey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; } ckey = ssl_generate_pkey ( skey ) ; <S2SV_StartBug> dh_clnt = EVP_PKEY_get0_DH ( ckey ) ; <S2SV_EndBug> if ( dh_clnt == NULL || ssl_derive ( s , ckey , skey ) == 0 ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; EVP_PKEY_free ( ckey ) ; return 0 ; } DH_get0_key ( dh_clnt , & pub_key , NULL ) ; * len = BN_num_bytes ( pub_key ) ; s2n ( * len , * p ) ; BN_bn2bin ( pub_key , * p ) ; * len += 2 ; EVP_PKEY_free ( ckey ) ; return 1 ; # else SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; # endif }
","<S2SV_ModStart> skey ) ; if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; }
",openssl@openssl/efbe126e3ebb9123ac9d058aa2bb044261342aaa,CVE-2017-3730,https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa,2017-05-04T19:29Z,<S2SV_StartBug> dh_clnt = EVP_PKEY_get0_DH ( ckey ) ; <S2SV_EndBug>
3302,CWE-125,"void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
",torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc,CVE-2019-15090,https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc,2019-08-16T00:15Z,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug>"
1052,CWE-284,"socket_t * socket_accept ( const socket_t * socket ) { assert ( socket != NULL ) ; <S2SV_StartBug> int fd = accept ( socket -> fd , NULL , NULL ) ; <S2SV_EndBug> if ( fd == INVALID_FD ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>accept<S2SV_blank>socket:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; return NULL ; } socket_t * ret = ( socket_t * ) osi_calloc ( sizeof ( socket_t ) ) ; if ( ! ret ) { close ( fd ) ; LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>socket."" , __func__ ) ; return NULL ; } ret -> fd = fd ; return ret ; }
","<S2SV_ModStart> int fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> NULL , NULL )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> int fd = accept ( socket -> fd , NULL , NULL ) ; <S2SV_EndBug>"
2282,CWE-476,"smb_sdrc_t smb_com_flush ( smb_request_t * sr ) { smb_ofile_t * file ; smb_llist_t * flist ; int rc ; if ( smb_flush_required == 0 ) { rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; } if ( sr -> smb_fid != 0xffff ) { smbsr_lookup_file ( sr ) ; if ( sr -> fid_ofile == NULL ) { smbsr_error ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ; return ( SDRC_ERROR ) ; } <S2SV_StartBug> smb_flush_file ( sr , sr -> fid_ofile ) ; <S2SV_EndBug> } else { flist = & sr -> tid_tree -> t_ofile_list ; smb_llist_enter ( flist , RW_READER ) ; file = smb_llist_head ( flist ) ; while ( file ) { mutex_enter ( & file -> f_mutex ) ; <S2SV_StartBug> smb_flush_file ( sr , file ) ; <S2SV_EndBug> mutex_exit ( & file -> f_mutex ) ; file = smb_llist_next ( flist , file ) ; } smb_llist_exit ( flist ) ; } rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; }
","<S2SV_ModStart> ) ; } smb_ofile_flush <S2SV_ModEnd> ( sr , <S2SV_ModStart> f_mutex ) ; smb_ofile_flush <S2SV_ModEnd> ( sr ,
",illumos@illumos-gate/6d1c73b5858fefc6161c7d686345f0dc887ea799,CVE-2016-6561,https://github.com/illumos/illumos-gate/commit/6d1c73b5858fefc6161c7d686345f0dc887ea799,2017-03-31T19:59Z,"<S2SV_StartBug> smb_flush_file ( sr , sr -> fid_ofile ) ; <S2SV_EndBug> <S2SV_StartBug> smb_flush_file ( sr , file ) ; <S2SV_EndBug>"
493,CWE-000,"<S2SV_StartBug> struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) <S2SV_EndBug> { struct key * keyring ; int bucket ; if ( ! name ) return ERR_PTR ( - EINVAL ) ; bucket = keyring_hash ( name ) ; read_lock ( & keyring_name_lock ) ; if ( keyring_name_hash [ bucket ] . next ) { list_for_each_entry ( keyring , & keyring_name_hash [ bucket ] , name_link ) { if ( ! kuid_has_mapping ( current_user_ns ( ) , keyring -> user -> uid ) ) continue ; if ( test_bit ( KEY_FLAG_REVOKED , & keyring -> flags ) ) continue ; if ( strcmp ( keyring -> description , name ) != 0 ) continue ; <S2SV_StartBug> if ( ! skip_perm_check && <S2SV_EndBug> key_permission ( make_key_ref ( keyring , 0 ) , KEY_NEED_SEARCH ) < 0 ) <S2SV_StartBug> continue ; <S2SV_EndBug> if ( ! refcount_inc_not_zero ( & keyring -> usage ) ) continue ; keyring -> last_used_at = current_kernel_time ( ) . tv_sec ; goto out ; } } keyring = ERR_PTR ( - ENOKEY ) ; out : read_unlock ( & keyring_name_lock ) ; return keyring ; }
","<S2SV_ModStart> name , bool uid_keyring <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; if ( uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> key_permission ( make_key_ref <S2SV_ModStart> ) continue ; }
",torvalds@linux/237bbd29f7a049d310d907f4b2716a7feef9abf3,CVE-2017-18270,https://github.com/torvalds/linux/commit/237bbd29f7a049d310d907f4b2716a7feef9abf3,2018-05-18T16:29Z,"<S2SV_StartBug> struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) <S2SV_EndBug> <S2SV_StartBug> if ( ! skip_perm_check && <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug>"
3005,CWE-119,"IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ( u2_width ) ; } } else { if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; <S2SV_StartBug> return SET_IVD_FATAL_ERROR ( e_error ) ; <S2SV_EndBug> } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; } impeg2d_bit_stream_flush ( ps_stream , 18 ) ; GET_MARKER_BIT ( ps_dec , ps_stream ) ; impeg2d_bit_stream_flush ( ps_stream , 11 ) ; if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_intra_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_intra_quant_matrix , gau1_impeg2_intra_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_inter_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_inter_quant_matrix , gau1_impeg2_inter_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
","<S2SV_ModStart> = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; return e_error <S2SV_ModEnd> ; } ps_dec
",external@libmpeg2/a86eb798d077b9b25c8f8c77e3c02c2f287c1ce7,CVE-2017-0587,https://android.googlesource.com/platform/external/libmpeg2/+/a86eb798d077b9b25c8f8c77e3c02c2f287c1ce7,2017-05-12T15:29Z,<S2SV_StartBug> return SET_IVD_FATAL_ERROR ( e_error ) ; <S2SV_EndBug>
5806,CWE-119,"static void intern_rec ( value * dest ) { unsigned int code ; tag_t tag ; mlsize_t size , len , ofs_ind ; value v ; asize_t ofs ; header_t header ; unsigned char digest [ 16 ] ; struct custom_operations * ops ; char * codeptr ; struct intern_item * sp ; sp = intern_stack ; ReadItems ( dest , 1 ) ; while ( sp != intern_stack ) { dest = sp -> dest ; switch ( sp -> op ) { case OFreshOID : <S2SV_StartBug> if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 ) <S2SV_EndBug> caml_set_oo_id ( ( value ) dest ) ; sp -- ; break ; case OShift : * dest += sp -> arg ; sp -- ; break ; case OReadItems : sp -> dest ++ ; if ( -- ( sp -> arg ) == 0 ) sp -- ; code = read8u ( ) ; if ( code >= PREFIX_SMALL_INT ) { if ( code >= PREFIX_SMALL_BLOCK ) { tag = code & 0xF ; size = ( code >> 4 ) & 0x7 ; read_block : if ( size == 0 ) { v = Atom ( tag ) ; } else { v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , tag , intern_color ) ; intern_dest += 1 + size ; if ( tag == Object_tag ) { Assert ( size >= 2 ) ; ReadItems ( & Field ( v , 2 ) , size - 2 ) ; PushItem ( ) ; sp -> op = OFreshOID ; sp -> dest = ( value * ) v ; sp -> arg = 1 ; ReadItems ( & Field ( v , 0 ) , 2 ) ; } else ReadItems ( & Field ( v , 0 ) , size ) ; } } else { v = Val_int ( code & 0x3F ) ; } } else { if ( code >= PREFIX_SMALL_STRING ) { len = ( code & 0x1F ) ; read_string : size = ( len + sizeof ( value ) ) / sizeof ( value ) ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , String_tag , intern_color ) ; intern_dest += 1 + size ; Field ( v , size - 1 ) = 0 ; ofs_ind = Bsize_wsize ( size ) - 1 ; Byte ( v , ofs_ind ) = ofs_ind - len ; readblock ( String_val ( v ) , len ) ; } else { switch ( code ) { case CODE_INT8 : v = Val_long ( read8s ( ) ) ; break ; case CODE_INT16 : v = Val_long ( read16s ( ) ) ; break ; case CODE_INT32 : v = Val_long ( read32s ( ) ) ; break ; case CODE_INT64 : # ifdef ARCH_SIXTYFOUR v = Val_long ( read64s ( ) ) ; break ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>integer<S2SV_blank>too<S2SV_blank>large"" ) ; break ; # endif case CODE_SHARED8 : ofs = read8u ( ) ; read_shared : Assert ( ofs > 0 ) ; Assert ( ofs <= obj_counter ) ; Assert ( intern_obj_table != NULL ) ; v = intern_obj_table [ obj_counter - ofs ] ; break ; case CODE_SHARED16 : ofs = read16u ( ) ; goto read_shared ; case CODE_SHARED32 : ofs = read32u ( ) ; goto read_shared ; case CODE_BLOCK32 : header = ( header_t ) read32u ( ) ; tag = Tag_hd ( header ) ; size = Wosize_hd ( header ) ; goto read_block ; case CODE_BLOCK64 : # ifdef ARCH_SIXTYFOUR header = ( header_t ) read64s ( ) ; tag = Tag_hd ( header ) ; size = Wosize_hd ( header ) ; goto read_block ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>data<S2SV_blank>block<S2SV_blank>too<S2SV_blank>large"" ) ; break ; # endif case CODE_STRING8 : len = read8u ( ) ; goto read_string ; case CODE_STRING32 : len = read32u ( ) ; goto read_string ; case CODE_DOUBLE_LITTLE : case CODE_DOUBLE_BIG : v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( Double_wosize , Double_tag , intern_color ) ; intern_dest += 1 + Double_wosize ; readfloat ( ( double * ) v , code ) ; break ; case CODE_DOUBLE_ARRAY8_LITTLE : case CODE_DOUBLE_ARRAY8_BIG : len = read8u ( ) ; read_double_array : size = len * Double_wosize ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , Double_array_tag , intern_color ) ; intern_dest += 1 + size ; readfloats ( ( double * ) v , len , code ) ; break ; case CODE_DOUBLE_ARRAY32_LITTLE : case CODE_DOUBLE_ARRAY32_BIG : len = read32u ( ) ; goto read_double_array ; case CODE_CODEPOINTER : ofs = read32u ( ) ; readblock ( digest , 16 ) ; codeptr = intern_resolve_code_pointer ( digest , ofs ) ; if ( codeptr != NULL ) { v = ( value ) codeptr ; } else { value * function_placeholder = caml_named_value ( ""Debugger.function_placeholder"" ) ; if ( function_placeholder != NULL ) { v = * function_placeholder ; } else { intern_cleanup ( ) ; intern_bad_code_pointer ( digest ) ; } } break ; case CODE_INFIXPOINTER : ofs = read32u ( ) ; PushItem ( ) ; sp -> dest = dest ; sp -> op = OShift ; sp -> arg = ofs ; ReadItems ( dest , 1 ) ; continue ; case CODE_CUSTOM : ops = caml_find_custom_operations ( ( char * ) intern_src ) ; if ( ops == NULL ) { intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>unknown<S2SV_blank>custom<S2SV_blank>block<S2SV_blank>identifier"" ) ; } while ( * intern_src ++ != 0 ) ; size = ops -> deserialize ( ( void * ) ( intern_dest + 2 ) ) ; size = 1 + ( size + sizeof ( value ) - 1 ) / sizeof ( value ) ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , Custom_tag , intern_color ) ; Custom_ops_val ( v ) = ops ; if ( ops -> finalize != NULL && Is_young ( v ) ) { if ( caml_finalize_table . ptr >= caml_finalize_table . limit ) { CAMLassert ( caml_finalize_table . ptr == caml_finalize_table . limit ) ; caml_realloc_ref_table ( & caml_finalize_table ) ; } * caml_finalize_table . ptr ++ = ( value * ) v ; } intern_dest += 1 + size ; break ; default : intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>ill-formed<S2SV_blank>message"" ) ; } } } * dest = v ; break ; default : Assert ( 0 ) ; } } intern_free_stack ( ) ; }
","<S2SV_ModStart> : if ( Long_val <S2SV_ModEnd> ( Field (
",ocaml@ocaml/659615c7b100a89eafe6253e7a5b9d84d0e8df74,CVE-2015-8869,https://github.com/ocaml/ocaml/commit/659615c7b100a89eafe6253e7a5b9d84d0e8df74,2016-06-13T19:59Z,"<S2SV_StartBug> if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 ) <S2SV_EndBug>"
3014,CWE-399,"static void emulate_load_store_insn ( struct pt_regs * regs , void __user * addr , unsigned int __user * pc ) { union mips_instruction insn ; unsigned long value ; unsigned int res ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> __get_user ( insn . word , pc ) ; switch ( insn . i_format . opcode ) { case ll_op : case lld_op : case sc_op : case scd_op : case ldl_op : case ldr_op : case lwl_op : case lwr_op : case sdl_op : case sdr_op : case swl_op : case swr_op : case lb_op : case lbu_op : case sb_op : goto sigbus ; case lh_op : if ( ! access_ok ( VERIFY_READ , addr , 2 ) ) goto sigbus ; __asm__ __volatile__ ( "".set\\tnoat\\n"" # ifdef __BIG_ENDIAN ""1:\\tlb\\t%0,<S2SV_blank>0(%2)\\n"" ""2:\\tlbu\\t$1,<S2SV_blank>1(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlb\\t%0,<S2SV_blank>1(%2)\\n"" ""2:\\tlbu\\t$1,<S2SV_blank>0(%2)\\n\\t"" # endif ""sll\\t%0,<S2SV_blank>0x8\\n\\t"" ""or\\t%0,<S2SV_blank>$1\\n\\t"" ""li\\t%1,<S2SV_blank>0\\n"" ""3:\\t.set\\tat\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lw_op : if ( ! access_ok ( VERIFY_READ , addr , 4 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tlwl\\t%0,<S2SV_blank>(%2)\\n"" ""2:\\tlwr\\t%0,<S2SV_blank>3(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlwl\\t%0,<S2SV_blank>3(%2)\\n"" ""2:\\tlwr\\t%0,<S2SV_blank>(%2)\\n\\t"" # endif ""li\\t%1,<S2SV_blank>0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lhu_op : if ( ! access_ok ( VERIFY_READ , addr , 2 ) ) goto sigbus ; __asm__ __volatile__ ( "".set\\tnoat\\n"" # ifdef __BIG_ENDIAN ""1:\\tlbu\\t%0,<S2SV_blank>0(%2)\\n"" ""2:\\tlbu\\t$1,<S2SV_blank>1(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlbu\\t%0,<S2SV_blank>1(%2)\\n"" ""2:\\tlbu\\t$1,<S2SV_blank>0(%2)\\n\\t"" # endif ""sll\\t%0,<S2SV_blank>0x8\\n\\t"" ""or\\t%0,<S2SV_blank>$1\\n\\t"" ""li\\t%1,<S2SV_blank>0\\n"" ""3:\\t.set\\tat\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lwu_op : # ifdef CONFIG_64BIT if ( ! access_ok ( VERIFY_READ , addr , 4 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tlwl\\t%0,<S2SV_blank>(%2)\\n"" ""2:\\tlwr\\t%0,<S2SV_blank>3(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlwl\\t%0,<S2SV_blank>3(%2)\\n"" ""2:\\tlwr\\t%0,<S2SV_blank>(%2)\\n\\t"" # endif ""dsll\\t%0,<S2SV_blank>%0,<S2SV_blank>32\\n\\t"" ""dsrl\\t%0,<S2SV_blank>%0,<S2SV_blank>32\\n\\t"" ""li\\t%1,<S2SV_blank>0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; # endif goto sigill ; case ld_op : # ifdef CONFIG_64BIT if ( ! access_ok ( VERIFY_READ , addr , 8 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tldl\\t%0,<S2SV_blank>(%2)\\n"" ""2:\\tldr\\t%0,<S2SV_blank>7(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tldl\\t%0,<S2SV_blank>7(%2)\\n"" ""2:\\tldr\\t%0,<S2SV_blank>(%2)\\n\\t"" # endif ""li\\t%1,<S2SV_blank>0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; # endif goto sigill ; case sh_op : if ( ! access_ok ( VERIFY_WRITE , addr , 2 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN "".set\\tnoat\\n"" ""1:\\tsb\\t%1,<S2SV_blank>1(%2)\\n\\t"" ""srl\\t$1,<S2SV_blank>%1,<S2SV_blank>0x8\\n"" ""2:\\tsb\\t$1,<S2SV_blank>0(%2)\\n\\t"" "".set\\tat\\n\\t"" # endif # ifdef __LITTLE_ENDIAN "".set\\tnoat\\n"" ""1:\\tsb\\t%1,<S2SV_blank>0(%2)\\n\\t"" ""srl\\t$1,%1,<S2SV_blank>0x8\\n"" ""2:\\tsb\\t$1,<S2SV_blank>1(%2)\\n\\t"" "".set\\tat\\n\\t"" # endif ""li\\t%0,<S2SV_blank>0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; case sw_op : if ( ! access_ok ( VERIFY_WRITE , addr , 4 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tswl\\t%1,(%2)\\n"" ""2:\\tswr\\t%1,<S2SV_blank>3(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tswl\\t%1,<S2SV_blank>3(%2)\\n"" ""2:\\tswr\\t%1,<S2SV_blank>(%2)\\n\\t"" # endif ""li\\t%0,<S2SV_blank>0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; case sd_op : # ifdef CONFIG_64BIT if ( ! access_ok ( VERIFY_WRITE , addr , 8 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tsdl\\t%1,(%2)\\n"" ""2:\\tsdr\\t%1,<S2SV_blank>7(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tsdl\\t%1,<S2SV_blank>7(%2)\\n"" ""2:\\tsdr\\t%1,<S2SV_blank>(%2)\\n\\t"" # endif ""li\\t%0,<S2SV_blank>0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; # endif goto sigill ; case lwc1_op : case ldc1_op : case swc1_op : case sdc1_op : goto sigbus ; case lwc2_op : cu2_notifier_call_chain ( CU2_LWC2_OP , regs ) ; break ; case ldc2_op : cu2_notifier_call_chain ( CU2_LDC2_OP , regs ) ; break ; case swc2_op : cu2_notifier_call_chain ( CU2_SWC2_OP , regs ) ; break ; case sdc2_op : cu2_notifier_call_chain ( CU2_SDC2_OP , regs ) ; break ; default : goto sigill ; } # ifdef CONFIG_DEBUG_FS unaligned_instructions ++ ; # endif return ; fault : if ( fixup_exception ( regs ) ) return ; die_if_kernel ( ""Unhandled<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>access"" , regs ) ; force_sig ( SIGSEGV , current ) ; return ; sigbus : die_if_kernel ( ""Unhandled<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>access"" , regs ) ; force_sig ( SIGBUS , current ) ; return ; sigill : die_if_kernel ( ""Unhandled<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>access<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>instruction"" , regs ) ; force_sig ( SIGILL , current ) ; }
","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug>"
3892,CWE-200,"static inline int verify_replay ( struct xfrm_usersa_info * p , struct nlattr * * attrs ) { struct nlattr * rt = attrs [ XFRMA_REPLAY_ESN_VAL ] ; <S2SV_StartBug> if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( ! rt ) return 0 ; if ( p -> id . proto != IPPROTO_ESP ) return - EINVAL ; if ( p -> replay_window != 0 ) return - EINVAL ; return 0 ; }
","<S2SV_ModStart> XFRMA_REPLAY_ESN_VAL ] ; struct xfrm_replay_state_esn * rs ; if <S2SV_ModEnd> ( p -> <S2SV_ModStart> & XFRM_STATE_ESN ) { if ( <S2SV_ModEnd> ! rt ) <S2SV_ModStart> - EINVAL ; rs = nla_data ( rt ) ; if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ; if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ; }
",torvalds@linux/ecd7918745234e423dd87fcc0c077da557909720,CVE-2012-6536,https://github.com/torvalds/linux/commit/ecd7918745234e423dd87fcc0c077da557909720,2013-03-15T20:55Z,<S2SV_StartBug> if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug>
1709,CWE-119,"<S2SV_StartBug> static void get_sb_partition_size_range ( VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> BLOCK_SIZE * min_block_size , <S2SV_StartBug> BLOCK_SIZE * max_block_size ) { <S2SV_EndBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int sb_width_in_blocks = MI_BLOCK_SIZE ; int sb_height_in_blocks = MI_BLOCK_SIZE ; int i , j ; int index = 0 ; for ( i = 0 ; i < sb_height_in_blocks ; ++ i ) { for ( j = 0 ; j < sb_width_in_blocks ; ++ j ) { MODE_INFO * mi = mi_8x8 [ index + j ] ; BLOCK_SIZE sb_type = mi ? mi -> mbmi . sb_type : 0 ; <S2SV_StartBug> * min_block_size = MIN ( * min_block_size , sb_type ) ; <S2SV_EndBug> * max_block_size = MAX ( * max_block_size , sb_type ) ; } index += xd -> mi_stride ; } }
","<S2SV_ModStart> void get_sb_partition_size_range ( MACROBLOCKD * xd <S2SV_ModEnd> , MODE_INFO * <S2SV_ModStart> BLOCK_SIZE * max_block_size , int bs_hist [ BLOCK_SIZES ] ) { <S2SV_ModEnd> int sb_width_in_blocks = <S2SV_ModStart> : 0 ; bs_hist [ sb_type ] ++ ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void get_sb_partition_size_range ( VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE * max_block_size ) { <S2SV_EndBug> <S2SV_StartBug> * min_block_size = MIN ( * min_block_size , sb_type ) ; <S2SV_EndBug>"
6648,CWE-125,"void bit_write_MC ( Bit_Chain * dat , BITCODE_MC val ) { int i , j ; int negative = 0 ; unsigned char byte [ 5 ] ; BITCODE_UMC mask = 0x0000007f ; BITCODE_UMC value = ( BITCODE_UMC ) val ; if ( val < 0 ) { negative = 1 ; value = ( BITCODE_UMC ) - val ; } for ( i = 4 , j = 0 ; i >= 0 ; i -- , j += 7 ) { byte [ i ] = ( unsigned char ) ( ( value & mask ) >> j ) ; byte [ i ] |= 0x80 ; mask = mask << 7 ; } for ( i = 0 ; i < 4 ; i ++ ) if ( byte [ i ] & 0x7f ) break ; <S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug> i -- ; byte [ i ] &= 0x7f ; if ( negative ) byte [ i ] |= 0x40 ; for ( j = 4 ; j >= i ; j -- ) bit_write_RC ( dat , byte [ j ] ) ; }
","<S2SV_ModStart> ] & 0x40 && i > 0
",LibreDWG@libredwg/95cc9300430d35feb05b06a9badf678419463dbe,CVE-2019-20915,https://github.com/LibreDWG/libredwg/commit/95cc9300430d35feb05b06a9badf678419463dbe,2020-07-16T18:15Z,<S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug>
445,CWE-399,"int xfs_setattr_nonsize ( struct xfs_inode * ip , struct iattr * iattr , int flags ) { xfs_mount_t * mp = ip -> i_mount ; struct inode * inode = VFS_I ( ip ) ; int mask = iattr -> ia_valid ; xfs_trans_t * tp ; int error ; kuid_t uid = GLOBAL_ROOT_UID , iuid = GLOBAL_ROOT_UID ; kgid_t gid = GLOBAL_ROOT_GID , igid = GLOBAL_ROOT_GID ; struct xfs_dquot * udqp = NULL , * gdqp = NULL ; struct xfs_dquot * olddquot1 = NULL , * olddquot2 = NULL ; ASSERT ( ( mask & ATTR_SIZE ) == 0 ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & ( ATTR_UID | ATTR_GID ) ) ) { uint qflags = 0 ; if ( ( mask & ATTR_UID ) && XFS_IS_UQUOTA_ON ( mp ) ) { uid = iattr -> ia_uid ; qflags |= XFS_QMOPT_UQUOTA ; } else { uid = inode -> i_uid ; } if ( ( mask & ATTR_GID ) && XFS_IS_GQUOTA_ON ( mp ) ) { gid = iattr -> ia_gid ; qflags |= XFS_QMOPT_GQUOTA ; } else { gid = inode -> i_gid ; } ASSERT ( udqp == NULL ) ; ASSERT ( gdqp == NULL ) ; error = xfs_qm_vop_dqalloc ( ip , xfs_kuid_to_uid ( uid ) , xfs_kgid_to_gid ( gid ) , xfs_get_projid ( ip ) , qflags , & udqp , & gdqp , NULL ) ; if ( error ) return error ; } error = xfs_trans_alloc ( mp , & M_RES ( mp ) -> tr_ichange , 0 , 0 , 0 , & tp ) ; if ( error ) goto out_dqrele ; xfs_ilock ( ip , XFS_ILOCK_EXCL ) ; xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask & ( ATTR_UID | ATTR_GID ) ) { iuid = inode -> i_uid ; igid = inode -> i_gid ; gid = ( mask & ATTR_GID ) ? iattr -> ia_gid : igid ; uid = ( mask & ATTR_UID ) ? iattr -> ia_uid : iuid ; if ( XFS_IS_QUOTA_RUNNING ( mp ) && ( ( XFS_IS_UQUOTA_ON ( mp ) && ! uid_eq ( iuid , uid ) ) || ( XFS_IS_GQUOTA_ON ( mp ) && ! gid_eq ( igid , gid ) ) ) ) { ASSERT ( tp ) ; error = xfs_qm_vop_chown_reserve ( tp , ip , udqp , gdqp , NULL , capable ( CAP_FOWNER ) ? XFS_QMOPT_FORCE_RES : 0 ) ; if ( error ) goto out_cancel ; } } if ( mask & ( ATTR_UID | ATTR_GID ) ) { if ( ( inode -> i_mode & ( S_ISUID | S_ISGID ) ) && ! capable ( CAP_FSETID ) ) inode -> i_mode &= ~ ( S_ISUID | S_ISGID ) ; if ( ! uid_eq ( iuid , uid ) ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_UQUOTA_ON ( mp ) ) { ASSERT ( mask & ATTR_UID ) ; ASSERT ( udqp ) ; olddquot1 = xfs_qm_vop_chown ( tp , ip , & ip -> i_udquot , udqp ) ; } ip -> i_d . di_uid = xfs_kuid_to_uid ( uid ) ; inode -> i_uid = uid ; } if ( ! gid_eq ( igid , gid ) ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_GQUOTA_ON ( mp ) ) { ASSERT ( xfs_sb_version_has_pquotino ( & mp -> m_sb ) || ! XFS_IS_PQUOTA_ON ( mp ) ) ; ASSERT ( mask & ATTR_GID ) ; ASSERT ( gdqp ) ; olddquot2 = xfs_qm_vop_chown ( tp , ip , & ip -> i_gdquot , gdqp ) ; } ip -> i_d . di_gid = xfs_kgid_to_gid ( gid ) ; inode -> i_gid = gid ; } } if ( mask & ATTR_MODE ) xfs_setattr_mode ( ip , iattr ) ; if ( mask & ( ATTR_ATIME | ATTR_CTIME | ATTR_MTIME ) ) xfs_setattr_time ( ip , iattr ) ; xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; XFS_STATS_INC ( mp , xs_ig_attrchg ) ; if ( mp -> m_flags & XFS_MOUNT_WSYNC ) xfs_trans_set_sync ( tp ) ; error = xfs_trans_commit ( tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ; xfs_qm_dqrele ( olddquot1 ) ; xfs_qm_dqrele ( olddquot2 ) ; xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; if ( error ) return error ; if ( ( mask & ATTR_MODE ) && ! ( flags & XFS_ATTR_NOACL ) ) { error = posix_acl_chmod ( inode , inode -> i_mode ) ; if ( error ) return error ; } return 0 ; out_cancel : xfs_trans_cancel ( tp ) ; <S2SV_StartBug> out_dqrele : <S2SV_EndBug> xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; return error ; }
","<S2SV_ModStart> tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;
",torvalds@linux/1fb254aa983bf190cfd685d40c64a480a9bafaee,CVE-2019-15538,https://github.com/torvalds/linux/commit/1fb254aa983bf190cfd685d40c64a480a9bafaee,2019-08-25T16:15Z,<S2SV_StartBug> out_dqrele : <S2SV_EndBug>
4294,CWE-362,"int get_evtchn_to_irq ( evtchn_port_t evtchn ) { if ( evtchn >= xen_evtchn_max_channels ( ) ) return - 1 ; if ( evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] == NULL ) return - 1 ; <S2SV_StartBug> return evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] [ EVTCHN_COL ( evtchn ) ] ; <S2SV_EndBug> }
","<S2SV_ModStart> 1 ; return READ_ONCE ( <S2SV_ModStart> evtchn ) ] )
",torvalds@linux/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,CVE-2020-27675,https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,2020-10-22T21:15Z,<S2SV_StartBug> return evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] [ EVTCHN_COL ( evtchn ) ] ; <S2SV_EndBug>
1455,CWE-119,"static void update_layer_contexts ( VP8_COMP * cpi ) { VP8_CONFIG * oxcf = & cpi -> oxcf ; if ( oxcf -> number_of_layers > 1 ) { unsigned int i ; double prev_layer_framerate = 0 ; assert ( oxcf -> number_of_layers <= VPX_TS_MAX_LAYERS ) ; <S2SV_StartBug> for ( i = 0 ; i < oxcf -> number_of_layers ; i ++ ) <S2SV_EndBug> { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / oxcf -> rate_decimator [ i ] ; lc -> target_bandwidth = oxcf -> target_bitrate [ i ] * 1000 ; lc -> starting_buffer_level = rescale ( ( int ) oxcf -> starting_buffer_level_in_ms , lc -> target_bandwidth , 1000 ) ; if ( oxcf -> optimal_buffer_level == 0 ) lc -> optimal_buffer_level = lc -> target_bandwidth / 8 ; else lc -> optimal_buffer_level = rescale ( ( int ) oxcf -> optimal_buffer_level_in_ms , lc -> target_bandwidth , 1000 ) ; if ( oxcf -> maximum_buffer_size == 0 ) lc -> maximum_buffer_size = lc -> target_bandwidth / 8 ; else lc -> maximum_buffer_size = rescale ( ( int ) oxcf -> maximum_buffer_size_in_ms , lc -> target_bandwidth , 1000 ) ; if ( i > 0 ) lc -> avg_frame_size_for_layer = ( int ) ( ( oxcf -> target_bitrate [ i ] - oxcf -> target_bitrate [ i - 1 ] ) * 1000 / ( lc -> framerate - prev_layer_framerate ) ) ; prev_layer_framerate = lc -> framerate ; } } }
","<S2SV_ModStart> oxcf -> number_of_layers && i < VPX_TS_MAX_LAYERS ; ++ i <S2SV_ModEnd> ) { LAYER_CONTEXT
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> for ( i = 0 ; i < oxcf -> number_of_layers ; i ++ ) <S2SV_EndBug>
7895,CWE-20,"error_t httpClientParseHeaderField ( HttpClientContext * context , char_t * line , size_t length ) { error_t error ; char_t * name ; size_t nameLen ; char_t * value ; size_t valueLen ; char_t * separator ; line [ length ] = '\\0' ; TRACE_DEBUG ( ""%s\\r\\n"" , line ) ; error = httpCheckCharset ( line , length , HTTP_CHARSET_TEXT ) ; if ( error ) return error ; if ( line [ 0 ] == '<S2SV_blank>' || line [ 0 ] == '\\t' ) { if ( context -> bufferPos == 0 ) return ERROR_INVALID_SYNTAX ; value = strTrimWhitespace ( line ) ; valueLen = osStrlen ( value ) ; if ( valueLen > 0 ) { context -> buffer [ context -> bufferPos - 1 ] = '<S2SV_blank>' ; osMemmove ( context -> buffer + context -> bufferPos , value , valueLen + 1 ) ; context -> bufferLen = context -> bufferPos + valueLen + 1 ; } } else { <S2SV_StartBug> separator = strchr ( line , ':' ) ; <S2SV_EndBug> if ( separator == NULL ) return ERROR_INVALID_SYNTAX ; * separator = '\\0' ; name = strTrimWhitespace ( line ) ; value = strTrimWhitespace ( separator + 1 ) ; nameLen = osStrlen ( name ) ; valueLen = osStrlen ( value ) ; if ( nameLen == 0 ) return ERROR_INVALID_SYNTAX ; if ( ! osStrcasecmp ( name , ""Connection"" ) ) { httpClientParseConnectionField ( context , value ) ; } else if ( ! osStrcasecmp ( name , ""Transfer-Encoding"" ) ) { httpClientParseTransferEncodingField ( context , value ) ; } else if ( ! osStrcasecmp ( name , ""Content-Length"" ) ) { httpClientParseContentLengthField ( context , value ) ; } # if ( HTTP_CLIENT_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( name , ""WWW-Authenticate"" ) ) { httpClientParseWwwAuthenticateField ( context , value ) ; } # endif else { } osMemmove ( context -> buffer + context -> bufferPos , name , nameLen + 1 ) ; osMemmove ( context -> buffer + context -> bufferPos + nameLen + 1 , value , valueLen + 1 ) ; context -> bufferLen = context -> bufferPos + nameLen + valueLen + 2 ; } context -> bufferPos = context -> bufferLen ; return NO_ERROR ; }
","<S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( line ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> separator = strchr ( line , ':' ) ; <S2SV_EndBug>"
2708,CWE-119,"int validate_camera_metadata_structure ( const camera_metadata_t * metadata , const size_t * expected_size ) { if ( metadata == NULL ) { ALOGE ( ""%s:<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>null!"" , __FUNCTION__ ) ; return ERROR ; } { static const struct { const char * name ; size_t alignment ; } alignments [ ] = { { . name = ""camera_metadata"" , . alignment = METADATA_ALIGNMENT } , { . name = ""camera_metadata_buffer_entry"" , . alignment = ENTRY_ALIGNMENT } , { . name = ""camera_metadata_data"" , . alignment = DATA_ALIGNMENT } , } ; for ( size_t i = 0 ; i < sizeof ( alignments ) / sizeof ( alignments [ 0 ] ) ; ++ i ) { uintptr_t aligned_ptr = ALIGN_TO ( metadata , alignments [ i ] . alignment ) ; if ( ( uintptr_t ) metadata != aligned_ptr ) { ALOGE ( ""%s:<S2SV_blank>Metadata<S2SV_blank>pointer<S2SV_blank>is<S2SV_blank>not<S2SV_blank>aligned<S2SV_blank>(actual<S2SV_blank>%p,<S2SV_blank>"" ""expected<S2SV_blank>%p)<S2SV_blank>to<S2SV_blank>type<S2SV_blank>%s"" , __FUNCTION__ , metadata , ( void * ) aligned_ptr , alignments [ i ] . name ) ; return ERROR ; } } } if ( expected_size != NULL && metadata -> size > * expected_size ) { ALOGE ( ""%s:<S2SV_blank>Metadata<S2SV_blank>size<S2SV_blank>(%"" PRIu32 "")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>expected<S2SV_blank>size<S2SV_blank>(%zu)"" , __FUNCTION__ , metadata -> size , * expected_size ) ; return ERROR ; } if ( metadata -> entry_count > metadata -> entry_capacity ) { ALOGE ( ""%s:<S2SV_blank>Entry<S2SV_blank>count<S2SV_blank>(%"" PRIu32 "")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>entry<S2SV_blank>capacity<S2SV_blank>"" ""(%"" PRIu32 "")"" , __FUNCTION__ , metadata -> entry_count , metadata -> entry_capacity ) ; return ERROR ; } const metadata_uptrdiff_t entries_end = metadata -> entries_start + metadata -> entry_capacity ; if ( entries_end < metadata -> entries_start || entries_end > metadata -> data_start ) { ALOGE ( ""%s:<S2SV_blank>Entry<S2SV_blank>start<S2SV_blank>+<S2SV_blank>capacity<S2SV_blank>(%"" PRIu32 "")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>data<S2SV_blank>start<S2SV_blank>"" ""(%"" PRIu32 "")"" , __FUNCTION__ , ( metadata -> entries_start + metadata -> entry_capacity ) , metadata -> data_start ) ; return ERROR ; } const metadata_uptrdiff_t data_end = metadata -> data_start + metadata -> data_capacity ; if ( data_end < metadata -> data_start || data_end > metadata -> size ) { ALOGE ( ""%s:<S2SV_blank>Data<S2SV_blank>start<S2SV_blank>+<S2SV_blank>capacity<S2SV_blank>(%"" PRIu32 "")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>total<S2SV_blank>size<S2SV_blank>"" ""(%"" PRIu32 "")"" , __FUNCTION__ , ( metadata -> data_start + metadata -> data_capacity ) , metadata -> size ) ; return ERROR ; } const metadata_size_t entry_count = metadata -> entry_count ; camera_metadata_buffer_entry_t * entries = get_entries ( metadata ) ; for ( size_t i = 0 ; i < entry_count ; ++ i ) { if ( ( uintptr_t ) & entries [ i ] != ALIGN_TO ( & entries [ i ] , ENTRY_ALIGNMENT ) ) { ALOGE ( ""%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>bad<S2SV_blank>alignment<S2SV_blank>(address<S2SV_blank>%p),"" ""<S2SV_blank>expected<S2SV_blank>alignment<S2SV_blank>%zu"" , __FUNCTION__ , i , & entries [ i ] , ENTRY_ALIGNMENT ) ; return ERROR ; } camera_metadata_buffer_entry_t entry = entries [ i ] ; if ( entry . type >= NUM_TYPES ) { ALOGE ( ""%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>a<S2SV_blank>bad<S2SV_blank>type<S2SV_blank>%d"" , __FUNCTION__ , i , entry . type ) ; return ERROR ; } uint32_t tag_section = entry . tag >> 16 ; int tag_type = get_camera_metadata_tag_type ( entry . tag ) ; if ( tag_type != ( int ) entry . type && tag_section < VENDOR_SECTION ) { ALOGE ( ""%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>tag<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%d"" , __FUNCTION__ , i , tag_type , entry . type ) ; return ERROR ; } <S2SV_StartBug> size_t data_size = <S2SV_EndBug> calculate_camera_metadata_entry_data_size ( entry . type , <S2SV_StartBug> entry . count ) ; <S2SV_EndBug> if ( data_size != 0 ) { camera_metadata_data_t * data = ( camera_metadata_data_t * ) ( get_data ( metadata ) + entry . data . offset ) ; if ( ( uintptr_t ) data != ALIGN_TO ( data , DATA_ALIGNMENT ) ) { ALOGE ( ""%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>bad<S2SV_blank>data<S2SV_blank>alignment<S2SV_blank>(address<S2SV_blank>%p),"" ""<S2SV_blank>expected<S2SV_blank>align<S2SV_blank>%zu,<S2SV_blank>(tag<S2SV_blank>name<S2SV_blank>%s,<S2SV_blank>data<S2SV_blank>size<S2SV_blank>%zu)"" , __FUNCTION__ , i , data , DATA_ALIGNMENT , get_camera_metadata_tag_name ( entry . tag ) ? : ""unknown"" , data_size ) ; return ERROR ; } size_t data_entry_end = entry . data . offset + data_size ; if ( data_entry_end < entry . data . offset || data_entry_end > metadata -> data_capacity ) { ALOGE ( ""%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>(%zu)<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>capacity<S2SV_blank>"" ""%"" PRIu32 , __FUNCTION__ , i , data_entry_end , metadata -> data_capacity ) ; return ERROR ; } } else if ( entry . count == 0 ) { if ( entry . data . offset != 0 ) { ALOGE ( ""%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>0<S2SV_blank>items,<S2SV_blank>but<S2SV_blank>offset<S2SV_blank>was<S2SV_blank>non-0<S2SV_blank>"" ""(%"" PRIu32 ""),<S2SV_blank>tag<S2SV_blank>name:<S2SV_blank>%s"" , __FUNCTION__ , i , entry . data . offset , get_camera_metadata_tag_name ( entry . tag ) ? : ""unknown"" ) ; return ERROR ; } } } return OK ; }
","<S2SV_ModStart> } size_t data_size ; if ( validate_and_calculate_camera_metadata_entry_data_size ( & data_size , <S2SV_ModEnd> entry . type <S2SV_ModStart> . count ) != OK ) { ALOGE ( ""%s:<S2SV_blank>Entry<S2SV_blank>data<S2SV_blank>size<S2SV_blank>is<S2SV_blank>invalid.<S2SV_blank>type:<S2SV_blank>%u<S2SV_blank>count:<S2SV_blank>%u"" , __FUNCTION__ , entry . type , entry . count ) ; return ERROR ; } <S2SV_ModEnd> if ( data_size
",system@media/8e7a2b4d13bff03973dbad2bfb88a04296140433,CVE-2016-3916,https://android.googlesource.com/platform/system/media/+/8e7a2b4d13bff03973dbad2bfb88a04296140433,2016-10-10T10:59Z,<S2SV_StartBug> size_t data_size = <S2SV_EndBug> <S2SV_StartBug> entry . count ) ; <S2SV_EndBug>
600,CWE-772,"struct bio * bio_map_user_iov ( struct request_queue * q , const struct iov_iter * iter , gfp_t gfp_mask ) { int j ; int nr_pages = 0 ; struct page * * pages ; struct bio * bio ; int cur_page = 0 ; int ret , offset ; struct iov_iter i ; <S2SV_StartBug> struct iovec iov ; <S2SV_EndBug> iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; if ( end < start ) return ERR_PTR ( - EINVAL ) ; nr_pages += end - start ; if ( uaddr & queue_dma_alignment ( q ) ) return ERR_PTR ( - EINVAL ) ; } if ( ! nr_pages ) return ERR_PTR ( - EINVAL ) ; bio = bio_kmalloc ( gfp_mask , nr_pages ) ; if ( ! bio ) return ERR_PTR ( - ENOMEM ) ; ret = - ENOMEM ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , gfp_mask ) ; if ( ! pages ) goto out ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; const int local_nr_pages = end - start ; const int page_limit = cur_page + local_nr_pages ; ret = get_user_pages_fast ( uaddr , local_nr_pages , ( iter -> type & WRITE ) != WRITE , & pages [ cur_page ] ) ; <S2SV_StartBug> if ( ret < local_nr_pages ) { <S2SV_EndBug> ret = - EFAULT ; goto out_unmap ; } offset = offset_in_page ( uaddr ) ; for ( j = cur_page ; j < page_limit ; j ++ ) { unsigned int bytes = PAGE_SIZE - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; if ( len <= 0 ) break ; if ( bytes > len ) bytes = len ; if ( bio_add_pc_page ( q , bio , pages [ j ] , bytes , offset ) < bytes ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ; len -= bytes ; offset = 0 ; } cur_page = j ; while ( j < page_limit ) put_page ( pages [ j ++ ] ) ; } kfree ( pages ) ; bio_set_flag ( bio , BIO_USER_MAPPED ) ; bio_get ( bio ) ; return bio ; out_unmap : <S2SV_StartBug> for ( j = 0 ; j < nr_pages ; j ++ ) { <S2SV_EndBug> if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } out : kfree ( pages ) ; bio_put ( bio ) ; return ERR_PTR ( ret ) ; }
","<S2SV_ModStart> struct iovec iov ; struct bio_vec * bvec <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> < local_nr_pages ) ) { for ( j = cur_page ; j < page_limit ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } <S2SV_ModEnd> ret = - <S2SV_ModStart> ; out_unmap : bio_for_each_segment_all ( bvec , bio , j ) { put_page ( bvec -> bv_page <S2SV_ModEnd> ) ; }
",torvalds@linux/2b04e8f6bbb196cab4b232af0f8d48ff2c7a8058,CVE-2017-12190,https://github.com/torvalds/linux/commit/2b04e8f6bbb196cab4b232af0f8d48ff2c7a8058,2017-11-22T18:29Z,<S2SV_StartBug> struct iovec iov ; <S2SV_EndBug> <S2SV_StartBug> if ( ret < local_nr_pages ) { <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < nr_pages ; j ++ ) { <S2SV_EndBug>
3466,CWE-399,"int CMS_verify ( CMS_ContentInfo * cms , STACK_OF ( X509 ) * certs , X509_STORE * store , BIO * dcont , BIO * out , unsigned int flags ) { CMS_SignerInfo * si ; STACK_OF ( CMS_SignerInfo ) * sinfos ; STACK_OF ( X509 ) * cms_certs = NULL ; STACK_OF ( X509_CRL ) * crls = NULL ; X509 * signer ; int i , scount = 0 , ret = 0 ; <S2SV_StartBug> BIO * cmsbio = NULL , * tmpin = NULL ; <S2SV_EndBug> if ( ! dcont && ! check_content ( cms ) ) return 0 ; sinfos = CMS_get0_SignerInfos ( cms ) ; if ( sk_CMS_SignerInfo_num ( sinfos ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_NO_SIGNERS ) ; goto err ; } for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; CMS_SignerInfo_get0_algs ( si , NULL , & signer , NULL , NULL ) ; if ( signer ) scount ++ ; } if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) scount += CMS_set1_signers_certs ( cms , certs , flags ) ; if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SIGNER_CERTIFICATE_NOT_FOUND ) ; goto err ; } if ( ! ( flags & CMS_NO_SIGNER_CERT_VERIFY ) ) { cms_certs = CMS_get1_certs ( cms ) ; if ( ! ( flags & CMS_NOCRL ) ) crls = CMS_get1_crls ( cms ) ; for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( ! cms_signerinfo_verify_cert ( si , store , cms_certs , crls , flags ) ) goto err ; } } if ( ! ( flags & CMS_NO_ATTR_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_signed_get_attr_count ( si ) < 0 ) continue ; if ( CMS_SignerInfo_verify ( si ) <= 0 ) goto err ; } } if ( dcont && ( BIO_method_type ( dcont ) == BIO_TYPE_MEM ) ) { char * ptr ; long len ; len = BIO_get_mem_data ( dcont , & ptr ) ; tmpin = BIO_new_mem_buf ( ptr , len ) ; if ( tmpin == NULL ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; return 0 ; } } else tmpin = dcont ; <S2SV_StartBug> cmsbio = CMS_dataInit ( cms , tmpin ) ; <S2SV_EndBug> if ( ! cmsbio ) goto err ; if ( ! cms_copy_content ( out , cmsbio , flags ) ) <S2SV_StartBug> goto err ; <S2SV_EndBug> if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_SignerInfo_verify_content ( si , cmsbio ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_CONTENT_VERIFY_ERROR ) ; goto err ; } } } ret = 1 ; err : <S2SV_StartBug> if ( dcont && ( tmpin == dcont ) ) <S2SV_EndBug> do_free_upto ( cmsbio , dcont ) ; else BIO_free_all ( cmsbio ) ; <S2SV_StartBug> if ( cms_certs ) <S2SV_EndBug> sk_X509_pop_free ( cms_certs , X509_free ) ; if ( crls ) sk_X509_CRL_pop_free ( crls , X509_CRL_free ) ; return ret ; }
","<S2SV_ModStart> , * tmpin = NULL , * tmpout <S2SV_ModStart> = dcont ; if ( ! ( flags & SMIME_BINARY ) && dcont ) { tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } <S2SV_ModStart> ( cms , tmpout ) ; if ( ! cmsbio ) goto err ; SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ; if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } } else { cmsbio = CMS_dataInit ( cms , <S2SV_ModStart> goto err ; } <S2SV_ModStart> : if ( ! ( flags & SMIME_BINARY ) && dcont ) { do_free_upto ( cmsbio , tmpout ) ; if ( tmpin != dcont ) BIO_free ( tmpin ) ; } else { if ( <S2SV_ModStart> cmsbio ) ; } if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ;
",openssl@openssl/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,CVE-2015-1792,https://github.com/openssl/openssl/commit/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,2015-06-12T19:59Z,"<S2SV_StartBug> BIO * cmsbio = NULL , * tmpin = NULL ; <S2SV_EndBug> <S2SV_StartBug> cmsbio = CMS_dataInit ( cms , tmpin ) ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( dcont && ( tmpin == dcont ) ) <S2SV_EndBug> <S2SV_StartBug> if ( cms_certs ) <S2SV_EndBug>"
37,CWE-125,"<S2SV_StartBug> INST_HANDLER ( lds ) { <S2SV_EndBug> int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; __generic_ld_st ( op , ""ram"" , 0 , 1 , 0 , k , 0 ) ; ESIL_A ( ""r%d,=,"" , d ) ; }
","<S2SV_ModStart> lds ) { if ( len < 4 ) { return ; }
",radare@radare2/041e53cab7ca33481ae45ecd65ad596976d78e68,CVE-2018-11375,https://github.com/radare/radare2/commit/041e53cab7ca33481ae45ecd65ad596976d78e68,2018-05-22T19:29Z,<S2SV_StartBug> INST_HANDLER ( lds ) { <S2SV_EndBug>
2901,CWE-310,"static noinline int btrfs_mksubvol ( struct path * parent , char * name , int namelen , struct btrfs_root * snap_src , u64 * async_transid , bool readonly , struct btrfs_qgroup_inherit * * inherit ) { struct inode * dir = parent -> dentry -> d_inode ; struct dentry * dentry ; int error ; mutex_lock_nested ( & dir -> i_mutex , I_MUTEX_PARENT ) ; dentry = lookup_one_len ( name , parent -> dentry , namelen ) ; error = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) goto out_unlock ; error = - EEXIST ; if ( dentry -> d_inode ) goto out_dput ; error = btrfs_may_create ( dir , dentry ) ; if ( error ) goto out_dput ; <S2SV_StartBug> down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; <S2SV_EndBug> if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ; if ( snap_src ) { error = create_snapshot ( snap_src , dentry , name , namelen , async_transid , readonly , inherit ) ; } else { error = create_subvol ( BTRFS_I ( dir ) -> root , dentry , name , namelen , async_transid , inherit ) ; } if ( ! error ) fsnotify_mkdir ( dir , dentry ) ; out_up_read : up_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; out_dput : dput ( dentry ) ; out_unlock : mutex_unlock ( & dir -> i_mutex ) ; return error ; }
","<S2SV_ModStart> goto out_dput ; error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ;
",torvalds@linux/9c52057c698fb96f8f07e7a4bcf4801a092bda89,CVE-2012-5375,https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89,2013-02-18T11:56Z,<S2SV_StartBug> down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; <S2SV_EndBug>
1933,CWE-119,"static vpx_codec_err_t ctrl_set_roi_map ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> return VPX_CODEC_INVALID_PARAM ; }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> args ) { ( void ) ctx ; ( void ) args ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug>"
5189,CWE-772,"static Image * ReadARTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { const unsigned char * pixels ; Image * image ; QuantumInfo * quantum_info ; MagickBooleanType status ; size_t length ; ssize_t count , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 1 ; image -> endian = MSBEndian ; ( void ) ReadBlobLSBShort ( image ) ; image -> columns = ( size_t ) ReadBlobLSBShort ( image ) ; ( void ) ReadBlobLSBShort ( image ) ; image -> rows = ( size_t ) ReadBlobLSBShort ( image ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; SetImageColorspace ( image , GRAYColorspace , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = GetQuantumExtent ( image , quantum_info , GrayQuantum ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) <S2SV_StartBug> ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; <S2SV_EndBug> ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ; pixels = ( const unsigned char * ) ReadBlobStream ( image , ( size_t ) ( - ( ssize_t ) length ) & 0x01 , GetQuantumPixels ( quantum_info ) , & count ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( SetImageProgress ( image , LoadImageTag , y , image -> rows ) == MagickFalse ) break ; } SetQuantumImageType ( image , GrayQuantum ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) length ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> ""UnableToReadImageData"" ) ; }
",ImageMagick@ImageMagick/3b0fe05cddd8910f84e51b4d50099702ea45ba4a,CVE-2017-9143,https://github.com/ImageMagick/ImageMagick/commit/3b0fe05cddd8910f84e51b4d50099702ea45ba4a,2017-05-22T14:29Z,"<S2SV_StartBug> ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; <S2SV_EndBug>"
712,CWE-119,"int evutil_parse_sockaddr_port ( const char * ip_as_string , struct sockaddr * out , int * outlen ) { int port ; char buf [ 128 ] ; const char * cp , * addr_part , * port_part ; int is_ipv6 ; cp = strchr ( ip_as_string , ':' ) ; if ( * ip_as_string == '[' ) { <S2SV_StartBug> int len ; <S2SV_EndBug> if ( ! ( cp = strchr ( ip_as_string , ']' ) ) ) { return - 1 ; } <S2SV_StartBug> len = ( int ) ( cp - ( ip_as_string + 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len > ( int ) sizeof ( buf ) - 1 ) { <S2SV_EndBug> return - 1 ; } memcpy ( buf , ip_as_string + 1 , len ) ; buf [ len ] = '\\0' ; addr_part = buf ; if ( cp [ 1 ] == ':' ) port_part = cp + 2 ; else port_part = NULL ; is_ipv6 = 1 ; } else if ( cp && strchr ( cp + 1 , ':' ) ) { is_ipv6 = 1 ; addr_part = ip_as_string ; port_part = NULL ; } else if ( cp ) { is_ipv6 = 0 ; if ( cp - ip_as_string > ( int ) sizeof ( buf ) - 1 ) { return - 1 ; } memcpy ( buf , ip_as_string , cp - ip_as_string ) ; buf [ cp - ip_as_string ] = '\\0' ; addr_part = buf ; port_part = cp + 1 ; } else { addr_part = ip_as_string ; port_part = NULL ; is_ipv6 = 0 ; } if ( port_part == NULL ) { port = 0 ; } else { port = atoi ( port_part ) ; if ( port <= 0 || port > 65535 ) { return - 1 ; } } if ( ! addr_part ) return - 1 ; # ifdef AF_INET6 if ( is_ipv6 ) { struct sockaddr_in6 sin6 ; memset ( & sin6 , 0 , sizeof ( sin6 ) ) ; # ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN sin6 . sin6_len = sizeof ( sin6 ) ; # endif sin6 . sin6_family = AF_INET6 ; sin6 . sin6_port = htons ( port ) ; if ( 1 != evutil_inet_pton ( AF_INET6 , addr_part , & sin6 . sin6_addr ) ) return - 1 ; if ( ( int ) sizeof ( sin6 ) > * outlen ) return - 1 ; memset ( out , 0 , * outlen ) ; memcpy ( out , & sin6 , sizeof ( sin6 ) ) ; * outlen = sizeof ( sin6 ) ; return 0 ; } else # endif { struct sockaddr_in sin ; memset ( & sin , 0 , sizeof ( sin ) ) ; # ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN sin . sin_len = sizeof ( sin ) ; # endif sin . sin_family = AF_INET ; sin . sin_port = htons ( port ) ; if ( 1 != evutil_inet_pton ( AF_INET , addr_part , & sin . sin_addr ) ) return - 1 ; if ( ( int ) sizeof ( sin ) > * outlen ) return - 1 ; memset ( out , 0 , * outlen ) ; memcpy ( out , & sin , sizeof ( sin ) ) ; * outlen = sizeof ( sin ) ; return 0 ; } }
","<S2SV_ModStart> '[' ) { size_t <S2SV_ModEnd> len ; if <S2SV_ModStart> } len = <S2SV_ModEnd> ( cp - <S2SV_ModStart> ( len > <S2SV_ModEnd> sizeof ( buf
",libevent@libevent/329acc18a0768c21ba22522f01a5c7f46cacc4d5,CVE-2016-10196,https://github.com/libevent/libevent/commit/329acc18a0768c21ba22522f01a5c7f46cacc4d5,2017-03-15T15:59Z,<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> len = ( int ) ( cp - ( ip_as_string + 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len > ( int ) sizeof ( buf ) - 1 ) { <S2SV_EndBug>
508,CWE-125,"int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; int hroom , troom ; __be32 frag_id ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; <S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) goto fail_toobig ; if ( IP6CB ( skb ) -> frag_max_size ) { if ( IP6CB ( skb ) -> frag_max_size > mtu ) goto fail_toobig ; mtu = IP6CB ( skb ) -> frag_max_size ; if ( mtu < IPV6_MIN_MTU ) mtu = IPV6_MIN_MTU ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) goto fail_toobig ; mtu -= hlen + sizeof ( struct frag_hdr ) ; frag_id = ipv6_select_ident ( net , & ipv6_hdr ( skb ) -> daddr , & ipv6_hdr ( skb ) -> saddr ) ; if ( skb -> ip_summed == CHECKSUM_PARTIAL && ( err = skb_checksum_help ( skb ) ) ) goto fail ; hroom = LL_RESERVED_SPACE ( rt -> dst . dev ) ; if ( skb_has_frag_list ( skb ) ) { unsigned int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) || skb_headroom ( skb ) < ( hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < ( hlen + hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; fh -> identification = frag_id ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( net , sk , skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; ip6_rt_put ( rt ) ; return 0 ; } kfree_skb_list ( frag ) ; IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; ip6_rt_put ( rt ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; troom = rt -> dst . dev -> needed_tailroom ; while ( left > 0 ) { u8 * fragnexthdr_offset ; len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + hroom + troom , GFP_ATOMIC ) ; if ( ! frag ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , hroom ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fragnexthdr_offset = skb_network_header ( frag ) ; fragnexthdr_offset += prevhdr - skb_network_header ( skb ) ; * fragnexthdr_offset = NEXTHDR_FRAGMENT ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> identification = frag_id ; BUG_ON ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( net , sk , frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; consume_skb ( skb ) ; return err ; fail_toobig : if ( skb -> sk && dst_allfrag ( skb_dst ( skb ) ) ) sk_nocaps_add ( skb -> sk , NETIF_F_GSO_MASK ) ; skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; err = - EMSGSIZE ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }
","<S2SV_ModStart> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z,"<S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug>"
3015,CWE-399,"static int cop1Emulate ( struct pt_regs * xcp , struct mips_fpu_struct * ctx , void * __user * fault_addr ) { mips_instruction ir ; unsigned long emulpc , contpc ; unsigned int cond ; if ( ! access_ok ( VERIFY_READ , xcp -> cp0_epc , sizeof ( mips_instruction ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGBUS ; } if ( __get_user ( ir , ( mips_instruction __user * ) xcp -> cp0_epc ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGSEGV ; } if ( ( xcp -> cp0_cause & CAUSEF_BD ) && ! isBranchInstr ( & ir ) ) xcp -> cp0_cause &= ~ CAUSEF_BD ; if ( xcp -> cp0_cause & CAUSEF_BD ) { emulpc = xcp -> cp0_epc + 4 ; if ( __compute_return_epc ( xcp ) ) { # ifdef CP1DBG printk ( ""failed<S2SV_blank>to<S2SV_blank>emulate<S2SV_blank>branch<S2SV_blank>at<S2SV_blank>%p\\n"" , ( void * ) ( xcp -> cp0_epc ) ) ; # endif return SIGILL ; } if ( ! access_ok ( VERIFY_READ , emulpc , sizeof ( mips_instruction ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) emulpc ; return SIGBUS ; } if ( __get_user ( ir , ( mips_instruction __user * ) emulpc ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) emulpc ; return SIGSEGV ; } contpc = xcp -> cp0_epc ; xcp -> cp0_epc = emulpc - 4 ; } else { emulpc = xcp -> cp0_epc ; contpc = xcp -> cp0_epc + 4 ; } emul : perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , xcp , 0 ) ; <S2SV_EndBug> MIPS_FPU_EMU_INC_STATS ( emulated ) ; switch ( MIPSInst_OPCODE ( ir ) ) { case ldc1_op : { u64 __user * va = ( u64 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u64 val ; MIPS_FPU_EMU_INC_STATS ( loads ) ; if ( ! access_ok ( VERIFY_READ , va , sizeof ( u64 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __get_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } DITOREG ( val , MIPSInst_RT ( ir ) ) ; break ; } case sdc1_op : { u64 __user * va = ( u64 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u64 val ; MIPS_FPU_EMU_INC_STATS ( stores ) ; DIFROMREG ( val , MIPSInst_RT ( ir ) ) ; if ( ! access_ok ( VERIFY_WRITE , va , sizeof ( u64 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __put_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } break ; } case lwc1_op : { u32 __user * va = ( u32 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u32 val ; MIPS_FPU_EMU_INC_STATS ( loads ) ; if ( ! access_ok ( VERIFY_READ , va , sizeof ( u32 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __get_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } SITOREG ( val , MIPSInst_RT ( ir ) ) ; break ; } case swc1_op : { u32 __user * va = ( u32 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u32 val ; MIPS_FPU_EMU_INC_STATS ( stores ) ; SIFROMREG ( val , MIPSInst_RT ( ir ) ) ; if ( ! access_ok ( VERIFY_WRITE , va , sizeof ( u32 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __put_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } break ; } case cop1_op : switch ( MIPSInst_RS ( ir ) ) { # if defined ( __mips64 ) case dmfc_op : if ( MIPSInst_RT ( ir ) != 0 ) { DIFROMREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; } break ; case dmtc_op : DITOREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; break ; # endif case mfc_op : if ( MIPSInst_RT ( ir ) != 0 ) { SIFROMREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; } break ; case mtc_op : SITOREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; break ; case cfc_op : { u32 value ; if ( MIPSInst_RD ( ir ) == FPCREG_CSR ) { value = ctx -> fcr31 ; value = ( value & ~ FPU_CSR_RM ) | mips_rm [ modeindex ( value ) ] ; # ifdef CSRTRACE printk ( ""%p<S2SV_blank>gpr[%d]<-csr=%08x\\n"" , ( void * ) ( xcp -> cp0_epc ) , MIPSInst_RT ( ir ) , value ) ; # endif } else if ( MIPSInst_RD ( ir ) == FPCREG_RID ) value = 0 ; else value = 0 ; if ( MIPSInst_RT ( ir ) ) xcp -> regs [ MIPSInst_RT ( ir ) ] = value ; break ; } case ctc_op : { u32 value ; if ( MIPSInst_RT ( ir ) == 0 ) value = 0 ; else value = xcp -> regs [ MIPSInst_RT ( ir ) ] ; if ( MIPSInst_RD ( ir ) == FPCREG_CSR ) { # ifdef CSRTRACE printk ( ""%p<S2SV_blank>gpr[%d]->csr=%08x\\n"" , ( void * ) ( xcp -> cp0_epc ) , MIPSInst_RT ( ir ) , value ) ; # endif ctx -> fcr31 = ( value & ~ ( FPU_CSR_RSVD | FPU_CSR_RM ) ) | ieee_rm [ modeindex ( value ) ] ; } if ( ( ctx -> fcr31 >> 5 ) & ctx -> fcr31 & FPU_CSR_ALL_E ) { return SIGFPE ; } break ; } case bc_op : { int likely = 0 ; if ( xcp -> cp0_cause & CAUSEF_BD ) return SIGILL ; # if __mips >= 4 cond = ctx -> fcr31 & fpucondbit [ MIPSInst_RT ( ir ) >> 2 ] ; # else cond = ctx -> fcr31 & FPU_CSR_COND ; # endif switch ( MIPSInst_RT ( ir ) & 3 ) { case bcfl_op : likely = 1 ; case bcf_op : cond = ! cond ; break ; case bctl_op : likely = 1 ; case bct_op : break ; default : return SIGILL ; } xcp -> cp0_cause |= CAUSEF_BD ; if ( cond ) { xcp -> cp0_epc += 4 ; contpc = ( xcp -> cp0_epc + ( MIPSInst_SIMM ( ir ) << 2 ) ) ; if ( ! access_ok ( VERIFY_READ , xcp -> cp0_epc , sizeof ( mips_instruction ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGBUS ; } if ( __get_user ( ir , ( mips_instruction __user * ) xcp -> cp0_epc ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGSEGV ; } switch ( MIPSInst_OPCODE ( ir ) ) { case lwc1_op : case swc1_op : # if ( __mips >= 2 || defined ( __mips64 ) ) case ldc1_op : case sdc1_op : # endif case cop1_op : # if __mips >= 4 && __mips != 32 case cop1x_op : # endif goto emul ; # if __mips >= 4 case spec_op : if ( MIPSInst_FUNC ( ir ) == movc_op ) goto emul ; break ; # endif } return mips_dsemul ( xcp , ir , contpc ) ; } else { if ( likely ) { xcp -> cp0_epc += 4 ; contpc += 4 ; } } break ; } default : if ( ! ( MIPSInst_RS ( ir ) & 0x10 ) ) return SIGILL ; { int sig ; if ( ( sig = fpu_emu ( xcp , ctx , ir ) ) ) return sig ; } } break ; # if __mips >= 4 && __mips != 32 case cop1x_op : { int sig = fpux_emu ( xcp , ctx , ir , fault_addr ) ; if ( sig ) return sig ; break ; } # endif # if __mips >= 4 case spec_op : if ( MIPSInst_FUNC ( ir ) != movc_op ) return SIGILL ; cond = fpucondbit [ MIPSInst_RT ( ir ) >> 2 ] ; if ( ( ( ctx -> fcr31 & cond ) != 0 ) == ( ( MIPSInst_RT ( ir ) & 1 ) != 0 ) ) xcp -> regs [ MIPSInst_RD ( ir ) ] = xcp -> regs [ MIPSInst_RS ( ir ) ] ; break ; # endif default : return SIGILL ; } xcp -> cp0_epc = contpc ; xcp -> cp0_cause &= ~ CAUSEF_BD ; return 0 ; }
","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , xcp ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> 1 , 0 , xcp , 0 ) ; <S2SV_EndBug>"
2929,CWE-119,"static int complete_emulated_mmio ( struct kvm_vcpu * vcpu ) { struct kvm_run * run = vcpu -> run ; struct kvm_mmio_fragment * frag ; unsigned len ; BUG_ON ( ! vcpu -> mmio_needed ) ; frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment ] ; len = min ( 8u , frag -> len ) ; if ( ! vcpu -> mmio_is_write ) memcpy ( frag -> data , run -> mmio . data , len ) ; if ( frag -> len <= 8 ) { frag ++ ; vcpu -> mmio_cur_fragment ++ ; } else { frag -> data += len ; frag -> gpa += len ; frag -> len -= len ; } <S2SV_StartBug> if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { <S2SV_EndBug> vcpu -> mmio_needed = 0 ; if ( vcpu -> mmio_is_write ) return 1 ; vcpu -> mmio_read_completed = 1 ; return complete_emulated_io ( vcpu ) ; } run -> exit_reason = KVM_EXIT_MMIO ; run -> mmio . phys_addr = frag -> gpa ; if ( vcpu -> mmio_is_write ) memcpy ( run -> mmio . data , frag -> data , min ( 8u , frag -> len ) ) ; run -> mmio . len = min ( 8u , frag -> len ) ; run -> mmio . is_write = vcpu -> mmio_is_write ; vcpu -> arch . complete_userspace_io = complete_emulated_mmio ; return 0 ; }
","<S2SV_ModStart> vcpu -> mmio_cur_fragment >= <S2SV_ModEnd> vcpu -> mmio_nr_fragments
",torvalds@linux/a08d3b3b99efd509133946056531cdf8f3a0c09b,CVE-2014-0049,https://github.com/torvalds/linux/commit/a08d3b3b99efd509133946056531cdf8f3a0c09b,2014-03-11T13:01Z,<S2SV_StartBug> if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { <S2SV_EndBug>
2073,CWE-119,"void mp_encode_lua_table_as_map ( lua_State * L , mp_buf * buf , int level ) { <S2SV_StartBug> size_t len = 0 ; <S2SV_EndBug> lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pop ( L , 1 ) ; len ++ ; } mp_encode_map ( L , buf , len ) ; lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pushvalue ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }
","<S2SV_ModStart> len = 0 ; luaL_checkstack ( L , 3 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map"" )
",antirez@redis/5ccb6f7a791bf3490357b00a898885759d98bab0,CVE-2018-11218,https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0,2018-06-17T17:29Z,<S2SV_StartBug> size_t len = 0 ; <S2SV_EndBug>
6893,CWE-119,"void lzxd_free ( struct lzxd_stream * lzx ) { struct mspack_system * sys ; if ( lzx ) { sys = lzx -> sys ; <S2SV_StartBug> sys -> free ( lzx -> inbuf ) ; <S2SV_EndBug> sys -> free ( lzx -> window ) ; sys -> free ( lzx ) ; } }
","<S2SV_ModStart> -> sys ; if ( lzx -> inbuf ) <S2SV_ModStart> inbuf ) ; if ( lzx -> window )
",vrtadmin@clamav-devel/a83773682e856ad6529ba6db8d1792e6d515d7f1,CVE-2017-6419,https://github.com/vrtadmin/clamav-devel/commit/a83773682e856ad6529ba6db8d1792e6d515d7f1,2017-08-07T03:29Z,<S2SV_StartBug> sys -> free ( lzx -> inbuf ) ; <S2SV_EndBug>
1627,CWE-119,"<S2SV_StartBug> static int decode_term_subexp ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 4 ) + 16 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 5 ) + 32 ; <S2SV_EndBug> return decode_uniform ( r ) + 64 ; }
","<S2SV_ModStart> int decode_term_subexp ( vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> if ( ! vpx_read_bit <S2SV_ModEnd> ( r ) <S2SV_ModStart> ) ) return vpx_read_literal <S2SV_ModEnd> ( r , <S2SV_ModStart> if ( ! vpx_read_bit <S2SV_ModEnd> ( r ) <S2SV_ModStart> ) ) return vpx_read_literal <S2SV_ModEnd> ( r , <S2SV_ModStart> if ( ! vpx_read_bit <S2SV_ModEnd> ( r ) <S2SV_ModStart> ) ) return vpx_read_literal <S2SV_ModEnd> ( r ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static int decode_term_subexp ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 4 ) + 16 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 5 ) + 32 ; <S2SV_EndBug>"
3528,CWE-264,"static int load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg ) { u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; <S2SV_StartBug> return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ; <S2SV_EndBug> }
","<S2SV_ModStart> cpl , false , NULL
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z,"<S2SV_StartBug> return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ; <S2SV_EndBug>"
424,CWE-399,"static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) <S2SV_StartBug> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <S2SV_EndBug> typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != ( unsigned char * ) NULL ) ; assert ( chroma2 != ( unsigned char * ) NULL ) ; buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; sum = 0 ; bits = 32 ; p = buffer + 0x800 ; for ( i = 0 ; i < 3 ; i ++ ) { pcd_table [ i ] = ( PCDTable * ) NULL ; pcd_length [ i ] = 0 ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) { PCDGetBits ( 8 ) ; length = ( sum & 0xff ) + 1 ; pcd_table [ i ] = ( PCDTable * ) AcquireQuantumMemory ( length , sizeof ( * pcd_table [ i ] ) ) ; if ( pcd_table [ i ] == ( PCDTable * ) NULL ) { buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_StartBug> ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , <S2SV_EndBug> image -> filename ) ; } r = pcd_table [ i ] ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { PCDGetBits ( 8 ) ; r -> length = ( unsigned int ) ( sum & 0xff ) + 1 ; if ( r -> length > 16 ) { <S2SV_StartBug> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_EndBug> return ( MagickFalse ) ; } PCDGetBits ( 16 ) ; r -> sequence = ( unsigned int ) ( sum & 0xffff ) << 16 ; PCDGetBits ( 8 ) ; r -> key = ( unsigned char ) ( sum & 0xff ) ; r -> mask = ( ~ ( ( 1U << ( 32 - r -> length ) ) - 1 ) ) ; r ++ ; } pcd_length [ i ] = ( size_t ) length ; } for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; while ( ( sum & 0x00fff000UL ) != 0x00fff000UL ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; count = 0 ; length = 0 ; plane = 0 ; row = 0 ; q = luma ; for ( ; ; ) { if ( IsSync ( sum ) != 0 ) { PCDGetBits ( 16 ) ; row = ( ( sum >> 9 ) & 0x1fff ) ; if ( row == image -> rows ) break ; PCDGetBits ( 8 ) ; plane = sum >> 30 ; PCDGetBits ( 16 ) ; switch ( plane ) { case 0 : { q = luma + row * image -> columns ; count = ( ssize_t ) image -> columns ; break ; } case 2 : { q = chroma1 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } case 3 : { q = chroma2 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } default : { for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; ThrowBinaryException ( CorruptImageError , ""CorruptImage"" , image -> filename ) ; } } length = pcd_length [ plane ] ; continue ; } r = pcd_table [ plane ] ; for ( i = 0 ; ( ( i < ( ssize_t ) length ) && ( ( sum & r -> mask ) != r -> sequence ) ) ; i ++ ) r ++ ; if ( ( row > image -> rows ) || ( r == ( PCDTable * ) NULL ) ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""SkipToSyncByte"" , ""`%s\'"" , image -> filename ) ; while ( ( sum & 0x00fff000 ) != 0x00fff000 ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; continue ; } if ( r -> key < 128 ) quantum = ( ssize_t ) ( * q ) + r -> key ; else quantum = ( ssize_t ) ( * q ) + r -> key - 256 ; * q = ( unsigned char ) ( ( quantum < 0 ) ? 0 : ( quantum > 255 ) ? 255 : quantum ) ; q ++ ; PCDGetBits ( r -> length ) ; count -- ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; return ( MagickTrue ) ; }
","<S2SV_ModStart> ( n ) \\\n{ <S2SV_ModEnd> sum = ( <S2SV_ModStart> ++ ; } \\\n} <S2SV_ModEnd> typedef struct PCDTable <S2SV_ModStart> buffer ) ; for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ]
",ImageMagick@ImageMagick/1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae,CVE-2019-7175,https://github.com/ImageMagick/ImageMagick/commit/1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae,2019-03-07T23:29Z,"<S2SV_StartBug> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <S2SV_EndBug> <S2SV_StartBug> ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , <S2SV_EndBug> <S2SV_StartBug> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_EndBug>"
3418,CWE-200,"static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == BT_CONNECT2 && test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) ) { hci_conn_accept ( pi -> conn -> hcon , 0 ) ; sk -> sk_state = BT_CONFIG ; <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }
","<S2SV_ModStart> = BT_CONFIG ; msg -> msg_namelen = 0 ;
",torvalds@linux/c8c499175f7d295ef867335bceb9a76a2c3cdc38,CVE-2013-3226,https://github.com/torvalds/linux/commit/c8c499175f7d295ef867335bceb9a76a2c3cdc38,2013-04-22T11:41Z,<S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug>
7444,CWE-125,"static void l2tp_avp_print ( netdissect_options * ndo , const u_char * dat , int length ) { u_int len ; const uint16_t * ptr = ( const uint16_t * ) dat ; uint16_t attr_type ; int hidden = FALSE ; if ( length <= 0 ) { return ; } ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; ND_TCHECK ( * ptr ) ; len = EXTRACT_16BITS ( ptr ) & L2TP_AVP_HDR_LEN_MASK ; if ( len < 6 ) goto trunc ; if ( len > ( u_int ) length ) goto trunc ; ND_TCHECK2 ( * ptr , len ) ; if ( EXTRACT_16BITS ( ptr ) & L2TP_AVP_HDR_FLAG_MANDATORY ) { ND_PRINT ( ( ndo , ""*"" ) ) ; } if ( EXTRACT_16BITS ( ptr ) & L2TP_AVP_HDR_FLAG_HIDDEN ) { hidden = TRUE ; ND_PRINT ( ( ndo , ""?"" ) ) ; } ptr ++ ; if ( EXTRACT_16BITS ( ptr ) ) { ND_PRINT ( ( ndo , ""VENDOR%04x:"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; ND_PRINT ( ( ndo , ""ATTR%04x"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; ND_PRINT ( ( ndo , ""("" ) ) ; print_octets ( ndo , ( const u_char * ) ptr , len - 6 ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { ptr ++ ; attr_type = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_avp2str , ""AVP-#%u"" , attr_type ) ) ) ; ND_PRINT ( ( ndo , ""("" ) ) ; if ( hidden ) { ND_PRINT ( ( ndo , ""???"" ) ) ; } else { switch ( attr_type ) { case L2TP_AVP_MSGTYPE : <S2SV_StartBug> l2tp_msgtype_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_RESULT_CODE : l2tp_result_code_print ( ndo , ( const u_char * ) ptr , len - 6 ) ; break ; case L2TP_AVP_PROTO_VER : <S2SV_StartBug> l2tp_proto_ver_print ( ndo , ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_FRAMING_CAP : <S2SV_StartBug> l2tp_framing_cap_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_BEARER_CAP : <S2SV_StartBug> l2tp_bearer_cap_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_TIE_BREAKER : <S2SV_StartBug> print_octets ( ndo , ( const u_char * ) ptr , 8 ) ; <S2SV_EndBug> break ; case L2TP_AVP_FIRM_VER : case L2TP_AVP_ASSND_TUN_ID : case L2TP_AVP_RECV_WIN_SIZE : case L2TP_AVP_ASSND_SESS_ID : <S2SV_StartBug> print_16bits_val ( ndo , ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_HOST_NAME : case L2TP_AVP_VENDOR_NAME : case L2TP_AVP_CALLING_NUMBER : case L2TP_AVP_CALLED_NUMBER : case L2TP_AVP_SUB_ADDRESS : case L2TP_AVP_PROXY_AUTH_NAME : case L2TP_AVP_PRIVATE_GRP_ID : print_string ( ndo , ( const u_char * ) ptr , len - 6 ) ; break ; case L2TP_AVP_CHALLENGE : case L2TP_AVP_INI_RECV_LCP : case L2TP_AVP_LAST_SENT_LCP : case L2TP_AVP_LAST_RECV_LCP : case L2TP_AVP_PROXY_AUTH_CHAL : case L2TP_AVP_PROXY_AUTH_RESP : case L2TP_AVP_RANDOM_VECTOR : print_octets ( ndo , ( const u_char * ) ptr , len - 6 ) ; break ; case L2TP_AVP_Q931_CC : l2tp_q931_cc_print ( ndo , ( const u_char * ) ptr , len - 6 ) ; break ; case L2TP_AVP_CHALLENGE_RESP : <S2SV_StartBug> print_octets ( ndo , ( const u_char * ) ptr , 16 ) ; <S2SV_EndBug> break ; case L2TP_AVP_CALL_SER_NUM : case L2TP_AVP_MINIMUM_BPS : case L2TP_AVP_MAXIMUM_BPS : case L2TP_AVP_TX_CONN_SPEED : case L2TP_AVP_PHY_CHANNEL_ID : case L2TP_AVP_RX_CONN_SPEED : <S2SV_StartBug> print_32bits_val ( ndo , ( const uint32_t * ) ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_BEARER_TYPE : <S2SV_StartBug> l2tp_bearer_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_FRAMING_TYPE : <S2SV_StartBug> l2tp_framing_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_PACKET_PROC_DELAY : l2tp_packet_proc_delay_print ( ndo ) ; break ; case L2TP_AVP_PROXY_AUTH_TYPE : <S2SV_StartBug> l2tp_proxy_auth_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_PROXY_AUTH_ID : <S2SV_StartBug> l2tp_proxy_auth_id_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_CALL_ERRORS : <S2SV_StartBug> l2tp_call_errors_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_ACCM : <S2SV_StartBug> l2tp_accm_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> break ; case L2TP_AVP_SEQ_REQUIRED : break ; case L2TP_AVP_PPP_DISCON_CC : l2tp_ppp_discon_cc_print ( ndo , ( const u_char * ) ptr , len - 6 ) ; break ; default : break ; } } ND_PRINT ( ( ndo , "")"" ) ) ; } l2tp_avp_print ( ndo , dat + len , length - len ) ; return ; trunc : ND_PRINT ( ( ndo , ""|..."" ) ) ; }
","<S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> ndo , ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> case L2TP_AVP_TIE_BREAKER : if ( len - 6 < 8 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> case L2TP_AVP_ASSND_SESS_ID : if ( len - 6 < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> case L2TP_AVP_CHALLENGE_RESP : if ( len - 6 < 16 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> case L2TP_AVP_RX_CONN_SPEED : if ( len - 6 < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,"<S2SV_StartBug> l2tp_msgtype_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proto_ver_print ( ndo , ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_framing_cap_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_bearer_cap_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> print_octets ( ndo , ( const u_char * ) ptr , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> print_16bits_val ( ndo , ptr ) ; <S2SV_EndBug> <S2SV_StartBug> print_octets ( ndo , ( const u_char * ) ptr , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> print_32bits_val ( ndo , ( const uint32_t * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_bearer_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_framing_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proxy_auth_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proxy_auth_id_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_call_errors_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_accm_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug>"
1080,CWE-000,"WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; <S2SV_StartBug> if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) <S2SV_EndBug> { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( num_mb_skip & 1 ) ) { num_mb_skip ++ ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; <S2SV_StartBug> if ( ! ps_dec -> u1_first_slice_in_stream ) <S2SV_EndBug> { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = - 1 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) { if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) { if ( ps_dec -> ps_pps [ i ] . ps_sps -> u1_is_valid == TRUE ) { j = i ; break ; } } } if ( j == - 1 ) { return ERROR_INV_SLICE_HDR_T ; } if ( ps_dec -> u4_pic_buf_got == 0 ) { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } ps_dec -> u4_first_slice_in_pic = 0 ; } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { if ( ( u1_mbaff ) && ( ps_dec -> u4_num_mbs_cur_nmb & 1 ) ) { ps_dec -> u4_num_mbs_cur_nmb = ps_dec -> u4_num_mbs_cur_nmb - 1 ; ps_dec -> u2_cur_mb_addr -- ; } u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; if ( u1_num_mbs ) { ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } if ( ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice < ( UWORD32 ) ( ps_dec -> u2_total_mbs_coded >> ps_slice -> u1_mbaff_frame_flag ) ) { ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> ps_parse_cur_slice ++ ; } } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= u1_mbaff ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> WORD32 ret ; UNUSED ( u1_is_idr_slice ) ; <S2SV_ModStart> = u2_frame_num ; <S2SV_ModEnd> { WORD32 i
",external@libavc/494561291a503840f385fbcd11d9bc5f4dc502b8,CVE-2017-0551,https://android.googlesource.com/platform/external/libavc/+/494561291a503840f385fbcd11d9bc5f4dc502b8,2017-04-07T22:59Z,<S2SV_StartBug> if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ps_dec -> u1_first_slice_in_stream ) <S2SV_EndBug>
2755,CWE-119,"static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t columns , <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) GetMagickPixelPacket ( images , & pixels [ i ] [ j ] ) ; } return ( pixels ) ; }
","<S2SV_ModStart> size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> ( size_t ) <S2SV_ModStart> ( ThreadResource ) ) <S2SV_ModStart> ) AcquireQuantumMemory ( rows , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> NULL ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ( ssize_t ) rows <S2SV_ModEnd> ; i ++
",ImageMagick@ImageMagick6/91e58d967a92250439ede038ccfb0913a81e59fe,CVE-2019-13307,https://github.com/ImageMagick/ImageMagick6/commit/91e58d967a92250439ede038ccfb0913a81e59fe,2019-07-05T01:15Z,"<S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug>"
6062,CWE-000,"<S2SV_StartBug> static ext4_io_end_t * ext4_init_io_end ( struct inode * inode ) <S2SV_EndBug> { ext4_io_end_t * io = NULL ; <S2SV_StartBug> io = kmalloc ( sizeof ( * io ) , GFP_NOFS ) ; <S2SV_EndBug> if ( io ) { igrab ( inode ) ; io -> inode = inode ; io -> flag = 0 ; io -> offset = 0 ; io -> size = 0 ; <S2SV_StartBug> io -> error = 0 ; <S2SV_EndBug> INIT_WORK ( & io -> work , ext4_end_io_work ) ; INIT_LIST_HEAD ( & io -> list ) ; } return io ; }
","<S2SV_ModStart> inode * inode , gfp_t flags <S2SV_ModStart> io ) , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; io -> page = NULL <S2SV_ModEnd> ; INIT_WORK (
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,"<S2SV_StartBug> static ext4_io_end_t * ext4_init_io_end ( struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> io = kmalloc ( sizeof ( * io ) , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> io -> error = 0 ; <S2SV_EndBug>"
402,CWE-787,"int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , ""."" ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , ""-c"" ) || ! strcmp ( arg , ""-cfg"" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , ""-mem-track"" ) || ! strcmp ( arg , ""-mem-track-stack"" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( arg , ""-mem-track-stack"" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , ""WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\""%s\\""\\n"" , arg ) ; # endif } else if ( ! strcmp ( arg , ""-gui"" ) ) { gui_mode = 1 ; } else if ( ! strcmp ( arg , ""-guid"" ) ) { gui_mode = 2 ; } else if ( ! strcmp ( arg , ""-h"" ) || ! strcmp ( arg , ""-help"" ) ) { PrintUsage ( ) ; return 0 ; } } # ifdef GPAC_MEMORY_TRACKING gf_sys_init ( mem_track ) ; # else gf_sys_init ( GF_MemTrackerNone ) ; # endif gf_sys_set_args ( argc , ( const char * * ) argv ) ; cfg_file = gf_cfg_init ( the_cfg , NULL ) ; if ( ! cfg_file ) { fprintf ( stderr , ""Error:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>not<S2SV_blank>found\\n"" ) ; return 1 ; } if ( gf_log_set_tools_levels ( gf_cfg_get_key ( cfg_file , ""General"" , ""Logs"" ) ) != GF_OK ) { return 1 ; } if ( gf_cfg_get_key ( cfg_file , ""General"" , ""Logs"" ) != NULL ) { logs_set = GF_TRUE ; } if ( ! gui_mode ) { str = gf_cfg_get_key ( cfg_file , ""General"" , ""ForceGUI"" ) ; if ( str && ! strcmp ( str , ""yes"" ) ) gui_mode = 1 ; } for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , ""-rti"" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , ""-rtix"" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; use_rtix = GF_TRUE ; } else if ( ! stricmp ( arg , ""-size"" ) ) { if ( sscanf ( argv [ i + 1 ] , ""%dx%d"" , & forced_width , & forced_height ) != 2 ) { forced_width = forced_height = 0 ; } i ++ ; } else if ( ! strcmp ( arg , ""-quiet"" ) ) { be_quiet = 1 ; } else if ( ! strcmp ( arg , ""-strict-error"" ) ) { gf_log_set_strict_error ( 1 ) ; } else if ( ! strcmp ( arg , ""-log-file"" ) || ! strcmp ( arg , ""-lf"" ) ) { logfile = gf_fopen ( argv [ i + 1 ] , ""wt"" ) ; gf_log_set_callback ( logfile , on_gpac_log ) ; i ++ ; } else if ( ! strcmp ( arg , ""-logs"" ) ) { if ( gf_log_set_tools_levels ( argv [ i + 1 ] ) != GF_OK ) { return 1 ; } logs_set = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , ""-log-clock"" ) || ! strcmp ( arg , ""-lc"" ) ) { log_time_start = 1 ; } else if ( ! strcmp ( arg , ""-log-utc"" ) || ! strcmp ( arg , ""-lu"" ) ) { log_utc_time = 1 ; } # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) else if ( ! strcmp ( arg , ""-thread"" ) ) threading_flags = 0 ; # else else if ( ! strcmp ( arg , ""-no-thread"" ) ) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD ; # endif else if ( ! strcmp ( arg , ""-no-cthread"" ) || ! strcmp ( arg , ""-no-compositor-thread"" ) ) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD ; else if ( ! strcmp ( arg , ""-no-audio"" ) ) no_audio = 1 ; else if ( ! strcmp ( arg , ""-no-regulation"" ) ) no_regulation = 1 ; else if ( ! strcmp ( arg , ""-fs"" ) ) start_fs = 1 ; else if ( ! strcmp ( arg , ""-opt"" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , ""-conf"" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; is_cfg_only = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , ""-ifce"" ) ) { gf_cfg_set_key ( cfg_file , ""Network"" , ""DefaultMCastInterface"" , argv [ i + 1 ] ) ; i ++ ; } else if ( ! stricmp ( arg , ""-help"" ) ) { PrintUsage ( ) ; return 1 ; } else if ( ! stricmp ( arg , ""-noprog"" ) ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } else if ( ! stricmp ( arg , ""-no-save"" ) || ! stricmp ( arg , ""--no-save"" ) ) { no_cfg_save = 1 ; } else if ( ! stricmp ( arg , ""-ntp-shift"" ) ) { s32 shift = atoi ( argv [ i + 1 ] ) ; i ++ ; gf_net_set_ntp_shift ( shift ) ; } else if ( ! stricmp ( arg , ""-run-for"" ) ) { simulation_time_in_ms = atoi ( argv [ i + 1 ] ) * 1000 ; if ( ! simulation_time_in_ms ) simulation_time_in_ms = 1 ; i ++ ; } else if ( ! strcmp ( arg , ""-out"" ) ) { out_arg = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , ""-fps"" ) ) { fps = atof ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , ""-avi"" ) || ! strcmp ( arg , ""-sha"" ) ) { dump_mode &= 0xFFFF0000 ; if ( ! strcmp ( arg , ""-sha"" ) ) dump_mode |= DUMP_SHA1 ; else dump_mode |= DUMP_AVI ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) { if ( ! strcmp ( arg , ""-avi"" ) && ( nb_times != 2 ) ) { fprintf ( stderr , ""Only<S2SV_blank>one<S2SV_blank>time<S2SV_blank>arg<S2SV_blank>found<S2SV_blank>for<S2SV_blank>-avi<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage\\n"" ) ; return 1 ; } i ++ ; } } else if ( ! strcmp ( arg , ""-rgbds"" ) ) { dump_mode |= DUMP_RGB_DEPTH_SHAPE ; } else if ( ! strcmp ( arg , ""-rgbd"" ) ) { dump_mode |= DUMP_RGB_DEPTH ; } else if ( ! strcmp ( arg , ""-depth"" ) ) { dump_mode |= DUMP_DEPTH_ONLY ; } else if ( ! strcmp ( arg , ""-bmp"" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_BMP ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , ""-png"" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_PNG ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , ""-raw"" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_RAW ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! stricmp ( arg , ""-scale"" ) ) { sscanf ( argv [ i + 1 ] , ""%f"" , & scale ) ; i ++ ; } else if ( ! strcmp ( arg , ""-c"" ) || ! strcmp ( arg , ""-cfg"" ) ) { i ++ ; } if ( ! gui_mode ) { if ( arg [ 0 ] != '-' ) { if ( url_arg ) { fprintf ( stderr , ""Several<S2SV_blank>input<S2SV_blank>URLs<S2SV_blank>provided<S2SV_blank>(\\""%s\\"",<S2SV_blank>\\""%s\\"").<S2SV_blank>Check<S2SV_blank>your<S2SV_blank>command-line.\\n"" , url_arg , arg ) ; return 1 ; } url_arg = arg ; } else if ( ! strcmp ( arg , ""-loop"" ) ) loop_at_end = 1 ; else if ( ! strcmp ( arg , ""-bench"" ) ) bench_mode = 1 ; else if ( ! strcmp ( arg , ""-vbench"" ) ) bench_mode = 2 ; else if ( ! strcmp ( arg , ""-sbench"" ) ) bench_mode = 3 ; else if ( ! strcmp ( arg , ""-no-addon"" ) ) enable_add_ons = GF_FALSE ; else if ( ! strcmp ( arg , ""-pause"" ) ) pause_at_first = 1 ; else if ( ! strcmp ( arg , ""-play-from"" ) ) { play_from = atof ( ( const char * ) argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , ""-speed"" ) ) { playback_speed = FLT2FIX ( atof ( ( const char * ) argv [ i + 1 ] ) ) ; if ( playback_speed <= 0 ) playback_speed = FIX_ONE ; i ++ ; } else if ( ! strcmp ( arg , ""-no-wnd"" ) ) user . init_flags |= GF_TERM_WINDOWLESS ; else if ( ! strcmp ( arg , ""-no-back"" ) ) user . init_flags |= GF_TERM_WINDOW_TRANSPARENT ; else if ( ! strcmp ( arg , ""-align"" ) ) { if ( argv [ i + 1 ] [ 0 ] == 'm' ) align_mode = 1 ; else if ( argv [ i + 1 ] [ 0 ] == 'b' ) align_mode = 2 ; align_mode <<= 8 ; if ( argv [ i + 1 ] [ 1 ] == 'm' ) align_mode |= 1 ; else if ( argv [ i + 1 ] [ 1 ] == 'r' ) align_mode |= 2 ; i ++ ; } else if ( ! strcmp ( arg , ""-fill"" ) ) { fill_ar = GF_TRUE ; } else if ( ! strcmp ( arg , ""-show"" ) ) { visible = 1 ; } else if ( ! strcmp ( arg , ""-uncache"" ) ) { do_uncache = GF_TRUE ; } else if ( ! strcmp ( arg , ""-exit"" ) ) auto_exit = GF_TRUE ; else if ( ! stricmp ( arg , ""-views"" ) ) { views = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , ""-mosaic"" ) ) { mosaic = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , ""-com"" ) ) { has_command = GF_TRUE ; i ++ ; } else if ( ! stricmp ( arg , ""-service"" ) ) { initial_service_id = atoi ( argv [ i + 1 ] ) ; i ++ ; } } } if ( is_cfg_only ) { gf_cfg_del ( cfg_file ) ; fprintf ( stderr , ""GPAC<S2SV_blank>Config<S2SV_blank>updated\\n"" ) ; return 0 ; } if ( do_uncache ) { const char * cache_dir = gf_cfg_get_key ( cfg_file , ""General"" , ""CacheDirectory"" ) ; do_flatten_cache ( cache_dir ) ; fprintf ( stderr , ""GPAC<S2SV_blank>Cache<S2SV_blank>dir<S2SV_blank>%s<S2SV_blank>flattened\\n"" , cache_dir ) ; gf_cfg_del ( cfg_file ) ; return 0 ; } if ( dump_mode && ! url_arg ) { FILE * test ; url_arg = ( char * ) gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) ; test = url_arg ? gf_fopen ( url_arg , ""rt"" ) : NULL ; if ( ! test ) url_arg = NULL ; else gf_fclose ( test ) ; if ( ! url_arg ) { fprintf ( stderr , ""Missing<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>dump\\n"" ) ; PrintUsage ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } } if ( ! gui_mode && ! url_arg && ( gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) != NULL ) ) { gui_mode = 1 ; } # ifdef WIN32 if ( gui_mode == 1 ) { const char * opt ; TCHAR buffer [ 1024 ] ; DWORD res = GetCurrentDirectory ( 1024 , buffer ) ; buffer [ res ] = 0 ; opt = gf_cfg_get_key ( cfg_file , ""General"" , ""ModulesDirectory"" ) ; if ( strstr ( opt , buffer ) ) { gui_mode = 1 ; } else { gui_mode = 2 ; } } # endif if ( gui_mode == 1 ) { hide_shell ( 1 ) ; } if ( gui_mode ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } if ( ! url_arg && simulation_time_in_ms ) simulation_time_in_ms += gf_sys_clock ( ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_init ( ) ; # endif if ( dump_mode ) rti_file = NULL ; if ( ! logs_set ) { gf_log_set_tool_level ( GF_LOG_ALL , GF_LOG_WARNING ) ; } if ( rti_file || logfile || log_utc_time || log_time_start ) gf_log_set_callback ( NULL , on_gpac_log ) ; if ( rti_file ) init_rti_logs ( rti_file , url_arg , use_rtix ) ; { GF_SystemRTInfo rti ; if ( gf_sys_get_rti ( 0 , & rti , 0 ) ) fprintf ( stderr , ""System<S2SV_blank>info:<S2SV_blank>%d<S2SV_blank>MB<S2SV_blank>RAM<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>cores\\n"" , ( u32 ) ( rti . physical_memory / 1024 / 1024 ) , rti . nb_cores ) ; } if ( dump_mode ) { user . init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION ; if ( ! visible ) user . init_flags |= GF_TERM_INIT_HIDE ; gf_cfg_set_key ( cfg_file , ""Audio"" , ""DriverName"" , ""Raw<S2SV_blank>Audio<S2SV_blank>Output"" ) ; no_cfg_save = GF_TRUE ; } else { init_w = forced_width ; init_h = forced_height ; } user . modules = gf_modules_new ( NULL , cfg_file ) ; if ( user . modules ) i = gf_modules_get_count ( user . modules ) ; if ( ! i || ! user . modules ) { fprintf ( stderr , ""Error:<S2SV_blank>no<S2SV_blank>modules<S2SV_blank>found<S2SV_blank>-<S2SV_blank>exiting\\n"" ) ; if ( user . modules ) gf_modules_del ( user . modules ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , ""Modules<S2SV_blank>Found<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>\\n"" , i ) ; str = gf_cfg_get_key ( cfg_file , ""General"" , ""GPACVersion"" ) ; if ( ! str || strcmp ( str , GPAC_FULL_VERSION ) ) { gf_cfg_del_section ( cfg_file , ""PluginsCache"" ) ; gf_cfg_set_key ( cfg_file , ""General"" , ""GPACVersion"" , GPAC_FULL_VERSION ) ; } user . config = cfg_file ; user . EventProc = GPAC_EventProc ; user . opaque = user . modules ; if ( threading_flags ) user . init_flags |= threading_flags ; if ( no_audio ) user . init_flags |= GF_TERM_NO_AUDIO ; if ( no_regulation ) user . init_flags |= GF_TERM_NO_REGULATION ; if ( threading_flags & ( GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD ) ) term_step = GF_TRUE ; if ( dump_mode ) user . init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK ; if ( bench_mode ) { gf_cfg_discard_changes ( user . config ) ; auto_exit = GF_TRUE ; gf_cfg_set_key ( user . config , ""Audio"" , ""DriverName"" , ""Raw<S2SV_blank>Audio<S2SV_blank>Output"" ) ; if ( bench_mode != 2 ) { gf_cfg_set_key ( user . config , ""Video"" , ""DriverName"" , ""Raw<S2SV_blank>Video<S2SV_blank>Output"" ) ; gf_cfg_set_key ( user . config , ""RAWVideo"" , ""RawOutput"" , ""null"" ) ; gf_cfg_set_key ( user . config , ""Compositor"" , ""OpenGLMode"" , ""disable"" ) ; } else { gf_cfg_set_key ( user . config , ""Video"" , ""DisableVSync"" , ""yes"" ) ; } } { char dim [ 50 ] ; sprintf ( dim , ""%d"" , forced_width ) ; gf_cfg_set_key ( user . config , ""Compositor"" , ""DefaultWidth"" , forced_width ? dim : NULL ) ; sprintf ( dim , ""%d"" , forced_height ) ; gf_cfg_set_key ( user . config , ""Compositor"" , ""DefaultHeight"" , forced_height ? dim : NULL ) ; } fprintf ( stderr , ""Loading<S2SV_blank>GPAC<S2SV_blank>Terminal\\n"" ) ; i = gf_sys_clock ( ) ; term = gf_term_new ( & user ) ; if ( ! term ) { fprintf ( stderr , ""\\nInit<S2SV_blank>error<S2SV_blank>-<S2SV_blank>check<S2SV_blank>you<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>video<S2SV_blank>out<S2SV_blank>and<S2SV_blank>one<S2SV_blank>rasterizer...\\nFound<S2SV_blank>modules:\\n"" ) ; list_modules ( user . modules ) ; gf_modules_del ( user . modules ) ; gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , ""Terminal<S2SV_blank>Loaded<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>ms\\n"" , gf_sys_clock ( ) - i ) ; if ( bench_mode ) { display_rti = 2 ; gf_term_set_option ( term , GF_OPT_VIDEO_BENCH , ( bench_mode == 3 ) ? 2 : 1 ) ; if ( bench_mode == 1 ) bench_mode = 2 ; } if ( dump_mode ) { if ( fill_ar ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; } else { str = gf_cfg_get_key ( cfg_file , ""Video"" , ""DriverName"" ) ; if ( ! bench_mode && ! strcmp ( str , ""Raw<S2SV_blank>Video<S2SV_blank>Output"" ) ) fprintf ( stderr , ""WARNING:<S2SV_blank>using<S2SV_blank>raw<S2SV_blank>output<S2SV_blank>video<S2SV_blank>(memory<S2SV_blank>only)<S2SV_blank>-<S2SV_blank>no<S2SV_blank>display<S2SV_blank>used\\n"" ) ; str = gf_cfg_get_key ( cfg_file , ""Audio"" , ""DriverName"" ) ; if ( ! str || ! strcmp ( str , ""No<S2SV_blank>Audio<S2SV_blank>Output<S2SV_blank>Available"" ) ) fprintf ( stderr , ""WARNING:<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>output<S2SV_blank>available<S2SV_blank>-<S2SV_blank>make<S2SV_blank>sure<S2SV_blank>no<S2SV_blank>other<S2SV_blank>program<S2SV_blank>is<S2SV_blank>locking<S2SV_blank>the<S2SV_blank>sound<S2SV_blank>card\\n"" ) ; str = gf_cfg_get_key ( cfg_file , ""General"" , ""NoMIMETypeFetch"" ) ; no_mime_check = ( str && ! stricmp ( str , ""yes"" ) ) ? 1 : 0 ; } str = gf_cfg_get_key ( cfg_file , ""HTTPProxy"" , ""Enabled"" ) ; if ( str && ! strcmp ( str , ""yes"" ) ) { str = gf_cfg_get_key ( cfg_file , ""HTTPProxy"" , ""Name"" ) ; if ( str ) fprintf ( stderr , ""HTTP<S2SV_blank>Proxy<S2SV_blank>%s<S2SV_blank>enabled\\n"" , str ) ; } if ( rti_file ) { str = gf_cfg_get_key ( cfg_file , ""General"" , ""RTIRefreshPeriod"" ) ; if ( str ) { rti_update_time_ms = atoi ( str ) ; } else { gf_cfg_set_key ( cfg_file , ""General"" , ""RTIRefreshPeriod"" , ""200"" ) ; } UpdateRTInfo ( ""At<S2SV_blank>GPAC<S2SV_blank>load<S2SV_blank>time\\n"" ) ; } Run = 1 ; if ( dump_mode ) { if ( ! nb_times ) { times [ 0 ] = 0 ; nb_times ++ ; } ret_val = dump_file ( url_arg , out_arg , dump_mode , fps , forced_width , forced_height , scale , times , nb_times ) ; Run = 0 ; } else if ( views ) { } else if ( ! gui_mode && url_arg ) { char * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , ""Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n"" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { strcpy ( the_url , url_arg ) ; } ext = strrchr ( the_url , '.' ) ; if ( ext && ( ! stricmp ( ext , "".m3u"" ) || ! stricmp ( ext , "".pls"" ) ) ) { GF_Err e = GF_OK ; fprintf ( stderr , ""Opening<S2SV_blank>Playlist<S2SV_blank>%s\\n"" , the_url ) ; strcpy ( pl_path , the_url ) ; if ( ! strncmp ( ""http:"" , the_url , 5 ) ) { GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; if ( sess ) { e = gf_dm_sess_process ( sess ) ; if ( ! e ) { strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; <S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> } gf_dm_sess_del ( sess ) ; } } playlist = e ? NULL : gf_fopen ( the_url , ""rt"" ) ; readonly_playlist = 1 ; if ( playlist ) { request_next_playlist_item = GF_TRUE ; } else { if ( e ) fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>playlist<S2SV_blank>%s:<S2SV_blank>%s\\n"" , the_url , gf_error_to_string ( e ) ) ; fprintf ( stderr , ""Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n"" ) ; } } else { fprintf ( stderr , ""Opening<S2SV_blank>URL<S2SV_blank>%s\\n"" , the_url ) ; if ( pause_at_first ) fprintf ( stderr , ""[Status:<S2SV_blank>Paused]\\n"" ) ; gf_term_connect_from_time ( term , the_url , ( u64 ) ( play_from * 1000 ) , pause_at_first ) ; } } else { fprintf ( stderr , ""Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n"" ) ; str = gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) ; if ( str ) { strncpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; gf_term_connect ( term , str ) ; startup_file = 1 ; is_connected = 1 ; } } if ( gui_mode == 2 ) gui_mode = 0 ; if ( start_fs ) gf_term_set_option ( term , GF_OPT_FULLSCREEN , 1 ) ; if ( views ) { char szTemp [ 4046 ] ; sprintf ( szTemp , ""views://%s"" , views ) ; gf_term_connect ( term , szTemp ) ; } if ( mosaic ) { char szTemp [ 4046 ] ; sprintf ( szTemp , ""mosaic://%s"" , mosaic ) ; gf_term_connect ( term , szTemp ) ; } if ( bench_mode ) { rti_update_time_ms = 500 ; bench_mode_start = gf_sys_clock ( ) ; } while ( Run ) { if ( ( gui_mode == 1 ) || ! gf_prompt_has_input ( ) ) { if ( reload ) { reload = 0 ; gf_term_disconnect ( term ) ; gf_term_connect ( term , startup_file ? gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) : the_url ) ; } if ( restart && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { restart = 0 ; gf_term_play_from_time ( term , 0 , 0 ) ; } if ( request_next_playlist_item ) { c = '\\n' ; request_next_playlist_item = 0 ; goto force_input ; } if ( has_command && is_connected ) { has_command = GF_FALSE ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , ""-com"" ) ) { gf_term_scene_update ( term , NULL , argv [ i + 1 ] ) ; i ++ ; } } } if ( initial_service_id && is_connected ) { GF_ObjectManager * root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { gf_term_select_service ( term , root_od , initial_service_id ) ; initial_service_id = 0 ; } } if ( ! use_rtix || display_rti ) UpdateRTInfo ( NULL ) ; if ( term_step ) { gf_term_process_step ( term ) ; } else { gf_sleep ( rti_update_time_ms ) ; } if ( auto_exit && eos_seen && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { Run = GF_FALSE ; } if ( simulation_time_in_ms && ( ( gf_term_get_elapsed_time_in_ms ( term ) > simulation_time_in_ms ) || ( ! url_arg && gf_sys_clock ( ) > simulation_time_in_ms ) ) ) { Run = GF_FALSE ; } continue ; } c = gf_prompt_get_char ( ) ; force_input : switch ( c ) { case 'q' : { GF_Event evt ; memset ( & evt , 0 , sizeof ( GF_Event ) ) ; evt . type = GF_EVENT_QUIT ; gf_term_send_event ( term , & evt ) ; } break ; case 'X' : exit ( 0 ) ; break ; case 'Q' : break ; case 'o' : startup_file = 0 ; gf_term_disconnect ( term ) ; fprintf ( stderr , ""Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL\\n"" ) ; if ( 1 > scanf ( ""%s"" , the_url ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting\\n"" ) ; break ; } if ( rti_file ) init_rti_logs ( rti_file , the_url , use_rtix ) ; gf_term_connect ( term , the_url ) ; break ; case 'O' : gf_term_disconnect ( term ) ; fprintf ( stderr , ""Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL<S2SV_blank>to<S2SV_blank>the<S2SV_blank>playlist\\n"" ) ; if ( 1 > scanf ( ""%s"" , the_url ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting.\\n"" ) ; break ; } playlist = gf_fopen ( the_url , ""rt"" ) ; if ( playlist ) { if ( 1 > fscanf ( playlist , ""%s"" , the_url ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>any<S2SV_blank>URL<S2SV_blank>from<S2SV_blank>playlist,<S2SV_blank>aborting.\\n"" ) ; gf_fclose ( playlist ) ; break ; } fprintf ( stderr , ""Opening<S2SV_blank>URL<S2SV_blank>%s\\n"" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case '\\n' : case 'N' : if ( playlist ) { int res ; gf_term_disconnect ( term ) ; res = fscanf ( playlist , ""%s"" , the_url ) ; if ( ( res == EOF ) && loop_at_end ) { fseek ( playlist , 0 , SEEK_SET ) ; res = fscanf ( playlist , ""%s"" , the_url ) ; } if ( res == EOF ) { fprintf ( stderr , ""No<S2SV_blank>more<S2SV_blank>items<S2SV_blank>-<S2SV_blank>exiting\\n"" ) ; Run = 0 ; } else if ( the_url [ 0 ] == '#' ) { request_next_playlist_item = GF_TRUE ; } else { fprintf ( stderr , ""Opening<S2SV_blank>URL<S2SV_blank>%s\\n"" , the_url ) ; gf_term_connect_with_path ( term , the_url , pl_path ) ; } } break ; case 'P' : if ( playlist ) { u32 count ; gf_term_disconnect ( term ) ; if ( 1 > scanf ( ""%u"" , & count ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>number,<S2SV_blank>aborting.\\n"" ) ; break ; } while ( count ) { if ( fscanf ( playlist , ""%s"" , the_url ) ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>line,<S2SV_blank>aborting\\n"" ) ; break ; } count -- ; } fprintf ( stderr , ""Opening<S2SV_blank>URL<S2SV_blank>%s\\n"" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case 'r' : if ( is_connected ) reload = 1 ; break ; case 'D' : if ( is_connected ) gf_term_disconnect ( term ) ; break ; case 'p' : if ( is_connected ) { Bool is_pause = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , ""[Status:<S2SV_blank>%s]\\n"" , is_pause ? ""Playing"" : ""Paused"" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } break ; case 's' : if ( is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , ""Step<S2SV_blank>time:<S2SV_blank>"" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , ""\\n"" ) ; } break ; case 'z' : case 'T' : if ( ! CanSeek || ( Duration <= 2000 ) ) { fprintf ( stderr , ""scene<S2SV_blank>not<S2SV_blank>seekable\\n"" ) ; } else { Double res ; s32 seekTo ; fprintf ( stderr , ""Duration:<S2SV_blank>"" ) ; PrintTime ( Duration ) ; res = gf_term_get_time_in_ms ( term ) ; if ( c == 'z' ) { res *= 100 ; res /= ( s64 ) Duration ; fprintf ( stderr , ""<S2SV_blank>(current<S2SV_blank>%.2f<S2SV_blank>%%)\\nEnter<S2SV_blank>Seek<S2SV_blank>percentage:\\n"" , res ) ; if ( scanf ( ""%d"" , & seekTo ) == 1 ) { if ( seekTo > 100 ) seekTo = 100 ; res = ( Double ) ( s64 ) Duration ; res /= 100 ; res *= seekTo ; gf_term_play_from_time ( term , ( u64 ) ( s64 ) res , 0 ) ; } } else { u32 r , h , m , s ; fprintf ( stderr , ""<S2SV_blank>-<S2SV_blank>Current<S2SV_blank>Time:<S2SV_blank>"" ) ; PrintTime ( ( u64 ) res ) ; fprintf ( stderr , ""\\nEnter<S2SV_blank>seek<S2SV_blank>time<S2SV_blank>(Format:<S2SV_blank>s,<S2SV_blank>m:s<S2SV_blank>or<S2SV_blank>h:m:s):\\n"" ) ; h = m = s = 0 ; r = scanf ( ""%d:%d:%d"" , & h , & m , & s ) ; if ( r == 2 ) { s = m ; m = h ; h = 0 ; } else if ( r == 1 ) { s = h ; m = h = 0 ; } if ( r && ( r <= 3 ) ) { u64 time = h * 3600 + m * 60 + s ; gf_term_play_from_time ( term , time * 1000 , 0 ) ; } } } break ; case 't' : { if ( is_connected ) { fprintf ( stderr , ""Current<S2SV_blank>Time:<S2SV_blank>"" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , ""<S2SV_blank>-<S2SV_blank>Duration:<S2SV_blank>"" ) ; PrintTime ( Duration ) ; fprintf ( stderr , ""\\n"" ) ; } } break ; case 'w' : if ( is_connected ) PrintWorldInfo ( term ) ; break ; case 'v' : if ( is_connected ) PrintODList ( term , NULL , 0 , 0 , ""Root"" ) ; break ; case 'i' : if ( is_connected ) { u32 ID ; fprintf ( stderr , ""Enter<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>"" ) ; fflush ( stderr ) ; if ( scanf ( ""%ud"" , & ID ) == 1 ) { ViewOD ( term , ID , ( u32 ) - 1 , NULL ) ; } else { char str_url [ GF_MAX_PATH ] ; if ( scanf ( ""%s"" , str_url ) == 1 ) ViewOD ( term , 0 , ( u32 ) - 1 , str_url ) ; } } break ; case 'j' : if ( is_connected ) { u32 num ; do { fprintf ( stderr , ""Enter<S2SV_blank>OD<S2SV_blank>number<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>"" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( ""%ud"" , & num ) ) ; ViewOD ( term , ( u32 ) - 1 , num , NULL ) ; } break ; case 'b' : if ( is_connected ) ViewODs ( term , 1 ) ; break ; case 'm' : if ( is_connected ) ViewODs ( term , 0 ) ; break ; case 'l' : list_modules ( user . modules ) ; break ; case 'n' : if ( is_connected ) set_navigation ( ) ; break ; case 'x' : if ( is_connected ) gf_term_set_option ( term , GF_OPT_NAVIGATION_TYPE , 0 ) ; break ; case 'd' : if ( is_connected ) { GF_ObjectManager * odm = NULL ; char radname [ GF_MAX_PATH ] , * sExt ; GF_Err e ; u32 i , count , odid ; Bool xml_dump , std_out ; radname [ 0 ] = 0 ; do { fprintf ( stderr , ""Enter<S2SV_blank>Inline<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>if<S2SV_blank>any<S2SV_blank>or<S2SV_blank>0<S2SV_blank>:<S2SV_blank>"" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( ""%ud"" , & odid ) ) ; if ( odid ) { GF_ObjectManager * root_odm = gf_term_get_root_object ( term ) ; if ( ! root_odm ) break ; count = gf_term_get_object_count ( term , root_odm ) ; for ( i = 0 ; i < count ; i ++ ) { GF_MediaInfo info ; odm = gf_term_get_object ( term , root_odm , i ) ; if ( gf_term_get_object_info ( term , odm , & info ) == GF_OK ) { if ( info . od -> objectDescriptorID == odid ) break ; } odm = NULL ; } } do { fprintf ( stderr , ""Enter<S2SV_blank>file<S2SV_blank>radical<S2SV_blank>name<S2SV_blank>(+\\\'.x\\\'<S2SV_blank>for<S2SV_blank>XML<S2SV_blank>dumping)<S2SV_blank>-<S2SV_blank>\\""std\\""<S2SV_blank>for<S2SV_blank>stderr:<S2SV_blank>"" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( ""%s"" , radname ) ) ; sExt = strrchr ( radname , '.' ) ; xml_dump = 0 ; if ( sExt ) { if ( ! stricmp ( sExt , "".x"" ) ) xml_dump = 1 ; sExt [ 0 ] = 0 ; } std_out = strnicmp ( radname , ""std"" , 3 ) ? 0 : 1 ; e = gf_term_dump_scene ( term , std_out ? NULL : radname , NULL , xml_dump , 0 , odm ) ; fprintf ( stderr , ""Dump<S2SV_blank>done<S2SV_blank>(%s)\\n"" , gf_error_to_string ( e ) ) ; } break ; case 'c' : PrintGPACConfig ( ) ; break ; case '3' : { Bool use_3d = ! gf_term_get_option ( term , GF_OPT_USE_OPENGL ) ; if ( gf_term_set_option ( term , GF_OPT_USE_OPENGL , use_3d ) == GF_OK ) { fprintf ( stderr , ""Using<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>2D<S2SV_blank>drawing\\n"" , use_3d ? ""OpenGL"" : ""2D<S2SV_blank>rasterizer"" ) ; } } break ; case 'k' : { Bool opt = gf_term_get_option ( term , GF_OPT_STRESS_MODE ) ; opt = ! opt ; fprintf ( stderr , ""Turning<S2SV_blank>stress<S2SV_blank>mode<S2SV_blank>%s\\n"" , opt ? ""on"" : ""off"" ) ; gf_term_set_option ( term , GF_OPT_STRESS_MODE , opt ) ; } break ; case '4' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case '5' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case '6' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case '7' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case 'C' : switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_DISABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_ENABLED ) ; break ; case GF_MEDIA_CACHE_ENABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_DISABLED ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>is<S2SV_blank>running<S2SV_blank>-<S2SV_blank>please<S2SV_blank>stop<S2SV_blank>it<S2SV_blank>first\\n"" ) ; continue ; } switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_ENABLED : fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>Enabled\\n"" ) ; break ; case GF_MEDIA_CACHE_DISABLED : fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>Disabled\\n"" ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>Running\\n"" ) ; break ; } break ; case 'S' : case 'A' : if ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) == GF_MEDIA_CACHE_RUNNING ) { gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , ( c == 'S' ) ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD ) ; fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>stopped\\n"" ) ; } else { fprintf ( stderr , ""Streaming<S2SV_blank>Cache<S2SV_blank>not<S2SV_blank>running\\n"" ) ; } break ; case 'R' : display_rti = ! display_rti ; ResetCaption ( ) ; break ; case 'F' : if ( display_rti ) display_rti = 0 ; else display_rti = 2 ; ResetCaption ( ) ; break ; case 'u' : { GF_Err e ; char szCom [ 8192 ] ; fprintf ( stderr , ""Enter<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send:\\n"" ) ; fflush ( stdin ) ; szCom [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , szCom ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send,<S2SV_blank>aborting.\\n"" ) ; break ; } e = gf_term_scene_update ( term , NULL , szCom ) ; if ( e ) fprintf ( stderr , ""Processing<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; } break ; case 'e' : { GF_Err e ; char jsCode [ 8192 ] ; fprintf ( stderr , ""Enter<S2SV_blank>JavaScript<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate:\\n"" ) ; fflush ( stdin ) ; jsCode [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , jsCode ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate,<S2SV_blank>aborting.\\n"" ) ; break ; } e = gf_term_scene_update ( term , ""application/ecmascript"" , jsCode ) ; if ( e ) fprintf ( stderr , ""Processing<S2SV_blank>JS<S2SV_blank>code<S2SV_blank>failed:<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; } break ; case 'L' : { char szLog [ 1024 ] , * cur_logs ; cur_logs = gf_log_get_tools_levels ( ) ; fprintf ( stderr , ""Enter<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level<S2SV_blank>(current<S2SV_blank>tools<S2SV_blank>%s):\\n"" , cur_logs ) ; gf_free ( cur_logs ) ; if ( scanf ( ""%s"" , szLog ) < 1 ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level,<S2SV_blank>aborting.\\n"" ) ; break ; } gf_log_modify_tools_levels ( szLog ) ; } break ; case 'g' : { GF_SystemRTInfo rti ; gf_sys_get_rti ( rti_update_time_ms , & rti , 0 ) ; fprintf ( stderr , ""GPAC<S2SV_blank>allocated<S2SV_blank>memory<S2SV_blank>"" LLD ""\\n"" , rti . gpac_memory ) ; } break ; case 'M' : { u32 size ; do { fprintf ( stderr , ""Enter<S2SV_blank>new<S2SV_blank>video<S2SV_blank>cache<S2SV_blank>memory<S2SV_blank>in<S2SV_blank>kBytes<S2SV_blank>(current<S2SV_blank>%ud):\\n"" , gf_term_get_option ( term , GF_OPT_VIDEO_CACHE_SIZE ) ) ; } while ( 1 > scanf ( ""%ud"" , & size ) ) ; gf_term_set_option ( term , GF_OPT_VIDEO_CACHE_SIZE , size ) ; } break ; case 'H' : { u32 http_bitrate = gf_term_get_option ( term , GF_OPT_HTTP_MAX_RATE ) ; do { fprintf ( stderr , ""Enter<S2SV_blank>new<S2SV_blank>http<S2SV_blank>bitrate<S2SV_blank>in<S2SV_blank>bps<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>none)<S2SV_blank>-<S2SV_blank>current<S2SV_blank>limit:<S2SV_blank>%d\\n"" , http_bitrate ) ; } while ( 1 > scanf ( ""%ud"" , & http_bitrate ) ) ; gf_term_set_option ( term , GF_OPT_HTTP_MAX_RATE , http_bitrate ) ; } break ; case 'E' : gf_term_set_option ( term , GF_OPT_RELOAD_CONFIG , 1 ) ; break ; case 'B' : switch_bench ( ! bench_mode ) ; break ; case 'Y' : { char szOpt [ 8192 ] ; fprintf ( stderr , ""Enter<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set<S2SV_blank>(Section:Name=Value):\\n"" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , szOpt ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>option\\n"" ) ; break ; } set_cfg_option ( szOpt ) ; } break ; case 'Z' : { char szFileName [ 100 ] ; u32 nb_pass , nb_views , offscreen_view = 0 ; GF_VideoSurface fb ; GF_Err e ; nb_pass = 1 ; nb_views = gf_term_get_option ( term , GF_OPT_NUM_STEREO_VIEWS ) ; if ( nb_views > 1 ) { fprintf ( stderr , ""Auto-stereo<S2SV_blank>mode<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>type<S2SV_blank>number<S2SV_blank>of<S2SV_blank>view<S2SV_blank>to<S2SV_blank>dump<S2SV_blank>(0<S2SV_blank>is<S2SV_blank>main<S2SV_blank>output,<S2SV_blank>1<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>offscreen<S2SV_blank>view,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen<S2SV_blank>and<S2SV_blank>main)\\n"" , nb_views , nb_views + 1 , nb_views + 2 ) ; if ( scanf ( ""%d"" , & offscreen_view ) != 1 ) { offscreen_view = 0 ; } if ( offscreen_view == nb_views + 1 ) { offscreen_view = 1 ; nb_pass = nb_views ; } else if ( offscreen_view == nb_views + 2 ) { offscreen_view = 0 ; nb_pass = nb_views + 1 ; } } while ( nb_pass ) { nb_pass -- ; if ( offscreen_view ) { sprintf ( szFileName , ""view%d_dump.png"" , offscreen_view ) ; e = gf_term_get_offscreen_buffer ( term , & fb , offscreen_view - 1 , 0 ) ; } else { sprintf ( szFileName , ""gpac_video_dump_"" LLU "".png"" , gf_net_get_utc ( ) ) ; e = gf_term_get_screen_buffer ( term , & fb ) ; } offscreen_view ++ ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>dumping<S2SV_blank>screen<S2SV_blank>buffer<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { # ifndef GPAC_DISABLE_AV_PARSERS u32 dst_size = fb . width * fb . height * 4 ; char * dst = ( char * ) gf_malloc ( sizeof ( char ) * dst_size ) ; e = gf_img_png_enc ( fb . video_buffer , fb . width , fb . height , fb . pitch_y , fb . pixel_format , dst , & dst_size ) ; if ( e ) { fprintf ( stderr , ""Error<S2SV_blank>encoding<S2SV_blank>PNG<S2SV_blank>%s\\n"" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { FILE * png = gf_fopen ( szFileName , ""wb"" ) ; if ( ! png ) { fprintf ( stderr , ""Error<S2SV_blank>writing<S2SV_blank>file<S2SV_blank>%s\\n"" , szFileName ) ; nb_pass = 0 ; } else { gf_fwrite ( dst , dst_size , 1 , png ) ; gf_fclose ( png ) ; fprintf ( stderr , ""Dump<S2SV_blank>to<S2SV_blank>%s\\n"" , szFileName ) ; } } if ( dst ) gf_free ( dst ) ; gf_term_release_screen_buffer ( term , & fb ) ; # endif } } fprintf ( stderr , ""Done:<S2SV_blank>%s\\n"" , szFileName ) ; } break ; case 'G' : { GF_ObjectManager * root_od , * odm ; u32 index ; char szOpt [ 8192 ] ; fprintf ( stderr , ""Enter<S2SV_blank>0-based<S2SV_blank>index<S2SV_blank>of<S2SV_blank>object<S2SV_blank>to<S2SV_blank>select<S2SV_blank>or<S2SV_blank>service<S2SV_blank>ID:\\n"" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , szOpt ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>read<S2SV_blank>OD<S2SV_blank>ID\\n"" ) ; break ; } index = atoi ( szOpt ) ; odm = NULL ; root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { if ( gf_term_find_service ( term , root_od , index ) ) { gf_term_select_service ( term , root_od , index ) ; } else { fprintf ( stderr , ""Cannot<S2SV_blank>find<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>with<S2SV_blank>object<S2SV_blank>index\\n"" , index ) ; odm = gf_term_get_object ( term , root_od , index ) ; if ( odm ) { gf_term_select_object ( term , odm ) ; } else { fprintf ( stderr , ""Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d\\n"" , index ) ; } } } } break ; case 'h' : PrintHelp ( ) ; break ; default : break ; } } if ( bench_mode ) { PrintAVInfo ( GF_TRUE ) ; } if ( simulation_time_in_ms ) { gf_log_set_strict_error ( 0 ) ; } i = gf_sys_clock ( ) ; gf_term_disconnect ( term ) ; if ( rti_file ) UpdateRTInfo ( ""Disconnected\\n"" ) ; fprintf ( stderr , ""Deleting<S2SV_blank>terminal...<S2SV_blank>"" ) ; if ( playlist ) gf_fclose ( playlist ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_uninit ( ) ; # endif gf_term_del ( term ) ; fprintf ( stderr , ""done<S2SV_blank>(in<S2SV_blank>%d<S2SV_blank>ms)<S2SV_blank>-<S2SV_blank>ran<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms\\n"" , gf_sys_clock ( ) - i , gf_sys_clock ( ) ) ; fprintf ( stderr , ""GPAC<S2SV_blank>cleanup<S2SV_blank>...\\n"" ) ; gf_modules_del ( user . modules ) ; if ( no_cfg_save ) gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( rti_logs ) gf_fclose ( rti_logs ) ; if ( logfile ) gf_fclose ( logfile ) ; if ( gui_mode ) { hide_shell ( 2 ) ; } # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return ret_val ; }
","<S2SV_ModStart> [ sizeof ( the_url <S2SV_ModEnd> ) - 1
",gpac@gpac/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd,CVE-2018-20763,https://github.com/gpac/gpac/commit/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd,2019-02-06T23:29Z,<S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug>
1262,CWE-264,"static int fr_add_pvc ( struct net_device * frad , unsigned int dlci , int type ) { hdlc_device * hdlc = dev_to_hdlc ( frad ) ; pvc_device * pvc ; struct net_device * dev ; int used ; if ( ( pvc = add_pvc ( frad , dlci ) ) == NULL ) { netdev_warn ( frad , ""Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_add_pvc()\\n"" ) ; return - ENOBUFS ; } if ( * get_dev_p ( pvc , type ) ) return - EEXIST ; used = pvc_is_used ( pvc ) ; <S2SV_StartBug> if ( type == ARPHRD_ETHER ) <S2SV_EndBug> dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ; <S2SV_StartBug> else <S2SV_EndBug> dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ; if ( ! dev ) { netdev_warn ( frad , ""Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_pvc()\\n"" ) ; delete_unused_pvcs ( hdlc ) ; return - ENOBUFS ; } if ( type == ARPHRD_ETHER ) random_ether_addr ( dev -> dev_addr ) ; else { * ( __be16 * ) dev -> dev_addr = htons ( dlci ) ; dlci_to_q922 ( dev -> broadcast , dlci ) ; } dev -> netdev_ops = & pvc_ops ; dev -> mtu = HDLC_MAX_MTU ; dev -> tx_queue_len = 0 ; dev -> ml_priv = pvc ; if ( register_netdevice ( dev ) != 0 ) { free_netdev ( dev ) ; delete_unused_pvcs ( hdlc ) ; return - EIO ; } dev -> destructor = free_netdev ; * get_dev_p ( pvc , type ) = dev ; if ( ! used ) { state ( hdlc ) -> dce_changed = 1 ; state ( hdlc ) -> dce_pvc_count ++ ; } return 0 ; }
","<S2SV_ModStart> == ARPHRD_ETHER ) { <S2SV_ModStart> ether_setup ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; }
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,<S2SV_StartBug> if ( type == ARPHRD_ETHER ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug>
7646,CWE-611,"void * merge_directory_configs ( apr_pool_t * mp , void * _parent , void * _child ) { directory_config * parent = ( directory_config * ) _parent ; directory_config * child = ( directory_config * ) _child ; directory_config * merged = create_directory_config ( mp , NULL ) ; # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Merge<S2SV_blank>parent<S2SV_blank>%pp<S2SV_blank>child<S2SV_blank>%pp<S2SV_blank>RESULT<S2SV_blank>%pp"" , _parent , _child , merged ) ; # endif if ( merged == NULL ) return NULL ; merged -> is_enabled = ( child -> is_enabled == NOT_SET ? parent -> is_enabled : child -> is_enabled ) ; merged -> reqbody_access = ( child -> reqbody_access == NOT_SET ? parent -> reqbody_access : child -> reqbody_access ) ; merged -> reqbody_buffering = ( child -> reqbody_buffering == NOT_SET ? parent -> reqbody_buffering : child -> reqbody_buffering ) ; merged -> reqbody_inmemory_limit = ( child -> reqbody_inmemory_limit == NOT_SET ? parent -> reqbody_inmemory_limit : child -> reqbody_inmemory_limit ) ; merged -> reqbody_limit = ( child -> reqbody_limit == NOT_SET ? parent -> reqbody_limit : child -> reqbody_limit ) ; merged -> reqbody_no_files_limit = ( child -> reqbody_no_files_limit == NOT_SET ? parent -> reqbody_no_files_limit : child -> reqbody_no_files_limit ) ; merged -> resbody_access = ( child -> resbody_access == NOT_SET ? parent -> resbody_access : child -> resbody_access ) ; merged -> of_limit = ( child -> of_limit == NOT_SET ? parent -> of_limit : child -> of_limit ) ; merged -> if_limit_action = ( child -> if_limit_action == NOT_SET ? parent -> if_limit_action : child -> if_limit_action ) ; merged -> of_limit_action = ( child -> of_limit_action == NOT_SET ? parent -> of_limit_action : child -> of_limit_action ) ; merged -> reqintercept_oe = ( child -> reqintercept_oe == NOT_SET ? parent -> reqintercept_oe : child -> reqintercept_oe ) ; if ( child -> of_mime_types != NOT_SET_P ) { if ( child -> of_mime_types_cleared == 1 ) { merged -> of_mime_types = child -> of_mime_types ; merged -> of_mime_types_cleared = 1 ; } else { if ( parent -> of_mime_types == NOT_SET_P ) { merged -> of_mime_types = child -> of_mime_types ; merged -> of_mime_types_cleared = NOT_SET ; } else { merged -> of_mime_types = apr_table_overlay ( mp , parent -> of_mime_types , child -> of_mime_types ) ; if ( merged -> of_mime_types == NULL ) return NULL ; } } } else { if ( child -> of_mime_types_cleared == 1 ) { merged -> of_mime_types_cleared = 1 ; } else { merged -> of_mime_types = parent -> of_mime_types ; merged -> of_mime_types_cleared = parent -> of_mime_types_cleared ; } } if ( child -> debuglog_fd == NOT_SET_P ) { merged -> debuglog_name = parent -> debuglog_name ; merged -> debuglog_fd = parent -> debuglog_fd ; } else { merged -> debuglog_name = child -> debuglog_name ; merged -> debuglog_fd = child -> debuglog_fd ; } merged -> debuglog_level = ( child -> debuglog_level == NOT_SET ? parent -> debuglog_level : child -> debuglog_level ) ; merged -> cookie_format = ( child -> cookie_format == NOT_SET ? parent -> cookie_format : child -> cookie_format ) ; merged -> argument_separator = ( child -> argument_separator == NOT_SET ? parent -> argument_separator : child -> argument_separator ) ; merged -> cookiev0_separator = ( child -> cookiev0_separator == NOT_SET_P ? parent -> cookiev0_separator : child -> cookiev0_separator ) ; if ( ( child -> rule_inheritance == NOT_SET ) || ( child -> rule_inheritance == 1 ) ) { merged -> rule_inheritance = parent -> rule_inheritance ; if ( ( child -> ruleset == NULL ) && ( parent -> ruleset == NULL ) ) { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""No<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif } else if ( child -> ruleset == NULL ) { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Using<S2SV_blank>parent<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( parent -> ruleset -> engine , mp ) ; copy_rules ( mp , parent -> ruleset , merged -> ruleset , child -> rule_exceptions ) ; } else if ( parent -> ruleset == NULL ) { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Using<S2SV_blank>child<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( child -> ruleset -> engine , mp ) ; merged -> ruleset -> phase_request_headers = apr_array_copy ( mp , child -> ruleset -> phase_request_headers ) ; merged -> ruleset -> phase_request_body = apr_array_copy ( mp , child -> ruleset -> phase_request_body ) ; merged -> ruleset -> phase_response_headers = apr_array_copy ( mp , child -> ruleset -> phase_response_headers ) ; merged -> ruleset -> phase_response_body = apr_array_copy ( mp , child -> ruleset -> phase_response_body ) ; merged -> ruleset -> phase_logging = apr_array_copy ( mp , child -> ruleset -> phase_logging ) ; } else { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Using<S2SV_blank>parent<S2SV_blank>then<S2SV_blank>child<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( parent -> ruleset -> engine , mp ) ; copy_rules ( mp , parent -> ruleset , merged -> ruleset , child -> rule_exceptions ) ; apr_array_cat ( merged -> ruleset -> phase_request_headers , child -> ruleset -> phase_request_headers ) ; apr_array_cat ( merged -> ruleset -> phase_request_body , child -> ruleset -> phase_request_body ) ; apr_array_cat ( merged -> ruleset -> phase_response_headers , child -> ruleset -> phase_response_headers ) ; apr_array_cat ( merged -> ruleset -> phase_response_body , child -> ruleset -> phase_response_body ) ; apr_array_cat ( merged -> ruleset -> phase_logging , child -> ruleset -> phase_logging ) ; } } else { merged -> rule_inheritance = 0 ; if ( child -> ruleset != NULL ) { merged -> ruleset = msre_ruleset_create ( child -> ruleset -> engine , mp ) ; merged -> ruleset -> phase_request_headers = apr_array_copy ( mp , child -> ruleset -> phase_request_headers ) ; merged -> ruleset -> phase_request_body = apr_array_copy ( mp , child -> ruleset -> phase_request_body ) ; merged -> ruleset -> phase_response_headers = apr_array_copy ( mp , child -> ruleset -> phase_response_headers ) ; merged -> ruleset -> phase_response_body = apr_array_copy ( mp , child -> ruleset -> phase_response_body ) ; merged -> ruleset -> phase_logging = apr_array_copy ( mp , child -> ruleset -> phase_logging ) ; } } merged -> rule_exceptions = apr_array_append ( mp , parent -> rule_exceptions , child -> rule_exceptions ) ; merged -> hash_method = apr_array_append ( mp , parent -> hash_method , child -> hash_method ) ; merged -> auditlog_flag = ( child -> auditlog_flag == NOT_SET ? parent -> auditlog_flag : child -> auditlog_flag ) ; merged -> auditlog_type = ( child -> auditlog_type == NOT_SET ? parent -> auditlog_type : child -> auditlog_type ) ; merged -> max_rule_time = ( child -> max_rule_time == NOT_SET ? parent -> max_rule_time : child -> max_rule_time ) ; merged -> auditlog_dirperms = ( child -> auditlog_dirperms == NOT_SET ? parent -> auditlog_dirperms : child -> auditlog_dirperms ) ; merged -> auditlog_fileperms = ( child -> auditlog_fileperms == NOT_SET ? parent -> auditlog_fileperms : child -> auditlog_fileperms ) ; if ( child -> auditlog_fd != NOT_SET_P ) { merged -> auditlog_fd = child -> auditlog_fd ; merged -> auditlog_name = child -> auditlog_name ; } else { merged -> auditlog_fd = parent -> auditlog_fd ; merged -> auditlog_name = parent -> auditlog_name ; } if ( child -> auditlog2_fd != NOT_SET_P ) { merged -> auditlog2_fd = child -> auditlog2_fd ; merged -> auditlog2_name = child -> auditlog2_name ; } else { merged -> auditlog2_fd = parent -> auditlog2_fd ; merged -> auditlog2_name = parent -> auditlog2_name ; } merged -> auditlog_storage_dir = ( child -> auditlog_storage_dir == NOT_SET_P ? parent -> auditlog_storage_dir : child -> auditlog_storage_dir ) ; merged -> auditlog_parts = ( child -> auditlog_parts == NOT_SET_P ? parent -> auditlog_parts : child -> auditlog_parts ) ; merged -> auditlog_relevant_regex = ( child -> auditlog_relevant_regex == NOT_SET_P ? parent -> auditlog_relevant_regex : child -> auditlog_relevant_regex ) ; merged -> tmp_dir = ( child -> tmp_dir == NOT_SET_P ? parent -> tmp_dir : child -> tmp_dir ) ; merged -> upload_dir = ( child -> upload_dir == NOT_SET_P ? parent -> upload_dir : child -> upload_dir ) ; merged -> upload_keep_files = ( child -> upload_keep_files == NOT_SET ? parent -> upload_keep_files : child -> upload_keep_files ) ; merged -> upload_validates_files = ( child -> upload_validates_files == NOT_SET ? parent -> upload_validates_files : child -> upload_validates_files ) ; merged -> upload_filemode = ( child -> upload_filemode == NOT_SET ? parent -> upload_filemode : child -> upload_filemode ) ; merged -> upload_file_limit = ( child -> upload_file_limit == NOT_SET ? parent -> upload_file_limit : child -> upload_file_limit ) ; merged -> data_dir = ( child -> data_dir == NOT_SET_P ? parent -> data_dir : child -> data_dir ) ; merged -> webappid = ( child -> webappid == NOT_SET_P ? parent -> webappid : child -> webappid ) ; merged -> sensor_id = ( child -> sensor_id == NOT_SET_P ? parent -> sensor_id : child -> sensor_id ) ; merged -> httpBlkey = ( child -> httpBlkey == NOT_SET_P ? parent -> httpBlkey : child -> httpBlkey ) ; merged -> content_injection_enabled = ( child -> content_injection_enabled == NOT_SET ? parent -> content_injection_enabled : child -> content_injection_enabled ) ; merged -> stream_inbody_inspection = ( child -> stream_inbody_inspection == NOT_SET ? parent -> stream_inbody_inspection : child -> stream_inbody_inspection ) ; merged -> stream_outbody_inspection = ( child -> stream_outbody_inspection == NOT_SET ? parent -> stream_outbody_inspection : child -> stream_outbody_inspection ) ; merged -> geo = ( child -> geo == NOT_SET_P ? parent -> geo : child -> geo ) ; merged -> gsb = ( child -> gsb == NOT_SET_P ? parent -> gsb : child -> gsb ) ; merged -> u_map = ( child -> u_map == NOT_SET_P ? parent -> u_map : child -> u_map ) ; merged -> cache_trans = ( child -> cache_trans == NOT_SET ? parent -> cache_trans : child -> cache_trans ) ; merged -> cache_trans_incremental = ( child -> cache_trans_incremental == NOT_SET ? parent -> cache_trans_incremental : child -> cache_trans_incremental ) ; merged -> cache_trans_min = ( child -> cache_trans_min == ( apr_size_t ) NOT_SET ? parent -> cache_trans_min : child -> cache_trans_min ) ; merged -> cache_trans_max = ( child -> cache_trans_max == ( apr_size_t ) NOT_SET ? parent -> cache_trans_max : child -> cache_trans_max ) ; merged -> cache_trans_maxitems = ( child -> cache_trans_maxitems == ( apr_size_t ) NOT_SET ? parent -> cache_trans_maxitems : child -> cache_trans_maxitems ) ; merged -> component_signatures = apr_array_append ( mp , parent -> component_signatures , child -> component_signatures ) ; merged -> request_encoding = ( child -> request_encoding == NOT_SET_P ? parent -> request_encoding : child -> request_encoding ) ; merged -> disable_backend_compression = ( child -> disable_backend_compression == NOT_SET ? parent -> disable_backend_compression : child -> disable_backend_compression ) ; merged -> col_timeout = ( child -> col_timeout == NOT_SET ? parent -> col_timeout : child -> col_timeout ) ; merged -> crypto_key = ( child -> crypto_key == NOT_SET_P ? parent -> crypto_key : child -> crypto_key ) ; merged -> crypto_key_len = ( child -> crypto_key_len == NOT_SET ? parent -> crypto_key_len : child -> crypto_key_len ) ; merged -> crypto_key_add = ( child -> crypto_key_add == NOT_SET ? parent -> crypto_key_add : child -> crypto_key_add ) ; merged -> crypto_param_name = ( child -> crypto_param_name == NOT_SET_P ? parent -> crypto_param_name : child -> crypto_param_name ) ; merged -> hash_is_enabled = ( child -> hash_is_enabled == NOT_SET ? parent -> hash_is_enabled : child -> hash_is_enabled ) ; merged -> hash_enforcement = ( child -> hash_enforcement == NOT_SET ? parent -> hash_enforcement : child -> hash_enforcement ) ; merged -> crypto_hash_href_rx = ( child -> crypto_hash_href_rx == NOT_SET ? parent -> crypto_hash_href_rx : child -> crypto_hash_href_rx ) ; merged -> crypto_hash_faction_rx = ( child -> crypto_hash_faction_rx == NOT_SET ? parent -> crypto_hash_faction_rx : child -> crypto_hash_faction_rx ) ; merged -> crypto_hash_location_rx = ( child -> crypto_hash_location_rx == NOT_SET ? parent -> crypto_hash_location_rx : child -> crypto_hash_location_rx ) ; merged -> crypto_hash_iframesrc_rx = ( child -> crypto_hash_iframesrc_rx == NOT_SET ? parent -> crypto_hash_iframesrc_rx : child -> crypto_hash_iframesrc_rx ) ; merged -> crypto_hash_framesrc_rx = ( child -> crypto_hash_framesrc_rx == NOT_SET ? parent -> crypto_hash_framesrc_rx : child -> crypto_hash_framesrc_rx ) ; merged -> crypto_hash_href_pm = ( child -> crypto_hash_href_pm == NOT_SET ? parent -> crypto_hash_href_pm : child -> crypto_hash_href_pm ) ; merged -> crypto_hash_faction_pm = ( child -> crypto_hash_faction_pm == NOT_SET ? parent -> crypto_hash_faction_pm : child -> crypto_hash_faction_pm ) ; merged -> crypto_hash_location_pm = ( child -> crypto_hash_location_pm == NOT_SET ? parent -> crypto_hash_location_pm : child -> crypto_hash_location_pm ) ; merged -> crypto_hash_iframesrc_pm = ( child -> crypto_hash_iframesrc_pm == NOT_SET ? parent -> crypto_hash_iframesrc_pm : child -> crypto_hash_iframesrc_pm ) ; merged -> crypto_hash_framesrc_pm = ( child -> crypto_hash_framesrc_pm == NOT_SET ? parent -> crypto_hash_framesrc_pm : child -> crypto_hash_framesrc_pm ) ; <S2SV_StartBug> return merged ; <S2SV_EndBug> }
","<S2SV_ModStart> crypto_hash_framesrc_pm ) ; merged -> xml_external_entity = ( child -> xml_external_entity == NOT_SET ? parent -> xml_external_entity : child -> xml_external_entity ) ;
",SpiderLabs@ModSecurity/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,CVE-2013-1915,https://github.com/SpiderLabs/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,2013-04-25T23:55Z,<S2SV_StartBug> return merged ; <S2SV_EndBug>
1751,CWE-119,"<S2SV_StartBug> void vp9_update_mv_count ( VP9_COMMON * cm , const MACROBLOCKD * xd ) { <S2SV_EndBug> const MODE_INFO * mi = xd -> mi [ 0 ] ; <S2SV_StartBug> const MB_MODE_INFO * const mbmi = & mi -> mbmi ; <S2SV_EndBug> if ( mbmi -> sb_type < BLOCK_8X8 ) { const int num_4x4_w = num_4x4_blocks_wide_lookup [ mbmi -> sb_type ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ mbmi -> sb_type ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int i = idy * 2 + idx ; if ( mi -> bmi [ i ] . as_mode == NEWMV ) <S2SV_StartBug> inc_mvs ( mbmi , mi -> bmi [ i ] . as_mv , & cm -> counts . mv ) ; <S2SV_EndBug> } } } else { if ( mbmi -> mode == NEWMV ) <S2SV_StartBug> inc_mvs ( mbmi , mbmi -> mv , & cm -> counts . mv ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> void vp9_update_mv_count ( ThreadData * td ) { <S2SV_ModEnd> const MACROBLOCKD * <S2SV_ModStart> MACROBLOCKD * xd = & td -> mb . e_mbd ; <S2SV_ModEnd> const MODE_INFO * <S2SV_ModStart> mi -> mbmi ; const MB_MODE_INFO_EXT * mbmi_ext = td -> mb . mbmi_ext <S2SV_ModStart> ( mbmi , mbmi_ext , <S2SV_ModStart> as_mv , & td -> counts -> <S2SV_ModEnd> mv ) ; <S2SV_ModStart> ( mbmi , mbmi_ext , <S2SV_ModStart> mv , & td -> counts -> <S2SV_ModEnd> mv ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> void vp9_update_mv_count ( VP9_COMMON * cm , const MACROBLOCKD * xd ) { <S2SV_EndBug> <S2SV_StartBug> const MB_MODE_INFO * const mbmi = & mi -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> inc_mvs ( mbmi , mi -> bmi [ i ] . as_mv , & cm -> counts . mv ) ; <S2SV_EndBug> <S2SV_StartBug> inc_mvs ( mbmi , mbmi -> mv , & cm -> counts . mv ) ; <S2SV_EndBug>"
668,CWE-476,"static int add_push_report_sideband_pkt ( git_push * push , git_pkt_data * data_pkt , git_buf * data_pkt_buf ) { git_pkt * pkt ; const char * line , * line_end = NULL ; size_t line_len ; int error ; int reading_from_buf = data_pkt_buf -> size > 0 ; if ( reading_from_buf ) { git_buf_put ( data_pkt_buf , data_pkt -> data , data_pkt -> len ) ; line = data_pkt_buf -> ptr ; line_len = data_pkt_buf -> size ; } else { line = data_pkt -> data ; line_len = data_pkt -> len ; } while ( line_len > 0 ) { error = git_pkt_parse_line ( & pkt , line , & line_end , line_len ) ; if ( error == GIT_EBUFS ) { if ( ! reading_from_buf ) git_buf_put ( data_pkt_buf , line , line_len ) ; error = 0 ; goto done ; } else if ( error < 0 ) goto done ; line_len -= ( line_end - line ) ; line = line_end ; <S2SV_StartBug> if ( pkt == NULL ) <S2SV_EndBug> continue ; error = add_push_report_pkt ( push , pkt ) ; git_pkt_free ( pkt ) ; if ( error < 0 && error != GIT_ITEROVER ) goto done ; } error = 0 ; done : if ( reading_from_buf ) git_buf_consume ( data_pkt_buf , line_end ) ; return error ; }
","<S2SV_ModStart> = line_end ; <S2SV_ModEnd> error = add_push_report_pkt
",libgit2@libgit2/2fdef641fd0dd2828bd948234ae86de75221a11a,CVE-2016-10129,https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a,2017-03-24T15:59Z,<S2SV_StartBug> if ( pkt == NULL ) <S2SV_EndBug>
5601,CWE-674,"static krb5_error_code split_der ( asn1buf * buf , uint8_t * const * der , size_t len , taginfo * tag_out ) { krb5_error_code ret ; const uint8_t * contents , * remainder ; size_t clen , rlen ; <S2SV_StartBug> ret = get_tag ( * der , len , tag_out , & contents , & clen , & remainder , & rlen ) ; <S2SV_EndBug> if ( ret ) return ret ; if ( rlen != 0 ) return ASN1_BAD_LENGTH ; insert_bytes ( buf , contents , clen ) ; return 0 ; }
","<S2SV_ModStart> , & rlen , 0
",krb5@krb5/57415dda6cf04e73ffc3723be518eddfae599bfd,CVE-2020-28196,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,2020-11-06T08:15Z,"<S2SV_StartBug> ret = get_tag ( * der , len , tag_out , & contents , & clen , & remainder , & rlen ) ; <S2SV_EndBug>"
1185,CWE-59,"int main ( int argc , char * * argv ) { int fd = xopen ( ""/dev/null"" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( ""Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]"" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( ""CCpp.conf"" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , ""MakeCompatCore"" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""SaveBinaryImage"" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""VerboseLog"" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || pid <= 0 ) { perror_msg_and_die ( ""PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus"" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN ""/abrt/saved_core_pattern"" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } struct utsname uts ; if ( ! argv [ 8 ] ) { uname ( & uts ) ; argv [ 8 ] = uts . nodename ; } char path [ PATH_MAX ] ; int src_fd_binary = - 1 ; char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; if ( executable && strstr ( executable , ""/abrt-hook-ccpp"" ) ) { error_msg_and_die ( ""PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion"" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( ""user_pwd:\'%s\'"" , user_pwd ) ; sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ; proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) { fsuid = tmp_fsuid ; } } if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ; goto create_user_core ; } const char * signame = NULL ; switch ( signal_no ) { case SIGILL : signame = ""ILL"" ; break ; case SIGFPE : signame = ""FPE"" ; break ; case SIGSEGV : signame = ""SEGV"" ; break ; case SIGBUS : signame = ""BUS"" ; break ; case SIGABRT : signame = ""ABRT"" ; break ; case SIGTRAP : signame = ""TRAP"" ; break ; default : goto create_user_core ; } if ( ! daemon_is_ok ( ) ) { log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'"" ) ; goto create_user_core ; } if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ; } snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { goto create_user_core ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) { snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) ; int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; return 0 ; } unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) { goto create_user_core ; } dd = dd_create ( path , fsuid , DEFAULT_DUMP_DIR_MODE ) ; if ( dd ) { char * rootdir = get_rootdir ( pid ) ; <S2SV_StartBug> dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ; <S2SV_EndBug> char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , ""/proc/%lu/smaps"" , ( long ) pid ) ; source_base_ofs -= strlen ( ""smaps"" ) ; char * dest_filename = concat_path_file ( dd -> dd_dirname , ""also_somewhat_longish_name"" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , ""maps"" ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""limits"" ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( rootdir ) { if ( strcmp ( rootdir , ""/"" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } char * reason = xasprintf ( ""%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s"" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : """" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : """" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; if ( src_fd_binary > 0 ) { strcpy ( path + path_len , ""/"" FILENAME_BINARY ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd_binary ) ; } strcpy ( path + path_len , ""/"" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path ) ; off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; dd_delete ( dd ) ; if ( user_core_fd >= 0 ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } error_msg_and_die ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , path ) ; } if ( user_core_fd >= 0 && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || ( ulimit_c == 0 || core_size > ulimit_c ) ) ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } # if 0 { char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( ""%s/hs_err_pid%lu.log"" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , ""/hs_err.log"" ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd ) ; } } # endif dd_close ( dd ) ; path [ path_len ] = '\\0' ; char * newpath = xstrndup ( path , path_len - ( sizeof ( "".new"" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } free ( rootdir ) ; return 0 ; } create_user_core : if ( user_core_fd >= 0 ) { off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) { perror_msg ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , full_core_basename ) ; xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } if ( ulimit_c == 0 || core_size > ulimit_c ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , full_core_basename , ( long long ) core_size ) ; } return 0 ; }
","<S2SV_ModStart> , fsuid , <S2SV_ModEnd> NULL ) ;
",abrt@abrt/4f2c1ddd3e3b81d2d5146b883115371f1cada9f9,CVE-2015-3315,https://github.com/abrt/abrt/commit/4f2c1ddd3e3b81d2d5146b883115371f1cada9f9,2017-06-26T15:29Z,"<S2SV_StartBug> dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ; <S2SV_EndBug>"
5615,CWE-125,"void messageAddArgument ( message * m , const char * arg ) { int offset ; char * p ; assert ( m != NULL ) ; if ( arg == NULL ) return ; while ( isspace ( * arg ) ) arg ++ ; if ( * arg == '\\0' ) return ; cli_dbgmsg ( ""messageAddArgument,<S2SV_blank>arg=\'%s\'\\n"" , arg ) ; if ( ! usefulArg ( arg ) ) return ; for ( offset = 0 ; offset < m -> numberOfArguments ; offset ++ ) if ( m -> mimeArguments [ offset ] == NULL ) break ; else if ( strcasecmp ( arg , m -> mimeArguments [ offset ] ) == 0 ) return ; if ( offset == m -> numberOfArguments ) { char * * q ; m -> numberOfArguments ++ ; q = ( char * * ) cli_realloc ( m -> mimeArguments , m -> numberOfArguments * sizeof ( char * ) ) ; if ( q == NULL ) { m -> numberOfArguments -- ; return ; } m -> mimeArguments = q ; } p = m -> mimeArguments [ offset ] = rfc2231 ( arg ) ; if ( ! p ) { cli_dbgmsg ( ""messageAddArgument,<S2SV_blank>error<S2SV_blank>from<S2SV_blank>rfc2231()\\n"" ) ; return ; } if ( strchr ( p , '=' ) == NULL ) { if ( strncmp ( p , ""filename"" , 8 ) == 0 ) { <S2SV_StartBug> cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>fixed\\n"" ) ; <S2SV_EndBug> p [ 8 ] = '=' ; } else { <S2SV_StartBug> if ( * p ) <S2SV_EndBug> cli_dbgmsg ( ""messageAddArgument,<S2SV_blank>\'%s\'<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>\'=\'\\n"" , p ) ; free ( m -> mimeArguments [ offset ] ) ; m -> mimeArguments [ offset ] = NULL ; return ; } } if ( ( strncasecmp ( p , ""filename="" , 9 ) == 0 ) || ( strncasecmp ( p , ""name="" , 5 ) == 0 ) ) if ( messageGetMimeType ( m ) == NOMIME ) { cli_dbgmsg ( ""Force<S2SV_blank>mime<S2SV_blank>encoding<S2SV_blank>to<S2SV_blank>application\\n"" ) ; messageSetMimeType ( m , ""application"" ) ; } }
","<S2SV_ModStart> 0 ) { if ( strlen ( p ) > 8 ) { <S2SV_ModStart> } else { cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>not<S2SV_blank>fixed\\n"" ) ; } } else {
",vrtadmin@clamav-devel/586a5180287262070637c8943f2f7efd652e4a2c,CVE-2017-6418,https://github.com/vrtadmin/clamav-devel/commit/586a5180287262070637c8943f2f7efd652e4a2c,2017-08-07T03:29Z,"<S2SV_StartBug> cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>fixed\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * p ) <S2SV_EndBug>"
3595,CWE-476,"int build_segment_manager ( struct f2fs_sb_info * sbi ) { struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; struct f2fs_sm_info * sm_info ; int err ; sm_info = kzalloc ( sizeof ( struct f2fs_sm_info ) , GFP_KERNEL ) ; if ( ! sm_info ) return - ENOMEM ; sbi -> sm_info = sm_info ; sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ; sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ; sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ; sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ; sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ; sm_info -> rec_prefree_segments = sm_info -> main_segments * DEF_RECLAIM_PREFREE_SEGMENTS / 100 ; if ( sm_info -> rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS ) sm_info -> rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS ; if ( ! test_opt ( sbi , LFS ) ) sm_info -> ipu_policy = 1 << F2FS_IPU_FSYNC ; sm_info -> min_ipu_util = DEF_MIN_IPU_UTIL ; sm_info -> min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS ; sm_info -> min_hot_blocks = DEF_MIN_HOT_BLOCKS ; sm_info -> trim_sections = DEF_BATCHED_TRIM_SECTIONS ; INIT_LIST_HEAD ( & sm_info -> sit_entry_set ) ; <S2SV_StartBug> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <S2SV_EndBug> err = create_flush_cmd_control ( sbi ) ; if ( err ) return err ; } err = create_discard_cmd_control ( sbi ) ; if ( err ) return err ; err = build_sit_info ( sbi ) ; if ( err ) return err ; err = build_free_segmap ( sbi ) ; if ( err ) return err ; err = build_curseg ( sbi ) ; if ( err ) return err ; build_sit_entries ( sbi ) ; init_free_segmap ( sbi ) ; err = build_dirty_segmap ( sbi ) ; if ( err ) return err ; init_min_max_mtime ( sbi ) ; return 0 ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! f2fs_readonly (
",torvalds@linux/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,CVE-2017-18241,https://github.com/torvalds/linux/commit/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,2018-03-21T16:29Z,"<S2SV_StartBug> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <S2SV_EndBug>"
4111,CWE-416,"static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; <S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> -> device_data ; cancel_autoload_drivers ( ) ;
",torvalds@linux/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,CVE-2017-16528,https://github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,2017-11-04T01:29Z,<S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug>
3023,CWE-399,"static int misaligned_fpu_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo , bufhi ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } buflo = * ( __u32 * ) & buffer ; bufhi = * ( 1 + ( __u32 * ) & buffer ) ; switch ( width_shift ) { case 2 : current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; break ; case 3 : if ( do_paired_load ) { current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = bufhi ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = buflo ; # else current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; # endif } break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_fpu_load,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } return 0 ; } else { die ( ""Misaligned<S2SV_blank>FPU<S2SV_blank>load<S2SV_blank>inside<S2SV_blank>kernel"" , regs , 0 ) ; return - 1 ; } }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug>"
4467,CWE-125,"static void youngcollection ( lua_State * L , global_State * g ) { GCObject * * psurvival ; lua_assert ( g -> gcstate == GCSpropagate ) ; <S2SV_StartBug> markold ( g , g -> survival , g -> reallyold ) ; <S2SV_EndBug> markold ( g , g -> finobj , g -> finobjrold ) ; atomic ( L ) ; psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; sweepgen ( L , g , psurvival , g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L , g , & g -> finobj , g -> finobjsur ) ; sweepgen ( L , g , psurvival , g -> finobjrold ) ; g -> finobjrold = g -> finobjold ; g -> finobjold = * psurvival ; g -> finobjsur = g -> finobj ; sweepgen ( L , g , & g -> tobefnz , NULL ) ; finishgencycle ( L , g ) ; }
","<S2SV_ModStart> , g -> allgc <S2SV_ModEnd> , g ->
",lua@lua/127e7a6c8942b362aa3c6627f44d660a4fb75312,CVE-2020-15889,https://github.com/lua/lua/commit/127e7a6c8942b362aa3c6627f44d660a4fb75312,2020-07-21T22:15Z,"<S2SV_StartBug> markold ( g , g -> survival , g -> reallyold ) ; <S2SV_EndBug>"
6525,CWE-119,"<S2SV_StartBug> cJSON * cJSON_CreateIntArray ( int64_t * numbers , int count ) <S2SV_EndBug> { int i ; cJSON * n = 0 , * p = 0 , * a = cJSON_CreateArray ( ) ; <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> n = cJSON_CreateInt ( numbers [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug> a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }
","<S2SV_ModStart> * cJSON_CreateIntArray ( const int <S2SV_ModEnd> * numbers , <S2SV_ModStart> < count ; i ++ <S2SV_ModEnd> ) { n <S2SV_ModStart> { n = cJSON_CreateNumber <S2SV_ModEnd> ( numbers [ <S2SV_ModStart> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,"<S2SV_StartBug> cJSON * cJSON_CreateIntArray ( int64_t * numbers , int count ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> n = cJSON_CreateInt ( numbers [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug>"
377,CWE-125,"void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u"" , dp -> icmp_type == ICMP_ECHO ? ""request"" : ""reply"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%u<S2SV_blank>port<S2SV_blank>%u<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , ""#%d<S2SV_blank>%%s<S2SV_blank>unreachable"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , ""redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , ""router<S2SV_blank>advertisement"" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , ""<S2SV_blank>lifetime<S2SV_blank>"" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u"" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u"" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u:%02u"" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>%d:"" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>[size<S2SV_blank>%d]"" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>{%s<S2SV_blank>%u}"" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = ""time<S2SV_blank>exceeded<S2SV_blank>in-transit"" ; break ; case ICMP_TIMXCEED_REASS : str = ""ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded"" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>exceeded-#%u"" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%u"" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>recv<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>xmit<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , ""type-#%d"" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , ""ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { if ( ND_TTEST2 ( * bp , plen ) ) { uint16_t sum ; vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ; <S2SV_StartBug> if ( sum != 0 ) { <S2SV_EndBug> uint16_t icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)"" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; ip = ( const struct ip * ) bp ; ndo -> ndo_snaplen = ndo -> ndo_snapend - bp ; snapend_save = ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len ) ; ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ; if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , ""\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u"" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? ""in"" : """" , hlen ) ) ; } hlen -= 4 ; obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( icmp_mpls_ext_obj_values , ""unknown"" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u"" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp]"" ) ) ; }
","<S2SV_ModStart> 0 ) { ND_TCHECK_16BITS ( & dp -> icmp_cksum ) ;
",the-tcpdump-group@tcpdump/1a1bce0526a77b62e41531b00f8bb5e21fd4f3a3,CVE-2018-14462,https://github.com/the-tcpdump-group/tcpdump/commit/1a1bce0526a77b62e41531b00f8bb5e21fd4f3a3,2019-10-03T16:15Z,<S2SV_StartBug> if ( sum != 0 ) { <S2SV_EndBug>
2628,CWE-000,"static struct sk_buff * xfrm_state_netlink ( struct sk_buff * in_skb , struct xfrm_state * x , u32 seq ) { struct xfrm_dump_info info ; <S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) return ERR_PTR ( - ENOMEM ) ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = seq ; info . nlmsg_flags = 0 ; <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> kfree_skb ( skb ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } return skb ; }
","<S2SV_ModStart> sk_buff * skb ; int err <S2SV_ModStart> = 0 ; err = <S2SV_ModEnd> dump_one_state ( x <S2SV_ModStart> & info ) ; if ( err <S2SV_ModStart> ) ; return ERR_PTR ( err ) <S2SV_ModEnd> ; } return
",torvalds@linux/864745d291b5ba80ea0bd0edcbe67273de368836,CVE-2013-1826,https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836,2013-03-22T11:59Z,"<S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug>"
621,CWE-125,"static void r_bin_dwarf_dump_debug_info ( FILE * f , const RBinDwarfDebugInfo * inf ) { size_t i , j , k ; RBinDwarfDIE * dies ; RBinDwarfAttrValue * values ; if ( ! inf || ! f ) { return ; } for ( i = 0 ; i < inf -> length ; i ++ ) { fprintf ( f , ""<S2SV_blank><S2SV_blank>Compilation<S2SV_blank>Unit<S2SV_blank>@<S2SV_blank>offset<S2SV_blank>0x%"" PFMT64x "":\\n"" , inf -> comp_units [ i ] . offset ) ; fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank>Length:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x\\n"" , inf -> comp_units [ i ] . hdr . length ) ; fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank>Version:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , inf -> comp_units [ i ] . hdr . version ) ; fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank>Abbrev<S2SV_blank>Offset:<S2SV_blank>0x%x\\n"" , inf -> comp_units [ i ] . hdr . abbrev_offset ) ; fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank>Pointer<S2SV_blank>Size:<S2SV_blank><S2SV_blank>%d\\n"" , inf -> comp_units [ i ] . hdr . pointer_size ) ; dies = inf -> comp_units [ i ] . dies ; for ( j = 0 ; j < inf -> comp_units [ i ] . length ; j ++ ) { fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Abbrev<S2SV_blank>Number:<S2SV_blank>%"" PFMT64u ""<S2SV_blank>"" , dies [ j ] . abbrev_code ) ; if ( dies [ j ] . tag && dies [ j ] . tag <= DW_TAG_volatile_type && dwarf_tag_name_encodings [ dies [ j ] . tag ] ) { fprintf ( f , ""(%s)\\n"" , dwarf_tag_name_encodings [ dies [ j ] . tag ] ) ; } else { fprintf ( f , ""(Unknown<S2SV_blank>abbrev<S2SV_blank>tag)\\n"" ) ; } if ( ! dies [ j ] . abbrev_code ) { continue ; } values = dies [ j ] . attr_values ; for ( k = 0 ; k < dies [ j ] . length ; k ++ ) { <S2SV_StartBug> if ( ! values [ k ] . name ) <S2SV_EndBug> continue ; if ( values [ k ] . name < DW_AT_vtable_elem_location && dwarf_attr_encodings [ values [ k ] . name ] ) { fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-18s<S2SV_blank>:<S2SV_blank>"" , dwarf_attr_encodings [ values [ k ] . name ] ) ; } else { fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TODO\\t"" ) ; } r_bin_dwarf_dump_attr_value ( & values [ k ] , f ) ; fprintf ( f , ""\\n"" ) ; } } } }
","<S2SV_ModStart> . name ) { continue ; } <S2SV_ModEnd> if ( values
",radare@radare2/2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d,CVE-2017-16805,https://github.com/radare/radare2/commit/2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d,2017-11-13T21:29Z,<S2SV_StartBug> if ( ! values [ k ] . name ) <S2SV_EndBug>
900,CWE-200,"void rds_inc_info_copy ( struct rds_incoming * inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) { struct rds_info_message minfo ; minfo . seq = be64_to_cpu ( inc -> i_hdr . h_sequence ) ; minfo . len = be32_to_cpu ( inc -> i_hdr . h_len ) ; if ( flip ) { minfo . laddr = daddr ; minfo . faddr = saddr ; minfo . lport = inc -> i_hdr . h_dport ; minfo . fport = inc -> i_hdr . h_sport ; } else { minfo . laddr = saddr ; minfo . faddr = daddr ; minfo . lport = inc -> i_hdr . h_sport ; minfo . fport = inc -> i_hdr . h_dport ; } <S2SV_StartBug> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> h_dport ; } minfo . flags = 0 ;
",torvalds@linux/4116def2337991b39919f3b448326e21c40e0dbb,CVE-2016-5244,https://github.com/torvalds/linux/commit/4116def2337991b39919f3b448326e21c40e0dbb,2016-06-27T10:59Z,"<S2SV_StartBug> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <S2SV_EndBug>"
4648,CWE-190,"static int mongo_cursor_get_more ( mongo_cursor * cursor ) { int res ; if ( cursor -> limit > 0 && cursor -> seen >= cursor -> limit ) { cursor -> err = MONGO_CURSOR_EXHAUSTED ; return MONGO_ERROR ; } else if ( ! cursor -> reply ) { cursor -> err = MONGO_CURSOR_INVALID ; return MONGO_ERROR ; } else if ( ! cursor -> reply -> fields . cursorID ) { cursor -> err = MONGO_CURSOR_EXHAUSTED ; return MONGO_ERROR ; } else { char * data ; <S2SV_StartBug> int sl = strlen ( cursor -> ns ) + 1 ; <S2SV_EndBug> int limit = 0 ; mongo_message * mm ; if ( cursor -> limit > 0 ) limit = cursor -> limit - cursor -> seen ; mm = mongo_message_create ( 16 + 4 + sl + 4 + 8 , 0 , 0 , MONGO_OP_GET_MORE ) ; data = & mm -> data ; data = mongo_data_append32 ( data , & ZERO ) ; data = mongo_data_append ( data , cursor -> ns , sl ) ; data = mongo_data_append32 ( data , & limit ) ; mongo_data_append64 ( data , & cursor -> reply -> fields . cursorID ) ; bson_free ( cursor -> reply ) ; res = mongo_message_send ( cursor -> conn , mm ) ; if ( res != MONGO_OK ) { mongo_cursor_destroy ( cursor ) ; return MONGO_ERROR ; } res = mongo_read_response ( cursor -> conn , & ( cursor -> reply ) ) ; if ( res != MONGO_OK ) { mongo_cursor_destroy ( cursor ) ; return MONGO_ERROR ; } cursor -> current . data = NULL ; cursor -> seen += cursor -> reply -> fields . num ; return MONGO_OK ; } }
","<S2SV_ModStart> * data ; size_t <S2SV_ModEnd> sl = strlen
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,<S2SV_StartBug> int sl = strlen ( cursor -> ns ) + 1 ; <S2SV_EndBug>
2863,CWE-000,"asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) <S2SV_StartBug> { <S2SV_EndBug> console_verbose ( ) ; pr_crit ( ""Bad<S2SV_blank>mode<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>handler<S2SV_blank>detected,<S2SV_blank>code<S2SV_blank>0x%08x\\n"" , handler [ reason ] , esr ) ; <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug> local_irq_disable ( ) ; panic ( ""bad<S2SV_blank>mode"" ) ; }
","<S2SV_ModStart> esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , <S2SV_ModStart> , regs , & info , 0 <S2SV_ModEnd> ) ; }
",torvalds@linux/9955ac47f4ba1c95ecb6092aeaefb40a22e99268,CVE-2013-4220,https://github.com/torvalds/linux/commit/9955ac47f4ba1c95ecb6092aeaefb40a22e99268,2013-08-25T03:27Z,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug>"
2336,CWE-119,"TEE_Result syscall_asymm_operate ( unsigned long state , const struct utee_attribute * usr_params , size_t num_params , const void * src_data , size_t src_len , void * dst_data , uint64_t * dst_len ) { TEE_Result res ; struct tee_cryp_state * cs ; struct tee_ta_session * sess ; uint64_t dlen64 ; size_t dlen ; struct tee_obj * o ; void * label = NULL ; size_t label_len = 0 ; size_t n ; int salt_len ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) src_data , src_len ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_svc_copy_from_user ( & dlen64 , dst_len , sizeof ( dlen64 ) ) ; if ( res != TEE_SUCCESS ) return res ; dlen = dlen64 ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) dst_data , dlen ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , num_params , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & o ) ; if ( res != TEE_SUCCESS ) goto out ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { res = TEE_ERROR_GENERIC ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_RSA_NOPAD : if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsanopad_encrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsanopad_decrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_GENERIC ; } break ; case TEE_ALG_RSAES_PKCS1_V1_5 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512 : for ( n = 0 ; n < num_params ; n ++ ) { if ( params [ n ] . attributeID == TEE_ATTR_RSA_OAEP_LABEL ) { label = params [ n ] . content . ref . buffer ; label_len = params [ n ] . content . ref . length ; break ; } } if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsaes_encrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsaes_decrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_BAD_PARAMETERS ; } break ; # if defined ( CFG_CRYPTO_RSASSA_NA1 ) case TEE_ALG_RSASSA_PKCS1_V1_5 : # endif case TEE_ALG_RSASSA_PKCS1_V1_5_MD5 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512 : if ( cs -> mode != TEE_MODE_SIGN ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } salt_len = pkcs1_get_salt_len ( params , num_params , src_len ) ; res = crypto_acipher_rsassa_sign ( cs -> algo , o -> attr , salt_len , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_DSA_SHA1 : case TEE_ALG_DSA_SHA224 : case TEE_ALG_DSA_SHA256 : res = crypto_acipher_dsa_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_ECDSA_P192 : case TEE_ALG_ECDSA_P224 : case TEE_ALG_ECDSA_P256 : case TEE_ALG_ECDSA_P384 : case TEE_ALG_ECDSA_P521 : res = crypto_acipher_ecc_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; default : res = TEE_ERROR_BAD_PARAMETERS ; break ; } out : free ( params ) ; if ( res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER ) { TEE_Result res2 ; dlen64 = dlen ; res2 = tee_svc_copy_to_user ( dst_len , & dlen64 , sizeof ( * dst_len ) ) ; if ( res2 != TEE_SUCCESS ) return res2 ; } return res ; }
","<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
",OP-TEE@optee_os/70697bf3c5dc3d201341b01a1a8e5bc6d2fb48f8,CVE-2019-1010298,https://github.com/OP-TEE/optee_os/commit/70697bf3c5dc3d201341b01a1a8e5bc6d2fb48f8,2019-07-15T18:15Z,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug>
2853,CWE-119,"static __forceinline void draw_line ( float * output , int x0 , int y0 , int x1 , int y1 , int n ) { int dy = y1 - y0 ; int adx = x1 - x0 ; int ady = abs ( dy ) ; int base ; int x = x0 , y = y0 ; int err = 0 ; int sy ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( adx < DIVTAB_DENOM && ady < DIVTAB_NUMER ) { if ( dy < 0 ) { base = - integer_divide_table [ ady ] [ adx ] ; sy = base - 1 ; } else { base = integer_divide_table [ ady ] [ adx ] ; sy = base + 1 ; } } else { base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; } # else base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; # endif ady -= abs ( base ) * adx ; if ( x1 > n ) x1 = n ; if ( x < x1 ) { <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> for ( ++ x ; x < x1 ; ++ x ) { err += ady ; if ( err >= adx ) { err -= adx ; y += sy ; } else y += base ; <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> } } }
","<S2SV_ModStart> inverse_db_table [ y & 255 <S2SV_ModStart> inverse_db_table [ y & 255
",nothings@stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,CVE-2019-13217,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,2019-08-15T17:15Z,"<S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug>"
3956,CWE-17,"static ssize_t <S2SV_StartBug> pipe_write ( struct kiocb * iocb , const struct iovec * _iov , <S2SV_EndBug> unsigned long nr_segs , loff_t ppos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> <S2SV_StartBug> int do_wakeup ; <S2SV_EndBug> struct iovec * iov = ( struct iovec * ) _iov ; <S2SV_StartBug> size_t total_len ; <S2SV_EndBug> ssize_t chars ; <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> if ( unlikely ( total_len == 0 ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; if ( ! pipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; ret = - EPIPE ; goto out ; } chars = total_len & ( PAGE_SIZE - 1 ) ; if ( pipe -> nrbufs && chars != 0 ) { int lastbuf = ( pipe -> curbuf + pipe -> nrbufs - 1 ) & ( pipe -> buffers - 1 ) ; struct pipe_buffer * buf = pipe -> bufs + lastbuf ; const struct pipe_buf_operations * ops = buf -> ops ; int offset = buf -> offset + buf -> len ; if ( ops -> can_merge && offset + chars <= PAGE_SIZE ) { <S2SV_StartBug> int error , atomic = 1 ; <S2SV_EndBug> void * addr ; error = ops -> confirm ( pipe , buf ) ; if ( error ) goto out ; <S2SV_StartBug> iov_fault_in_pages_read ( iov , chars ) ; <S2SV_EndBug> redo1 : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_from_user ( offset + addr , iov , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; ret = error ; do_wakeup = 1 ; if ( error ) { if ( atomic ) { atomic = 0 ; goto redo1 ; } goto out ; <S2SV_StartBug> } <S2SV_EndBug> buf -> len += chars ; <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> ret = chars ; if ( ! total_len ) goto out ; } } for ( ; ; ) { int bufs ; if ( ! pipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } bufs = pipe -> nrbufs ; if ( bufs < pipe -> buffers ) { int newbuf = ( pipe -> curbuf + bufs ) & ( pipe -> buffers - 1 ) ; struct pipe_buffer * buf = pipe -> bufs + newbuf ; struct page * page = pipe -> tmp_page ; <S2SV_StartBug> char * src ; <S2SV_EndBug> int error , atomic = 1 ; if ( ! page ) { page = alloc_page ( GFP_HIGHUSER ) ; if ( unlikely ( ! page ) ) { ret = ret ? : - ENOMEM ; break ; } pipe -> tmp_page = page ; } do_wakeup = 1 ; <S2SV_StartBug> chars = PAGE_SIZE ; <S2SV_EndBug> if ( chars > total_len ) chars = total_len ; iov_fault_in_pages_read ( iov , chars ) ; redo2 : if ( atomic ) src = kmap_atomic ( page ) ; else src = kmap ( page ) ; error = pipe_iov_copy_from_user ( src , iov , chars , atomic ) ; if ( atomic ) kunmap_atomic ( src ) ; else kunmap ( page ) ; <S2SV_StartBug> if ( unlikely ( error ) ) { <S2SV_EndBug> if ( atomic ) { atomic = 0 ; goto redo2 ; } if ( ! ret ) ret = error ; break ; } <S2SV_StartBug> ret += chars ; <S2SV_EndBug> buf -> page = page ; buf -> ops = & anon_pipe_buf_ops ; buf -> offset = 0 ; <S2SV_StartBug> buf -> len = chars ; <S2SV_EndBug> buf -> flags = 0 ; if ( is_packetized ( filp ) ) { buf -> ops = & packet_pipe_buf_ops ; buf -> flags = PIPE_BUF_FLAG_PACKET ; } pipe -> nrbufs = ++ bufs ; pipe -> tmp_page = NULL ; <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> if ( ! total_len ) break ; } if ( bufs < pipe -> buffers ) continue ; if ( filp -> f_flags & O_NONBLOCK ) { if ( ! ret ) ret = - EAGAIN ; break ; } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - ERESTARTSYS ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; do_wakeup = 0 ; } pipe -> waiting_writers ++ ; pipe_wait ( pipe ) ; pipe -> waiting_writers -- ; } out : __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; } if ( ret > 0 && sb_start_write_trylock ( file_inode ( filp ) -> i_sb ) ) { int err = file_update_time ( filp ) ; if ( err ) ret = err ; sb_end_write ( file_inode ( filp ) -> i_sb ) ; } return ret ; }
","<S2SV_ModStart> * iocb , struct iov_iter * from <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; ssize_t ret = 0 <S2SV_ModStart> ; int do_wakeup = 0 <S2SV_ModEnd> ; size_t total_len <S2SV_ModStart> ; size_t total_len = iov_iter_count ( from ) <S2SV_ModStart> ssize_t chars ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> ) ) return <S2SV_ModEnd> 0 ; __pipe_lock <S2SV_ModStart> { int error <S2SV_ModEnd> = ops -> <S2SV_ModStart> goto out ; ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } do_wakeup = 1 ; <S2SV_ModStart> += chars ; ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> -> tmp_page ; int copied <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 1 ; copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ; <S2SV_ModStart> } ret += copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> len = copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> = NULL ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) break ;
",torvalds@linux/f0d1bec9d58d4c038d0ac958c9af82be6eb18045,CVE-2015-1805,https://github.com/torvalds/linux/commit/f0d1bec9d58d4c038d0ac958c9af82be6eb18045,2015-08-08T10:59Z,"<S2SV_StartBug> pipe_write ( struct kiocb * iocb , const struct iovec * _iov , <S2SV_EndBug> <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> <S2SV_StartBug> int do_wakeup ; <S2SV_EndBug> <S2SV_StartBug> size_t total_len ; <S2SV_EndBug> <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic = 1 ; <S2SV_EndBug> <S2SV_StartBug> iov_fault_in_pages_read ( iov , chars ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> <S2SV_StartBug> char * src ; <S2SV_EndBug> <S2SV_StartBug> chars = PAGE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( error ) ) { <S2SV_EndBug> <S2SV_StartBug> ret += chars ; <S2SV_EndBug> <S2SV_StartBug> buf -> len = chars ; <S2SV_EndBug> <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug>"
902,CWE-000,"static int ras_getdatastd ( jas_stream_t * in , ras_hdr_t * hdr , ras_cmap_t * cmap , jas_image_t * image ) { int pad ; int nz ; int z ; int c ; int y ; int x ; int v ; int i ; jas_matrix_t * data [ 3 ] ; cmap = 0 ; <S2SV_StartBug> for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ; <S2SV_EndBug> assert ( data [ i ] ) ; } pad = RAS_ROWSIZE ( hdr ) - ( hdr -> width * hdr -> depth + 7 ) / 8 ; for ( y = 0 ; y < hdr -> height ; y ++ ) { nz = 0 ; z = 0 ; for ( x = 0 ; x < hdr -> width ; x ++ ) { while ( nz < hdr -> depth ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> z = ( z << 8 ) | c ; <S2SV_EndBug> nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { return - 1 ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; } return 0 ; }
","<S2SV_ModStart> = 0 ; assert ( <S2SV_ModEnd> jas_image_numcmpts ( image <S2SV_ModStart> ( image ) <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( ! ( <S2SV_ModEnd> data [ i <S2SV_ModStart> image ) ) ) ) { goto error ; } <S2SV_ModEnd> } pad = <S2SV_ModStart> EOF ) { goto error ; } z = ( z << 8 ) | c ; nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { goto error ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < 3 ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",mdadams@jasper/411a4068f8c464e883358bf403a3e25158863823,CVE-2016-9388,https://github.com/mdadams/jasper/commit/411a4068f8c464e883358bf403a3e25158863823,2017-03-23T18:59Z,"<S2SV_StartBug> for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> z = ( z << 8 ) | c ; <S2SV_EndBug>"
5706,CWE-269,"void virtio_config_writeb ( VirtIODevice * vdev , uint32_t addr , uint32_t data ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint8_t val = data ; <S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> return ; stb_p ( vdev -> config + addr , val ) ; if ( k -> set_config ) { k -> set_config ( vdev , vdev -> config ) ; } }
","<S2SV_ModStart> if ( addr + <S2SV_ModEnd> sizeof ( val <S2SV_ModStart> ( val ) > vdev -> config_len ) { return ; } <S2SV_ModEnd> stb_p ( vdev
",qemu@qemu/5f5a1318653c08e435cfa52f60b6a712815b659d,CVE-2013-2016,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,2019-12-30T22:15Z,<S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug>
2925,CWE-119,"static void cliRefreshPrompt ( void ) { <S2SV_StartBug> int len ; <S2SV_EndBug> if ( config . eval_ldb ) return ; <S2SV_StartBug> if ( config . hostsocket != NULL ) <S2SV_EndBug> <S2SV_StartBug> len = snprintf ( config . prompt , sizeof ( config . prompt ) , ""redis<S2SV_blank>%s"" , <S2SV_EndBug> config . hostsocket ) ; else len = anetFormatAddr ( config . prompt , sizeof ( config . prompt ) , config . hostip , config . hostport ) ; if ( config . dbnum != 0 ) len += snprintf ( config . prompt + len , sizeof ( config . prompt ) - len , ""[%d]"" , config . dbnum ) ; snprintf ( config . prompt + len , sizeof ( config . prompt ) - len , ""><S2SV_blank>"" ) ; }
","<S2SV_ModStart> void ) { <S2SV_ModEnd> if ( config <S2SV_ModStart> ) return ; sds prompt = sdsempty ( ) ; <S2SV_ModStart> != NULL ) { prompt = sdscatfmt ( prompt , ""redis<S2SV_blank>%s"" , config . hostsocket ) ; } else { char addr [ 256 ] ; anetFormatAddr ( addr , sizeof ( addr ) , config . hostip , config . hostport ) ; prompt = sdscatlen ( prompt , addr , strlen ( addr ) ) ; } if ( config . dbnum != 0 ) prompt = sdscatfmt ( prompt , ""[%i]"" , config . dbnum ) ; prompt = sdscatlen ( prompt , ""><S2SV_blank>"" , 2 ) ; <S2SV_ModEnd> snprintf ( config <S2SV_ModStart> prompt ) , ""%s"" , prompt ) ; sdsfree ( prompt <S2SV_ModEnd> ) ; }
",antirez@redis/9fdcc15962f9ff4baebe6fdd947816f43f730d50,CVE-2018-12326,https://github.com/antirez/redis/commit/9fdcc15962f9ff4baebe6fdd947816f43f730d50,2018-06-17T14:29Z,"<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> if ( config . hostsocket != NULL ) <S2SV_EndBug> <S2SV_StartBug> len = snprintf ( config . prompt , sizeof ( config . prompt ) , ""redis<S2SV_blank>%s"" , <S2SV_EndBug>"
4293,CWE-362,"evtchn_port_t evtchn_from_irq ( unsigned irq ) { <S2SV_StartBug> if ( WARN ( irq >= nr_irqs , ""Invalid<S2SV_blank>irq<S2SV_blank>%d!\\n"" , irq ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> return info_for_irq ( irq ) -> evtchn ; <S2SV_EndBug> }
","<S2SV_ModStart> irq ) { const struct irq_info * info = NULL ; if ( likely ( irq < nr_irqs ) ) info = info_for_irq ( irq ) ; if ( ! info <S2SV_ModEnd> ) return 0 <S2SV_ModStart> 0 ; return info <S2SV_ModEnd> -> evtchn ;
",torvalds@linux/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,CVE-2020-27675,https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,2020-10-22T21:15Z,"<S2SV_StartBug> if ( WARN ( irq >= nr_irqs , ""Invalid<S2SV_blank>irq<S2SV_blank>%d!\\n"" , irq ) ) <S2SV_EndBug> <S2SV_StartBug> return info_for_irq ( irq ) -> evtchn ; <S2SV_EndBug>"
3769,CWE-90,"kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_timestamp now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; if ( entry == NULL ) return EINVAL ; if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = calloc ( 1 , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = ts_incr ( now , polent . pw_max_life ) ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; ret = krb5_copy_principal ( handle -> context , entry -> principal , & kdb -> princ ) ; if ( ret ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }
","<S2SV_ModStart> return KADM5_BAD_MASK ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } }
",krb5@krb5/e1caf6fb74981da62039846931ebdffed71309d1,CVE-2018-5730,https://github.com/krb5/krb5/commit/e1caf6fb74981da62039846931ebdffed71309d1,2018-03-06T20:29Z,<S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug>
3078,CWE-674,"static int bgp_attr_print ( netdissect_options * ndo , <S2SV_StartBug> u_int atype , const u_char * pptr , u_int len ) <S2SV_EndBug> { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) <S2SV_EndBug> return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }
","<S2SV_ModStart> , u_int len , const unsigned attr_set_level <S2SV_ModStart> } if ( attr_set_level == 10 ) ND_PRINT ( ( ndo , ""(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)"" ) ) ; else if ( <S2SV_ModStart> tptr , alen , attr_set_level + 1
",the-tcpdump-group@tcpdump/af2cf04a9394c1a56227c2289ae8da262828294a,CVE-2018-16300,https://github.com/the-tcpdump-group/tcpdump/commit/af2cf04a9394c1a56227c2289ae8da262828294a,2019-10-03T16:15Z,"<S2SV_StartBug> u_int atype , const u_char * pptr , u_int len ) <S2SV_EndBug> <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) <S2SV_EndBug>"
1221,CWE-436,"static void flatpak_proxy_client_init ( FlatpakProxyClient * client ) { init_side ( client , & client -> client_side ) ; init_side ( client , & client -> bus_side ) ; <S2SV_StartBug> client -> auth_end_offset = AUTH_END_INIT_OFFSET ; <S2SV_EndBug> client -> rewrite_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_object_unref ) ; client -> get_owner_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_free ) ; client -> unique_id_policy = g_hash_table_new_full ( g_str_hash , g_str_equal , g_free , NULL ) ; }
","<S2SV_ModStart> ; client -> auth_buffer = g_byte_array_new ( ) <S2SV_ModEnd> ; client ->
",flatpak@flatpak/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6,CVE-2018-6560,https://github.com/flatpak/flatpak/commit/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6,2018-02-02T14:29Z,<S2SV_StartBug> client -> auth_end_offset = AUTH_END_INIT_OFFSET ; <S2SV_EndBug>
1159,CWE-119,"static RD_BOOL mcs_recv_connect_response ( STREAM mcs_data ) { UNUSED ( mcs_data ) ; uint8 result ; <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( Protocol , Debug , ""%s()"" , __func__ ) ; s = iso_recv ( & is_fastpath , & fastpath_hdr ) ; if ( s == NULL ) return False ; <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_RESULT , & length ) ; in_uint8 ( s , result ) ; if ( result != 0 ) { logger ( Protocol , Error , ""mcs_recv_connect_response(),<S2SV_blank>result=%d"" , result ) ; return False ; } ber_parse_header ( s , BER_TAG_INTEGER , & length ) ; in_uint8s ( s , length ) ; <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ; sec_process_mcs_data ( s ) ; return s_check_end ( s ) ; }
","<S2SV_ModStart> uint8 result ; uint32 <S2SV_ModEnd> length ; STREAM <S2SV_ModStart> ; STREAM s ; struct stream packet <S2SV_ModStart> return False ; packet = * s ; <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-20182,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-03-15T18:29Z,"<S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug>"
3467,CWE-399,"static int cms_copy_content ( BIO * out , BIO * in , unsigned int flags ) { unsigned char buf [ 4096 ] ; int r = 0 , i ; <S2SV_StartBug> BIO * tmpout = NULL ; <S2SV_EndBug> if ( out == NULL ) tmpout = BIO_new ( BIO_s_null ( ) ) ; else if ( flags & CMS_TEXT ) { <S2SV_StartBug> tmpout = BIO_new ( BIO_s_mem ( ) ) ; <S2SV_EndBug> BIO_set_mem_eof_return ( tmpout , 0 ) ; } else tmpout = out ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } r = 1 ; err : if ( tmpout && ( tmpout != out ) ) BIO_free ( tmpout ) ; return r ; }
","<S2SV_ModStart> BIO * tmpout ; tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } <S2SV_ModEnd> if ( flags <S2SV_ModStart> CMS_TEXT ) { <S2SV_ModEnd> if ( !
",openssl@openssl/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,CVE-2015-1792,https://github.com/openssl/openssl/commit/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,2015-06-12T19:59Z,<S2SV_StartBug> BIO * tmpout = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmpout = BIO_new ( BIO_s_mem ( ) ) ; <S2SV_EndBug>
2609,CWE-125,"u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int hdrlen ; uint16_t fc ; uint8_t seq ; uint16_t panid = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; <S2SV_EndBug> p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; case FC_ADDRESSING_MODE_SHORT : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; return hdrlen ; }
","<S2SV_ModStart> EXTRACT_LE_16BITS ( p <S2SV_ModEnd> ) ) )
",the-tcpdump-group@tcpdump/8512734883227c11568bb35da1d48b9f8466f43f,CVE-2017-13000,https://github.com/the-tcpdump-group/tcpdump/commit/8512734883227c11568bb35da1d48b9f8466f43f,2017-09-14T06:29Z,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; <S2SV_EndBug>"
178,CWE-200,"WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; UNUSED ( u1_is_idr_slice ) ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( num_mb_skip & 1 ) ) { num_mb_skip ++ ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = - 1 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) { if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) { if ( ps_dec -> ps_pps [ i ] . ps_sps -> u1_is_valid == TRUE ) { j = i ; break ; } } } if ( j == - 1 ) { return ERROR_INV_SLICE_HDR_T ; } if ( ps_dec -> u4_pic_buf_got == 0 ) { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } <S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_EndBug> } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { if ( ( u1_mbaff ) && ( ps_dec -> u4_num_mbs_cur_nmb & 1 ) ) { ps_dec -> u4_num_mbs_cur_nmb = ps_dec -> u4_num_mbs_cur_nmb - 1 ; ps_dec -> u2_cur_mb_addr -- ; } u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; if ( u1_num_mbs ) { ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } if ( ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice < ( UWORD32 ) ( ps_dec -> u2_total_mbs_coded >> ps_slice -> u1_mbaff_frame_flag ) ) { ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> ps_parse_cur_slice ++ ; } } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= u1_mbaff ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> } } } <S2SV_ModEnd> } else {
",external@libavc/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,CVE-2017-0555,https://android.googlesource.com/platform/external/libavc/+/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,2017-04-07T22:59Z,<S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_EndBug>
4523,CWE-125,"PyObject * ast2obj_alias ( void * _o ) { alias_ty o = ( alias_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( alias_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> asname ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_asname , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug>
1537,CWE-119,"void vp9_print_modes_and_motion_vectors ( VP9_COMMON * cm , const char * file ) { int mi_row ; int mi_col ; <S2SV_StartBug> int mi_index = 0 ; <S2SV_EndBug> FILE * mvs = fopen ( file , ""a"" ) ; <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ; <S2SV_EndBug> int rows = cm -> mi_rows ; int cols = cm -> mi_cols ; print_mi_data ( cm , mvs , ""Partitions:"" , offsetof ( MB_MODE_INFO , sb_type ) ) ; print_mi_data ( cm , mvs , ""Modes:"" , offsetof ( MB_MODE_INFO , mode ) ) ; <S2SV_StartBug> print_mi_data ( cm , mvs , ""Skips:"" , offsetof ( MB_MODE_INFO , skip ) ) ; <S2SV_EndBug> print_mi_data ( cm , mvs , ""Ref<S2SV_blank>frame:"" , offsetof ( MB_MODE_INFO , ref_frame [ 0 ] ) ) ; print_mi_data ( cm , mvs , ""Transform:"" , offsetof ( MB_MODE_INFO , tx_size ) ) ; print_mi_data ( cm , mvs , ""UV<S2SV_blank>Modes:"" , offsetof ( MB_MODE_INFO , uv_mode ) ) ; log_frame_info ( cm , ""Vectors<S2SV_blank>"" , mvs ) ; for ( mi_row = 0 ; mi_row < rows ; mi_row ++ ) { <S2SV_StartBug> fprintf ( mvs , ""V<S2SV_blank>"" ) ; <S2SV_EndBug> for ( mi_col = 0 ; mi_col < cols ; mi_col ++ ) { <S2SV_StartBug> fprintf ( mvs , ""%4d:%4d<S2SV_blank>"" , mi_8x8 [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row , <S2SV_EndBug> mi_8x8 [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . col ) ; mi_index ++ ; } fprintf ( mvs , ""\\n"" ) ; <S2SV_StartBug> mi_index += 8 ; <S2SV_EndBug> } fprintf ( mvs , ""\\n"" ) ; <S2SV_StartBug> fclose ( mvs ) ; <S2SV_EndBug> }
","<S2SV_ModStart> int mi_col ; <S2SV_ModEnd> FILE * mvs <S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> = cm -> <S2SV_ModStart> , mvs , ""Ref<S2SV_blank>frame:"" , offsetof ( MB_MODE_INFO , ref_frame [ 0 ] ) ) ; print_mi_data ( cm , mvs , ""Transform:"" , offsetof ( MB_MODE_INFO , tx_size ) ) ; print_mi_data ( cm , mvs , ""UV<S2SV_blank>Modes:"" , offsetof ( MB_MODE_INFO , uv_mode ) ) ; log_frame_info ( cm , ""Skips:"" <S2SV_ModEnd> , mvs ) <S2SV_ModStart> ( mvs , ""S<S2SV_blank>"" <S2SV_ModEnd> ) ; for <S2SV_ModStart> ( mvs , ""%2d<S2SV_blank>"" , mi [ 0 <S2SV_ModEnd> ] -> mbmi <S2SV_ModStart> -> mbmi . skip ) ; mi <S2SV_ModEnd> ++ ; } <S2SV_ModStart> ""\\n"" ) ; mi <S2SV_ModEnd> += 8 ; <S2SV_ModStart> ""\\n"" ) ; log_frame_info ( cm , ""Vectors<S2SV_blank>"" , mvs ) ; mi = cm -> mi_grid_visible ; for ( mi_row = 0 ; mi_row < rows ; mi_row ++ ) { fprintf ( mvs , ""V<S2SV_blank>"" ) ; for ( mi_col = 0 ; mi_col < cols ; mi_col ++ ) { fprintf ( mvs , ""%4d:%4d<S2SV_blank>"" , mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv . row , mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv . col ) ; mi ++ ; } fprintf ( mvs , ""\\n"" ) ; mi += 8 ; } fprintf ( mvs , ""\\n"" ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int mi_index = 0 ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ; <S2SV_EndBug> <S2SV_StartBug> print_mi_data ( cm , mvs , ""Skips:"" , offsetof ( MB_MODE_INFO , skip ) ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( mvs , ""V<S2SV_blank>"" ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( mvs , ""%4d:%4d<S2SV_blank>"" , mi_8x8 [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row , <S2SV_EndBug> <S2SV_StartBug> mi_index += 8 ; <S2SV_EndBug> <S2SV_StartBug> fclose ( mvs ) ; <S2SV_EndBug>"
1890,CWE-119,"void vp9_init_layer_context ( VP9_COMP * const cpi ) { SVC * const svc = & cpi -> svc ; <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int layer ; <S2SV_EndBug> int layer_end ; svc -> spatial_layer_id = 0 ; svc -> temporal_layer_id = 0 ; <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> layer_end = svc -> number_temporal_layers ; } else { layer_end = svc -> number_spatial_layers ; } for ( layer = 0 ; layer < layer_end ; ++ layer ) { <S2SV_StartBug> LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; <S2SV_EndBug> RATE_CONTROL * const lrc = & lc -> rc ; lc -> current_video_frame_in_layer = 0 ; lrc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ; lrc -> ni_av_qi = oxcf -> worst_allowed_q ; lrc -> total_actual_bits = 0 ; lrc -> total_target_vs_actual = 0 ; lrc -> ni_tot_qi = 0 ; lrc -> tot_q = 0.0 ; lrc -> avg_q = 0.0 ; lrc -> ni_frames = 0 ; lrc -> decimation_count = 0 ; lrc -> decimation_factor = 0 ; lrc -> rate_correction_factor = 1.0 ; lrc -> key_frame_rate_correction_factor = 1.0 ; if ( svc -> number_temporal_layers > 1 ) { lc -> target_bandwidth = oxcf -> ts_target_bitrate [ layer ] * 1000 ; lrc -> last_q [ INTER_FRAME ] = oxcf -> worst_allowed_q ; } else { lc -> target_bandwidth = oxcf -> ss_target_bitrate [ layer ] * 1000 ; lrc -> last_q [ 0 ] = oxcf -> best_allowed_q ; lrc -> last_q [ 1 ] = oxcf -> best_allowed_q ; lrc -> last_q [ 2 ] = oxcf -> best_allowed_q ; } lrc -> buffer_level = vp9_rescale ( ( int ) ( oxcf -> starting_buffer_level ) , lc -> target_bandwidth , 1000 ) ; lrc -> bits_off_target = lrc -> buffer_level ; } }
","<S2SV_ModStart> svc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> oxcf ; int sl , tl ; int alt_ref_idx = svc -> number_spatial_layers ; svc -> spatial_layer_id = 0 ; svc -> temporal_layer_id = 0 ; if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . pass == 2 ) { if ( vpx_realloc_frame_buffer ( & cpi -> svc . empty_frame . img , SMALL_FRAME_WIDTH , SMALL_FRAME_HEIGHT , cpi -> common . subsampling_x , cpi -> common . subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cpi -> common . use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , cpi -> common . byte_alignment , NULL , NULL , NULL ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>empty<S2SV_blank>frame<S2SV_blank>for<S2SV_blank>multiple<S2SV_blank>frame<S2SV_blank>"" ""contexts"" ) ; memset ( cpi -> svc . empty_frame . img . buffer_alloc , 0x80 , cpi -> svc . empty_frame . img . buffer_alloc_sz ) ; } for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { int layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; RATE_CONTROL * const lrc = & lc -> rc ; int i ; lc -> current_video_frame_in_layer = 0 ; lc -> layer_size = 0 ; lc -> frames_from_key_frame = 0 ; lc -> last_frame_type = FRAME_TYPES ; lrc -> ni_av_qi = oxcf -> worst_allowed_q ; lrc -> total_actual_bits = 0 ; lrc -> total_target_vs_actual = 0 ; lrc -> ni_tot_qi = 0 ; lrc -> tot_q = 0.0 ; lrc -> avg_q = 0.0 ; lrc -> ni_frames = 0 ; lrc -> decimation_count = 0 ; lrc -> decimation_factor = 0 ; for ( i = 0 ; i < RATE_FACTOR_LEVELS ; ++ i ) { lrc -> rate_correction_factors [ i ] = 1.0 ; } if ( cpi -> oxcf . rc_mode == VPX_CBR ) { lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; lrc -> last_q [ INTER_FRAME ] = oxcf -> worst_allowed_q ; lrc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ; lrc -> avg_frame_qindex [ KEY_FRAME ] = oxcf -> worst_allowed_q ; } else { lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; lrc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ; lrc -> last_q [ INTER_FRAME ] = oxcf -> best_allowed_q ; lrc -> avg_frame_qindex [ KEY_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ; lrc -> avg_frame_qindex [ INTER_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ; if ( oxcf -> ss_enable_auto_arf [ sl ] ) lc -> alt_ref_idx = alt_ref_idx ++ ; else lc -> alt_ref_idx = INVALID_IDX ; lc -> gold_ref_idx = INVALID_IDX ; } lrc -> buffer_level = oxcf -> starting_buffer_level_ms * lc -> target_bandwidth / 1000 ; lrc -> bits_off_target = lrc -> buffer_level ; } } if ( ! <S2SV_ModEnd> ( svc -> <S2SV_ModStart> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) && alt_ref_idx < REF_FRAMES ) <S2SV_ModEnd> svc -> layer_context <S2SV_ModStart> -> layer_context [ 0 ] . gold_ref_idx = alt_ref_idx ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int layer ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; <S2SV_EndBug>
5196,CWE-476,"void gf_isom_cenc_get_default_info_internal ( GF_TrackBox * trak , u32 sampleDescriptionIndex , u32 * container_type , Bool * default_IsEncrypted , u8 * crypt_byte_block , u8 * skip_byte_block , const u8 * * key_info , u32 * key_info_size ) { GF_ProtectionSchemeInfoBox * sinf ; if ( default_IsEncrypted ) * default_IsEncrypted = GF_FALSE ; if ( crypt_byte_block ) * crypt_byte_block = 0 ; if ( skip_byte_block ) * skip_byte_block = 0 ; if ( container_type ) * container_type = 0 ; if ( key_info ) * key_info = NULL ; if ( key_info_size ) * key_info_size = 0 ; sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CENC_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CBC_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CENS_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CBCS_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_PIFF_SCHEME , NULL ) ; if ( ! sinf ) { u32 i , nb_stsd = gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ; for ( i = 0 ; i < nb_stsd ; i ++ ) { GF_ProtectionSchemeInfoBox * a_sinf ; GF_SampleEntryBox * sentry = NULL ; if ( i + 1 == sampleDescriptionIndex ) continue ; sentry = gf_list_get ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes , i ) ; a_sinf = ( GF_ProtectionSchemeInfoBox * ) gf_isom_box_find_child ( sentry -> child_boxes , GF_ISOM_BOX_TYPE_SINF ) ; if ( ! a_sinf ) continue ; return ; } } if ( sinf && sinf -> info && sinf -> info -> tenc ) { if ( default_IsEncrypted ) * default_IsEncrypted = sinf -> info -> tenc -> isProtected ; if ( crypt_byte_block ) * crypt_byte_block = sinf -> info -> tenc -> crypt_byte_block ; if ( skip_byte_block ) * skip_byte_block = sinf -> info -> tenc -> skip_byte_block ; if ( key_info ) * key_info = sinf -> info -> tenc -> key_info ; if ( key_info_size ) { * key_info_size = 20 ; if ( ! sinf -> info -> tenc -> key_info [ 3 ] ) * key_info_size += 1 + sinf -> info -> tenc -> key_info [ 20 ] ; } if ( container_type ) * container_type = GF_ISOM_BOX_TYPE_SENC ; } else if ( sinf && sinf -> info && sinf -> info -> piff_tenc ) { if ( default_IsEncrypted ) * default_IsEncrypted = GF_TRUE ; if ( key_info ) * key_info = sinf -> info -> piff_tenc -> key_info ; if ( key_info_size ) * key_info_size = 19 ; if ( container_type ) * container_type = GF_ISOM_BOX_UUID_PSEC ; } else { u32 i , count = 0 ; GF_CENCSampleEncryptionGroupEntry * seig_entry = NULL ; if ( ! trak -> moov -> mov -> is_smooth ) count = gf_list_count ( trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) ; for ( i = 0 ; i < count ; i ++ ) { GF_SampleGroupDescriptionBox * sgdesc = ( GF_SampleGroupDescriptionBox * ) gf_list_get ( trak -> Media -> information -> sampleTable -> sampleGroupsDescription , i ) ; if ( sgdesc -> grouping_type != GF_ISOM_SAMPLE_GROUP_SEIG ) continue ; if ( sgdesc -> default_description_index ) seig_entry = gf_list_get ( sgdesc -> group_descriptions , sgdesc -> default_description_index - 1 ) ; else seig_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; <S2SV_StartBug> if ( ! seig_entry -> key_info [ 0 ] ) <S2SV_EndBug> seig_entry = NULL ; break ; } if ( seig_entry ) { if ( default_IsEncrypted ) * default_IsEncrypted = seig_entry -> IsProtected ; if ( crypt_byte_block ) * crypt_byte_block = seig_entry -> crypt_byte_block ; if ( skip_byte_block ) * skip_byte_block = seig_entry -> skip_byte_block ; if ( key_info ) * key_info = seig_entry -> key_info ; if ( key_info_size ) * key_info_size = seig_entry -> key_info_size ; if ( container_type ) * container_type = GF_ISOM_BOX_TYPE_SENC ; } else { if ( ! trak -> moov -> mov -> is_smooth ) { trak -> moov -> mov -> is_smooth = GF_TRUE ; GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>senc<S2SV_blank>box<S2SV_blank>without<S2SV_blank>tenc,<S2SV_blank>assuming<S2SV_blank>MS<S2SV_blank>smooth+piff\\n"" ) ) ; } if ( default_IsEncrypted ) * default_IsEncrypted = GF_TRUE ; if ( container_type ) * container_type = GF_ISOM_BOX_UUID_PSEC ; } } if ( container_type && trak -> sample_encryption ) { if ( trak -> sample_encryption -> type == GF_ISOM_BOX_TYPE_SENC ) * container_type = GF_ISOM_BOX_TYPE_SENC ; else if ( trak -> sample_encryption -> type == GF_ISOM_BOX_TYPE_UUID ) * container_type = ( ( GF_UUIDBox * ) trak -> sample_encryption ) -> internal_4cc ; } }
","<S2SV_ModStart> ; if ( seig_entry &&
",gpac@gpac/3b84ffcbacf144ce35650df958432f472b6483f8,CVE-2021-31259,https://github.com/gpac/gpac/commit/3b84ffcbacf144ce35650df958432f472b6483f8,2021-04-19T19:15Z,<S2SV_StartBug> if ( ! seig_entry -> key_info [ 0 ] ) <S2SV_EndBug>
8248,CWE-787,"static inline int l2cap_connect_rsp ( struct l2cap_conn * conn , struct l2cap_cmd_hdr * cmd , u8 * data ) { struct l2cap_conn_rsp * rsp = ( struct l2cap_conn_rsp * ) data ; u16 scid , dcid , result , status ; struct sock * sk ; u8 req [ 128 ] ; scid = __le16_to_cpu ( rsp -> scid ) ; dcid = __le16_to_cpu ( rsp -> dcid ) ; result = __le16_to_cpu ( rsp -> result ) ; status = __le16_to_cpu ( rsp -> status ) ; BT_DBG ( ""dcid<S2SV_blank>0x%4.4x<S2SV_blank>scid<S2SV_blank>0x%4.4x<S2SV_blank>result<S2SV_blank>0x%2.2x<S2SV_blank>status<S2SV_blank>0x%2.2x"" , dcid , scid , result , status ) ; if ( scid ) { sk = l2cap_get_chan_by_scid ( & conn -> chan_list , scid ) ; if ( ! sk ) return 0 ; } else { sk = l2cap_get_chan_by_ident ( & conn -> chan_list , cmd -> ident ) ; if ( ! sk ) return 0 ; } switch ( result ) { case L2CAP_CR_SUCCESS : sk -> sk_state = BT_CONFIG ; l2cap_pi ( sk ) -> ident = 0 ; l2cap_pi ( sk ) -> dcid = dcid ; l2cap_pi ( sk ) -> conf_state |= L2CAP_CONF_REQ_SENT ; l2cap_pi ( sk ) -> conf_state &= ~ L2CAP_CONF_CONNECT_PEND ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , l2cap_build_conf_req ( sk , req ) , req ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case L2CAP_CR_PEND : l2cap_pi ( sk ) -> conf_state |= L2CAP_CONF_CONNECT_PEND ; break ; default : l2cap_chan_del ( sk , ECONNREFUSED ) ; break ; } bh_unlock_sock ( sk ) ; return 0 ; }
","<S2SV_ModStart> req ) ; l2cap_pi ( sk ) -> num_conf_req ++ ;
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z,<S2SV_StartBug> break ; <S2SV_EndBug>
7900,CWE-20,"error_t httpReadRequestHeader ( HttpConnection * connection ) { error_t error ; size_t length ; error = socketSetTimeout ( connection -> socket , HTTP_SERVER_IDLE_TIMEOUT ) ; if ( error ) return error ; error = httpReceive ( connection , connection -> buffer , HTTP_SERVER_BUFFER_SIZE - 1 , & length , SOCKET_FLAG_BREAK_CRLF ) ; if ( error ) return error ; error = socketSetTimeout ( connection -> socket , HTTP_SERVER_TIMEOUT ) ; if ( error ) return error ; connection -> buffer [ length ] = '\\0' ; TRACE_INFO ( ""%s"" , connection -> buffer ) ; error = httpParseRequestLine ( connection , connection -> buffer ) ; if ( error ) return error ; connection -> request . chunkedEncoding = FALSE ; connection -> request . contentLength = 0 ; # if ( HTTP_SERVER_WEB_SOCKET_SUPPORT == ENABLED ) connection -> request . upgradeWebSocket = FALSE ; connection -> request . connectionUpgrade = FALSE ; osStrcpy ( connection -> request . clientKey , """" ) ; # endif if ( connection -> request . version >= HTTP_VERSION_1_0 ) { char_t firstChar ; char_t * separator ; char_t * name ; char_t * value ; firstChar = '\\0' ; while ( 1 ) { error = httpReadHeaderField ( connection , connection -> buffer , HTTP_SERVER_BUFFER_SIZE , & firstChar ) ; if ( error ) return error ; TRACE_DEBUG ( ""%s"" , connection -> buffer ) ; if ( ! osStrcmp ( connection -> buffer , ""\\r\\n"" ) ) break ; <S2SV_StartBug> separator = strchr ( connection -> buffer , ':' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( connection -> buffer ) ; value = strTrimWhitespace ( separator + 1 ) ; httpParseHeaderField ( connection , name , value ) ; } } } if ( connection -> request . chunkedEncoding ) { connection -> request . byteCount = 0 ; connection -> request . firstChunk = TRUE ; connection -> request . lastChunk = FALSE ; } else { connection -> request . byteCount = connection -> request . contentLength ; } return NO_ERROR ; }
","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( connection ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> separator = strchr ( connection -> buffer , ':' ) ; <S2SV_EndBug>"
3094,CWE-835,"static void setup_connection ( GsmXSMPClient * client ) { GIOChannel * channel ; int fd ; g_debug ( ""GsmXSMPClient:<S2SV_blank>Setting<S2SV_blank>up<S2SV_blank>new<S2SV_blank>connection"" ) ; fd = IceConnectionNumber ( client -> priv -> ice_connection ) ; fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD , 0 ) | FD_CLOEXEC ) ; channel = g_io_channel_unix_new ( fd ) ; client -> priv -> watch_id = g_io_add_watch ( channel , G_IO_IN | G_IO_ERR , ( GIOFunc ) client_iochannel_watch , client ) ; g_io_channel_unref ( channel ) ; <S2SV_StartBug> client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 , <S2SV_EndBug> ( GSourceFunc ) _client_protocol_timeout , client ) ; set_description ( client ) ; g_debug ( ""GsmXSMPClient:<S2SV_blank>New<S2SV_blank>client<S2SV_blank>\'%s\'"" , client -> priv -> description ) ; }
","<S2SV_ModStart> channel ) ; <S2SV_ModEnd> set_description ( client
",GNOME@gnome-session/b0dc999e0b45355314616321dbb6cb71e729fc9d,CVE-2017-11171,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,2017-07-11T20:29Z,"<S2SV_StartBug> client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 , <S2SV_EndBug>"
2270,CWE-119,"static int translate_hex_string ( char * s , char * saved_orphan ) { int c1 = * saved_orphan ; char * start = s ; char * t = s ; for ( ; * s ; s ++ ) { <S2SV_StartBug> if ( isspace ( * s ) ) <S2SV_EndBug> continue ; if ( c1 ) { * t ++ = ( hexval ( c1 ) << 4 ) + hexval ( * s ) ; c1 = 0 ; } else c1 = * s ; } * saved_orphan = c1 ; return t - start ; }
","<S2SV_ModStart> ( isspace ( ( unsigned char )
",kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,CVE-2015-3905,https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,2015-06-08T14:59Z,<S2SV_StartBug> if ( isspace ( * s ) ) <S2SV_EndBug>
2735,CWE-269,"static int store_xauthority ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_XAUTHORITY_FILE ; FILE * fp = fopen ( dest , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0600 ) ; fclose ( fp ) ; } if ( asprintf ( & src , ""%s/.Xauthority"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { <S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> exit ( 1 ) ; } pid_t child = fork ( ) ; if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; else { fs_logger2 ( ""clone"" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) <S2SV_EndBug> errExit ( ""fchown"" ) ; if ( chmod ( dest , 0600 ) == - 1 ) errExit ( ""fchmod"" ) ; return 1 ; } return 0 ; }
","<S2SV_ModStart> ( stderr , ""Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; return 0 ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> ( src , <S2SV_ModEnd> dest , getuid <S2SV_ModStart> getgid ( ) , 0600 ) ; fs_logger2 ( ""clone"" , dest <S2SV_ModEnd> ) ; return
",netblue30@firejail/903fd8a0789ca3cc3c21d84cd0282481515592ef,CVE-2017-5940,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,2017-02-09T18:59Z,"<S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) <S2SV_EndBug>"
2868,CWE-200,"static int get_linux_shareopts ( const char * shareopts , char * * plinux_opts ) { int rc ; assert ( plinux_opts != NULL ) ; * plinux_opts = NULL ; ( void ) add_linux_shareopt ( plinux_opts , ""no_subtree_check"" , NULL ) ; ( void ) add_linux_shareopt ( plinux_opts , ""no_root_squash"" , NULL ) ; ( void ) add_linux_shareopt ( plinux_opts , ""mountpoint"" , NULL ) ; <S2SV_StartBug> rc = foreach_nfs_shareopt ( shareopts , get_linux_shareopts_cb , <S2SV_EndBug> plinux_opts ) ; if ( rc != SA_OK ) { free ( * plinux_opts ) ; * plinux_opts = NULL ; } return ( rc ) ; }
","<S2SV_ModStart> ; rc = foreach_shareopt <S2SV_ModEnd> ( shareopts ,
",FransUrbo@zfs/99aa4d2b4fd12c6bef62d02ffd1b375ddd42fcf4,CVE-2015-3400,https://github.com/FransUrbo/zfs/commit/99aa4d2b4fd12c6bef62d02ffd1b375ddd42fcf4,2017-10-18T15:29Z,"<S2SV_StartBug> rc = foreach_nfs_shareopt ( shareopts , get_linux_shareopts_cb , <S2SV_EndBug>"
1905,CWE-119,"static void set_entropy_context_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct tokenize_b_args * const args = arg ; <S2SV_StartBug> MACROBLOCKD * const xd = args -> xd ; <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * p = & args -> cpi -> mb . plane [ plane ] ; <S2SV_EndBug> struct macroblockd_plane * pd = & xd -> plane [ plane ] ; int aoff , loff ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ; vp9_set_contexts ( xd , pd , plane_bsize , tx_size , p -> eobs [ block ] > 0 , aoff , loff ) ; }
","<S2SV_ModStart> = arg ; ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; <S2SV_ModStart> const xd = & x -> e_mbd <S2SV_ModEnd> ; struct macroblock_plane <S2SV_ModStart> p = & x -> <S2SV_ModEnd> plane [ plane
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> MACROBLOCKD * const xd = args -> xd ; <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * p = & args -> cpi -> mb . plane [ plane ] ; <S2SV_EndBug>
4938,CWE-617,"void pci_lintr_deassert ( struct pci_vdev * dev ) { <S2SV_StartBug> assert ( dev -> lintr . pin > 0 ) ; <S2SV_EndBug> pthread_mutex_lock ( & dev -> lintr . lock ) ; if ( dev -> lintr . state == ASSERTED ) { dev -> lintr . state = IDLE ; pci_irq_deassert ( dev ) ; } else if ( dev -> lintr . state == PENDING ) dev -> lintr . state = IDLE ; pthread_mutex_unlock ( & dev -> lintr . lock ) ; }
","<S2SV_ModStart> dev ) { if <S2SV_ModEnd> ( dev -> <S2SV_ModStart> lintr . pin <= 0 ) { pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\n"" , __func__ , dev -> name ) ; return ; } <S2SV_ModEnd> pthread_mutex_lock ( &
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,<S2SV_StartBug> assert ( dev -> lintr . pin > 0 ) ; <S2SV_EndBug>
1138,CWE-20,"static krb5_int32 find_referral_tgs ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , krb5_principal * krbtgt_princ ) { krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; char * * realms = NULL , * hostname = NULL ; krb5_data srealm = request -> server -> realm ; if ( ! is_referral_req ( kdc_active_realm , request ) ) goto cleanup ; hostname = data2string ( krb5_princ_component ( kdc_context , request -> server , 1 ) ) ; if ( hostname == NULL ) { retval = ENOMEM ; goto cleanup ; } if ( strchr ( hostname , '.' ) == NULL ) goto cleanup ; retval = krb5_get_host_realm ( kdc_context , hostname , & realms ) ; if ( retval ) { kdc_err ( kdc_context , retval , ""unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>realm<S2SV_blank>of<S2SV_blank>host"" ) ; goto cleanup ; } <S2SV_StartBug> if ( realms == NULL || realms [ 0 ] == '\\0' || <S2SV_EndBug> data_eq_string ( srealm , realms [ 0 ] ) ) { retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto cleanup ; } retval = krb5_build_principal ( kdc_context , krbtgt_princ , srealm . length , srealm . data , ""krbtgt"" , realms [ 0 ] , ( char * ) 0 ) ; cleanup : krb5_free_host_realm ( kdc_context , realms ) ; free ( hostname ) ; return retval ; }
","<S2SV_ModStart> 0 ] == NULL || * realms [ 0 ] ==
",krb5@krb5/4c023ba43c16396f0d199e2df1cfa59b88b62acc,CVE-2013-1417,https://github.com/krb5/krb5/commit/4c023ba43c16396f0d199e2df1cfa59b88b62acc,2013-11-20T14:12Z,<S2SV_StartBug> if ( realms == NULL || realms [ 0 ] == '\\0' || <S2SV_EndBug>
2263,CWE-20,"static int do_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags , pte_t orig_pte ) { pgoff_t pgoff = ( ( ( address & PAGE_MASK ) - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; <S2SV_StartBug> pte_unmap ( page_table ) ; <S2SV_EndBug> if ( ! ( flags & FAULT_FLAG_WRITE ) ) return do_read_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; if ( ! ( vma -> vm_flags & VM_SHARED ) ) return do_cow_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; return do_shared_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; }
","<S2SV_ModStart> ( page_table ) ; if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS
",torvalds@linux/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,CVE-2015-3288,https://github.com/torvalds/linux/commit/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,2016-10-16T21:59Z,<S2SV_StartBug> pte_unmap ( page_table ) ; <S2SV_EndBug>
2584,CWE-787,"tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>"" ""t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef ZIP_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef OJPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { if ( t2p -> tiff_dataoffset != 0 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( t2p -> pdf_ojpegiflength == 0 ) { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; t2pReadFile ( input , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } else { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; bufferoffset = t2pReadFile ( input , ( tdata_t ) buffer , t2p -> pdf_ojpegiflength ) ; t2p -> pdf_ojpegiflength = 0 ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & h_samp , & v_samp ) ; buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xdd ; buffer [ bufferoffset ++ ] = 0x00 ; buffer [ bufferoffset ++ ] = 0x04 ; h_samp *= 8 ; v_samp *= 8 ; ri = ( t2p -> tiff_width + h_samp - 1 ) / h_samp ; TIFFGetField ( input , TIFFTAG_ROWSPERSTRIP , & rows ) ; ri *= ( rows + v_samp - 1 ) / v_samp ; buffer [ bufferoffset ++ ] = ( ri >> 8 ) & 0xff ; buffer [ bufferoffset ++ ] = ri & 0xff ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } } else { if ( ! t2p -> pdf_ojpegdata ) { TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>tables"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; bufferoffset = t2p -> pdf_ojpegdatalength ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } if ( ! ( ( buffer [ bufferoffset - 1 ] == 0xd9 ) && ( buffer [ bufferoffset - 2 ] == 0xff ) ) ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; # if 0 TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>JPEG<S2SV_blank>File<S2SV_blank>Interchange<S2SV_blank>offset"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; # endif } } # endif # ifdef JPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { uint32 count = 0 ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { if ( count > 4 ) { _TIFFmemcpy ( buffer , jpt , count ) ; bufferoffset += count - 2 ; } } stripcount = TIFFNumberOfStrips ( input ) ; TIFFGetField ( input , TIFFTAG_STRIPBYTECOUNTS , & sbc ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( sbc [ i ] > max_striplength ) max_striplength = sbc [ i ] ; } stripbuffer = ( unsigned char * ) _TIFFmalloc ( max_striplength ) ; if ( stripbuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , max_striplength , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { striplength = TIFFReadRawStrip ( input , i , ( tdata_t ) stripbuffer , - 1 ) ; if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer , <S2SV_StartBug> & bufferoffset , <S2SV_EndBug> i , t2p -> tiff_length ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>process<S2SV_blank>JPEG<S2SV_blank>data<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( stripbuffer ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif ( void ) 0 ; } if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } } else { if ( t2p -> pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { sepstripsize = TIFFStripSize ( input ) ; sepstripcount = TIFFNumberOfStrips ( input ) ; stripsize = sepstripsize * t2p -> tiff_samplesperpixel ; stripcount = sepstripcount / t2p -> tiff_samplesperpixel ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; samplebuffer = ( unsigned char * ) _TIFFmalloc ( stripsize ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { samplebufferoffset = 0 ; for ( j = 0 ; j < t2p -> tiff_samplesperpixel ; j ++ ) { read = TIFFReadEncodedStrip ( input , i + j * stripcount , ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , TIFFmin ( sepstripsize , stripsize - samplebufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i + j * stripcount , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset += read ; } t2p_sample_planar_separate_to_contig ( t2p , & ( buffer [ bufferoffset ] ) , samplebuffer , samplebufferoffset ) ; bufferoffset += samplebufferoffset ; } _TIFFfree ( samplebuffer ) ; goto dataready ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } if ( t2p -> pdf_sample & T2P_SAMPLE_REALIZE_PALETTE ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_datasize * t2p -> tiff_samplesperpixel ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; t2p -> tiff_datasize *= t2p -> tiff_samplesperpixel ; } t2p_sample_realize_palette ( t2p , buffer ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length * 4 ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; } if ( ! TIFFReadRGBAImageOriented ( input , t2p -> tiff_width , t2p -> tiff_length , ( uint32 * ) buffer , ORIENTATION_TOPLEFT , 0 ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>use<S2SV_blank>TIFFReadRGBAImageOriented<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>RGB<S2SV_blank>image<S2SV_blank>from<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } t2p -> tiff_datasize = t2p_sample_abgr_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } } dataready : t2p_disable ( output ) ; TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_width ) ; TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; switch ( t2p -> pdf_compression ) { case T2P_COMPRESS_NONE : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; break ; # ifdef CCITT_SUPPORT case T2P_COMPRESS_G4 : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; break ; # endif # ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG : if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { uint16 hor = 0 , ver = 0 ; if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { if ( hor != 0 && ver != 0 ) { TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; } } if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; } } if ( TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) == 0 ) { TIFFError ( TIFF2PDF_MODULE , ""Unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>JPEG<S2SV_blank>compression<S2SV_blank>for<S2SV_blank>input<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>output<S2SV_blank>%s"" , TIFFFileName ( input ) , TIFFFileName ( output ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; } } if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { ( void ) 0 ; } if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { ( void ) 0 ; } if ( t2p -> pdf_defaultcompressionquality != 0 ) { TIFFSetField ( output , TIFFTAG_JPEGQUALITY , t2p -> pdf_defaultcompressionquality ) ; } break ; # endif # ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { TIFFSetField ( output , TIFFTAG_PREDICTOR , t2p -> pdf_defaultcompressionquality % 100 ) ; } if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { TIFFSetField ( output , TIFFTAG_ZIPQUALITY , ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; } break ; # endif default : break ; } t2p_enable ( output ) ; t2p -> outputwritten = 0 ; # ifdef JPEG_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_JPEG && t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , stripsize * stripcount ) ; } else # endif { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , t2p -> tiff_datasize ) ; } if ( buffer != NULL ) { _TIFFfree ( buffer ) ; buffer = NULL ; } if ( bufferoffset == ( tsize_t ) - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>writing<S2SV_blank>encoded<S2SV_blank>strip<S2SV_blank>to<S2SV_blank>output<S2SV_blank>PDF<S2SV_blank>%s"" , TIFFFileName ( output ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } written = t2p -> outputwritten ; return ( written ) ; }
","<S2SV_ModStart> , buffer , t2p -> tiff_datasize ,
",vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a,CVE-2016-9533,https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a#diff-bdc795f6afeb9558c1012b3cfae729ef,2016-11-22T19:59Z,"<S2SV_StartBug> & bufferoffset , <S2SV_EndBug>"
940,CWE-190,"static int tiffcp ( TIFF * in , TIFF * out ) { <S2SV_StartBug> uint16 bitspersample , samplesperpixel ; <S2SV_EndBug> <S2SV_StartBug> uint16 input_compression , input_photometric ; <S2SV_EndBug> copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24 ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV ) ; else if ( input_compression == COMPRESSION_JPEG && samplesperpixel == 3 ) { TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_RGB ) ; } else CopyTag ( TIFFTAG_PHOTOMETRIC , 1 , TIFF_SHORT ) ; if ( fillorder != 0 ) TIFFSetField ( out , TIFFTAG_FILLORDER , fillorder ) ; else CopyTag ( TIFFTAG_FILLORDER , 1 , TIFF_SHORT ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; switch ( orientation ) { case ORIENTATION_BOTRIGHT : case ORIENTATION_RIGHTBOT : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>bottom-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_BOTLEFT ; case ORIENTATION_LEFTBOT : case ORIENTATION_BOTLEFT : break ; case ORIENTATION_TOPRIGHT : case ORIENTATION_RIGHTTOP : default : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>top-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_TOPLEFT ; case ORIENTATION_LEFTTOP : case ORIENTATION_TOPLEFT : break ; } TIFFSetField ( out , TIFFTAG_ORIENTATION , orientation ) ; if ( outtiled == - 1 ) outtiled = TIFFIsTiled ( in ) ; if ( outtiled ) { if ( tilewidth == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tilewidth ) ; if ( tilelength == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tilelength ) ; TIFFDefaultTileSize ( out , & tilewidth , & tilelength ) ; TIFFSetField ( out , TIFFTAG_TILEWIDTH , tilewidth ) ; TIFFSetField ( out , TIFFTAG_TILELENGTH , tilelength ) ; } else { if ( rowsperstrip == ( uint32 ) 0 ) { if ( ! TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ) { rowsperstrip = TIFFDefaultStripSize ( out , rowsperstrip ) ; } if ( rowsperstrip > length && rowsperstrip != ( uint32 ) - 1 ) rowsperstrip = length ; } else if ( rowsperstrip == ( uint32 ) - 1 ) rowsperstrip = length ; TIFFSetField ( out , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; } if ( config != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PLANARCONFIG , config ) ; else CopyField ( TIFFTAG_PLANARCONFIG , config ) ; if ( samplesperpixel <= 4 ) CopyTag ( TIFFTAG_TRANSFERFUNCTION , 4 , TIFF_SHORT ) ; CopyTag ( TIFFTAG_COLORMAP , 4 , TIFF_SHORT ) ; switch ( compression ) { case COMPRESSION_JPEG : TIFFSetField ( out , TIFFTAG_JPEGQUALITY , quality ) ; TIFFSetField ( out , TIFFTAG_JPEGCOLORMODE , jpegcolormode ) ; break ; case COMPRESSION_JBIG : CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; CopyTag ( TIFFTAG_FAXDCS , 1 , TIFF_ASCII ) ; break ; case COMPRESSION_LZW : case COMPRESSION_ADOBE_DEFLATE : case COMPRESSION_DEFLATE : case COMPRESSION_LZMA : if ( predictor != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PREDICTOR , predictor ) ; else CopyField ( TIFFTAG_PREDICTOR , predictor ) ; if ( preset != - 1 ) { if ( compression == COMPRESSION_ADOBE_DEFLATE || compression == COMPRESSION_DEFLATE ) TIFFSetField ( out , TIFFTAG_ZIPQUALITY , preset ) ; else if ( compression == COMPRESSION_LZMA ) TIFFSetField ( out , TIFFTAG_LZMAPRESET , preset ) ; } break ; case COMPRESSION_CCITTFAX3 : case COMPRESSION_CCITTFAX4 : if ( compression == COMPRESSION_CCITTFAX3 ) { if ( g3opts != ( uint32 ) - 1 ) TIFFSetField ( out , TIFFTAG_GROUP3OPTIONS , g3opts ) ; else CopyField ( TIFFTAG_GROUP3OPTIONS , g3opts ) ; } else CopyTag ( TIFFTAG_GROUP4OPTIONS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_BADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CLEANFAXDATA , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CONSECUTIVEBADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; break ; } { uint32 len32 ; void * * data ; if ( TIFFGetField ( in , TIFFTAG_ICCPROFILE , & len32 , & data ) ) TIFFSetField ( out , TIFFTAG_ICCPROFILE , len32 , data ) ; } { uint16 ninks ; const char * inknames ; if ( TIFFGetField ( in , TIFFTAG_NUMBEROFINKS , & ninks ) ) { TIFFSetField ( out , TIFFTAG_NUMBEROFINKS , ninks ) ; if ( TIFFGetField ( in , TIFFTAG_INKNAMES , & inknames ) ) { int inknameslen = strlen ( inknames ) + 1 ; const char * cp = inknames ; while ( ninks > 1 ) { cp = strchr ( cp , '\\0' ) ; cp ++ ; inknameslen += ( strlen ( cp ) + 1 ) ; ninks -- ; } TIFFSetField ( out , TIFFTAG_INKNAMES , inknameslen , inknames ) ; } } } { unsigned short pg0 , pg1 ; if ( pageInSeq == 1 ) { if ( pageNum < 0 ) { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; } else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } else { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) { if ( pageNum < 0 ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } } } for ( p = tags ; p < & tags [ NTAGS ] ; p ++ ) CopyTag ( p -> tag , p -> count , p -> type ) ; cf = pickCopyFunc ( in , out , bitspersample , samplesperpixel ) ; return ( cf ? ( * cf ) ( in , out , length , width , samplesperpixel ) : FALSE ) ; }
","<S2SV_ModStart> bitspersample , samplesperpixel = 1 <S2SV_ModStart> input_compression , input_photometric = PHOTOMETRIC_MINISBLACK
",vadz@libtiff/43c0b81a818640429317c80fea1e66771e85024b,CVE-2016-9538,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b#diff-c8b4b355f9b5c06d585b23138e1c185f,2016-11-22T19:59Z,"<S2SV_StartBug> uint16 bitspersample , samplesperpixel ; <S2SV_EndBug> <S2SV_StartBug> uint16 input_compression , input_photometric ; <S2SV_EndBug>"
6110,CWE-203,"int secure_decrypt ( void * data , unsigned int data_length , int is_signed ) { at91_aes_key_size_t key_size ; unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ; unsigned int iv [ AT91_AES_IV_SIZE_WORD ] ; unsigned int computed_cmac [ AT91_AES_BLOCK_SIZE_WORD ] ; unsigned int fixed_length ; const unsigned int * cmac ; int rc = - 1 ; init_keys ( & key_size , cipher_key , cmac_key , iv ) ; at91_aes_init ( ) ; if ( is_signed ) { if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ; fixed_length = at91_aes_roundup ( data_length ) ; cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ; <S2SV_StartBug> if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) <S2SV_EndBug> goto exit ; } if ( at91_aes_cbc ( data_length , data , data , 0 , key_size , cipher_key , iv ) ) goto exit ; rc = 0 ; exit : at91_aes_cleanup ( ) ; memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ; memset ( cipher_key , 0 , sizeof ( cipher_key ) ) ; memset ( iv , 0 , sizeof ( iv ) ) ; return rc ; }
","<S2SV_ModStart> ; if ( ! consttime_memequal <S2SV_ModEnd> ( cmac ,
",linux4sam@at91bootstrap/7753914c9a622c245f3a3cf2af5e24b6a9904213,CVE-2020-11683,https://github.com/linux4sam/at91bootstrap/commit/7753914c9a622c245f3a3cf2af5e24b6a9904213,2020-09-14T14:15Z,"<S2SV_StartBug> if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) <S2SV_EndBug>"
3322,CWE-399,"static int ceph_x_decrypt ( struct ceph_crypto_key * secret , <S2SV_StartBug> void * * p , void * end , void * obuf , size_t olen ) <S2SV_EndBug> { struct ceph_x_encrypt_header head ; size_t head_len = sizeof ( head ) ; int len , ret ; len = ceph_decode_32 ( p ) ; if ( * p + len > end ) return - EINVAL ; dout ( ""ceph_x_decrypt<S2SV_blank>len<S2SV_blank>%d\\n"" , len ) ; <S2SV_StartBug> ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen , <S2SV_EndBug> * p , len ) ; if ( ret ) return ret ; if ( head . struct_v != 1 || le64_to_cpu ( head . magic ) != CEPHX_ENC_MAGIC ) return - EPERM ; * p += len ; return olen ; }
","<S2SV_ModStart> end , void * <S2SV_ModStart> len ) ; if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> & head_len , *
",torvalds@linux/c27a3e4d667fdcad3db7b104f75659478e0c68d8,CVE-2014-6418,https://github.com/torvalds/linux/commit/c27a3e4d667fdcad3db7b104f75659478e0c68d8,2014-09-28T10:55Z,"<S2SV_StartBug> void * * p , void * end , void * obuf , size_t olen ) <S2SV_EndBug> <S2SV_StartBug> ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen , <S2SV_EndBug>"
5198,CWE-284,"static my_bool get_one_option ( int optid , const struct my_option * opt , char * argument ) { my_bool add_option = TRUE ; switch ( optid ) { case '?' : printf ( ""%s<S2SV_blank><S2SV_blank>Ver<S2SV_blank>%s<S2SV_blank>Distrib<S2SV_blank>%s,<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)\\n"" , my_progname , VER , MYSQL_SERVER_VERSION , SYSTEM_TYPE , MACHINE_TYPE ) ; puts ( ORACLE_WELCOME_COPYRIGHT_NOTICE ( ""2000"" ) ) ; puts ( ""MySQL<S2SV_blank>utility<S2SV_blank>for<S2SV_blank>upgrading<S2SV_blank>databases<S2SV_blank>to<S2SV_blank>new<S2SV_blank>MySQL<S2SV_blank>versions.\\n"" ) ; my_print_help ( my_long_options ) ; exit ( 0 ) ; break ; case '#' : DBUG_PUSH ( argument ? argument : default_dbug_option ) ; add_option = FALSE ; debug_check_flag = 1 ; break ; case 'p' : if ( argument == disabled_my_option ) argument = ( char * ) """" ; tty_password = 1 ; add_option = FALSE ; if ( argument ) { add_one_option ( & ds_args , opt , argument ) ; while ( * argument ) * argument ++ = 'x' ; tty_password = 0 ; } break ; case 't' : my_stpnmov ( opt_tmpdir , argument , sizeof ( opt_tmpdir ) ) ; add_option = FALSE ; break ; case 'k' : case 'v' : case 'f' : case 's' : case OPT_WRITE_BINLOG : add_option = FALSE ; break ; <S2SV_StartBug> case 'h' : <S2SV_EndBug> case 'W' : case 'P' : case 'S' : case OPT_MYSQL_PROTOCOL : case OPT_SHARED_MEMORY_BASE_NAME : case OPT_PLUGIN_DIR : case OPT_DEFAULT_AUTH : add_one_option ( & conn_args , opt , argument ) ; break ; } if ( add_option ) { add_one_option ( & ds_args , opt , argument ) ; } return 0 ; }
","<S2SV_ModStart> ; break ; # include < sslopt - case . h >
",mysql@mysql-server/3bd5589e1a5a93f9c224badf983cd65c45215390,CVE-2015-3152,https://github.com/mysql/mysql-server/commit/3bd5589e1a5a93f9c224badf983cd65c45215390,2016-05-16T10:59Z,<S2SV_StartBug> case 'h' : <S2SV_EndBug>
8041,CWE-347,"<S2SV_StartBug> void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) { <S2SV_EndBug> PointZZ_p R0 , R1 , tmp ; mpz_inits ( R1 . x , R1 . y , tmp . x , tmp . y , NULL ) ; mpz_init_set ( R0 . x , point -> x ) ; mpz_init_set ( R0 . y , point -> y ) ; pointZZ_pDouble ( & R1 , point , curve ) ; int dbits = mpz_sizeinbase ( scalar , 2 ) , i ; for ( i = dbits - 2 ; i >= 0 ; i -- ) { if ( mpz_tstbit ( scalar , i ) ) { mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pAdd ( & R0 , & R1 , & tmp , curve ) ; mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pDouble ( & R1 , & tmp , curve ) ; } else { mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pAdd ( & R1 , & R0 , & tmp , curve ) ; mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pDouble ( & R0 , & tmp , curve ) ; } } mpz_init_set ( rop -> x , R0 . x ) ; mpz_init_set ( rop -> y , R0 . y ) ; mpz_clears ( R0 . x , R0 . y , R1 . x , R1 . y , tmp . x , tmp . y , NULL ) ; }
","<S2SV_ModStart> curve ) { if ( pointZZ_pIsIdentityElement ( point ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; }
",AntonKueltz@fastecdsa/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,CVE-2020-12607,https://github.com/AntonKueltz/fastecdsa/commit/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,2020-06-02T21:15Z,"<S2SV_StartBug> void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) { <S2SV_EndBug>"
2576,CWE-000,"int main ( int argc , char * argv [ ] ) { OM_uint32 minor , major ; gss_ctx_id_t context ; gss_union_ctx_id_desc uctx ; krb5_gss_ctx_id_rec kgctx ; krb5_key k1 , k2 ; krb5_keyblock kb1 , kb2 ; gss_buffer_desc in , out ; unsigned char k1buf [ 32 ] , k2buf [ 32 ] , outbuf [ 44 ] ; size_t i ; context = ( gss_ctx_id_t ) & uctx ; uctx . mech_type = & mech_krb5 ; uctx . internal_ctx_id = ( gss_ctx_id_t ) & kgctx ; kgctx . k5_context = NULL ; <S2SV_StartBug> kgctx . have_acceptor_subkey = 1 ; <S2SV_EndBug> kb1 . contents = k1buf ; kb2 . contents = k2buf ; for ( i = 0 ; i < sizeof ( tests ) / sizeof ( * tests ) ; i ++ ) { kb1 . enctype = tests [ i ] . enctype ; kb1 . length = fromhex ( tests [ i ] . key1 , k1buf ) ; check_k5err ( NULL , ""create_key"" , krb5_k_create_key ( NULL , & kb1 , & k1 ) ) ; kgctx . subkey = k1 ; kb2 . enctype = tests [ i ] . enctype ; kb2 . length = fromhex ( tests [ i ] . key2 , k2buf ) ; check_k5err ( NULL , ""create_key"" , krb5_k_create_key ( NULL , & kb2 , & k2 ) ) ; kgctx . acceptor_subkey = k2 ; in . length = 0 ; in . value = NULL ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_PARTIAL , & in , 44 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; ( void ) fromhex ( tests [ i ] . out1 , outbuf ) ; assert ( out . length == 44 && memcmp ( out . value , outbuf , 44 ) == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; in . length = strlen ( inputstr ) ; in . value = ( char * ) inputstr ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_FULL , & in , 44 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; ( void ) fromhex ( tests [ i ] . out2 , outbuf ) ; assert ( out . length == 44 && memcmp ( out . value , outbuf , 44 ) == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_FULL , & in , 0 , & out ) ; check_gsserr ( ""gss_pseudo_random"" , major , minor ) ; assert ( out . length == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; krb5_k_free_key ( NULL , k1 ) ; krb5_k_free_key ( NULL , k2 ) ; } return 0 ; }
","<S2SV_ModStart> ; kgctx . established = 1 ; kgctx .
",krb5@krb5/82dc33da50338ac84c7b4102dc6513d897d0506a,CVE-2014-5352,https://github.com/krb5/krb5/commit/82dc33da50338ac84c7b4102dc6513d897d0506a,2015-02-19T11:59Z,<S2SV_StartBug> kgctx . have_acceptor_subkey = 1 ; <S2SV_EndBug>
2459,CWE-404,"static int cp2112_gpio_get_all ( struct gpio_chip * chip ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> int ret ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_GET_LENGTH ) { hid_err ( hdev , ""error<S2SV_blank>requesting<S2SV_blank>GPIO<S2SV_blank>values:<S2SV_blank>%d\\n"" , ret ) ; ret = ret < 0 ? ret : - EIO ; goto exit ; } ret = buf [ 1 ] ; exit : <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> ; exit : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
",torvalds@linux/7a7b5df84b6b4e5d599c7289526eed96541a0654,CVE-2017-8071,https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654,2017-04-23T05:59Z,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug>"
99,CWE-189,"int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { size_t tail = ( i << 1 ) + 1 ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail ) ; q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; <S2SV_StartBug> if ( q > e ) { <S2SV_EndBug> DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements && i < sh . sh_properties ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
","<S2SV_ModStart> if ( q < p ) { DPRINTF ( ( ""Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\n"" , q , p ) ) ; goto out ; } if ( q
",file@file/0641e56be1af003aa02c7c6b0184466540637233,CVE-2014-3587,https://github.com/file/file/commit/0641e56be1af003aa02c7c6b0184466540637233,2014-08-23T01:55Z,<S2SV_StartBug> if ( q > e ) { <S2SV_EndBug>
1935,CWE-119,"<S2SV_StartBug> static vpx_codec_err_t ctrl_set_svc ( vpx_codec_alg_priv_t * ctx , int ctr_id , <S2SV_EndBug> va_list args ) { int data = va_arg ( args , int ) ; const vpx_codec_enc_cfg_t * cfg = & ctx -> cfg ; vp9_set_svc ( ctx -> cpi , data ) ; if ( data == 1 && <S2SV_StartBug> ( cfg -> rc_end_usage == VPX_CBR || <S2SV_EndBug> cfg -> g_pass == VPX_RC_FIRST_PASS || cfg -> g_pass == VPX_RC_LAST_PASS ) && cfg -> ss_number_layers > 1 && cfg -> ts_number_layers > 1 ) { return VPX_CODEC_INVALID_PARAM ; } return VPX_CODEC_OK ; }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> ( cfg -> <S2SV_ModEnd> g_pass == VPX_RC_FIRST_PASS
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static vpx_codec_err_t ctrl_set_svc ( vpx_codec_alg_priv_t * ctx , int ctr_id , <S2SV_EndBug> <S2SV_StartBug> ( cfg -> rc_end_usage == VPX_CBR || <S2SV_EndBug>"
2401,CWE-89,"static CURLcode imap_parse_url_path ( struct connectdata * conn ) { struct imap_conn * imapc = & conn -> proto . imapc ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <S2SV_StartBug> int len ; <S2SV_EndBug> if ( ! * path ) path = ""INBOX"" ; <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }
","<S2SV_ModStart> . path ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> = ""INBOX"" ; return Curl_urldecode <S2SV_ModEnd> ( data , <S2SV_ModStart> 0 , & <S2SV_ModEnd> imapc -> mailbox <S2SV_ModStart> imapc -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null>
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,"<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug>"
7168,CWE-552,"static ssize_t _consolefs_read ( oe_fd_t * file_ , void * buf , size_t count ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( file_ ) ; <S2SV_StartBug> if ( ! file ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_syscall_read_ocall ( & ret , file -> host_fd , buf , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> ( ! file || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,<S2SV_StartBug> if ( ! file ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug>
3405,CWE-404,"int nfsd_cross_mnt ( struct svc_rqst * rqstp , struct dentry * * dpp , struct svc_export * * expp ) { struct svc_export * exp = * expp , * exp2 = NULL ; struct dentry * dentry = * dpp ; struct path path = { . mnt = mntget ( exp -> ex_path . mnt ) , . dentry = dget ( dentry ) } ; int err = 0 ; err = follow_down ( & path ) ; if ( err < 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> exp2 = rqst_exp_get_by_name ( rqstp , & path ) ; if ( IS_ERR ( exp2 ) ) { err = PTR_ERR ( exp2 ) ; if ( err == - ENOENT && ! ( exp -> ex_flags & NFSEXP_V4ROOT ) ) err = 0 ; path_put ( & path ) ; goto out ; } if ( nfsd_v4client ( rqstp ) || ( exp -> ex_flags & NFSEXP_CROSSMOUNT ) || EX_NOHIDE ( exp2 ) ) { * dpp = path . dentry ; path . dentry = dentry ; * expp = exp2 ; exp2 = exp ; } path_put ( & path ) ; exp_put ( exp2 ) ; out : return err ; }
","<S2SV_ModStart> goto out ; if ( path . mnt == exp -> ex_path . mnt && path . dentry == dentry && nfsd_mountpoint ( dentry , exp ) == 2 ) { path_put ( & path ) ; goto out ; }
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z,<S2SV_StartBug> goto out ; <S2SV_EndBug>
43,CWE-834,"static MagickBooleanType ReadPSDLayersInternal ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , const MagickBooleanType skip_layers , ExceptionInfo * exception ) { char type [ 4 ] ; LayerInfo * layer_info ; MagickSizeType size ; MagickBooleanType status ; register ssize_t i ; ssize_t count , j , number_layers ; size = GetPSDSize ( psd_info , image ) ; if ( size == 0 ) { ( void ) ReadBlobLong ( image ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; status = MagickFalse ; if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) return ( MagickTrue ) ; else { count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count != 0 ) && ( LocaleNCompare ( type , ""Lr16"" , 4 ) == 0 ) ) size = GetPSDSize ( psd_info , image ) ; else return ( MagickTrue ) ; } } status = MagickTrue ; if ( size != 0 ) { layer_info = ( LayerInfo * ) NULL ; number_layers = ( short ) ReadBlobShort ( image ) ; if ( number_layers < 0 ) { number_layers = MagickAbsoluteValue ( number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>negative<S2SV_blank>layer<S2SV_blank>count<S2SV_blank>corrected<S2SV_blank>for"" ) ; image -> alpha_trait = BlendPixelTrait ; } if ( skip_layers != MagickFalse ) return ( MagickTrue ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>image<S2SV_blank>contains<S2SV_blank>%.20g<S2SV_blank>layers"" , ( double ) number_layers ) ; if ( number_layers == 0 ) ThrowBinaryException ( CorruptImageError , ""InvalidNumberOfLayers"" , image -> filename ) ; layer_info = ( LayerInfo * ) AcquireQuantumMemory ( ( size_t ) number_layers , sizeof ( * layer_info ) ) ; if ( layer_info == ( LayerInfo * ) NULL ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>LayerInfo<S2SV_blank>failed"" ) ; ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; } ( void ) ResetMagickMemory ( layer_info , 0 , ( size_t ) number_layers * sizeof ( * layer_info ) ) ; for ( i = 0 ; i < number_layers ; i ++ ) { ssize_t x , y ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>layer<S2SV_blank>#%.20g"" , ( double ) i + 1 ) ; layer_info [ i ] . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . x = ReadBlobSignedLong ( image ) ; y = ReadBlobSignedLong ( image ) ; x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . width = ( size_t ) ( x - layer_info [ i ] . page . x ) ; layer_info [ i ] . page . height = ( size_t ) ( y - layer_info [ i ] . page . y ) ; layer_info [ i ] . channels = ReadBlobShort ( image ) ; if ( layer_info [ i ] . channels > MaxPSDChannels ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""MaximumChannelsExceeded"" , image -> filename ) ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>channels=%.20g"" , ( double ) layer_info [ i ] . page . x , ( double ) layer_info [ i ] . page . y , ( double ) layer_info [ i ] . page . height , ( double ) layer_info [ i ] . page . width , ( double ) layer_info [ i ] . channels ) ; for ( j = 0 ; j < ( ssize_t ) layer_info [ i ] . channels ; j ++ ) { layer_info [ i ] . channel_info [ j ] . type = ( short ) ReadBlobShort ( image ) ; layer_info [ i ] . channel_info [ j ] . size = ( size_t ) GetPSDSize ( psd_info , image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>channel[%.20g]:<S2SV_blank>type=%.20g,<S2SV_blank>size=%.20g"" , ( double ) j , ( double ) layer_info [ i ] . channel_info [ j ] . type , ( double ) layer_info [ i ] . channel_info [ j ] . size ) ; } count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>layer<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%.4s<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>8BIM"" , type ) ; layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""ImproperImageHeader"" , image -> filename ) ; } count = ReadBlob ( image , 4 , ( unsigned char * ) layer_info [ i ] . blendkey ) ; ReversePSDString ( image , layer_info [ i ] . blendkey , 4 ) ; layer_info [ i ] . opacity = ( Quantum ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; layer_info [ i ] . clipping = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . flags = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . visible = ! ( layer_info [ i ] . flags & 0x02 ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>blend=%.4s,<S2SV_blank>opacity=%.20g,<S2SV_blank>clipping=%s,<S2SV_blank>flags=%d,<S2SV_blank>visible=%s"" , layer_info [ i ] . blendkey , ( double ) layer_info [ i ] . opacity , layer_info [ i ] . clipping ? ""true"" : ""false"" , layer_info [ i ] . flags , layer_info [ i ] . visible ? ""true"" : ""false"" ) ; ( void ) ReadBlobByte ( image ) ; size = ReadBlobLong ( image ) ; if ( size != 0 ) { MagickSizeType combined_length , length ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>contains<S2SV_blank>additional<S2SV_blank>info"" ) ; length = ReadBlobLong ( image ) ; combined_length = length + 4 ; if ( length != 0 ) { layer_info [ i ] . mask . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . height = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . y ) ; layer_info [ i ] . mask . page . width = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . x ) ; layer_info [ i ] . mask . background = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . mask . flags = ( unsigned char ) ReadBlobByte ( image ) ; if ( ! ( layer_info [ i ] . mask . flags & 0x01 ) ) { layer_info [ i ] . mask . page . y = layer_info [ i ] . mask . page . y - layer_info [ i ] . page . y ; layer_info [ i ] . mask . page . x = layer_info [ i ] . mask . page . x - layer_info [ i ] . page . x ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>mask:<S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>length=%.20g"" , ( double ) layer_info [ i ] . mask . page . x , ( double ) layer_info [ i ] . mask . page . y , ( double ) layer_info [ i ] . mask . page . width , ( double ) layer_info [ i ] . mask . page . height , ( double ) ( ( MagickOffsetType ) length ) - 18 ) ; if ( DiscardBlobBytes ( image , ( MagickSizeType ) ( length - 18 ) ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } length = ReadBlobLong ( image ) ; combined_length += length + 4 ; if ( length != 0 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>blending<S2SV_blank>ranges:<S2SV_blank>length=%.20g"" , ( double ) ( ( MagickOffsetType ) length ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) length ; j += 8 ) <S2SV_EndBug> { size_t blend_source = ReadBlobLong ( image ) ; size_t blend_dest = ReadBlobLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , <S2SV_StartBug> ""InsufficientImageDataInFile"" , image -> filename ) ; <S2SV_EndBug> } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)"" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ; } } length = ( MagickSizeType ) ( unsigned char ) ReadBlobByte ( image ) ; combined_length += length + 1 ; if ( length > 0 ) ( void ) ReadBlob ( image , ( size_t ) length ++ , layer_info [ i ] . name ) ; layer_info [ i ] . name [ length ] = '\\0' ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>name:<S2SV_blank>%s"" , layer_info [ i ] . name ) ; if ( ( length % 4 ) != 0 ) { length = 4 - ( length % 4 ) ; combined_length += length ; if ( DiscardBlobBytes ( image , length ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } length = ( MagickSizeType ) size - combined_length ; if ( length > 0 ) { unsigned char * info ; if ( length > GetBlobSize ( image ) ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ; } layer_info [ i ] . info = AcquireStringInfo ( ( const size_t ) length ) ; info = GetStringInfoDatum ( layer_info [ i ] . info ) ; ( void ) ReadBlob ( image , ( const size_t ) length , info ) ; } } } for ( i = 0 ; i < number_layers ; i ++ ) { if ( ( layer_info [ i ] . page . width == 0 ) || ( layer_info [ i ] . page . height == 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>data<S2SV_blank>is<S2SV_blank>empty"" ) ; if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; continue ; } layer_info [ i ] . image = CloneImage ( image , layer_info [ i ] . page . width , layer_info [ i ] . page . height , MagickFalse , exception ) ; if ( layer_info [ i ] . image == ( Image * ) NULL ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>image<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g<S2SV_blank>failed"" , ( double ) i ) ; ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; } if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) { ( void ) SetImageProfile ( layer_info [ i ] . image , ""psd:additional-info"" , layer_info [ i ] . info , exception ) ; layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; } } if ( image_info -> ping == MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = 0 ; j < layer_info [ i ] . channels ; j ++ ) { if ( DiscardBlobBytes ( image , ( MagickSizeType ) layer_info [ i ] . channel_info [ j ] . size ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } continue ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>data<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g"" , ( double ) i ) ; status = ReadPSDLayer ( image , image_info , psd_info , & layer_info [ i ] , exception ) ; if ( status == MagickFalse ) break ; status = SetImageProgress ( image , LoadImagesTag , i , ( MagickSizeType ) number_layers ) ; if ( status == MagickFalse ) break ; } } if ( status != MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = i ; j < number_layers - 1 ; j ++ ) layer_info [ j ] = layer_info [ j + 1 ] ; number_layers -- ; i -- ; } } if ( number_layers > 0 ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( i > 0 ) layer_info [ i ] . image -> previous = layer_info [ i - 1 ] . image ; if ( i < ( number_layers - 1 ) ) layer_info [ i ] . image -> next = layer_info [ i + 1 ] . image ; layer_info [ i ] . image -> page = layer_info [ i ] . page ; } image -> next = layer_info [ 0 ] . image ; layer_info [ 0 ] . image -> previous = image ; } layer_info = ( LayerInfo * ) RelinquishMagickMemory ( layer_info ) ; } else layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; } return ( status ) ; }
","<S2SV_ModStart> ) ) ; if ( DiscardBlobBytes ( image , length ) == <S2SV_ModEnd> MagickFalse ) { <S2SV_ModStart> ( CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModEnd> , image -> <S2SV_ModStart> image -> filename <S2SV_ModEnd> ) ; }
",ImageMagick@ImageMagick/04a567494786d5bb50894fc8bb8fea0cf496bea8,CVE-2017-14174,https://github.com/ImageMagick/ImageMagick/commit/04a567494786d5bb50894fc8bb8fea0cf496bea8,2017-09-07T06:29Z,"<S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) length ; j += 8 ) <S2SV_EndBug> <S2SV_StartBug> ""InsufficientImageDataInFile"" , image -> filename ) ; <S2SV_EndBug>"
2789,CWE-000,"bgp_size_t bgp_packet_attribute ( struct bgp * bgp , struct peer * peer , struct stream * s , struct attr * attr , struct bpacket_attr_vec_arr * vecarr , struct prefix * p , afi_t afi , safi_t safi , struct peer * from , struct prefix_rd * prd , mpls_label_t * label , uint32_t num_labels , int addpath_encode , uint32_t addpath_tx_id ) { size_t cp ; size_t aspath_sizep ; struct aspath * aspath ; int send_as4_path = 0 ; int send_as4_aggregator = 0 ; int use32bit = ( CHECK_FLAG ( peer -> cap , PEER_CAP_AS4_RCV ) ) ? 1 : 0 ; if ( ! bgp ) bgp = peer -> bgp ; cp = stream_get_endp ( s ) ; if ( p && ! ( ( afi == AFI_IP && safi == SAFI_UNICAST ) && ! peer_cap_enhe ( peer , afi , safi ) ) ) { size_t mpattrlen_pos = 0 ; mpattrlen_pos = bgp_packet_mpattr_start ( s , peer , afi , safi , vecarr , attr ) ; bgp_packet_mpattr_prefix ( s , afi , safi , p , prd , label , num_labels , addpath_encode , addpath_tx_id , attr ) ; bgp_packet_mpattr_end ( s , mpattrlen_pos ) ; } stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_ORIGIN ) ; stream_putc ( s , 1 ) ; stream_putc ( s , attr -> origin ) ; if ( peer -> sort == BGP_PEER_EBGP && ( ! CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_AS_PATH_UNCHANGED ) || attr -> aspath -> segments == NULL ) && ( ! CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_RSERVER_CLIENT ) ) ) { aspath = aspath_dup ( attr -> aspath ) ; aspath = aspath_delete_confed_seq ( aspath ) ; if ( CHECK_FLAG ( bgp -> config , BGP_CONFIG_CONFEDERATION ) ) { aspath = aspath_add_seq ( aspath , bgp -> confed_id ) ; } else { if ( peer -> change_local_as ) { if ( ! CHECK_FLAG ( peer -> flags , PEER_FLAG_LOCAL_AS_REPLACE_AS ) ) { aspath = aspath_add_seq ( aspath , peer -> local_as ) ; } aspath = aspath_add_seq ( aspath , peer -> change_local_as ) ; } else { aspath = aspath_add_seq ( aspath , peer -> local_as ) ; } } } else if ( peer -> sort == BGP_PEER_CONFED ) { aspath = aspath_dup ( attr -> aspath ) ; aspath = aspath_add_confed_seq ( aspath , peer -> local_as ) ; } else aspath = attr -> aspath ; stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_AS_PATH ) ; aspath_sizep = stream_get_endp ( s ) ; stream_putw ( s , 0 ) ; stream_putw_at ( s , aspath_sizep , aspath_put ( s , aspath , use32bit ) ) ; if ( ! use32bit && aspath_has_as4 ( aspath ) ) send_as4_path = 1 ; if ( afi == AFI_IP && safi == SAFI_UNICAST && ! peer_cap_enhe ( peer , afi , safi ) ) { if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_NEXT_HOP ) ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_NEXT_HOP ) ; bpacket_attr_vec_arr_set_vec ( vecarr , BGP_ATTR_VEC_NH , s , attr ) ; stream_putc ( s , 4 ) ; stream_put_ipv4 ( s , attr -> nexthop . s_addr ) ; } else if ( peer_cap_enhe ( from , afi , safi ) ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_NEXT_HOP ) ; bpacket_attr_vec_arr_set_vec ( vecarr , BGP_ATTR_VEC_NH , s , NULL ) ; stream_putc ( s , 4 ) ; stream_put_ipv4 ( s , 0 ) ; } } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_MULTI_EXIT_DISC ) || bgp -> maxmed_active ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , BGP_ATTR_MULTI_EXIT_DISC ) ; stream_putc ( s , 4 ) ; stream_putl ( s , ( bgp -> maxmed_active ? bgp -> maxmed_value : attr -> med ) ) ; } if ( peer -> sort == BGP_PEER_IBGP || peer -> sort == BGP_PEER_CONFED ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_LOCAL_PREF ) ; stream_putc ( s , 4 ) ; stream_putl ( s , attr -> local_pref ) ; } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_ATOMIC_AGGREGATE ) ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_ATOMIC_AGGREGATE ) ; stream_putc ( s , 0 ) ; } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_AGGREGATOR ) ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_AGGREGATOR ) ; if ( use32bit ) { stream_putc ( s , 8 ) ; stream_putl ( s , attr -> aggregator_as ) ; } else { stream_putc ( s , 6 ) ; if ( attr -> aggregator_as > 65535 ) { stream_putw ( s , BGP_AS_TRANS ) ; send_as4_aggregator = 1 ; } else stream_putw ( s , ( uint16_t ) attr -> aggregator_as ) ; } stream_put_ipv4 ( s , attr -> aggregator_addr . s_addr ) ; } if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_SEND_COMMUNITY ) && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_COMMUNITIES ) ) ) { if ( attr -> community -> size * 4 > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_COMMUNITIES ) ; stream_putw ( s , attr -> community -> size * 4 ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_COMMUNITIES ) ; stream_putc ( s , attr -> community -> size * 4 ) ; } stream_put ( s , attr -> community -> val , attr -> community -> size * 4 ) ; } if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_SEND_LARGE_COMMUNITY ) && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_LARGE_COMMUNITIES ) ) ) { if ( lcom_length ( attr -> lcommunity ) > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_LARGE_COMMUNITIES ) ; stream_putw ( s , lcom_length ( attr -> lcommunity ) ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_LARGE_COMMUNITIES ) ; stream_putc ( s , lcom_length ( attr -> lcommunity ) ) ; } stream_put ( s , attr -> lcommunity -> val , lcom_length ( attr -> lcommunity ) ) ; } if ( peer -> sort == BGP_PEER_IBGP && from && from -> sort == BGP_PEER_IBGP ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , BGP_ATTR_ORIGINATOR_ID ) ; stream_putc ( s , 4 ) ; if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_ORIGINATOR_ID ) ) stream_put_in_addr ( s , & attr -> originator_id ) ; else stream_put_in_addr ( s , & from -> remote_id ) ; stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , BGP_ATTR_CLUSTER_LIST ) ; if ( attr -> cluster ) { stream_putc ( s , attr -> cluster -> length + 4 ) ; if ( bgp -> config & BGP_CONFIG_CLUSTER_ID ) stream_put_in_addr ( s , & bgp -> cluster_id ) ; else stream_put_in_addr ( s , & bgp -> router_id ) ; stream_put ( s , attr -> cluster -> list , attr -> cluster -> length ) ; } else { stream_putc ( s , 4 ) ; if ( bgp -> config & BGP_CONFIG_CLUSTER_ID ) stream_put_in_addr ( s , & bgp -> cluster_id ) ; else stream_put_in_addr ( s , & bgp -> router_id ) ; } } if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_SEND_EXT_COMMUNITY ) && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_EXT_COMMUNITIES ) ) ) { if ( peer -> sort == BGP_PEER_IBGP || peer -> sort == BGP_PEER_CONFED ) { if ( attr -> ecommunity -> size * 8 > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putw ( s , attr -> ecommunity -> size * 8 ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putc ( s , attr -> ecommunity -> size * 8 ) ; } stream_put ( s , attr -> ecommunity -> val , attr -> ecommunity -> size * 8 ) ; } else { uint8_t * pnt ; int tbit ; int ecom_tr_size = 0 ; int i ; for ( i = 0 ; i < attr -> ecommunity -> size ; i ++ ) { pnt = attr -> ecommunity -> val + ( i * 8 ) ; tbit = * pnt ; if ( CHECK_FLAG ( tbit , ECOMMUNITY_FLAG_NON_TRANSITIVE ) ) continue ; ecom_tr_size ++ ; } if ( ecom_tr_size ) { if ( ecom_tr_size * 8 > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putw ( s , ecom_tr_size * 8 ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putc ( s , ecom_tr_size * 8 ) ; } for ( i = 0 ; i < attr -> ecommunity -> size ; i ++ ) { pnt = attr -> ecommunity -> val + ( i * 8 ) ; tbit = * pnt ; if ( CHECK_FLAG ( tbit , ECOMMUNITY_FLAG_NON_TRANSITIVE ) ) continue ; stream_put ( s , pnt , 8 ) ; } } } } if ( safi == SAFI_LABELED_UNICAST ) { if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_PREFIX_SID ) ) { uint32_t label_index ; label_index = attr -> label_index ; if ( label_index != BGP_INVALID_LABEL_INDEX ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_PREFIX_SID ) ; stream_putc ( s , 10 ) ; stream_putc ( s , BGP_PREFIX_SID_LABEL_INDEX ) ; stream_putw ( s , BGP_PREFIX_SID_LABEL_INDEX_LENGTH ) ; stream_putc ( s , 0 ) ; stream_putw ( s , 0 ) ; stream_putl ( s , label_index ) ; } } } if ( send_as4_path ) { aspath = aspath_delete_confed_seq ( aspath ) ; stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_AS4_PATH ) ; aspath_sizep = stream_get_endp ( s ) ; stream_putw ( s , 0 ) ; stream_putw_at ( s , aspath_sizep , aspath_put ( s , aspath , 1 ) ) ; } if ( aspath != attr -> aspath ) aspath_free ( aspath ) ; if ( send_as4_aggregator ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_AS4_AGGREGATOR ) ; stream_putc ( s , 8 ) ; stream_putl ( s , attr -> aggregator_as ) ; stream_put_ipv4 ( s , attr -> aggregator_addr . s_addr ) ; } if ( ( ( afi == AFI_IP || afi == AFI_IP6 ) && ( safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN ) ) || ( afi == AFI_L2VPN && safi == SAFI_EVPN ) ) { bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_ENCAP ) ; <S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ; # endif } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_PMSI_TUNNEL ) ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_PMSI_TUNNEL ) ; stream_putc ( s , 9 ) ; stream_putc ( s , 0 ) ; stream_putc ( s , PMSI_TNLTYPE_INGR_REPL ) ; stream_put ( s , & ( attr -> label ) , BGP_LABEL_BYTES ) ; stream_put_ipv4 ( s , attr -> nexthop . s_addr ) ; } if ( attr -> transit ) stream_put ( s , attr -> transit -> val , attr -> transit -> length ) ; return stream_get_endp ( s ) - cp ; }
","<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> bgp_packet_mpattr_tea ( bgp
",FRRouting@frr/943d595a018e69b550db08cccba1d0778a86705a,CVE-2019-5892,https://github.com/FRRouting/frr/commit/943d595a018e69b550db08cccba1d0778a86705a,2019-01-10T17:29Z,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug>
2930,CWE-416,"int blk_rq_map_user_iov ( struct request_queue * q , struct request * rq , struct rq_map_data * map_data , const struct iov_iter * iter , gfp_t gfp_mask ) { bool copy = false ; unsigned long align = q -> dma_pad_mask | queue_dma_alignment ( q ) ; struct bio * bio = NULL ; struct iov_iter i ; int ret ; <S2SV_StartBug> if ( map_data ) <S2SV_EndBug> copy = true ; else if ( iov_iter_alignment ( iter ) & align ) copy = true ; else if ( queue_virt_boundary ( q ) ) copy = queue_virt_boundary ( q ) & iov_iter_gap_alignment ( iter ) ; i = * iter ; do { ret = __blk_rq_map_user_iov ( rq , map_data , & i , gfp_mask , copy ) ; if ( ret ) goto unmap_rq ; if ( ! bio ) bio = rq -> bio ; } while ( iov_iter_count ( & i ) ) ; if ( ! bio_flagged ( bio , BIO_USER_MAPPED ) ) rq -> cmd_flags |= REQ_COPY_USER ; return 0 ; unmap_rq : __blk_rq_unmap_user ( bio ) ; <S2SV_StartBug> rq -> bio = NULL ; <S2SV_EndBug> return - EINVAL ; }
","<S2SV_ModStart> ; if ( ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> bio ) ; fail :
",torvalds@linux/a0ac402cfcdc904f9772e1762b3fda112dcc56a0,CVE-2016-9576,https://github.com/torvalds/linux/commit/a0ac402cfcdc904f9772e1762b3fda112dcc56a0,2016-12-28T07:59Z,<S2SV_StartBug> if ( map_data ) <S2SV_EndBug> <S2SV_StartBug> rq -> bio = NULL ; <S2SV_EndBug>
2745,CWE-119,"void pid_ns_release_proc ( struct pid_namespace * ns ) { <S2SV_StartBug> mntput ( ns -> proc_mnt ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ns ) { kern_unmount <S2SV_ModEnd> ( ns ->
",torvalds@linux/905ad269c55fc62bee3da29f7b1d1efeba8aa1e1,CVE-2012-2127,https://github.com/torvalds/linux/commit/905ad269c55fc62bee3da29f7b1d1efeba8aa1e1,2012-06-21T23:55Z,<S2SV_StartBug> mntput ( ns -> proc_mnt ) ; <S2SV_EndBug>
6415,CWE-399,"void mono_reflection_create_dynamic_method ( MonoReflectionDynamicMethod * mb ) { <S2SV_StartBug> ReflectionMethodBuilder rmb ; <S2SV_EndBug> MonoMethodSignature * sig ; MonoClass * klass ; GSList * l ; <S2SV_StartBug> int i ; <S2SV_EndBug> sig = dynamic_method_to_signature ( mb ) ; reflection_methodbuilder_from_dynamic_method ( & rmb , mb ) ; rmb . nrefs = mb -> nrefs ; rmb . refs = g_new0 ( gpointer , mb -> nrefs + 1 ) ; for ( i = 0 ; i < mb -> nrefs ; i += 2 ) { MonoClass * handle_class ; gpointer ref ; MonoObject * obj = mono_array_get ( mb -> refs , MonoObject * , i ) ; if ( strcmp ( obj -> vtable -> klass -> name , ""DynamicMethod"" ) == 0 ) { MonoReflectionDynamicMethod * method = ( MonoReflectionDynamicMethod * ) obj ; if ( method -> mhandle ) { ref = method -> mhandle ; } else { ref = method ; method -> referenced_by = g_slist_append ( method -> referenced_by , mb ) ; } handle_class = mono_defaults . methodhandle_class ; } else { MonoException * ex = NULL ; ref = resolve_object ( mb -> module -> image , obj , & handle_class , NULL ) ; if ( ! ref ) ex = mono_get_exception_type_load ( NULL , NULL ) ; else if ( mono_security_get_mode ( ) == MONO_SECURITY_MODE_CORE_CLR ) ex = mono_security_core_clr_ensure_dynamic_method_resolved_object ( ref , handle_class ) ; if ( ex ) { g_free ( rmb . refs ) ; mono_raise_exception ( ex ) ; return ; } } rmb . refs [ i ] = ref ; rmb . refs [ i + 1 ] = handle_class ; } klass = mb -> owner ? mono_class_from_mono_type ( mono_reflection_type_get_handle ( ( MonoReflectionType * ) mb -> owner ) ) : mono_defaults . object_class ; <S2SV_StartBug> mb -> mhandle = reflection_methodbuilder_to_mono_method ( klass , & rmb , sig ) ; <S2SV_EndBug> for ( l = mb -> referenced_by ; l ; l = l -> next ) { MonoReflectionDynamicMethod * method = ( MonoReflectionDynamicMethod * ) l -> data ; MonoMethodWrapper * wrapper = ( MonoMethodWrapper * ) method -> mhandle ; gpointer * data ; g_assert ( method -> mhandle ) ; data = ( gpointer * ) wrapper -> method_data ; for ( i = 0 ; i < GPOINTER_TO_UINT ( data [ 0 ] ) ; i += 2 ) { if ( ( data [ i + 1 ] == mb ) && ( data [ i + 1 + 1 ] == mono_defaults . methodhandle_class ) ) data [ i + 1 ] = mb -> mhandle ; } } g_slist_free ( mb -> referenced_by ) ; g_free ( rmb . refs ) ; mb -> ilgen = NULL ; }
","<S2SV_ModStart> mb ) { MonoReferenceQueue * queue ; MonoMethod * handle ; DynamicMethodReleaseData * release_data ; <S2SV_ModStart> int i ; if ( mono_runtime_is_shutting_down ( ) ) mono_raise_exception ( mono_get_exception_invalid_operation ( """" ) ) ; if ( ! ( queue = dynamic_method_queue ) ) { mono_loader_lock ( ) ; if ( ! ( queue = dynamic_method_queue ) ) queue = dynamic_method_queue = mono_gc_reference_queue_new ( free_dynamic_method ) ; mono_loader_unlock ( ) ; } <S2SV_ModStart> -> mhandle = handle = <S2SV_ModStart> rmb , sig ) ; release_data = g_new ( DynamicMethodReleaseData , 1 ) ; release_data -> handle = handle ; release_data -> domain = mono_object_get_domain ( ( MonoObject * ) mb ) ; if ( ! mono_gc_reference_queue_add ( queue , ( MonoObject * ) mb , release_data ) ) g_free ( release_data
",mono@mono/89d1455a80ef13cddee5d79ec00c06055da3085c,CVE-2011-0991,https://github.com/mono/mono/commit/89d1455a80ef13cddee5d79ec00c06055da3085c,2011-04-13T21:55Z,"<S2SV_StartBug> ReflectionMethodBuilder rmb ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> mb -> mhandle = reflection_methodbuilder_to_mono_method ( klass , & rmb , sig ) ; <S2SV_EndBug>"
3763,CWE-119,"static int udf_read_inode ( struct inode * inode , bool hidden_inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; struct kernel_lb_addr * iloc = & iinfo -> i_location ; unsigned int link_count ; unsigned int indirections = 0 ; int ret = - EIO ; reread : if ( iloc -> logicalBlockNum >= sbi -> s_partmaps [ iloc -> partitionReferenceNum ] . s_partition_len ) { udf_debug ( ""block=%d,<S2SV_blank>partition=%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , iloc -> logicalBlockNum , iloc -> partitionReferenceNum ) ; return - EIO ; } bh = udf_read_ptagged ( inode -> i_sb , iloc , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n"" , inode -> i_ino ) ; return - EIO ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; goto out ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , iloc , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) { struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; if ( ie -> indirectICB . extLength ) { brelse ( ibh ) ; memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; goto out ; } brelse ( bh ) ; goto reread ; } } brelse ( ibh ) ; } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n"" , le16_to_cpu ( fe -> icbTag . strategyType ) ) ; goto out ; } if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & ICBTAG_FLAG_AD_MASK ; iinfo -> i_unique = 0 ; iinfo -> i_lenEAttr = 0 ; iinfo -> i_lenExtents = 0 ; iinfo -> i_lenAlloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenAlloc = le32_to_cpu ( ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> lengthAllocDescs ) ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocSpaceEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; return 0 ; } ret = - EIO ; read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_fmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_dmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> fileLinkCount ) ; if ( ! link_count ) { if ( ! hidden_inode ) { ret = - ESTALE ; goto out ; } link_count = 1 ; } set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; iinfo -> i_lenExtents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } inode -> i_generation = iinfo -> i_unique ; <S2SV_StartBug> switch ( fe -> icbTag . fileType ) { <S2SV_EndBug> case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= S_IFDIR ; inc_nlink ( inode ) ; break ; case ICBTAG_FILE_TYPE_REALTIME : case ICBTAG_FILE_TYPE_REGULAR : case ICBTAG_FILE_TYPE_UNDEF : case ICBTAG_FILE_TYPE_VAT20 : if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= S_IFREG ; break ; case ICBTAG_FILE_TYPE_BLOCK : inode -> i_mode |= S_IFBLK ; break ; case ICBTAG_FILE_TYPE_CHAR : inode -> i_mode |= S_IFCHR ; break ; case ICBTAG_FILE_TYPE_FIFO : init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; break ; case ICBTAG_FILE_TYPE_SOCKET : init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; break ; case ICBTAG_FILE_TYPE_SYMLINK : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = S_IFLNK | S_IRWXUGO ; break ; case ICBTAG_FILE_TYPE_MAIN : udf_debug ( ""METADATA<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_MIRROR : udf_debug ( ""METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_BITMAP : udf_debug ( ""METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n"" , inode -> i_ino , fe -> icbTag . fileType ) ; goto out ; } if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { struct deviceSpec * dsea = ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; } else goto out ; } ret = 0 ; out : brelse ( bh ) ; return ret ; }
","<S2SV_ModStart> -> i_unique ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; }
",torvalds@linux/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,CVE-2014-9728,https://github.com/torvalds/linux/commit/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,2015-08-31T10:59Z,<S2SV_StartBug> switch ( fe -> icbTag . fileType ) { <S2SV_EndBug>
3636,CWE-74,"static int einj_error_inject ( u32 type , u32 flags , u64 param1 , u64 param2 , u64 param3 , u64 param4 ) { int rc ; <S2SV_StartBug> u64 base_addr , size ; <S2SV_EndBug> if ( flags && ( flags & ~ ( SETWA_FLAGS_APICID | SETWA_FLAGS_MEM | SETWA_FLAGS_PCIE_SBDF ) ) ) return - EINVAL ; if ( ! ( param_extension || acpi5 ) ) goto inject ; if ( type & ACPI5_VENDOR_BIT ) { if ( vendor_flags != SETWA_FLAGS_MEM ) goto inject ; } else if ( ! ( type & MEM_ERROR_MASK ) && ! ( flags & SETWA_FLAGS_MEM ) ) goto inject ; base_addr = param1 & param2 ; size = ~ param2 + 1 ; if ( ( ( param2 & PAGE_MASK ) != PAGE_MASK ) || ( ( region_intersects ( base_addr , size , IORESOURCE_SYSTEM_RAM , IORES_DESC_NONE ) != REGION_INTERSECTS ) && ( region_intersects ( base_addr , size , IORESOURCE_MEM , IORES_DESC_PERSISTENT_MEMORY ) != REGION_INTERSECTS ) ) ) return - EINVAL ; inject : mutex_lock ( & einj_mutex ) ; rc = __einj_error_inject ( type , flags , param1 , param2 , param3 , param4 ) ; mutex_unlock ( & einj_mutex ) ; return rc ; }
","<S2SV_ModStart> base_addr , size ; if ( get_securelevel ( ) > 0 ) return - EPERM
",mjg59@linux/d7a6be58edc01b1c66ecd8fcc91236bfbce0a420,CVE-2016-3695,https://github.com/mjg59/linux/commit/d7a6be58edc01b1c66ecd8fcc91236bfbce0a420,2017-12-29T15:29Z,"<S2SV_StartBug> u64 base_addr , size ; <S2SV_EndBug>"
4396,CWE-000,"static int list_fields ( MYSQL * mysql , const char * db , const char * table , const char * wild ) { <S2SV_StartBug> char query [ 1024 ] , * end ; <S2SV_EndBug> MYSQL_RES * result ; MYSQL_ROW row ; ulong UNINIT_VAR ( rows ) ; if ( mysql_select_db ( mysql , db ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>db:<S2SV_blank>%s:<S2SV_blank>%s\\n"" , my_progname , db , mysql_error ( mysql ) ) ; return 1 ; } if ( opt_count ) { <S2SV_StartBug> sprintf ( query , ""select<S2SV_blank>count(*)<S2SV_blank>from<S2SV_blank>`%s`"" , table ) ; <S2SV_EndBug> if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>get<S2SV_blank>record<S2SV_blank>count<S2SV_blank>for<S2SV_blank>db:<S2SV_blank>%s,<S2SV_blank>table:<S2SV_blank>%s:<S2SV_blank>%s\\n"" , my_progname , db , table , mysql_error ( mysql ) ) ; return 1 ; } row = mysql_fetch_row ( result ) ; rows = ( ulong ) strtoull ( row [ 0 ] , ( char * * ) 0 , 10 ) ; mysql_free_result ( result ) ; } <S2SV_StartBug> end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wild && wild [ 0 ] ) <S2SV_EndBug> strxmov ( end , ""<S2SV_blank>like<S2SV_blank>\'"" , wild , ""\'"" , NullS ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>list<S2SV_blank>columns<S2SV_blank>in<S2SV_blank>db:<S2SV_blank>%s,<S2SV_blank>table:<S2SV_blank>%s:<S2SV_blank>%s\\n"" , my_progname , db , table , mysql_error ( mysql ) ) ; return 1 ; } printf ( ""Database:<S2SV_blank>%s<S2SV_blank><S2SV_blank>Table:<S2SV_blank>%s"" , db , table ) ; if ( opt_count ) printf ( ""<S2SV_blank><S2SV_blank>Rows:<S2SV_blank>%lu"" , rows ) ; if ( wild && wild [ 0 ] ) printf ( ""<S2SV_blank><S2SV_blank>Wildcard:<S2SV_blank>%s"" , wild ) ; putchar ( '\\n' ) ; print_res_header ( result ) ; while ( ( row = mysql_fetch_row ( result ) ) ) print_res_row ( result , row ) ; print_res_top ( result ) ; if ( opt_show_keys ) { <S2SV_StartBug> end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ; <S2SV_EndBug> if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>list<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>db:<S2SV_blank>%s,<S2SV_blank>table:<S2SV_blank>%s:<S2SV_blank>%s\\n"" , my_progname , db , table , mysql_error ( mysql ) ) ; return 1 ; } if ( mysql_num_rows ( result ) ) { print_res_header ( result ) ; while ( ( row = mysql_fetch_row ( result ) ) ) print_res_row ( result , row ) ; print_res_top ( result ) ; } else puts ( ""Table<S2SV_blank>has<S2SV_blank>no<S2SV_blank>keys"" ) ; } mysql_free_result ( result ) ; return 0 ; }
","<S2SV_ModStart> char query [ NAME_LEN + 100 ] ; int len <S2SV_ModEnd> ; MYSQL_RES * <S2SV_ModStart> opt_count ) { my_snprintf ( query , sizeof ( query ) <S2SV_ModEnd> , ""select<S2SV_blank>count(*)<S2SV_blank>from<S2SV_blank>`%s`"" , <S2SV_ModStart> ) ; } len = sizeof ( query ) ; len -= my_snprintf ( query , len , ""show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`%s`"" , table <S2SV_ModEnd> ) ; if <S2SV_ModStart> [ 0 ] && len ) strxnmov ( query + strlen ( query ) , len <S2SV_ModEnd> , ""<S2SV_blank>like<S2SV_blank>\'"" , <S2SV_ModStart> opt_show_keys ) { my_snprintf ( query , sizeof ( query ) , ""show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`%s`"" , table <S2SV_ModEnd> ) ; if
",mysql@mysql-server/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,CVE-2016-0546,https://github.com/mysql/mysql-server/commit/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,2016-01-21T03:01Z,"<S2SV_StartBug> char query [ 1024 ] , * end ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( query , ""select<S2SV_blank>count(*)<S2SV_blank>from<S2SV_blank>`%s`"" , table ) ; <S2SV_EndBug> <S2SV_StartBug> end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wild && wild [ 0 ] ) <S2SV_EndBug> <S2SV_StartBug> end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ; <S2SV_EndBug>"
7749,CWE-000,"<S2SV_StartBug> static void update_open_stateflags ( struct nfs4_state * state , mode_t open_flags ) <S2SV_EndBug> { <S2SV_StartBug> switch ( open_flags ) { <S2SV_EndBug> case FMODE_WRITE : state -> n_wronly ++ ; break ; case FMODE_READ : state -> n_rdonly ++ ; break ; case FMODE_READ | FMODE_WRITE : state -> n_rdwr ++ ; } <S2SV_StartBug> nfs4_state_set_mode_locked ( state , state -> state | open_flags ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { switch <S2SV_ModStart> { switch ( fmode <S2SV_ModEnd> ) { case <S2SV_ModStart> -> state | fmode <S2SV_ModEnd> ) ; }
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static void update_open_stateflags ( struct nfs4_state * state , mode_t open_flags ) <S2SV_EndBug> <S2SV_StartBug> switch ( open_flags ) { <S2SV_EndBug> <S2SV_StartBug> nfs4_state_set_mode_locked ( state , state -> state | open_flags ) ; <S2SV_EndBug>"
5856,CWE-20,"sds genRedisInfoString ( void ) { sds info ; time_t uptime = time ( NULL ) - server . stat_starttime ; int j ; char hmem [ 64 ] ; struct rusage self_ru , c_ru ; getrusage ( RUSAGE_SELF , & self_ru ) ; getrusage ( RUSAGE_CHILDREN , & c_ru ) ; bytesToHuman ( hmem , zmalloc_used_memory ( ) ) ; info = sdscatprintf ( sdsempty ( ) , ""redis_version:%s\\r\\n"" ""redis_git_sha1:%s\\r\\n"" ""redis_git_dirty:%d\\r\\n"" ""arch_bits:%s\\r\\n"" ""multiplexing_api:%s\\r\\n"" ""process_id:%ld\\r\\n"" ""uptime_in_seconds:%ld\\r\\n"" ""uptime_in_days:%ld\\r\\n"" ""lru_clock:%ld\\r\\n"" ""used_cpu_sys:%.2f\\r\\n"" ""used_cpu_user:%.2f\\r\\n"" ""used_cpu_sys_childrens:%.2f\\r\\n"" ""used_cpu_user_childrens:%.2f\\r\\n"" ""connected_clients:%d\\r\\n"" ""connected_slaves:%d\\r\\n"" ""blocked_clients:%d\\r\\n"" ""used_memory:%zu\\r\\n"" ""used_memory_human:%s\\r\\n"" ""used_memory_rss:%zu\\r\\n"" ""mem_fragmentation_ratio:%.2f\\r\\n"" ""use_tcmalloc:%d\\r\\n"" ""loading:%d\\r\\n"" ""aof_enabled:%d\\r\\n"" ""changes_since_last_save:%lld\\r\\n"" ""bgsave_in_progress:%d\\r\\n"" ""last_save_time:%ld\\r\\n"" ""bgrewriteaof_in_progress:%d\\r\\n"" ""total_connections_received:%lld\\r\\n"" ""total_commands_processed:%lld\\r\\n"" ""expired_keys:%lld\\r\\n"" ""evicted_keys:%lld\\r\\n"" ""keyspace_hits:%lld\\r\\n"" ""keyspace_misses:%lld\\r\\n"" ""hash_max_zipmap_entries:%zu\\r\\n"" ""hash_max_zipmap_value:%zu\\r\\n"" ""pubsub_channels:%ld\\r\\n"" ""pubsub_patterns:%u\\r\\n"" <S2SV_StartBug> ""vm_enabled:%d\\r\\n"" <S2SV_EndBug> ""role:%s\\r\\n"" , REDIS_VERSION , redisGitSHA1 ( ) , strtol ( redisGitDirty ( ) , NULL , 10 ) > 0 , ( sizeof ( long ) == 8 ) ? ""64"" : ""32"" , aeGetApiName ( ) , ( long ) getpid ( ) , uptime , uptime / ( 3600 * 24 ) , ( unsigned long ) server . lruclock , ( float ) self_ru . ru_utime . tv_sec + ( float ) self_ru . ru_utime . tv_usec / 1000000 , ( float ) self_ru . ru_stime . tv_sec + ( float ) self_ru . ru_stime . tv_usec / 1000000 , ( float ) c_ru . ru_utime . tv_sec + ( float ) c_ru . ru_utime . tv_usec / 1000000 , ( float ) c_ru . ru_stime . tv_sec + ( float ) c_ru . ru_stime . tv_usec / 1000000 , listLength ( server . clients ) - listLength ( server . slaves ) , listLength ( server . slaves ) , server . bpop_blocked_clients , zmalloc_used_memory ( ) , hmem , zmalloc_get_rss ( ) , zmalloc_get_fragmentation_ratio ( ) , # ifdef USE_TCMALLOC 1 , # else 0 , # endif server . loading , server . appendonly , server . dirty , server . bgsavechildpid != - 1 , server . lastsave , server . bgrewritechildpid != - 1 , server . stat_numconnections , server . stat_numcommands , server . stat_expiredkeys , server . stat_evictedkeys , server . stat_keyspace_hits , server . stat_keyspace_misses , server . hash_max_zipmap_entries , server . hash_max_zipmap_value , dictSize ( server . pubsub_channels ) , listLength ( server . pubsub_patterns ) , <S2SV_StartBug> server . vm_enabled != 0 , <S2SV_EndBug> server . masterhost == NULL ? ""master"" : ""slave"" ) ; if ( server . masterhost ) { info = sdscatprintf ( info , ""master_host:%s\\r\\n"" ""master_port:%d\\r\\n"" ""master_link_status:%s\\r\\n"" ""master_last_io_seconds_ago:%d\\r\\n"" ""master_sync_in_progress:%d\\r\\n"" , server . masterhost , server . masterport , ( server . replstate == REDIS_REPL_CONNECTED ) ? ""up"" : ""down"" , server . master ? ( ( int ) ( time ( NULL ) - server . master -> lastinteraction ) ) : - 1 , server . replstate == REDIS_REPL_TRANSFER ) ; if ( server . replstate == REDIS_REPL_TRANSFER ) { info = sdscatprintf ( info , ""master_sync_left_bytes:%ld\\r\\n"" ""master_sync_last_io_seconds_ago:%d\\r\\n"" , ( long ) server . repl_transfer_left , ( int ) ( time ( NULL ) - server . repl_transfer_lastio ) ) ; } } <S2SV_StartBug> if ( server . vm_enabled ) { <S2SV_EndBug> lockThreadedIO ( ) ; info = sdscatprintf ( info , <S2SV_StartBug> ""vm_conf_max_memory:%llu\\r\\n"" <S2SV_EndBug> ""vm_conf_page_size:%llu\\r\\n"" ""vm_conf_pages:%llu\\r\\n"" ""vm_stats_used_pages:%llu\\r\\n"" ""vm_stats_swapped_objects:%llu\\r\\n"" ""vm_stats_swappin_count:%llu\\r\\n"" ""vm_stats_swappout_count:%llu\\r\\n"" ""vm_stats_io_newjobs_len:%lu\\r\\n"" ""vm_stats_io_processing_len:%lu\\r\\n"" ""vm_stats_io_processed_len:%lu\\r\\n"" ""vm_stats_io_active_threads:%lu\\r\\n"" ""vm_stats_blocked_clients:%lu\\r\\n"" <S2SV_StartBug> , ( unsigned long long ) server . vm_max_memory , <S2SV_EndBug> <S2SV_StartBug> ( unsigned long long ) server . vm_page_size , <S2SV_EndBug> ( unsigned long long ) server . vm_pages , ( unsigned long long ) server . vm_stats_used_pages , ( unsigned long long ) server . vm_stats_swapped_objects , ( unsigned long long ) server . vm_stats_swapins , ( unsigned long long ) server . vm_stats_swapouts , ( unsigned long ) listLength ( server . io_newjobs ) , ( unsigned long ) listLength ( server . io_processing ) , ( unsigned long ) listLength ( server . io_processed ) , ( unsigned long ) server . io_active_threads , ( unsigned long ) server . vm_blocked_clients ) ; unlockThreadedIO ( ) ; } if ( server . loading ) { double perc ; time_t eta , elapsed ; off_t remaining_bytes = server . loading_total_bytes - server . loading_loaded_bytes ; perc = ( ( double ) server . loading_loaded_bytes / server . loading_total_bytes ) * 100 ; elapsed = time ( NULL ) - server . loading_start_time ; if ( elapsed == 0 ) { eta = 1 ; } else { eta = ( elapsed * remaining_bytes ) / server . loading_loaded_bytes ; } info = sdscatprintf ( info , ""loading_start_time:%ld\\r\\n"" ""loading_total_bytes:%llu\\r\\n"" ""loading_loaded_bytes:%llu\\r\\n"" ""loading_loaded_perc:%.2f\\r\\n"" ""loading_eta_seconds:%ld\\r\\n"" , ( unsigned long ) server . loading_start_time , ( unsigned long long ) server . loading_total_bytes , ( unsigned long long ) server . loading_loaded_bytes , perc , eta ) ; } for ( j = 0 ; j < server . dbnum ; j ++ ) { long long keys , vkeys ; keys = dictSize ( server . db [ j ] . dict ) ; vkeys = dictSize ( server . db [ j ] . expires ) ; if ( keys || vkeys ) { info = sdscatprintf ( info , ""db%d:keys=%lld,expires=%lld\\r\\n"" , j , keys , vkeys ) ; } } return info ; }
","<S2SV_ModStart> ""hash_max_zipmap_value:%zu\\r\\n"" ""pubsub_channels:%ld\\r\\n"" ""pubsub_patterns:%u\\r\\n"" ""ds_enabled:%d\\r\\n"" <S2SV_ModEnd> ""role:%s\\r\\n"" , REDIS_VERSION <S2SV_ModStart> , server . ds_enabled <S2SV_ModEnd> != 0 , <S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> ) { lockThreadedIO <S2SV_ModStart> ( info , ""cache_max_memory:%llu\\r\\n"" ""cache_blocked_clients:%lu\\r\\n"" <S2SV_ModEnd> , ( unsigned <S2SV_ModStart> ) server . cache_max_memory <S2SV_ModEnd> , ( unsigned <S2SV_ModStart> ( unsigned long ) server . cache_blocked_clients <S2SV_ModEnd> ) ; unlockThreadedIO
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,"<S2SV_StartBug> ""vm_enabled:%d\\r\\n"" <S2SV_EndBug> <S2SV_StartBug> server . vm_enabled != 0 , <S2SV_EndBug> <S2SV_StartBug> if ( server . vm_enabled ) { <S2SV_EndBug> <S2SV_StartBug> ""vm_conf_max_memory:%llu\\r\\n"" <S2SV_EndBug> <S2SV_StartBug> , ( unsigned long long ) server . vm_max_memory , <S2SV_EndBug> <S2SV_StartBug> ( unsigned long long ) server . vm_page_size , <S2SV_EndBug>"
1063,CWE-284,"static void uipc_read_task ( void * arg ) { int ch_id ; int result ; UNUSED ( arg ) ; prctl ( PR_SET_NAME , ( unsigned long ) ""uipc-main"" , 0 , 0 , 0 ) ; raise_priority_a2dp ( TASK_UIPC_READ ) ; while ( uipc_main . running ) { uipc_main . read_set = uipc_main . active_set ; <S2SV_StartBug> result = select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ; <S2SV_EndBug> if ( result == 0 ) { BTIF_TRACE_EVENT ( ""select<S2SV_blank>timeout"" ) ; continue ; } else if ( result < 0 ) { BTIF_TRACE_EVENT ( ""select<S2SV_blank>failed<S2SV_blank>%s"" , strerror ( errno ) ) ; continue ; } UIPC_LOCK ( ) ; uipc_check_interrupt_locked ( ) ; uipc_check_task_flags_locked ( ) ; uipc_check_fd_locked ( UIPC_CH_ID_AV_AUDIO ) ; for ( ch_id = 0 ; ch_id < UIPC_CH_NUM ; ch_id ++ ) { if ( ch_id != UIPC_CH_ID_AV_AUDIO ) uipc_check_fd_locked ( ch_id ) ; } UIPC_UNLOCK ( ) ; } BTIF_TRACE_EVENT ( ""UIPC<S2SV_blank>READ<S2SV_blank>THREAD<S2SV_blank>EXITING"" ) ; uipc_main_cleanup ( ) ; uipc_main . tid = 0 ; BTIF_TRACE_EVENT ( ""UIPC<S2SV_blank>READ<S2SV_blank>THREAD<S2SV_blank>DONE"" ) ; }
","<S2SV_ModStart> ; result = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , NULL ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> result = select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ; <S2SV_EndBug>"
3712,CWE-125,"void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len ) ) ; return ; } <S2SV_StartBug> tlen = len - sizeof ( struct eigrp_common_header ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tEIGRP<S2SV_blank>v%u,<S2SV_blank>opcode:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>chksum:<S2SV_blank>0x%04x,<S2SV_blank>Flags:<S2SV_blank>[%s]\\n\\tseq:<S2SV_blank>0x%08x,<S2SV_blank>ack:<S2SV_blank>0x%08x,<S2SV_blank>AS:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , eigrp_com_header -> version , tok2str ( eigrp_opcode_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , eigrp_com_header -> opcode ) , eigrp_com_header -> opcode , EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , tok2str ( eigrp_common_header_flag_values , ""none"" , EXTRACT_32BITS ( & eigrp_com_header -> flags ) ) , EXTRACT_32BITS ( & eigrp_com_header -> seq ) , EXTRACT_32BITS ( & eigrp_com_header -> ack ) , EXTRACT_32BITS ( & eigrp_com_header -> asn ) , tlen ) ) ; tptr += sizeof ( const struct eigrp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct eigrp_tlv_header ) ) ; eigrp_tlv_header = ( const struct eigrp_tlv_header * ) tptr ; eigrp_tlv_len = EXTRACT_16BITS ( & eigrp_tlv_header -> length ) ; eigrp_tlv_type = EXTRACT_16BITS ( & eigrp_tlv_header -> type ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) || eigrp_tlv_len > tlen ) { print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_tlv_values , ""Unknown"" , eigrp_tlv_type ) , eigrp_tlv_type , eigrp_tlv_len ) ) ; <S2SV_StartBug> tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ; <S2SV_EndBug> tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ; ND_TCHECK2 ( * tptr , eigrp_tlv_len ) ; switch ( eigrp_tlv_type ) { case EIGRP_TLV_GENERAL_PARM : tlv_ptr . eigrp_tlv_general_parm = ( const struct eigrp_tlv_general_parm_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" , <S2SV_EndBug> EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_general_parm -> holdtime ) , tlv_ptr . eigrp_tlv_general_parm -> k1 , tlv_ptr . eigrp_tlv_general_parm -> k2 , tlv_ptr . eigrp_tlv_general_parm -> k3 , tlv_ptr . eigrp_tlv_general_parm -> k4 , tlv_ptr . eigrp_tlv_general_parm -> k5 ) ) ; break ; case EIGRP_TLV_SW_VERSION : tlv_ptr . eigrp_tlv_sw_version = ( const struct eigrp_tlv_sw_version_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" , <S2SV_EndBug> tlv_ptr . eigrp_tlv_sw_version -> ios_major , tlv_ptr . eigrp_tlv_sw_version -> ios_minor , tlv_ptr . eigrp_tlv_sw_version -> eigrp_major , tlv_ptr . eigrp_tlv_sw_version -> eigrp_minor ) ) ; break ; case EIGRP_TLV_IP_INT : tlv_ptr . eigrp_tlv_ip_int = ( const struct eigrp_tlv_ip_int_t * ) tlv_tptr ; <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ; <S2SV_EndBug> if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_int -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_int -> mtu ) , tlv_ptr . eigrp_tlv_ip_int -> hopcount , tlv_ptr . eigrp_tlv_ip_int -> reliability , tlv_ptr . eigrp_tlv_ip_int -> load ) ) ; break ; case EIGRP_TLV_IP_EXT : tlv_ptr . eigrp_tlv_ip_ext = ( const struct eigrp_tlv_ip_ext_t * ) tlv_tptr ; <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ; <S2SV_EndBug> if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_ext -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%s,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , ipaddr_string ( ndo , tlv_ptr . eigrp_tlv_ip_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_ip_ext -> proto_id ) , tlv_ptr . eigrp_tlv_ip_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> tag ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> mtu ) , tlv_ptr . eigrp_tlv_ip_ext -> hopcount , tlv_ptr . eigrp_tlv_ip_ext -> reliability , tlv_ptr . eigrp_tlv_ip_ext -> load ) ) ; break ; case EIGRP_TLV_AT_CABLE_SETUP : tlv_ptr . eigrp_tlv_at_cable_setup = ( const struct eigrp_tlv_at_cable_setup_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" , <S2SV_EndBug> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_end ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> router_id ) ) ) ; break ; case EIGRP_TLV_AT_INT : <S2SV_StartBug> tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_int -> mtu ) , tlv_ptr . eigrp_tlv_at_int -> hopcount , tlv_ptr . eigrp_tlv_at_int -> reliability , tlv_ptr . eigrp_tlv_at_int -> load ) ) ; break ; case EIGRP_TLV_AT_EXT : tlv_ptr . eigrp_tlv_at_ext = ( const struct eigrp_tlv_at_ext_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , <S2SV_EndBug> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_at_ext -> proto_id ) , tlv_ptr . eigrp_tlv_at_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> tag ) , EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_at_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_ext -> mtu ) , tlv_ptr . eigrp_tlv_at_ext -> hopcount , tlv_ptr . eigrp_tlv_at_ext -> reliability , tlv_ptr . eigrp_tlv_at_ext -> load ) ) ; break ; case EIGRP_TLV_AUTH : case EIGRP_TLV_SEQ : case EIGRP_TLV_MCAST_SEQ : case EIGRP_TLV_IPX_INT : case EIGRP_TLV_IPX_EXT : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tlv_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ) ; tptr += eigrp_tlv_len ; tlen -= eigrp_tlv_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }
","<S2SV_ModStart> return ; } if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; }
",the-tcpdump-group@tcpdump/de981e6070d168b58ec1bb0713ded77ed4ad87f4,CVE-2017-12901,https://github.com/the-tcpdump-group/tcpdump/commit/de981e6070d168b58ec1bb0713ded77ed4ad87f4,2017-09-14T06:29Z,"<S2SV_StartBug> tlen = len - sizeof ( struct eigrp_common_header ) ; <S2SV_EndBug> <S2SV_StartBug> tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" , <S2SV_EndBug> <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ; <S2SV_EndBug> <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , <S2SV_EndBug>"
3120,CWE-476,"av_cold void ff_mpv_idct_init ( MpegEncContext * s ) <S2SV_StartBug> { <S2SV_EndBug> ff_idctdsp_init ( & s -> idsp , s -> avctx ) ; if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; } ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; }
","<S2SV_ModStart> s ) { if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;
",FFmpeg@FFmpeg/b3332a182f8ba33a34542e4a0370f38b914ccf7d,CVE-2018-12460,https://github.com/FFmpeg/FFmpeg/commit/b3332a182f8ba33a34542e4a0370f38b914ccf7d,2018-06-15T15:29Z,<S2SV_StartBug> { <S2SV_EndBug>
3548,CWE-125,"static size_t consume_init_expr ( ut8 * buf , ut8 * max , ut8 eoc , void * out , ut32 * offset ) { ut32 i = 0 ; while ( buf + i < max && buf [ i ] != eoc ) { <S2SV_StartBug> i += 1 ; <S2SV_EndBug> } if ( buf [ i ] != eoc ) { return 0 ; } if ( offset ) { * offset += i + 1 ; } return i + 1 ; }
","<S2SV_ModStart> ) { i ++ <S2SV_ModEnd> ; } if
",radare@radare2/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,CVE-2017-7854,https://github.com/radare/radare2/commit/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4,2017-04-13T16:59Z,<S2SV_StartBug> i += 1 ; <S2SV_EndBug>
2978,CWE-200,"static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) { if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , ""GAB2"" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) { uint8_t desc [ 256 ] ; int score = AVPROBE_SCORE_EXTENSION , ret ; AVIStream * ast = st -> priv_data ; AVInputFormat * sub_demuxer ; AVRational time_base ; int size ; AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ; AVProbeData pd ; unsigned int desc_len = avio_rl32 ( pb ) ; if ( desc_len > pb -> buf_end - pb -> buf_ptr ) goto error ; ret = avio_get_str16le ( pb , desc_len , desc , sizeof ( desc ) ) ; avio_skip ( pb , desc_len - ret ) ; if ( * desc ) av_dict_set ( & st -> metadata , ""title"" , desc , 0 ) ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; size = pb -> buf_end - pb -> buf_ptr ; pd = ( AVProbeData ) { . buf = av_mallocz ( size + AVPROBE_PADDING_SIZE ) , . buf_size = size } ; if ( ! pd . buf ) goto error ; memcpy ( pd . buf , pb -> buf_ptr , size ) ; sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ; av_freep ( & pd . buf ) ; if ( ! sub_demuxer ) goto error ; <S2SV_StartBug> if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) <S2SV_EndBug> goto error ; ast -> sub_ctx -> pb = pb ; if ( ff_copy_whiteblacklists ( ast -> sub_ctx , s ) < 0 ) goto error ; if ( ! avformat_open_input ( & ast -> sub_ctx , """" , sub_demuxer , NULL ) ) { if ( ast -> sub_ctx -> nb_streams != 1 ) goto error ; ff_read_packet ( ast -> sub_ctx , & ast -> sub_pkt ) ; avcodec_parameters_copy ( st -> codecpar , ast -> sub_ctx -> streams [ 0 ] -> codecpar ) ; time_base = ast -> sub_ctx -> streams [ 0 ] -> time_base ; avpriv_set_pts_info ( st , 64 , time_base . num , time_base . den ) ; } ast -> sub_buffer = pkt -> data ; memset ( pkt , 0 , sizeof ( * pkt ) ) ; return 1 ; error : av_freep ( & ast -> sub_ctx ) ; av_freep ( & pb ) ; } return 0 ; }
","<S2SV_ModStart> ; if ( strcmp ( sub_demuxer -> name , ""srt"" ) && strcmp ( sub_demuxer -> name , ""ass"" ) ) goto error ; if (
",FFmpeg@FFmpeg/a5d849b149ca67ced2d271dc84db0bc95a548abb,CVE-2017-9993,https://github.com/FFmpeg/FFmpeg/commit/a5d849b149ca67ced2d271dc84db0bc95a548abb,2017-06-28T06:29Z,<S2SV_StartBug> if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) <S2SV_EndBug>
1289,CWE-200,"static int mincore_unmapped_range ( unsigned long addr , unsigned long end , struct mm_walk * walk ) { <S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug> walk -> vma , walk -> private ) ; return 0 ; }
","<S2SV_ModStart> walk ) { unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; <S2SV_ModStart> -> private += nr <S2SV_ModEnd> ; return 0
",torvalds@linux/574823bfab82d9d8fa47f422778043fbb4b4f50e,CVE-2019-5489,https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e,2019-01-07T17:29Z,"<S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug>"
3064,CWE-119,"static void logi_dj_recv_add_djhid_device ( struct dj_receiver_dev * djrcv_dev , struct dj_report * dj_report ) { struct hid_device * djrcv_hdev = djrcv_dev -> hdev ; struct usb_interface * intf = to_usb_interface ( djrcv_hdev -> dev . parent ) ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct hid_device * dj_hiddev ; struct dj_device * dj_dev ; unsigned char tmpstr [ 3 ] ; if ( dj_report -> report_params [ DEVICE_PAIRED_PARAM_SPFUNCTION ] & SPFUNCTION_DEVICE_LIST_EMPTY ) { dbg_hid ( ""%s:<S2SV_blank>device<S2SV_blank>list<S2SV_blank>is<S2SV_blank>empty\\n"" , __func__ ) ; djrcv_dev -> querying_devices = false ; return ; } <S2SV_StartBug> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || <S2SV_EndBug> ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n"" , __func__ , dj_report -> device_index ) ; return ; } if ( djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] ) { dbg_hid ( ""%s:<S2SV_blank>device<S2SV_blank>is<S2SV_blank>already<S2SV_blank>known\\n"" , __func__ ) ; return ; } dj_hiddev = hid_allocate_device ( ) ; if ( IS_ERR ( dj_hiddev ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>hid_allocate_device<S2SV_blank>failed\\n"" , __func__ ) ; return ; } dj_hiddev -> ll_driver = & logi_dj_ll_driver ; dj_hiddev -> dev . parent = & djrcv_hdev -> dev ; dj_hiddev -> bus = BUS_USB ; dj_hiddev -> vendor = le16_to_cpu ( usbdev -> descriptor . idVendor ) ; dj_hiddev -> product = le16_to_cpu ( usbdev -> descriptor . idProduct ) ; snprintf ( dj_hiddev -> name , sizeof ( dj_hiddev -> name ) , ""Logitech<S2SV_blank>Unifying<S2SV_blank>Device.<S2SV_blank>Wireless<S2SV_blank>PID:%02x%02x"" , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_MSB ] , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_LSB ] ) ; usb_make_path ( usbdev , dj_hiddev -> phys , sizeof ( dj_hiddev -> phys ) ) ; snprintf ( tmpstr , sizeof ( tmpstr ) , "":%d"" , dj_report -> device_index ) ; strlcat ( dj_hiddev -> phys , tmpstr , sizeof ( dj_hiddev -> phys ) ) ; dj_dev = kzalloc ( sizeof ( struct dj_device ) , GFP_KERNEL ) ; if ( ! dj_dev ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>failed<S2SV_blank>allocating<S2SV_blank>dj_device\\n"" , __func__ ) ; goto dj_device_allocate_fail ; } dj_dev -> reports_supported = get_unaligned_le32 ( dj_report -> report_params + DEVICE_PAIRED_RF_REPORT_TYPE ) ; dj_dev -> hdev = dj_hiddev ; dj_dev -> dj_receiver_dev = djrcv_dev ; dj_dev -> device_index = dj_report -> device_index ; dj_hiddev -> driver_data = dj_dev ; djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = dj_dev ; if ( hid_add_device ( dj_hiddev ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>failed<S2SV_blank>adding<S2SV_blank>dj_device\\n"" , __func__ ) ; goto hid_add_device_fail ; } return ; hid_add_device_fail : djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = NULL ; kfree ( dj_dev ) ; dj_device_allocate_fail : hid_destroy_device ( dj_hiddev ) ; }
","<S2SV_ModStart> } if ( <S2SV_ModEnd> djrcv_dev -> paired_dj_devices
",torvalds@linux/ad3e14d7c5268c2e24477c6ef54bbdf88add5d36,CVE-2014-3182,https://github.com/torvalds/linux/commit/ad3e14d7c5268c2e24477c6ef54bbdf88add5d36,2014-09-28T10:55Z,<S2SV_StartBug> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || <S2SV_EndBug>
8023,CWE-835,"void CLASS parse_minolta ( int base ) { int save , tag , len , offset , high = 0 , wide = 0 , i , c ; short sorder = order ; fseek ( ifp , base , SEEK_SET ) ; if ( fgetc ( ifp ) || fgetc ( ifp ) - 'M' || fgetc ( ifp ) - 'R' ) return ; order = fgetc ( ifp ) * 0x101 ; <S2SV_StartBug> offset = base + get4 ( ) + 8 ; <S2SV_EndBug> while ( ( save = ftell ( ifp ) ) < offset ) { for ( tag = i = 0 ; i < 4 ; i ++ ) tag = tag << 8 | fgetc ( ifp ) ; len = get4 ( ) ; <S2SV_StartBug> switch ( tag ) <S2SV_EndBug> { case 0x505244 : fseek ( ifp , 8 , SEEK_CUR ) ; high = get2 ( ) ; wide = get2 ( ) ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . makernotes . sony . prd_ImageHeight = get2 ( ) ; imgdata . makernotes . sony . prd_ImageWidth = get2 ( ) ; fseek ( ifp , 1L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_RawBitDepth = ( ushort ) fgetc ( ifp ) ; imgdata . makernotes . sony . prd_StorageMethod = ( ushort ) fgetc ( ifp ) ; fseek ( ifp , 4L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_BayerPattern = ( ushort ) fgetc ( ifp ) ; # endif break ; # ifdef LIBRAW_LIBRARY_BUILD case 0x524946 : if ( ! strncasecmp ( model , ""DSLR-A100"" , 9 ) ) { fseek ( ifp , 8 , SEEK_CUR ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 2 ] = get2 ( ) ; get4 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 3 ] = 0x100 ; } break ; # endif case 0x574247 : get4 ( ) ; i = strcmp ( model , ""DiMAGE<S2SV_blank>A200"" ) ? 0 : 3 ; FORC4 cam_mul [ c ^ ( c >> 1 ) ^ i ] = get2 ( ) ; break ; case 0x545457 : parse_tiff ( ftell ( ifp ) ) ; data_offset = offset ; } fseek ( ifp , save + len + 8 , SEEK_SET ) ; } raw_height = high ; raw_width = wide ; order = sorder ; }
","<S2SV_ModStart> + 8 ; # ifdef LIBRAW_LIBRARY_BUILD if ( offset > ifp -> size ( ) - 8 ) offset = ifp -> size ( ) - 8 ; # endif <S2SV_ModStart> ( ) ; if ( len < 0 ) return ;
",LibRaw@LibRaw/e47384546b43d0fd536e933249047bc397a4d88b,CVE-2018-5813,https://github.com/LibRaw/LibRaw/commit/e47384546b43d0fd536e933249047bc397a4d88b,2018-12-07T22:29Z,<S2SV_StartBug> offset = base + get4 ( ) + 8 ; <S2SV_EndBug> <S2SV_StartBug> switch ( tag ) <S2SV_EndBug>
498,CWE-264,"static inline int check_sticky ( struct inode * dir , struct inode * inode ) { kuid_t fsuid = current_fsuid ( ) ; if ( ! ( dir -> i_mode & S_ISVTX ) ) return 0 ; if ( uid_eq ( inode -> i_uid , fsuid ) ) return 0 ; if ( uid_eq ( dir -> i_uid , fsuid ) ) return 0 ; <S2SV_StartBug> return ! inode_capable ( inode , CAP_FOWNER ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; return ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
",torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03,CVE-2014-4014,https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03,2014-06-23T11:21Z,"<S2SV_StartBug> return ! inode_capable ( inode , CAP_FOWNER ) ; <S2SV_EndBug>"
2312,CWE-119,"static char * rfc2047_decode_word ( const char * s , size_t len , enum ContentEncoding enc ) { const char * it = s ; const char * end = s + len ; if ( enc == ENCQUOTEDPRINTABLE ) { struct Buffer buf = { 0 } ; for ( ; it < end ; ++ it ) { if ( * it == '_' ) { mutt_buffer_addch ( & buf , '<S2SV_blank>' ) ; } else if ( ( * it == '=' ) && ( ! ( it [ 1 ] & ~ 127 ) && hexval ( it [ 1 ] ) != - 1 ) && ( ! ( it [ 2 ] & ~ 127 ) && hexval ( it [ 2 ] ) != - 1 ) ) { mutt_buffer_addch ( & buf , ( hexval ( it [ 1 ] ) << 4 ) | hexval ( it [ 2 ] ) ) ; it += 2 ; } else { mutt_buffer_addch ( & buf , * it ) ; } } mutt_buffer_addch ( & buf , '\\0' ) ; return buf . data ; } else if ( enc == ENCBASE64 ) { <S2SV_StartBug> char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int dlen = mutt_b64_decode ( out , it ) ; <S2SV_EndBug> if ( dlen == - 1 ) { FREE ( & out ) ; return NULL ; } out [ dlen ] = '\\0' ; return out ; } assert ( 0 ) ; return NULL ; }
","<S2SV_ModStart> ENCBASE64 ) { const int olen = <S2SV_ModEnd> 3 * len <S2SV_ModStart> 4 + 1 ; char * out = mutt_mem_malloc ( olen <S2SV_ModStart> out , it , olen
",neomutt@neomutt/6f163e07ae68654d7ac5268cbb7565f6df79ad85,CVE-2018-14359,https://github.com/neomutt/neomutt/commit/6f163e07ae68654d7ac5268cbb7565f6df79ad85,2018-07-17T17:29Z,"<S2SV_StartBug> char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int dlen = mutt_b64_decode ( out , it ) ; <S2SV_EndBug>"
3672,CWE-310,"<S2SV_StartBug> static void prefetch_table ( const volatile byte * tab , size_t len ) <S2SV_EndBug> { size_t i ; <S2SV_StartBug> for ( i = 0 ; i < len ; i += 8 * 32 ) <S2SV_EndBug> { ( void ) tab [ i + 0 * 32 ] ; ( void ) tab [ i + 1 * 32 ] ; ( void ) tab [ i + 2 * 32 ] ; ( void ) tab [ i + 3 * 32 ] ; ( void ) tab [ i + 4 * 32 ] ; ( void ) tab [ i + 5 * 32 ] ; ( void ) tab [ i + 6 * 32 ] ; ( void ) tab [ i + 7 * 32 ] ; } <S2SV_StartBug> ( void ) tab [ len - 1 ] ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static inline <S2SV_ModStart> = 0 ; len - i >= 8 * 32 <S2SV_ModEnd> ; i += <S2SV_ModStart> ] ; } for ( ; i < len ; i += 32 ) { ( void ) tab [ i ] ; }
",gpg@libgcrypt/daedbbb5541cd8ecda1459d3b843ea4d92788762,CVE-2019-12904,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,2019-06-20T00:15Z,"<S2SV_StartBug> static void prefetch_table ( const volatile byte * tab , size_t len ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < len ; i += 8 * 32 ) <S2SV_EndBug> <S2SV_StartBug> ( void ) tab [ len - 1 ] ; <S2SV_EndBug>"
782,CWE-269,"long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; <S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } # ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , ""%s\\n"" , filename ) ; # endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }
","<S2SV_ModStart> long len ; qboolean isLocalConfig ; <S2SV_ModStart> ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> next ) { if ( isLocalConfig && search -> pack ) continue ;
",ioquake@ioq3/376267d534476a875d8b9228149c4ee18b74a4fd,CVE-2017-6903,https://github.com/ioquake/ioq3/commit/376267d534476a875d8b9228149c4ee18b74a4fd,2017-03-14T22:59Z,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug>
4977,CWE-119,"static int stellaris_enet_init ( SysBusDevice * sbd ) { DeviceState * dev = DEVICE ( sbd ) ; stellaris_enet_state * s = STELLARIS_ENET ( dev ) ; memory_region_init_io ( & s -> mmio , OBJECT ( s ) , & stellaris_enet_ops , s , ""stellaris_enet"" , 0x1000 ) ; sysbus_init_mmio ( sbd , & s -> mmio ) ; sysbus_init_irq ( sbd , & s -> irq ) ; qemu_macaddr_default_if_unset ( & s -> conf . macaddr ) ; s -> nic = qemu_new_nic ( & net_stellaris_enet_info , & s -> conf , object_get_typename ( OBJECT ( dev ) ) , dev -> id , s ) ; qemu_format_nic_info_str ( qemu_get_queue ( s -> nic ) , s -> conf . macaddr . a ) ; stellaris_enet_reset ( s ) ; <S2SV_StartBug> register_savevm ( dev , ""stellaris_enet"" , - 1 , 1 , <S2SV_EndBug> stellaris_enet_save , stellaris_enet_load , s ) ; return 0 ; }
","<S2SV_ModStart> s ) ; <S2SV_ModEnd> return 0 ;
",qemu@qemu/2e1198672759eda6e122ff38fcf6df06f27e0fe2,CVE-2013-4532,https://github.com/qemu/qemu/commit/2e1198672759eda6e122ff38fcf6df06f27e0fe2,2020-01-02T16:15Z,"<S2SV_StartBug> register_savevm ( dev , ""stellaris_enet"" , - 1 , 1 , <S2SV_EndBug>"
3179,CWE-269,"static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( ! arg_shell_none && ( strcmp ( cfg . shell , ""/usr/bin/zsh"" ) == 0 || strcmp ( cfg . shell , ""/bin/zsh"" ) == 0 ) ) { if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ; <S2SV_StartBug> } <S2SV_EndBug> } free ( fname ) ; } else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ; <S2SV_StartBug> } <S2SV_EndBug> } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> free ( fname ) ; } }
","<S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.zshrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" <S2SV_ModStart> ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 <S2SV_ModStart> fname ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.cshrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" <S2SV_ModStart> ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 <S2SV_ModStart> fname ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.bashrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" <S2SV_ModStart> ) ; } <S2SV_ModEnd> free ( fname
",netblue30@firejail/b8a4ff9775318ca5e679183884a6a63f3da8f863,CVE-2017-5940,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,2017-02-09T18:59Z,"<S2SV_StartBug> if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
6930,CWE-400,"static int x86_pmu_handle_irq ( struct pt_regs * regs ) { struct perf_sample_data data ; struct cpu_hw_events * cpuc ; struct perf_event * event ; int idx , handled = 0 ; u64 val ; perf_sample_data_init ( & data , 0 ) ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; apic_write ( APIC_LVTPC , APIC_DM_NMI ) ; for ( idx = 0 ; idx < x86_pmu . num_counters ; idx ++ ) { if ( ! test_bit ( idx , cpuc -> active_mask ) ) { if ( __test_and_clear_bit ( idx , cpuc -> running ) ) handled ++ ; continue ; } event = cpuc -> events [ idx ] ; val = x86_perf_event_update ( event ) ; if ( val & ( 1ULL << ( x86_pmu . cntval_bits - 1 ) ) ) continue ; handled ++ ; data . period = event -> hw . last_period ; if ( ! x86_perf_event_set_period ( event ) ) continue ; <S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) <S2SV_EndBug> x86_pmu_stop ( event , 0 ) ; } if ( handled ) inc_irq_stat ( apic_perf_irqs ) ; return handled ; }
","<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) <S2SV_EndBug>"
1373,CWE-119,"void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh , <S2SV_StartBug> int flag ) <S2SV_EndBug> { double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065 ; int ppl = ( int ) ( level + .5 ) ; <S2SV_StartBug> int mb_rows = source -> y_width >> 4 ; <S2SV_EndBug> <S2SV_StartBug> int mb_cols = source -> y_height >> 4 ; <S2SV_EndBug> unsigned char * limits = cm -> pp_limits_buffer ; ; <S2SV_StartBug> int mbr , mbc ; <S2SV_EndBug> ( void ) post ; ( void ) low_var_thresh ; ( void ) flag ; <S2SV_StartBug> vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ; <S2SV_EndBug> for ( mbr = 0 ; mbr < mb_rows ; mbr ++ ) { vp8_post_proc_down_and_across_mb_row ( source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_stride , source -> y_stride , source -> y_width , limits , 16 ) ; <S2SV_StartBug> vp8_post_proc_down_and_across_mb_row ( <S2SV_EndBug> source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; vp8_post_proc_down_and_across_mb_row ( source -> v_buffer + 8 * mbr * source -> uv_stride , source -> v_buffer + 8 * mbr * source -> uv_stride , <S2SV_StartBug> source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> , int flag , int uvfilter ) { int mbr ; <S2SV_ModEnd> double level = <S2SV_ModStart> int mb_rows = cm -> mb_rows <S2SV_ModEnd> ; int mb_cols <S2SV_ModStart> int mb_cols = cm -> mb_cols <S2SV_ModEnd> ; unsigned char <S2SV_ModStart> pp_limits_buffer ; ; <S2SV_ModEnd> ( void ) <S2SV_ModStart> ) flag ; memset <S2SV_ModEnd> ( limits , <S2SV_ModStart> 16 ) ; if ( uvfilter == 1 ) { <S2SV_ModStart> , limits , 8 ) ; } <S2SV_ModEnd> } } <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> int flag ) <S2SV_EndBug> <S2SV_StartBug> int mb_rows = source -> y_width >> 4 ; <S2SV_EndBug> <S2SV_StartBug> int mb_cols = source -> y_height >> 4 ; <S2SV_EndBug> <S2SV_StartBug> int mbr , mbc ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_post_proc_down_and_across_mb_row ( <S2SV_EndBug> <S2SV_StartBug> source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; <S2SV_EndBug>"
5997,CWE-119,"SNDFILE * sf_open ( const char * path , int mode , SF_INFO * sfinfo ) { SF_PRIVATE * psf ; assert ( sizeof ( sf_count_t ) == 8 ) ; <S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug> { sf_errno = SFE_MALLOC_FAILED ; return NULL ; } ; psf_init_files ( psf ) ; psf_log_printf ( psf , ""File<S2SV_blank>:<S2SV_blank>%s\\n"" , path ) ; if ( copy_filename ( psf , path ) != 0 ) { sf_errno = psf -> error ; return NULL ; } ; psf -> file . mode = mode ; if ( strcmp ( path , ""-"" ) == 0 ) psf -> error = psf_set_stdio ( psf ) ; else psf -> error = psf_fopen ( psf ) ; return psf_open_file ( psf , sfinfo ) ; }
","<S2SV_ModStart> ( psf = psf_allocate ( <S2SV_ModEnd> ) ) ==
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,"<S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug>"
986,CWE-119,"static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_EndBug> coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } <S2SV_StartBug> __reg_deduce_bounds ( dst_reg ) ; <S2SV_EndBug> __reg_bound_offset ( dst_reg ) ; return 0 ; }
","<S2SV_ModStart> , umax_val ; u64 insn_bitness = <S2SV_ModEnd> ( BPF_CLASS ( <S2SV_ModStart> -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> smin_val = src_reg <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; }
",torvalds@linux/468f6eafa6c44cb2c5d8aad35e12f06c240a812a,CVE-2017-17852,https://github.com/torvalds/linux/commit/468f6eafa6c44cb2c5d8aad35e12f06c240a812a,2017-12-27T17:08Z,<S2SV_StartBug> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> __reg_deduce_bounds ( dst_reg ) ; <S2SV_EndBug>
6948,CWE-400,"<S2SV_StartBug> static void sample_hbp_handler ( struct perf_event * bp , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { printk ( KERN_INFO ""%s<S2SV_blank>value<S2SV_blank>is<S2SV_blank>changed\\n"" , ksym_name ) ; dump_stack ( ) ; printk ( KERN_INFO ""Dump<S2SV_blank>stack<S2SV_blank>from<S2SV_blank>sample_hbp_handler\\n"" ) ; }
","<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> static void sample_hbp_handler ( struct perf_event * bp , int nmi , <S2SV_EndBug>"
1788,CWE-119,"static int find_best_16x16_intra ( VP9_COMP * cpi , <S2SV_StartBug> MB_PREDICTION_MODE * pbest_mode ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> MB_PREDICTION_MODE best_mode = - 1 , mode ; <S2SV_EndBug> unsigned int best_err = INT_MAX ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { unsigned int err ; xd -> mi [ 0 ] -> mbmi . mode = mode ; <S2SV_StartBug> vp9_predict_intra_block ( xd , 0 , 2 , TX_16X16 , mode , <S2SV_EndBug> x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , 0 , 0 , 0 ) ; <S2SV_StartBug> err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , best_err ) ; if ( err < best_err ) { best_err = err ; best_mode = mode ; } } if ( pbest_mode ) * pbest_mode = best_mode ; return best_err ; }
","<S2SV_ModStart> * cpi , PREDICTION_MODE <S2SV_ModEnd> * pbest_mode ) <S2SV_ModStart> & cpi -> td . <S2SV_ModStart> -> e_mbd ; PREDICTION_MODE <S2SV_ModEnd> best_mode = - <S2SV_ModStart> ( xd , <S2SV_ModEnd> 2 , TX_16X16 <S2SV_ModStart> ; err = vpx_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride <S2SV_ModEnd> ) ; if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> MB_PREDICTION_MODE * pbest_mode ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE best_mode = - 1 , mode ; <S2SV_EndBug> <S2SV_StartBug> vp9_predict_intra_block ( xd , 0 , 2 , TX_16X16 , mode , <S2SV_EndBug> <S2SV_StartBug> err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug>"
5921,CWE-74,"gboolean flatpak_run_add_environment_args ( FlatpakBwrap * bwrap , const char * app_info_path , FlatpakRunFlags flags , const char * app_id , FlatpakContext * context , GFile * app_id_dir , GPtrArray * previous_app_id_dirs , FlatpakExports * * exports_out , GCancellable * cancellable , GError * * error ) { g_autoptr ( GError ) my_error = NULL ; g_autoptr ( FlatpakExports ) exports = NULL ; g_autoptr ( FlatpakBwrap ) proxy_arg_bwrap = flatpak_bwrap_new ( flatpak_bwrap_empty_env ) ; gboolean has_wayland = FALSE ; gboolean allow_x11 = FALSE ; if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_IPC ) == 0 ) { g_debug ( ""Disallowing<S2SV_blank>ipc<S2SV_blank>access"" ) ; flatpak_bwrap_add_args ( bwrap , ""--unshare-ipc"" , NULL ) ; } if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_NETWORK ) == 0 ) { g_debug ( ""Disallowing<S2SV_blank>network<S2SV_blank>access"" ) ; flatpak_bwrap_add_args ( bwrap , ""--unshare-net"" , NULL ) ; } if ( context -> devices & FLATPAK_CONTEXT_DEVICE_ALL ) { flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , ""/dev"" , ""/dev"" , NULL ) ; if ( g_file_test ( ""/dev/shm"" , G_FILE_TEST_IS_DIR ) ) { if ( ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM ) == 0 ) flatpak_bwrap_add_args ( bwrap , ""--tmpfs"" , ""/dev/shm"" , NULL ) ; } else if ( g_file_test ( ""/dev/shm"" , G_FILE_TEST_IS_SYMLINK ) ) { g_autofree char * link = flatpak_readlink ( ""/dev/shm"" , NULL ) ; if ( g_strcmp0 ( link , ""/run/shm"" ) == 0 ) { if ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM && g_file_test ( ""/run/shm"" , G_FILE_TEST_IS_DIR ) ) flatpak_bwrap_add_args ( bwrap , ""--bind"" , ""/run/shm"" , ""/run/shm"" , NULL ) ; else flatpak_bwrap_add_args ( bwrap , ""--dir"" , ""/run/shm"" , NULL ) ; } else g_warning ( ""Unexpected<S2SV_blank>/dev/shm<S2SV_blank>symlink<S2SV_blank>%s"" , link ) ; } } else { flatpak_bwrap_add_args ( bwrap , ""--dev"" , ""/dev"" , NULL ) ; if ( context -> devices & FLATPAK_CONTEXT_DEVICE_DRI ) { g_debug ( ""Allowing<S2SV_blank>dri<S2SV_blank>access"" ) ; int i ; char * dri_devices [ ] = { ""/dev/dri"" , ""/dev/mali"" , ""/dev/mali0"" , ""/dev/umplock"" , ""/dev/nvidiactl"" , ""/dev/nvidia-modeset"" , ""/dev/nvidia-uvm"" , ""/dev/nvidia-uvm-tools"" , } ; for ( i = 0 ; i < G_N_ELEMENTS ( dri_devices ) ; i ++ ) { if ( g_file_test ( dri_devices [ i ] , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , dri_devices [ i ] , dri_devices [ i ] , NULL ) ; } char nvidia_dev [ 14 ] ; for ( i = 0 ; i < 20 ; i ++ ) { g_snprintf ( nvidia_dev , sizeof ( nvidia_dev ) , ""/dev/nvidia%d"" , i ) ; if ( g_file_test ( nvidia_dev , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , nvidia_dev , nvidia_dev , NULL ) ; } } if ( context -> devices & FLATPAK_CONTEXT_DEVICE_KVM ) { g_debug ( ""Allowing<S2SV_blank>kvm<S2SV_blank>access"" ) ; if ( g_file_test ( ""/dev/kvm"" , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , ""/dev/kvm"" , ""/dev/kvm"" , NULL ) ; } if ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM ) { g_autofree char * real_dev_shm = realpath ( ""/dev/shm"" , NULL ) ; g_debug ( ""Allowing<S2SV_blank>/dev/shm<S2SV_blank>access<S2SV_blank>(as<S2SV_blank>%s)"" , real_dev_shm ) ; if ( real_dev_shm != NULL ) flatpak_bwrap_add_args ( bwrap , ""--bind"" , real_dev_shm , ""/dev/shm"" , NULL ) ; } } flatpak_context_append_bwrap_filesystem ( context , bwrap , app_id , app_id_dir , previous_app_id_dirs , & exports ) ; if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND ) { g_debug ( ""Allowing<S2SV_blank>wayland<S2SV_blank>access"" ) ; has_wayland = flatpak_run_add_wayland_args ( bwrap ) ; } if ( ( context -> sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11 ) != 0 ) allow_x11 = ! has_wayland ; else allow_x11 = ( context -> sockets & FLATPAK_CONTEXT_SOCKET_X11 ) != 0 ; flatpak_run_add_x11_args ( bwrap , allow_x11 ) ; if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH ) { flatpak_run_add_ssh_args ( bwrap ) ; } if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO ) { g_debug ( ""Allowing<S2SV_blank>pulseaudio<S2SV_blank>access"" ) ; flatpak_run_add_pulseaudio_args ( bwrap ) ; } if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_PCSC ) { flatpak_run_add_pcsc_args ( bwrap ) ; } if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_CUPS ) { flatpak_run_add_cups_args ( bwrap ) ; } flatpak_run_add_session_dbus_args ( bwrap , proxy_arg_bwrap , context , flags , app_id ) ; flatpak_run_add_system_dbus_args ( bwrap , proxy_arg_bwrap , context , flags ) ; flatpak_run_add_a11y_dbus_args ( bwrap , proxy_arg_bwrap , context , flags ) ; <S2SV_StartBug> if ( g_environ_getenv ( bwrap -> envp , ""LD_LIBRARY_PATH"" ) != NULL ) <S2SV_EndBug> { flatpak_bwrap_add_args ( bwrap , ""--setenv"" , ""LD_LIBRARY_PATH"" , g_environ_getenv ( bwrap -> envp , ""LD_LIBRARY_PATH"" ) , NULL ) ; flatpak_bwrap_unset_env ( bwrap , ""LD_LIBRARY_PATH"" ) ; } if ( g_environ_getenv ( bwrap -> envp , ""TMPDIR"" ) != NULL ) { flatpak_bwrap_add_args ( bwrap , ""--setenv"" , ""TMPDIR"" , g_environ_getenv ( bwrap -> envp , ""TMPDIR"" ) , NULL ) ; flatpak_bwrap_unset_env ( bwrap , ""TMPDIR"" ) ; } if ( ! flatpak_run_in_transient_unit ( app_id , & my_error ) ) { g_debug ( ""Failed<S2SV_blank>to<S2SV_blank>run<S2SV_blank>in<S2SV_blank>transient<S2SV_blank>scope:<S2SV_blank>%s"" , my_error -> message ) ; g_clear_error ( & my_error ) ; } if ( ! flatpak_bwrap_is_empty ( proxy_arg_bwrap ) && ! start_dbus_proxy ( bwrap , proxy_arg_bwrap , app_info_path , error ) ) return FALSE ; if ( exports_out ) * exports_out = g_steal_pointer ( & exports ) ; return TRUE ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! flatpak_run_in_transient_unit (
",flatpak@flatpak/6d1773d2a54dde9b099043f07a2094a4f1c2f486,CVE-2021-21261,https://github.com/flatpak/flatpak/commit/6d1773d2a54dde9b099043f07a2094a4f1c2f486,2021-01-14T20:15Z,"<S2SV_StartBug> if ( g_environ_getenv ( bwrap -> envp , ""LD_LIBRARY_PATH"" ) != NULL ) <S2SV_EndBug>"
1728,CWE-119,"static INLINE void store_pred_mv ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx ) { <S2SV_StartBug> vpx_memcpy ( ctx -> pred_mv , x -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ctx ) { memcpy <S2SV_ModEnd> ( ctx ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( ctx -> pred_mv , x -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug>"
348,CWE-59,"int main ( int argc , char * * argv ) { int fd = xopen ( ""/dev/null"" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( ""Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]"" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( ""CCpp.conf"" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , ""MakeCompatCore"" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""SaveBinaryImage"" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""VerboseLog"" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || pid <= 0 ) { perror_msg_and_die ( ""PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus"" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN ""/abrt/saved_core_pattern"" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } struct utsname uts ; if ( ! argv [ 8 ] ) { uname ( & uts ) ; argv [ 8 ] = uts . nodename ; } char path [ PATH_MAX ] ; int src_fd_binary = - 1 ; char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; if ( executable && strstr ( executable , ""/abrt-hook-ccpp"" ) ) { error_msg_and_die ( ""PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion"" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( ""user_pwd:\'%s\'"" , user_pwd ) ; sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ; proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) { fsuid = tmp_fsuid ; } } if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ; goto create_user_core ; } const char * signame = NULL ; switch ( signal_no ) { case SIGILL : signame = ""ILL"" ; break ; case SIGFPE : signame = ""FPE"" ; break ; case SIGSEGV : signame = ""SEGV"" ; break ; case SIGBUS : signame = ""BUS"" ; break ; case SIGABRT : signame = ""ABRT"" ; break ; case SIGTRAP : signame = ""TRAP"" ; break ; default : goto create_user_core ; } if ( ! daemon_is_ok ( ) ) { log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'"" ) ; goto create_user_core ; } if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ; } snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { goto create_user_core ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) { snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) ; int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; return 0 ; } unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) { goto create_user_core ; } dd = dd_create ( path , fsuid , DEFAULT_DUMP_DIR_MODE ) ; if ( dd ) { char * rootdir = get_rootdir ( pid ) ; dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ; char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , ""/proc/%lu/smaps"" , ( long ) pid ) ; source_base_ofs -= strlen ( ""smaps"" ) ; char * dest_filename = concat_path_file ( dd -> dd_dirname , ""also_somewhat_longish_name"" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , ""maps"" ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""limits"" ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( rootdir ) { if ( strcmp ( rootdir , ""/"" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } char * reason = xasprintf ( ""%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s"" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : """" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : """" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; if ( src_fd_binary > 0 ) { strcpy ( path + path_len , ""/"" FILENAME_BINARY ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd_binary ) ; } strcpy ( path + path_len , ""/"" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path ) ; off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; dd_delete ( dd ) ; if ( user_core_fd >= 0 ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } error_msg_and_die ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , path ) ; } if ( user_core_fd >= 0 && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || ( ulimit_c == 0 || core_size > ulimit_c ) ) ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } <S2SV_StartBug> { <S2SV_EndBug> char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( ""%s/hs_err_pid%lu.log"" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , ""/hs_err.log"" ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd ) ; } <S2SV_StartBug> } <S2SV_EndBug> dd_close ( dd ) ; path [ path_len ] = '\\0' ; char * newpath = xstrndup ( path , path_len - ( sizeof ( "".new"" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } free ( rootdir ) ; return 0 ; } create_user_core : if ( user_core_fd >= 0 ) { off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) { perror_msg ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , full_core_basename ) ; xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } if ( ulimit_c == 0 || core_size > ulimit_c ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , full_core_basename , ( long long ) core_size ) ; } return 0 ; }
","<S2SV_ModStart> ) ; } # if 0 <S2SV_ModStart> ; } } # endif
",abrt@abrt/17cb66b13997b0159b4253b3f5722db79f476d68,CVE-2015-3315,https://github.com/abrt/abrt/commit/17cb66b13997b0159b4253b3f5722db79f476d68,2017-06-26T15:29Z,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
4146,CWE-254,"IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data ( dec_state_t * ps_dec ) { stream_t * ps_stream ; UWORD32 u4_start_code ; IMPEG2D_ERROR_CODES_T e_error ; e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && <S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug> { if ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_dec_user_data ( ps_dec ) ; } else { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , EXT_ID_LEN ) ; switch ( u4_start_code ) { case SEQ_DISPLAY_EXT_ID : impeg2d_dec_seq_disp_ext ( ps_dec ) ; break ; case SEQ_SCALABLE_EXT_ID : e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED ; break ; default : impeg2d_bit_stream_flush ( ps_stream , EXT_ID_LEN ) ; impeg2d_peek_next_start_code ( ps_dec ) ; break ; } } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } return e_error ; }
","<S2SV_ModStart> IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
",external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3,CVE-2016-0824,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,2016-03-12T21:59Z,<S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug>
5054,CWE-189,"static VarBit * bit_catenate ( VarBit * arg1 , VarBit * arg2 ) { VarBit * result ; int bitlen1 , bitlen2 , bytelen , bit1pad , bit2shift ; bits8 * pr , * pa ; bitlen1 = VARBITLEN ( arg1 ) ; <S2SV_StartBug> bitlen2 = VARBITLEN ( arg2 ) ; <S2SV_EndBug> bytelen = VARBITTOTALLEN ( bitlen1 + bitlen2 ) ; result = ( VarBit * ) palloc ( bytelen ) ; SET_VARSIZE ( result , bytelen ) ; VARBITLEN ( result ) = bitlen1 + bitlen2 ; memcpy ( VARBITS ( result ) , VARBITS ( arg1 ) , VARBITBYTES ( arg1 ) ) ; bit1pad = VARBITPAD ( arg1 ) ; if ( bit1pad == 0 ) { memcpy ( VARBITS ( result ) + VARBITBYTES ( arg1 ) , VARBITS ( arg2 ) , VARBITBYTES ( arg2 ) ) ; } else if ( bitlen2 > 0 ) { bit2shift = BITS_PER_BYTE - bit1pad ; pr = VARBITS ( result ) + VARBITBYTES ( arg1 ) - 1 ; for ( pa = VARBITS ( arg2 ) ; pa < VARBITEND ( arg2 ) ; pa ++ ) { * pr |= ( ( * pa >> bit2shift ) & BITMASK ) ; pr ++ ; if ( pr < VARBITEND ( result ) ) * pr = ( * pa << bit1pad ) & BITMASK ; } } return result ; }
","<S2SV_ModStart> VARBITLEN ( arg2 ) ; if ( bitlen1 > VARBITMAXLEN - bitlen2 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) )
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,<S2SV_StartBug> bitlen2 = VARBITLEN ( arg2 ) ; <S2SV_EndBug>
8426,CWE-74,"int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , ""200"" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , ""201"" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( ""%s"" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , ""MODE<S2SV_blank>READER\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , ""200"" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , ""201"" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode"" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( ""Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s"" ) , conn -> account . host , posting ? _ ( ""Posting<S2SV_blank>is<S2SV_blank>ok"" ) : _ ( ""Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok"" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , ""STARTTLS\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , ""382"" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( ""STARTTLS:<S2SV_blank>%s"" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , ""STAT\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , ""480"" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode"" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }
","<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;
",neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc,CVE-2020-14954,https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc,2020-06-21T17:15Z,<S2SV_StartBug> } <S2SV_EndBug>
7745,CWE-000,"<S2SV_StartBug> static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) <S2SV_EndBug> { struct nfs_delegation * delegation ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( inode ) -> delegation ) ; <S2SV_StartBug> if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) { <S2SV_EndBug> rcu_read_unlock ( ) ; return ; } rcu_read_unlock ( ) ; nfs_inode_return_delegation ( inode ) ; }
","<S2SV_ModStart> * inode , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> -> type & fmode ) == fmode <S2SV_ModEnd> ) { rcu_read_unlock
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) <S2SV_EndBug> <S2SV_StartBug> if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) { <S2SV_EndBug>"
959,CWE-119,"SQLRETURN SQLSetDescField ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>SQL_INVALID_HANDLE"" ) ; return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; } else if ( CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { SQLWCHAR * s1 = NULL ; if ( isStrField ) { s1 = ansi_to_unicode_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; if ( SQL_NTS != buffer_length ) { buffer_length *= sizeof ( SQLWCHAR ) ; } } else { s1 = value ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , s1 , buffer_length ) ; if ( isStrField ) { if ( s1 ) free ( s1 ) ; } } else { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }
","<S2SV_ModStart> -> msg , ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )
",lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f,CVE-2018-7485,https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f#diff-d52750c7ba4e594410438569d8e2963aL24,2018-02-26T14:29Z,"<S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug>"
4844,CWE-401,"static int i40e_setup_macvlans ( struct i40e_vsi * vsi , u16 macvlan_cnt , u16 qcnt , struct net_device * vdev ) { struct i40e_pf * pf = vsi -> back ; struct i40e_hw * hw = & pf -> hw ; struct i40e_vsi_context ctxt ; u16 sections , qmap , num_qps ; struct i40e_channel * ch ; int i , pow , ret = 0 ; u8 offset = 0 ; if ( vsi -> type != I40E_VSI_MAIN || ! macvlan_cnt ) return - EINVAL ; num_qps = vsi -> num_queue_pairs - ( macvlan_cnt * qcnt ) ; pow = fls ( roundup_pow_of_two ( num_qps ) - 1 ) ; qmap = ( offset << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT ) | ( pow << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT ) ; sections = I40E_AQ_VSI_PROP_QUEUE_MAP_VALID ; sections |= I40E_AQ_VSI_PROP_SCHED_VALID ; memset ( & ctxt , 0 , sizeof ( ctxt ) ) ; ctxt . seid = vsi -> seid ; ctxt . pf_num = vsi -> back -> hw . pf_id ; ctxt . vf_num = 0 ; ctxt . uplink_seid = vsi -> uplink_seid ; ctxt . info = vsi -> info ; ctxt . info . tc_mapping [ 0 ] = cpu_to_le16 ( qmap ) ; ctxt . info . mapping_flags |= cpu_to_le16 ( I40E_AQ_VSI_QUE_MAP_CONTIG ) ; ctxt . info . queue_mapping [ 0 ] = cpu_to_le16 ( vsi -> base_queue ) ; ctxt . info . valid_sections |= cpu_to_le16 ( sections ) ; vsi -> rss_size = max_t ( u16 , num_qps , qcnt ) ; ret = i40e_vsi_config_rss ( vsi ) ; if ( ret ) { dev_info ( & pf -> pdev -> dev , ""Failed<S2SV_blank>to<S2SV_blank>reconfig<S2SV_blank>RSS<S2SV_blank>for<S2SV_blank>num_queues<S2SV_blank>(%u)\\n"" , vsi -> rss_size ) ; return ret ; } vsi -> reconfig_rss = true ; dev_dbg ( & vsi -> back -> pdev -> dev , ""Reconfigured<S2SV_blank>RSS<S2SV_blank>with<S2SV_blank>num_queues<S2SV_blank>(%u)\\n"" , vsi -> rss_size ) ; vsi -> next_base_queue = num_qps ; vsi -> cnt_q_avail = vsi -> num_queue_pairs - num_qps ; ret = i40e_aq_update_vsi_params ( hw , & ctxt , NULL ) ; if ( ret ) { dev_info ( & pf -> pdev -> dev , ""Update<S2SV_blank>vsi<S2SV_blank>tc<S2SV_blank>config<S2SV_blank>failed,<S2SV_blank>err<S2SV_blank>%s<S2SV_blank>aq_err<S2SV_blank>%s\\n"" , i40e_stat_str ( hw , ret ) , i40e_aq_str ( hw , hw -> aq . asq_last_status ) ) ; return ret ; } i40e_vsi_update_queue_map ( vsi , & ctxt ) ; vsi -> info . valid_sections = 0 ; INIT_LIST_HEAD ( & vsi -> macvlan_list ) ; for ( i = 0 ; i < macvlan_cnt ; i ++ ) { ch = kzalloc ( sizeof ( * ch ) , GFP_KERNEL ) ; if ( ! ch ) { ret = - ENOMEM ; goto err_free ; } INIT_LIST_HEAD ( & ch -> list ) ; ch -> num_queue_pairs = qcnt ; if ( ! i40e_setup_channel ( pf , vsi , ch ) ) { ret = - EINVAL ; <S2SV_StartBug> goto err_free ; <S2SV_EndBug> } ch -> parent_vsi = vsi ; vsi -> cnt_q_avail -= ch -> num_queue_pairs ; vsi -> macvlan_cnt ++ ; list_add_tail ( & ch -> list , & vsi -> macvlan_list ) ; } return ret ; err_free : dev_info ( & pf -> pdev -> dev , ""Failed<S2SV_blank>to<S2SV_blank>setup<S2SV_blank>macvlans\\n"" ) ; i40e_free_macvlan_channels ( vsi ) ; return ret ; }
","<S2SV_ModStart> - EINVAL ; kfree ( ch ) ;
",torvalds@linux/27d461333459d282ffa4a2bdb6b215a59d493a8f,CVE-2019-19043,https://github.com/torvalds/linux/commit/27d461333459d282ffa4a2bdb6b215a59d493a8f,2019-11-18T06:15Z,<S2SV_StartBug> goto err_free ; <S2SV_EndBug>
3642,CWE-125,"static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property , ExceptionInfo * exception ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\n"" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005 <S2SV_StartBug> # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char * description ; } TagInfo ; static TagInfo EXIFTag [ ] = { { 0x001 , ""exif:InteroperabilityIndex"" } , { 0x002 , ""exif:InteroperabilityVersion"" } , { 0x100 , ""exif:ImageWidth"" } , { 0x101 , ""exif:ImageLength"" } , { 0x102 , ""exif:BitsPerSample"" } , { 0x103 , ""exif:Compression"" } , { 0x106 , ""exif:PhotometricInterpretation"" } , { 0x10a , ""exif:FillOrder"" } , { 0x10d , ""exif:DocumentName"" } , { 0x10e , ""exif:ImageDescription"" } , { 0x10f , ""exif:Make"" } , { 0x110 , ""exif:Model"" } , { 0x111 , ""exif:StripOffsets"" } , { 0x112 , ""exif:Orientation"" } , { 0x115 , ""exif:SamplesPerPixel"" } , { 0x116 , ""exif:RowsPerStrip"" } , { 0x117 , ""exif:StripByteCounts"" } , { 0x11a , ""exif:XResolution"" } , { 0x11b , ""exif:YResolution"" } , { 0x11c , ""exif:PlanarConfiguration"" } , { 0x11d , ""exif:PageName"" } , { 0x11e , ""exif:XPosition"" } , { 0x11f , ""exif:YPosition"" } , { 0x118 , ""exif:MinSampleValue"" } , { 0x119 , ""exif:MaxSampleValue"" } , { 0x120 , ""exif:FreeOffsets"" } , { 0x121 , ""exif:FreeByteCounts"" } , { 0x122 , ""exif:GrayResponseUnit"" } , { 0x123 , ""exif:GrayResponseCurve"" } , { 0x124 , ""exif:T4Options"" } , { 0x125 , ""exif:T6Options"" } , { 0x128 , ""exif:ResolutionUnit"" } , { 0x12d , ""exif:TransferFunction"" } , { 0x131 , ""exif:Software"" } , { 0x132 , ""exif:DateTime"" } , { 0x13b , ""exif:Artist"" } , { 0x13e , ""exif:WhitePoint"" } , { 0x13f , ""exif:PrimaryChromaticities"" } , { 0x140 , ""exif:ColorMap"" } , { 0x141 , ""exif:HalfToneHints"" } , { 0x142 , ""exif:TileWidth"" } , { 0x143 , ""exif:TileLength"" } , { 0x144 , ""exif:TileOffsets"" } , { 0x145 , ""exif:TileByteCounts"" } , { 0x14a , ""exif:SubIFD"" } , { 0x14c , ""exif:InkSet"" } , { 0x14d , ""exif:InkNames"" } , { 0x14e , ""exif:NumberOfInks"" } , { 0x150 , ""exif:DotRange"" } , { 0x151 , ""exif:TargetPrinter"" } , { 0x152 , ""exif:ExtraSample"" } , { 0x153 , ""exif:SampleFormat"" } , { 0x154 , ""exif:SMinSampleValue"" } , { 0x155 , ""exif:SMaxSampleValue"" } , { 0x156 , ""exif:TransferRange"" } , { 0x157 , ""exif:ClipPath"" } , { 0x158 , ""exif:XClipPathUnits"" } , { 0x159 , ""exif:YClipPathUnits"" } , { 0x15a , ""exif:Indexed"" } , { 0x15b , ""exif:JPEGTables"" } , { 0x15f , ""exif:OPIProxy"" } , { 0x200 , ""exif:JPEGProc"" } , { 0x201 , ""exif:JPEGInterchangeFormat"" } , { 0x202 , ""exif:JPEGInterchangeFormatLength"" } , { 0x203 , ""exif:JPEGRestartInterval"" } , { 0x205 , ""exif:JPEGLosslessPredictors"" } , { 0x206 , ""exif:JPEGPointTransforms"" } , { 0x207 , ""exif:JPEGQTables"" } , { 0x208 , ""exif:JPEGDCTables"" } , { 0x209 , ""exif:JPEGACTables"" } , { 0x211 , ""exif:YCbCrCoefficients"" } , { 0x212 , ""exif:YCbCrSubSampling"" } , { 0x213 , ""exif:YCbCrPositioning"" } , { 0x214 , ""exif:ReferenceBlackWhite"" } , { 0x2bc , ""exif:ExtensibleMetadataPlatform"" } , { 0x301 , ""exif:Gamma"" } , { 0x302 , ""exif:ICCProfileDescriptor"" } , { 0x303 , ""exif:SRGBRenderingIntent"" } , { 0x320 , ""exif:ImageTitle"" } , { 0x5001 , ""exif:ResolutionXUnit"" } , { 0x5002 , ""exif:ResolutionYUnit"" } , { 0x5003 , ""exif:ResolutionXLengthUnit"" } , { 0x5004 , ""exif:ResolutionYLengthUnit"" } , { 0x5005 , ""exif:PrintFlags"" } , { 0x5006 , ""exif:PrintFlagsVersion"" } , { 0x5007 , ""exif:PrintFlagsCrop"" } , { 0x5008 , ""exif:PrintFlagsBleedWidth"" } , { 0x5009 , ""exif:PrintFlagsBleedWidthScale"" } , { 0x500A , ""exif:HalftoneLPI"" } , { 0x500B , ""exif:HalftoneLPIUnit"" } , { 0x500C , ""exif:HalftoneDegree"" } , { 0x500D , ""exif:HalftoneShape"" } , { 0x500E , ""exif:HalftoneMisc"" } , { 0x500F , ""exif:HalftoneScreen"" } , { 0x5010 , ""exif:JPEGQuality"" } , { 0x5011 , ""exif:GridSize"" } , { 0x5012 , ""exif:ThumbnailFormat"" } , { 0x5013 , ""exif:ThumbnailWidth"" } , { 0x5014 , ""exif:ThumbnailHeight"" } , { 0x5015 , ""exif:ThumbnailColorDepth"" } , { 0x5016 , ""exif:ThumbnailPlanes"" } , { 0x5017 , ""exif:ThumbnailRawBytes"" } , { 0x5018 , ""exif:ThumbnailSize"" } , { 0x5019 , ""exif:ThumbnailCompressedSize"" } , { 0x501a , ""exif:ColorTransferFunction"" } , { 0x501b , ""exif:ThumbnailData"" } , { 0x5020 , ""exif:ThumbnailImageWidth"" } , { 0x5021 , ""exif:ThumbnailImageHeight"" } , { 0x5022 , ""exif:ThumbnailBitsPerSample"" } , { 0x5023 , ""exif:ThumbnailCompression"" } , { 0x5024 , ""exif:ThumbnailPhotometricInterp"" } , { 0x5025 , ""exif:ThumbnailImageDescription"" } , { 0x5026 , ""exif:ThumbnailEquipMake"" } , { 0x5027 , ""exif:ThumbnailEquipModel"" } , { 0x5028 , ""exif:ThumbnailStripOffsets"" } , { 0x5029 , ""exif:ThumbnailOrientation"" } , { 0x502a , ""exif:ThumbnailSamplesPerPixel"" } , { 0x502b , ""exif:ThumbnailRowsPerStrip"" } , { 0x502c , ""exif:ThumbnailStripBytesCount"" } , { 0x502d , ""exif:ThumbnailResolutionX"" } , { 0x502e , ""exif:ThumbnailResolutionY"" } , { 0x502f , ""exif:ThumbnailPlanarConfig"" } , { 0x5030 , ""exif:ThumbnailResolutionUnit"" } , { 0x5031 , ""exif:ThumbnailTransferFunction"" } , { 0x5032 , ""exif:ThumbnailSoftwareUsed"" } , { 0x5033 , ""exif:ThumbnailDateTime"" } , { 0x5034 , ""exif:ThumbnailArtist"" } , { 0x5035 , ""exif:ThumbnailWhitePoint"" } , { 0x5036 , ""exif:ThumbnailPrimaryChromaticities"" } , { 0x5037 , ""exif:ThumbnailYCbCrCoefficients"" } , { 0x5038 , ""exif:ThumbnailYCbCrSubsampling"" } , { 0x5039 , ""exif:ThumbnailYCbCrPositioning"" } , { 0x503A , ""exif:ThumbnailRefBlackWhite"" } , { 0x503B , ""exif:ThumbnailCopyRight"" } , { 0x5090 , ""exif:LuminanceTable"" } , { 0x5091 , ""exif:ChrominanceTable"" } , { 0x5100 , ""exif:FrameDelay"" } , { 0x5101 , ""exif:LoopCount"" } , { 0x5110 , ""exif:PixelUnit"" } , { 0x5111 , ""exif:PixelPerUnitX"" } , { 0x5112 , ""exif:PixelPerUnitY"" } , { 0x5113 , ""exif:PaletteHistogram"" } , { 0x1000 , ""exif:RelatedImageFileFormat"" } , { 0x1001 , ""exif:RelatedImageLength"" } , { 0x1002 , ""exif:RelatedImageWidth"" } , { 0x800d , ""exif:ImageID"" } , { 0x80e3 , ""exif:Matteing"" } , { 0x80e4 , ""exif:DataType"" } , { 0x80e5 , ""exif:ImageDepth"" } , { 0x80e6 , ""exif:TileDepth"" } , { 0x828d , ""exif:CFARepeatPatternDim"" } , { 0x828e , ""exif:CFAPattern2"" } , { 0x828f , ""exif:BatteryLevel"" } , { 0x8298 , ""exif:Copyright"" } , { 0x829a , ""exif:ExposureTime"" } , { 0x829d , ""exif:FNumber"" } , { 0x83bb , ""exif:IPTC/NAA"" } , { 0x84e3 , ""exif:IT8RasterPadding"" } , { 0x84e5 , ""exif:IT8ColorTable"" } , { 0x8649 , ""exif:ImageResourceInformation"" } , { 0x8769 , ""exif:ExifOffset"" } , { 0x8773 , ""exif:InterColorProfile"" } , { 0x8822 , ""exif:ExposureProgram"" } , { 0x8824 , ""exif:SpectralSensitivity"" } , { 0x8825 , ""exif:GPSInfo"" } , { 0x8827 , ""exif:ISOSpeedRatings"" } , { 0x8828 , ""exif:OECF"" } , { 0x8829 , ""exif:Interlace"" } , { 0x882a , ""exif:TimeZoneOffset"" } , { 0x882b , ""exif:SelfTimerMode"" } , { 0x9000 , ""exif:ExifVersion"" } , { 0x9003 , ""exif:DateTimeOriginal"" } , { 0x9004 , ""exif:DateTimeDigitized"" } , { 0x9101 , ""exif:ComponentsConfiguration"" } , { 0x9102 , ""exif:CompressedBitsPerPixel"" } , { 0x9201 , ""exif:ShutterSpeedValue"" } , { 0x9202 , ""exif:ApertureValue"" } , { 0x9203 , ""exif:BrightnessValue"" } , { 0x9204 , ""exif:ExposureBiasValue"" } , { 0x9205 , ""exif:MaxApertureValue"" } , { 0x9206 , ""exif:SubjectDistance"" } , { 0x9207 , ""exif:MeteringMode"" } , { 0x9208 , ""exif:LightSource"" } , { 0x9209 , ""exif:Flash"" } , { 0x920a , ""exif:FocalLength"" } , { 0x920b , ""exif:FlashEnergy"" } , { 0x920c , ""exif:SpatialFrequencyResponse"" } , { 0x920d , ""exif:Noise"" } , { 0x9211 , ""exif:ImageNumber"" } , { 0x9212 , ""exif:SecurityClassification"" } , { 0x9213 , ""exif:ImageHistory"" } , { 0x9214 , ""exif:SubjectArea"" } , { 0x9215 , ""exif:ExposureIndex"" } , { 0x9216 , ""exif:TIFF-EPStandardID"" } , { 0x927c , ""exif:MakerNote"" } , { 0x9C9b , ""exif:WinXP-Title"" } , { 0x9C9c , ""exif:WinXP-Comments"" } , { 0x9C9d , ""exif:WinXP-Author"" } , { 0x9C9e , ""exif:WinXP-Keywords"" } , { 0x9C9f , ""exif:WinXP-Subject"" } , { 0x9286 , ""exif:UserComment"" } , { 0x9290 , ""exif:SubSecTime"" } , { 0x9291 , ""exif:SubSecTimeOriginal"" } , { 0x9292 , ""exif:SubSecTimeDigitized"" } , { 0xa000 , ""exif:FlashPixVersion"" } , { 0xa001 , ""exif:ColorSpace"" } , { 0xa002 , ""exif:ExifImageWidth"" } , { 0xa003 , ""exif:ExifImageLength"" } , { 0xa004 , ""exif:RelatedSoundFile"" } , { 0xa005 , ""exif:InteroperabilityOffset"" } , { 0xa20b , ""exif:FlashEnergy"" } , { 0xa20c , ""exif:SpatialFrequencyResponse"" } , { 0xa20d , ""exif:Noise"" } , { 0xa20e , ""exif:FocalPlaneXResolution"" } , { 0xa20f , ""exif:FocalPlaneYResolution"" } , { 0xa210 , ""exif:FocalPlaneResolutionUnit"" } , { 0xa214 , ""exif:SubjectLocation"" } , { 0xa215 , ""exif:ExposureIndex"" } , { 0xa216 , ""exif:TIFF/EPStandardID"" } , { 0xa217 , ""exif:SensingMethod"" } , { 0xa300 , ""exif:FileSource"" } , { 0xa301 , ""exif:SceneType"" } , { 0xa302 , ""exif:CFAPattern"" } , { 0xa401 , ""exif:CustomRendered"" } , { 0xa402 , ""exif:ExposureMode"" } , { 0xa403 , ""exif:WhiteBalance"" } , { 0xa404 , ""exif:DigitalZoomRatio"" } , { 0xa405 , ""exif:FocalLengthIn35mmFilm"" } , { 0xa406 , ""exif:SceneCaptureType"" } , { 0xa407 , ""exif:GainControl"" } , { 0xa408 , ""exif:Contrast"" } , { 0xa409 , ""exif:Saturation"" } , { 0xa40a , ""exif:Sharpness"" } , { 0xa40b , ""exif:DeviceSettingDescription"" } , { 0xa40c , ""exif:SubjectDistanceRange"" } , { 0xa420 , ""exif:ImageUniqueID"" } , { 0xc4a5 , ""exif:PrintImageMatching"" } , { 0xa500 , ""exif:Gamma"" } , { 0xc640 , ""exif:CR2Slice"" } , { 0x10000 , ""exif:GPSVersionID"" } , { 0x10001 , ""exif:GPSLatitudeRef"" } , { 0x10002 , ""exif:GPSLatitude"" } , { 0x10003 , ""exif:GPSLongitudeRef"" } , { 0x10004 , ""exif:GPSLongitude"" } , { 0x10005 , ""exif:GPSAltitudeRef"" } , { 0x10006 , ""exif:GPSAltitude"" } , { 0x10007 , ""exif:GPSTimeStamp"" } , { 0x10008 , ""exif:GPSSatellites"" } , { 0x10009 , ""exif:GPSStatus"" } , { 0x1000a , ""exif:GPSMeasureMode"" } , { 0x1000b , ""exif:GPSDop"" } , { 0x1000c , ""exif:GPSSpeedRef"" } , { 0x1000d , ""exif:GPSSpeed"" } , { 0x1000e , ""exif:GPSTrackRef"" } , { 0x1000f , ""exif:GPSTrack"" } , { 0x10010 , ""exif:GPSImgDirectionRef"" } , { 0x10011 , ""exif:GPSImgDirection"" } , { 0x10012 , ""exif:GPSMapDatum"" } , { 0x10013 , ""exif:GPSDestLatitudeRef"" } , { 0x10014 , ""exif:GPSDestLatitude"" } , { 0x10015 , ""exif:GPSDestLongitudeRef"" } , { 0x10016 , ""exif:GPSDestLongitude"" } , { 0x10017 , ""exif:GPSDestBearingRef"" } , { 0x10018 , ""exif:GPSDestBearing"" } , { 0x10019 , ""exif:GPSDestDistanceRef"" } , { 0x1001a , ""exif:GPSDestDistance"" } , { 0x1001b , ""exif:GPSProcessingMethod"" } , { 0x1001c , ""exif:GPSAreaInformation"" } , { 0x1001d , ""exif:GPSDateStamp"" } , { 0x1001e , ""exif:GPSDifferential"" } , { 0x00000 , ( const char * ) NULL } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; register ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , ""exif"" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { register unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ; <S2SV_StartBug> if ( GetValueFromSplayTree ( exif_resources , q ) == q ) <S2SV_EndBug> break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ; <S2SV_StartBug> components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ; <S2SV_EndBug> number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) continue ; if ( ( ssize_t ) ( offset + number_bytes ) < offset ) continue ; if ( ( size_t ) ( offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MagickPathExtent ] , * value ; value = ( char * ) NULL ; * buffer = '\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( unsigned char * ) p1 ) ) ; break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , ""%hd"" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , ""%hu"" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { EXIFMultipleValues ( 4 , ""%f"" , ( double ) * ( float * ) p1 ) ; break ; } case EXIF_FMT_DOUBLE : { EXIFMultipleValues ( 8 , ""%f"" , * ( double * ) p1 ) ; break ; } default : case EXIF_FMT_STRING : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; register const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; register ssize_t i ; description = ""unknown"" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MagickPathExtent , ""%s"" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""#%04lx"" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""@%04lx"" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MagickPathExtent , ""unknown"" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value , exception ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }
","<S2SV_ModStart> , arg ) \\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\n} <S2SV_ModEnd> # define EXIFMultipleFractions <S2SV_ModStart> , arg2 ) \\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\n} <S2SV_ModEnd> typedef struct _DirectoryInfo <S2SV_ModStart> ; if ( q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> + 4 ) ; if ( components < 0 ) break
",ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5842,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z,"<S2SV_StartBug> # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( GetValueFromSplayTree ( exif_resources , q ) == q ) <S2SV_EndBug> <S2SV_StartBug> components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ; <S2SV_EndBug>"
1781,CWE-119,"static void zero_stats ( FIRSTPASS_STATS * section ) { <S2SV_StartBug> section -> frame = 0.0 ; <S2SV_EndBug> section -> intra_error = 0.0 ; section -> coded_error = 0.0 ; <S2SV_StartBug> section -> sr_coded_error = 0.0 ; <S2SV_EndBug> section -> ssim_weighted_pred_err = 0.0 ; section -> pcnt_inter = 0.0 ; section -> pcnt_motion = 0.0 ; section -> pcnt_second_ref = 0.0 ; <S2SV_StartBug> section -> pcnt_neutral = 0.0 ; <S2SV_EndBug> section -> MVr = 0.0 ; section -> mvr_abs = 0.0 ; section -> MVc = 0.0 ; section -> mvc_abs = 0.0 ; section -> MVrv = 0.0 ; section -> MVcv = 0.0 ; section -> mv_in_out_count = 0.0 ; section -> new_mv_count = 0.0 ; section -> count = 0.0 ; section -> duration = 1.0 ; section -> spatial_layer_id = 0 ; }
","<S2SV_ModStart> section -> frame = 0.0 ; section -> weight <S2SV_ModStart> section -> sr_coded_error <S2SV_ModEnd> = 0.0 ; <S2SV_ModStart> section -> pcnt_neutral = 0.0 ; section -> intra_skip_pct = 0.0 ; section -> inactive_zone_rows = 0.0 ; section -> inactive_zone_cols
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> section -> frame = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> section -> sr_coded_error = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> section -> pcnt_neutral = 0.0 ; <S2SV_EndBug>
7798,CWE-125,"static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; <S2SV_StartBug> arg = arg ( argname , annotation , LINENO ( ch ) , ch -> n_col_offset , <S2SV_EndBug> ch -> n_end_lineno , ch -> n_end_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; <S2SV_StartBug> i += 2 ; <S2SV_EndBug> break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }
","<S2SV_ModStart> , annotation , NULL , <S2SV_ModStart> ; i += 1 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 <S2SV_ModEnd> ; break ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> arg = arg ( argname , annotation , LINENO ( ch ) , ch -> n_col_offset , <S2SV_EndBug> <S2SV_StartBug> i += 2 ; <S2SV_EndBug>"
108,CWE-119,"static void kvp_respond_to_host ( char * key , char * value , int error ) { struct hv_kvp_msg * kvp_msg ; struct hv_kvp_msg_enumerate * kvp_data ; char * key_name ; struct icmsg_hdr * icmsghdrp ; int keylen , valuelen ; u32 buf_len ; struct vmbus_channel * channel ; u64 req_id ; if ( ! kvp_transaction . active ) { pr_warn ( ""KVP:<S2SV_blank>Transaction<S2SV_blank>not<S2SV_blank>active\\n"" ) ; return ; } buf_len = kvp_transaction . recv_len ; channel = kvp_transaction . recv_channel ; req_id = kvp_transaction . recv_req_id ; kvp_transaction . active = false ; if ( channel -> onchannel_callback == NULL ) return ; icmsghdrp = ( struct icmsg_hdr * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) ] ; kvp_msg = ( struct hv_kvp_msg * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) + sizeof ( struct icmsg_hdr ) ] ; kvp_data = & kvp_msg -> kvp_data ; key_name = key ; if ( error ) { icmsghdrp -> status = HV_E_FAIL ; goto response_done ; } <S2SV_StartBug> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . key ) ; <S2SV_EndBug> kvp_data -> data . key_size = 2 * ( keylen + 1 ) ; <S2SV_StartBug> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . value ) ; <S2SV_EndBug> kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ; kvp_data -> data . value_type = REG_SZ ; icmsghdrp -> status = HV_S_OK ; response_done : icmsghdrp -> icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE ; vmbus_sendpacket ( channel , recv_buffer , buf_len , req_id , VM_PKT_DATA_INBAND , 0 ) ; }
","<S2SV_ModStart> key_name ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> value ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2
",torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,CVE-2013-1773,https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,2013-02-28T19:55Z,"<S2SV_StartBug> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . key ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . value ) ; <S2SV_EndBug>"
4521,CWE-125,"static int add_ast_fields ( void ) { PyObject * empty_tuple , * d ; if ( PyType_Ready ( & AST_type ) < 0 ) return - 1 ; d = AST_type . tp_dict ; empty_tuple = PyTuple_New ( 0 ) ; if ( ! empty_tuple || <S2SV_StartBug> PyDict_SetItemString ( d , ""_fields"" , empty_tuple ) < 0 || <S2SV_EndBug> <S2SV_StartBug> PyDict_SetItemString ( d , ""_attributes"" , empty_tuple ) < 0 ) { <S2SV_EndBug> Py_XDECREF ( empty_tuple ) ; return - 1 ; } Py_DECREF ( empty_tuple ) ; return 0 ; }
","<S2SV_ModStart> ! empty_tuple || _PyDict_SetItemId <S2SV_ModEnd> ( d , <S2SV_ModStart> ( d , & PyId__fields <S2SV_ModEnd> , empty_tuple ) <S2SV_ModStart> < 0 || _PyDict_SetItemId <S2SV_ModEnd> ( d , <S2SV_ModStart> ( d , & PyId__attributes <S2SV_ModEnd> , empty_tuple )
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> PyDict_SetItemString ( d , ""_fields"" , empty_tuple ) < 0 || <S2SV_EndBug> <S2SV_StartBug> PyDict_SetItemString ( d , ""_attributes"" , empty_tuple ) < 0 ) { <S2SV_EndBug>"
2739,CWE-399,"static struct page * alloc_huge_page ( struct vm_area_struct * vma , unsigned long addr , int avoid_reserve ) { <S2SV_StartBug> struct hstate * h = hstate_vma ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> struct page * page ; <S2SV_EndBug> struct address_space * mapping = vma -> vm_file -> f_mapping ; struct inode * inode = mapping -> host ; long chg ; chg = vma_needs_reservation ( h , vma , addr ) ; if ( chg < 0 ) return ERR_PTR ( - VM_FAULT_OOM ) ; if ( chg ) <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> return ERR_PTR ( - VM_FAULT_SIGBUS ) ; spin_lock ( & hugetlb_lock ) ; page = dequeue_huge_page_vma ( h , vma , addr , avoid_reserve ) ; spin_unlock ( & hugetlb_lock ) ; if ( ! page ) { page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ; if ( ! page ) { <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> return ERR_PTR ( - VM_FAULT_SIGBUS ) ; } } <S2SV_StartBug> set_page_private ( page , ( unsigned long ) mapping ) ; <S2SV_EndBug> vma_commit_reservation ( h , vma , addr ) ; return page ; }
","<S2SV_ModStart> ) { struct hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart> page * page <S2SV_ModEnd> ; long chg <S2SV_ModStart> ) if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> page ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> unsigned long ) spool <S2SV_ModEnd> ) ; vma_commit_reservation
",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z,"<S2SV_StartBug> struct hstate * h = hstate_vma ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> struct page * page ; <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> <S2SV_StartBug> set_page_private ( page , ( unsigned long ) mapping ) ; <S2SV_EndBug>"
6884,CWE-310,"void bn_mul_comba4 ( BN_ULONG * r , BN_ULONG * a , BN_ULONG * b ) { <S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> BN_ULONG c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 0 ] , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 0 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 0 ] , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 2 ] , b [ 0 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 1 ] , b [ 1 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 0 ] , b [ 2 ] , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 3 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 1 ] , b [ 2 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 2 ] , b [ 1 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 3 ] , b [ 0 ] , c1 , c2 , c3 ) ; r [ 3 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 3 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 2 ] , b [ 2 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 3 ] , c2 , c3 , c1 ) ; r [ 4 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 2 ] , b [ 3 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 3 ] , b [ 2 ] , c3 , c1 , c2 ) ; r [ 5 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 3 ] , b [ 3 ] , c1 , c2 , c3 ) ; r [ 6 ] = c1 ; r [ 7 ] = c2 ; }
","<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
",openssl@openssl/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,CVE-2014-3570,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,2015-01-09T02:59Z,"<S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug>"
3974,CWE-200,"IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ALIGN16 ( u2_width ) ; } } else { if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; return SET_IVD_FATAL_ERROR ( e_error ) ; } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_StartBug> ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_EndBug> impeg2d_bit_stream_flush ( ps_stream , 18 ) ; GET_MARKER_BIT ( ps_dec , ps_stream ) ; impeg2d_bit_stream_flush ( ps_stream , 11 ) ; if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_intra_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_intra_quant_matrix , gau1_impeg2_intra_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_inter_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_inter_quant_matrix , gau1_impeg2_inter_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
","<S2SV_ModStart> 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; }
",external@libmpeg2/f301cff2c1ddd880d9a2c77b22602a137519867b,CVE-2017-0556,https://android.googlesource.com/platform/external/libmpeg2/+/f301cff2c1ddd880d9a2c77b22602a137519867b,2017-04-07T22:59Z,"<S2SV_StartBug> ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_EndBug>"
1251,CWE-119,"<S2SV_StartBug> static inline bool unconditional ( const struct ipt_ip * ip ) <S2SV_EndBug> { static const struct ipt_ip uncond ; <S2SV_StartBug> return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> # undef FWINV }
","<S2SV_ModStart> ( const struct ipt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> <S2SV_ModEnd> ip , &
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z,"<S2SV_StartBug> static inline bool unconditional ( const struct ipt_ip * ip ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug>"
7189,CWE-552,"int oe_iov_sync ( const struct oe_iovec * iov , int iovcnt , const void * buf_ , size_t buf_size ) { struct oe_iovec * buf = ( struct oe_iovec * ) buf_ ; int ret = - 1 ; int i ; size_t n ; if ( iovcnt < 0 || ( iovcnt > 0 && ! iov ) ) goto done ; for ( i = 0 , n = buf_size ; i < iovcnt ; i ++ ) { if ( buf [ i ] . iov_len != iov [ i ] . iov_len ) goto done ; if ( buf [ i ] . iov_len ) { if ( buf [ i ] . iov_base && ! iov [ i ] . iov_base ) goto done ; if ( ! buf [ i ] . iov_base && iov [ i ] . iov_base ) goto done ; if ( ! buf [ i ] . iov_base ) continue ; if ( n < buf [ i ] . iov_len ) goto done ; { uint8_t * src = ( uint8_t * ) buf [ i ] . iov_base + ( uint64_t ) buf ; size_t src_size = buf [ i ] . iov_len ; uint8_t * dest = ( uint8_t * ) iov [ i ] . iov_base ; size_t dest_size = iov [ i ] . iov_len ; if ( src_size != dest_size ) goto done ; <S2SV_StartBug> if ( src < ( uint8_t * ) buf || src > ( uint8_t * ) buf + buf_size ) <S2SV_EndBug> goto done ; if ( oe_memcpy_s ( dest , dest_size , src , src_size ) != OE_OK ) goto done ; } } n -= buf [ i ] . iov_len ; } ret = 0 ; done : return ret ; }
","<S2SV_ModStart> buf || src + src_size < src || src + src_size
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,<S2SV_StartBug> if ( src < ( uint8_t * ) buf || src > ( uint8_t * ) buf + buf_size ) <S2SV_EndBug>
3530,CWE-264,"static int load_state_from_tss32 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_32 * tss ) { int ret ; u8 cpl ; if ( ctxt -> ops -> set_cr ( ctxt , 3 , tss -> cr3 ) ) return emulate_gp ( ctxt , 0 ) ; ctxt -> _eip = tss -> eip ; ctxt -> eflags = tss -> eflags | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> eax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> ecx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> edx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> ebx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> esp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> ebp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> esi ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> edi ; set_segment_selector ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; set_segment_selector ( ctxt , tss -> fs , VCPU_SREG_FS ) ; set_segment_selector ( ctxt , tss -> gs , VCPU_SREG_GS ) ; if ( ctxt -> eflags & X86_EFLAGS_VM ) { ctxt -> mode = X86EMUL_MODE_VM86 ; cpl = 3 ; } else { ctxt -> mode = X86EMUL_MODE_PROT32 ; cpl = tss -> cs & 3 ; } <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; return X86EMUL_CONTINUE ; }
","<S2SV_ModStart> , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z,"<S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug>"
2026,CWE-119,"static void encode_frame ( struct stream_state * stream , struct VpxEncoderConfig * global , struct vpx_image * img , unsigned int frames_in ) { vpx_codec_pts_t frame_start , next_frame_start ; struct vpx_codec_enc_cfg * cfg = & stream -> config . cfg ; struct vpx_usec_timer timer ; frame_start = ( cfg -> g_timebase . den * ( int64_t ) ( frames_in - 1 ) * global -> framerate . den ) / cfg -> g_timebase . num / global -> framerate . num ; next_frame_start = ( cfg -> g_timebase . den * ( int64_t ) ( frames_in ) * global -> framerate . den ) / cfg -> g_timebase . num / global -> framerate . num ; <S2SV_StartBug> if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! stream -> img ) <S2SV_EndBug> <S2SV_StartBug> stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 , <S2SV_EndBug> cfg -> g_w , cfg -> g_h , 16 ) ; I420Scale ( img -> planes [ VPX_PLANE_Y ] , img -> stride [ VPX_PLANE_Y ] , img -> planes [ VPX_PLANE_U ] , img -> stride [ VPX_PLANE_U ] , img -> planes [ VPX_PLANE_V ] , img -> stride [ VPX_PLANE_V ] , img -> d_w , img -> d_h , stream -> img -> planes [ VPX_PLANE_Y ] , stream -> img -> stride [ VPX_PLANE_Y ] , stream -> img -> planes [ VPX_PLANE_U ] , stream -> img -> stride [ VPX_PLANE_U ] , stream -> img -> planes [ VPX_PLANE_V ] , stream -> img -> stride [ VPX_PLANE_V ] , stream -> img -> d_w , stream -> img -> d_h , kFilterBox ) ; <S2SV_StartBug> img = stream -> img ; <S2SV_EndBug> } vpx_usec_timer_start ( & timer ) ; vpx_codec_encode ( & stream -> encoder , img , frame_start , ( unsigned long ) ( next_frame_start - frame_start ) , 0 , global -> deadline ) ; vpx_usec_timer_mark ( & timer ) ; stream -> cx_time += vpx_usec_timer_elapsed ( & timer ) ; ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame"" , stream -> index ) ; }
","<S2SV_ModStart> . num ; # if CONFIG_VP9_HIGHBITDEPTH if ( img ) { if ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) <S2SV_ModEnd> && ( img <S2SV_ModStart> { if ( img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , ""%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>inputs\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( <S2SV_ModStart> -> img ) { <S2SV_ModStart> ( NULL , VPX_IMG_FMT_I42016 , cfg -> g_w , cfg -> g_h , 16 ) ; } I420Scale_16 ( ( uint16 * ) img -> planes [ VPX_PLANE_Y ] , img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_U ] , img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_V ] , img -> stride [ VPX_PLANE_V ] / 2 , img -> d_w , img -> d_h , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_Y ] , stream -> img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_U ] , stream -> img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_V ] , stream -> img -> stride [ VPX_PLANE_V ] / 2 , stream -> img -> d_w , stream -> img -> d_h , kFilterBox ) ; img = stream -> img ; # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n"" ""Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n"" ""To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n"" , stream -> index ) ; # endif } } # endif if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) { fprintf ( stderr , ""%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>8bpp<S2SV_blank>inputs\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( ! stream -> img ) stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 <S2SV_ModEnd> , cfg -> <S2SV_ModStart> -> img ; # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n"" ""Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n"" ""To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n"" , stream -> index ) ; # endif
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! stream -> img ) <S2SV_EndBug> <S2SV_StartBug> stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 , <S2SV_EndBug> <S2SV_StartBug> img = stream -> img ; <S2SV_EndBug>"
5582,CWE-399,"void cib_remote_connection_destroy ( gpointer user_data ) { <S2SV_StartBug> cib_client_t * client = user_data ; <S2SV_EndBug> if ( client == NULL ) { return ; } crm_trace ( ""Cleaning<S2SV_blank>up<S2SV_blank>after<S2SV_blank>client<S2SV_blank>disconnect:<S2SV_blank>%s/%s"" , crm_str ( client -> name ) , client -> id ) ; if ( client -> id != NULL ) { if ( ! g_hash_table_remove ( client_list , client -> id ) ) { crm_err ( ""Client<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>hashtable"" , client -> name ) ; } } crm_trace ( ""Destroying<S2SV_blank>%s<S2SV_blank>(%p)"" , client -> name , user_data ) ; num_clients -- ; crm_trace ( ""Num<S2SV_blank>unfree\'d<S2SV_blank>clients:<S2SV_blank>%d"" , num_clients ) ; <S2SV_StartBug> free ( client -> name ) ; <S2SV_EndBug> free ( client -> callback_id ) ; free ( client -> id ) ; free ( client -> user ) ; <S2SV_StartBug> free ( client ) ; <S2SV_EndBug> crm_trace ( ""Freed<S2SV_blank>the<S2SV_blank>cib<S2SV_blank>client"" ) ; if ( cib_shutdown_flag ) { cib_shutdown ( 0 ) ; } return ; }
","<S2SV_ModStart> client = user_data ; int csock = 0 <S2SV_ModStart> num_clients ) ; if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } if ( client -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> session ) { void * sock_ptr = gnutls_transport_get_ptr ( * client -> session ) ; csock = GPOINTER_TO_INT ( sock_ptr ) ; if ( client -> handshake_complete ) { gnutls_bye ( * client -> session , GNUTLS_SHUT_WR ) ; } gnutls_deinit ( * client -> session ) ; gnutls_free ( client -> session ) ; } # endif } else { csock = GPOINTER_TO_INT ( client -> session ) ; } client -> session = NULL ; if ( csock > 0 ) { close ( csock ) ; } <S2SV_ModStart> free ( client -> recv_buf ) ; free ( client
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z,<S2SV_StartBug> cib_client_t * client = user_data ; <S2SV_EndBug> <S2SV_StartBug> free ( client -> name ) ; <S2SV_EndBug> <S2SV_StartBug> free ( client ) ; <S2SV_EndBug>
6557,CWE-119,"<S2SV_StartBug> static char * print_string ( cJSON * item ) <S2SV_EndBug> { <S2SV_StartBug> return print_string_ptr ( item -> valuestring ) ; <S2SV_EndBug> }
","<S2SV_ModStart> cJSON * item , printbuffer * p <S2SV_ModStart> item -> valuestring , p
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,<S2SV_StartBug> static char * print_string ( cJSON * item ) <S2SV_EndBug> <S2SV_StartBug> return print_string_ptr ( item -> valuestring ) ; <S2SV_EndBug>
707,CWE-190,"static int burl_normalize_2F_to_slash_fix ( buffer * b , int qs , int i ) { char * const s = b -> ptr ; const int blen = ( int ) buffer_string_length ( b ) ; const int used = qs < 0 ? blen : qs ; int j = i ; for ( ; i < used ; ++ i , ++ j ) { s [ j ] = s [ i ] ; if ( s [ i ] == '%' && s [ i + 1 ] == '2' && s [ i + 2 ] == 'F' ) { s [ j ] = '/' ; i += 2 ; } } if ( qs >= 0 ) { <S2SV_StartBug> memmove ( s + j , s + qs , blen - qs ) ; <S2SV_EndBug> <S2SV_StartBug> j += blen - qs ; <S2SV_EndBug> } buffer_string_set_length ( b , j ) ; return qs ; }
","<S2SV_ModStart> 0 ) { const int qslen = blen - qs ; <S2SV_ModStart> + qs , ( size_t ) qslen ) ; qs = j <S2SV_ModEnd> ; j += <S2SV_ModStart> ; j += qslen <S2SV_ModEnd> ; } buffer_string_set_length
",lighttpd@lighttpd1.4/32120d5b8b3203fc21ccb9eafb0eaf824bb59354,CVE-2019-11072,https://github.com/lighttpd/lighttpd1.4/commit/32120d5b8b3203fc21ccb9eafb0eaf824bb59354,2019-04-10T22:29Z,"<S2SV_StartBug> memmove ( s + j , s + qs , blen - qs ) ; <S2SV_EndBug> <S2SV_StartBug> j += blen - qs ; <S2SV_EndBug>"
2392,CWE-119,"long fuse_do_ioctl ( struct file * file , unsigned int cmd , unsigned long arg , unsigned int flags ) { struct fuse_file * ff = file -> private_data ; struct fuse_conn * fc = ff -> fc ; struct fuse_ioctl_in inarg = { . fh = ff -> fh , . cmd = cmd , . arg = arg , . flags = flags } ; struct fuse_ioctl_out outarg ; struct fuse_req * req = NULL ; struct page * * pages = NULL ; struct page * iov_page = NULL ; struct iovec * in_iov = NULL , * out_iov = NULL ; unsigned int in_iovs = 0 , out_iovs = 0 , num_pages = 0 , max_pages ; size_t in_size , out_size , transferred ; int err ; BUILD_BUG_ON ( sizeof ( struct iovec ) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE ) ; err = - ENOMEM ; pages = kzalloc ( sizeof ( pages [ 0 ] ) * FUSE_MAX_PAGES_PER_REQ , GFP_KERNEL ) ; iov_page = alloc_page ( GFP_KERNEL ) ; if ( ! pages || ! iov_page ) goto out ; if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) ) { struct iovec * iov = page_address ( iov_page ) ; iov -> iov_base = ( void __user * ) arg ; iov -> iov_len = _IOC_SIZE ( cmd ) ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { in_iov = iov ; in_iovs = 1 ; } if ( _IOC_DIR ( cmd ) & _IOC_READ ) { out_iov = iov ; out_iovs = 1 ; } } retry : inarg . in_size = in_size = iov_length ( in_iov , in_iovs ) ; inarg . out_size = out_size = iov_length ( out_iov , out_iovs ) ; out_size = max_t ( size_t , out_size , PAGE_SIZE ) ; max_pages = DIV_ROUND_UP ( max ( in_size , out_size ) , PAGE_SIZE ) ; err = - ENOMEM ; if ( max_pages > FUSE_MAX_PAGES_PER_REQ ) goto out ; while ( num_pages < max_pages ) { pages [ num_pages ] = alloc_page ( GFP_KERNEL | __GFP_HIGHMEM ) ; if ( ! pages [ num_pages ] ) goto out ; num_pages ++ ; } req = fuse_get_req ( fc ) ; if ( IS_ERR ( req ) ) { err = PTR_ERR ( req ) ; req = NULL ; goto out ; } memcpy ( req -> pages , pages , sizeof ( req -> pages [ 0 ] ) * num_pages ) ; req -> num_pages = num_pages ; req -> in . h . opcode = FUSE_IOCTL ; req -> in . h . nodeid = ff -> nodeid ; req -> in . numargs = 1 ; req -> in . args [ 0 ] . size = sizeof ( inarg ) ; req -> in . args [ 0 ] . value = & inarg ; if ( in_size ) { req -> in . numargs ++ ; req -> in . args [ 1 ] . size = in_size ; req -> in . argpages = 1 ; err = fuse_ioctl_copy_user ( pages , in_iov , in_iovs , in_size , false ) ; if ( err ) goto out ; } req -> out . numargs = 2 ; req -> out . args [ 0 ] . size = sizeof ( outarg ) ; req -> out . args [ 0 ] . value = & outarg ; req -> out . args [ 1 ] . size = out_size ; req -> out . argpages = 1 ; req -> out . argvar = 1 ; fuse_request_send ( fc , req ) ; err = req -> out . h . error ; transferred = req -> out . args [ 1 ] . size ; fuse_put_request ( fc , req ) ; req = NULL ; if ( err ) goto out ; if ( outarg . flags & FUSE_IOCTL_RETRY ) { char * vaddr ; err = - EIO ; if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) ) goto out ; in_iovs = outarg . in_iovs ; out_iovs = outarg . out_iovs ; err = - ENOMEM ; if ( in_iovs > FUSE_IOCTL_MAX_IOV || out_iovs > FUSE_IOCTL_MAX_IOV || in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV ) goto out ; vaddr = kmap_atomic ( pages [ 0 ] , KM_USER0 ) ; err = fuse_copy_ioctl_iovec ( page_address ( iov_page ) , vaddr , transferred , in_iovs + out_iovs , ( flags & FUSE_IOCTL_COMPAT ) != 0 ) ; kunmap_atomic ( vaddr , KM_USER0 ) ; if ( err ) goto out ; in_iov = page_address ( iov_page ) ; out_iov = in_iov + in_iovs ; <S2SV_StartBug> goto retry ; <S2SV_EndBug> } err = - EIO ; if ( transferred > inarg . out_size ) goto out ; err = fuse_ioctl_copy_user ( pages , out_iov , out_iovs , transferred , true ) ; out : if ( req ) fuse_put_request ( fc , req ) ; if ( iov_page ) __free_page ( iov_page ) ; while ( num_pages ) __free_page ( pages [ -- num_pages ] ) ; kfree ( pages ) ; return err ? err : outarg . result ; }
","<S2SV_ModStart> + in_iovs ; err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ;
",torvalds@linux/7572777eef78ebdee1ecb7c258c0ef94d35bad16,CVE-2010-4650,https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16,2012-06-21T23:55Z,<S2SV_StartBug> goto retry ; <S2SV_EndBug>
30,CWE-200,"int btrfs_truncate_inode_items ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * inode , u64 new_size , u32 min_type ) { struct btrfs_path * path ; struct extent_buffer * leaf ; struct btrfs_file_extent_item * fi ; struct btrfs_key key ; struct btrfs_key found_key ; u64 extent_start = 0 ; u64 extent_num_bytes = 0 ; u64 extent_offset = 0 ; u64 item_end = 0 ; u64 last_size = new_size ; u32 found_type = ( u8 ) - 1 ; int found_extent ; int del_item ; int pending_del_nr = 0 ; int pending_del_slot = 0 ; int extent_type = - 1 ; int ret ; int err = 0 ; u64 ino = btrfs_ino ( inode ) ; u64 bytes_deleted = 0 ; bool be_nice = 0 ; bool should_throttle = 0 ; bool should_end = 0 ; BUG_ON ( new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY ) ; if ( ! btrfs_is_free_space_inode ( inode ) && test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) be_nice = 1 ; path = btrfs_alloc_path ( ) ; if ( ! path ) return - ENOMEM ; path -> reada = - 1 ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || root == root -> fs_info -> tree_root ) btrfs_drop_extent_cache ( inode , ALIGN ( new_size , root -> sectorsize ) , ( u64 ) - 1 , 0 ) ; if ( min_type == 0 && root == BTRFS_I ( inode ) -> root ) btrfs_kill_delayed_inode_items ( inode ) ; key . objectid = ino ; key . offset = ( u64 ) - 1 ; key . type = ( u8 ) - 1 ; search_again : if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { if ( btrfs_should_end_transaction ( trans , root ) ) { err = - EAGAIN ; goto error ; } } path -> leave_spinning = 1 ; ret = btrfs_search_slot ( trans , root , & key , path , - 1 , 1 ) ; if ( ret < 0 ) { err = ret ; goto out ; } if ( ret > 0 ) { if ( path -> slots [ 0 ] == 0 ) goto out ; path -> slots [ 0 ] -- ; } while ( 1 ) { fi = NULL ; leaf = path -> nodes [ 0 ] ; btrfs_item_key_to_cpu ( leaf , & found_key , path -> slots [ 0 ] ) ; found_type = found_key . type ; if ( found_key . objectid != ino ) break ; if ( found_type < min_type ) break ; item_end = found_key . offset ; if ( found_type == BTRFS_EXTENT_DATA_KEY ) { fi = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , struct btrfs_file_extent_item ) ; extent_type = btrfs_file_extent_type ( leaf , fi ) ; if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { item_end += btrfs_file_extent_num_bytes ( leaf , fi ) ; } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { item_end += btrfs_file_extent_inline_len ( leaf , path -> slots [ 0 ] , fi ) ; } item_end -- ; } if ( found_type > min_type ) { del_item = 1 ; } else { if ( item_end < new_size ) break ; if ( found_key . offset >= new_size ) del_item = 1 ; else del_item = 0 ; } found_extent = 0 ; if ( found_type != BTRFS_EXTENT_DATA_KEY ) goto delete ; if ( del_item ) last_size = found_key . offset ; else last_size = new_size ; if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { u64 num_dec ; extent_start = btrfs_file_extent_disk_bytenr ( leaf , fi ) ; if ( ! del_item ) { u64 orig_num_bytes = btrfs_file_extent_num_bytes ( leaf , fi ) ; extent_num_bytes = ALIGN ( new_size - found_key . offset , root -> sectorsize ) ; btrfs_set_file_extent_num_bytes ( leaf , fi , extent_num_bytes ) ; num_dec = ( orig_num_bytes - extent_num_bytes ) ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { extent_num_bytes = btrfs_file_extent_disk_num_bytes ( leaf , fi ) ; extent_offset = found_key . offset - btrfs_file_extent_offset ( leaf , fi ) ; num_dec = btrfs_file_extent_num_bytes ( leaf , fi ) ; if ( extent_start != 0 ) { found_extent = 1 ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , num_dec ) ; } } } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { if ( ! del_item && <S2SV_StartBug> btrfs_file_extent_compression ( leaf , fi ) == 0 && <S2SV_EndBug> btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { u32 size = new_size - found_key . offset ; <S2SV_StartBug> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) <S2SV_EndBug> inode_sub_bytes ( inode , item_end + 1 - <S2SV_StartBug> new_size ) ; <S2SV_EndBug> btrfs_set_file_extent_ram_bytes ( leaf , fi , size ) ; size = btrfs_file_extent_calc_inline_size ( size ) ; btrfs_truncate_item ( root , path , size , 1 ) ; } else if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) { inode_sub_bytes ( inode , item_end + 1 - found_key . offset ) ; } } delete : if ( del_item ) { if ( ! pending_del_nr ) { pending_del_slot = path -> slots [ 0 ] ; pending_del_nr = 1 ; } else if ( pending_del_nr && path -> slots [ 0 ] + 1 == pending_del_slot ) { pending_del_nr ++ ; pending_del_slot = path -> slots [ 0 ] ; } else { BUG ( ) ; } } else { break ; } should_throttle = 0 ; if ( found_extent && ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || root == root -> fs_info -> tree_root ) ) { btrfs_set_path_blocking ( path ) ; bytes_deleted += extent_num_bytes ; ret = btrfs_free_extent ( trans , root , extent_start , extent_num_bytes , 0 , btrfs_header_owner ( leaf ) , ino , extent_offset , 0 ) ; BUG_ON ( ret ) ; if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) btrfs_async_run_delayed_refs ( root , trans -> delayed_ref_updates * 2 , 0 ) ; if ( be_nice ) { if ( truncate_space_check ( trans , root , extent_num_bytes ) ) { should_end = 1 ; } if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) { should_throttle = 1 ; } } } if ( found_type == BTRFS_INODE_ITEM_KEY ) break ; if ( path -> slots [ 0 ] == 0 || path -> slots [ 0 ] != pending_del_slot || should_throttle || should_end ) { if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto error ; } pending_del_nr = 0 ; } btrfs_release_path ( path ) ; if ( should_throttle ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } if ( should_end ) { err = - EAGAIN ; goto error ; } goto search_again ; } else { path -> slots [ 0 ] -- ; } } out : if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; } error : if ( root -> root_key . objectid != BTRFS_TREE_LOG_OBJECTID ) btrfs_ordered_update_i_size ( inode , last_size , NULL ) ; btrfs_free_path ( path ) ; if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } return err ; }
","<S2SV_ModStart> ! del_item && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { if ( <S2SV_ModStart> , fi ) != BTRFS_COMPRESS_NONE && pending_del_nr ) { err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } pending_del_nr = 0 ; } err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } } else <S2SV_ModEnd> if ( test_bit <S2SV_ModStart> state ) ) { <S2SV_ModStart> 1 - new_size <S2SV_ModEnd> ) ; }
",torvalds@linux/0305cd5f7fca85dae392b9ba85b116896eb7c1c7,CVE-2015-8374,https://github.com/torvalds/linux/commit/0305cd5f7fca85dae392b9ba85b116896eb7c1c7,2015-12-28T11:59Z,"<S2SV_StartBug> btrfs_file_extent_compression ( leaf , fi ) == 0 && <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) <S2SV_EndBug> <S2SV_StartBug> new_size ) ; <S2SV_EndBug>"
1022,CWE-284,"static BOOLEAN flush_incoming_que_on_wr_signal_l ( l2cap_socket * sock ) { uint8_t * buf ; uint32_t len ; while ( packet_get_head_l ( sock , & buf , & len ) ) { <S2SV_StartBug> int sent = send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ; <S2SV_EndBug> if ( sent == ( signed ) len ) osi_free ( buf ) ; else if ( sent >= 0 ) { packet_put_head_l ( sock , buf + sent , len - sent ) ; osi_free ( buf ) ; if ( ! sent ) return TRUE ; } else { packet_put_head_l ( sock , buf , len ) ; osi_free ( buf ) ; return errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN ; } } return FALSE ; }
","<S2SV_ModStart> int sent = TEMP_FAILURE_RETRY ( <S2SV_ModStart> len , MSG_DONTWAIT )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> int sent = send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ; <S2SV_EndBug>"
3971,CWE-59,"<S2SV_StartBug> static int fsmVerify ( const char * path , rpmfi fi ) <S2SV_EndBug> { int rc ; int saveerrno = errno ; struct stat dsb ; mode_t mode = rpmfiFMode ( fi ) ; rc = fsmStat ( path , 1 , & dsb ) ; if ( rc ) return rc ; if ( S_ISREG ( mode ) ) { char * rmpath = rstrscat ( NULL , path , ""-RPMDELETE"" , NULL ) ; rc = fsmRename ( path , rmpath ) ; if ( ! rc ) ( void ) fsmUnlink ( rmpath ) ; else rc = RPMERR_UNLINK_FAILED ; free ( rmpath ) ; return ( rc ? rc : RPMERR_ENOENT ) ; } else if ( S_ISDIR ( mode ) ) { if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; if ( S_ISLNK ( dsb . st_mode ) ) { <S2SV_StartBug> rc = fsmStat ( path , 0 , & dsb ) ; <S2SV_EndBug> if ( rc == RPMERR_ENOENT ) rc = 0 ; if ( rc ) return rc ; errno = saveerrno ; <S2SV_StartBug> if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; <S2SV_EndBug> } } else if ( S_ISLNK ( mode ) ) { if ( S_ISLNK ( dsb . st_mode ) ) { char buf [ 8 * BUFSIZ ] ; size_t len ; rc = fsmReadLink ( path , buf , 8 * BUFSIZ , & len ) ; errno = saveerrno ; if ( rc ) return rc ; if ( rstreq ( rpmfiFLink ( fi ) , buf ) ) return 0 ; } } else if ( S_ISFIFO ( mode ) ) { if ( S_ISFIFO ( dsb . st_mode ) ) return 0 ; } else if ( S_ISCHR ( mode ) || S_ISBLK ( mode ) ) { if ( ( S_ISCHR ( dsb . st_mode ) || S_ISBLK ( dsb . st_mode ) ) && ( dsb . st_rdev == rpmfiFRdev ( fi ) ) ) return 0 ; } else if ( S_ISSOCK ( mode ) ) { if ( S_ISSOCK ( dsb . st_mode ) ) return 0 ; } rc = fsmUnlink ( path ) ; if ( rc == 0 ) rc = RPMERR_ENOENT ; return ( rc ? rc : RPMERR_ENOENT ) ; }
","<S2SV_ModStart> , rpmfi fi , const struct stat * fsb <S2SV_ModStart> ) ) { uid_t luid = dsb . st_uid ; <S2SV_ModStart> . st_mode ) && ( luid == 0 || luid == fsb -> st_uid ) ) <S2SV_ModEnd> return 0 ;
",rpm-software-management@rpm/f2d3be2a8741234faaa96f5fd05fdfdc75779a79,CVE-2017-7500,https://github.com/rpm-software-management/rpm/commit/f2d3be2a8741234faaa96f5fd05fdfdc75779a79,2018-08-13T17:29Z,"<S2SV_StartBug> static int fsmVerify ( const char * path , rpmfi fi ) <S2SV_EndBug> <S2SV_StartBug> rc = fsmStat ( path , 0 , & dsb ) ; <S2SV_EndBug> <S2SV_StartBug> if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; <S2SV_EndBug>"
2508,CWE-834,"static int cine_read_header ( AVFormatContext * avctx ) { AVIOContext * pb = avctx -> pb ; AVStream * st ; unsigned int version , compression , offImageHeader , offSetup , offImageOffsets , biBitCount , length , CFA ; int vflip ; char * description ; uint64_t i ; st = avformat_new_stream ( avctx , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; st -> codecpar -> codec_tag = 0 ; avio_skip ( pb , 4 ) ; compression = avio_rl16 ( pb ) ; version = avio_rl16 ( pb ) ; if ( version != 1 ) { avpriv_request_sample ( avctx , ""unknown<S2SV_blank>version<S2SV_blank>%i"" , version ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 12 ) ; st -> duration = avio_rl32 ( pb ) ; offImageHeader = avio_rl32 ( pb ) ; offSetup = avio_rl32 ( pb ) ; offImageOffsets = avio_rl32 ( pb ) ; avio_skip ( pb , 8 ) ; avio_seek ( pb , offImageHeader , SEEK_SET ) ; avio_skip ( pb , 4 ) ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; if ( avio_rl16 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; biBitCount = avio_rl16 ( pb ) ; if ( biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48 ) { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } switch ( avio_rl32 ( pb ) ) { case BMP_RGB : vflip = 0 ; break ; case 0x100 : st -> codecpar -> codec_tag = MKTAG ( 'B' , 'I' , 'T' , 0 ) ; vflip = 1 ; break ; default : avpriv_request_sample ( avctx , ""unknown<S2SV_blank>bitmap<S2SV_blank>compression"" ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 4 ) ; avio_seek ( pb , offSetup , SEEK_SET ) ; avio_skip ( pb , 140 ) ; if ( avio_rl16 ( pb ) != 0x5453 ) return AVERROR_INVALIDDATA ; length = avio_rl16 ( pb ) ; if ( length < 0x163C ) { avpriv_request_sample ( avctx , ""short<S2SV_blank>SETUP<S2SV_blank>header"" ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 616 ) ; if ( ! avio_rl32 ( pb ) ^ vflip ) { st -> codecpar -> extradata = av_strdup ( ""BottomUp"" ) ; st -> codecpar -> extradata_size = 9 ; } avio_skip ( pb , 4 ) ; avpriv_set_pts_info ( st , 64 , 1 , avio_rl32 ( pb ) ) ; avio_skip ( pb , 20 ) ; set_metadata_int ( & st -> metadata , ""camera_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""firmware_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""software_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""recording_timezone"" , avio_rl32 ( pb ) , 0 ) ; CFA = avio_rl32 ( pb ) ; set_metadata_int ( & st -> metadata , ""brightness"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""contrast"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""gamma"" , avio_rl32 ( pb ) , 1 ) ; avio_skip ( pb , 12 + 16 ) ; set_metadata_float ( & st -> metadata , ""wbgain[0].r"" , av_int2float ( avio_rl32 ( pb ) ) , 1 ) ; set_metadata_float ( & st -> metadata , ""wbgain[0].b"" , av_int2float ( avio_rl32 ( pb ) ) , 1 ) ; avio_skip ( pb , 36 ) ; st -> codecpar -> bits_per_coded_sample = avio_rl32 ( pb ) ; if ( compression == CC_RGB ) { if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_GRAY8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_GRAY16LE ; } else if ( biBitCount == 24 ) { st -> codecpar -> format = AV_PIX_FMT_BGR24 ; } else if ( biBitCount == 48 ) { st -> codecpar -> format = AV_PIX_FMT_BGR48LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } } else if ( compression == CC_UNINT ) { switch ( CFA & 0xFFFFFF ) { case CFA_BAYER : if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_GBRG8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_GBRG16LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } break ; case CFA_BAYERFLIP : if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_RGGB8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_RGGB16LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } break ; default : avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>Color<S2SV_blank>Field<S2SV_blank>Array<S2SV_blank>(CFA)<S2SV_blank>%i"" , CFA & 0xFFFFFF ) ; return AVERROR_INVALIDDATA ; } } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>compression<S2SV_blank>%i"" , compression ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 668 ) ; set_metadata_int ( & st -> metadata , ""shutter_ns"" , avio_rl32 ( pb ) , 0 ) ; avio_skip ( pb , 24 ) ; # define DESCRIPTION_SIZE 4096 description = av_malloc ( DESCRIPTION_SIZE + 1 ) ; if ( ! description ) return AVERROR ( ENOMEM ) ; i = avio_get_str ( pb , DESCRIPTION_SIZE , description , DESCRIPTION_SIZE + 1 ) ; if ( i < DESCRIPTION_SIZE ) avio_skip ( pb , DESCRIPTION_SIZE - i ) ; if ( description [ 0 ] ) av_dict_set ( & st -> metadata , ""description"" , description , AV_DICT_DONT_STRDUP_VAL ) ; else av_free ( description ) ; avio_skip ( pb , 1176 ) ; set_metadata_int ( & st -> metadata , ""enable_crop"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_left"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_top"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_right"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_bottom"" , avio_rl32 ( pb ) , 1 ) ; avio_seek ( pb , offImageOffsets , SEEK_SET ) ; <S2SV_StartBug> for ( i = 0 ; i < st -> duration ; i ++ ) <S2SV_EndBug> av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> AVINDEX_KEYFRAME ) ; }
",FFmpeg@FFmpeg/7e80b63ecd259d69d383623e75b318bf2bd491f6,CVE-2017-14059,https://github.com/FFmpeg/FFmpeg/commit/7e80b63ecd259d69d383623e75b318bf2bd491f6,2017-08-31T15:29Z,<S2SV_StartBug> for ( i = 0 ; i < st -> duration ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>
557,CWE-000,"int ocfs2_setattr ( struct dentry * dentry , struct iattr * attr ) { int status = 0 , size_change ; int inode_locked = 0 ; struct inode * inode = d_inode ( dentry ) ; struct super_block * sb = inode -> i_sb ; struct ocfs2_super * osb = OCFS2_SB ( sb ) ; struct buffer_head * bh = NULL ; handle_t * handle = NULL ; struct dquot * transfer_to [ MAXQUOTAS ] = { } ; int qtype ; int had_lock ; struct ocfs2_lock_holder oh ; trace_ocfs2_setattr ( inode , dentry , ( unsigned long long ) OCFS2_I ( inode ) -> ip_blkno , dentry -> d_name . len , dentry -> d_name . name , attr -> ia_valid , attr -> ia_mode , from_kuid ( & init_user_ns , attr -> ia_uid ) , from_kgid ( & init_user_ns , attr -> ia_gid ) ) ; if ( S_ISLNK ( inode -> i_mode ) ) attr -> ia_valid &= ~ ATTR_SIZE ; # define OCFS2_VALID_ATTRS ( ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE | ATTR_GID | ATTR_UID | ATTR_MODE ) if ( ! ( attr -> ia_valid & OCFS2_VALID_ATTRS ) ) return 0 ; status = setattr_prepare ( dentry , attr ) ; if ( status ) return status ; if ( is_quota_modification ( inode , attr ) ) { status = dquot_initialize ( inode ) ; if ( status ) return status ; } size_change = S_ISREG ( inode -> i_mode ) && attr -> ia_valid & ATTR_SIZE ; if ( size_change ) { <S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> if ( status < 0 ) { mlog_errno ( status ) ; goto bail ; } } had_lock = ocfs2_inode_lock_tracker ( inode , & bh , 1 , & oh ) ; if ( had_lock < 0 ) { status = had_lock ; goto bail_unlock_rw ; } else if ( had_lock ) { mlog ( ML_ERROR , ""Another<S2SV_blank>case<S2SV_blank>of<S2SV_blank>recursive<S2SV_blank>locking:\\n"" ) ; dump_stack ( ) ; } inode_locked = 1 ; if ( size_change ) { status = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( status ) <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug> inode_dio_wait ( inode ) ; if ( i_size_read ( inode ) >= attr -> ia_size ) { if ( ocfs2_should_order_data ( inode ) ) { status = ocfs2_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( status ) goto bail_unlock ; } status = ocfs2_truncate_file ( inode , bh , attr -> ia_size ) ; } else status = ocfs2_extend_file ( inode , bh , attr -> ia_size ) ; if ( status < 0 ) { if ( status != - ENOSPC ) mlog_errno ( status ) ; status = - ENOSPC ; goto bail_unlock ; } } if ( ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { if ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_USRQUOTA ) ) { transfer_to [ USRQUOTA ] = dqget ( sb , make_kqid_uid ( attr -> ia_uid ) ) ; if ( IS_ERR ( transfer_to [ USRQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ USRQUOTA ] ) ; goto bail_unlock ; } } if ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_GRPQUOTA ) ) { transfer_to [ GRPQUOTA ] = dqget ( sb , make_kqid_gid ( attr -> ia_gid ) ) ; if ( IS_ERR ( transfer_to [ GRPQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ GRPQUOTA ] ) ; goto bail_unlock ; } } handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS + 2 * ocfs2_quota_trans_credits ( sb ) ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } status = __dquot_transfer ( inode , transfer_to ) ; if ( status < 0 ) goto bail_commit ; } else { handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } } setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; status = ocfs2_mark_inode_dirty ( handle , inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; bail_commit : ocfs2_commit_trans ( osb , handle ) ; bail_unlock : if ( status && inode_locked ) { ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; inode_locked = 0 ; } bail_unlock_rw : if ( size_change ) ocfs2_rw_unlock ( inode , 1 ) ; bail : for ( qtype = 0 ; qtype < OCFS2_MAXQUOTAS ; qtype ++ ) dqput ( transfer_to [ qtype ] ) ; if ( ! status && attr -> ia_valid & ATTR_MODE ) { status = ocfs2_acl_chmod ( inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; } if ( inode_locked ) ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; brelse ( bh ) ; return status ; }
","<S2SV_ModStart> size_change ) { inode_dio_wait ( inode ) ; <S2SV_ModStart> ) goto bail_unlock <S2SV_ModEnd> ; if (
",torvalds@linux/28f5a8a7c033cbf3e32277f4cc9c6afd74f05300,CVE-2017-18204,https://github.com/torvalds/linux/commit/28f5a8a7c033cbf3e32277f4cc9c6afd74f05300,2018-02-27T20:29Z,"<S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug>"
3483,CWE-264,"static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! arp_checkentry ( & e -> arp ) ) return - EINVAL ; <S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> , e -> elems , e ->
",torvalds@linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,CVE-2016-4997,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,2016-07-03T21:59Z,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug>"
5424,CWE-119,"hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( ""HIVEX_DEBUG"" ) ; if ( debug && STREQ ( debug , ""1"" ) ) h -> msglvl = 2 ; DEBUG ( 2 , ""created<S2SV_blank>handle<S2SV_blank>%p"" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; h -> size = statbuf . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } if ( ! h -> writable ) { h -> addr = mmap ( NULL , h -> size , PROT_READ , MAP_SHARED , h -> fd , 0 ) ; if ( h -> addr == MAP_FAILED ) goto error ; DEBUG ( 2 , ""mapped<S2SV_blank>file<S2SV_blank>at<S2SV_blank>%p"" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == NULL ) goto error ; if ( full_read ( h -> fd , h -> addr , h -> size ) < h -> size ) goto error ; if ( close ( h -> fd ) == - 1 ) goto error ; h -> fd = - 1 ; } if ( h -> hdr -> magic [ 0 ] != 'r' || h -> hdr -> magic [ 1 ] != 'e' || h -> hdr -> magic [ 2 ] != 'g' || h -> hdr -> magic [ 3 ] != 'f' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } uint32_t major_ver = le32toh ( h -> hdr -> major_ver ) ; if ( major_ver != 1 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>hive<S2SV_blank>file<S2SV_blank>major<S2SV_blank>version<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(expected<S2SV_blank>1)"" , filename , major_ver ) ; goto error ; } h -> bitmap = calloc ( 1 + h -> size / 32 , 1 ) ; if ( h -> bitmap == NULL ) goto error ; uint32_t sum = header_checksum ( h ) ; if ( sum != le32toh ( h -> hdr -> csum ) ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>hive<S2SV_blank>header"" , filename ) ; goto error ; } h -> last_modified = le64toh ( ( int64_t ) h -> hdr -> last_modified ) ; if ( h -> msglvl >= 2 ) { char * name = _hivex_windows_utf16_to_utf8 ( h -> hdr -> name , 64 ) ; fprintf ( stderr , ""hivex_open:<S2SV_blank>header<S2SV_blank>fields:\\n"" ""<S2SV_blank><S2SV_blank>file<S2SV_blank>version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 "".%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank>sequence<S2SV_blank>nos<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 ""<S2SV_blank>%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(sequences<S2SV_blank>nos<S2SV_blank>should<S2SV_blank>match<S2SV_blank>if<S2SV_blank>hive<S2SV_blank>was<S2SV_blank>synched<S2SV_blank>at<S2SV_blank>shutdown)\\n"" ""<S2SV_blank><S2SV_blank>last<S2SV_blank>modified<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu64 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Windows<S2SV_blank>filetime,<S2SV_blank>x<S2SV_blank>100<S2SV_blank>ns<S2SV_blank>since<S2SV_blank>1601-01-01)\\n"" ""<S2SV_blank><S2SV_blank>original<S2SV_blank>file<S2SV_blank>name<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(only<S2SV_blank>32<S2SV_blank>chars<S2SV_blank>are<S2SV_blank>stored,<S2SV_blank>name<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>truncated)\\n"" ""<S2SV_blank><S2SV_blank>root<S2SV_blank>offset<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000\\n"" ""<S2SV_blank><S2SV_blank>end<S2SV_blank>of<S2SV_blank>last<S2SV_blank>page<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000<S2SV_blank>(total<S2SV_blank>file<S2SV_blank>size<S2SV_blank>0x%zx)\\n"" ""<S2SV_blank><S2SV_blank>checksum<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>(calculated<S2SV_blank>0x%x)\\n"" , major_ver , le32toh ( h -> hdr -> minor_ver ) , le32toh ( h -> hdr -> sequence1 ) , le32toh ( h -> hdr -> sequence2 ) , h -> last_modified , name ? name : ""(conversion<S2SV_blank>failed)"" , le32toh ( h -> hdr -> offset ) , le32toh ( h -> hdr -> blocks ) , h -> size , le32toh ( h -> hdr -> csum ) , sum ) ; free ( name ) ; } h -> rootoffs = le32toh ( h -> hdr -> offset ) + 0x1000 ; h -> endpages = le32toh ( h -> hdr -> blocks ) + 0x1000 ; DEBUG ( 2 , ""root<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>0x%zx"" , h -> rootoffs ) ; int seen_root_block = 0 , bad_root_block = 0 ; size_t pages = 0 ; size_t smallest_page = SIZE_MAX , largest_page = 0 ; size_t blocks = 0 ; size_t smallest_block = SIZE_MAX , largest_block = 0 , blocks_bytes = 0 ; size_t used_blocks = 0 ; size_t used_size = 0 ; size_t off ; struct ntreg_hbin_page * page ; for ( off = 0x1000 ; off < h -> size ; off += le32toh ( page -> page_size ) ) { if ( off >= h -> endpages ) break ; page = ( struct ntreg_hbin_page * ) ( ( char * ) h -> addr + off ) ; if ( page -> magic [ 0 ] != 'h' || page -> magic [ 1 ] != 'b' || page -> magic [ 2 ] != 'i' || page -> magic [ 3 ] != 'n' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>"" ""(at<S2SV_blank>0x%zx,<S2SV_blank>after<S2SV_blank>%zu<S2SV_blank>pages)"" , filename , off , pages ) ; goto error ; } size_t page_size = le32toh ( page -> page_size ) ; DEBUG ( 2 , ""page<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>size<S2SV_blank>%zu"" , off , page_size ) ; pages ++ ; if ( page_size < smallest_page ) smallest_page = page_size ; if ( page_size > largest_page ) largest_page = page_size ; if ( page_size <= sizeof ( struct ntreg_hbin_page ) || ( page_size & 0x0fff ) != 0 ) { SET_ERRNO ( ENOTSUP , <S2SV_StartBug> ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , <S2SV_EndBug> filename , page_size , off ) ; goto error ; } size_t blkoff ; struct ntreg_hbin_block * block ; size_t seg_len ; for ( blkoff = off + 0x20 ; blkoff < off + page_size ; blkoff += seg_len ) { blocks ++ ; int is_root = blkoff == h -> rootoffs ; if ( is_root ) seen_root_block = 1 ; block = ( struct ntreg_hbin_block * ) ( ( char * ) h -> addr + blkoff ) ; int used ; seg_len = block_len ( h , blkoff , & used ) ; if ( seg_len <= 4 || ( seg_len & 3 ) != 0 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%"" PRIu32 ""<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , le32toh ( block -> seg_len ) , blkoff ) ; goto error ; } if ( h -> msglvl >= 2 ) { unsigned char * id = ( unsigned char * ) block -> id ; int id0 = id [ 0 ] , id1 = id [ 1 ] ; fprintf ( stderr , ""%s:<S2SV_blank>%s:<S2SV_blank>"" ""%s<S2SV_blank>block<S2SV_blank>id<S2SV_blank>%d,%d<S2SV_blank>(%c%c)<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>size<S2SV_blank>%zu%s\\n"" , ""hivex"" , __func__ , used ? ""used"" : ""free"" , id0 , id1 , c_isprint ( id0 ) ? id0 : '.' , c_isprint ( id1 ) ? id1 : '.' , blkoff , seg_len , is_root ? ""<S2SV_blank>(root)"" : """" ) ; } blocks_bytes += seg_len ; if ( seg_len < smallest_block ) smallest_block = seg_len ; if ( seg_len > largest_block ) largest_block = seg_len ; if ( is_root && ! used ) bad_root_block = 1 ; if ( used ) { used_blocks ++ ; used_size += seg_len ; if ( is_root && ( block -> id [ 0 ] != 'n' || block -> id [ 1 ] != 'k' ) ) bad_root_block = 1 ; BITMAP_SET ( h -> bitmap , blkoff ) ; } } } if ( ! seen_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>no<S2SV_blank>root<S2SV_blank>block<S2SV_blank>found"" , filename ) ; goto error ; } if ( bad_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>bad<S2SV_blank>root<S2SV_blank>block<S2SV_blank>(free<S2SV_blank>or<S2SV_blank>not<S2SV_blank>nk)"" , filename ) ; goto error ; } DEBUG ( 1 , ""successfully<S2SV_blank>read<S2SV_blank>Windows<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file:\\n"" ""<S2SV_blank><S2SV_blank>pages:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>avg:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu\\n"" ""<S2SV_blank><S2SV_blank>bytes<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu"" , pages , smallest_page , largest_page , blocks , smallest_block , blocks_bytes / blocks , largest_block , used_blocks , used_size ) ; return h ; error : ; int err = errno ; if ( h ) { free ( h -> bitmap ) ; if ( h -> addr && h -> size && h -> addr != MAP_FAILED ) { if ( ! h -> writable ) munmap ( h -> addr , h -> size ) ; else free ( h -> addr ) ; } if ( h -> fd >= 0 ) close ( h -> fd ) ; free ( h -> filename ) ; free ( h ) ; } errno = err ; return NULL ; }
","<S2SV_ModStart> ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , page_size , off ) ; goto error ; } if ( off + page_size > h -> size ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>extends<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file,<S2SV_blank>bad<S2SV_blank>registry""
",libguestfs@hivex/4bbdf555f88baeae0fa804a369a81a83908bd705,CVE-2014-9273,https://github.com/libguestfs/hivex/commit/4bbdf555f88baeae0fa804a369a81a83908bd705,2014-12-08T16:59Z,"<S2SV_StartBug> ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , <S2SV_EndBug>"
1,CWE-362,"static bool blk_kick_flush ( struct request_queue * q , struct blk_flush_queue * fq ) { struct list_head * pending = & fq -> flush_queue [ fq -> flush_pending_idx ] ; struct request * first_rq = list_first_entry ( pending , struct request , flush . list ) ; struct request * flush_rq = fq -> flush_rq ; if ( fq -> flush_pending_idx != fq -> flush_running_idx || list_empty ( pending ) ) return false ; if ( ! list_empty ( & fq -> flush_data_in_flight ) && time_before ( jiffies , fq -> flush_pending_since + FLUSH_PENDING_TIMEOUT ) ) return false ; fq -> flush_pending_idx ^= 1 ; blk_rq_init ( q , flush_rq ) ; if ( q -> mq_ops ) { <S2SV_StartBug> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <S2SV_EndBug> <S2SV_StartBug> flush_rq -> tag = first_rq -> tag ; <S2SV_EndBug> } flush_rq -> cmd_type = REQ_TYPE_FS ; flush_rq -> cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ ; flush_rq -> rq_disk = first_rq -> rq_disk ; flush_rq -> end_io = flush_end_io ; return blk_flush_queue_rq ( flush_rq , false ) ; }
","<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> first_rq -> tag ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq )
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z,<S2SV_StartBug> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <S2SV_EndBug> <S2SV_StartBug> flush_rq -> tag = first_rq -> tag ; <S2SV_EndBug>
2500,CWE-20,"static fp_info * fp_set_per_packet_inf_from_conv ( umts_fp_conversation_info_t * p_conv_data , tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree _U_ ) { fp_info * fpi ; guint8 tfi , c_t ; int offset = 0 , i = 0 , j = 0 , num_tbs , chan , tb_size , tb_bit_off ; gboolean is_control_frame ; umts_mac_info * macinf ; rlc_info * rlcinf ; guint8 fake_lchid = 0 ; gint * cur_val = NULL ; fpi = wmem_new0 ( wmem_file_scope ( ) , fp_info ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 , fpi ) ; fpi -> iface_type = p_conv_data -> iface_type ; fpi -> division = p_conv_data -> division ; fpi -> release = 7 ; fpi -> release_year = 2006 ; fpi -> release_month = 12 ; fpi -> channel = p_conv_data -> channel ; fpi -> dch_crc_present = p_conv_data -> dch_crc_present ; fpi -> link_type = FP_Link_Ethernet ; # if 0 if ( ! pinfo -> fd -> flags . visited && p_conv_data -> reset_frag ) { fpi -> reset_frag = p_conv_data -> reset_frag ; p_conv_data -> reset_frag = FALSE ; } # endif fpi -> srcport = pinfo -> srcport ; fpi -> destport = pinfo -> destport ; fpi -> com_context_id = p_conv_data -> com_context_id ; if ( pinfo -> link_dir == P2P_DIR_UL ) { fpi -> is_uplink = TRUE ; } else { fpi -> is_uplink = FALSE ; } is_control_frame = tvb_get_guint8 ( tvb , offset ) & 0x01 ; switch ( fpi -> channel ) { case CHANNEL_HSDSCH : fpi -> hsdsch_entity = p_conv_data -> hsdsch_entity ; macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; fpi -> hsdsch_macflowd_id = p_conv_data -> hsdsch_macdflow_id ; macinf -> content [ 0 ] = hsdsch_macdflow_id_mac_content_map [ p_conv_data -> hsdsch_macdflow_id ] ; macinf -> lchid [ 0 ] = p_conv_data -> hsdsch_macdflow_id ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; rlcinf -> mode [ 0 ] = hsdsch_macdflow_id_rlc_map [ p_conv_data -> hsdsch_macdflow_id ] ; if ( fpi -> hsdsch_entity == hs ) { for ( i = 0 ; i < MAX_NUM_HSDHSCH_MACDFLOW ; i ++ ) { if ( ( cur_val = ( gint * ) g_tree_lookup ( hsdsch_muxed_flows , GINT_TO_POINTER ( ( gint ) p_conv_data -> hrnti ) ) ) != NULL ) { j = 1 << i ; fpi -> hsdhsch_macfdlow_is_mux [ i ] = j & * cur_val ; } else { fpi -> hsdhsch_macfdlow_is_mux [ i ] = FALSE ; } } } rlcinf -> urnti [ 0 ] = fpi -> com_context_id ; rlcinf -> li_size [ 0 ] = RLC_LI_7BITS ; rlcinf -> ciphered [ 0 ] = FALSE ; rlcinf -> deciphered [ 0 ] = FALSE ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; return fpi ; case CHANNEL_EDCH : macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; fpi -> no_ddi_entries = p_conv_data -> no_ddi_entries ; for ( i = 0 ; i < fpi -> no_ddi_entries ; i ++ ) { fpi -> edch_ddi [ i ] = p_conv_data -> edch_ddi [ i ] ; fpi -> edch_macd_pdu_size [ i ] = p_conv_data -> edch_macd_pdu_size [ i ] ; fpi -> edch_lchId [ i ] = p_conv_data -> edch_lchId [ i ] ; } fpi -> edch_type = p_conv_data -> edch_type ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; rlcinf -> urnti [ 0 ] = fpi -> com_context_id ; rlcinf -> li_size [ 0 ] = RLC_LI_7BITS ; rlcinf -> ciphered [ 0 ] = FALSE ; rlcinf -> deciphered [ 0 ] = FALSE ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; return fpi ; case CHANNEL_PCH : fpi -> paging_indications = p_conv_data -> paging_indications ; fpi -> num_chans = p_conv_data -> num_dch_in_flow ; if ( is_control_frame ) { return fpi ; } offset = 3 ; break ; case CHANNEL_DCH : fpi -> num_chans = p_conv_data -> num_dch_in_flow ; if ( is_control_frame ) { return fpi ; } rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; offset = 2 ; fakes = 5 ; for ( chan = 0 ; chan < fpi -> num_chans ; chan ++ ) { tfi = tvb_get_bits8 ( tvb , 3 + offset * 8 , 5 ) ; num_tbs = ( fpi -> is_uplink ) ? p_conv_data -> fp_dch_channel_info [ chan ] . ul_chan_num_tbs [ tfi ] : p_conv_data -> fp_dch_channel_info [ chan ] . dl_chan_num_tbs [ tfi ] ; tb_size = ( fpi -> is_uplink ) ? p_conv_data -> fp_dch_channel_info [ i ] . ul_chan_tf_size [ tfi ] : p_conv_data -> fp_dch_channel_info [ i ] . dl_chan_tf_size [ tfi ] ; if ( p_conv_data -> dchs_in_flow_list [ chan ] != 31 && ( p_conv_data -> dchs_in_flow_list [ chan ] == 24 && tb_size != 340 ) ) { fake_lchid = make_fake_lchid ( pinfo , p_conv_data -> dchs_in_flow_list [ chan ] ) ; } tb_bit_off = ( 2 + p_conv_data -> num_dch_in_flow ) * 8 ; for ( j = 0 ; j < num_tbs && j + chan < MAX_MAC_FRAMES ; j ++ ) { macinf -> trchid [ j + chan ] = p_conv_data -> dchs_in_flow_list [ chan ] ; if ( p_conv_data -> dchs_in_flow_list [ chan ] == 31 || p_conv_data -> dchs_in_flow_list [ chan ] == 24 ) { if ( 0 ) { macinf -> ctmux [ j + chan ] = FALSE ; macinf -> lchid [ j + chan ] = 1 ; macinf -> content [ j + chan ] = lchId_type_table [ 1 ] ; rlcinf -> mode [ j + chan ] = lchId_rlc_map [ 1 ] ; } else if ( p_conv_data -> dchs_in_flow_list [ chan ] == 24 && tb_size != 340 ) { macinf -> ctmux [ j + chan ] = FALSE ; macinf -> lchid [ j + chan ] = fake_lchid ; macinf -> fake_chid [ j + chan ] = TRUE ; macinf -> content [ j + chan ] = MAC_CONTENT_PS_DTCH ; rlcinf -> mode [ j + chan ] = RLC_AM ; } else { macinf -> ctmux [ j + chan ] = TRUE ; <S2SV_StartBug> c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> macinf -> lchid [ j + chan ] = c_t + 1 ; <S2SV_EndBug> <S2SV_StartBug> macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ; <S2SV_EndBug> } } else { fake_lchid = make_fake_lchid ( pinfo , p_conv_data -> dchs_in_flow_list [ chan ] ) ; macinf -> ctmux [ j + chan ] = FALSE ; macinf -> content [ j + chan ] = lchId_type_table [ fake_lchid ] ; rlcinf -> mode [ j + chan ] = lchId_rlc_map [ fake_lchid ] ; macinf -> fake_chid [ j + chan ] = TRUE ; macinf -> lchid [ j + chan ] = fake_lchid ; } rlcinf -> urnti [ j + chan ] = p_conv_data -> com_context_id ; rlcinf -> li_size [ j + chan ] = RLC_LI_7BITS ; # if 0 if ( rrc_ciph_inf && g_tree_lookup ( rrc_ciph_inf , GINT_TO_POINTER ( ( gint ) p_conv_data -> com_context_id ) ) != NULL ) { rlcinf -> ciphered [ j + chan ] = TRUE ; } else { rlcinf -> ciphered [ j + chan ] = FALSE ; } # endif rlcinf -> ciphered [ j + chan ] = FALSE ; rlcinf -> deciphered [ j + chan ] = FALSE ; rlcinf -> rbid [ j + chan ] = macinf -> lchid [ j + chan ] ; tb_bit_off += tb_size + 4 ; } offset ++ ; } p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; offset = 2 ; break ; case CHANNEL_FACH_FDD : fpi -> num_chans = p_conv_data -> num_dch_in_flow ; if ( is_control_frame ) { return fpi ; } offset = 2 ; macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; macinf -> ctmux [ 0 ] = 1 ; macinf -> content [ 0 ] = MAC_CONTENT_DCCH ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; rlcinf -> urnti [ 0 ] = fpi -> channel ; rlcinf -> mode [ 0 ] = RLC_AM ; rlcinf -> li_size [ 0 ] = RLC_LI_7BITS ; rlcinf -> ciphered [ 0 ] = FALSE ; rlcinf -> deciphered [ 0 ] = FALSE ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; break ; case CHANNEL_RACH_FDD : fpi -> num_chans = p_conv_data -> num_dch_in_flow ; if ( is_control_frame ) { return fpi ; } offset = 2 ; macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; for ( chan = 0 ; chan < fpi -> num_chans ; chan ++ ) { macinf -> ctmux [ chan ] = 1 ; macinf -> content [ chan ] = MAC_CONTENT_DCCH ; rlcinf -> urnti [ chan ] = fpi -> com_context_id ; } p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; break ; case CHANNEL_HSDSCH_COMMON : rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; break ; default : expert_add_info ( pinfo , NULL , & ei_fp_transport_channel_type_unknown ) ; return NULL ; } for ( i = 0 ; i < fpi -> num_chans ; i ++ ) { tfi = tvb_get_guint8 ( tvb , offset ) ; if ( pinfo -> link_dir == P2P_DIR_UL ) { fpi -> chan_tf_size [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . ul_chan_tf_size [ tfi ] ; fpi -> chan_num_tbs [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . ul_chan_num_tbs [ tfi ] ; } else { fpi -> chan_tf_size [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . dl_chan_tf_size [ tfi ] ; fpi -> chan_num_tbs [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . dl_chan_num_tbs [ tfi ] ; } offset ++ ; } return fpi ; }
","<S2SV_ModStart> ; c_t = ( <S2SV_ModStart> , 4 ) + 1 ) % 0xf <S2SV_ModStart> ] = c_t <S2SV_ModEnd> ; macinf -> <S2SV_ModStart> lchId_type_table [ c_t <S2SV_ModEnd> ] ; rlcinf <S2SV_ModStart> lchId_rlc_map [ c_t <S2SV_ModEnd> ] ; }
",wireshark@wireshark/7d7190695ce2ff269fdffb04e87139995cde21f4,CVE-2016-5353,https://github.com/wireshark/wireshark/commit/7d7190695ce2ff269fdffb04e87139995cde21f4,2016-08-07T16:59Z,"<S2SV_StartBug> c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> macinf -> lchid [ j + chan ] = c_t + 1 ; <S2SV_EndBug> <S2SV_StartBug> macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ; <S2SV_EndBug>"
7178,CWE-552,"static int _hostsock_getsockname ( oe_fd_t * sock_ , struct oe_sockaddr * addr , oe_socklen_t * addrlen ) { int ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_socklen_t addrlen_in = 0 ; <S2SV_StartBug> oe_errno = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( addrlen ) <S2SV_EndBug> addrlen_in = * addrlen ; if ( oe_syscall_getsockname_ocall ( & ret , sock -> host_fd , <S2SV_StartBug> ( struct oe_sockaddr * ) addr , <S2SV_EndBug> addrlen_in , <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> = 0 ; oe_socklen_t addrlen_out = 0 ; <S2SV_ModStart> ( ! sock || ! addr || ! addrlen ) OE_RAISE_ERRNO ( OE_EINVAL ) ; addrlen_in = * addrlen ; if ( addrlen_in < 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> oe_syscall_getsockname_ocall ( & <S2SV_ModStart> -> host_fd , <S2SV_ModEnd> addr , addrlen_in <S2SV_ModStart> , addrlen_in , & addrlen_out <S2SV_ModEnd> ) != OE_OK <S2SV_ModStart> ) ; } if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( addrlen_in >= addrlen_out ) * addrlen = addrlen_out ;
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,"<S2SV_StartBug> oe_errno = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock ) <S2SV_EndBug> <S2SV_StartBug> if ( addrlen ) <S2SV_EndBug> <S2SV_StartBug> ( struct oe_sockaddr * ) addr , <S2SV_EndBug> <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug>"
1593,CWE-119,"<S2SV_StartBug> static void read_mv_probs ( nmv_context * ctx , int allow_hp , vp9_reader * r ) { <S2SV_EndBug> int i , j ; update_mv_probs ( ctx -> joints , MV_JOINTS - 1 , r ) ; for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * const comp_ctx = & ctx -> comps [ i ] ; update_mv_probs ( & comp_ctx -> sign , 1 , r ) ; update_mv_probs ( comp_ctx -> classes , MV_CLASSES - 1 , r ) ; update_mv_probs ( comp_ctx -> class0 , CLASS0_SIZE - 1 , r ) ; update_mv_probs ( comp_ctx -> bits , MV_OFFSET_BITS , r ) ; } for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * const comp_ctx = & ctx -> comps [ i ] ; for ( j = 0 ; j < CLASS0_SIZE ; ++ j ) update_mv_probs ( comp_ctx -> class0_fp [ j ] , MV_FP_SIZE - 1 , r ) ; update_mv_probs ( comp_ctx -> fp , 3 , r ) ; } if ( allow_hp ) { for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * const comp_ctx = & ctx -> comps [ i ] ; update_mv_probs ( & comp_ctx -> class0_hp , 1 , r ) ; update_mv_probs ( & comp_ctx -> hp , 1 , r ) ; } } }
","<S2SV_ModStart> int allow_hp , vpx_reader <S2SV_ModEnd> * r )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void read_mv_probs ( nmv_context * ctx , int allow_hp , vp9_reader * r ) { <S2SV_EndBug>"
2313,CWE-119,"void test_base64_decode ( void ) { char buffer [ 16 ] ; <S2SV_StartBug> int len = mutt_b64_decode ( buffer , encoded ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , sizeof ( clear ) - 1 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , len ) ; } buffer [ len ] = '\\0' ; if ( ! TEST_CHECK ( strcmp ( buffer , clear ) == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%s"" , clear ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s"" , buffer ) ; } }
","<S2SV_ModStart> buffer , encoded , sizeof ( buffer )
",neomutt@neomutt/6f163e07ae68654d7ac5268cbb7565f6df79ad85,CVE-2018-14359,https://github.com/neomutt/neomutt/commit/6f163e07ae68654d7ac5268cbb7565f6df79ad85,2018-07-17T17:29Z,"<S2SV_StartBug> int len = mutt_b64_decode ( buffer , encoded ) ; <S2SV_EndBug>"
2612,CWE-476,"static ssize_t o2nm_node_num_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> unsigned long tmp ; char * p = ( char * ) page ; int ret = 0 ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; if ( tmp >= O2NM_MAX_NODES ) return - ERANGE ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <S2SV_StartBug> write_lock ( & cluster -> cl_nodes_lock ) ; <S2SV_EndBug> if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { cluster -> cl_nodes [ tmp ] = node ; node -> nd_num = tmp ; set_bit ( tmp , cluster -> cl_nodes_bitmap ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; <S2SV_StartBug> if ( ret ) <S2SV_EndBug> return ret ; return count ; }
","<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
",torvalds@linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,CVE-2017-18216,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,2018-03-05T18:29Z,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> write_lock ( & cluster -> cl_nodes_lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug>
4189,CWE-120,"static int try_read_command_binary ( conn * c ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { memcpy ( & c -> binary_header , c -> rcurr , sizeof ( c -> binary_header ) ) ; protocol_binary_request_header * req ; req = & c -> binary_header ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d<S2SV_blank>Read<S2SV_blank>binary<S2SV_blank>protocol<S2SV_blank>data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d<S2SV_blank><S2SV_blank><S2SV_blank>"" , c -> sfd ) ; } fprintf ( stderr , ""<S2SV_blank>0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid<S2SV_blank>magic:<S2SV_blank><S2SV_blank>%x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } uint8_t extlen = c -> binary_header . request . extlen ; uint16_t keylen = c -> binary_header . request . keylen ; if ( c -> rbytes < keylen + extlen + sizeof ( c -> binary_header ) ) { return 0 ; } if ( ! resp_start ( c ) ) { conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; c -> last_cmd_time = current_time ; <S2SV_StartBug> char extbuf [ sizeof ( c -> binary_header ) + BIN_MAX_EXTLEN ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( extbuf + sizeof ( c -> binary_header ) , c -> rcurr + sizeof ( c -> binary_header ) , extlen ) ; <S2SV_EndBug> c -> rbytes -= sizeof ( c -> binary_header ) + extlen + keylen ; c -> rcurr += sizeof ( c -> binary_header ) + extlen + keylen ; dispatch_bin_command ( c , extbuf ) ; } return 1 ; }
","<S2SV_ModStart> ) + BIN_MAX_EXTLEN + 1 <S2SV_ModStart> binary_header ) , extlen > BIN_MAX_EXTLEN ? BIN_MAX_EXTLEN :
",memcached@memcached/02c6a2b62ddcb6fa4569a591d3461a156a636305,CVE-2020-10931,https://github.com/memcached/memcached/commit/02c6a2b62ddcb6fa4569a591d3461a156a636305,2020-03-24T15:15Z,"<S2SV_StartBug> char extbuf [ sizeof ( c -> binary_header ) + BIN_MAX_EXTLEN ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( extbuf + sizeof ( c -> binary_header ) , c -> rcurr + sizeof ( c -> binary_header ) , extlen ) ; <S2SV_EndBug>"
4319,CWE-787,"int tcp_test ( const char * ip_str , const short port ) { int sock , i ; struct sockaddr_in s_in ; int packetsize = 1024 ; unsigned char packet [ packetsize ] ; struct timeval tv , tv2 , tv3 ; int caplen = 0 ; int times [ REQUESTS ] ; int min , avg , max , len ; struct net_hdr nh ; tv3 . tv_sec = 0 ; tv3 . tv_usec = 1 ; s_in . sin_family = PF_INET ; s_in . sin_port = htons ( port ) ; if ( ! inet_aton ( ip_str , & s_in . sin_addr ) ) return - 1 ; if ( ( sock = socket ( s_in . sin_family , SOCK_STREAM , IPPROTO_TCP ) ) == - 1 ) return - 1 ; if ( fcntl ( sock , F_SETFL , O_NONBLOCK ) < 0 ) { perror ( ""fcntl(O_NONBLOCK)<S2SV_blank>failed"" ) ; return ( 1 ) ; } gettimeofday ( & tv , NULL ) ; while ( 1 ) { if ( connect ( sock , ( struct sockaddr * ) & s_in , sizeof ( s_in ) ) == - 1 ) { if ( errno != EINPROGRESS && errno != EALREADY ) { perror ( ""connect"" ) ; close ( sock ) ; printf ( ""Failed<S2SV_blank>to<S2SV_blank>connect\\n"" ) ; return - 1 ; } } else { gettimeofday ( & tv2 , NULL ) ; break ; } gettimeofday ( & tv2 , NULL ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 3000 * 1000 ) ) { printf ( ""Connection<S2SV_blank>timed<S2SV_blank>out\\n"" ) ; close ( sock ) ; return ( - 1 ) ; } usleep ( 10 ) ; } PCT ; printf ( ""TCP<S2SV_blank>connection<S2SV_blank>successful\\n"" ) ; memset ( & nh , 0 , sizeof ( nh ) ) ; nh . nh_type = 2 ; nh . nh_len = htonl ( 0 ) ; if ( send ( sock , & nh , sizeof ( nh ) , 0 ) != sizeof ( nh ) ) { perror ( ""send"" ) ; return - 1 ; } gettimeofday ( & tv , NULL ) ; i = 0 ; while ( 1 ) { caplen = read ( sock , & nh , sizeof ( nh ) ) ; if ( caplen == - 1 ) { if ( errno != EAGAIN ) { perror ( ""read"" ) ; return - 1 ; } } if ( ( unsigned ) caplen == sizeof ( nh ) ) { len = ntohl ( nh . nh_len ) ; <S2SV_StartBug> if ( nh . nh_type == 1 && i == 0 ) <S2SV_EndBug> { i = 1 ; caplen = read ( sock , packet , len ) ; if ( caplen == len ) { i = 2 ; break ; } else { i = 0 ; } } else { caplen = read ( sock , packet , len ) ; } } gettimeofday ( & tv2 , NULL ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 1000 * 1000 ) ) { break ; } if ( caplen == - 1 ) usleep ( 10 ) ; } if ( i == 2 ) { PCT ; printf ( ""airserv-ng<S2SV_blank>found\\n"" ) ; } else { PCT ; printf ( ""airserv-ng<S2SV_blank>NOT<S2SV_blank>found\\n"" ) ; } close ( sock ) ; for ( i = 0 ; i < REQUESTS ; i ++ ) { if ( ( sock = socket ( s_in . sin_family , SOCK_STREAM , IPPROTO_TCP ) ) == - 1 ) return - 1 ; if ( fcntl ( sock , F_SETFL , O_NONBLOCK ) < 0 ) { perror ( ""fcntl(O_NONBLOCK)<S2SV_blank>failed"" ) ; return ( 1 ) ; } usleep ( 1000 ) ; gettimeofday ( & tv , NULL ) ; while ( 1 ) { if ( connect ( sock , ( struct sockaddr * ) & s_in , sizeof ( s_in ) ) == - 1 ) { if ( errno != EINPROGRESS && errno != EALREADY ) { perror ( ""connect"" ) ; close ( sock ) ; printf ( ""Failed<S2SV_blank>to<S2SV_blank>connect\\n"" ) ; return - 1 ; } } else { gettimeofday ( & tv2 , NULL ) ; break ; } gettimeofday ( & tv2 , NULL ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 1000 * 1000 ) ) { break ; } select ( 1 , NULL , NULL , NULL , & tv3 ) ; } times [ i ] = ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) ; printf ( ""\\r%d/%d\\r"" , i , REQUESTS ) ; fflush ( stdout ) ; close ( sock ) ; } min = INT_MAX ; avg = 0 ; max = 0 ; for ( i = 0 ; i < REQUESTS ; i ++ ) { if ( times [ i ] < min ) min = times [ i ] ; if ( times [ i ] > max ) max = times [ i ] ; avg += times [ i ] ; } avg /= REQUESTS ; PCT ; printf ( ""ping<S2SV_blank>%s:%d<S2SV_blank>(min/avg/max):<S2SV_blank>%.3fms/%.3fms/%.3fms\\n"" , ip_str , port , min / 1000.0 , avg / 1000.0 , max / 1000.0 ) ; return 0 ; }
","<S2SV_ModStart> ; if ( len > 1024 || len < 0 ) continue ; if (
",aircrack-ng@aircrack-ng/091b153f294b9b695b0b2831e65936438b550d7b,CVE-2014-8322,https://github.com/aircrack-ng/aircrack-ng/commit/091b153f294b9b695b0b2831e65936438b550d7b,2020-01-31T22:15Z,<S2SV_StartBug> if ( nh . nh_type == 1 && i == 0 ) <S2SV_EndBug>
1044,CWE-284,"static uint16_t transmit_data ( serial_data_type_t type , uint8_t * data , uint16_t length ) { assert ( data != NULL ) ; assert ( length > 0 ) ; if ( type < DATA_TYPE_COMMAND || type > DATA_TYPE_SCO ) { LOG_ERROR ( ""%s<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>type:<S2SV_blank>%d"" , __func__ , type ) ; return 0 ; } -- data ; uint8_t previous_byte = * data ; * ( data ) = type ; ++ length ; uint16_t transmitted_length = 0 ; while ( length > 0 ) { <S2SV_StartBug> ssize_t ret = write ( uart_fd , data + transmitted_length , length ) ; <S2SV_EndBug> switch ( ret ) { case - 1 : LOG_ERROR ( ""In<S2SV_blank>%s,<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>the<S2SV_blank>uart<S2SV_blank>serial<S2SV_blank>port:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto done ; case 0 : goto done ; default : transmitted_length += ret ; length -= ret ; break ; } } done : ; * ( data ) = previous_byte ; if ( transmitted_length > 0 ) -- transmitted_length ; return transmitted_length ; }
","<S2SV_ModStart> ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> transmitted_length , length )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> ssize_t ret = write ( uart_fd , data + transmitted_length , length ) ; <S2SV_EndBug>"
6737,CWE-522,"int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""*<S2SV_blank>OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""*<S2SV_blank>OK<S2SV_blank>[CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ) == MUTT_ABORT ) { <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""*<S2SV_blank>PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; <S2SV_StartBug> # ifdef USE_SSL <S2SV_EndBug> err_close_conn : imap_close_connection ( adata ) ; <S2SV_StartBug> # endif <S2SV_EndBug> bail : FREE ( & adata -> capstr ) ; return - 1 ; }
","<S2SV_ModStart> ) { goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> return 0 ; bail <S2SV_ModEnd> : imap_close_connection ( <S2SV_ModStart> adata ) ; <S2SV_ModEnd> FREE ( &
",neomutt@neomutt/9c36717a3e2af1f2c1b7242035455ec8112b4b06,CVE-2020-28896,https://github.com/neomutt/neomutt/commit/9c36717a3e2af1f2c1b7242035455ec8112b4b06,2020-11-23T19:15Z,<S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> # ifdef USE_SSL <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug>
2753,CWE-476,"bool CompileKeymap ( XkbFile * file , struct xkb_keymap * keymap , enum merge_mode merge ) { bool ok ; XkbFile * files [ LAST_KEYMAP_FILE_TYPE + 1 ] = { NULL } ; enum xkb_file_type type ; struct xkb_context * ctx = keymap -> ctx ; for ( file = ( XkbFile * ) file -> defs ; file ; file = ( XkbFile * ) file -> common . next ) { if ( file -> file_type < FIRST_KEYMAP_FILE_TYPE || file -> file_type > LAST_KEYMAP_FILE_TYPE ) { <S2SV_StartBug> log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\n"" , <S2SV_EndBug> <S2SV_StartBug> xkb_file_type_to_string ( file -> file_type ) ) ; <S2SV_EndBug> continue ; } if ( files [ file -> file_type ] ) { log_err ( ctx , ""More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>%s<S2SV_blank>section<S2SV_blank>in<S2SV_blank>keymap<S2SV_blank>file;<S2SV_blank>"" ""All<S2SV_blank>sections<S2SV_blank>after<S2SV_blank>the<S2SV_blank>first<S2SV_blank>ignored\\n"" , xkb_file_type_to_string ( file -> file_type ) ) ; continue ; } files [ file -> file_type ] = file ; } ok = true ; for ( type = FIRST_KEYMAP_FILE_TYPE ; type <= LAST_KEYMAP_FILE_TYPE ; type ++ ) { if ( files [ type ] == NULL ) { log_err ( ctx , ""Required<S2SV_blank>section<S2SV_blank>%s<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>keymap\\n"" , xkb_file_type_to_string ( type ) ) ; ok = false ; } } if ( ! ok ) return false ; for ( type = FIRST_KEYMAP_FILE_TYPE ; type <= LAST_KEYMAP_FILE_TYPE ; type ++ ) { log_dbg ( ctx , ""Compiling<S2SV_blank>%s<S2SV_blank>\\""%s\\""\\n"" , xkb_file_type_to_string ( type ) , files [ type ] -> name ) ; ok = compile_file_fns [ type ] ( files [ type ] , keymap , merge ) ; if ( ! ok ) { log_err ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>%s\\n"" , xkb_file_type_to_string ( type ) ) ; return false ; } } return UpdateDerivedKeymapFields ( keymap ) ; }
","<S2SV_ModStart> LAST_KEYMAP_FILE_TYPE ) { if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , ""Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\n"" ) ; } else { <S2SV_ModStart> ) ) ; }
",xkbcommon@libxkbcommon/917636b1d0d70205a13f89062b95e3a0fc31d4ff,CVE-2018-15855,https://github.com/xkbcommon/libxkbcommon/commit/917636b1d0d70205a13f89062b95e3a0fc31d4ff,2018-08-25T21:29Z,"<S2SV_StartBug> log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\n"" , <S2SV_EndBug> <S2SV_StartBug> xkb_file_type_to_string ( file -> file_type ) ) ; <S2SV_EndBug>"
2649,CWE-399,"<S2SV_StartBug> static int udp_push_pending_frames ( struct sock * sk ) <S2SV_EndBug> { struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct flowi4 * fl4 = & inet -> cork . fl . u . ip4 ; struct sk_buff * skb ; int err = 0 ; skb = ip_finish_skb ( sk , fl4 ) ; if ( ! skb ) goto out ; err = udp_send_skb ( skb , fl4 ) ; out : up -> len = 0 ; up -> pending = 0 ; return err ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int udp_push_pending_frames (
",torvalds@linux/8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1,CVE-2013-4162,https://github.com/torvalds/linux/commit/8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1,2013-07-29T13:59Z,<S2SV_StartBug> static int udp_push_pending_frames ( struct sock * sk ) <S2SV_EndBug>
287,CWE-416,"static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; <S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; <S2SV_StartBug> } <S2SV_EndBug> hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( <S2SV_ModStart> ! head ) ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> hlist_add_head_rcu ( &
",torvalds@linux/12ca6ad2e3a896256f086497a7c7406a547ee373,CVE-2015-8963,https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373,2016-11-16T05:59Z,<S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
1969,CWE-119,"static void set_ppflags ( const vpx_codec_alg_priv_t * ctx , vp9_ppflags_t * flags ) { flags -> post_proc_flag = <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> ( ctx -> dbg_color_ref_frame_flag ? VP9D_DEBUG_CLR_FRM_REF_BLKS : 0 ) | ( ctx -> dbg_color_mb_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_color_b_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_display_mv_flag ? VP9D_DEBUG_DRAW_MV : 0 ) | # endif ctx -> postproc_cfg . post_proc_flag ; flags -> deblocking_level = ctx -> postproc_cfg . deblocking_level ; flags -> noise_level = ctx -> postproc_cfg . noise_level ; <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> flags -> display_ref_frame_flag = ctx -> dbg_color_ref_frame_flag ; flags -> display_mb_modes_flag = ctx -> dbg_color_mb_modes_flag ; flags -> display_b_modes_flag = ctx -> dbg_color_b_modes_flag ; flags -> display_mv_flag = ctx -> dbg_display_mv_flag ; # endif }
","<S2SV_ModStart> -> post_proc_flag = <S2SV_ModEnd> ctx -> postproc_cfg <S2SV_ModStart> . noise_level ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug>
1618,CWE-119,"static void swap_frame_buffers ( VP9Decoder * pbi ) { int ref_index = 0 , mask ; VP9_COMMON * const cm = & pbi -> common ; <S2SV_StartBug> for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( mask & 1 ) { <S2SV_EndBug> const int old_idx = cm -> ref_frame_map [ ref_index ] ; <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , & cm -> ref_frame_map [ ref_index ] , <S2SV_EndBug> <S2SV_StartBug> cm -> new_fb_idx ) ; <S2SV_EndBug> <S2SV_StartBug> if ( old_idx >= 0 && cm -> frame_bufs [ old_idx ] . ref_count == 0 ) <S2SV_EndBug> cm -> release_fb_cb ( cm -> cb_priv , & cm -> frame_bufs [ old_idx ] . raw_frame_buffer ) ; } ++ ref_index ; } cm -> frame_to_show = get_frame_new_buffer ( cm ) ; cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ; for ( ref_index = 0 ; ref_index < 3 ; ref_index ++ ) <S2SV_StartBug> cm -> frame_refs [ ref_index ] . idx = INT_MAX ; <S2SV_EndBug> }
","<S2SV_ModStart> -> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; lock_buffer_pool ( pool ) ; <S2SV_ModStart> 1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( <S2SV_ModEnd> ( mask & <S2SV_ModStart> & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) <S2SV_ModStart> ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf = 0 ; cm -> frame_to_show = get_frame_new_buffer ( cm ) ; if ( ! pbi -> frame_parallel_decode || ! cm -> show_frame ) { lock_buffer_pool ( pool ) ; -- frame_bufs [ <S2SV_ModEnd> cm -> new_fb_idx <S2SV_ModStart> cm -> new_fb_idx <S2SV_ModEnd> ] . ref_count <S2SV_ModStart> ] . ref_count ; unlock_buffer_pool ( pool ) ; } <S2SV_ModEnd> for ( ref_index <S2SV_ModStart> . idx = - 1 <S2SV_ModEnd> ; } <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( mask & 1 ) { <S2SV_EndBug> <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , & cm -> ref_frame_map [ ref_index ] , <S2SV_EndBug> <S2SV_StartBug> cm -> new_fb_idx ) ; <S2SV_EndBug> <S2SV_StartBug> if ( old_idx >= 0 && cm -> frame_bufs [ old_idx ] . ref_count == 0 ) <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ ref_index ] . idx = INT_MAX ; <S2SV_EndBug>"
2857,CWE-119,"static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; <S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }
","<S2SV_ModStart> , n ) ; if ( w == NULL ) return 0
",nothings@stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,CVE-2019-13217,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,2019-08-15T17:15Z,"<S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug>"
3143,CWE-284,"static int http_connect ( http_subtransport * t ) { int error ; char * proxy_url ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , ""git_stream"" ) ; if ( git_stream_supports_proxy ( t -> io ) && ! git_remote__get_http_proxy ( t -> owner -> owner , ! ! t -> connection_data . use_ssl , & proxy_url ) ) { error = git_stream_set_proxy ( t -> io , proxy_url ) ; git__free ( proxy_url ) ; if ( error < 0 ) return error ; } error = git_stream_connect ( t -> io ) ; # if defined ( GIT_OPENSSL ) || defined ( GIT_SECURE_TRANSPORT ) || defined ( GIT_CURL ) if ( ( ! error || error == GIT_ECERTIFICATE ) && t -> owner -> certificate_check_cb != NULL && git_stream_is_encrypted ( t -> io ) ) { git_cert * cert ; <S2SV_StartBug> int is_valid ; <S2SV_EndBug> if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ; <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug> is_valid = error != GIT_ECERTIFICATE ; error = t -> owner -> certificate_check_cb ( cert , is_valid , t -> connection_data . host , t -> owner -> message_cb_payload ) ; if ( error < 0 ) { if ( ! giterr_last ( ) ) giterr_set ( GITERR_NET , ""user<S2SV_blank>cancelled<S2SV_blank>certificate<S2SV_blank>check"" ) ; return error ; } } # endif if ( error < 0 ) return error ; t -> connected = 1 ; return 0 ; }
","<S2SV_ModStart> ; int is_valid = ( error == GIT_OK ) <S2SV_ModStart> giterr_clear ( ) <S2SV_ModEnd> ; error =
",libgit2@libgit2/b5c6a1b407b7f8b952bded2789593b68b1876211,CVE-2016-10130,https://github.com/libgit2/libgit2/commit/b5c6a1b407b7f8b952bded2789593b68b1876211,2017-03-24T15:59Z,<S2SV_StartBug> int is_valid ; <S2SV_EndBug> <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug>
2002,CWE-119,"void * vpx_memalign ( size_t align , size_t size ) { void * addr , * x = NULL ; <S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> int number_aau ; if ( vpx_mm_create_heap_memory ( ) < 0 ) { _P ( printf ( ""[vpx][mm]<S2SV_blank>ERROR<S2SV_blank>vpx_memalign()<S2SV_blank>Couldn\'t<S2SV_blank>create<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Heap.\\n"" ) ; ) } number_aau = ( ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ; addr = hmm_alloc ( & hmm_d , number_aau ) ; # else addr = VPX_MALLOC_L ( size + align - 1 + ADDRESS_STORAGE_SIZE ) ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( addr ) { x = align_addr ( ( unsigned char * ) addr + ADDRESS_STORAGE_SIZE , ( int ) align ) ; ( ( size_t * ) x ) [ - 1 ] = ( size_t ) addr ; } return x ; }
","<S2SV_ModStart> = NULL ; addr = malloc <S2SV_ModEnd> ( size + <S2SV_ModStart> ADDRESS_STORAGE_SIZE ) ; <S2SV_ModEnd> if ( addr
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug>
2433,CWE-119,"static bool parse_reconnect ( struct pool * pool , json_t * val ) { <S2SV_StartBug> char * sockaddr_url , * stratum_port , * tmp ; <S2SV_EndBug> char * url , * port , address [ 256 ] ; <S2SV_StartBug> if ( opt_disable_client_reconnect ) { <S2SV_EndBug> applog ( LOG_WARNING , ""Stratum<S2SV_blank>client.reconnect<S2SV_blank>forbidden,<S2SV_blank>aborting."" ) ; return false ; } memset ( address , 0 , 255 ) ; <S2SV_StartBug> url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; <S2SV_EndBug> if ( ! url ) url = pool -> sockaddr_url ; port = ( char * ) json_string_value ( json_array_get ( val , 1 ) ) ; if ( ! port ) port = pool -> stratum_port ; <S2SV_StartBug> sprintf ( address , ""%s:%s"" , url , port ) ; <S2SV_EndBug> if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ; applog ( LOG_NOTICE , ""Reconnect<S2SV_blank>requested<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s"" , get_pool_name ( pool ) , address ) ; clear_pool_work ( pool ) ; mutex_lock ( & pool -> stratum_lock ) ; __suspend_stratum ( pool ) ; tmp = pool -> sockaddr_url ; pool -> sockaddr_url = sockaddr_url ; pool -> stratum_url = pool -> sockaddr_url ; free ( tmp ) ; tmp = pool -> stratum_port ; pool -> stratum_port = stratum_port ; free ( tmp ) ; mutex_unlock ( & pool -> stratum_lock ) ; if ( ! restart_stratum ( pool ) ) { pool_failed ( pool ) ; return false ; } return true ; }
","<S2SV_ModStart> val ) { if ( opt_disable_client_reconnect ) { applog ( LOG_WARNING , ""Stratum<S2SV_blank>client.reconnect<S2SV_blank>received<S2SV_blank>but<S2SV_blank>is<S2SV_blank>disabled,<S2SV_blank>not<S2SV_blank>reconnecting."" ) ; return false ; } <S2SV_ModEnd> char * url <S2SV_ModStart> 256 ] ; char * sockaddr_url , * stratum_port , * tmp ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; port <S2SV_ModEnd> = ( char <S2SV_ModStart> ( val , <S2SV_ModEnd> 1 ) ) <S2SV_ModStart> -> stratum_port ; snprintf ( address , sizeof ( address ) <S2SV_ModEnd> , ""%s:%s"" ,
",sgminer-dev@sgminer/78cc408369bdbbd440196c93574098d1482efbce,CVE-2014-4501,https://github.com/sgminer-dev/sgminer/commit/78cc408369bdbbd440196c93574098d1482efbce,2014-07-23T14:55Z,"<S2SV_StartBug> char * sockaddr_url , * stratum_port , * tmp ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_disable_client_reconnect ) { <S2SV_EndBug> <S2SV_StartBug> url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( address , ""%s:%s"" , url , port ) ; <S2SV_EndBug>"
2034,CWE-119,"static void open_output_file ( struct stream_state * stream , <S2SV_StartBug> struct VpxEncoderConfig * global ) { <S2SV_EndBug> const char * fn = stream -> config . out_fn ; const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ; if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ; stream -> file = strcmp ( fn , ""-"" ) ? fopen ( fn , ""wb"" ) : set_binary_mode ( stdout ) ; if ( ! stream -> file ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>output<S2SV_blank>file"" ) ; if ( stream -> config . write_webm && fseek ( stream -> file , 0 , SEEK_CUR ) ) fatal ( ""WebM<S2SV_blank>output<S2SV_blank>to<S2SV_blank>pipes<S2SV_blank>not<S2SV_blank>supported."" ) ; # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) { stream -> ebml . stream = stream -> file ; write_webm_file_header ( & stream -> ebml , cfg , & global -> framerate , stream -> config . stereo_fmt , <S2SV_StartBug> global -> codec -> fourcc ) ; <S2SV_EndBug> } # endif if ( ! stream -> config . write_webm ) { ivf_write_file_header ( stream -> file , cfg , global -> codec -> fourcc , 0 ) ; } }
","<S2SV_ModStart> VpxEncoderConfig * global , const struct VpxRational * pixel_aspect_ratio <S2SV_ModStart> codec -> fourcc , pixel_aspect_ratio
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> struct VpxEncoderConfig * global ) { <S2SV_EndBug> <S2SV_StartBug> global -> codec -> fourcc ) ; <S2SV_EndBug>
6871,CWE-79,"static int rndr_quote ( struct buf * ob , const struct buf * text , void * opaque ) { if ( ! text || ! text -> size ) return 0 ; <S2SV_StartBug> BUFPUTSL ( ob , ""<q>"" ) ; <S2SV_EndBug> bufput ( ob , text -> data , text -> size ) ; BUFPUTSL ( ob , ""</q>"" ) ; return 1 ; }
","<S2SV_ModStart> return 0 ; struct html_renderopt * options = opaque ; <S2SV_ModStart> ""<q>"" ) ; if ( options -> flags & HTML_ESCAPE ) escape_html ( ob , text -> data , text -> size ) ; else
",vmg@redcarpet/a699c82292b17c8e6a62e1914d5eccc252272793,CVE-2020-26298,https://github.com/vmg/redcarpet/commit/a699c82292b17c8e6a62e1914d5eccc252272793,2021-01-11T19:15Z,"<S2SV_StartBug> BUFPUTSL ( ob , ""<q>"" ) ; <S2SV_EndBug>"
1978,CWE-119,"const char * vpx_svc_get_message ( const SvcContext * svc_ctx ) { <S2SV_StartBug> const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( svc_ctx == NULL || si == NULL ) return NULL ; return si -> message_buffer ; }
","<S2SV_ModStart> ) { const SvcInternal_t <S2SV_ModEnd> * const si
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ; <S2SV_EndBug>
3086,CWE-264,"static int command_read ( struct pci_dev * dev , int offset , u16 * value , void * data ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int ret ; <S2SV_StartBug> ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; <S2SV_EndBug> if ( ! pci_is_enabled ( dev ) ) return ret ; for ( i = 0 ; i < PCI_ROM_RESOURCE ; i ++ ) { if ( dev -> resource [ i ] . flags & IORESOURCE_IO ) <S2SV_StartBug> * value |= PCI_COMMAND_IO ; <S2SV_EndBug> if ( dev -> resource [ i ] . flags & IORESOURCE_MEM ) * value |= PCI_COMMAND_MEMORY ; } return ret ; }
","<S2SV_ModStart> ) { int ret = pci_read_config_word <S2SV_ModEnd> ( dev , <S2SV_ModStart> offset , value ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; <S2SV_ModEnd> * value |= <S2SV_ModStart> * value |= cmd -> val & ~ PCI_COMMAND_GUEST ; <S2SV_ModEnd> return ret ;
",torvalds@linux/af6fc858a35b90e89ea7a7ee58e66628c55c776b,CVE-2015-2150,https://github.com/torvalds/linux/commit/af6fc858a35b90e89ea7a7ee58e66628c55c776b,2015-03-12T14:59Z,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; <S2SV_EndBug> <S2SV_StartBug> * value |= PCI_COMMAND_IO ; <S2SV_EndBug>"
130,CWE-476,"rdpCredssp * credssp_new ( freerdp * instance , rdpTransport * transport , rdpSettings * settings ) { rdpCredssp * credssp ; credssp = ( rdpCredssp * ) malloc ( sizeof ( rdpCredssp ) ) ; ZeroMemory ( credssp , sizeof ( rdpCredssp ) ) ; if ( credssp != NULL ) { HKEY hKey ; LONG status ; DWORD dwType ; DWORD dwSize ; credssp -> instance = instance ; credssp -> settings = settings ; credssp -> server = settings -> ServerMode ; credssp -> transport = transport ; credssp -> send_seq_num = 0 ; credssp -> recv_seq_num = 0 ; ZeroMemory ( & credssp -> negoToken , sizeof ( SecBuffer ) ) ; ZeroMemory ( & credssp -> pubKeyAuth , sizeof ( SecBuffer ) ) ; <S2SV_StartBug> ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ; <S2SV_EndBug> if ( credssp -> server ) { status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE , _T ( ""Software\\\\FreeRDP\\\\Server"" ) , 0 , KEY_READ | KEY_WOW64_64KEY , & hKey ) ; if ( status == ERROR_SUCCESS ) { status = RegQueryValueEx ( hKey , _T ( ""SspiModule"" ) , NULL , & dwType , NULL , & dwSize ) ; if ( status == ERROR_SUCCESS ) { credssp -> SspiModule = ( LPTSTR ) malloc ( dwSize + sizeof ( TCHAR ) ) ; status = RegQueryValueEx ( hKey , _T ( ""SspiModule"" ) , NULL , & dwType , ( BYTE * ) credssp -> SspiModule , & dwSize ) ; if ( status == ERROR_SUCCESS ) { _tprintf ( _T ( ""Using<S2SV_blank>SSPI<S2SV_blank>Module:<S2SV_blank>%s\\n"" ) , credssp -> SspiModule ) ; RegCloseKey ( hKey ) ; } } } } } return credssp ; }
","<S2SV_ModStart> ( SecBuffer ) ) ; SecInvalidateHandle ( & credssp -> context
",FreeRDP@FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53,CVE-2013-4119,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,2016-10-03T21:59Z,"<S2SV_StartBug> ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ; <S2SV_EndBug>"
1806,CWE-119,"static int calc_pframe_target_size_one_pass_vbr ( const VP9_COMP * const cpi ) { static const int af_ratio = 10 ; const RATE_CONTROL * const rc = & cpi -> rc ; int target ; # if USE_ALTREF_FOR_ONE_PASS target = ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ? <S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) / <S2SV_EndBug> ( rc -> baseline_gf_interval + af_ratio - 1 ) : <S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval ) / <S2SV_EndBug> ( rc -> baseline_gf_interval + af_ratio - 1 ) ; # else <S2SV_StartBug> target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> # endif return vp9_rc_clamp_pframe_target_size ( cpi , target ) ; }
","<S2SV_ModStart> ( rc -> avg_frame_bandwidth <S2SV_ModEnd> * rc -> <S2SV_ModStart> ( rc -> avg_frame_bandwidth <S2SV_ModEnd> * rc -> <S2SV_ModStart> = rc -> avg_frame_bandwidth <S2SV_ModEnd> ; # endif
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) / <S2SV_EndBug> <S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval ) / <S2SV_EndBug> <S2SV_StartBug> target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug>
6332,CWE-772,"chrand_ret * chrand_principal_2_svc ( chrand_arg * arg , struct svc_req * rqstp ) { static chrand_ret ret ; krb5_keyblock * k ; int nkeys ; char * prime_arg , * funcname ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_chrand_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_randkey_principal"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = randkey_principal_wrapper_3 ( ( void * ) handle , arg -> princ , FALSE , 0 , NULL , & k , & nkeys ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_randkey_principal ( ( void * ) handle , arg -> princ , & k , & nkeys ) ; } else { log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code == KADM5_OK ) { ret . keys = k ; ret . n_keys = nkeys ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug>"
2411,CWE-190,"static int _gd2GetHeader ( gdIOCtxPtr in , int * sx , int * sy , int * cs , int * vers , int * fmt , int * ncx , int * ncy , t_chunk_info * * chunkIdx ) { int i ; int ch ; char id [ 5 ] ; t_chunk_info * cidx ; int sidx ; int nc ; GD2_DBG ( php_gd_error ( ""Reading<S2SV_blank>gd2<S2SV_blank>header<S2SV_blank>info"" ) ) ; for ( i = 0 ; i < 4 ; i ++ ) { ch = gdGetC ( in ) ; if ( ch == EOF ) { goto fail1 ; } id [ i ] = ch ; } id [ 4 ] = 0 ; GD2_DBG ( php_gd_error ( ""Got<S2SV_blank>file<S2SV_blank>code:<S2SV_blank>%s"" , id ) ) ; if ( strcmp ( id , GD2_ID ) != 0 ) { GD2_DBG ( php_gd_error ( ""Not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>gd2<S2SV_blank>file"" ) ) ; goto fail1 ; } if ( gdGetWord ( vers , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""Version:<S2SV_blank>%d"" , * vers ) ) ; if ( ( * vers != 1 ) && ( * vers != 2 ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>version:<S2SV_blank>%d"" , * vers ) ) ; goto fail1 ; } if ( ! gdGetWord ( sx , in ) ) { GD2_DBG ( php_gd_error ( ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>x-size"" ) ) ; goto fail1 ; } if ( ! gdGetWord ( sy , in ) ) { GD2_DBG ( php_gd_error ( ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>y-size"" ) ) ; goto fail1 ; } GD2_DBG ( php_gd_error ( ""Image<S2SV_blank>is<S2SV_blank>%dx%d"" , * sx , * sy ) ) ; if ( gdGetWord ( cs , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""ChunkSize:<S2SV_blank>%d"" , * cs ) ) ; if ( ( * cs < GD2_CHUNKSIZE_MIN ) || ( * cs > GD2_CHUNKSIZE_MAX ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>chunk<S2SV_blank>size:<S2SV_blank>%d"" , * cs ) ) ; goto fail1 ; } if ( gdGetWord ( fmt , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""Format:<S2SV_blank>%d"" , * fmt ) ) ; if ( ( * fmt != GD2_FMT_RAW ) && ( * fmt != GD2_FMT_COMPRESSED ) && ( * fmt != GD2_FMT_TRUECOLOR_RAW ) && ( * fmt != GD2_FMT_TRUECOLOR_COMPRESSED ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>data<S2SV_blank>format:<S2SV_blank>%d"" , * fmt ) ) ; goto fail1 ; } if ( gdGetWord ( ncx , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""%d<S2SV_blank>Chunks<S2SV_blank>Wide"" , * ncx ) ) ; if ( gdGetWord ( ncy , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""%d<S2SV_blank>Chunks<S2SV_blank>vertically"" , * ncy ) ) ; if ( gd2_compressed ( * fmt ) ) { nc = ( * ncx ) * ( * ncy ) ; GD2_DBG ( php_gd_error ( ""Reading<S2SV_blank>%d<S2SV_blank>chunk<S2SV_blank>index<S2SV_blank>entries"" , nc ) ) ; <S2SV_StartBug> sidx = sizeof ( t_chunk_info ) * nc ; <S2SV_EndBug> if ( sidx <= 0 ) { goto fail1 ; } <S2SV_StartBug> cidx = gdCalloc ( sidx , 1 ) ; <S2SV_EndBug> for ( i = 0 ; i < nc ; i ++ ) { if ( gdGetInt ( & cidx [ i ] . offset , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( gdGetInt ( & cidx [ i ] . size , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( cidx [ i ] . offset < 0 || cidx [ i ] . size < 0 ) { gdFree ( cidx ) ; goto fail1 ; } } * chunkIdx = cidx ; } GD2_DBG ( php_gd_error ( ""gd2<S2SV_blank>header<S2SV_blank>complete"" ) ) ; return 1 ; fail1 : return 0 ; }
","<S2SV_ModStart> ) ) ; if ( overflow2 ( sidx , nc ) ) { goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( cidx == NULL ) { goto fail1 ; }
",php@php-src/7722455726bec8c53458a32851d2a87982cf0eac,CVE-2016-5766,https://github.com/php/php-src/commit/7722455726bec8c53458a32851d2a87982cf0eac?w=1,2016-08-07T10:59Z,"<S2SV_StartBug> sidx = sizeof ( t_chunk_info ) * nc ; <S2SV_EndBug> <S2SV_StartBug> cidx = gdCalloc ( sidx , 1 ) ; <S2SV_EndBug>"
4050,CWE-119,"static Image * ReadAAIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; size_t height , length , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) 4 * image -> columns ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( * p == 254 ) * p = 255 ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( q -> opacity != OpaqueOpacity ) image -> matte = MagickTrue ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( ( width != 0UL ) && ( height != 0UL ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( width != 0UL ) && ( height != 0UL ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug>"
3966,CWE-125,"static int jpc_pi_nextrpcl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; uint_fast32_t trx0 ; uint_fast32_t try0 ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <S2SV_StartBug> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> JAS_UINTFAST32_NUMBITS - 2 || <S2SV_StartBug> pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pchg -> rlvlnoend && pi -> rlvlno < pi -> maxrlvls ; ++ pi -> rlvlno ) { for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
","<S2SV_ModStart> -> prcwidthexpn + <S2SV_ModEnd> picomp -> numrlvls <S2SV_ModStart> -> prcheightexpn + <S2SV_ModEnd> picomp -> numrlvls
",mdadams@jasper/f25486c3d4aa472fec79150f2c41ed4333395d3d,CVE-2016-9583,https://github.com/mdadams/jasper/commit/f25486c3d4aa472fec79150f2c41ed4333395d3d,2018-08-01T17:29Z,<S2SV_StartBug> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> <S2SV_StartBug> pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > <S2SV_EndBug>
154,CWE-000,"static xsltCompMatchPtr xsltCompilePatternInternal ( const xmlChar * pattern , xmlDocPtr doc , xmlNodePtr node , xsltStylesheetPtr style , xsltTransformContextPtr runtime , int novar ) { xsltParserContextPtr ctxt = NULL ; xsltCompMatchPtr element , first = NULL , previous = NULL ; int current , start , end , level , j ; if ( pattern == NULL ) { xsltTransformError ( NULL , NULL , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; return ( NULL ) ; } ctxt = xsltNewParserContext ( style , runtime ) ; if ( ctxt == NULL ) return ( NULL ) ; ctxt -> doc = doc ; ctxt -> elem = node ; current = end = 0 ; while ( pattern [ current ] != 0 ) { start = current ; while ( IS_BLANK_CH ( pattern [ current ] ) ) current ++ ; end = current ; level = 0 ; while ( ( pattern [ end ] != 0 ) && ( ( pattern [ end ] != '|' ) || ( level != 0 ) ) ) { if ( pattern [ end ] == '[' ) level ++ ; else if ( pattern [ end ] == ']' ) level -- ; else if ( pattern [ end ] == '\\'' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != '\\'' ) ) end ++ ; } else if ( pattern [ end ] == \'""\' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != \'""\' ) ) end ++ ; } <S2SV_StartBug> end ++ ; <S2SV_EndBug> } if ( current == end ) { xsltTransformError ( NULL , NULL , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; goto error ; } element = xsltNewCompMatch ( ) ; if ( element == NULL ) { goto error ; } if ( first == NULL ) first = element ; else if ( previous != NULL ) previous -> next = element ; previous = element ; ctxt -> comp = element ; ctxt -> base = xmlStrndup ( & pattern [ start ] , end - start ) ; if ( ctxt -> base == NULL ) goto error ; ctxt -> cur = & ( ctxt -> base ) [ current - start ] ; element -> pattern = ctxt -> base ; element -> nsList = xmlGetNsList ( doc , node ) ; j = 0 ; if ( element -> nsList != NULL ) { while ( element -> nsList [ j ] != NULL ) j ++ ; } element -> nsNr = j ; # ifdef WITH_XSLT_DEBUG_PATTERN xsltGenericDebug ( xsltGenericDebugContext , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>parsing<S2SV_blank>\'%s\'\\n"" , element -> pattern ) ; # endif element -> priority = 0 ; xsltCompileLocationPathPattern ( ctxt , novar ) ; if ( ctxt -> error ) { xsltTransformError ( NULL , style , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>\'%s\'\\n"" , element -> pattern ) ; if ( style != NULL ) style -> errors ++ ; goto error ; } xsltReverseCompMatch ( ctxt , element ) ; if ( element -> priority == 0 ) { if ( ( ( element -> steps [ 0 ] . op == XSLT_OP_ELEM ) || ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) || ( element -> steps [ 0 ] . op == XSLT_OP_PI ) ) && ( element -> steps [ 0 ] . value != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) && ( element -> steps [ 0 ] . value2 != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.25 ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_NS ) && ( element -> steps [ 0 ] . value != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.25 ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) && ( element -> steps [ 0 ] . value == NULL ) && ( element -> steps [ 0 ] . value2 == NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.5 ; } else if ( ( ( element -> steps [ 0 ] . op == XSLT_OP_PI ) || ( element -> steps [ 0 ] . op == XSLT_OP_TEXT ) || ( element -> steps [ 0 ] . op == XSLT_OP_ALL ) || ( element -> steps [ 0 ] . op == XSLT_OP_NODE ) || ( element -> steps [ 0 ] . op == XSLT_OP_COMMENT ) ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.5 ; } else { element -> priority = 0.5 ; } } # ifdef WITH_XSLT_DEBUG_PATTERN xsltGenericDebug ( xsltGenericDebugContext , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>parsed<S2SV_blank>%s,<S2SV_blank>default<S2SV_blank>priority<S2SV_blank>%f\\n"" , element -> pattern , element -> priority ) ; # endif if ( pattern [ end ] == '|' ) end ++ ; current = end ; } if ( end == 0 ) { xsltTransformError ( NULL , style , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; if ( style != NULL ) style -> errors ++ ; goto error ; } xsltFreeParserContext ( ctxt ) ; return ( first ) ; error : if ( ctxt != NULL ) xsltFreeParserContext ( ctxt ) ; if ( first != NULL ) xsltFreeCompMatchList ( first ) ; return ( NULL ) ; }
","<S2SV_ModStart> ++ ; } if ( pattern [ end ] == 0 ) break ;
",chromium@chromium/094c773bb6c144f07b004ff3d1886100f157f4f6,,https://github.com/chromium/chromium/commit/094c773bb6c144f07b004ff3d1886100f157f4f6, ,<S2SV_StartBug> end ++ ; <S2SV_EndBug>
4200,CWE-772,"static Image * ReadPALMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickOffsetType totalOffset , seekNextDepth ; PixelInfo transpix ; Quantum index ; register ssize_t i , x ; register Quantum * q ; size_t bytes_per_row , flags , bits_per_pixel , version , nextDepthOffset , transparentIndex , compressionType , byte , mask , redbits , greenbits , bluebits , one , pad , size , bit ; ssize_t count , y ; unsigned char <S2SV_StartBug> * lastrow , <S2SV_EndBug> * one_row , * ptr ; unsigned short color16 ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } totalOffset = 0 ; do { image -> columns = ReadBlobMSBShort ( image ) ; image -> rows = ReadBlobMSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_row = ReadBlobMSBShort ( image ) ; flags = ReadBlobMSBShort ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; if ( ( bits_per_pixel != 1 ) && ( bits_per_pixel != 2 ) && ( bits_per_pixel != 4 ) && ( bits_per_pixel != 8 ) && ( bits_per_pixel != 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; version = ( size_t ) ReadBlobByte ( image ) ; if ( ( version != 0 ) && ( version != 1 ) && ( version != 2 ) ) ThrowReaderException ( CorruptImageError , ""FileFormatVersionMismatch"" ) ; nextDepthOffset = ( size_t ) ReadBlobMSBShort ( image ) ; transparentIndex = ( size_t ) ReadBlobByte ( image ) ; compressionType = ( size_t ) ReadBlobByte ( image ) ; if ( ( compressionType != PALM_COMPRESSION_NONE ) && ( compressionType != PALM_COMPRESSION_SCANLINE ) && ( compressionType != PALM_COMPRESSION_RLE ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; pad = ReadBlobMSBShort ( image ) ; ( void ) pad ; one = 1 ; if ( ( bits_per_pixel < 16 ) && ( AcquireImageColormap ( image , one << bits_per_pixel , exception ) == MagickFalse ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; GetPixelInfo ( image , & transpix ) ; if ( bits_per_pixel == 16 ) { redbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) redbits ; greenbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) greenbits ; bluebits = ( size_t ) ReadBlobByte ( image ) ; ( void ) bluebits ; ReadBlobByte ( image ) ; ReadBlobByte ( image ) ; transpix . red = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; transpix . green = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 63 ) ; transpix . blue = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; } if ( bits_per_pixel == 8 ) { ssize_t index ; if ( flags & PALM_HAS_COLORMAP_FLAG ) { count = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { ReadBlobByte ( image ) ; index = ConstrainColormapIndex ( image , 255 - i , exception ) ; image -> colormap [ index ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ index ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ index ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } } else for ( i = 0 ; i < ( ssize_t ) ( 1L << bits_per_pixel ) ; i ++ ) { index = ConstrainColormapIndex ( image , 255 - i , exception ) ; image -> colormap [ index ] . red = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 0 ] ) ; image -> colormap [ index ] . green = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 1 ] ) ; image -> colormap [ index ] . blue = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 2 ] ) ; } } if ( flags & PALM_IS_COMPRESSED_FLAG ) size = ReadBlobMSBShort ( image ) ; ( void ) size ; image -> storage_class = DirectClass ; if ( bits_per_pixel < 16 ) { image -> storage_class = PseudoClass ; image -> depth = 8 ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; one_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ; if ( one_row == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> lastrow = ( unsigned char * ) NULL ; <S2SV_EndBug> if ( compressionType == PALM_COMPRESSION_SCANLINE ) { <S2SV_StartBug> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , <S2SV_EndBug> <S2SV_StartBug> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; <S2SV_EndBug> if ( lastrow == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } mask = ( size_t ) ( 1U << bits_per_pixel ) - 1 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( ( flags & PALM_IS_COMPRESSED_FLAG ) == 0 ) { image -> compression = NoCompression ; count = ReadBlob ( image , bytes_per_row , one_row ) ; if ( count != ( ssize_t ) bytes_per_row ) break ; } else { if ( compressionType == PALM_COMPRESSION_RLE ) { image -> compression = RLECompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; count = MagickMin ( count , ( ssize_t ) bytes_per_row - i ) ; byte = ( size_t ) ReadBlobByte ( image ) ; ( void ) ResetMagickMemory ( one_row + i , ( int ) byte , ( size_t ) count ) ; i += count ; } } else if ( compressionType == PALM_COMPRESSION_SCANLINE ) { size_t one ; one = 1 ; image -> compression = FaxCompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; i += 8 ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; byte = ( size_t ) MagickMin ( ( ssize_t ) bytes_per_row - i , 8 ) ; for ( bit = 0 ; bit < byte ; bit ++ ) { if ( ( y == 0 ) || ( count & ( one << ( 7 - bit ) ) ) ) one_row [ i + bit ] = ( unsigned char ) ReadBlobByte ( image ) ; else <S2SV_StartBug> one_row [ i + bit ] = lastrow [ i + bit ] ; <S2SV_EndBug> } } <S2SV_StartBug> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <S2SV_EndBug> } } ptr = one_row ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; if ( bits_per_pixel == 16 ) { if ( image -> columns > ( 2 * bytes_per_row ) ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { color16 = ( * ptr ++ << 8 ) ; color16 |= ( * ptr ++ ) ; SetPixelRed ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 11 ) & 0x1f ) ) / 0x1f ) , q ) ; SetPixelGreen ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 5 ) & 0x3f ) ) / 0x3f ) , q ) ; SetPixelBlue ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 0 ) & 0x1f ) ) / 0x1f ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } } else { bit = 8 - bits_per_pixel ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( size_t ) ( ptr - one_row ) >= bytes_per_row ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } index = ( Quantum ) ( mask - ( ( ( * ptr ) & ( mask << bit ) ) >> bit ) ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; if ( bit ) bit -= bits_per_pixel ; else { ptr ++ ; bit = 8 - bits_per_pixel ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( flags & PALM_HAS_TRANSPARENCY_FLAG ) { ssize_t index = ConstrainColormapIndex ( image , ( ssize_t ) ( mask - transparentIndex ) , exception ) ; if ( bits_per_pixel != 16 ) transpix = image -> colormap [ index ] ; ( void ) TransparentPaintImage ( image , & transpix , ( Quantum ) TransparentAlpha , MagickFalse , exception ) ; } one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( nextDepthOffset != 0 ) { totalOffset += ( MagickOffsetType ) ( nextDepthOffset * 4 ) ; if ( totalOffset >= ( MagickOffsetType ) GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) else seekNextDepth = SeekBlob ( image , totalOffset , SEEK_SET ) ; if ( seekNextDepth != totalOffset ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( nextDepthOffset != 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> unsigned char * last_row <S2SV_ModEnd> , * one_row <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> PALM_COMPRESSION_SCANLINE ) { last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> sizeof ( * last_row ) ) ; if ( last_row <S2SV_ModEnd> == ( unsigned <S2SV_ModStart> bit ] = last_row <S2SV_ModEnd> [ i + <S2SV_ModStart> ) CopyMagickMemory ( last_row <S2SV_ModEnd> , one_row , <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; if
",ImageMagick@ImageMagick/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89,CVE-2017-12664,https://github.com/ImageMagick/ImageMagick/commit/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89,2017-08-07T21:29Z,"<S2SV_StartBug> * lastrow , <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) NULL ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , <S2SV_EndBug> <S2SV_StartBug> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; <S2SV_EndBug> <S2SV_StartBug> one_row [ i + bit ] = lastrow [ i + bit ] ; <S2SV_EndBug> <S2SV_StartBug> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug>"
977,CWE-416,"int inet6_csk_xmit ( struct sock * sk , struct sk_buff * skb , struct flowi * fl_unused ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 fl6 ; struct dst_entry * dst ; int res ; dst = inet6_csk_route_socket ( sk , & fl6 ) ; if ( IS_ERR ( dst ) ) { sk -> sk_err_soft = - PTR_ERR ( dst ) ; sk -> sk_route_caps = 0 ; kfree_skb ( skb ) ; return PTR_ERR ( dst ) ; } rcu_read_lock ( ) ; skb_dst_set_noref ( skb , dst ) ; fl6 . daddr = sk -> sk_v6_daddr ; <S2SV_StartBug> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; return res ; }
","<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,"<S2SV_StartBug> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug>"
3730,CWE-200,"__be32 ipv6_select_ident ( struct net * net , const struct in6_addr * daddr , const struct in6_addr * saddr ) { <S2SV_StartBug> static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 id ; net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; <S2SV_EndBug> return htonl ( id ) ; }
","<S2SV_ModStart> saddr ) { u32 id <S2SV_ModEnd> ; id = <S2SV_ModStart> __ipv6_select_ident ( net <S2SV_ModEnd> , daddr ,
",torvalds@linux/df453700e8d81b1bdafdf684365ee2b9431fb702,CVE-2019-10638,https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702,2019-07-05T23:15Z,"<S2SV_StartBug> static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_EndBug> <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; <S2SV_EndBug>"
8429,CWE-401,"static int gs_can_open ( struct net_device * netdev ) { struct gs_can * dev = netdev_priv ( netdev ) ; struct gs_usb * parent = dev -> parent ; int rc , i ; struct gs_device_mode * dm ; u32 ctrlmode ; rc = open_candev ( netdev ) ; if ( rc ) return rc ; if ( atomic_add_return ( 1 , & parent -> active_channels ) == 1 ) { for ( i = 0 ; i < GS_MAX_RX_URBS ; i ++ ) { struct urb * urb ; u8 * buf ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) return - ENOMEM ; buf = usb_alloc_coherent ( dev -> udev , sizeof ( struct gs_host_frame ) , GFP_KERNEL , & urb -> transfer_dma ) ; if ( ! buf ) { netdev_err ( netdev , ""No<S2SV_blank>memory<S2SV_blank>left<S2SV_blank>for<S2SV_blank>USB<S2SV_blank>buffer\\n"" ) ; usb_free_urb ( urb ) ; return - ENOMEM ; } usb_fill_bulk_urb ( urb , dev -> udev , usb_rcvbulkpipe ( dev -> udev , GSUSB_ENDPOINT_IN ) , buf , sizeof ( struct gs_host_frame ) , gs_usb_receive_bulk_callback , parent ) ; urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; usb_anchor_urb ( urb , & parent -> rx_submitted ) ; rc = usb_submit_urb ( urb , GFP_KERNEL ) ; if ( rc ) { if ( rc == - ENODEV ) netif_device_detach ( dev -> netdev ) ; netdev_err ( netdev , ""usb_submit<S2SV_blank>failed<S2SV_blank>(err=%d)\\n"" , rc ) ; <S2SV_StartBug> usb_unanchor_urb ( urb ) ; <S2SV_EndBug> break ; } usb_free_urb ( urb ) ; } } dm = kmalloc ( sizeof ( * dm ) , GFP_KERNEL ) ; if ( ! dm ) return - ENOMEM ; ctrlmode = dev -> can . ctrlmode ; dm -> flags = 0 ; if ( ctrlmode & CAN_CTRLMODE_LOOPBACK ) dm -> flags |= GS_CAN_MODE_LOOP_BACK ; else if ( ctrlmode & CAN_CTRLMODE_LISTENONLY ) dm -> flags |= GS_CAN_MODE_LISTEN_ONLY ; if ( ctrlmode & CAN_CTRLMODE_ONE_SHOT ) dm -> flags |= GS_CAN_MODE_ONE_SHOT ; if ( ctrlmode & CAN_CTRLMODE_3_SAMPLES ) dm -> flags |= GS_CAN_MODE_TRIPLE_SAMPLE ; dm -> mode = GS_CAN_MODE_START ; rc = usb_control_msg ( interface_to_usbdev ( dev -> iface ) , usb_sndctrlpipe ( interface_to_usbdev ( dev -> iface ) , 0 ) , GS_USB_BREQ_MODE , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , dev -> channel , 0 , dm , sizeof ( * dm ) , 1000 ) ; if ( rc < 0 ) { netdev_err ( netdev , ""Couldn\'t<S2SV_blank>start<S2SV_blank>device<S2SV_blank>(err=%d)\\n"" , rc ) ; kfree ( dm ) ; return rc ; } kfree ( dm ) ; dev -> can . state = CAN_STATE_ERROR_ACTIVE ; if ( ! ( dev -> can . ctrlmode & CAN_CTRLMODE_LISTENONLY ) ) netif_start_queue ( netdev ) ; return 0 ; }
","<S2SV_ModStart> ) ; usb_unanchor_urb ( urb ) ; usb_free_urb
",torvalds@linux/fb5be6a7b4863ecc44963bb80ca614584b6c7817,CVE-2019-19052,https://github.com/torvalds/linux/commit/fb5be6a7b4863ecc44963bb80ca614584b6c7817,2019-11-18T06:15Z,<S2SV_StartBug> usb_unanchor_urb ( urb ) ; <S2SV_EndBug>
1007,CWE-284,"static inline int btif_hl_close_select_thread ( void ) { int result = 0 ; char sig_on = btif_hl_signal_select_exit ; BTIF_TRACE_DEBUG ( ""btif_hl_signal_select_exit"" ) ; <S2SV_StartBug> result = send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> if ( btif_is_enabled ( ) ) { if ( select_thread_id != - 1 ) { pthread_join ( select_thread_id , NULL ) ; select_thread_id = - 1 ; } } list_free ( soc_queue ) ; return result ; }
","<S2SV_ModStart> ; result = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) , 0 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,"<S2SV_StartBug> result = send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug>"
1397,CWE-119,"void vp8_reset_mb_tokens_context ( MACROBLOCKD * x ) { ENTROPY_CONTEXT * a_ctx = ( ( ENTROPY_CONTEXT * ) x -> above_context ) ; ENTROPY_CONTEXT * l_ctx = ( ( ENTROPY_CONTEXT * ) x -> left_context ) ; <S2SV_StartBug> vpx_memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> if ( ! x -> mode_info_context -> mbmi . is_4x4 ) { a_ctx [ 8 ] = l_ctx [ 8 ] = 0 ; } }
","<S2SV_ModStart> left_context ) ; memset <S2SV_ModEnd> ( a_ctx , <S2SV_ModStart> 1 ) ; memset <S2SV_ModEnd> ( l_ctx ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug>"
6922,CWE-400,"int handle_ldf_stq ( u32 insn , struct pt_regs * regs ) { unsigned long addr = compute_effective_address ( regs , insn , 0 ) ; int freg = ( ( insn >> 25 ) & 0x1e ) | ( ( insn >> 20 ) & 0x20 ) ; struct fpustate * f = FPUSTATE ; int asi = decode_asi ( insn , regs ) ; int flag = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> save_and_clear_fpu ( ) ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ 0x1c000 ; if ( freg & 3 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; do_fpother ( regs ) ; return 0 ; } if ( insn & 0x200000 ) { u64 first = 0 , second = 0 ; if ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) { first = * ( u64 * ) & f -> regs [ freg ] ; second = * ( u64 * ) & f -> regs [ freg + 2 ] ; } if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } switch ( asi ) { case ASI_P : case ASI_S : break ; case ASI_PL : case ASI_SL : { u64 tmp = __swab64p ( & first ) ; first = __swab64p ( & second ) ; second = tmp ; break ; } default : if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( put_user ( first >> 32 , ( u32 __user * ) addr ) || __put_user ( ( u32 ) first , ( u32 __user * ) ( addr + 4 ) ) || __put_user ( second >> 32 , ( u32 __user * ) ( addr + 8 ) ) || __put_user ( ( u32 ) second , ( u32 __user * ) ( addr + 12 ) ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } } else { u32 data [ 4 ] __attribute__ ( ( aligned ( 8 ) ) ) ; int size , i ; int err ; if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } else if ( asi > ASI_SNFL ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } switch ( insn & 0x180000 ) { case 0x000000 : size = 1 ; break ; case 0x100000 : size = 4 ; break ; default : size = 2 ; break ; } for ( i = 0 ; i < size ; i ++ ) data [ i ] = 0 ; err = get_user ( data [ 0 ] , ( u32 __user * ) addr ) ; if ( ! err ) { for ( i = 1 ; i < size ; i ++ ) err |= __get_user ( data [ i ] , ( u32 __user * ) ( addr + 4 * i ) ) ; } if ( err && ! ( asi & 0x2 ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( asi & 0x8 ) { u64 tmp ; switch ( size ) { case 1 : data [ 0 ] = le32_to_cpup ( data + 0 ) ; break ; default : * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; break ; case 4 : tmp = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 2 ) ) ; * ( u64 * ) ( data + 2 ) = tmp ; break ; } } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & FPRS_FEF ) ) { current_thread_info ( ) -> fpsaved [ 0 ] = FPRS_FEF ; current_thread_info ( ) -> gsr [ 0 ] = 0 ; } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) ) { if ( freg < 32 ) memset ( f -> regs , 0 , 32 * sizeof ( u32 ) ) ; else memset ( f -> regs + 32 , 0 , 32 * sizeof ( u32 ) ) ; } memcpy ( f -> regs + freg , data , size * 4 ) ; current_thread_info ( ) -> fpsaved [ 0 ] |= flag ; } advance ( regs ) ; return 1 ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug>"
5362,CWE-264,"static struct sock * tcp_v6_syn_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq ; struct ipv6_pinfo * newnp ; <S2SV_StartBug> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; # ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key * key ; # endif struct flowi6 fl6 ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( ! newsk ) return NULL ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; # ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; # endif newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } ireq = inet_rsk ( req ) ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_TCP ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( ! newsk ) goto out_nonewsk ; newsk -> sk_gso_type = SKB_GSO_TCPV6 ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; inet6_sk_rx_dst_set ( newsk , skb ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; <S2SV_StartBug> if ( np -> opt ) <S2SV_EndBug> <S2SV_StartBug> newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; <S2SV_EndBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; <S2SV_StartBug> if ( newnp -> opt ) <S2SV_EndBug> <S2SV_StartBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + <S2SV_EndBug> <S2SV_StartBug> newnp -> opt -> opt_flen ) ; <S2SV_EndBug> tcp_ca_openreq_child ( newsk , dst ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = dst_metric_advmss ( dst ) ; if ( tcp_sk ( sk ) -> rx_opt . user_mss && tcp_sk ( sk ) -> rx_opt . user_mss < newtp -> advmss ) newtp -> advmss = tcp_sk ( sk ) -> rx_opt . user_mss ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; # ifdef CONFIG_TCP_MD5SIG key = tcp_v6_md5_do_lookup ( sk , & newsk -> sk_v6_daddr ) ; if ( key ) { tcp_md5_do_add ( newsk , ( union tcp_md5_addr * ) & newsk -> sk_v6_daddr , AF_INET6 , key -> key , key -> keylen , sk_gfp_atomic ( sk , GFP_ATOMIC ) ) ; } # endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; tcp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req ) { tcp_move_syn ( newtp , req ) ; if ( ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , sk_gfp_atomic ( sk , GFP_ATOMIC ) ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } } return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
","<S2SV_ModStart> ( sk ) ; struct ipv6_txoptions * opt <S2SV_ModStart> ) ) ; opt = rcu_dereference <S2SV_ModEnd> ( np -> <S2SV_ModStart> -> opt ) ; if ( opt ) { <S2SV_ModEnd> opt = ipv6_dup_options <S2SV_ModStart> ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> inet_csk ( newsk <S2SV_ModStart> ; if ( <S2SV_ModEnd> opt ) inet_csk <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> -> opt_nflen + <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> opt -> opt_flen <S2SV_ModEnd> ; tcp_ca_openreq_child (
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,"<S2SV_StartBug> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt ) <S2SV_EndBug> <S2SV_StartBug> newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( newnp -> opt ) <S2SV_EndBug> <S2SV_StartBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + <S2SV_EndBug> <S2SV_StartBug> newnp -> opt -> opt_flen ) ; <S2SV_EndBug>"
1767,CWE-119,"<S2SV_StartBug> static int frame_max_bits ( const RATE_CONTROL * rc , const VP9_CONFIG * oxcf ) { <S2SV_EndBug> <S2SV_StartBug> int64_t max_bits = ( ( int64_t ) rc -> av_per_frame_bandwidth * <S2SV_EndBug> ( int64_t ) oxcf -> two_pass_vbrmax_section ) / 100 ; if ( max_bits < 0 ) max_bits = 0 ; else if ( max_bits > rc -> max_frame_bandwidth ) max_bits = rc -> max_frame_bandwidth ; return ( int ) max_bits ; }
","<S2SV_ModStart> rc , const VP9EncoderConfig <S2SV_ModEnd> * oxcf ) <S2SV_ModStart> ) rc -> avg_frame_bandwidth <S2SV_ModEnd> * ( int64_t
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static int frame_max_bits ( const RATE_CONTROL * rc , const VP9_CONFIG * oxcf ) { <S2SV_EndBug> <S2SV_StartBug> int64_t max_bits = ( ( int64_t ) rc -> av_per_frame_bandwidth * <S2SV_EndBug>"
3360,CWE-787,"static OPJ_BOOL opj_t2_encode_packet ( OPJ_UINT32 tileno , opj_tcd_tile_t * tile , opj_tcp_t * tcp , opj_pi_iterator_t * pi , OPJ_BYTE * dest , OPJ_UINT32 * p_data_written , OPJ_UINT32 length , opj_codestream_info_t * cstr_info , J2K_T2_MODE p_t2_mode , opj_event_mgr_t * p_manager ) { OPJ_UINT32 bandno , cblkno ; OPJ_BYTE * c = dest ; OPJ_UINT32 l_nb_bytes ; OPJ_UINT32 compno = pi -> compno ; OPJ_UINT32 resno = pi -> resno ; OPJ_UINT32 precno = pi -> precno ; OPJ_UINT32 layno = pi -> layno ; OPJ_UINT32 l_nb_blocks ; opj_tcd_band_t * band = 00 ; opj_tcd_cblk_enc_t * cblk = 00 ; opj_tcd_pass_t * pass = 00 ; opj_tcd_tilecomp_t * tilec = & tile -> comps [ compno ] ; opj_tcd_resolution_t * res = & tilec -> resolutions [ resno ] ; opj_bio_t * bio = 00 ; OPJ_BOOL packet_empty = OPJ_TRUE ; <S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_SOP ) { <S2SV_EndBug> c [ 0 ] = 255 ; c [ 1 ] = 145 ; c [ 2 ] = 0 ; c [ 3 ] = 4 ; # if 0 c [ 4 ] = ( tile -> packno % 65536 ) / 256 ; c [ 5 ] = ( tile -> packno % 65536 ) % 256 ; # else c [ 4 ] = ( tile -> packno >> 8 ) & 0xff ; c [ 5 ] = tile -> packno & 0xff ; # endif c += 6 ; length -= 6 ; } if ( ! layno ) { band = res -> bands ; for ( bandno = 0 ; bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; opj_tgt_reset ( prc -> incltree ) ; opj_tgt_reset ( prc -> imsbtree ) ; l_nb_blocks = prc -> cw * prc -> ch ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { cblk = & prc -> cblks . enc [ cblkno ] ; cblk -> numpasses = 0 ; opj_tgt_setvalue ( prc -> imsbtree , cblkno , band -> numbps - ( OPJ_INT32 ) cblk -> numbps ) ; } } } bio = opj_bio_create ( ) ; if ( ! bio ) { return OPJ_FALSE ; } opj_bio_init_enc ( bio , c , length ) ; band = res -> bands ; for ( bandno = 0 ; bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; cblkno ++ , ++ cblk ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! layer -> numpasses ) { continue ; } packet_empty = OPJ_FALSE ; break ; } if ( ! packet_empty ) { break ; } } opj_bio_write ( bio , packet_empty ? 0 : 1 , 1 ) ; band = res -> bands ; for ( bandno = 0 ; ! packet_empty && bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! cblk -> numpasses && layer -> numpasses ) { opj_tgt_setvalue ( prc -> incltree , cblkno , ( OPJ_INT32 ) layno ) ; } ++ cblk ; } cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; cblkno ++ ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; OPJ_UINT32 increment = 0 ; OPJ_UINT32 nump = 0 ; OPJ_UINT32 len = 0 , passno ; OPJ_UINT32 l_nb_passes ; if ( ! cblk -> numpasses ) { opj_tgt_encode ( bio , prc -> incltree , cblkno , ( OPJ_INT32 ) ( layno + 1 ) ) ; } else { opj_bio_write ( bio , layer -> numpasses != 0 , 1 ) ; } if ( ! layer -> numpasses ) { ++ cblk ; continue ; } if ( ! cblk -> numpasses ) { cblk -> numlenbits = 3 ; opj_tgt_encode ( bio , prc -> imsbtree , cblkno , 999 ) ; } opj_t2_putnumpasses ( bio , layer -> numpasses ) ; l_nb_passes = cblk -> numpasses + layer -> numpasses ; pass = cblk -> passes + cblk -> numpasses ; for ( passno = cblk -> numpasses ; passno < l_nb_passes ; ++ passno ) { ++ nump ; len += pass -> len ; if ( pass -> term || passno == ( cblk -> numpasses + layer -> numpasses ) - 1 ) { increment = ( OPJ_UINT32 ) opj_int_max ( ( OPJ_INT32 ) increment , opj_int_floorlog2 ( ( OPJ_INT32 ) len ) + 1 - ( ( OPJ_INT32 ) cblk -> numlenbits + opj_int_floorlog2 ( ( OPJ_INT32 ) nump ) ) ) ; len = 0 ; nump = 0 ; } ++ pass ; } opj_t2_putcommacode ( bio , ( OPJ_INT32 ) increment ) ; cblk -> numlenbits += increment ; pass = cblk -> passes + cblk -> numpasses ; for ( passno = cblk -> numpasses ; passno < l_nb_passes ; ++ passno ) { nump ++ ; len += pass -> len ; if ( pass -> term || passno == ( cblk -> numpasses + layer -> numpasses ) - 1 ) { opj_bio_write ( bio , ( OPJ_UINT32 ) len , cblk -> numlenbits + ( OPJ_UINT32 ) opj_int_floorlog2 ( ( OPJ_INT32 ) nump ) ) ; len = 0 ; nump = 0 ; } ++ pass ; } ++ cblk ; } } if ( ! opj_bio_flush ( bio ) ) { opj_bio_destroy ( bio ) ; return OPJ_FALSE ; } l_nb_bytes = ( OPJ_UINT32 ) opj_bio_numbytes ( bio ) ; c += l_nb_bytes ; length -= l_nb_bytes ; opj_bio_destroy ( bio ) ; <S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_EPH ) { <S2SV_EndBug> c [ 0 ] = 255 ; c [ 1 ] = 146 ; c += 2 ; length -= 2 ; } if ( cstr_info && cstr_info -> index_write ) { opj_packet_info_t * info_PK = & cstr_info -> tile [ tileno ] . packet [ cstr_info -> packno ] ; info_PK -> end_ph_pos = ( OPJ_INT32 ) ( c - dest ) ; } band = res -> bands ; for ( bandno = 0 ; ! packet_empty && bandno < res -> numbands ; bandno ++ , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! layer -> numpasses ) { ++ cblk ; continue ; } if ( layer -> len > length ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , layer -> len ) ; } return OPJ_FALSE ; } memcpy ( c , layer -> data , layer -> len ) ; cblk -> numpasses += layer -> numpasses ; c += layer -> len ; length -= layer -> len ; if ( cstr_info && cstr_info -> index_write ) { opj_packet_info_t * info_PK = & cstr_info -> tile [ tileno ] . packet [ cstr_info -> packno ] ; info_PK -> disto += layer -> disto ; if ( cstr_info -> D_max < info_PK -> disto ) { cstr_info -> D_max = info_PK -> disto ; } } ++ cblk ; } } assert ( c >= dest ) ; * p_data_written += ( OPJ_UINT32 ) ( c - dest ) ; return OPJ_TRUE ; }
","<S2SV_ModStart> J2K_CP_CSTY_SOP ) { if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 6 ) ; } return OPJ_FALSE ; } <S2SV_ModStart> J2K_CP_CSTY_EPH ) { if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 2 ) ; } return OPJ_FALSE ; }
",uclouvain@openjpeg/c535531f03369623b9b833ef41952c62257b507e,CVE-2017-14039,https://github.com/uclouvain/openjpeg/commit/c535531f03369623b9b833ef41952c62257b507e,2017-08-30T22:29Z,<S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_SOP ) { <S2SV_EndBug> <S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_EPH ) { <S2SV_EndBug>
1094,CWE-264,"static inline unsigned long zap_pmd_range ( struct mmu_gather * tlb , struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , struct zap_details * details ) { pmd_t * pmd ; unsigned long next ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( pmd_trans_huge ( * pmd ) ) { if ( next - addr != HPAGE_PMD_SIZE ) { VM_BUG_ON ( ! rwsem_is_locked ( & tlb -> mm -> mmap_sem ) ) ; split_huge_page_pmd ( vma -> vm_mm , pmd ) ; } else if ( zap_huge_pmd ( tlb , vma , pmd , addr ) ) <S2SV_StartBug> continue ; <S2SV_EndBug> } <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ; <S2SV_EndBug> cond_resched ( ) ; } while ( pmd ++ , addr = next , addr != end ) ; return addr ; }
","<S2SV_ModStart> addr ) ) goto next <S2SV_ModEnd> ; } if <S2SV_ModStart> } if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ) <S2SV_ModStart> pmd ) ) goto next <S2SV_ModEnd> ; next = <S2SV_ModStart> details ) ; next :
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z,"<S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ; <S2SV_EndBug>"
4810,CWE-000,"rfbBool SetFormatAndEncodings ( rfbClient * client ) { rfbSetPixelFormatMsg spf ; <S2SV_StartBug> char buf [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetEncodingsMsg * se = ( rfbSetEncodingsMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint32_t * encs = ( uint32_t * ) ( & buf [ sz_rfbSetEncodingsMsg ] ) ; <S2SV_EndBug> int len = 0 ; rfbBool requestCompressLevel = FALSE ; rfbBool requestQualityLevel = FALSE ; rfbBool requestLastRectEncoding = FALSE ; rfbClientProtocolExtension * e ; if ( ! SupportsClient2Server ( client , rfbSetPixelFormat ) ) return TRUE ; spf . type = rfbSetPixelFormat ; spf . pad1 = 0 ; spf . pad2 = 0 ; spf . format = client -> format ; spf . format . redMax = rfbClientSwap16IfLE ( spf . format . redMax ) ; spf . format . greenMax = rfbClientSwap16IfLE ( spf . format . greenMax ) ; spf . format . blueMax = rfbClientSwap16IfLE ( spf . format . blueMax ) ; if ( ! WriteToRFBServer ( client , ( char * ) & spf , sz_rfbSetPixelFormatMsg ) ) return FALSE ; if ( ! SupportsClient2Server ( client , rfbSetEncodings ) ) return TRUE ; se -> type = rfbSetEncodings ; se -> pad = 0 ; se -> nEncodings = 0 ; if ( client -> appData . encodingsString ) { const char * encStr = client -> appData . encodingsString ; int encStrLen ; do { const char * nextEncStr = strchr ( encStr , '<S2SV_blank>' ) ; if ( nextEncStr ) { encStrLen = nextEncStr - encStr ; nextEncStr ++ ; } else { encStrLen = strlen ( encStr ) ; } if ( strncasecmp ( encStr , ""raw"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRaw ) ; } else if ( strncasecmp ( encStr , ""copyrect"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCopyRect ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ # ifdef LIBVNCSERVER_HAVE_LIBJPEG } else if ( strncasecmp ( encStr , ""tight"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTight ) ; requestLastRectEncoding = TRUE ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; if ( client -> appData . enableJPEG ) requestQualityLevel = TRUE ; # endif # endif } else if ( strncasecmp ( encStr , ""hextile"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingHextile ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ } else if ( strncasecmp ( encStr , ""zlib"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlib ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; } else if ( strncasecmp ( encStr , ""zlibhex"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlibHex ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; } else if ( strncasecmp ( encStr , ""trle"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTRLE ) ; } else if ( strncasecmp ( encStr , ""zrle"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZRLE ) ; } else if ( strncasecmp ( encStr , ""zywrle"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZYWRLE ) ; requestQualityLevel = TRUE ; # endif } else if ( ( strncasecmp ( encStr , ""ultra"" , encStrLen ) == 0 ) || ( strncasecmp ( encStr , ""ultrazip"" , encStrLen ) == 0 ) ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltra ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltraZip ) ; } else if ( strncasecmp ( encStr , ""corre"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCoRRE ) ; } else if ( strncasecmp ( encStr , ""rre"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRRE ) ; } else { rfbClientLog ( ""Unknown<S2SV_blank>encoding<S2SV_blank>\'%.*s\'\\n"" , encStrLen , encStr ) ; } encStr = nextEncStr ; } while ( encStr && se -> nEncodings < MAX_ENCODINGS ) ; if ( se -> nEncodings < MAX_ENCODINGS && requestCompressLevel ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . compressLevel + rfbEncodingCompressLevel0 ) ; } if ( se -> nEncodings < MAX_ENCODINGS && requestQualityLevel ) { if ( client -> appData . qualityLevel < 0 || client -> appData . qualityLevel > 9 ) client -> appData . qualityLevel = 5 ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . qualityLevel + rfbEncodingQualityLevel0 ) ; } } else { if ( SameMachine ( client -> sock ) ) { rfbClientLog ( ""Same<S2SV_blank>machine:<S2SV_blank>preferring<S2SV_blank>raw<S2SV_blank>encoding\\n"" ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRaw ) ; } encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCopyRect ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ # ifdef LIBVNCSERVER_HAVE_LIBJPEG encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTight ) ; requestLastRectEncoding = TRUE ; # endif # endif encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingHextile ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlib ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZRLE ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZYWRLE ) ; # endif encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltra ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltraZip ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCoRRE ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRRE ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . compressLevel + rfbEncodingCompressLevel0 ) ; } else { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCompressLevel1 ) ; } if ( client -> appData . enableJPEG ) { if ( client -> appData . qualityLevel < 0 || client -> appData . qualityLevel > 9 ) client -> appData . qualityLevel = 5 ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . qualityLevel + rfbEncodingQualityLevel0 ) ; } } if ( client -> appData . useRemoteCursor ) { if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingXCursor ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRichCursor ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingPointerPos ) ; } if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingKeyboardLedState ) ; if ( se -> nEncodings < MAX_ENCODINGS && client -> canHandleNewFBSize ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingNewFBSize ) ; if ( se -> nEncodings < MAX_ENCODINGS && requestLastRectEncoding ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingLastRect ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingSupportedMessages ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingSupportedEncodings ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingServerIdentity ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingXvp ) ; for ( e = rfbClientExtensions ; e ; e = e -> next ) if ( e -> encodings ) { int * enc ; for ( enc = e -> encodings ; * enc ; enc ++ ) if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( * enc ) ; } len = sz_rfbSetEncodingsMsg + se -> nEncodings * 4 ; se -> nEncodings = rfbClientSwap16IfLE ( se -> nEncodings ) ; <S2SV_StartBug> if ( ! WriteToRFBServer ( client , buf , len ) ) return FALSE ; <S2SV_EndBug> return TRUE ; }
","<S2SV_ModStart> rfbSetPixelFormatMsg spf ; union { char bytes <S2SV_ModEnd> [ sz_rfbSetEncodingsMsg + <S2SV_ModStart> ] ; rfbSetEncodingsMsg msg ; } buf ; rfbSetEncodingsMsg * se = & buf . msg <S2SV_ModEnd> ; uint32_t * <S2SV_ModStart> ( & buf . bytes <S2SV_ModStart> client , buf . bytes
",LibVNC@libvncserver/23e5cbe6b090d7f22982aee909a6a618174d3c2d,CVE-2020-14399,https://github.com/LibVNC/libvncserver/commit/23e5cbe6b090d7f22982aee909a6a618174d3c2d,2020-06-17T16:15Z,"<S2SV_StartBug> char buf [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetEncodingsMsg * se = ( rfbSetEncodingsMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint32_t * encs = ( uint32_t * ) ( & buf [ sz_rfbSetEncodingsMsg ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! WriteToRFBServer ( client , buf , len ) ) return FALSE ; <S2SV_EndBug>"
2479,CWE-120,"static int mwifiex_update_vs_ie ( const u8 * ies , int ies_len , struct mwifiex_ie * * ie_ptr , u16 mask , unsigned int oui , u8 oui_type ) { struct ieee_types_header * vs_ie ; struct mwifiex_ie * ie = * ie_ptr ; const u8 * vendor_ie ; vendor_ie = cfg80211_find_vendor_ie ( oui , oui_type , ies , ies_len ) ; if ( vendor_ie ) { if ( ! * ie_ptr ) { * ie_ptr = kzalloc ( sizeof ( struct mwifiex_ie ) , GFP_KERNEL ) ; if ( ! * ie_ptr ) return - ENOMEM ; ie = * ie_ptr ; } vs_ie = ( struct ieee_types_header * ) vendor_ie ; <S2SV_StartBug> memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , <S2SV_EndBug> vs_ie , vs_ie -> len + 2 ) ; le16_unaligned_add_cpu ( & ie -> ie_length , vs_ie -> len + 2 ) ; ie -> mgmt_subtype_mask = cpu_to_le16 ( mask ) ; ie -> ie_index = cpu_to_le16 ( MWIFIEX_AUTO_IDX_MASK ) ; } * ie_ptr = ie ; return 0 ; }
","<S2SV_ModStart> ) vendor_ie ; if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ;
",torvalds@linux/7caac62ed598a196d6ddf8d9c121e12e082cac3a,CVE-2019-14814,https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a,2019-09-20T19:15Z,"<S2SV_StartBug> memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , <S2SV_EndBug>"
4158,CWE-20,"int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { <S2SV_StartBug> int namelen = strlen ( name ) ; <S2SV_EndBug> int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; <S2SV_StartBug> data ++ ; <S2SV_EndBug> for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; <S2SV_StartBug> if ( ! size ) <S2SV_EndBug> break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; <S2SV_StartBug> if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { <S2SV_EndBug> switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : <S2SV_StartBug> snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; <S2SV_EndBug> break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
","<S2SV_ModStart> dst_size ) { GetByteContext gb <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( data >= data_end <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; bytestream2_init ( & gb , data , data_end - <S2SV_ModEnd> data ) ; <S2SV_ModStart> data ) ; return amf_get_field_value2 ( & gb <S2SV_ModEnd> , name , <S2SV_ModStart> , name , <S2SV_ModEnd> dst , dst_size <S2SV_ModStart> dst , dst_size ) <S2SV_ModEnd> ; } <S2SV_null>
",FFmpeg@FFmpeg/ffcc82219cef0928bed2d558b19ef6ea35634130,CVE-2017-11665,https://github.com/FFmpeg/FFmpeg/commit/ffcc82219cef0928bed2d558b19ef6ea35634130,2017-07-27T12:29Z,"<S2SV_StartBug> int namelen = strlen ( name ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> data ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! size ) <S2SV_EndBug> <S2SV_StartBug> if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; <S2SV_EndBug>"
1653,CWE-119,"<S2SV_StartBug> static void prob_diff_update ( const vp9_tree_index * tree , <S2SV_EndBug> <S2SV_StartBug> vp9_prob probs [ ] , <S2SV_EndBug> const unsigned int counts [ ] , <S2SV_StartBug> int n , vp9_writer * w ) { <S2SV_EndBug> int i ; unsigned int branch_ct [ 32 ] [ 2 ] ; assert ( n <= 32 ) ; vp9_tree_probs_from_distribution ( tree , branch_ct , counts ) ; for ( i = 0 ; i < n - 1 ; ++ i ) vp9_cond_prob_diff_update ( w , & probs [ i ] , branch_ct [ i ] ) ; }
","<S2SV_ModStart> prob_diff_update ( const vpx_tree_index <S2SV_ModEnd> * tree , <S2SV_ModStart> * tree , vpx_prob <S2SV_ModEnd> probs [ ] <S2SV_ModStart> int n , vpx_writer <S2SV_ModEnd> * w )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static void prob_diff_update ( const vp9_tree_index * tree , <S2SV_EndBug> <S2SV_StartBug> vp9_prob probs [ ] , <S2SV_EndBug> <S2SV_StartBug> int n , vp9_writer * w ) { <S2SV_EndBug>"
801,CWE-269,"static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( ! arg_shell_none && ( strcmp ( cfg . shell , ""/usr/bin/zsh"" ) == 0 || strcmp ( cfg . shell , ""/bin/zsh"" ) == 0 ) ) { if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <S2SV_StartBug> if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ; <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( ""touch"" , fname ) ; } free ( fname ) ; } else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <S2SV_StartBug> if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) ; <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( ""touch"" , fname ) ; } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <S2SV_StartBug> if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) ; <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ; } free ( fname ) ; } }
","<S2SV_ModStart> ; if ( is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> 0 ) { copy_file_as_user <S2SV_ModEnd> ( ""/etc/skel/.zshrc"" , <S2SV_ModStart> ; if ( is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> 0 ) { copy_file_as_user <S2SV_ModEnd> ( ""/etc/skel/.cshrc"" , <S2SV_ModStart> ; if ( is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> 0 ) { copy_file_as_user <S2SV_ModEnd> ( ""/etc/skel/.bashrc"" ,
",netblue30@firejail/38d418505e9ee2d326557e5639e8da49c298858f,CVE-2017-5940,https://github.com/netblue30/firejail/commit/38d418505e9ee2d326557e5639e8da49c298858f,2017-02-09T18:59Z,"<S2SV_StartBug> if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) ; <S2SV_EndBug>"
3601,CWE-399,"static struct kioctx * ioctx_alloc ( unsigned nr_events ) { struct mm_struct * mm = current -> mm ; struct kioctx * ctx ; int err = - ENOMEM ; nr_events = max ( nr_events , num_possible_cpus ( ) * 4 ) ; nr_events *= 2 ; if ( ( nr_events > ( 0x10000000U / sizeof ( struct io_event ) ) ) || ( nr_events > ( 0x10000000U / sizeof ( struct kiocb ) ) ) ) { pr_debug ( ""ENOMEM:<S2SV_blank>nr_events<S2SV_blank>too<S2SV_blank>high\\n"" ) ; return ERR_PTR ( - EINVAL ) ; } if ( ! nr_events || ( unsigned long ) nr_events > ( aio_max_nr * 2UL ) ) return ERR_PTR ( - EAGAIN ) ; ctx = kmem_cache_zalloc ( kioctx_cachep , GFP_KERNEL ) ; if ( ! ctx ) return ERR_PTR ( - ENOMEM ) ; ctx -> max_reqs = nr_events ; if ( percpu_ref_init ( & ctx -> users , free_ioctx_users ) ) goto err ; if ( percpu_ref_init ( & ctx -> reqs , free_ioctx_reqs ) ) goto err ; spin_lock_init ( & ctx -> ctx_lock ) ; spin_lock_init ( & ctx -> completion_lock ) ; mutex_init ( & ctx -> ring_lock ) ; init_waitqueue_head ( & ctx -> wait ) ; INIT_LIST_HEAD ( & ctx -> active_reqs ) ; ctx -> cpu = alloc_percpu ( struct kioctx_cpu ) ; if ( ! ctx -> cpu ) goto err ; if ( aio_setup_ring ( ctx ) < 0 ) goto err ; atomic_set ( & ctx -> reqs_available , ctx -> nr_events - 1 ) ; ctx -> req_batch = ( ctx -> nr_events - 1 ) / ( num_possible_cpus ( ) * 4 ) ; if ( ctx -> req_batch < 1 ) ctx -> req_batch = 1 ; spin_lock ( & aio_nr_lock ) ; if ( aio_nr + nr_events > ( aio_max_nr * 2UL ) || aio_nr + nr_events < aio_nr ) { spin_unlock ( & aio_nr_lock ) ; err = - EAGAIN ; goto err ; } aio_nr += ctx -> max_reqs ; spin_unlock ( & aio_nr_lock ) ; percpu_ref_get ( & ctx -> users ) ; err = ioctx_add_table ( ctx , mm ) ; if ( err ) goto err_cleanup ; pr_debug ( ""allocated<S2SV_blank>ioctx<S2SV_blank>%p[%ld]:<S2SV_blank>mm=%p<S2SV_blank>mask=0x%x\\n"" , ctx , ctx -> user_id , mm , ctx -> nr_events ) ; return ctx ; err_cleanup : aio_nr_sub ( ctx -> max_reqs ) ; err : <S2SV_StartBug> aio_free_ring ( ctx ) ; <S2SV_EndBug> free_percpu ( ctx -> cpu ) ; free_percpu ( ctx -> reqs . pcpu_count ) ; free_percpu ( ctx -> users . pcpu_count ) ; kmem_cache_free ( kioctx_cachep , ctx ) ; pr_debug ( ""error<S2SV_blank>allocating<S2SV_blank>ioctx<S2SV_blank>%d\\n"" , err ) ; return ERR_PTR ( err ) ; }
","<S2SV_ModStart> ; err : <S2SV_ModEnd> free_percpu ( ctx
",torvalds@linux/d558023207e008a4476a3b7bb8706b2a2bf5d84f,CVE-2013-7348,https://github.com/torvalds/linux/commit/d558023207e008a4476a3b7bb8706b2a2bf5d84f,2014-04-01T06:35Z,<S2SV_StartBug> aio_free_ring ( ctx ) ; <S2SV_EndBug>
1097,CWE-264,"static int walk_pmd_range ( pud_t * pud , unsigned long addr , unsigned long end , struct mm_walk * walk ) { pmd_t * pmd ; unsigned long next ; int err = 0 ; pmd = pmd_offset ( pud , addr ) ; do { again : next = pmd_addr_end ( addr , end ) ; if ( pmd_none ( * pmd ) ) { if ( walk -> pte_hole ) err = walk -> pte_hole ( addr , next , walk ) ; if ( err ) break ; continue ; } if ( walk -> pmd_entry ) err = walk -> pmd_entry ( pmd , addr , next , walk ) ; if ( err ) break ; if ( ! walk -> pte_entry ) continue ; split_huge_page_pmd ( walk -> mm , pmd ) ; <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> goto again ; err = walk_pte_range ( pmd , addr , next , walk ) ; if ( err ) break ; } while ( pmd ++ , addr = next , addr != end ) ; return err ; }
","<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z,<S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug>
928,CWE-119,"interval * PGTYPESinterval_from_asc ( char * str , char * * endptr ) { interval * result = NULL ; fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; tm -> tm_year = 0 ; tm -> tm_mon = 0 ; tm -> tm_mday = 0 ; tm -> tm_hour = 0 ; tm -> tm_min = 0 ; tm -> tm_sec = 0 ; fsec = 0 ; <S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> { errno = PGTYPES_INTVL_BAD_INTERVAL ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } <S2SV_StartBug> if ( tm2interval ( tm , fsec , result ) != 0 ) <S2SV_EndBug> { errno = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } errno = 0 ; return result ; }
","<S2SV_ModStart> ( str ) > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA <S2SV_ModEnd> ) { errno <S2SV_ModStart> = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } if ( tm2interval ( tm , fsec , result ) != 0 <S2SV_ModEnd> ) { errno <S2SV_ModStart> = PGTYPES_INTVL_BAD_INTERVAL ; <S2SV_ModEnd> free ( result <S2SV_ModStart> NULL ; } <S2SV_ModEnd> errno = 0
",postgres@postgres/4318daecc959886d001a6e79c6ea853e8b1dfb4b,CVE-2014-0063,https://github.com/postgres/postgres/commit/4318daecc959886d001a6e79c6ea853e8b1dfb4b,2014-03-31T14:58Z,"<S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( tm2interval ( tm , fsec , result ) != 0 ) <S2SV_EndBug>"
1478,CWE-119,"void vp8_setup_key_frame ( VP8_COMP * cpi ) { vp8_default_coef_probs ( & cpi -> common ) ; <S2SV_StartBug> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> { int flag [ 2 ] = { 1 , 1 } ; vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cpi -> common . fc . mvc , flag ) ; } <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ; if ( cpi -> auto_gold ) cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; else cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; cpi -> common . refresh_golden_frame = 1 ; cpi -> common . refresh_alt_ref_frame = 1 ; }
","<S2SV_ModStart> common ) ; memcpy <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ; } memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug>"
214,CWE-787,"void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , ""<S2SV_blank>Page(%d)\\n"" , page ) ; else fprintf ( out , ""\\n"" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , ""%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n"" ""%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n"" , pdf -> name , pdf -> name ) ; fprintf ( out , ""----------<S2SV_blank>%s<S2SV_blank>----------\\n"" ""Versions:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , ""Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n"" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , ""%s:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }
","<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,<S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug>
3783,CWE-416,"void comps_objmrtree_unite ( COMPS_ObjMRTree * rt1 , COMPS_ObjMRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; COMPS_ObjListIt * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_ObjMRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_objmrtree_set ( rt1 , pair -> key , it2 -> comps_obj ) ; } if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
","<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair <S2SV_ModStart> it ) ; <S2SV_ModEnd> for ( it
",rpm-software-management@libcomps/e3a5d056633677959ad924a51758876d415e7046,CVE-2019-3817,https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046,2019-03-27T13:29Z,<S2SV_StartBug> char added ; <S2SV_EndBug> <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug>
3523,CWE-200,"static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ; <S2SV_StartBug> spin_lock_irq ( & tu -> qlock ) ; <S2SV_EndBug> while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) { err = - EAGAIN ; goto _error ; } set_current_state ( TASK_INTERRUPTIBLE ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> schedule ( ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - ENODEV ; goto _error ; } if ( signal_pending ( current ) ) { err = - ERESTARTSYS ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> if ( tu -> tread ) { if ( copy_to_user ( buffer , & tu -> tqueue [ qhead ] , sizeof ( struct snd_timer_tread ) ) ) err = - EFAULT ; } else { if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ; } <S2SV_StartBug> mutex_unlock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; if ( err < 0 ) goto _error ; result += unit ; buffer += unit ; } _error : spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> return result > 0 ? result : err ; <S2SV_EndBug> }
","<S2SV_ModStart> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <S2SV_ModEnd> ) ; spin_lock_irq <S2SV_ModStart> qlock ) ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> spin_lock_irq ( & <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ;
",torvalds@linux/d11662f4f798b50d8c8743f433842c3e40fe3378,CVE-2017-1000380,https://github.com/torvalds/linux/commit/d11662f4f798b50d8c8743f433842c3e40fe3378,2017-06-17T18:29Z,<S2SV_StartBug> spin_lock_irq ( & tu -> qlock ) ; <S2SV_EndBug> <S2SV_StartBug> schedule ( ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> <S2SV_StartBug> return result > 0 ? result : err ; <S2SV_EndBug>
726,CWE-787,"GPMF_ERR IsValidSize ( GPMF_stream * ms , uint32_t size ) { if ( ms ) { <S2SV_StartBug> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <S2SV_EndBug> if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ; if ( size + 2 <= nestsize ) return GPMF_OK ; } return GPMF_ERROR_BAD_STRUCTURE ; }
","<S2SV_ModStart> ms ) { uint32_t <S2SV_ModEnd> nestsize = ( <S2SV_ModStart> nestsize = ( uint32_t <S2SV_ModEnd> ) ms ->
",gopro@gpmf-parser/341f12cd5b97ab419e53853ca00176457c9f1681,CVE-2019-15148,https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681,2019-08-18T19:15Z,<S2SV_StartBug> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <S2SV_EndBug>
451,CWE-787,"void avcodec_align_dimensions2 ( AVCodecContext * s , int * width , int * height , int linesize_align [ AV_NUM_DATA_POINTERS ] ) { int i ; int w_align = 1 ; int h_align = 1 ; AVPixFmtDescriptor const * desc = av_pix_fmt_desc_get ( s -> pix_fmt ) ; if ( desc ) { w_align = 1 << desc -> log2_chroma_w ; h_align = 1 << desc -> log2_chroma_h ; } switch ( s -> pix_fmt ) { case AV_PIX_FMT_YUV420P : case AV_PIX_FMT_YUYV422 : case AV_PIX_FMT_YVYU422 : case AV_PIX_FMT_UYVY422 : case AV_PIX_FMT_YUV422P : case AV_PIX_FMT_YUV440P : case AV_PIX_FMT_YUV444P : case AV_PIX_FMT_GBRP : case AV_PIX_FMT_GBRAP : case AV_PIX_FMT_GRAY8 : case AV_PIX_FMT_GRAY16BE : case AV_PIX_FMT_GRAY16LE : case AV_PIX_FMT_YUVJ420P : case AV_PIX_FMT_YUVJ422P : case AV_PIX_FMT_YUVJ440P : case AV_PIX_FMT_YUVJ444P : case AV_PIX_FMT_YUVA420P : case AV_PIX_FMT_YUVA422P : case AV_PIX_FMT_YUVA444P : case AV_PIX_FMT_YUV420P9LE : case AV_PIX_FMT_YUV420P9BE : case AV_PIX_FMT_YUV420P10LE : case AV_PIX_FMT_YUV420P10BE : case AV_PIX_FMT_YUV420P12LE : case AV_PIX_FMT_YUV420P12BE : case AV_PIX_FMT_YUV420P14LE : case AV_PIX_FMT_YUV420P14BE : case AV_PIX_FMT_YUV420P16LE : case AV_PIX_FMT_YUV420P16BE : case AV_PIX_FMT_YUVA420P9LE : case AV_PIX_FMT_YUVA420P9BE : case AV_PIX_FMT_YUVA420P10LE : case AV_PIX_FMT_YUVA420P10BE : case AV_PIX_FMT_YUVA420P16LE : case AV_PIX_FMT_YUVA420P16BE : case AV_PIX_FMT_YUV422P9LE : case AV_PIX_FMT_YUV422P9BE : case AV_PIX_FMT_YUV422P10LE : case AV_PIX_FMT_YUV422P10BE : case AV_PIX_FMT_YUV422P12LE : case AV_PIX_FMT_YUV422P12BE : case AV_PIX_FMT_YUV422P14LE : case AV_PIX_FMT_YUV422P14BE : case AV_PIX_FMT_YUV422P16LE : case AV_PIX_FMT_YUV422P16BE : case AV_PIX_FMT_YUVA422P9LE : case AV_PIX_FMT_YUVA422P9BE : case AV_PIX_FMT_YUVA422P10LE : case AV_PIX_FMT_YUVA422P10BE : case AV_PIX_FMT_YUVA422P16LE : case AV_PIX_FMT_YUVA422P16BE : case AV_PIX_FMT_YUV440P10LE : case AV_PIX_FMT_YUV440P10BE : case AV_PIX_FMT_YUV440P12LE : case AV_PIX_FMT_YUV440P12BE : case AV_PIX_FMT_YUV444P9LE : case AV_PIX_FMT_YUV444P9BE : case AV_PIX_FMT_YUV444P10LE : case AV_PIX_FMT_YUV444P10BE : case AV_PIX_FMT_YUV444P12LE : case AV_PIX_FMT_YUV444P12BE : case AV_PIX_FMT_YUV444P14LE : case AV_PIX_FMT_YUV444P14BE : case AV_PIX_FMT_YUV444P16LE : case AV_PIX_FMT_YUV444P16BE : case AV_PIX_FMT_YUVA444P9LE : case AV_PIX_FMT_YUVA444P9BE : case AV_PIX_FMT_YUVA444P10LE : case AV_PIX_FMT_YUVA444P10BE : case AV_PIX_FMT_YUVA444P16LE : case AV_PIX_FMT_YUVA444P16BE : case AV_PIX_FMT_GBRP9LE : case AV_PIX_FMT_GBRP9BE : case AV_PIX_FMT_GBRP10LE : case AV_PIX_FMT_GBRP10BE : case AV_PIX_FMT_GBRP12LE : case AV_PIX_FMT_GBRP12BE : case AV_PIX_FMT_GBRP14LE : case AV_PIX_FMT_GBRP14BE : case AV_PIX_FMT_GBRP16LE : case AV_PIX_FMT_GBRP16BE : case AV_PIX_FMT_GBRAP12LE : case AV_PIX_FMT_GBRAP12BE : case AV_PIX_FMT_GBRAP16LE : case AV_PIX_FMT_GBRAP16BE : w_align = 16 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV411P : case AV_PIX_FMT_YUVJ411P : case AV_PIX_FMT_UYYVYY411 : w_align = 32 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV410P : if ( s -> codec_id == AV_CODEC_ID_SVQ1 ) { w_align = 64 ; h_align = 64 ; } break ; case AV_PIX_FMT_RGB555 : if ( s -> codec_id == AV_CODEC_ID_RPZA ) { w_align = 4 ; h_align = 4 ; } <S2SV_StartBug> break ; <S2SV_EndBug> case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; } <S2SV_StartBug> if ( s -> codec_id == AV_CODEC_ID_JV ) { <S2SV_EndBug> w_align = 8 ; h_align = 8 ; } break ; case AV_PIX_FMT_BGR24 : if ( ( s -> codec_id == AV_CODEC_ID_MSZH ) || ( s -> codec_id == AV_CODEC_ID_ZLIB ) ) { w_align = 4 ; h_align = 4 ; } break ; case AV_PIX_FMT_RGB24 : if ( s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; } break ; default : break ; } if ( s -> codec_id == AV_CODEC_ID_IFF_ILBM ) { w_align = FFMAX ( w_align , 8 ) ; } * width = FFALIGN ( * width , w_align ) ; * height = FFALIGN ( * height , h_align ) ; if ( s -> codec_id == AV_CODEC_ID_H264 || s -> lowres ) { * height += 2 ; * width = FFMAX ( * width , 32 ) ; } for ( i = 0 ; i < 4 ; i ++ ) linesize_align [ i ] = STRIDE_ALIGN ; }
","<S2SV_ModStart> 4 ; } if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> codec_id == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO
",FFmpeg@FFmpeg/2080bc33717955a0e4268e738acf8c1eeddbf8cb,CVE-2017-7865,https://github.com/FFmpeg/FFmpeg/commit/2080bc33717955a0e4268e738acf8c1eeddbf8cb,2017-04-14T04:59Z,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> codec_id == AV_CODEC_ID_JV ) { <S2SV_EndBug>
5052,CWE-189,"Datum txid_current_snapshot ( PG_FUNCTION_ARGS ) { TxidSnapshot * snap ; uint32 nxip , i , size ; TxidEpoch state ; Snapshot cur ; cur = GetActiveSnapshot ( ) ; if ( cur == NULL ) elog ( ERROR , ""no<S2SV_blank>active<S2SV_blank>snapshot<S2SV_blank>set"" ) ; <S2SV_StartBug> load_xid_epoch ( & state ) ; <S2SV_EndBug> nxip = cur -> xcnt ; size = TXID_SNAPSHOT_SIZE ( nxip ) ; snap = palloc ( size ) ; SET_VARSIZE ( snap , size ) ; snap -> xmin = convert_xid ( cur -> xmin , & state ) ; snap -> xmax = convert_xid ( cur -> xmax , & state ) ; snap -> nxip = nxip ; for ( i = 0 ; i < nxip ; i ++ ) snap -> xip [ i ] = convert_xid ( cur -> xip [ i ] , & state ) ; sort_snapshot ( snap ) ; PG_RETURN_POINTER ( snap ) ; }
","<S2SV_ModStart> ( & state ) ; StaticAssertStmt ( MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP , ""possible<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>txid_current_snapshot()""
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,<S2SV_StartBug> load_xid_epoch ( & state ) ; <S2SV_EndBug>
2924,CWE-200,"static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ; int number_extensionss = 0 ; MagickBooleanType status ; RectangleInfo page ; register ssize_t i ; register unsigned char * p ; size_t delay , dispose , duration , global_colors , image_count , iterations , one ; ssize_t count , opacity ; unsigned char background , c , flag , * global_colormap , buffer [ 257 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 6 , buffer ) ; if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) buffer , ""GIF87"" , 5 ) != 0 ) && ( LocaleNCompare ( ( char * ) buffer , ""GIF89"" , 5 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; page . width = ReadBlobLSBShort ( image ) ; page . height = ReadBlobLSBShort ( image ) ; flag = ( unsigned char ) ReadBlobByte ( image ) ; background = ( unsigned char ) ReadBlobByte ( image ) ; c = ( unsigned char ) ReadBlobByte ( image ) ; one = 1 ; global_colors = one << ( ( ( size_t ) flag & 0x07 ) + 1 ) ; global_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( global_colors , 256 ) , 3UL * sizeof ( * global_colormap ) ) ; if ( global_colormap == ( unsigned char * ) NULL ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) { count = ReadBlob ( image , ( size_t ) ( 3 * global_colors ) , global_colormap ) ; if ( count != ( ssize_t ) ( 3 * global_colors ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } delay = 0 ; dispose = 0 ; duration = 0 ; iterations = 1 ; opacity = ( - 1 ) ; image_count = 0 ; meta_image = AcquireImage ( image_info , exception ) ; for ( ; ; ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) break ; if ( c == ( unsigned char ) ';' ) break ; if ( c == ( unsigned char ) '!' ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadExtensionBlock"" ) ; } switch ( c ) { case 0xf9 : { while ( ReadBlobBlock ( image , buffer ) != 0 ) ; dispose = ( size_t ) ( buffer [ 0 ] >> 2 ) ; delay = ( size_t ) ( ( buffer [ 2 ] << 8 ) | buffer [ 1 ] ) ; if ( ( ssize_t ) ( buffer [ 0 ] & 0x01 ) == 0x01 ) opacity = ( ssize_t ) buffer [ 3 ] ; break ; } case 0xfe : { char * comments ; size_t length ; comments = AcquireString ( ( char * ) NULL ) ; for ( length = 0 ; ; length += count ) { count = ( ssize_t ) ReadBlobBlock ( image , buffer ) ; if ( count == 0 ) break ; buffer [ count ] = '\\0' ; ( void ) ConcatenateString ( & comments , ( const char * ) buffer ) ; } ( void ) SetImageProperty ( meta_image , ""comment"" , comments , exception ) ; comments = DestroyString ( comments ) ; break ; } case 0xff : { MagickBooleanType loop ; loop = MagickFalse ; if ( ReadBlobBlock ( image , buffer ) != 0 ) loop = LocaleNCompare ( ( char * ) buffer , ""NETSCAPE2.0"" , 11 ) == 0 ? MagickTrue : MagickFalse ; if ( loop != MagickFalse ) { while ( ReadBlobBlock ( image , buffer ) != 0 ) iterations = ( size_t ) ( ( buffer [ 2 ] << 8 ) | buffer [ 1 ] ) ; break ; } else { char name [ MagickPathExtent ] ; int block_length , info_length , reserved_length ; MagickBooleanType i8bim , icc , iptc , magick ; StringInfo * profile ; unsigned char * info ; icc = LocaleNCompare ( ( char * ) buffer , ""ICCRGBG1012"" , 11 ) == 0 ? MagickTrue : MagickFalse ; magick = LocaleNCompare ( ( char * ) buffer , ""ImageMagick"" , 11 ) == 0 ? MagickTrue : MagickFalse ; i8bim = LocaleNCompare ( ( char * ) buffer , ""MGK8BIM0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; iptc = LocaleNCompare ( ( char * ) buffer , ""MGKIPTC0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; number_extensionss ++ ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Reading<S2SV_blank>GIF<S2SV_blank>application<S2SV_blank>extension"" ) ; info = ( unsigned char * ) AcquireQuantumMemory ( 255UL , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) { meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } reserved_length = 255 ; for ( info_length = 0 ; ; ) { block_length = ( int ) ReadBlobBlock ( image , & info [ info_length ] ) ; if ( block_length == 0 ) break ; info_length += block_length ; if ( info_length > ( reserved_length - 255 ) ) { reserved_length += 4096 ; info = ( unsigned char * ) ResizeQuantumMemory ( info , ( size_t ) reserved_length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) { meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } } } profile = BlobToStringInfo ( info , ( size_t ) info_length ) ; if ( profile == ( StringInfo * ) NULL ) { meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } if ( i8bim != MagickFalse ) ( void ) CopyMagickString ( name , ""8bim"" , sizeof ( name ) ) ; else if ( icc != MagickFalse ) ( void ) CopyMagickString ( name , ""icc"" , sizeof ( name ) ) ; else if ( iptc != MagickFalse ) ( void ) CopyMagickString ( name , ""iptc"" , sizeof ( name ) ) ; else if ( magick != MagickFalse ) { ( void ) CopyMagickString ( name , ""magick"" , sizeof ( name ) ) ; meta_image -> gamma = StringToDouble ( ( char * ) info + 6 , ( char * * ) NULL ) ; } else ( void ) FormatLocaleString ( name , sizeof ( name ) , ""gif:%.11s"" , buffer ) ; info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; if ( magick == MagickFalse ) ( void ) SetImageProfile ( meta_image , name , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>profile<S2SV_blank>name=%s"" , name ) ; } break ; } default : { while ( ReadBlobBlock ( image , buffer ) != 0 ) ; break ; } } } if ( c != ( unsigned char ) ',' ) continue ; if ( image_count != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; } image_count ++ ; meta_image -> scene = image -> scene ; ( void ) CloneImageProperties ( image , meta_image ) ; DestroyImageProperties ( meta_image ) ; ( void ) CloneImageProfiles ( image , meta_image ) ; DestroyImageProfiles ( meta_image ) ; image -> storage_class = PseudoClass ; image -> compression = LZWCompression ; page . x = ( ssize_t ) ReadBlobLSBShort ( image ) ; page . y = ( ssize_t ) ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; image -> depth = 8 ; flag = ( unsigned char ) ReadBlobByte ( image ) ; image -> interlace = BitSet ( ( int ) flag , 0x40 ) != 0 ? GIFInterlace : NoInterlace ; image -> colors = BitSet ( ( int ) flag , 0x80 ) == 0 ? global_colors : one << ( ( size_t ) ( flag & 0x07 ) + 1 ) ; if ( opacity >= ( ssize_t ) image -> colors ) opacity = ( - 1 ) ; image -> page . width = page . width ; image -> page . height = page . height ; image -> page . y = page . y ; image -> page . x = page . x ; image -> delay = delay ; image -> ticks_per_second = 100 ; image -> dispose = ( DisposeType ) dispose ; image -> iterations = iterations ; image -> alpha_trait = opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait ; delay = 0 ; dispose = 0 ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; } if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } if ( BitSet ( ( int ) flag , 0x80 ) == 0 ) { p = global_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( double ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( double ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ( double ) ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) { image -> colormap [ i ] . alpha = ( double ) TransparentAlpha ; image -> transparent_color = image -> colormap [ opacity ] ; } } image -> background_color = image -> colormap [ MagickMin ( ( ssize_t ) background , ( ssize_t ) image -> colors - 1 ) ] ; } else { unsigned char * colormap ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , 3 * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } count = ReadBlob ( image , ( 3 * image -> colors ) * sizeof ( * colormap ) , colormap ) ; if ( count != ( ssize_t ) ( 3 * image -> colors ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( double ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( double ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ( double ) ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) image -> colormap [ i ] . alpha = ( double ) TransparentAlpha ; } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } if ( image -> gamma == 1.0 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) if ( IsPixelInfoGray ( image -> colormap + i ) == MagickFalse ) break ; ( void ) SetImageColorspace ( image , i == ( ssize_t ) image -> colors ? GRAYColorspace : RGBColorspace , exception ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image_info -> ping != MagickFalse ) status = PingGIFImage ( image , exception ) ; else status = DecodeImage ( image , opacity , exception ) ; if ( ( image_info -> ping == MagickFalse ) && ( status == MagickFalse ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } duration += image -> delay * image -> iterations ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; opacity = ( - 1 ) ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) image -> scene - 1 , image -> scene ) ; if ( status == MagickFalse ) break ; } image -> duration = duration ; meta_image = DestroyImage ( meta_image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap )
",ImageMagick@ImageMagick/9fd10cf630832b36a588c1545d8736539b2f1fb5,CVE-2017-15277,https://github.com/ImageMagick/ImageMagick/commit/9fd10cf630832b36a588c1545d8736539b2f1fb5,2017-10-12T08:29Z,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug>"
7938,CWE-476,"GF_Err MergeTrack ( GF_TrackBox * trak , GF_TrackFragmentBox * traf , GF_MovieFragmentBox * moof_box , u64 moof_offset , s32 compressed_diff , u64 * cumulated_offset , Bool is_first_merge ) { u32 i , j , chunk_size , track_num ; u64 base_offset , data_offset , traf_duration ; u32 def_duration , DescIndex , def_size , def_flags ; u32 duration , size , flags , prev_trun_data_offset , sample_index ; u8 pad , sync ; u16 degr ; Bool first_samp_in_traf = GF_TRUE ; Bool store_traf_map = GF_FALSE ; u8 * moof_template = NULL ; u32 moof_template_size = 0 ; Bool is_seg_start = GF_FALSE ; u64 seg_start = 0 , sidx_start = 0 , sidx_end = 0 , frag_start = 0 , last_dts = 0 ; GF_TrackFragmentRunBox * trun ; GF_TrunEntry * ent ; # ifdef GF_ENABLE_CTRN GF_TrackFragmentBox * traf_ref = NULL ; # endif GF_Err stbl_AppendTime ( GF_SampleTableBox * stbl , u32 duration , u32 nb_pack ) ; GF_Err stbl_AppendSize ( GF_SampleTableBox * stbl , u32 size , u32 nb_pack ) ; GF_Err stbl_AppendChunk ( GF_SampleTableBox * stbl , u64 offset ) ; GF_Err stbl_AppendSampleToChunk ( GF_SampleTableBox * stbl , u32 DescIndex , u32 samplesInChunk ) ; GF_Err stbl_AppendCTSOffset ( GF_SampleTableBox * stbl , s32 CTSOffset ) ; GF_Err stbl_AppendRAP ( GF_SampleTableBox * stbl , u8 isRap ) ; GF_Err stbl_AppendPadding ( GF_SampleTableBox * stbl , u8 padding ) ; GF_Err stbl_AppendDegradation ( GF_SampleTableBox * stbl , u16 DegradationPriority ) ; if ( trak -> Header -> trackID != traf -> tfhd -> trackID ) return GF_OK ; if ( ! trak -> Media -> information -> sampleTable || ! trak -> Media -> information -> sampleTable -> SampleSize || ! trak -> Media -> information -> sampleTable -> TimeToSample || ! trak -> Media -> information -> sampleTable -> SampleToChunk || ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { return GF_ISOM_INVALID_FILE ; } if ( ! traf -> trex -> track ) traf -> trex -> track = trak ; DescIndex = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DESC ) ? traf -> tfhd -> sample_desc_index : traf -> trex -> def_sample_desc_index ; if ( ! DescIndex ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>0,<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" ) ) ; DescIndex = 1 ; } else if ( DescIndex > gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>sample<S2SV_blank>description(s),<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" , DescIndex , gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) ) ; DescIndex = 1 ; } # ifdef GF_ENABLE_CTRN if ( traf -> trex -> inherit_from_traf_id ) { u32 traf_count = gf_list_count ( moof_box -> TrackList ) ; for ( i = 0 ; i < traf_count ; i ++ ) { GF_TrackFragmentBox * atraf = gf_list_get ( moof_box -> TrackList , i ) ; if ( atraf -> tfhd && atraf -> tfhd -> trackID == traf -> trex -> inherit_from_traf_id ) { traf_ref = atraf ; break ; } } } # endif def_duration = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DUR ) ? traf -> tfhd -> def_sample_duration : traf -> trex -> def_sample_duration ; def_size = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_SIZE ) ? traf -> tfhd -> def_sample_size : traf -> trex -> def_sample_size ; def_flags = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_FLAGS ) ? traf -> tfhd -> def_sample_flags : traf -> trex -> def_sample_flags ; base_offset = moof_offset ; if ( traf -> tfhd -> flags & GF_ISOM_TRAF_BASE_OFFSET ) base_offset = traf -> tfhd -> base_data_offset ; else if ( ! ( traf -> tfhd -> flags & GF_ISOM_MOOF_BASE_OFFSET ) ) base_offset = * cumulated_offset ; chunk_size = 0 ; prev_trun_data_offset = 0 ; data_offset = 0 ; traf_duration = 0 ; if ( traf -> tfdt && is_first_merge ) { # ifndef GPAC_DISABLE_LOG if ( trak -> moov -> mov -> NextMoofNumber && trak -> present_in_scalable_segment && trak -> sample_count_at_seg_start && ( trak -> dts_at_seg_start != traf -> tfdt -> baseMediaDecodeTime ) ) { s32 drift = ( s32 ) ( ( s64 ) traf -> tfdt -> baseMediaDecodeTime - ( s64 ) trak -> dts_at_seg_start ) ; if ( drift < 0 ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Warning:<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>less<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>-<S2SV_blank>using<S2SV_blank>tfdt\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } else { GF_LOG ( GF_LOG_INFO , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>(last<S2SV_blank>sample<S2SV_blank>got<S2SV_blank>extended<S2SV_blank>in<S2SV_blank>duration)\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } } # endif trak -> dts_at_seg_start = traf -> tfdt -> baseMediaDecodeTime ; } else if ( traf -> tfxd ) { trak -> dts_at_seg_start = traf -> tfxd -> absolute_time_in_track_timescale ; } if ( traf -> tfxd ) { trak -> last_tfxd_value = traf -> tfxd -> absolute_time_in_track_timescale ; trak -> last_tfxd_value += traf -> tfxd -> fragment_duration_in_track_timescale ; } if ( traf -> tfrf ) { if ( trak -> tfrf ) gf_isom_box_del_parent ( & trak -> child_boxes , ( GF_Box * ) trak -> tfrf ) ; trak -> tfrf = traf -> tfrf ; gf_list_del_item ( traf -> child_boxes , traf -> tfrf ) ; gf_list_add ( trak -> child_boxes , trak -> tfrf ) ; } if ( trak -> moov -> mov -> signal_frag_bounds ) { store_traf_map = GF_TRUE ; if ( is_first_merge ) { GF_MovieFragmentBox * moof_clone = NULL ; gf_isom_box_freeze_order ( ( GF_Box * ) moof_box ) ; gf_isom_clone_box ( ( GF_Box * ) moof_box , ( GF_Box * * ) & moof_clone ) ; if ( moof_clone ) { GF_BitStream * bs ; for ( i = 0 ; i < gf_list_count ( moof_clone -> TrackList ) ; i ++ ) { GF_TrackFragmentBox * traf_clone = gf_list_get ( moof_clone -> TrackList , i ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> TrackRuns ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroups ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroupsDescription ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sub_samples ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_offsets ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_sizes ) ; if ( traf_clone -> sample_encryption ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sample_encryption ) ; traf_clone -> sample_encryption = NULL ; } if ( traf_clone -> sdtp ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sdtp ) ; traf_clone -> sdtp = NULL ; } } gf_isom_box_size ( ( GF_Box * ) moof_clone ) ; bs = gf_bs_new ( NULL , 0 , GF_BITSTREAM_WRITE ) ; if ( trak -> moov -> mov -> seg_styp ) { gf_isom_box_size ( trak -> moov -> mov -> seg_styp ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_styp , bs ) ; } if ( trak -> moov -> mov -> root_sidx ) { gf_isom_box_size ( ( GF_Box * ) trak -> moov -> mov -> root_sidx ) ; gf_isom_box_write ( ( GF_Box * ) trak -> moov -> mov -> root_sidx , bs ) ; } if ( trak -> moov -> mov -> seg_ssix ) { gf_isom_box_size ( trak -> moov -> mov -> seg_ssix ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_ssix , bs ) ; } gf_isom_box_write ( ( GF_Box * ) moof_clone , bs ) ; gf_isom_box_del ( ( GF_Box * ) moof_clone ) ; gf_bs_get_content ( bs , & moof_template , & moof_template_size ) ; gf_bs_del ( bs ) ; } } if ( trak -> moov -> mov -> seg_styp ) { is_seg_start = GF_TRUE ; seg_start = trak -> moov -> mov -> styp_start_offset ; } if ( trak -> moov -> mov -> root_sidx ) { is_seg_start = GF_TRUE ; sidx_start = trak -> moov -> mov -> sidx_start_offset ; sidx_end = trak -> moov -> mov -> sidx_end_offset ; if ( ! seg_start || ( sidx_start < seg_start ) ) seg_start = sidx_start ; } frag_start = trak -> moov -> mov -> current_top_box_start ; } else if ( trak -> moov -> mov -> store_traf_map ) { store_traf_map = GF_TRUE ; } sample_index = 0 ; i = 0 ; while ( ( trun = ( GF_TrackFragmentRunBox * ) gf_list_enum ( traf -> TrackRuns , & i ) ) ) { for ( j = 0 ; j < trun -> sample_count ; j ++ ) { GF_Err e ; s32 cts_offset = 0 ; if ( j < trun -> nb_samples ) { ent = & trun -> samples [ j ] ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>enough<S2SV_blank>trun<S2SV_blank>entries<S2SV_blank>(%d)<S2SV_blank>compared<S2SV_blank>to<S2SV_blank>sample<S2SV_blank>count<S2SV_blank>(%d)<S2SV_blank>in<S2SV_blank>run\\n"" , traf -> trex -> trackID , trun -> nb_samples , trun -> sample_count ) ) ; break ; } size = def_size ; duration = def_duration ; flags = def_flags ; cts_offset = ent -> CTS_Offset ; # ifdef GF_ENABLE_CTRN if ( trun -> use_ctrn ) { if ( ! j && ( trun -> ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE ) ) { if ( trun -> ctrn_first_dur ) duration = ent -> Duration ; if ( trun -> ctrn_first_size ) size = ent -> size ; if ( trun -> ctrn_first_ctts ) flags = ent -> flags ; } else { if ( trun -> ctrn_dur ) duration = ent -> Duration ; if ( trun -> ctrn_size ) size = ent -> size ; if ( trun -> ctrn_sample_flags ) flags = ent -> flags ; } if ( trun -> ctrn_flags & 0xF0 ) { GF_TrunEntry * ref_entry ; if ( ! traf_ref ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>to<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>reference<S2SV_blank>traf<S2SV_blank>not<S2SV_blank>found\\n"" , traf -> trex -> trackID , traf -> trex -> inherit_from_traf_id ) ) ; break ; } ref_entry = traf_get_sample_entry ( traf_ref , sample_index ) ; if ( ! ref_entry ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>but<S2SV_blank>sample<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>reference<S2SV_blank>traf\\n"" , traf -> trex -> trackID , sample_index + 1 ) ) ; break ; } if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR ) duration = ref_entry -> Duration ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE ) size = ref_entry -> size ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS ) flags = ref_entry -> flags ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO ) cts_offset = ref_entry -> CTS_Offset ; } } else # endif { if ( trun -> flags & GF_ISOM_TRUN_DURATION ) duration = ent -> Duration ; if ( trun -> flags & GF_ISOM_TRUN_SIZE ) size = ent -> size ; if ( trun -> flags & GF_ISOM_TRUN_FLAGS ) { flags = ent -> flags ; } else if ( ! j && ( trun -> flags & GF_ISOM_TRUN_FIRST_FLAG ) ) { flags = trun -> first_sample_flags ; } } sample_index ++ ; ent -> size = size ; ent -> Duration = duration ; ent -> flags = flags ; ent -> CTS_Offset = cts_offset ; last_dts += duration ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) { trak -> Media -> information -> sampleTable -> SampleSize = ( GF_SampleSizeBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSZ ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) return GF_OUT_OF_MEM ; } e = stbl_AppendSize ( trak -> Media -> information -> sampleTable , size , ent -> nb_pack ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) { trak -> Media -> information -> sampleTable -> TimeToSample = ( GF_TimeToSampleBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STTS ) ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) return GF_OUT_OF_MEM ; } e = stbl_AppendTime ( trak -> Media -> information -> sampleTable , duration , ent -> nb_pack ) ; if ( e ) return e ; if ( ! j ) { u64 final_offset ; data_offset = base_offset ; if ( trun -> flags & GF_ISOM_TRUN_DATA_OFFSET ) { data_offset += trun -> data_offset ; chunk_size = 0 ; prev_trun_data_offset = trun -> data_offset ; if ( trun -> data_offset >= 0 ) { data_offset -= compressed_diff ; prev_trun_data_offset -= compressed_diff ; } } else if ( prev_trun_data_offset ) { data_offset += prev_trun_data_offset + chunk_size ; } else { data_offset += chunk_size ; if ( ( i == 1 ) && ( trun -> data_offset >= 0 ) ) { data_offset -= compressed_diff ; } } final_offset = data_offset ; if ( trak -> moov -> compressed_diff ) { final_offset += trak -> moov -> compressed_diff ; } if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { trak -> Media -> information -> sampleTable -> ChunkOffset = gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STCO ) ; if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) return GF_OUT_OF_MEM ; } e = stbl_AppendChunk ( trak -> Media -> information -> sampleTable , final_offset ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) { trak -> Media -> information -> sampleTable -> SampleToChunk = ( GF_SampleToChunkBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSC ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) return GF_OUT_OF_MEM ; } e = stbl_AppendSampleToChunk ( trak -> Media -> information -> sampleTable , DescIndex , trun -> sample_count ) ; if ( e ) return e ; } chunk_size += size ; if ( store_traf_map && first_samp_in_traf ) { first_samp_in_traf = GF_FALSE ; e = stbl_AppendTrafMap ( trak -> Media -> information -> sampleTable , is_seg_start , seg_start , frag_start , moof_template , moof_template_size , sidx_start , sidx_end ) ; if ( e ) return e ; moof_template = NULL ; moof_template_size = 0 ; } if ( ent -> nb_pack > 1 ) { j += ent -> nb_pack - 1 ; traf_duration += ent -> nb_pack * duration ; continue ; } traf_duration += duration ; e = stbl_AppendCTSOffset ( trak -> Media -> information -> sampleTable , cts_offset ) ; if ( e ) return e ; sync = GF_ISOM_GET_FRAG_SYNC ( flags ) ; if ( trak -> Media -> information -> sampleTable -> no_sync_found && sync ) { trak -> Media -> information -> sampleTable -> no_sync_found = 0 ; } e = stbl_AppendRAP ( trak -> Media -> information -> sampleTable , sync ) ; if ( e ) return e ; pad = GF_ISOM_GET_FRAG_PAD ( flags ) ; if ( pad ) { e = stbl_AppendPadding ( trak -> Media -> information -> sampleTable , pad ) ; if ( e ) return e ; } degr = GF_ISOM_GET_FRAG_DEG ( flags ) ; if ( degr ) { e = stbl_AppendDegradation ( trak -> Media -> information -> sampleTable , degr ) ; if ( e ) return e ; } e = stbl_AppendDependencyType ( trak -> Media -> information -> sampleTable , GF_ISOM_GET_FRAG_LEAD ( flags ) , GF_ISOM_GET_FRAG_DEPENDS ( flags ) , GF_ISOM_GET_FRAG_DEPENDED ( flags ) , GF_ISOM_GET_FRAG_REDUNDANT ( flags ) ) ; if ( e ) return e ; } } if ( trak -> moov -> mov -> is_smooth && ! traf -> tfdt && ! traf -> tfxd ) { if ( is_first_merge ) trak -> dts_at_seg_start = trak -> dts_at_next_seg_start ; trak -> dts_at_next_seg_start += last_dts ; } if ( traf_duration && trak -> editBox && trak -> editBox -> editList ) { for ( i = 0 ; i < gf_list_count ( trak -> editBox -> editList -> entryList ) ; i ++ ) { GF_EdtsEntry * edts_e = gf_list_get ( trak -> editBox -> editList -> entryList , i ) ; if ( edts_e -> was_empty_dur ) { u64 extend_dur = traf_duration ; extend_dur *= trak -> moov -> mvhd -> timeScale ; extend_dur /= trak -> Media -> mediaHeader -> timeScale ; edts_e -> segmentDuration += extend_dur ; } else if ( ! edts_e -> segmentDuration ) { edts_e -> was_empty_dur = GF_TRUE ; if ( ( s64 ) traf_duration > edts_e -> mediaTime ) traf_duration -= edts_e -> mediaTime ; else traf_duration = 0 ; edts_e -> segmentDuration = traf_duration ; edts_e -> segmentDuration *= trak -> moov -> mvhd -> timeScale ; edts_e -> segmentDuration /= trak -> Media -> mediaHeader -> timeScale ; } } } * cumulated_offset = data_offset + chunk_size ; if ( traf -> sampleGroups ) { GF_List * groups ; GF_List * groupDescs ; Bool is_identical_sgpd = GF_TRUE ; u32 * new_idx = NULL , new_idx_count = 0 ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroups ) trak -> Media -> information -> sampleTable -> sampleGroups = gf_list_new ( ) ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) trak -> Media -> information -> sampleTable -> sampleGroupsDescription = gf_list_new ( ) ; groupDescs = trak -> Media -> information -> sampleTable -> sampleGroupsDescription ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroupsDescription ) ; i ++ ) { GF_SampleGroupDescriptionBox * new_sgdesc = NULL ; GF_SampleGroupDescriptionBox * sgdesc = gf_list_get ( traf -> sampleGroupsDescription , i ) ; for ( j = 0 ; j < gf_list_count ( groupDescs ) ; j ++ ) { new_sgdesc = gf_list_get ( groupDescs , j ) ; if ( new_sgdesc -> grouping_type == sgdesc -> grouping_type ) break ; new_sgdesc = NULL ; } if ( ! new_sgdesc ) { gf_list_add ( groupDescs , sgdesc ) ; gf_list_add ( trak -> Media -> information -> sampleTable -> child_boxes , sgdesc ) ; gf_list_rem ( traf -> sampleGroupsDescription , i ) ; gf_list_del_item ( traf -> child_boxes , sgdesc ) ; i -- ; } else { u32 count ; is_identical_sgpd = gf_isom_is_identical_sgpd ( new_sgdesc , sgdesc , 0 ) ; if ( is_identical_sgpd ) continue ; new_idx_count = gf_list_count ( sgdesc -> group_descriptions ) ; new_idx = ( u32 * ) gf_malloc ( new_idx_count * sizeof ( u32 ) ) ; if ( ! new_idx ) return GF_OUT_OF_MEM ; count = 0 ; while ( gf_list_count ( sgdesc -> group_descriptions ) ) { void * sgpd_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; Bool new_entry = GF_TRUE ; for ( j = 0 ; j < gf_list_count ( new_sgdesc -> group_descriptions ) ; j ++ ) { void * ptr = gf_list_get ( new_sgdesc -> group_descriptions , j ) ; if ( gf_isom_is_identical_sgpd ( sgpd_entry , ptr , new_sgdesc -> grouping_type ) ) { new_idx [ count ] = j + 1 ; count ++ ; new_entry = GF_FALSE ; gf_free ( sgpd_entry ) ; break ; } } if ( new_entry ) { gf_list_add ( new_sgdesc -> group_descriptions , sgpd_entry ) ; new_idx [ count ] = gf_list_count ( new_sgdesc -> group_descriptions ) ; count ++ ; } gf_list_rem ( sgdesc -> group_descriptions , 0 ) ; } } } groups = trak -> Media -> information -> sampleTable -> sampleGroups ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroups ) ; i ++ ) { GF_SampleGroupBox * stbl_group = NULL ; GF_SampleGroupBox * frag_group = gf_list_get ( traf -> sampleGroups , i ) ; for ( j = 0 ; j < gf_list_count ( groups ) ; j ++ ) { stbl_group = gf_list_get ( groups , j ) ; if ( ( frag_group -> grouping_type == stbl_group -> grouping_type ) && ( frag_group -> grouping_type_parameter == stbl_group -> grouping_type_parameter ) ) break ; stbl_group = NULL ; } if ( ! stbl_group ) { stbl_group = ( GF_SampleGroupBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_SBGP ) ; if ( ! stbl_group ) return GF_OUT_OF_MEM ; stbl_group -> grouping_type = frag_group -> grouping_type ; stbl_group -> grouping_type_parameter = frag_group -> grouping_type_parameter ; stbl_group -> version = frag_group -> version ; gf_list_add ( groups , stbl_group ) ; } if ( is_identical_sgpd ) { for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) frag_group -> sample_entries [ j ] . group_description_index &= 0x0FFFF ; if ( frag_group -> entry_count && stbl_group -> entry_count && ( frag_group -> sample_entries [ 0 ] . group_description_index == stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . group_description_index ) ) { stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . sample_count += frag_group -> sample_entries [ 0 ] . sample_count ; if ( frag_group -> entry_count > 1 ) { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count - 1 ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 1 ] , sizeof ( GF_SampleGroupEntry ) * ( frag_group -> entry_count - 1 ) ) ; stbl_group -> entry_count += frag_group -> entry_count - 1 ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) { u32 sgidx = frag_group -> sample_entries [ j ] . group_description_index ; if ( sgidx > 0x10000 ) { sgidx -= 0x10001 ; if ( sgidx >= new_idx_count ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>corrupted<S2SV_blank>sample<S2SV_blank>group<S2SV_blank>index<S2SV_blank>in<S2SV_blank>fragment<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>group<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>fragment\\n"" , sgidx , new_idx_count ) ) ; } else { frag_group -> sample_entries [ j ] . group_description_index = new_idx [ sgidx ] ; } } } memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } if ( new_idx ) gf_free ( new_idx ) ; } track_num = gf_isom_get_tracknum_from_id ( trak -> moov , trak -> Header -> trackID ) ; if ( gf_isom_is_cenc_media ( trak -> moov -> mov , track_num , DescIndex ) || traf -> sample_encryption ) { GF_SampleEncryptionBox * senc = NULL ; u32 scheme_type ; gf_isom_get_cenc_info ( trak -> moov -> mov , track_num , DescIndex , NULL , & scheme_type , NULL ) ; if ( traf -> sample_encryption ) { for ( i = 0 ; i < gf_list_count ( trak -> Media -> information -> sampleTable -> child_boxes ) ; i ++ ) { GF_Box * a = ( GF_Box * ) gf_list_get ( trak -> Media -> information -> sampleTable -> child_boxes , i ) ; if ( a -> type != traf -> sample_encryption -> type ) continue ; if ( ( a -> type == GF_ISOM_BOX_TYPE_UUID ) && ( ( ( GF_UUIDBox * ) a ) -> internal_4cc == GF_ISOM_BOX_UUID_PSEC ) ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } else if ( a -> type == GF_ISOM_BOX_TYPE_SENC ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } } if ( ! senc && trak -> sample_encryption ) senc = trak -> sample_encryption ; if ( ! senc ) { if ( traf -> sample_encryption -> piff_type == 1 ) { senc = ( GF_SampleEncryptionBox * ) gf_isom_create_piff_psec_box ( 1 , 0x2 , 0 , 0 , NULL ) ; } else { senc = gf_isom_create_samp_enc_box ( 1 , 0x2 ) ; } if ( ! trak -> Media -> information -> sampleTable -> child_boxes ) trak -> Media -> information -> sampleTable -> child_boxes = gf_list_new ( ) ; trak -> sample_encryption = senc ; if ( ! trak -> child_boxes ) trak -> child_boxes = gf_list_new ( ) ; gf_list_add ( trak -> child_boxes , senc ) ; } } if ( gf_isom_cenc_has_saiz_saio_traf ( traf , scheme_type ) ) { u32 nb_saio ; u32 aux_info_type ; u64 offset ; GF_Err e ; Bool is_encrypted ; GF_SampleAuxiliaryInfoOffsetBox * saio = NULL ; GF_SampleAuxiliaryInfoSizeBox * saiz = NULL ; offset = nb_saio = 0 ; for ( i = 0 ; i < gf_list_count ( traf -> sai_offsets ) ; i ++ ) { saio = ( GF_SampleAuxiliaryInfoOffsetBox * ) gf_list_get ( traf -> sai_offsets , i ) ; aux_info_type = saio -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_offsets ) == 1 ) ) { <S2SV_StartBug> offset = saio -> offsets [ 0 ] + moof_offset ; <S2SV_EndBug> nb_saio = saio -> entry_count ; break ; } } <S2SV_StartBug> for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) { <S2SV_EndBug> saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ; aux_info_type = saiz -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_sizes ) == 1 ) ) { break ; <S2SV_StartBug> } <S2SV_EndBug> } if ( saiz && saio && senc ) { for ( i = 0 ; i < saiz -> sample_count ; i ++ ) { GF_CENCSampleAuxInfo * sai ; const u8 * key_info = NULL ; u32 key_info_size ; u64 cur_position ; if ( nb_saio != 1 ) offset = saio -> offsets [ i ] + moof_offset ; size = saiz -> default_sample_info_size ? saiz -> default_sample_info_size : saiz -> sample_info_size [ i ] ; cur_position = gf_bs_get_position ( trak -> moov -> mov -> movieFileMap -> bs ) ; gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , offset ) ; GF_SAFEALLOC ( sai , GF_CENCSampleAuxInfo ) ; if ( ! sai ) return GF_OUT_OF_MEM ; e = gf_isom_get_sample_cenc_info_internal ( trak , traf , senc , i + 1 , & is_encrypted , NULL , NULL , & key_info , & key_info_size ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>cenc<S2SV_blank>info<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d:<S2SV_blank>%s\\n"" , i + 1 , gf_error_to_string ( e ) ) ) ; return e ; } if ( is_encrypted ) { sai -> cenc_data_size = size ; sai -> cenc_data = gf_malloc ( sizeof ( u8 ) * size ) ; if ( ! sai -> cenc_data ) return GF_OUT_OF_MEM ; gf_bs_read_data ( trak -> moov -> mov -> movieFileMap -> bs , sai -> cenc_data , sai -> cenc_data_size ) ; } else { sai -> isNotProtected = 1 ; } if ( key_info ) { if ( ! key_info [ 0 ] ) { if ( size > key_info [ 3 ] ) senc -> flags = 0x00000002 ; } else { senc -> flags = 0x00000002 ; } } gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , cur_position ) ; gf_list_add ( senc -> samp_aux_info , sai ) ; e = gf_isom_cenc_merge_saiz_saio ( senc , trak -> Media -> information -> sampleTable , offset , size ) ; if ( e ) return e ; if ( nb_saio == 1 ) offset += size ; } } } else if ( traf -> sample_encryption ) { senc_Parse ( trak -> moov -> mov -> movieFileMap -> bs , trak , traf , traf -> sample_encryption ) ; trak -> sample_encryption -> AlgorithmID = traf -> sample_encryption -> AlgorithmID ; if ( ! trak -> sample_encryption -> IV_size ) trak -> sample_encryption -> IV_size = traf -> sample_encryption -> IV_size ; if ( ! trak -> sample_encryption -> samp_aux_info ) trak -> sample_encryption -> samp_aux_info = gf_list_new ( ) ; gf_list_transfer ( trak -> sample_encryption -> samp_aux_info , traf -> sample_encryption -> samp_aux_info ) ; if ( traf -> sample_encryption -> flags & 0x00000002 ) trak -> sample_encryption -> flags |= 0x00000002 ; } } return GF_OK ; }
","<S2SV_ModStart> ) ) { if ( saio -> offsets && saio -> entry_count ) { <S2SV_ModStart> ; } } saio = NULL ; } <S2SV_ModStart> break ; } saiz = NULL ;
",gpac@gpac/df8fffd839fe5ae9acd82d26fd48280a397411d9,CVE-2021-31260,https://github.com/gpac/gpac/commit/df8fffd839fe5ae9acd82d26fd48280a397411d9,2021-04-19T19:15Z,<S2SV_StartBug> offset = saio -> offsets [ 0 ] + moof_offset ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
1736,CWE-119,"void vp9_setup_src_planes ( MACROBLOCK * x , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; int i ; x -> e_mbd . cur_buf = src ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) setup_pred_plane ( & x -> plane [ i ] . src , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , x -> e_mbd . plane [ i ] . subsampling_x , x -> e_mbd . plane [ i ] . subsampling_y ) ; }
","<S2SV_ModStart> const buffers [ 3 <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> v_buffer <S2SV_ModEnd> } ; const <S2SV_ModStart> int strides [ 3 <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> uv_stride <S2SV_ModEnd> } ; int
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug>"
1351,CWE-119,"<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><frame>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
","<S2SV_ModStart> void usage_exit ( void
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug>
4073,CWE-125,"void isakmp_rfc3948_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 ) { <S2SV_StartBug> if ( length == 1 && bp [ 0 ] == 0xff ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""isakmp-nat-keep-alive"" ) ) ; return ; } if ( length < 4 ) { goto trunc ; <S2SV_StartBug> } <S2SV_EndBug> if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) { ND_PRINT ( ( ndo , ""NONESP-encap:<S2SV_blank>"" ) ) ; isakmp_print ( ndo , bp + 4 , length - 4 , bp2 ) ; return ; } { int nh , enh , padlen ; int advance ; ND_PRINT ( ( ndo , ""UDP-encap:<S2SV_blank>"" ) ) ; advance = esp_print ( ndo , bp , length , bp2 , & enh , & padlen ) ; if ( advance <= 0 ) return ; bp += advance ; length -= advance + padlen ; nh = enh & 0xff ; ip_print_inner ( ndo , bp , length , nh , bp2 ) ; return ; } trunc : ND_PRINT ( ( ndo , ""[|isakmp]"" ) ) ; return ; }
","<S2SV_ModStart> bp2 ) { ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModStart> trunc ; } ND_TCHECK ( bp [ 3 ] ) ;
",the-tcpdump-group@tcpdump/f76e7feb41a4327d2b0978449bbdafe98d4a3771,CVE-2017-12896,https://github.com/the-tcpdump-group/tcpdump/commit/f76e7feb41a4327d2b0978449bbdafe98d4a3771,2017-09-14T06:29Z,<S2SV_StartBug> if ( length == 1 && bp [ 0 ] == 0xff ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
946,CWE-125,"int libevt_record_values_read_event ( libevt_record_values_t * record_values , uint8_t * record_data , size_t record_data_size , uint8_t strict_mode , libcerror_error_t * * error ) { static char * function = ""libevt_record_values_read_event"" ; size_t record_data_offset = 0 ; size_t strings_data_offset = 0 ; ssize_t value_data_size = 0 ; uint32_t data_offset = 0 ; uint32_t data_size = 0 ; uint32_t members_data_size = 0 ; uint32_t size = 0 ; uint32_t size_copy = 0 ; uint32_t strings_offset = 0 ; uint32_t strings_size = 0 ; uint32_t user_sid_offset = 0 ; uint32_t user_sid_size = 0 ; # if defined ( HAVE_DEBUG_OUTPUT ) uint32_t value_32bit = 0 ; uint16_t value_16bit = 0 ; # endif if ( record_values == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>values."" , function ) ; return ( - 1 ) ; } if ( record_data == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>data."" , function ) ; return ( - 1 ) ; } if ( record_data_size > ( size_t ) SSIZE_MAX ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>exceeds<S2SV_blank>maximum."" , function ) ; return ( - 1 ) ; } if ( record_data_size < ( sizeof ( evt_record_event_header_t ) + 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>record<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; return ( - 1 ) ; } byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> size , size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> record_number , record_values -> number ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> creation_time , record_values -> creation_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> written_time , record_values -> written_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_identifier , record_values -> event_identifier ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_type , record_values -> event_type ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_category , record_values -> event_category ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> strings_offset , strings_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_size , user_sid_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_offset , user_sid_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_size , data_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_offset , data_offset ) ; byte_stream_copy_to_uint32_little_endian ( & ( record_data [ record_data_size - 4 ] ) , size_copy ) ; # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>size\\t\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , size ) ; libcnotify_printf ( ""%s:<S2SV_blank>signature\\t\\t\\t\\t:<S2SV_blank>%c%c%c%c\\n"" , function , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 0 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 1 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 2 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 3 ] ) ; libcnotify_printf ( ""%s:<S2SV_blank>record<S2SV_blank>number\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , record_values -> number ) ; if ( libevt_debug_print_posix_time_value ( function , ""creation<S2SV_blank>time\\t\\t\\t\\t"" , ( ( evt_record_event_header_t * ) record_data ) -> creation_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>POSIX<S2SV_blank>time<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libevt_debug_print_posix_time_value ( function , ""written<S2SV_blank>time\\t\\t\\t\\t"" , ( ( evt_record_event_header_t * ) record_data ) -> written_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>POSIX<S2SV_blank>time<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier\\t\\t\\t:<S2SV_blank>0x%08"" PRIx32 ""\\n"" , function , record_values -> event_identifier ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>code\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , record_values -> event_identifier & 0x0000ffffUL ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>facility\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x0fff0000UL ) >> 16 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>reserved\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x10000000UL ) >> 28 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>customer<S2SV_blank>flags\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x20000000UL ) >> 29 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>severity\\t\\t:<S2SV_blank>%"" PRIu32 ""<S2SV_blank>("" , function , ( record_values -> event_identifier & 0xc0000000UL ) >> 30 ) ; libevt_debug_print_event_identifier_severity ( record_values -> event_identifier ) ; libcnotify_printf ( "")\\n"" ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>type\\t\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>("" , function , record_values -> event_type ) ; libevt_debug_print_event_type ( record_values -> event_type ) ; libcnotify_printf ( "")\\n"" ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> number_of_strings , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>strings\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""\\n"" , function , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>category\\t\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""\\n"" , function , record_values -> event_category ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_flags , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>flags\\t\\t\\t\\t:<S2SV_blank>0x%04"" PRIx16 ""\\n"" , function , value_16bit ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> closing_record_number , value_32bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>closing<S2SV_blank>record<S2SV_blank>values<S2SV_blank>number\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , value_32bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>strings<S2SV_blank>offset\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , strings_offset ) ; libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>size\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , user_sid_size ) ; libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>offset\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , user_sid_offset ) ; libcnotify_printf ( ""%s:<S2SV_blank>data<S2SV_blank>size\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , data_size ) ; libcnotify_printf ( ""%s:<S2SV_blank>data<S2SV_blank>offset\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , data_offset ) ; } # endif record_data_offset = sizeof ( evt_record_event_header_t ) ; if ( ( user_sid_offset == 0 ) && ( user_sid_size != 0 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>offset<S2SV_blank>or<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( user_sid_offset != 0 ) { if ( ( ( size_t ) user_sid_offset < record_data_offset ) || ( ( size_t ) user_sid_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( user_sid_size != 0 ) { if ( ( size_t ) ( user_sid_offset + user_sid_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } } if ( ( ( size_t ) strings_offset < user_sid_offset ) || ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( ( ( size_t ) data_offset < strings_offset ) || ( ( size_t ) data_offset >= ( record_data_size - 4 ) ) ) { if ( data_size != 0 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } data_offset = ( uint32_t ) record_data_size - 4 ; } if ( ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) && ( strings_offset != data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( strings_offset != 0 ) { if ( strings_offset < record_data_offset ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } if ( user_sid_offset != 0 ) { members_data_size = user_sid_offset - ( uint32_t ) record_data_offset ; } else if ( strings_offset != 0 ) { members_data_size = strings_offset - ( uint32_t ) record_data_offset ; } if ( strings_offset != 0 ) { strings_size = data_offset - strings_offset ; } if ( data_size != 0 ) { if ( ( size_t ) ( data_offset + data_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } if ( members_data_size != 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>members<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> source_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> source_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>source<S2SV_blank>name\\t\\t\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> source_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( libfvalue_value_type_initialize ( & ( record_values -> computer_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> computer_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>computer<S2SV_blank>name\\t\\t\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> computer_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( members_data_size > 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>members<S2SV_blank>trailing<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif record_data_offset += members_data_size ; } } if ( user_sid_size != 0 ) { <S2SV_StartBug> if ( libfvalue_value_type_initialize ( <S2SV_EndBug> & ( record_values -> user_security_identifier ) , LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> user_security_identifier , & ( record_data [ user_sid_offset ] ) , ( size_t ) user_sid_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> user_security_identifier , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += user_sid_size ; } if ( strings_size != 0 ) <S2SV_StartBug> { <S2SV_EndBug> # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>strings<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ strings_offset ] ) , strings_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( size_copy == 0 ) { strings_data_offset = strings_offset + strings_size - 2 ; while ( strings_data_offset > strings_offset ) { if ( ( record_data [ strings_data_offset ] != 0 ) || ( record_data [ strings_data_offset + 1 ] != 0 ) ) { strings_size += 2 ; break ; } strings_data_offset -= 2 ; strings_size -= 2 ; } } if ( libfvalue_value_type_initialize ( & ( record_values -> strings ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>strings<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_strings_array ( record_values -> strings , & ( record_data [ strings_offset ] ) , strings_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>strings<S2SV_blank>value."" , function ) ; goto on_error ; } record_data_offset += strings_size ; } if ( data_size != 0 ) { <S2SV_StartBug> # if defined ( HAVE_DEBUG_OUTPUT ) <S2SV_EndBug> if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( <S2SV_StartBug> & ( record_data [ data_offset ] ) , <S2SV_EndBug> ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> data ) , LIBFVALUE_VALUE_TYPE_BINARY_DATA , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>data<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> data , & ( record_data [ record_data_offset ] ) , ( size_t ) data_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>data<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) record_data_offset += data_size ; # endif } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { if ( record_data_offset < ( record_data_size - 4 ) ) { libcnotify_printf ( ""%s:<S2SV_blank>padding:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , ( size_t ) record_data_size - record_data_offset - 4 , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } libcnotify_printf ( ""%s:<S2SV_blank>size<S2SV_blank>copy\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , size_copy ) ; libcnotify_printf ( ""\\n"" ) ; } # endif if ( ( strict_mode == 0 ) && ( size_copy == 0 ) ) { size_copy = size ; } if ( size != size_copy ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , ""%s:<S2SV_blank>value<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>size<S2SV_blank>and<S2SV_blank>size<S2SV_blank>copy."" , function ) ; goto on_error ; } if ( record_data_size != ( size_t ) size ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , ""%s:<S2SV_blank>value<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>record_values<S2SV_blank>data<S2SV_blank>size<S2SV_blank>and<S2SV_blank>size."" , function ) ; goto on_error ; } return ( 1 ) ; on_error : if ( record_values -> data != NULL ) { libfvalue_value_free ( & ( record_values -> data ) , NULL ) ; } if ( record_values -> strings != NULL ) { libfvalue_value_free ( & ( record_values -> strings ) , NULL ) ; } if ( record_values -> user_security_identifier != NULL ) { libfvalue_value_free ( & ( record_values -> user_security_identifier ) , NULL ) ; } if ( record_values -> computer_name != NULL ) { libfvalue_value_free ( & ( record_values -> computer_name ) , NULL ) ; } if ( record_values -> source_name != NULL ) { libfvalue_value_free ( & ( record_values -> source_name ) , NULL ) ; } return ( - 1 ) ; }
","<S2SV_ModStart> { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( <S2SV_ModStart> 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> 0 ) { if ( data_size > ( ( record_data_size - 4 ) - data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> ( record_data [ record_data_offset <S2SV_ModEnd> ] ) ,
",libyal@libevt/444ca3ce7853538c577e0ec3f6146d2d65780734,CVE-2018-8754,https://github.com/libyal/libevt/commit/444ca3ce7853538c577e0ec3f6146d2d65780734,2018-03-18T03:29Z,"<S2SV_StartBug> if ( libfvalue_value_type_initialize ( <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> # if defined ( HAVE_DEBUG_OUTPUT ) <S2SV_EndBug> <S2SV_StartBug> & ( record_data [ data_offset ] ) , <S2SV_EndBug>"
916,CWE-125,"static int juniper_parse_header ( netdissect_options * ndo , const u_char * p , const struct pcap_pkthdr * h , struct juniper_l2info_t * l2info ) { const struct juniper_cookie_table_t * lp = juniper_cookie_table ; u_int idx , jnx_ext_len , jnx_header_len = 0 ; uint8_t tlv_type , tlv_len ; uint32_t control_word ; int tlv_value ; const u_char * tptr ; l2info -> header_len = 0 ; l2info -> cookie_len = 0 ; l2info -> proto = 0 ; l2info -> length = h -> len ; l2info -> caplen = h -> caplen ; ND_TCHECK2 ( p [ 0 ] , 4 ) ; l2info -> flags = p [ 3 ] ; l2info -> direction = p [ 3 ] & JUNIPER_BPF_PKT_IN ; if ( EXTRACT_24BITS ( p ) != JUNIPER_MGC_NUMBER ) { ND_PRINT ( ( ndo , ""no<S2SV_blank>magic-number<S2SV_blank>found!"" ) ) ; return 0 ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%3s<S2SV_blank>"" , tok2str ( juniper_direction_values , ""---"" , l2info -> direction ) ) ) ; jnx_header_len = 4 ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\tJuniper<S2SV_blank>PCAP<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( jnx_flag_values , ""none"" , l2info -> flags ) ) ) ; if ( ( l2info -> flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) { tptr = p + jnx_header_len ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; jnx_ext_len = EXTRACT_16BITS ( tptr ) ; jnx_header_len += 2 ; tptr += 2 ; jnx_header_len += jnx_ext_len ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>PCAP<S2SV_blank>Extension(s)<S2SV_blank>total<S2SV_blank>length<S2SV_blank>%u"" , jnx_ext_len ) ) ; ND_TCHECK2 ( tptr [ 0 ] , jnx_ext_len ) ; while ( jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD ) { tlv_type = * ( tptr ++ ) ; tlv_len = * ( tptr ++ ) ; tlv_value = 0 ; if ( tlv_type == 0 || tlv_len == 0 ) break ; if ( tlv_len + JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len ) goto trunc ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Extension<S2SV_blank>TLV<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value<S2SV_blank>"" , tok2str ( jnx_ext_tlv_values , ""Unknown"" , tlv_type ) , tlv_type , tlv_len ) ) ; tlv_value = juniper_read_tlv_value ( tptr , tlv_type , tlv_len ) ; switch ( tlv_type ) { case JUNIPER_EXT_TLV_IFD_NAME : break ; case JUNIPER_EXT_TLV_IFD_MEDIATYPE : case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifmt_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_ENCAPS : case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifle_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_IDX : case JUNIPER_EXT_TLV_IFL_UNIT : case JUNIPER_EXT_TLV_IFD_IDX : default : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%u"" , tlv_value ) ) ; } break ; } tptr += tlv_len ; jnx_ext_len -= tlv_len + JUNIPER_EXT_TLV_OVERHEAD ; } if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t-----original<S2SV_blank>packet-----\\n\\t"" ) ) ; } if ( ( l2info -> flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""no-L2-hdr,<S2SV_blank>"" ) ) ; ND_TCHECK2 ( p [ jnx_header_len + 4 ] , 1 ) ; if ( ip_heuristic_guess ( ndo , p + jnx_header_len + 4 , l2info -> length - ( jnx_header_len + 4 ) ) == 0 ) ND_PRINT ( ( ndo , ""no<S2SV_blank>IP-hdr<S2SV_blank>found!"" ) ) ; l2info -> header_len = jnx_header_len + 4 ; return 0 ; } l2info -> header_len = jnx_header_len ; p += l2info -> header_len ; l2info -> length -= l2info -> header_len ; l2info -> caplen -= l2info -> header_len ; ND_TCHECK ( p [ 0 ] ) ; while ( lp -> s != NULL ) { if ( lp -> pictype == l2info -> pictype ) { l2info -> cookie_len += lp -> cookie_len ; switch ( p [ 0 ] ) { case LS_COOKIE_ID : l2info -> cookie_type = LS_COOKIE_ID ; l2info -> cookie_len += 2 ; break ; case AS_COOKIE_ID : l2info -> cookie_type = AS_COOKIE_ID ; l2info -> cookie_len = 8 ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } # ifdef DLT_JUNIPER_MFR if ( l2info -> pictype == DLT_JUNIPER_MFR && ( p [ 0 ] & MFR_BE_MASK ) == MFR_BE_MASK ) { l2info -> cookie_len = 0 ; } # endif l2info -> header_len += l2info -> cookie_len ; l2info -> length -= l2info -> cookie_len ; l2info -> caplen -= l2info -> cookie_len ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%s-PIC,<S2SV_blank>cookie-len<S2SV_blank>%u"" , lp -> s , l2info -> cookie_len ) ) ; if ( l2info -> cookie_len > 0 ) { ND_TCHECK2 ( p [ 0 ] , l2info -> cookie_len ) ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>cookie<S2SV_blank>0x"" ) ) ; for ( idx = 0 ; idx < l2info -> cookie_len ; idx ++ ) { l2info -> cookie [ idx ] = p [ idx ] ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%02x"" , p [ idx ] ) ) ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; <S2SV_StartBug> l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ; <S2SV_EndBug> break ; } ++ lp ; } p += l2info -> cookie_len ; switch ( l2info -> pictype ) { # ifdef DLT_JUNIPER_MLPPP case DLT_JUNIPER_MLPPP : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_MLFR case DLT_JUNIPER_MLFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; } break ; # endif # ifdef DLT_JUNIPER_MFR case DLT_JUNIPER_MFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_ATM2 case DLT_JUNIPER_ATM2 : ND_TCHECK2 ( p [ 0 ] , 4 ) ; if ( l2info -> cookie [ 7 ] & ATM2_PKT_TYPE_MASK ) { control_word = EXTRACT_32BITS ( p ) ; switch ( control_word ) { case 0 : case 0x08000000 : case 0x08380000 : l2info -> header_len += 4 ; break ; default : break ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""control-word<S2SV_blank>0x%08x<S2SV_blank>"" , control_word ) ) ; } break ; # endif # ifdef DLT_JUNIPER_GGSN case DLT_JUNIPER_GGSN : break ; # endif # ifdef DLT_JUNIPER_ATM1 case DLT_JUNIPER_ATM1 : break ; # endif # ifdef DLT_JUNIPER_PPP case DLT_JUNIPER_PPP : break ; # endif # ifdef DLT_JUNIPER_CHDLC case DLT_JUNIPER_CHDLC : break ; # endif # ifdef DLT_JUNIPER_ETHER case DLT_JUNIPER_ETHER : break ; # endif # ifdef DLT_JUNIPER_FRELAY case DLT_JUNIPER_FRELAY : break ; # endif default : ND_PRINT ( ( ndo , ""Unknown<S2SV_blank>Juniper<S2SV_blank>DLT_<S2SV_blank>type<S2SV_blank>%u:<S2SV_blank>"" , l2info -> pictype ) ) ; break ; } if ( ndo -> ndo_eflag > 1 ) ND_PRINT ( ( ndo , ""hlen<S2SV_blank>%u,<S2SV_blank>proto<S2SV_blank>0x%04x,<S2SV_blank>"" , l2info -> header_len , l2info -> proto ) ) ; return 1 ; trunc : ND_PRINT ( ( ndo , ""[|juniper_hdr],<S2SV_blank>length<S2SV_blank>%u"" , h -> len ) ) ; return 0 ; }
","<S2SV_ModStart> ) ) ; ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;
",the-tcpdump-group@tcpdump/42073d54c53a496be40ae84152bbfe2c923ac7bc,CVE-2017-13004,https://github.com/the-tcpdump-group/tcpdump/commit/42073d54c53a496be40ae84152bbfe2c923ac7bc,2017-09-14T06:29Z,<S2SV_StartBug> l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ; <S2SV_EndBug>
393,CWE-264,"static int rio_ioctl ( struct net_device * dev , struct ifreq * rq , int cmd ) { int phy_addr ; struct netdev_private * np = netdev_priv ( dev ) ; <S2SV_StartBug> struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ; <S2SV_EndBug> struct netdev_desc * desc ; int i ; phy_addr = np -> phy_addr ; switch ( cmd ) { <S2SV_StartBug> case SIOCDEVPRIVATE : <S2SV_EndBug> break ; <S2SV_StartBug> case SIOCDEVPRIVATE + 1 : <S2SV_EndBug> <S2SV_StartBug> miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ; <S2SV_EndBug> break ; <S2SV_StartBug> case SIOCDEVPRIVATE + 2 : <S2SV_EndBug> <S2SV_StartBug> mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ; <S2SV_EndBug> break ; case SIOCDEVPRIVATE + 3 : break ; case SIOCDEVPRIVATE + 4 : break ; case SIOCDEVPRIVATE + 5 : netif_stop_queue ( dev ) ; break ; case SIOCDEVPRIVATE + 6 : netif_wake_queue ( dev ) ; break ; case SIOCDEVPRIVATE + 7 : printk ( ""tx_full=%x<S2SV_blank>cur_tx=%lx<S2SV_blank>old_tx=%lx<S2SV_blank>cur_rx=%lx<S2SV_blank>old_rx=%lx\\n"" , netif_queue_stopped ( dev ) , np -> cur_tx , np -> old_tx , np -> cur_rx , np -> old_rx ) ; break ; case SIOCDEVPRIVATE + 8 : printk ( ""TX<S2SV_blank>ring:\\n"" ) ; for ( i = 0 ; i < TX_RING_SIZE ; i ++ ) { desc = & np -> tx_ring [ i ] ; printk ( ""%02x:cur:%08x<S2SV_blank>next:%08x<S2SV_blank>status:%08x<S2SV_blank>frag1:%08x<S2SV_blank>frag0:%08x"" , i , ( u32 ) ( np -> tx_ring_dma + i * sizeof ( * desc ) ) , ( u32 ) le64_to_cpu ( desc -> next_desc ) , ( u32 ) le64_to_cpu ( desc -> status ) , ( u32 ) ( le64_to_cpu ( desc -> fraginfo ) >> 32 ) , ( u32 ) le64_to_cpu ( desc -> fraginfo ) ) ; printk ( ""\\n"" ) ; } printk ( ""\\n"" ) ; break ; default : return - EOPNOTSUPP ; } return 0 ; }
","<S2SV_ModStart> ) ; struct mii_ioctl_data <S2SV_ModEnd> * miidata = <S2SV_ModStart> * miidata = if_mii ( rq ) <S2SV_ModEnd> ; phy_addr = <S2SV_ModStart> ) { case SIOCGMIIPHY : miidata -> phy_id = phy_addr ; <S2SV_ModEnd> break ; case <S2SV_ModStart> break ; case SIOCGMIIREG <S2SV_ModEnd> : miidata -> <S2SV_ModStart> : miidata -> val_out <S2SV_ModEnd> = mii_read ( <S2SV_ModStart> break ; case SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_ModEnd> mii_write ( dev <S2SV_ModStart> , miidata -> val_in <S2SV_ModEnd> ) ; break
",torvalds@linux/1bb57e940e1958e40d51f2078f50c3a96a9b2d75,CVE-2012-2313,https://github.com/torvalds/linux/commit/1bb57e940e1958e40d51f2078f50c3a96a9b2d75,2012-06-13T10:24Z,"<S2SV_StartBug> struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE : <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 1 : <S2SV_EndBug> <S2SV_StartBug> miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 2 : <S2SV_EndBug> <S2SV_StartBug> mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ; <S2SV_EndBug>"
610,CWE-119,"u32 h264bsdInit ( storage_t * pStorage , u32 noOutputReordering ) { u32 size ; ASSERT ( pStorage ) ; h264bsdInitStorage ( pStorage ) ; size = ( sizeof ( macroblockLayer_t ) + 63 ) & ~ 0x3F ; <S2SV_StartBug> pStorage -> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size ) ; <S2SV_EndBug> if ( ! pStorage -> mbLayer ) return HANTRO_NOK ; if ( noOutputReordering ) pStorage -> noReordering = HANTRO_TRUE ; return HANTRO_OK ; }
","<S2SV_ModStart> H264SwDecMalloc ( size , 1
",frameworks@av/2b6f22dc64d456471a1dc6df09d515771d1427c8,CVE-2016-2463,https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8,2016-06-13T01:59Z,<S2SV_StartBug> pStorage -> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size ) ; <S2SV_EndBug>
8042,CWE-000,"int sqlite3Select ( Parse * pParse , Select * p , SelectDest * pDest ) { int i , j ; WhereInfo * pWInfo ; Vdbe * v ; int isAgg ; ExprList * pEList = 0 ; SrcList * pTabList ; Expr * pWhere ; ExprList * pGroupBy ; Expr * pHaving ; int rc = 1 ; DistinctCtx sDistinct ; SortCtx sSort ; AggInfo sAggInfo ; int iEnd ; sqlite3 * db ; ExprList * pMinMaxOrderBy = 0 ; u8 minMaxFlag ; db = pParse -> db ; v = sqlite3GetVdbe ( pParse ) ; if ( p == 0 || db -> mallocFailed || pParse -> nErr ) { return 1 ; } if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) ) return 1 ; memset ( & sAggInfo , 0 , sizeof ( sAggInfo ) ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 1 , pParse , p , ( ""begin<S2SV_blank>processing:\\n"" , pParse -> addrExplain ) ) ; if ( sqlite3SelectTrace & 0x100 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ) ; if ( IgnorableOrderby ( pDest ) ) { assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ) ; sqlite3ExprListDelete ( db , p -> pOrderBy ) ; p -> pOrderBy = 0 ; p -> selFlags &= ~ SF_Distinct ; } sqlite3SelectPrep ( pParse , p , 0 ) ; if ( pParse -> nErr || db -> mallocFailed ) { goto select_end ; } assert ( p -> pEList != 0 ) ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x104 ) { SELECTTRACE ( 0x104 , pParse , p , ( ""after<S2SV_blank>name<S2SV_blank>resolution:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( pDest -> eDest == SRT_Output ) { generateColumnNames ( pParse , p ) ; } # ifndef SQLITE_OMIT_WINDOWFUNC if ( sqlite3WindowRewrite ( pParse , p ) ) { goto select_end ; } # if SELECTTRACE_ENABLED if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 ) { SELECTTRACE ( 0x104 , pParse , p , ( ""after<S2SV_blank>window<S2SV_blank>rewrite:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif # endif pTabList = p -> pSrc ; isAgg = ( p -> selFlags & SF_Aggregate ) != 0 ; memset ( & sSort , 0 , sizeof ( sSort ) ) ; sSort . pOrderBy = p -> pOrderBy ; # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) for ( i = 0 ; ! p -> pPrior && i < pTabList -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pTabList -> a [ i ] ; Select * pSub = pItem -> pSelect ; Table * pTab = pItem -> pTab ; if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) ) { SELECTTRACE ( 0x100 , pParse , p , ( ""LEFT-JOIN<S2SV_blank>simplifies<S2SV_blank>to<S2SV_blank>JOIN<S2SV_blank>on<S2SV_blank>term<S2SV_blank>%d\\n"" , i ) ) ; pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ) ; unsetJoinExpr ( p -> pWhere , pItem -> iCursor ) ; } if ( pSub == 0 ) continue ; if ( pTab -> nCol != pSub -> pEList -> nExpr ) { sqlite3ErrorMsg ( pParse , ""expected<S2SV_blank>%d<S2SV_blank>columns<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%d"" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ) ; goto select_end ; } if ( ( pSub -> selFlags & SF_Aggregate ) != 0 ) continue ; assert ( pSub -> pGroupBy == 0 ) ; if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) ) { continue ; } if ( flattenSubquery ( pParse , p , i , isAgg ) ) { if ( pParse -> nErr ) goto select_end ; i = - 1 ; } pTabList = p -> pSrc ; if ( db -> mallocFailed ) goto select_end ; if ( ! IgnorableOrderby ( pDest ) ) { sSort . pOrderBy = p -> pOrderBy ; } } # endif # ifndef SQLITE_OMIT_COMPOUND_SELECT if ( p -> pPrior ) { rc = multiSelect ( pParse , p , pDest ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 0x1 , pParse , p , ( ""end<S2SV_blank>compound-select<S2SV_blank>processing\\n"" ) ) ; if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( p -> pNext == 0 ) ExplainQueryPlanPop ( pParse ) ; return rc ; } # endif if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) ) { # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x100 ) { SELECTTRACE ( 0x100 , pParse , p , ( ""After<S2SV_blank>constant<S2SV_blank>propagation:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } else { SELECTTRACE ( 0x100 , pParse , p , ( ""Constant<S2SV_blank>propagation<S2SV_blank>not<S2SV_blank>helpful\\n"" ) ) ; } # ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) ) { if ( db -> mallocFailed ) goto select_end ; pEList = p -> pEList ; pTabList = p -> pSrc ; } # endif for ( i = 0 ; i < pTabList -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pTabList -> a [ i ] ; SelectDest dest ; Select * pSub ; # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) const char * zSavedAuthContext ; # endif if ( pItem -> colUsed == 0 && pItem -> zName != 0 ) { sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , """" , pItem -> zDatabase ) ; } # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) pSub = pItem -> pSelect ; if ( pSub == 0 ) continue ; testcase ( pItem -> addrFillSub != 0 ) ; pParse -> nHeight += sqlite3SelectExprHeight ( p ) ; if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) ) { # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x100 ) { SELECTTRACE ( 0x100 , pParse , p , ( ""After<S2SV_blank>WHERE-clause<S2SV_blank>push-down<S2SV_blank>into<S2SV_blank>subquery<S2SV_blank>%d:\\n"" , pSub -> selId ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } else { SELECTTRACE ( 0x100 , pParse , p , ( ""Push-down<S2SV_blank>not<S2SV_blank>possible\\n"" ) ) ; } zSavedAuthContext = pParse -> zAuthContext ; pParse -> zAuthContext = pItem -> zName ; if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) ) { int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; pItem -> regReturn = ++ pParse -> nMem ; sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ) ; VdbeComment ( ( v , ""%s"" , pItem -> pTab -> zName ) ) ; pItem -> addrFillSub = addrTop ; sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ) ; ExplainQueryPlan ( ( pParse , 1 , ""CO-ROUTINE<S2SV_blank>%u"" , pSub -> selId ) ) ; sqlite3Select ( pParse , pSub , & dest ) ; pItem -> pTab -> nRowLogEst = pSub -> nSelectRow ; pItem -> fg . viaCoroutine = 1 ; pItem -> regResult = dest . iSdst ; sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ) ; sqlite3VdbeJumpHere ( v , addrTop - 1 ) ; sqlite3ClearTempRegCache ( pParse ) ; } else { int topAddr ; int onceAddr = 0 ; int retAddr ; struct SrcList_item * pPrior ; testcase ( pItem -> addrFillSub == 0 ) ; pItem -> regReturn = ++ pParse -> nMem ; topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ) ; pItem -> addrFillSub = topAddr + 1 ; if ( pItem -> fg . isCorrelated == 0 ) { onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , ""materialize<S2SV_blank>\\""%s\\"""" , pItem -> pTab -> zName ) ) ; } else { VdbeNoopComment ( ( v , ""materialize<S2SV_blank>\\""%s\\"""" , pItem -> pTab -> zName ) ) ; } pPrior = isSelfJoinView ( pTabList , pItem ) ; if ( pPrior ) { sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ) ; assert ( pPrior -> pSelect != 0 ) ; pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow ; } else { sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ) ; ExplainQueryPlan ( ( pParse , 1 , ""MATERIALIZE<S2SV_blank>%u"" , pSub -> selId ) ) ; sqlite3Select ( pParse , pSub , & dest ) ; } pItem -> pTab -> nRowLogEst = pSub -> nSelectRow ; if ( onceAddr ) sqlite3VdbeJumpHere ( v , onceAddr ) ; retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ) ; VdbeComment ( ( v , ""end<S2SV_blank>%s"" , pItem -> pTab -> zName ) ) ; sqlite3VdbeChangeP1 ( v , topAddr , retAddr ) ; sqlite3ClearTempRegCache ( pParse ) ; } if ( db -> mallocFailed ) goto select_end ; pParse -> nHeight -= sqlite3SelectExprHeight ( p ) ; pParse -> zAuthContext = zSavedAuthContext ; # endif } pEList = p -> pEList ; pWhere = p -> pWhere ; pGroupBy = p -> pGroupBy ; pHaving = p -> pHaving ; sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0 ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { SELECTTRACE ( 0x400 , pParse , p , ( ""After<S2SV_blank>all<S2SV_blank>FROM-clause<S2SV_blank>analysis:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 <S2SV_StartBug> ) { <S2SV_EndBug> p -> selFlags &= ~ SF_Distinct ; pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ) ; assert ( sDistinct . isTnct ) ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { SELECTTRACE ( 0x400 , pParse , p , ( ""Transform<S2SV_blank>DISTINCT<S2SV_blank>into<S2SV_blank>GROUP<S2SV_blank>BY:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } if ( sSort . pOrderBy ) { KeyInfo * pKeyInfo ; pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ) ; sSort . iECursor = pParse -> nTab ++ ; sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ) ; } else { sSort . addrSortIndex = - 1 ; } if ( pDest -> eDest == SRT_EphemTab ) { sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ) ; } iEnd = sqlite3VdbeMakeLabel ( pParse ) ; if ( ( p -> selFlags & SF_FixedLimit ) == 0 ) { p -> nSelectRow = 320 ; } computeLimitRegisters ( pParse , p , iEnd ) ; if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 ) { sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ) ; sSort . sortFlags |= SORTFLAG_UseSorter ; } if ( p -> selFlags & SF_Distinct ) { sDistinct . tabTnct = pParse -> nTab ++ ; sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ) ; sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ) ; sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED ; } else { sDistinct . eTnctType = WHERE_DISTINCT_NOOP ; } if ( ! isAgg && pGroupBy == 0 ) { u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; # ifndef SQLITE_OMIT_WINDOWFUNC Window * pWin = p -> pWin ; if ( pWin ) { sqlite3WindowCodeInit ( pParse , pWin ) ; } # endif assert ( WHERE_USE_LIMIT == SF_FixedLimit ) ; SELECTTRACE ( 1 , pParse , p , ( ""WhereBegin\\n"" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ) ; if ( pWInfo == 0 ) goto select_end ; if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow ) { p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ) ; } if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) ) { sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ) ; } if ( sSort . pOrderBy ) { sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ) ; sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ) ; if ( sSort . nOBSat == sSort . pOrderBy -> nExpr ) { sSort . pOrderBy = 0 ; } } if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 ) { sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ) ; } assert ( p -> pEList == pEList ) ; # ifndef SQLITE_OMIT_WINDOWFUNC if ( pWin ) { int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; int iCont = sqlite3VdbeMakeLabel ( pParse ) ; int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; int regGosub = ++ pParse -> nMem ; sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ) ; sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ) ; sqlite3VdbeResolveLabel ( v , addrGosub ) ; VdbeNoopComment ( ( v , ""inner-loop<S2SV_blank>subroutine"" ) ) ; sSort . labelOBLopt = 0 ; selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ) ; sqlite3VdbeResolveLabel ( v , iCont ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ) ; VdbeComment ( ( v , ""end<S2SV_blank>inner-loop<S2SV_blank>subroutine"" ) ) ; sqlite3VdbeResolveLabel ( v , iBreak ) ; } else # endif { selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ) ; sqlite3WhereEnd ( pWInfo ) ; } } else { NameContext sNC ; int iAMem ; int iBMem ; int iUseFlag ; int iAbortFlag ; int groupBySort ; int addrEnd ; int sortPTab = 0 ; int sortOut = 0 ; int orderByGrp = 0 ; if ( pGroupBy ) { int k ; struct ExprList_item * pItem ; for ( k = p -> pEList -> nExpr , pItem = p -> pEList -> a ; k > 0 ; k -- , pItem ++ ) { pItem -> u . x . iAlias = 0 ; } for ( k = pGroupBy -> nExpr , pItem = pGroupBy -> a ; k > 0 ; k -- , pItem ++ ) { pItem -> u . x . iAlias = 0 ; } assert ( 66 == sqlite3LogEst ( 100 ) ) ; if ( p -> nSelectRow > 66 ) p -> nSelectRow = 66 ; if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr ) { int ii ; for ( ii = 0 ; ii < pGroupBy -> nExpr ; ii ++ ) { u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; pGroupBy -> a [ ii ] . sortFlags = sortFlags ; } if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 ) { orderByGrp = 1 ; } } } else { assert ( 0 == sqlite3LogEst ( 1 ) ) ; p -> nSelectRow = 0 ; } addrEnd = sqlite3VdbeMakeLabel ( pParse ) ; memset ( & sNC , 0 , sizeof ( sNC ) ) ; sNC . pParse = pParse ; sNC . pSrcList = pTabList ; sNC . uNC . pAggInfo = & sAggInfo ; VVA_ONLY ( sNC . ncFlags = NC_UAggInfo ; ) sAggInfo . mnReg = pParse -> nMem + 1 ; sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0 ; sAggInfo . pGroupBy = pGroupBy ; sqlite3ExprAnalyzeAggList ( & sNC , pEList ) ; sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ) ; if ( pHaving ) { if ( pGroupBy ) { assert ( pWhere == p -> pWhere ) ; assert ( pHaving == p -> pHaving ) ; assert ( pGroupBy == p -> pGroupBy ) ; havingToWhere ( pParse , p ) ; pWhere = p -> pWhere ; } sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ) ; } sAggInfo . nAccumulator = sAggInfo . nColumn ; if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 ) { minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ) ; } else { minMaxFlag = WHERE_ORDERBY_NORMAL ; } for ( i = 0 ; i < sAggInfo . nFunc ; i ++ ) { Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; sNC . ncFlags |= NC_InAggFunc ; sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ) ; # ifndef SQLITE_OMIT_WINDOWFUNC assert ( ! IsWindowFunc ( pExpr ) ) ; if ( ExprHasProperty ( pExpr , EP_WinFunc ) ) { sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ) ; } # endif sNC . ncFlags &= ~ NC_InAggFunc ; } sAggInfo . mxReg = pParse -> nMem ; if ( db -> mallocFailed ) goto select_end ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { int ii ; SELECTTRACE ( 0x400 , pParse , p , ( ""After<S2SV_blank>aggregate<S2SV_blank>analysis:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; for ( ii = 0 ; ii < sAggInfo . nColumn ; ii ++ ) { sqlite3DebugPrintf ( ""agg-column[%d]<S2SV_blank>iMem=%d\\n"" , ii , sAggInfo . aCol [ ii ] . iMem ) ; sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ) ; } for ( ii = 0 ; ii < sAggInfo . nFunc ; ii ++ ) { sqlite3DebugPrintf ( ""agg-func[%d]:<S2SV_blank>iMem=%d\\n"" , ii , sAggInfo . aFunc [ ii ] . iMem ) ; sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ) ; } } # endif if ( pGroupBy ) { KeyInfo * pKeyInfo ; int addr1 ; int addrOutputRow ; int regOutputRow ; int addrSetAbort ; int addrTopOfLoop ; int addrSortingIdx ; int addrReset ; int regReset ; sAggInfo . sortingIdx = pParse -> nTab ++ ; pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ) ; addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ) ; iUseFlag = ++ pParse -> nMem ; iAbortFlag = ++ pParse -> nMem ; regOutputRow = ++ pParse -> nMem ; addrOutputRow = sqlite3VdbeMakeLabel ( pParse ) ; regReset = ++ pParse -> nMem ; addrReset = sqlite3VdbeMakeLabel ( pParse ) ; iAMem = pParse -> nMem + 1 ; pParse -> nMem += pGroupBy -> nExpr ; iBMem = pParse -> nMem + 1 ; pParse -> nMem += pGroupBy -> nExpr ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ) ; VdbeComment ( ( v , ""clear<S2SV_blank>abort<S2SV_blank>flag"" ) ) ; sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ) ; SELECTTRACE ( 1 , pParse , p , ( ""WhereBegin\\n"" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ) ; if ( pWInfo == 0 ) goto select_end ; if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr ) { groupBySort = 0 ; } else { int regBase ; int regRecord ; int nCol ; int nGroupBy ; explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? ""DISTINCT"" : ""GROUP<S2SV_blank>BY"" ) ; groupBySort = 1 ; nGroupBy = pGroupBy -> nExpr ; nCol = nGroupBy ; j = nGroupBy ; for ( i = 0 ; i < sAggInfo . nColumn ; i ++ ) { if ( sAggInfo . aCol [ i ] . iSorterColumn >= j ) { nCol ++ ; j ++ ; } } regBase = sqlite3GetTempRange ( pParse , nCol ) ; sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ) ; j = nGroupBy ; for ( i = 0 ; i < sAggInfo . nColumn ; i ++ ) { struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; if ( pCol -> iSorterColumn >= j ) { int r1 = j + regBase ; sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ) ; j ++ ; } } regRecord = sqlite3GetTempReg ( pParse ) ; sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ) ; sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ) ; sqlite3ReleaseTempReg ( pParse , regRecord ) ; sqlite3ReleaseTempRange ( pParse , regBase , nCol ) ; sqlite3WhereEnd ( pWInfo ) ; sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++ ; sortOut = sqlite3GetTempReg ( pParse ) ; sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ) ; sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ) ; VdbeComment ( ( v , ""GROUP<S2SV_blank>BY<S2SV_blank>sort"" ) ) ; VdbeCoverage ( v ) ; sAggInfo . useSortingIdx = 1 ; } if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) ) { sSort . pOrderBy = 0 ; sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ) ; } addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ) ; if ( groupBySort ) { sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ) ; } for ( j = 0 ; j < pGroupBy -> nExpr ; j ++ ) { if ( groupBySort ) { sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ) ; } else { sAggInfo . directMode = 1 ; sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ) ; } } sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ) ; addr1 = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ) ; VdbeCoverage ( v ) ; sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ) ; VdbeComment ( ( v , ""output<S2SV_blank>one<S2SV_blank>row"" ) ) ; sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , ""check<S2SV_blank>abort<S2SV_blank>flag"" ) ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ) ; VdbeComment ( ( v , ""reset<S2SV_blank>accumulator"" ) ) ; sqlite3VdbeJumpHere ( v , addr1 ) ; updateAccumulator ( pParse , iUseFlag , & sAggInfo ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ) ; VdbeComment ( ( v , ""indicate<S2SV_blank>data<S2SV_blank>in<S2SV_blank>accumulator"" ) ) ; if ( groupBySort ) { sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ) ; VdbeCoverage ( v ) ; } else { sqlite3WhereEnd ( pWInfo ) ; sqlite3VdbeChangeToNoop ( v , addrSortingIdx ) ; } sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ) ; VdbeComment ( ( v , ""output<S2SV_blank>final<S2SV_blank>row"" ) ) ; sqlite3VdbeGoto ( v , addrEnd ) ; addrSetAbort = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ) ; VdbeComment ( ( v , ""set<S2SV_blank>abort<S2SV_blank>flag"" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; sqlite3VdbeResolveLabel ( v , addrOutputRow ) ; addrOutputRow = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , ""Groupby<S2SV_blank>result<S2SV_blank>generator<S2SV_blank>entry<S2SV_blank>point"" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; finalizeAggFunctions ( pParse , & sAggInfo ) ; sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ) ; selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; VdbeComment ( ( v , ""end<S2SV_blank>groupby<S2SV_blank>result<S2SV_blank>generator"" ) ) ; sqlite3VdbeResolveLabel ( v , addrReset ) ; resetAccumulator ( pParse , & sAggInfo ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ) ; VdbeComment ( ( v , ""indicate<S2SV_blank>accumulator<S2SV_blank>empty"" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regReset ) ; } else { # ifndef SQLITE_OMIT_BTREECOUNT Table * pTab ; if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 ) { const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; const int iCsr = pParse -> nTab ++ ; Index * pIdx ; KeyInfo * pKeyInfo = 0 ; Index * pBest = 0 ; int iRoot = pTab -> tnum ; sqlite3CodeVerifySchema ( pParse , iDb ) ; sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ) ; if ( ! HasRowid ( pTab ) ) pBest = sqlite3PrimaryKeyIndex ( pTab ) ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) ) { pBest = pIdx ; } } if ( pBest ) { iRoot = pBest -> tnum ; pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ) ; } sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ) ; if ( pKeyInfo ) { sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ) ; } sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ) ; sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ) ; explainSimpleCount ( pParse , pTab , pBest ) ; } else # endif { int regAcc = 0 ; if ( sAggInfo . nAccumulator ) { for ( i = 0 ; i < sAggInfo . nFunc ; i ++ ) { if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) ) continue ; if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) break ; } if ( i == sAggInfo . nFunc ) { regAcc = ++ pParse -> nMem ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ) ; } } assert ( p -> pGroupBy == 0 ) ; resetAccumulator ( pParse , & sAggInfo ) ; assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ) ; assert ( pMinMaxOrderBy == 0 || pMinMaxOrderBy -> nExpr == 1 ) ; SELECTTRACE ( 1 , pParse , p , ( ""WhereBegin\\n"" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ) ; if ( pWInfo == 0 ) { goto select_end ; } updateAccumulator ( pParse , regAcc , & sAggInfo ) ; if ( regAcc ) sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ) ; if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 ) { sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ) ; VdbeComment ( ( v , ""%s()<S2SV_blank>by<S2SV_blank>index"" , ( minMaxFlag == WHERE_ORDERBY_MIN ? ""min"" : ""max"" ) ) ) ; } sqlite3WhereEnd ( pWInfo ) ; finalizeAggFunctions ( pParse , & sAggInfo ) ; } sSort . pOrderBy = 0 ; sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ) ; selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ) ; } sqlite3VdbeResolveLabel ( v , addrEnd ) ; } if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED ) { explainTempTable ( pParse , ""DISTINCT"" ) ; } if ( sSort . pOrderBy ) { explainTempTable ( pParse , sSort . nOBSat > 0 ? ""RIGHT<S2SV_blank>PART<S2SV_blank>OF<S2SV_blank>ORDER<S2SV_blank>BY"" : ""ORDER<S2SV_blank>BY"" ) ; assert ( p -> pEList == pEList ) ; generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ) ; } sqlite3VdbeResolveLabel ( v , iEnd ) ; rc = ( pParse -> nErr > 0 ) ; select_end : sqlite3ExprListDelete ( db , pMinMaxOrderBy ) ; sqlite3DbFree ( db , sAggInfo . aCol ) ; sqlite3DbFree ( db , sAggInfo . aFunc ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 0x1 , pParse , p , ( ""end<S2SV_blank>processing\\n"" ) ) ; if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif ExplainQueryPlanPop ( pParse ) ; return rc ; }
","<S2SV_ModStart> ) == 0 && p -> pWin == 0
",sqlite@sqlite/e59c562b3f6894f84c715772c4b116d7b5c01348,CVE-2019-19244,https://github.com/sqlite/sqlite/commit/e59c562b3f6894f84c715772c4b116d7b5c01348,2019-11-25T20:15Z,<S2SV_StartBug> ) { <S2SV_EndBug>
1807,CWE-119,"<S2SV_StartBug> static int get_minq_index ( double maxq , double x3 , double x2 , double x1 ) { <S2SV_EndBug> int i ; const double minqtarget = MIN ( ( ( x3 * maxq + x2 ) * maxq + x1 ) * maxq , maxq ) ; if ( minqtarget <= 2.0 ) return 0 ; <S2SV_StartBug> for ( i = 0 ; i < QINDEX_RANGE ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( minqtarget <= vp9_convert_qindex_to_q ( i ) ) <S2SV_EndBug> <S2SV_StartBug> return i ; <S2SV_EndBug> return QINDEX_RANGE - 1 ; }
","<S2SV_ModStart> , double x1 , vpx_bit_depth_t bit_depth <S2SV_ModStart> i ++ ) { <S2SV_ModStart> vp9_convert_qindex_to_q ( i , bit_depth <S2SV_ModStart> return i ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> static int get_minq_index ( double maxq , double x3 , double x2 , double x1 ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < QINDEX_RANGE ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( minqtarget <= vp9_convert_qindex_to_q ( i ) ) <S2SV_EndBug> <S2SV_StartBug> return i ; <S2SV_EndBug>"
1492,CWE-119,"static int vp8_rdcost_mby ( MACROBLOCK * mb ) { int cost = 0 ; int b ; MACROBLOCKD * x = & mb -> e_mbd ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; <S2SV_StartBug> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; for ( b = 0 ; b < 16 ; b ++ ) cost += cost_coeffs ( mb , x -> block + b , PLANE_TYPE_Y_NO_DC , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; cost += cost_coeffs ( mb , x -> block + 24 , PLANE_TYPE_Y2 , ta + vp8_block2above [ 24 ] , tl + vp8_block2left [ 24 ] ) ; return cost ; }
","<S2SV_ModStart> * tl ; memcpy <S2SV_ModEnd> ( & t_above <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & t_left
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug>"
3486,CWE-264,"<S2SV_StartBug> int xt_check_entry_offsets ( const void * base , <S2SV_EndBug> unsigned int target_offset , unsigned int next_offset ) { <S2SV_StartBug> const struct xt_entry_target * t ; <S2SV_EndBug> <S2SV_StartBug> const char * e = base ; <S2SV_EndBug> if ( target_offset + sizeof ( * t ) > next_offset ) return - EINVAL ; t = ( void * ) ( e + target_offset ) ; if ( t -> u . target_size < sizeof ( * t ) ) return - EINVAL ; if ( target_offset + t -> u . target_size > next_offset ) return - EINVAL ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) == 0 && target_offset + sizeof ( struct xt_standard_target ) != next_offset ) return - EINVAL ; return 0 ; }
","<S2SV_ModStart> void * base , const char * elems <S2SV_ModStart> next_offset ) { long size_of_base_struct = elems - ( const char * ) base ; <S2SV_ModStart> e = base ; if ( target_offset < size_of_base_struct ) return - EINVAL
",torvalds@linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,CVE-2016-4997,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,2016-07-03T21:59Z,"<S2SV_StartBug> int xt_check_entry_offsets ( const void * base , <S2SV_EndBug> <S2SV_StartBug> const struct xt_entry_target * t ; <S2SV_EndBug> <S2SV_StartBug> const char * e = base ; <S2SV_EndBug>"
4509,CWE-125,"dfa * Ta3Grammar_FindDFA ( grammar * g , int type ) { dfa * d ; # if 1 d = & g -> g_dfa [ type - NT_OFFSET ] ; assert ( d -> d_type == type ) ; return d ; # else int i ; for ( i = g -> g_ndfas , d = g -> g_dfa ; -- i >= 0 ; d ++ ) { if ( d -> d_type == type ) return d ; } <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> # endif }
","<S2SV_ModStart> d ; } abort ( <S2SV_ModEnd> ) ; #
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug>
1415,CWE-119,"static void init_encode_frame_mb_context ( VP8_COMP * cpi ) { MACROBLOCK * const x = & cpi -> mb ; VP8_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; x -> gf_active_ptr = ( signed char * ) cpi -> gf_active_flags ; x -> mb_activity_ptr = cpi -> mb_activity_map ; x -> act_zbin_adj = 0 ; x -> partition_info = x -> pi ; xd -> mode_info_context = cm -> mi ; xd -> mode_info_stride = cm -> mode_info_stride ; xd -> frame_type = cm -> frame_type ; if ( cm -> frame_type == KEY_FRAME ) vp8_init_mbmode_probs ( cm ) ; x -> src = * cpi -> Source ; xd -> pre = cm -> yv12_fb [ cm -> lst_fb_idx ] ; xd -> dst = cm -> yv12_fb [ cm -> new_fb_idx ] ; vp8_setup_intra_recon ( & cm -> yv12_fb [ cm -> new_fb_idx ] ) ; vp8_build_block_offsets ( x ) ; xd -> mode_info_context -> mbmi . mode = DC_PRED ; xd -> mode_info_context -> mbmi . uv_mode = DC_PRED ; xd -> left_context = & cm -> left_context ; x -> mvc = cm -> fc . mvc ; <S2SV_StartBug> vpx_memset ( cm -> above_context , 0 , <S2SV_EndBug> sizeof ( ENTROPY_CONTEXT_PLANES ) * cm -> mb_cols ) ; if ( cpi -> ref_frame_flags == VP8_LAST_FRAME ) vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , 255 , 128 ) ; else if ( ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags == VP8_GOLD_FRAME ) ) vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , 1 , 255 ) ; else if ( ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags == VP8_ALTR_FRAME ) ) vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , 1 , 1 ) ; else vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , cpi -> prob_last_coded , cpi -> prob_gf_coded ) ; xd -> fullpixel_mask = 0xffffffff ; if ( cm -> full_pixel ) xd -> fullpixel_mask = 0xfffffff8 ; vp8_zero ( x -> coef_counts ) ; vp8_zero ( x -> ymode_count ) ; vp8_zero ( x -> uv_mode_count ) x -> prediction_error = 0 ; x -> intra_error = 0 ; vp8_zero ( x -> count_mb_ref_frame_usage ) ; }
","<S2SV_ModStart> . mvc ; memset <S2SV_ModEnd> ( cm ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,"<S2SV_StartBug> vpx_memset ( cm -> above_context , 0 , <S2SV_EndBug>"
3565,CWE-400,"static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( IS_MNT_NEW ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = CL_MAKE_SHARED ; } else { struct mount * n , * p ; bool done ; for ( n = m ; ; n = p ) { p = n -> mnt_master ; if ( p == dest_master || IS_MNT_MARKED ( p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; type = CL_SLAVE ; if ( IS_MNT_SHARED ( m ) ) type |= CL_MAKE_SHARED ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) return PTR_ERR ( child ) ; child -> mnt . mnt_flags &= ~ MNT_LOCKED ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; SET_MNT_MARK ( m -> mnt_master ) ; read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; return count_mounts ( m -> mnt_ns , child ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z,<S2SV_StartBug> return 0 ; <S2SV_EndBug>
3644,CWE-125,"static inline signed short ReadPropertyMSBShort ( const unsigned char * * p , size_t * length ) { union { unsigned short unsigned_value ; signed short signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 2 ] ; unsigned short value ; if ( * length < 2 ) return ( ( unsigned short ) ~ 0 ) ; for ( i = 0 ; i < 2 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } <S2SV_StartBug> value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }
","<S2SV_ModStart> unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 8 <S2SV_ModEnd> ; value |= <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ; return (
",ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5842,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z,<S2SV_StartBug> value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug>
2550,CWE-189,"static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; <S2SV_StartBug> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ; ue -> card = card ; ue -> info = * info ; ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }
","<S2SV_ModStart> ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <S2SV_ModEnd> card -> user_ctl_count <S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; memcpy (
",torvalds@linux/82262a46627bebb0febcc26664746c25cef08563,CVE-2014-4655,https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563,2014-07-03T04:22Z,<S2SV_StartBug> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug>
8119,CWE-295,"int options_cmdline ( char * arg1 , char * arg2 ) { char * name ; CONF_TYPE type ; # ifdef USE_WIN32 ( void ) arg2 ; # endif if ( ! arg1 ) { name = # ifdef CONFDIR CONFDIR # ifdef USE_WIN32 ""\\\\"" # else ""/"" # endif # endif ""stunnel.conf"" ; type = CONF_FILE ; } else if ( ! strcasecmp ( arg1 , ""-help"" ) ) { <S2SV_StartBug> parse_global_option ( CMD_PRINT_HELP , NULL , NULL ) ; <S2SV_EndBug> parse_service_option ( CMD_PRINT_HELP , NULL , NULL , NULL ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-version"" ) ) { <S2SV_StartBug> parse_global_option ( CMD_PRINT_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug> parse_service_option ( CMD_PRINT_DEFAULTS , NULL , NULL , NULL ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-sockets"" ) ) { socket_options_print ( ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-options"" ) ) { print_ssl_options ( ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else # ifndef USE_WIN32 if ( ! strcasecmp ( arg1 , ""-fd"" ) ) { if ( ! arg2 ) { s_log ( LOG_ERR , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>specified"" ) ; print_syntax ( ) ; return 1 ; } name = arg2 ; type = CONF_FD ; } else # endif { name = arg1 ; type = CONF_FILE ; } if ( type == CONF_FILE ) { # ifdef HAVE_REALPATH char * real_path = NULL ; # ifdef MAXPATHLEN real_path = malloc ( MAXPATHLEN ) ; # endif real_path = realpath ( name , real_path ) ; if ( ! real_path ) { s_log ( LOG_ERR , ""Invalid<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>name<S2SV_blank>\\""%s\\"""" , name ) ; ioerror ( ""realpath"" ) ; return 1 ; } configuration_file = str_dup ( real_path ) ; free ( real_path ) ; # else configuration_file = str_dup ( name ) ; # endif # ifndef USE_WIN32 } else if ( type == CONF_FD ) { configuration_file = str_dup ( name ) ; # endif } return options_parse ( type ) ; }
","<S2SV_ModStart> NULL , NULL , NULL <S2SV_ModStart> parse_global_option ( CMD_PRINT_DEFAULTS , NULL
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,"<S2SV_StartBug> parse_global_option ( CMD_PRINT_HELP , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> parse_global_option ( CMD_PRINT_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug>"
2935,CWE-20,"static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s"" , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> name ) ; if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ;
",git@git/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,CVE-2018-17456,https://github.com/git/git/commit/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,2018-10-06T14:29Z,<S2SV_StartBug> free ( name ) ; <S2SV_EndBug>
1866,CWE-119,"static void down2_symodd ( const uint8_t * const input , int length , uint8_t * output ) { <S2SV_StartBug> static const int16_t * filter = vp9_down2_symodd_half_filter ; <S2SV_EndBug> const int filter_len_half = sizeof ( vp9_down2_symodd_half_filter ) / 2 ; int i , j ; uint8_t * optr = output ; int l1 = filter_len_half - 1 ; int l2 = ( length - filter_len_half + 1 ) ; l1 += ( l1 & 1 ) ; l2 += ( l2 & 1 ) ; if ( l1 > l2 ) { for ( i = 0 ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ ( i + j >= length ? length - 1 : i + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } else { for ( i = 0 ; i < l1 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ i + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < l2 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ i + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ ( i + j >= length ? length - 1 : i + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } }
","<S2SV_ModStart> output ) { <S2SV_ModEnd> const int16_t *
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,<S2SV_StartBug> static const int16_t * filter = vp9_down2_symodd_half_filter ; <S2SV_EndBug>
3156,CWE-119,"int add_packetdata ( struct mt_packet * packet , unsigned char * data , unsigned short length ) { <S2SV_StartBug> if ( packet -> size + length > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"" ) , MT_PACKET_LEN ) ; return - 1 ; } memcpy ( packet -> data + packet -> size , data , length ) ; packet -> size += length ; return length ; }
","<S2SV_ModStart> { if ( length > MT_PACKET_LEN - <S2SV_ModStart> packet -> size <S2SV_ModEnd> ) { fprintf
",haakonnessjoen@MAC-Telnet/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,CVE-2016-7115,https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,2016-08-30T17:59Z,<S2SV_StartBug> if ( packet -> size + length > MT_PACKET_LEN ) { <S2SV_EndBug>
2608,CWE-125,"void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u"" , dp -> icmp_type == ICMP_ECHO ? ""request"" : ""reply"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , ""#%d<S2SV_blank>%%s<S2SV_blank>unreachable"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , ""redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , ""router<S2SV_blank>advertisement"" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , ""<S2SV_blank>lifetime<S2SV_blank>"" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u"" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u"" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u:%02u"" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>%d:"" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>[size<S2SV_blank>%d]"" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>{%s<S2SV_blank>%u}"" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = ""time<S2SV_blank>exceeded<S2SV_blank>in-transit"" ; break ; case ICMP_TIMXCEED_REASS : str = ""ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded"" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>exceeded-#%d"" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%d"" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%d"" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>recv<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>xmit<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , ""type-#%d"" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , ""ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , icmp_sum ; if ( ND_TTEST2 ( * bp , plen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ; if ( sum != 0 ) { icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)"" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; ip = ( const struct ip * ) bp ; <S2SV_StartBug> snapend_save = ndo -> ndo_snapend ; <S2SV_EndBug> ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ; if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , ""\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u"" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? ""in"" : """" , hlen ) ) ; } hlen -= 4 ; obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( icmp_mpls_ext_obj_values , ""unknown"" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u"" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp]"" ) ) ; }
","<S2SV_ModStart> ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len )
",the-tcpdump-group@tcpdump/8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b,CVE-2017-13012,https://github.com/the-tcpdump-group/tcpdump/commit/8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b,2017-09-14T06:29Z,<S2SV_StartBug> snapend_save = ndo -> ndo_snapend ; <S2SV_EndBug>
7052,CWE-476,"static GF_AV1Config * AV1_DuplicateConfig ( GF_AV1Config const * const cfg ) { u32 i = 0 ; GF_AV1Config * out = gf_malloc ( sizeof ( GF_AV1Config ) ) ; out -> marker = cfg -> marker ; out -> version = cfg -> version ; out -> seq_profile = cfg -> seq_profile ; out -> seq_level_idx_0 = cfg -> seq_level_idx_0 ; out -> seq_tier_0 = cfg -> seq_tier_0 ; out -> high_bitdepth = cfg -> high_bitdepth ; out -> twelve_bit = cfg -> twelve_bit ; out -> monochrome = cfg -> monochrome ; out -> chroma_subsampling_x = cfg -> chroma_subsampling_x ; out -> chroma_subsampling_y = cfg -> chroma_subsampling_y ; out -> chroma_sample_position = cfg -> chroma_sample_position ; out -> initial_presentation_delay_present = cfg -> initial_presentation_delay_present ; out -> initial_presentation_delay_minus_one = cfg -> initial_presentation_delay_minus_one ; out -> obu_array = gf_list_new ( ) ; for ( i = 0 ; i < gf_list_count ( cfg -> obu_array ) ; ++ i ) { GF_AV1_OBUArrayEntry * dst = gf_malloc ( sizeof ( GF_AV1_OBUArrayEntry ) ) , * src = gf_list_get ( cfg -> obu_array , i ) ; dst -> obu_length = src -> obu_length ; dst -> obu_type = src -> obu_type ; dst -> obu = gf_malloc ( ( size_t ) dst -> obu_length ) ; memcpy ( dst -> obu , src -> obu , ( size_t ) src -> obu_length ) ; gf_list_add ( out -> obu_array , dst ) ; } return out ; }
","
",gpac@gpac/b2eab95e07cb5819375a50358d4806a8813b6e50,CVE-2021-31262,https://github.com/gpac/gpac/commit/b2eab95e07cb5819375a50358d4806a8813b6e50,2021-04-19T19:15Z,
7836,CWE-20,"error_t rawSocketReceiveIpPacket ( Socket * socket , SocketMsg * message , uint_t flags ) { error_t error ; SocketQueueItem * queueItem ; if ( ( flags & SOCKET_FLAG_DONT_WAIT ) == 0 ) { if ( socket -> receiveQueue == NULL ) { socket -> eventMask = SOCKET_EVENT_RX_READY ; osResetEvent ( & socket -> event ) ; osReleaseMutex ( & netMutex ) ; osWaitForEvent ( & socket -> event , socket -> timeout ) ; osAcquireMutex ( & netMutex ) ; } } if ( socket -> receiveQueue != NULL ) { queueItem = socket -> receiveQueue ; message -> length = netBufferRead ( message -> data , queueItem -> buffer , queueItem -> offset , message -> size ) ; <S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug> message -> srcPort = queueItem -> srcPort ; message -> destIpAddr = queueItem -> destIpAddr ; message -> ttl = queueItem -> ancillary . ttl ; # if ( ETH_SUPPORT == ENABLED ) message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ; message -> destMacAddr = queueItem -> ancillary . destMacAddr ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) message -> switchPort = queueItem -> ancillary . port ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) message -> timestamp = queueItem -> ancillary . timestamp ; # endif if ( ( flags & SOCKET_FLAG_PEEK ) == 0 ) { socket -> receiveQueue = queueItem -> next ; netBufferFree ( queueItem -> buffer ) ; } rawSocketUpdateEvents ( socket ) ; error = NO_ERROR ; } else { message -> length = 0 ; error = ERROR_TIMEOUT ; } return error ; }
","<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug>
6170,CWE-772,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; <S2SV_StartBug> } <S2SV_EndBug> clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> ) ; } quantum_info = ( QuantumInfo * ) NULL ; <S2SV_ModStart> BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL )
",ImageMagick@ImageMagick/79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20,CVE-2017-13146,https://github.com/ImageMagick/ImageMagick/commit/79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20,2017-08-23T06:29Z,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug>
