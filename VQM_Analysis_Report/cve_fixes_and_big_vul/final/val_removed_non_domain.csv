index,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,localization_target
3667,CWE-119,"bool f2fs_init_extent_tree ( struct inode * inode , struct f2fs_extent * i_ext ) { struct f2fs_sb_info * sbi = f2fs_i_sb ( inode ) ; struct extent_tree * et ; struct extent_node * en ; struct extent_info ei ; if ( ! f2fs_may_extent_tree ( inode ) ) { if ( i_ext && i_ext -> len ) { i_ext -> len = 0 ; return true ; } return false ; } et = __grab_extent_tree ( inode ) ; if ( ! i_ext || ! i_ext -> len ) return false ; get_extent_info ( & ei , i_ext ) ; write_lock ( & et -> lock ) ; if ( atomic_read ( & et -> node_cnt ) ) goto out ; en = __init_extent_tree ( sbi , et , & ei ) ; if ( en ) { spin_lock ( & sbi -> extent_lock ) ; list_add_tail ( & en -> list , & sbi -> extent_list ) ; spin_unlock ( & sbi -> extent_lock ) ; } out : write_unlock ( & et -> lock ) ; return false ; }","<S2SV_ModStart> i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/dad48e73127ba10279ea33e6dbc8d3905c4d31c0,CVE-2017-18193,https://github.com/torvalds/linux/commit/dad48e73127ba10279ea33e6dbc8d3905c4d31c0,2018-02-22T15:29Z,<S2SV_StartBug> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i_ext || ! i_ext -> len ) <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug>
7005,CWE-400,"static void listdir ( unsigned int depth , int f , void * const tls_fd , const char * name ) { purefileinfo * dir ; char * names ; purefileinfo * s ; purefileinfo * r ; int d ; if ( depth >= max_ls_depth || matches >= max_ls_files ) { return ; } if ( ( dir = sreaddir ( & names ) ) == null ) { addreply ( 226 , msg_cant_read_file , name ) ; return ; } s = dir ; while ( s -> name_offset != ( size_t ) - 1 ) { d = 0 ; if ( fi_name ( s ) [ 0 ] != '.' ) { d = listfile ( s , null ) ; } else if ( opt_a ) { if ( fi_name ( s ) [ 1 ] == 0 || ( fi_name ( s ) [ 1 ] == '.' && fi_name ( s ) [ 2 ] == 0 ) ) { listfile ( s , null ) ; } else { d = listfile ( s , null ) ; } } if ( ! d ) { s -> name_offset = ( size_t ) - 1 ; } s ++ ; } outputfiles ( f , tls_fd ) ; r = dir ; while ( opt_r && r != s ) { if ( r -> name_offset != ( size_t ) - 1 && ! chdir ( fi_name ( r ) ) ) { char * alloca_subdir ; const size_t sizeof_subdir = path_max + 1u ; if ( ( alloca_subdir = alloca ( sizeof_subdir ) ) == null ) { goto toomany ; } if ( sncheck ( snprintf ( alloca_subdir , sizeof_subdir , ""%s/%s"" , name , fi_name ( r ) ) , sizeof_subdir ) ) { goto nolist ; } wrstr ( f , tls_fd , ""\\r\\n\\r\\n"" ) ; wrstr ( f , tls_fd , alloca_subdir ) ; wrstr ( f , tls_fd , "":\\r\\n\\r\\n"" ) ; listdir ( depth + 1u , f , tls_fd , alloca_subdir ) ; nolist : alloca_free ( alloca_subdir ) ; if ( matches >= max_ls_files ) { goto toomany ; } if ( chdir ( "".."" ) ) { if ( chdir ( wd ) || chdir ( name ) ) { die ( 421 , log_err , ""chdir:<s2sv_blank>%s"" , strerror ( errno ) ) ; } } } r ++ ; } toomany : free ( names ) ; free ( dir ) ; names = null ; }","<S2SV_ModStart> PureFileInfo * r ; char * alloca_subdir ; size_t sizeof_subdir <S2SV_ModStart> = dir ; sizeof_subdir = PATH_MAX + 1U ; if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) { goto toomany ; } <S2SV_ModStart> ) ) { <S2SV_ModEnd> if ( SNCHECK <S2SV_ModStart> ; nolist : <S2SV_ModEnd> if ( matches <S2SV_ModStart> } toomany : ALLOCA_FREE ( alloca_subdir ) ;
",jedisct1@pure-ftpd/aea56f4bcb9948d456f3fae4d044fd3fa2e19706,CVE-2019-20176,https://github.com/jedisct1/pure-ftpd/commit/aea56f4bcb9948d456f3fae4d044fd3fa2e19706,2019-12-31T15:15Z,<S2SV_StartBug> PureFileInfo * r ; <S2SV_EndBug> <S2SV_StartBug> while ( opt_R && r != s ) { <S2SV_EndBug> <S2SV_StartBug> char * alloca_subdir ; <S2SV_EndBug> <S2SV_StartBug> ALLOCA_FREE ( alloca_subdir ) ; <S2SV_EndBug> <S2SV_StartBug> free ( names ) ; <S2SV_EndBug>
8415,CWE-125,"int mutt_seqset_iterator_next ( struct seqsetiterator * iter , unsigned int * next ) { if ( ! iter || ! next ) return - 1 ; if ( iter -> in_range ) { if ( ( iter -> down && ( iter -> range_cur == ( iter -> range_end - 1 ) ) ) || ( ! iter -> down && ( iter -> range_cur == ( iter -> range_end + 1 ) ) ) ) { iter -> in_range = 0 ; } } if ( ! iter -> in_range ) { iter -> substr_cur = iter -> substr_end ; if ( iter -> substr_cur == iter -> eostr ) return 1 ; while ( ! * ( iter -> substr_cur ) ) iter -> substr_cur ++ ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ) = '\\0' ; char * range_sep = strchr ( iter -> substr_cur , ':' ) ; if ( range_sep ) * range_sep ++ = '\\0' ; if ( mutt_str_atoui ( iter -> substr_cur , & iter -> range_cur ) != 0 ) return - 1 ; if ( range_sep ) { if ( mutt_str_atoui ( range_sep , & iter -> range_end ) != 0 ) return - 1 ; } else iter -> range_end = iter -> range_cur ; iter -> down = ( iter -> range_end < iter -> range_cur ) ; iter -> in_range = 1 ; } * next = iter -> range_cur ; if ( iter -> down ) iter -> range_cur -- ; else iter -> range_cur ++ ; return 0 ; }","<S2SV_ModStart> return 1 ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ++ <S2SV_ModEnd> ) = '\\0'
",neomutt@neomutt/fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc,CVE-2021-32055,https://github.com/neomutt/neomutt/commit/fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc,2021-05-05T16:15Z,<S2SV_StartBug> while ( ! * ( iter -> substr_cur ) ) <S2SV_EndBug>
3305,CWE-119,"static int wdm_post_reset ( struct usb_interface * intf ) { struct wdm_device * desc = wdm_find_device ( intf ) ; int rv ; clear_bit ( wdm_resetting , & desc -> flags ) ; rv = recover_from_urb_loss ( desc ) ; mutex_unlock ( & desc -> wlock ) ; mutex_unlock ( & desc -> rlock ) ; return 0 ; }","<S2SV_ModStart> ; int rv ; clear_bit ( WDM_OVERFLOW , & desc -> flags )
",torvalds@linux/c0f5ecee4e741667b2493c742b60b6218d40b3aa,CVE-2013-1860,https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa,2013-03-22T11:59Z,<S2SV_StartBug> int rv ; <S2SV_EndBug>
65,CWE-362,"static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - efault ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - einval ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( uffdio_register_mode_missing | uffdio_register_mode_wp ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & uffdio_register_mode_missing ) vm_flags |= vm_uffd_missing ; if ( uffdio_register . mode & uffdio_register_mode_wp ) { vm_flags |= vm_uffd_wp ; ret = - einval ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - enomem ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - einval ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; bug_on ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( vm_uffd_missing | vm_uffd_wp ) ) ) ; ret = - einval ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - eperm ; if ( unlikely ( ! ( cur -> vm_flags & vm_maywrite ) ) ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - einval ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - ebusy ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } bug_on ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; bug_on ( ! vma_can_userfault ( vma ) ) ; bug_on ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; warn_on ( ! ( vma -> vm_flags & vm_maywrite ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? uffd_api_range_ioctls_basic : uffd_api_range_ioctls , & user_uffdio_register -> ioctls ) ) ret = - efault ; } out : return ret ; }","<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock
",torvalds@linux/04f5866e41fb70690e28397487d8bd8eea7d712a,CVE-2019-11599,https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a,2019-04-29T18:29Z,<S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug>
4941,CWE-617,"static void pci_lintr_route ( struct pci_vdev * dev ) { struct businfo * bi ; struct intxinfo * ii ; if ( dev -> lintr . pin == 0 ) return ; bi = pci_businfo [ dev -> bus ] ; assert ( bi != null ) ; ii = & bi -> slotinfo [ dev -> slot ] . si_intpins [ dev -> lintr . pin - 1 ] ; if ( ii -> ii_ioapic_irq == 0 ) ii -> ii_ioapic_irq = ioapic_pci_alloc_irq ( dev ) ; assert ( ii -> ii_ioapic_irq > 0 ) ; if ( ii -> ii_pirq_pin == 0 ) ii -> ii_pirq_pin = pirq_alloc_pin ( dev ) ; assert ( ii -> ii_pirq_pin > 0 ) ; dev -> lintr . ioapic_irq = ii -> ii_ioapic_irq ; dev -> lintr . pirq_pin = ii -> ii_pirq_pin ; pci_set_cfgdata8 ( dev , pcir_intline , pirq_irq ( ii -> ii_pirq_pin ) ) ; }","<S2SV_ModStart> bus ] ; if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> ii = & <S2SV_ModStart> dev ) ; <S2SV_ModEnd> if ( ii <S2SV_ModStart> pirq_alloc_pin ( dev <S2SV_ModEnd> ) ; dev
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,<S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ii -> ii_ioapic_irq > 0 ) ; <S2SV_EndBug> <S2SV_StartBug> ii -> ii_pirq_pin = pirq_alloc_pin ( dev ) ; <S2SV_EndBug>
4665,CWE-787,"int pdf_is_pdf ( file * fp ) { int is_pdf ; char * header ; header = get_header ( fp ) ; if ( header && strstr ( header , ""%pdf-"" ) ) is_pdf = 1 ; else is_pdf = 0 ; free ( header ) ; return is_pdf ; }","<S2SV_ModStart> fp ) { <S2SV_ModEnd> char * header <S2SV_ModStart> * header ; if ( ! ( <S2SV_ModStart> ( fp ) ) ) return 0 ; const char * c = <S2SV_ModEnd> strstr ( header <S2SV_ModStart> , ""%PDF-"" ) ; const int is_pdf = c && ( ( c - header + strlen ( ""%PDF-M.m"" ) ) < 1024 ) <S2SV_ModEnd> ; free (
",enferex@pdfresurrect/1b422459f07353adce2878806d5247d9e91fb397,CVE-2020-20740,https://github.com/enferex/pdfresurrect/commit/1b422459f07353adce2878806d5247d9e91fb397,2020-11-20T19:15Z,"<S2SV_StartBug> int is_pdf ; <S2SV_EndBug> <S2SV_StartBug> header = get_header ( fp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( header && strstr ( header , ""%PDF-"" ) ) <S2SV_EndBug>"
6339,CWE-772,"gpols_ret * get_pols_2_svc ( gpols_arg * arg , struct svc_req * rqstp ) { static gpols_ret ret ; char * prime_arg ; gss_buffer_desc client_name , service_name ; om_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = null ; xdr_free ( xdr_gpols_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = kadm5_failure ; goto exit_func ; } prime_arg = arg -> exp ; if ( prime_arg == null ) prime_arg = ""*"" ; if ( changepw_service ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , acl_list , null , null ) ) { ret . code = kadm5_auth_list ; log_unauth ( ""kadm5_get_policies"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_policies ( ( void * ) handle , arg -> exp , & ret . pols , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_policies"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != null ) krb5_free_error_message ( handle -> context , errmsg ) ; } gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug>"
4641,CWE-190,"static bcon_error_t bson_append_bcon_with_state ( bson * b , const bcon * bc , bcon_state_t start_state ) { bcon_error_t ret = bcon_ok ; bcon_state_t state = start_state ; char * key = 0 ; char * typespec = 0 ; unsigned char doc_stack [ doc_stack_size ] ; size_t doc_stack_pointer = 0 ; size_t array_index = 0 ; unsigned int array_index_stack [ array_index_stack_size ] ; size_t array_index_stack_pointer = 0 ; char array_index_buffer [ array_index_buffer_size ] ; int end_of_data ; const bcon * bcp ; for ( end_of_data = 0 , bcp = bc ; ret == bcon_ok && ! end_of_data ; bcp ++ ) { bcon bci = * bcp ; char * s = bci . s ; switch ( state ) { case state_element : switch ( bcon_token ( s ) ) { case token_closebrace : bson_append_finish_object ( b ) ; doc_pop_state ; break ; case token_end : end_of_data = 1 ; break ; default : key = s ; state = state_docspecvalue ; break ; } break ; case state_docspecvalue : switch ( bcon_token ( s ) ) { case token_typespec : typespec = s ; state = state_docvalue ; break ; case token_openbrace : bson_append_start_object ( b , key ) ; doc_push_state ( state_element ) ; state = state_element ; break ; case token_openbracket : bson_append_start_array ( b , key ) ; array_push_reset_index_state ( state_element ) ; state = state_arrayspecvalue ; break ; case token_end : end_of_data = 1 ; break ; default : ret = bson_bcon_key_value ( b , key , typespec , bci ) ; state = state_element ; break ; } break ; case state_docvalue : ret = bson_bcon_key_value ( b , key , typespec , bci ) ; state = state_element ; typespec = 0 ; break ; case state_arrayspecvalue : switch ( bcon_token ( s ) ) { case token_typespec : typespec = s ; state = state_arrayvalue ; break ; case token_openbrace : key = array_key_string ( array_index ++ ) ; bson_append_start_object ( b , key ) ; doc_push_state ( state_arrayspecvalue ) ; state = state_element ; break ; case token_openbracket : key = array_key_string ( array_index ++ ) ; bson_append_start_array ( b , key ) ; array_push_reset_index_state ( state_arrayspecvalue ) ; break ; case token_closebracket : bson_append_finish_array ( b ) ; array_pop_index_state ; break ; case token_end : end_of_data = 1 ; break ; default : key = array_key_string ( array_index ++ ) ; ret = bson_bcon_key_value ( b , key , typespec , bci ) ; break ; } break ; case state_arrayvalue : key = array_key_string ( array_index ++ ) ; ret = bson_bcon_key_value ( b , key , typespec , bci ) ; state = state_arrayspecvalue ; typespec = 0 ; break ; default : assert ( not_reached ) ; break ; } } return state == start_state ? bcon_ok : bcon_document_incomplete ; }","<S2SV_ModStart> = 0 ; size_t <S2SV_ModEnd> array_index_stack [ ARRAY_INDEX_STACK_SIZE
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,<S2SV_StartBug> unsigned int array_index_stack [ ARRAY_INDEX_STACK_SIZE ] ; <S2SV_EndBug>
2226,CWE-189,"static int efx_register_netdev ( struct efx_nic * efx ) { struct net_device * net_dev = efx -> net_dev ; struct efx_channel * channel ; int rc ; net_dev -> watchdog_timeo = 5 * hz ; net_dev -> irq = efx -> pci_dev -> irq ; net_dev -> netdev_ops = & efx_netdev_ops ; set_ethtool_ops ( net_dev , & efx_ethtool_ops ) ; efx -> mac_op -> update_stats ( efx ) ; memset ( & efx -> mac_stats , 0 , sizeof ( efx -> mac_stats ) ) ; rtnl_lock ( ) ; rc = dev_alloc_name ( net_dev , net_dev -> name ) ; if ( rc < 0 ) goto fail_locked ; efx_update_name ( efx ) ; rc = register_netdevice ( net_dev ) ; if ( rc ) goto fail_locked ; efx_for_each_channel ( channel , efx ) { struct efx_tx_queue * tx_queue ; efx_for_each_channel_tx_queue ( tx_queue , channel ) efx_init_tx_queue_core_txq ( tx_queue ) ; } netif_carrier_off ( efx -> net_dev ) ; rtnl_unlock ( ) ; rc = device_create_file ( & efx -> pci_dev -> dev , & dev_attr_phy_type ) ; if ( rc ) { netif_err ( efx , drv , efx -> net_dev , ""failed<s2sv_blank>to<s2sv_blank>init<s2sv_blank>net<s2sv_blank>dev<s2sv_blank>attributes\\n"" ) ; goto fail_registered ; } return 0 ; fail_locked : rtnl_unlock ( ) ; netif_err ( efx , drv , efx -> net_dev , ""could<s2sv_blank>not<s2sv_blank>register<s2sv_blank>net<s2sv_blank>dev\\n"" ) ; return rc ; fail_registered : unregister_netdev ( net_dev ) ; return rc ; }","<S2SV_ModStart> efx_ethtool_ops ) ; net_dev -> gso_max_segs = EFX_TSO_MAX_SEGS ;
",torvalds@linux/68cb695ccecf949d48949e72f8ce591fdaaa325c,CVE-2012-3412,https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c,2012-10-03T11:02Z,<S2SV_StartBug> efx -> mac_op -> update_stats ( efx ) ; <S2SV_EndBug>
3239,CWE-200,"int udpv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = is_udplite ( sk ) ; int is_udp4 ; bool slow ; if ( addr_len ) * addr_len = sizeof ( struct sockaddr_in6 ) ; if ( flags & msg_errqueue ) return ipv6_recv_error ( sk , msg , len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? msg_dontwait : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= msg_trunc ; is_udp4 = ( skb -> protocol == htons ( eth_p_ip ) ) ; if ( copied < ulen || udp_skb_cb ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov , copied ) ; else { err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov ) ; if ( err == - einval ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) udp_inc_stats_user ( sock_net ( sk ) , udp_mib_inerrors , is_udplite ) ; else udp6_inc_stats_user ( sock_net ( sk ) , udp_mib_inerrors , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) udp_inc_stats_user ( sock_net ( sk ) , udp_mib_indatagrams , is_udplite ) ; else udp6_inc_stats_user ( sock_net ( sk ) , udp_mib_indatagrams , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { struct sockaddr_in6 * sin6 ; sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; sin6 -> sin6_family = af_inet6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , ip6cb ( skb ) -> iif ) ; } } if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & msg_trunc ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { udp_inc_stats_user ( sock_net ( sk ) , udp_mib_csumerrors , is_udplite ) ; udp_inc_stats_user ( sock_net ( sk ) , udp_mib_inerrors , is_udplite ) ; } else { udp6_inc_stats_user ( sock_net ( sk ) , udp_mib_csumerrors , is_udplite ) ; udp6_inc_stats_user ( sock_net ( sk ) , udp_mib_inerrors , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; if ( noblock ) return - eagain ; msg -> msg_flags &= ~ msg_trunc ; goto try_again ; }","<S2SV_ModStart> ; bool slow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } * addr_len = sizeof ( * sin6 ) ;
",torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69,CVE-2013-7281,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,2014-01-08T16:55Z,<S2SV_StartBug> bool slow ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
4090,CWE-200,"static int rfcomm_get_dev_list ( void __user * arg ) { struct rfcomm_dev * dev ; struct rfcomm_dev_list_req * dl ; struct rfcomm_dev_info * di ; int n = 0 , size , err ; u16 dev_num ; bt_dbg ( """" ) ; if ( get_user ( dev_num , ( u16 __user * ) arg ) ) return - efault ; if ( ! dev_num || dev_num > ( page_size * 4 ) / sizeof ( * di ) ) return - einval ; size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ; dl = kmalloc ( size , gfp_kernel ) ; if ( ! dl ) return - enomem ; di = dl -> dev_info ; spin_lock ( & rfcomm_dev_lock ) ; list_for_each_entry ( dev , & rfcomm_dev_list , list ) { if ( test_bit ( rfcomm_tty_released , & dev -> flags ) ) continue ; ( di + n ) -> id = dev -> id ; ( di + n ) -> flags = dev -> flags ; ( di + n ) -> state = dev -> dlc -> state ; ( di + n ) -> channel = dev -> channel ; bacpy ( & ( di + n ) -> src , & dev -> src ) ; bacpy ( & ( di + n ) -> dst , & dev -> dst ) ; if ( ++ n >= dev_num ) break ; } spin_unlock ( & rfcomm_dev_lock ) ; dl -> dev_num = n ; size = sizeof ( * dl ) + n * sizeof ( * di ) ; err = copy_to_user ( arg , dl , size ) ; kfree ( dl ) ; return err ? - efault : 0 ; }","<S2SV_ModStart> ; dl = kzalloc <S2SV_ModEnd> ( size ,
",torvalds@linux/f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a,CVE-2012-6545,https://github.com/torvalds/linux/commit/f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a,2013-03-15T20:55Z,"<S2SV_StartBug> dl = kmalloc ( size , GFP_KERNEL ) ; <S2SV_EndBug>"
7475,CWE-476,"vterm * vterm_new_with_allocator ( int rows , int cols , vtermallocatorfunctions * funcs , void * allocdata ) { vterm * vt = ( * funcs -> malloc ) ( sizeof ( vterm ) , allocdata ) ; vt -> allocator = funcs ; vt -> allocdata = allocdata ; vt -> rows = rows ; vt -> cols = cols ; vt -> parser . state = normal ; vt -> parser . callbacks = null ; vt -> parser . cbdata = null ; vt -> parser . strbuffer_len = 500 ; vt -> parser . strbuffer_cur = 0 ; vt -> parser . strbuffer = vterm_allocator_malloc ( vt , vt -> parser . strbuffer_len ) ; vt -> outbuffer_len = 200 ; vt -> outbuffer_cur = 0 ; vt -> outbuffer = vterm_allocator_malloc ( vt , vt -> outbuffer_len ) ; return vt ; }","<S2SV_ModStart> allocdata ) ; if ( vt == NULL ) return NULL ; <S2SV_ModStart> strbuffer_len ) ; if ( vt -> parser . strbuffer == NULL ) { vterm_allocator_free ( vt , vt ) ; return NULL ; } <S2SV_ModStart> outbuffer_len ) ; if ( vt -> outbuffer == NULL ) { vterm_allocator_free ( vt , vt -> parser . strbuffer ) ; vterm_allocator_free ( vt , vt ) ; return NULL ; }
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,"<S2SV_StartBug> vt -> allocator = funcs ; <S2SV_EndBug> <S2SV_StartBug> vt -> outbuffer_len = 200 ; <S2SV_EndBug> <S2SV_StartBug> vt -> outbuffer = vterm_allocator_malloc ( vt , vt -> outbuffer_len ) ; <S2SV_EndBug>"
3751,CWE-20,"static int rose_parse_ccitt ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char l , n = 0 ; char callsign [ 11 ] ; do { switch ( * p & 0xc0 ) { case 0x00 : p += 2 ; n += 2 ; len -= 2 ; break ; case 0x40 : p += 3 ; n += 3 ; len -= 3 ; break ; case 0x80 : p += 4 ; n += 4 ; len -= 4 ; break ; case 0xc0 : l = p [ 1 ] ; if ( l < 10 || l > 20 ) return - 1 ; if ( * p == fac_ccitt_dest_nsap ) { memcpy ( & facilities -> source_addr , p + 7 , rose_addr_len ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> source_call , callsign ) ; } if ( * p == fac_ccitt_src_nsap ) { memcpy ( & facilities -> dest_addr , p + 7 , rose_addr_len ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> dest_call , callsign ) ; } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }","<S2SV_ModStart> case 0x00 : if ( len < 2 ) return - 1 ; <S2SV_ModStart> case 0x40 : if ( len < 3 ) return - 1 ; <S2SV_ModStart> case 0x80 : if ( len < 4 ) return - 1 ; <S2SV_ModStart> case 0xC0 : if ( len < 2 ) return - 1 ;
",torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,CVE-2011-4914,https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,2012-06-21T23:55Z,<S2SV_StartBug> p += 2 ; <S2SV_EndBug> <S2SV_StartBug> p += 3 ; <S2SV_EndBug> <S2SV_StartBug> p += 4 ; <S2SV_EndBug> <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug>
7180,CWE-552,"static ssize_t _hostsock_readv ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( desc ) ; void * buf = null ; size_t buf_size = 0 ; if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > oe_iov_max ) oe_raise_errno ( oe_einval ) ; if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) oe_raise_errno ( oe_enomem ) ; if ( oe_syscall_recvv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != oe_ok ) { oe_raise_errno ( oe_einval ) ; } if ( ret > 0 ) { if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) oe_raise_errno ( oe_einval ) ; } done : if ( buf ) oe_free ( buf ) ; return ret ; }","<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ( ret > ( ssize_t ) ( data_size ) ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret >
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,"<S2SV_StartBug> if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret > 0 ) <S2SV_EndBug>"
905,CWE-119,static int hns_gmac_get_sset_count ( int stringset ) { if ( stringset == eth_ss_stats ) return array_size ( g_gmac_stats_string ) ; return 0 ; },"<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
",torvalds@linux/412b65d15a7f8a93794653968308fc100f2aa87c,CVE-2017-18222,https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c,2018-03-08T14:29Z,<S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug>
702,CWE-000,"static void sas_eh_finish_cmd ( struct scsi_cmnd * cmd ) { struct sas_ha_struct * sas_ha = shost_to_sas_ha ( cmd -> device -> host ) ; struct sas_task * task = to_sas_task ( cmd ) ; sas_end_task ( cmd , task ) ; scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; }","<S2SV_ModStart> ) ; struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> task ) ; if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; }
",torvalds@linux/318aaf34f1179b39fa9c30fa0f3288b645beee39,CVE-2018-10021,https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39,2018-04-11T17:29Z,"<S2SV_StartBug> struct sas_task * task = TO_SAS_TASK ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; <S2SV_EndBug>"
3133,CWE-125,"int smb2_negotiate ( const unsigned int xid , struct cifs_ses * ses ) { struct smb_rqst rqst ; struct smb2_negotiate_req * req ; struct smb2_negotiate_rsp * rsp ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; int rc = 0 ; int resp_buftype ; struct tcp_server_info * server = ses -> server ; int blob_offset , blob_length ; char * security_blob ; int flags = cifs_neg_op ; unsigned int total_len ; cifs_dbg ( fyi , ""negotiate<s2sv_blank>protocol\\n"" ) ; if ( ! server ) { warn ( 1 , ""%s:<s2sv_blank>server<s2sv_blank>is<s2sv_blank>null!\\n"" , __func__ ) ; return - eio ; } rc = smb2_plain_req_init ( smb2_negotiate , null , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; req -> sync_hdr . sessionid = 0 ; memset ( server -> preauth_sha_hash , 0 , smb2_preauth_hash_size ) ; memset ( ses -> preauth_sha_hash , 0 , smb2_preauth_hash_size ) ; if ( strcmp ( ses -> server -> vals -> version_string , smb3any_version_string ) == 0 ) { req -> dialects [ 0 ] = cpu_to_le16 ( smb30_prot_id ) ; req -> dialects [ 1 ] = cpu_to_le16 ( smb302_prot_id ) ; req -> dialectcount = cpu_to_le16 ( 2 ) ; total_len += 4 ; } else if ( strcmp ( ses -> server -> vals -> version_string , smbdefault_version_string ) == 0 ) { req -> dialects [ 0 ] = cpu_to_le16 ( smb21_prot_id ) ; req -> dialects [ 1 ] = cpu_to_le16 ( smb30_prot_id ) ; req -> dialects [ 2 ] = cpu_to_le16 ( smb302_prot_id ) ; req -> dialects [ 3 ] = cpu_to_le16 ( smb311_prot_id ) ; req -> dialectcount = cpu_to_le16 ( 4 ) ; total_len += 8 ; } else { req -> dialects [ 0 ] = cpu_to_le16 ( ses -> server -> vals -> protocol_id ) ; req -> dialectcount = cpu_to_le16 ( 1 ) ; total_len += 2 ; } if ( ses -> sign ) req -> securitymode = cpu_to_le16 ( smb2_negotiate_signing_required ) ; else if ( global_secflags & cifssec_may_sign ) req -> securitymode = cpu_to_le16 ( smb2_negotiate_signing_enabled ) ; else req -> securitymode = 0 ; req -> capabilities = cpu_to_le32 ( ses -> server -> vals -> req_capabilities ) ; if ( ses -> server -> vals -> protocol_id == smb20_prot_id ) memset ( req -> clientguid , 0 , smb2_client_guid_size ) ; else { memcpy ( req -> clientguid , server -> client_guid , smb2_client_guid_size ) ; if ( ( ses -> server -> vals -> protocol_id == smb311_prot_id ) || ( strcmp ( ses -> server -> vals -> version_string , smbdefault_version_string ) == 0 ) ) assemble_neg_contexts ( req , & total_len ) ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; cifs_small_buf_release ( req ) ; rsp = ( struct smb2_negotiate_rsp * ) rsp_iov . iov_base ; if ( rc == - eopnotsupp ) { cifs_dbg ( vfs , ""dialect<s2sv_blank>not<s2sv_blank>supported<s2sv_blank>by<s2sv_blank>server.<s2sv_blank>consider<s2sv_blank>"" ""specifying<s2sv_blank>vers=1.0<s2sv_blank>or<s2sv_blank>vers=2.0<s2sv_blank>on<s2sv_blank>mount<s2sv_blank>for<s2sv_blank>accessing"" ""<s2sv_blank>older<s2sv_blank>servers\\n"" ) ; goto neg_exit ; } else if ( rc != 0 ) goto neg_exit ; if ( strcmp ( ses -> server -> vals -> version_string , smb3any_version_string ) == 0 ) { if ( rsp -> dialectrevision == cpu_to_le16 ( smb20_prot_id ) ) { cifs_dbg ( vfs , ""smb2<s2sv_blank>dialect<s2sv_blank>returned<s2sv_blank>but<s2sv_blank>not<s2sv_blank>requested\\n"" ) ; return - eio ; } else if ( rsp -> dialectrevision == cpu_to_le16 ( smb21_prot_id ) ) { cifs_dbg ( vfs , ""smb2.1<s2sv_blank>dialect<s2sv_blank>returned<s2sv_blank>but<s2sv_blank>not<s2sv_blank>requested\\n"" ) ; return - eio ; } } else if ( strcmp ( ses -> server -> vals -> version_string , smbdefault_version_string ) == 0 ) { if ( rsp -> dialectrevision == cpu_to_le16 ( smb20_prot_id ) ) { cifs_dbg ( vfs , ""smb2<s2sv_blank>dialect<s2sv_blank>returned<s2sv_blank>but<s2sv_blank>not<s2sv_blank>requested\\n"" ) ; return - eio ; } else if ( rsp -> dialectrevision == cpu_to_le16 ( smb21_prot_id ) ) { ses -> server -> ops = & smb21_operations ; } else if ( rsp -> dialectrevision == cpu_to_le16 ( smb311_prot_id ) ) ses -> server -> ops = & smb311_operations ; } else if ( le16_to_cpu ( rsp -> dialectrevision ) != ses -> server -> vals -> protocol_id ) { cifs_dbg ( vfs , ""illegal<s2sv_blank>0x%x<s2sv_blank>dialect<s2sv_blank>returned:<s2sv_blank>not<s2sv_blank>requested\\n"" , le16_to_cpu ( rsp -> dialectrevision ) ) ; return - eio ; } cifs_dbg ( fyi , ""mode<s2sv_blank>0x%x\\n"" , rsp -> securitymode ) ; if ( rsp -> dialectrevision == cpu_to_le16 ( smb20_prot_id ) ) cifs_dbg ( fyi , ""negotiated<s2sv_blank>smb2.0<s2sv_blank>dialect\\n"" ) ; else if ( rsp -> dialectrevision == cpu_to_le16 ( smb21_prot_id ) ) cifs_dbg ( fyi , ""negotiated<s2sv_blank>smb2.1<s2sv_blank>dialect\\n"" ) ; else if ( rsp -> dialectrevision == cpu_to_le16 ( smb30_prot_id ) ) cifs_dbg ( fyi , ""negotiated<s2sv_blank>smb3.0<s2sv_blank>dialect\\n"" ) ; else if ( rsp -> dialectrevision == cpu_to_le16 ( smb302_prot_id ) ) cifs_dbg ( fyi , ""negotiated<s2sv_blank>smb3.02<s2sv_blank>dialect\\n"" ) ; else if ( rsp -> dialectrevision == cpu_to_le16 ( smb311_prot_id ) ) cifs_dbg ( fyi , ""negotiated<s2sv_blank>smb3.1.1<s2sv_blank>dialect\\n"" ) ; else { cifs_dbg ( vfs , ""illegal<s2sv_blank>dialect<s2sv_blank>returned<s2sv_blank>by<s2sv_blank>server<s2sv_blank>0x%x\\n"" , le16_to_cpu ( rsp -> dialectrevision ) ) ; rc = - eio ; goto neg_exit ; } server -> dialect = le16_to_cpu ( rsp -> dialectrevision ) ; memcpy ( server -> preauth_sha_hash , ses -> preauth_sha_hash , smb2_preauth_hash_size ) ; server -> negflavor = cifs_negflavor_extended ; server -> maxbuf = min_t ( unsigned int , le32_to_cpu ( rsp -> maxtransactsize ) , smb2_max_buffer_size ) ; server -> max_read = le32_to_cpu ( rsp -> maxreadsize ) ; server -> max_write = le32_to_cpu ( rsp -> maxwritesize ) ; server -> sec_mode = le16_to_cpu ( rsp -> securitymode ) ; if ( ( server -> sec_mode & smb2_sec_mode_flags_all ) != server -> sec_mode ) cifs_dbg ( fyi , ""server<s2sv_blank>returned<s2sv_blank>unexpected<s2sv_blank>security<s2sv_blank>mode<s2sv_blank>0x%x\\n"" , server -> sec_mode ) ; server -> capabilities = le32_to_cpu ( rsp -> capabilities ) ; server -> capabilities |= smb2_nt_find | smb2_large_files ; security_blob = smb2_get_data_area_len ( & blob_offset , & blob_length , ( struct smb2_sync_hdr * ) rsp ) ; if ( blob_length == 0 ) { cifs_dbg ( fyi , ""missing<s2sv_blank>security<s2sv_blank>blob<s2sv_blank>on<s2sv_blank>negprot\\n"" ) ; server -> sec_ntlmssp = true ; } rc = cifs_enable_signing ( server , ses -> sign ) ; if ( rc ) goto neg_exit ; if ( blob_length ) { rc = decode_negtokeninit ( security_blob , blob_length , server ) ; if ( rc == 1 ) rc = 0 ; else if ( rc == 0 ) rc = - eio ; } if ( rsp -> dialectrevision == cpu_to_le16 ( smb311_prot_id ) ) { if ( rsp -> negotiatecontextcount ) rc = smb311_decode_neg_context ( rsp , server , rsp_iov . iov_len ) ; else cifs_dbg ( vfs , ""missing<s2sv_blank>expected<s2sv_blank>negotiate<s2sv_blank>contexts\\n"" ) ; } neg_exit : free_rsp_buf ( resp_buftype , rsp ) ; return rc ; }","<S2SV_ModStart> & smb21_operations ; ses -> server -> vals = & smb21_values ; <S2SV_ModStart> SMB311_PROT_ID ) ) { <S2SV_ModStart> & smb311_operations ; ses -> server -> vals = & smb311_values ; }
",torvalds@linux/b57a55e2200ede754e4dc9cce4ba9402544b9365,CVE-2019-15918,https://github.com/torvalds/linux/commit/b57a55e2200ede754e4dc9cce4ba9402544b9365,2019-09-04T19:15Z,<S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug>
3198,CWE-362,"static int newque ( struct ipc_namespace * ns , struct ipc_params * params ) { struct msg_queue * msq ; int id , retval ; key_t key = params -> key ; int msgflg = params -> flg ; msq = ipc_rcu_alloc ( sizeof ( * msq ) ) ; if ( ! msq ) return - enomem ; msq -> q_perm . mode = msgflg & s_irwxugo ; msq -> q_perm . key = key ; msq -> q_perm . security = null ; retval = security_msg_queue_alloc ( msq ) ; if ( retval ) { ipc_rcu_putref ( msq , ipc_rcu_free ) ; return retval ; } id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ; if ( id < 0 ) { ipc_rcu_putref ( msq , msg_rcu_free ) ; return id ; } msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; init_list_head ( & msq -> q_messages ) ; init_list_head ( & msq -> q_receivers ) ; init_list_head ( & msq -> q_senders ) ; ipc_unlock_object ( & msq -> q_perm ) ; rcu_read_unlock ( ) ; return msq -> q_perm . id ; }","<S2SV_ModStart> retval ; } msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; <S2SV_ModStart> id ; } <S2SV_ModEnd> ipc_unlock_object ( &
",torvalds@linux/b9a532277938798b53178d5a66af6e2915cb27cf,CVE-2015-7613,https://github.com/torvalds/linux/commit/b9a532277938798b53178d5a66af6e2915cb27cf,2015-10-19T10:59Z,"<S2SV_StartBug> id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ; <S2SV_EndBug> <S2SV_StartBug> msq -> q_stime = msq -> q_rtime = 0 ; <S2SV_EndBug>"
3697,CWE-20,"long kernel_wait4 ( pid_t upid , int __user * stat_addr , int options , struct rusage * ru ) { struct wait_opts wo ; struct pid * pid = null ; enum pid_type type ; long ret ; if ( options & ~ ( wnohang | wuntraced | wcontinued | __wnothread | __wclone | __wall ) ) return - einval ; if ( upid == - 1 ) type = pidtype_max ; else if ( upid < 0 ) { type = pidtype_pgid ; pid = find_get_pid ( - upid ) ; } else if ( upid == 0 ) { type = pidtype_pgid ; pid = get_task_pid ( current , pidtype_pgid ) ; } else { type = pidtype_pid ; pid = find_get_pid ( upid ) ; } wo . wo_type = type ; wo . wo_pid = pid ; wo . wo_flags = options | wexited ; wo . wo_info = null ; wo . wo_stat = 0 ; wo . wo_rusage = ru ; ret = do_wait ( & wo ) ; put_pid ( pid ) ; if ( ret > 0 && stat_addr && put_user ( wo . wo_stat , stat_addr ) ) ret = - efault ; return ret ; }","<S2SV_ModStart> ( upid == INT_MIN ) return - ESRCH ; if ( upid ==
",torvalds@linux/dd83c161fbcc5d8be637ab159c0de015cbff5ba4,CVE-2018-10087,https://github.com/torvalds/linux/commit/dd83c161fbcc5d8be637ab159c0de015cbff5ba4,2018-04-13T13:29Z,<S2SV_StartBug> if ( upid == - 1 ) <S2SV_EndBug>
4108,CWE-190,"static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = futex_key_init , key2 = futex_key_init ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = null ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; define_wake_q ( wake_q ) ; if ( ! is_enabled ( config_futex_pi ) && requeue_pi ) return - enosys ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - einval ; if ( refill_pi_state_cache ( ) ) return - enomem ; if ( nr_wake != 1 ) return - einval ; } retry : ret = get_futex_key ( uaddr1 , flags & flags_shared , & key1 , verify_read ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & flags_shared , & key2 , requeue_pi ? verify_write : verify_read ) ; if ( unlikely ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - einval ; goto out_put_keys ; } hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != null ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & flags_shared ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - eagain ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { warn_on ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( uaddr2 , ret , hb2 , & key2 , & pi_state ) ; } switch ( ret ) { case 0 : break ; case - efault : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - eagain : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - einval ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { mark_wake_futex ( & wake_q , this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - einval ; break ; } if ( requeue_pi ) { get_pi_state ( pi_state ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = null ; put_pi_state ( pi_state ) ; break ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } put_pi_state ( pi_state ) ; out_unlock : double_unlock_hb ( hb1 , hb2 ) ; wake_up_q ( & wake_q ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : return ret ? ret : task_count ; }","<S2SV_ModStart> ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL
",torvalds@linux/fbe0e839d1e22d88810f3ee3e2f1479be4c0aa4a,CVE-2018-6927,https://github.com/torvalds/linux/commit/fbe0e839d1e22d88810f3ee3e2f1479be4c0aa4a,2018-02-12T19:29Z,<S2SV_StartBug> DEFINE_WAKE_Q ( wake_q ) ; <S2SV_EndBug>
3068,CWE-362,"int sctp_rcv ( struct sk_buff * skb ) { struct sock * sk ; struct sctp_association * asoc ; struct sctp_endpoint * ep = null ; struct sctp_ep_common * rcvr ; struct sctp_transport * transport = null ; struct sctp_chunk * chunk ; struct sctphdr * sh ; union sctp_addr src ; union sctp_addr dest ; int family ; struct sctp_af * af ; if ( skb -> pkt_type != packet_host ) goto discard_it ; sctp_inc_stats_bh ( sctp_mib_insctppacks ) ; if ( skb_linearize ( skb ) ) goto discard_it ; sh = sctp_hdr ( skb ) ; __skb_pull ( skb , skb_transport_offset ( skb ) ) ; if ( skb -> len < sizeof ( struct sctphdr ) ) goto discard_it ; if ( ! skb_csum_unnecessary ( skb ) && sctp_rcv_checksum ( skb ) < 0 ) goto discard_it ; skb_pull ( skb , sizeof ( struct sctphdr ) ) ; if ( skb -> len < sizeof ( struct sctp_chunkhdr ) ) goto discard_it ; family = ipver2af ( ip_hdr ( skb ) -> version ) ; af = sctp_get_af_specific ( family ) ; if ( unlikely ( ! af ) ) goto discard_it ; af -> from_skb ( & src , skb , 1 ) ; af -> from_skb ( & dest , skb , 0 ) ; if ( ! af -> addr_valid ( & src , null , skb ) || ! af -> addr_valid ( & dest , null , skb ) ) goto discard_it ; asoc = __sctp_rcv_lookup ( skb , & src , & dest , & transport ) ; if ( ! asoc ) ep = __sctp_rcv_lookup_endpoint ( & dest ) ; rcvr = asoc ? & asoc -> base : & ep -> base ; sk = rcvr -> sk ; if ( sk -> sk_bound_dev_if && ( sk -> sk_bound_dev_if != af -> skb_iif ( skb ) ) ) { if ( asoc ) { sctp_association_put ( asoc ) ; asoc = null ; } else { sctp_endpoint_put ( ep ) ; ep = null ; } sk = sctp_get_ctl_sock ( ) ; ep = sctp_sk ( sk ) -> ep ; sctp_endpoint_hold ( ep ) ; rcvr = & ep -> base ; } if ( ! asoc ) { if ( sctp_rcv_ootb ( skb ) ) { sctp_inc_stats_bh ( sctp_mib_outofblues ) ; goto discard_release ; } } if ( ! xfrm_policy_check ( sk , xfrm_policy_in , skb , family ) ) goto discard_release ; nf_reset ( skb ) ; if ( sk_filter ( sk , skb ) ) goto discard_release ; chunk = sctp_chunkify ( skb , asoc , sk ) ; if ( ! chunk ) goto discard_release ; sctp_input_cb ( skb ) -> chunk = chunk ; chunk -> rcvr = rcvr ; chunk -> sctp_hdr = sh ; sctp_init_addrs ( chunk , & src , & dest ) ; chunk -> transport = transport ; sctp_bh_lock_sock ( sk ) ; if ( sock_owned_by_user ( sk ) ) { sctp_inc_stats_bh ( sctp_mib_in_pkt_backlog ) ; sctp_add_backlog ( sk , skb ) ; } else { sctp_inc_stats_bh ( sctp_mib_in_pkt_softirq ) ; sctp_inq_push ( & chunk -> rcvr -> inqueue , chunk ) ; } sctp_bh_unlock_sock ( sk ) ; if ( asoc ) sctp_association_put ( asoc ) ; else sctp_endpoint_put ( ep ) ; return 0 ; discard_it : sctp_inc_stats_bh ( sctp_mib_in_pkt_discards ) ; kfree_skb ( skb ) ; return 0 ; discard_release : if ( asoc ) sctp_association_put ( asoc ) ; else sctp_endpoint_put ( ep ) ; goto discard_it ; }","<S2SV_ModStart> ; if ( sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if (
",torvalds@linux/ae53b5bd77719fed58086c5be60ce4f22bffe1c6,CVE-2011-4348,https://github.com/torvalds/linux/commit/ae53b5bd77719fed58086c5be60ce4f22bffe1c6,2013-06-08T13:05Z,<S2SV_StartBug> if ( sock_owned_by_user ( sk ) ) { <S2SV_EndBug>
4577,CWE-125,"static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { pyobject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg ; int i = start ; int j = 0 ; if ( kwonlyargs == null ) { ast_error ( c , child ( n , start ) , ""named<s2sv_blank>arguments<s2sv_blank>must<s2sv_blank>follow<s2sv_blank>bare<s2sv_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != null ) ; while ( i < nch ( n ) ) { ch = child ( n , i ) ; switch ( type ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < nch ( n ) && type ( child ( n , i + 1 ) ) == equal ) { expression = ast_for_expr ( c , child ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_set ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_set ( kwdefaults , j , null ) ; } if ( nch ( ch ) == 3 ) { annotation = ast_for_expr ( c , child ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = null ; } ch = child ( ch , 0 ) ; argname = new_identifier ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , null , lineno ( ch ) , ch -> n_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_set ( kwonlyargs , j ++ , arg ) ; i += 1 ; if ( i < nch ( n ) && type ( child ( n , i ) ) == comma ) i += 1 ; break ; case type_comment : arg -> type_comment = new_type_comment ( ch ) ; i += 1 ; break ; case doublestar : return i ; default : ast_error ( c , ch , ""unexpected<s2sv_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }","<S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug>"
5816,CWE-000,"static int ext4_ext_convert_to_initialized ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path ) { struct ext4_extent * ex , newex , orig_ex ; struct ext4_extent * ex1 = null ; struct ext4_extent * ex2 = null ; struct ext4_extent * ex3 = null ; struct ext4_extent_header * eh ; ext4_lblk_t ee_block , eof_block ; unsigned int allocated , ee_len , depth ; ext4_fsblk_t newblock ; int err = 0 ; int ret = 0 ; int may_zeroout ; ext_debug ( ""ext4_ext_convert_to_initialized:<s2sv_blank>inode<s2sv_blank>%lu,<s2sv_blank>logical"" ""block<s2sv_blank>%llu,<s2sv_blank>max_blocks<s2sv_blank>%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len ) ; eof_block = ( inode -> i_size + inode -> i_sb -> s_blocksize - 1 ) >> inode -> i_sb -> s_blocksize_bits ; if ( eof_block < map -> m_lblk + map -> m_len ) eof_block = map -> m_lblk + map -> m_len ; depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; allocated = ee_len - ( map -> m_lblk - ee_block ) ; newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ; ex2 = ex ; orig_ex . ee_block = ex -> ee_block ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_store_pblock ( & orig_ex , ext4_ext_pblock ( ex ) ) ; may_zeroout = ee_block + ee_len <= eof_block ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; if ( ee_len <= 2 * ext4_ext_zero_len && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } if ( map -> m_lblk > ee_block ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } if ( ! ex1 && allocated > map -> m_len ) ex2 -> ee_len = cpu_to_le16 ( map -> m_len ) ; if ( allocated > map -> m_len ) { unsigned int newdepth ; if ( allocated <= ext4_ext_zero_len && may_zeroout ) { ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = cpu_to_le16 ( ee_len - allocated ) ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; ex3 = & newex ; ex3 -> ee_block = cpu_to_le32 ( map -> m_lblk ) ; ext4_ext_store_pblock ( ex3 , newblock ) ; ex3 -> ee_len = cpu_to_le16 ( allocated ) ; err = ext4_ext_insert_extent ( handle , inode , path , ex3 , 0 ) ; if ( err == - enospc ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; err = ext4_ext_zeroout ( inode , ex3 ) ; if ( err ) { depth = ext_depth ( inode ) ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( is_err ( path ) ) { err = ptr_err ( path ) ; return err ; } ex = path [ depth ] . p_ext ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) return err ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; } return allocated ; } ex3 = & newex ; ex3 -> ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; ext4_ext_store_pblock ( ex3 , newblock + map -> m_len ) ; ex3 -> ee_len = cpu_to_le16 ( allocated - map -> m_len ) ; ext4_ext_mark_uninitialized ( ex3 ) ; err = ext4_ext_insert_extent ( handle , inode , path , ex3 , 0 ) ; if ( err == - enospc && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; newdepth = ext_depth ( inode ) ; ee_len -= ext4_ext_get_actual_len ( ex3 ) ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; may_zeroout = ee_block + ee_len <= eof_block ; depth = newdepth ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( is_err ( path ) ) { err = ptr_err ( path ) ; goto out ; } eh = path [ depth ] . p_hdr ; ex = path [ depth ] . p_ext ; if ( ex2 != & newex ) ex2 = ex ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; allocated = map -> m_len ; if ( le16_to_cpu ( orig_ex . ee_len ) <= ext4_ext_zero_len && map -> m_lblk != ee_block && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } } if ( ex1 && ex1 != ex ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } ex2 -> ee_block = cpu_to_le32 ( map -> m_lblk ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; ex2 -> ee_len = cpu_to_le16 ( allocated ) ; if ( ex2 != ex ) goto insert ; if ( ex2 > ext_first_extent ( eh ) ) { ret = ext4_ext_try_to_merge ( inode , path , ex2 - 1 ) ; if ( ret ) { err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto out ; depth = ext_depth ( inode ) ; ex2 -- ; } } if ( ! ex3 ) { ret = ext4_ext_try_to_merge ( inode , path , ex2 ) ; if ( ret ) { err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto out ; } } err = ext4_ext_dirty ( handle , inode , path + depth ) ; goto out ; insert : err = ext4_ext_insert_extent ( handle , inode , path , & newex , 0 ) ; if ( err == - enospc && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ? err : allocated ; fix_extent_len : ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }","<S2SV_ModStart> ) { struct ext4_map_blocks split_map ; struct ext4_extent zero_ex <S2SV_ModEnd> ; struct ext4_extent <S2SV_ModStart> struct ext4_extent * ex <S2SV_ModEnd> ; ext4_lblk_t ee_block <S2SV_ModStart> , depth ; <S2SV_ModEnd> int err = <S2SV_ModStart> 0 ; int split_flag = 0 <S2SV_ModEnd> ; ext_debug ( <S2SV_ModStart> inode ) ; ex <S2SV_ModEnd> = path [ <S2SV_ModStart> depth ] . <S2SV_ModEnd> p_ext ; ee_block <S2SV_ModStart> ee_block ) ; WARN_ON ( map -> m_lblk < ee_block ) ; split_flag |= <S2SV_ModEnd> ee_block + ee_len <S2SV_ModStart> ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> * EXT4_EXT_ZERO_LEN && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) <S2SV_ModEnd> ) { err <S2SV_ModStart> ( inode , ex <S2SV_ModEnd> ) ; if <S2SV_ModStart> err ) goto out ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( inode , path , ex ) ; err = <S2SV_ModEnd> ext4_ext_dirty ( handle <S2SV_ModStart> depth ) ; goto out ; } split_map . m_lblk = map -> m_lblk ; split_map . m_len = map -> m_len ; if ( allocated > map -> m_len ) { <S2SV_ModEnd> if ( allocated <S2SV_ModStart> <= EXT4_EXT_ZERO_LEN && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { zero_ex . ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; zero_ex . <S2SV_ModEnd> ee_len = cpu_to_le16 <S2SV_ModStart> = cpu_to_le16 ( allocated - map -> m_len <S2SV_ModEnd> ) ; ext4_ext_store_pblock <S2SV_ModStart> ; ext4_ext_store_pblock ( & zero_ex , ext4_ext_pblock ( ex ) + map -> m_lblk - ee_block ) ; <S2SV_ModEnd> err = ext4_ext_zeroout <S2SV_ModStart> inode , & zero_ex <S2SV_ModEnd> ) ; if <S2SV_ModStart> err ) goto out ; split_map . m_lblk = map -> m_lblk ; split_map . m_len = <S2SV_ModEnd> allocated ; } <S2SV_ModStart> else if ( ( map -> m_lblk - ee_block + map -> m_len < EXT4_EXT_ZERO_LEN ) && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { if ( map -> m_lblk != ee_block ) { zero_ex . ee_block = ex -> ee_block ; zero_ex . ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_store_pblock ( & zero_ex , ext4_ext_pblock ( ex ) ) <S2SV_ModEnd> ; err = <S2SV_ModStart> ( inode , & zero_ex ) ; if ( err ) <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } allocated = map -> m_lblk - ee_block + map -> m_len ; split_map . m_lblk = ee_block ; split_map . m_len = allocated ; } } allocated = ext4_split_extent ( handle , inode , path , & split_map , split_flag <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ; if ( allocated < 0 ) err = allocated <S2SV_ModEnd> ; out : <S2SV_ModStart> ; out : <S2SV_ModEnd> return err ? <S2SV_ModStart> err : allocated <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3,CVE-2011-3638,https://github.com/torvalds/linux/commit/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3,2013-03-01T12:37Z,"<S2SV_StartBug> struct ext4_extent * ex , newex , orig_ex ; <S2SV_EndBug> <S2SV_StartBug> struct ext4_extent * ex1 = NULL ; <S2SV_EndBug> <S2SV_StartBug> ext4_fsblk_t newblock ; <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> eh = path [ depth ] . p_hdr ; <S2SV_EndBug> <S2SV_StartBug> newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ; <S2SV_EndBug> <S2SV_StartBug> may_zeroout = ee_block + ee_len <= eof_block ; <S2SV_EndBug> <S2SV_StartBug> if ( ee_len <= 2 * EXT4_EXT_ZERO_LEN && may_zeroout ) { <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> <S2SV_StartBug> goto fix_extent_len ; <S2SV_EndBug> <S2SV_StartBug> return allocated ; <S2SV_EndBug> <S2SV_StartBug> if ( allocated <= EXT4_EXT_ZERO_LEN && may_zeroout ) { <S2SV_EndBug> <S2SV_StartBug> ex -> ee_len = cpu_to_le16 ( ee_len - allocated ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> <S2SV_StartBug> goto fix_extent_len ; <S2SV_EndBug> <S2SV_StartBug> } else if ( err ) <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , ex3 ) ; <S2SV_EndBug> <S2SV_StartBug> eh = path [ depth ] . p_hdr ; <S2SV_EndBug> <S2SV_StartBug> if ( err == - ENOSPC && may_zeroout ) { <S2SV_EndBug> <S2SV_StartBug> ext4_ext_show_leaf ( inode , path ) ; <S2SV_EndBug> <S2SV_StartBug> return err ? err : allocated ; <S2SV_EndBug>"
2246,CWE-399,"static int br_multicast_add_group ( struct net_bridge * br , struct net_bridge_port * port , struct br_ip * group ) { struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; unsigned long now = jiffies ; int err ; spin_lock ( & br -> multicast_lock ) ; if ( ! netif_running ( br -> dev ) || ( port && port -> state == br_state_disabled ) ) goto out ; mp = br_multicast_new_group ( br , port , group ) ; err = ptr_err ( mp ) ; if ( is_err ( mp ) ) goto err ; if ( ! port ) { hlist_add_head ( & mp -> mglist , & br -> mglist ) ; mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ; goto out ; } for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != null ; pp = & p -> next ) { if ( p -> port == port ) goto found ; if ( ( unsigned long ) p -> port < ( unsigned long ) port ) break ; } p = kzalloc ( sizeof ( * p ) , gfp_atomic ) ; err = - enomem ; if ( unlikely ( ! p ) ) goto err ; p -> addr = * group ; p -> port = port ; p -> next = * pp ; hlist_add_head ( & p -> mglist , & port -> mglist ) ; setup_timer ( & p -> timer , br_multicast_port_group_expired , ( unsigned long ) p ) ; setup_timer ( & p -> query_timer , br_multicast_port_group_query_expired , ( unsigned long ) p ) ; rcu_assign_pointer ( * pp , p ) ; found : mod_timer ( & p -> timer , now + br -> multicast_membership_interval ) ; out : err = 0 ; err : spin_unlock ( & br -> multicast_lock ) ; return err ; }","<S2SV_ModStart> port ) { if ( hlist_unhashed ( & mp -> mglist ) )
",torvalds@linux/6b0d6a9b4296fa16a28d10d416db7a770fc03287,CVE-2011-0716,https://github.com/torvalds/linux/commit/6b0d6a9b4296fa16a28d10d416db7a770fc03287,2012-06-21T23:55Z,"<S2SV_StartBug> hlist_add_head ( & mp -> mglist , & br -> mglist ) ; <S2SV_EndBug>"
7315,CWE-787,"static int blosc_c ( struct thread_context * thread_context , int32_t bsize , int32_t leftoverblock , int32_t ntbytes , int32_t maxbytes , const uint8_t * src , const int32_t offset , uint8_t * dest , uint8_t * tmp , uint8_t * tmp2 ) { blosc2_context * context = thread_context -> parent_context ; int dont_split = ( context -> header_flags & 0x10 ) >> 4 ; int dict_training = context -> use_dict && context -> dict_cdict == null ; int32_t j , neblock , nstreams ; int32_t cbytes ; int32_t ctbytes = 0 ; int64_t maxout ; int32_t typesize = context -> typesize ; const char * compname ; int accel ; const uint8_t * _src ; uint8_t * _tmp = tmp , * _tmp2 = tmp2 ; uint8_t * _tmp3 = thread_context -> tmp4 ; int last_filter_index = last_filter ( context -> filters , 'c' ) ; bool memcpyed = context -> header_flags & ( uint8_t ) blosc_memcpyed ; if ( last_filter_index >= 0 || context -> prefilter != null ) { if ( memcpyed && context -> prefilter != null ) { _src = pipeline_c ( thread_context , bsize , src , offset , dest , _tmp2 , _tmp3 ) ; if ( _src == null ) { return - 9 ; } return bsize ; } _src = pipeline_c ( thread_context , bsize , src , offset , _tmp , _tmp2 , _tmp3 ) ; if ( _src == null ) { return - 9 ; } } else { _src = src + offset ; } assert ( context -> clevel > 0 ) ; accel = get_accel ( context ) ; if ( ! dont_split && ! leftoverblock && ! dict_training ) { nstreams = ( int32_t ) typesize ; } else { nstreams = 1 ; } neblock = bsize / nstreams ; for ( j = 0 ; j < nstreams ; j ++ ) { if ( ! dict_training ) { dest += sizeof ( int32_t ) ; ntbytes += sizeof ( int32_t ) ; ctbytes += sizeof ( int32_t ) ; } const uint8_t * ip = ( uint8_t * ) _src + j * neblock ; const uint8_t * ipbound = ( uint8_t * ) _src + ( j + 1 ) * neblock ; if ( get_run ( ip , ipbound ) ) { int32_t value = _src [ j * neblock ] ; _sw32 ( dest - 4 , - value ) ; continue ; } maxout = neblock ; # if defined ( have_snappy ) if ( context -> compcode == blosc_snappy ) { maxout = ( int32_t ) snappy_max_compressed_length ( ( size_t ) neblock ) ; } # endif if ( ntbytes + maxout > maxbytes ) { maxout = ( int64_t ) maxbytes - ( int64_t ) ntbytes ; if ( maxout <= 0 ) { return 0 ; } } if ( dict_training ) { memcpy ( dest , _src + j * neblock , ( unsigned int ) neblock ) ; cbytes = ( int32_t ) neblock ; } else if ( context -> compcode == blosc_blosclz ) { cbytes = blosclz_compress ( context -> clevel , _src + j * neblock , ( int ) neblock , dest , ( int ) maxout ) ; } # if defined ( have_lz4 ) else if ( context -> compcode == blosc_lz4 ) { void * hash_table = null ; # ifdef have_ipp hash_table = ( void * ) thread_context -> lz4_hash_table ; # endif cbytes = lz4_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , accel , hash_table ) ; } else if ( context -> compcode == blosc_lz4hc ) { cbytes = lz4hc_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , context -> clevel ) ; } # endif # if defined ( have_lizard ) else if ( context -> compcode == blosc_lizard ) { cbytes = lizard_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , accel ) ; } # endif # if defined ( have_snappy ) else if ( context -> compcode == blosc_snappy ) { cbytes = snappy_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout ) ; } # endif # if defined ( have_zlib ) else if ( context -> compcode == blosc_zlib ) { cbytes = zlib_wrap_compress ( ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , context -> clevel ) ; } # endif # if defined ( have_zstd ) else if ( context -> compcode == blosc_zstd ) { cbytes = zstd_wrap_compress ( thread_context , ( char * ) _src + j * neblock , ( size_t ) neblock , ( char * ) dest , ( size_t ) maxout , context -> clevel ) ; } # endif else { blosc_compcode_to_compname ( context -> compcode , & compname ) ; fprintf ( stderr , ""blosc<s2sv_blank>has<s2sv_blank>not<s2sv_blank>been<s2sv_blank>compiled<s2sv_blank>with<s2sv_blank>\'%s\'<s2sv_blank>"" , compname ) ; fprintf ( stderr , ""compression<s2sv_blank>support.<s2sv_blank><s2sv_blank>please<s2sv_blank>use<s2sv_blank>one<s2sv_blank>having<s2sv_blank>it."" ) ; return - 5 ; } if ( cbytes > maxout ) { return - 1 ; } if ( cbytes < 0 ) { return - 2 ; } if ( ! dict_training ) { if ( cbytes == 0 || cbytes == neblock ) { if ( ( ntbytes + neblock ) > maxbytes ) { return 0 ; } memcpy ( dest , _src + j * neblock , ( unsigned int ) neblock ) ; cbytes = neblock ; } _sw32 ( dest - 4 , cbytes ) ; } dest += cbytes ; ntbytes += cbytes ; ctbytes += cbytes ; } return ctbytes ; }","<S2SV_ModStart> ntbytes , int32_t destsize <S2SV_ModEnd> , const uint8_t <S2SV_ModStart> neblock ] ; if ( ntbytes > destsize ) { return - 1 ; } <S2SV_ModStart> + maxout > destsize <S2SV_ModEnd> ) { maxout <S2SV_ModStart> ( int64_t ) destsize <S2SV_ModEnd> - ( int64_t <S2SV_ModStart> neblock ) > destsize <S2SV_ModEnd> ) { return
",Blosc@c-blosc2/c4c6470e88210afc95262c8b9fcc27e30ca043ee,CVE-2020-29367,https://github.com/Blosc/c-blosc2/commit/c4c6470e88210afc95262c8b9fcc27e30ca043ee,2020-11-27T20:15Z,"<S2SV_StartBug> int32_t leftoverblock , int32_t ntbytes , int32_t maxbytes , <S2SV_EndBug> <S2SV_StartBug> _sw32 ( dest - 4 , - value ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ntbytes + maxout > maxbytes ) { <S2SV_EndBug> <S2SV_StartBug> maxout = ( int64_t ) maxbytes - ( int64_t ) ntbytes ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ntbytes + neblock ) > maxbytes ) { <S2SV_EndBug>"
806,CWE-254,"static int follow_dotdot_rcu ( struct nameidata * nd ) { struct inode * inode = nd -> inode ; if ( ! nd -> root . mnt ) set_root_rcu ( nd ) ; while ( 1 ) { if ( path_equal ( & nd -> path , & nd -> root ) ) break ; if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { struct dentry * old = nd -> path . dentry ; struct dentry * parent = old -> d_parent ; unsigned seq ; inode = parent -> d_inode ; seq = read_seqcount_begin ( & parent -> d_seq ) ; if ( unlikely ( read_seqcount_retry ( & old -> d_seq , nd -> seq ) ) ) return - echild ; nd -> path . dentry = parent ; nd -> seq = seq ; break ; } else { struct mount * mnt = real_mount ( nd -> path . mnt ) ; struct mount * mparent = mnt -> mnt_parent ; struct dentry * mountpoint = mnt -> mnt_mountpoint ; struct inode * inode2 = mountpoint -> d_inode ; unsigned seq = read_seqcount_begin ( & mountpoint -> d_seq ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - echild ; if ( & mparent -> mnt == nd -> path . mnt ) break ; nd -> path . dentry = mountpoint ; nd -> path . mnt = & mparent -> mnt ; inode = inode2 ; nd -> seq = seq ; } } while ( unlikely ( d_mountpoint ( nd -> path . dentry ) ) ) { struct mount * mounted ; mounted = __lookup_mnt ( nd -> path . mnt , nd -> path . dentry ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - echild ; if ( ! mounted ) break ; nd -> path . mnt = & mounted -> mnt ; nd -> path . dentry = mounted -> mnt . mnt_root ; inode = nd -> path . dentry -> d_inode ; nd -> seq = read_seqcount_begin ( & nd -> path . dentry -> d_seq ) ; } nd -> inode = inode ; return 0 ; }","<S2SV_ModStart> = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
",torvalds@linux/397d425dc26da728396e66d392d5dcb8dac30c37,CVE-2015-2925,https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37,2015-11-16T11:59Z,<S2SV_StartBug> break ; <S2SV_EndBug>
1098,CWE-264,"static inline int unuse_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , swp_entry_t entry , struct page * page ) { pmd_t * pmd ; unsigned long next ; int ret ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( unlikely ( pmd_trans_huge ( * pmd ) ) ) continue ; if ( pmd_none_or_clear_bad ( pmd ) ) continue ; ret = unuse_pte_range ( vma , pmd , addr , next , entry , page ) ; if ( ret ) return ret ; } while ( pmd ++ , addr = next , addr != end ) ; return 0 ; }","<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z,<S2SV_StartBug> if ( unlikely ( pmd_trans_huge ( * pmd ) ) ) <S2SV_EndBug>
231,CWE-17,"int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , int flen ) { struct ustr * filename , * unifilename ; int len = 0 ; filename = kmalloc ( sizeof ( struct ustr ) , gfp_nofs ) ; if ( ! filename ) return 0 ; unifilename = kmalloc ( sizeof ( struct ustr ) , gfp_nofs ) ; if ( ! unifilename ) goto out1 ; if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) goto out2 ; if ( udf_query_flag ( sb , udf_flag_utf8 ) ) { if ( ! udf_cs0toutf8 ( filename , unifilename ) ) { udf_debug ( ""failed<s2sv_blank>in<s2sv_blank>udf_get_filename:<s2sv_blank>sname<s2sv_blank>=<s2sv_blank>%s\\n"" , sname ) ; goto out2 ; } } else if ( udf_query_flag ( sb , udf_flag_nls_map ) ) { if ( ! udf_cs0tonls ( udf_sb ( sb ) -> s_nls_map , filename , unifilename ) ) { udf_debug ( ""failed<s2sv_blank>in<s2sv_blank>udf_get_filename:<s2sv_blank>sname<s2sv_blank>=<s2sv_blank>%s\\n"" , sname ) ; goto out2 ; } } else goto out2 ; len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , unifilename -> u_name , unifilename -> u_len ) ; out2 : kfree ( unifilename ) ; out1 : kfree ( filename ) ; return len ; }","<S2SV_ModStart> * sname , int slen , <S2SV_ModStart> * dname , int dlen <S2SV_ModEnd> ) { struct <S2SV_ModStart> , sname , slen <S2SV_ModEnd> ) ) goto <S2SV_ModStart> ( dname , dlen ,
",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z,"<S2SV_StartBug> int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , <S2SV_EndBug> <S2SV_StartBug> int flen ) <S2SV_EndBug> <S2SV_StartBug> if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) <S2SV_EndBug> <S2SV_StartBug> len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , <S2SV_EndBug>"
7072,CWE-763,"static om_uint32 init_ctx_new ( om_uint32 * minor_status , spnego_gss_cred_id_t spcred , gss_ctx_id_t * ctx , send_token_flag * tokflag ) { om_uint32 ret ; spnego_gss_ctx_id_t sc = null ; sc = create_spnego_ctx ( ) ; if ( sc == null ) return gss_s_failure ; ret = get_negotiable_mechs ( minor_status , spcred , gss_c_initiate , & sc -> mech_set ) ; if ( ret != gss_s_complete ) goto cleanup ; sc -> internal_mech = & sc -> mech_set -> elements [ 0 ] ; if ( put_mech_set ( sc -> mech_set , & sc -> der_mechtypes ) < 0 ) { ret = gss_s_failure ; goto cleanup ; } sc -> ctx_handle = gss_c_no_context ; * ctx = ( gss_ctx_id_t ) sc ; sc = null ; * tokflag = init_token_send ; ret = gss_s_continue_needed ; cleanup : release_spnego_ctx ( & sc ) ; return ret ; }","<S2SV_ModStart> = create_spnego_ctx ( 1
",krb5@krb5/b51b33f2bc5d1497ddf5bd107f791c101695000d,CVE-2015-2695,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,2015-11-09T03:59Z,<S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug>
723,CWE-476,"static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & i8042_str_obf ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( ""interrupt<s2sv_blank>%d,<s2sv_blank>without<s2sv_blank>any<s2sv_blank>data\\n"" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & i8042_str_auxdata ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & i8042_str_muxerr ) { dbg ( ""mux<s2sv_blank>error,<s2sv_blank>status<s2sv_blank>is<s2sv_blank>%02x,<s2sv_blank>data<s2sv_blank>is<s2sv_blank>%02x\\n"" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + hz / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = serio_timeout ; data = 0xfe ; break ; case 0xff : dfl = serio_parity ; data = 0xfe ; break ; } } port_no = i8042_mux_port_no + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & i8042_str_parity ) ? serio_parity : 0 ) | ( ( str & i8042_str_timeout && ! i8042_notimeout ) ? serio_timeout : 0 ) ; port_no = ( str & i8042_str_auxdata ) ? i8042_aux_port_no : i8042_kbd_port_no ; } port = & i8042_ports [ port_no ] ; serio = port -> exists ? port -> serio : null ; filter_dbg ( port -> driver_bound , data , ""<-<s2sv_blank>i8042<s2sv_blank>(interrupt,<s2sv_blank>%d,<s2sv_blank>%d%s%s)\\n"" , port_no , irq , dfl & serio_parity ? "",<s2sv_blank>bad<s2sv_blank>parity"" : """" , dfl & serio_timeout ? "",<s2sv_blank>timeout"" : """" ) ; filtered = i8042_filter ( data , str , serio ) ; spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( likely ( port -> exists && ! filtered ) ) serio_interrupt ( serio , data , dfl ) ; out : return irq_retval ( ret ) ; }","<S2SV_ModStart> ( likely ( serio <S2SV_ModEnd> && ! filtered
",torvalds@linux/340d394a789518018f834ff70f7534fc463d3226,CVE-2017-18079,https://github.com/torvalds/linux/commit/340d394a789518018f834ff70f7534fc463d3226,2018-01-29T05:29Z,<S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug>
5022,CWE-119,"static int ssh_packet_set_postauth ( struct ssh * ssh ) { struct sshcomp * comp ; int r , mode ; debug ( ""%s:<s2sv_blank>called"" , __func__ ) ; ssh -> state -> after_authentication = 1 ; ssh -> state -> rekeying = 0 ; for ( mode = 0 ; mode < mode_max ; mode ++ ) { if ( ssh -> state -> newkeys [ mode ] == null ) continue ; comp = & ssh -> state -> newkeys [ mode ] -> comp ; if ( comp && comp -> enabled && ( r = ssh_packet_init_compression ( ssh ) ) != 0 ) return r ; } return 0 ; }","<S2SV_ModStart> ssh ) { int r <S2SV_ModEnd> ; debug ( <S2SV_ModStart> = 0 ; if ( <S2SV_ModEnd> ( r = <S2SV_ModStart> ( r = ssh_packet_enable_delayed_compress <S2SV_ModEnd> ( ssh ) <S2SV_ModStart> return r ; <S2SV_ModEnd> return 0 ;
",openbsd@src/3095060f479b86288e31c79ecbc5131a66bcd2f9,CVE-2016-10012,https://github.com/openbsd/src/commit/3095060f479b86288e31c79ecbc5131a66bcd2f9,2017-01-05T02:59Z,<S2SV_StartBug> struct sshcomp * comp ; <S2SV_EndBug> <S2SV_StartBug> for ( mode = 0 ; mode < MODE_MAX ; mode ++ ) { <S2SV_EndBug> <S2SV_StartBug> ( r = ssh_packet_init_compression ( ssh ) ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
8472,CWE-787,"void gps_tracker ( void ) { ssize_t unused ; int gpsd_sock ; char line [ 256 ] , * temp ; struct sockaddr_in gpsd_addr ; int ret , is_json , pos ; fd_set read_fd ; struct timeval timeout ; pos = 0 ; gpsd_sock = socket ( af_inet , sock_stream , 0 ) ; if ( gpsd_sock < 0 ) { return ; } gpsd_addr . sin_family = af_inet ; gpsd_addr . sin_port = htons ( 2947 ) ; gpsd_addr . sin_addr . s_addr = inet_addr ( ""127.0.0.1"" ) ; if ( connect ( gpsd_sock , ( struct sockaddr * ) & gpsd_addr , sizeof ( gpsd_addr ) ) < 0 ) { return ; } fd_zero ( & read_fd ) ; fd_set ( gpsd_sock , & read_fd ) ; timeout . tv_sec = 1 ; timeout . tv_usec = 0 ; is_json = select ( gpsd_sock + 1 , & read_fd , null , null , & timeout ) ; if ( is_json ) { if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; is_json = ( line [ 0 ] == '{' ) ; if ( is_json ) { memset ( line , 0 , sizeof ( line ) ) ; strcpy ( line , ""?watch={\\""json\\"":true};\\n"" ) ; if ( send ( gpsd_sock , line , 22 , 0 ) != 22 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( strncmp ( line , ""{\\""class\\"":\\""devices\\"",\\""devices\\"":[]}"" , 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } else { pos = strlen ( line ) ; } } } while ( g . do_exit == 0 ) { usleep ( 500000 ) ; memset ( g . gps_loc , 0 , sizeof ( float ) * 5 ) ; if ( is_json ) { if ( pos == sizeof ( line ) ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; temp = strstr ( line , ""{\\""class\\"":\\""tpv\\"""" ) ; if ( temp == null ) { continue ; } if ( strchr ( temp , '}' ) == null ) { pos = strlen ( temp ) ; if ( temp != line ) { memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } temp = strstr ( temp , ""\\""lat\\"":"" ) ; if ( temp == null ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & g . gps_loc [ 0 ] ) ; temp = strstr ( temp , ""\\""lon\\"":"" ) ; if ( temp == null ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & g . gps_loc [ 1 ] ) ; temp = strstr ( temp , ""\\""alt\\"":"" ) ; if ( temp == null ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & g . gps_loc [ 4 ] ) ; temp = strstr ( temp , ""\\""speed\\"":"" ) ; if ( temp == null ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & g . gps_loc [ 2 ] ) ; temp = strstr ( temp , ""{\\""class\\"":\\""tpv\\"""" ) ; if ( temp == null ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } else { pos = strlen ( temp ) ; memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } else { memset ( line , 0 , sizeof ( line ) ) ; snprintf ( line , sizeof ( line ) - 1 , ""pvtad\\r\\n"" ) ; if ( send ( gpsd_sock , line , 7 , 0 ) != 7 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( memcmp ( line , ""gpsd,p="" , 7 ) != 0 ) continue ; if ( line [ 7 ] == '?' ) continue ; ret = sscanf ( line + 7 , ""%f<s2sv_blank>%f"" , & g . gps_loc [ 0 ] , & g . gps_loc [ 1 ] ) ; if ( ( temp = strstr ( line , ""v="" ) ) == null ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & g . gps_loc [ 2 ] ) ; if ( ( temp = strstr ( line , ""t="" ) ) == null ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & g . gps_loc [ 3 ] ) ; if ( ( temp = strstr ( line , ""a="" ) ) == null ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & g . gps_loc [ 4 ] ) ; } if ( g . record_data ) fputs ( line , g . f_gps ) ; g . save_gps = 1 ; if ( g . do_exit == 0 ) { unused = write ( g . gc_pipe [ 1 ] , g . gps_loc , sizeof ( float ) * 5 ) ; kill ( getppid ( ) , sigusr2 ) ; } } }","<S2SV_ModStart> line ) - pos -
",aircrack-ng@aircrack-ng/ff70494dd389ba570dbdbf36f217c28d4381c6b5,CVE-2014-8321,https://github.com/aircrack-ng/aircrack-ng/commit/ff70494dd389ba570dbdbf36f217c28d4381c6b5,2020-01-31T22:15Z,"<S2SV_StartBug> if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 ) <S2SV_EndBug>"
7640,CWE-190,"int pgx_validate ( jas_stream_t * in ) { uchar buf [ pgx_magiclen ] ; uint_fast32_t magic ; int i ; int n ; assert ( jas_stream_maxputback >= pgx_magiclen ) ; if ( ( n = jas_stream_read ( in , buf , pgx_magiclen ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == eof ) { return - 1 ; } } if ( n < pgx_magiclen ) { return - 1 ; } magic = ( buf [ 0 ] << 8 ) | buf [ 1 ] ; if ( magic != pgx_magic ) { return - 1 ; } return 0 ; }","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ PGX_MAGICLEN
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> uchar buf [ PGX_MAGICLEN ] ; <S2SV_EndBug>
3279,CWE-189,"static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ nfs4acl_maxpages ] ; struct nfs_getaclargs args = { . fh = nfs_fh ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ nfsproc4_clnt_getacl ] , . rpc_argp = & args , . rpc_resp = & res , } ; struct page * localpage = null ; int ret ; if ( buflen < page_size ) { localpage = alloc_page ( gfp_kernel ) ; resp_buf = page_address ( localpage ) ; if ( localpage == null ) return - enomem ; args . acl_pages [ 0 ] = localpage ; args . acl_pgbase = 0 ; args . acl_len = page_size ; } else { resp_buf = buf ; buf_to_pages ( buf , buflen , args . acl_pages , & args . acl_pgbase ) ; } ret = nfs4_call_sync ( nfs_server ( inode ) -> client , nfs_server ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; if ( res . acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , null , res . acl_len ) ; else nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ; if ( buf ) { ret = - erange ; if ( res . acl_len > buflen ) goto out_free ; if ( localpage ) memcpy ( buf , resp_buf , res . acl_len ) ; } ret = res . acl_len ; out_free : if ( localpage ) __free_page ( localpage ) ; return ret ; }","<S2SV_ModStart> [ NFS4ACL_MAXPAGES ] = { NULL , } <S2SV_ModStart> , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { args . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! args . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; <S2SV_ModEnd> ret = nfs4_call_sync <S2SV_ModStart> goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( <S2SV_ModEnd> acl_len > args <S2SV_ModStart> , NULL , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> inode , resp_buf + res . acl_data_offset , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> acl_len > buflen <S2SV_ModStart> goto out_free ; _copy_from_pages <S2SV_ModEnd> ( buf , <S2SV_ModStart> ( buf , pages , res . acl_data_offset , res . acl_len ) ; } ret = <S2SV_ModEnd> acl_len ; out_free <S2SV_ModStart> ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] <S2SV_ModEnd> ) __free_page ( <S2SV_ModStart> ) __free_page ( pages [ i ] ) ; if ( args . acl_scratch ) __free_page ( args . acl_scratch <S2SV_ModEnd> ) ; return
",torvalds@linux/bf118a342f10dafe44b14451a1392c3254629a1f,CVE-2011-4131,https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f,2012-05-17T11:00Z,"<S2SV_StartBug> struct page * pages [ NFS4ACL_MAXPAGES ] ; <S2SV_EndBug> <S2SV_StartBug> struct page * localpage = NULL ; <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> if ( res . acl_len > args . acl_len ) <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res . acl_len > buflen ) <S2SV_EndBug> <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( buf , resp_buf , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> __free_page ( localpage ) ; <S2SV_EndBug>"
7946,CWE-18,"static krb5_error_code iakerb_alloc_context ( iakerb_ctx_id_t * pctx ) { iakerb_ctx_id_t ctx ; krb5_error_code code ; * pctx = null ; ctx = k5alloc ( sizeof ( * ctx ) , & code ) ; if ( ctx == null ) goto cleanup ; ctx -> defcred = gss_c_no_credential ; ctx -> magic = kg_iakerb_context ; ctx -> state = iakerb_as_req ; ctx -> count = 0 ; code = krb5_gss_init_context ( & ctx -> k5c ) ; if ( code != 0 ) goto cleanup ; * pctx = ctx ; cleanup : if ( code != 0 ) iakerb_release_context ( ctx ) ; return code ; }","<S2SV_ModStart> iakerb_ctx_id_t * pctx , int initiate <S2SV_ModStart> = 0 ; ctx -> initiate = initiate ; ctx -> established = 0 ;
",krb5@krb5/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,CVE-2015-2696,https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,2015-11-09T03:59Z,<S2SV_StartBug> iakerb_alloc_context ( iakerb_ctx_id_t * pctx ) <S2SV_EndBug> <S2SV_StartBug> code = krb5_gss_init_context ( & ctx -> k5c ) ; <S2SV_EndBug>
2861,CWE-476,static int crypto_skcipher_init_tfm ( struct crypto_tfm * tfm ) { struct crypto_skcipher * skcipher = __crypto_skcipher_cast ( tfm ) ; struct skcipher_alg * alg = crypto_skcipher_alg ( skcipher ) ; if ( tfm -> __crt_alg -> cra_type == & crypto_blkcipher_type ) return crypto_init_skcipher_ops_blkcipher ( tfm ) ; if ( tfm -> __crt_alg -> cra_type == & crypto_ablkcipher_type || tfm -> __crt_alg -> cra_type == & crypto_givcipher_type ) return crypto_init_skcipher_ops_ablkcipher ( tfm ) ; skcipher -> setkey = alg -> setkey ; skcipher -> encrypt = alg -> encrypt ; skcipher -> decrypt = alg -> decrypt ; skcipher -> ivsize = alg -> ivsize ; skcipher -> keysize = alg -> max_keysize ; if ( alg -> exit ) skcipher -> base . exit = crypto_skcipher_exit_tfm ; if ( alg -> init ) return alg -> init ( skcipher ) ; return 0 ; },"<S2SV_ModStart> -> setkey = skcipher_setkey <S2SV_ModEnd> ; skcipher ->
",torvalds@linux/9933e113c2e87a9f46a40fde8dafbf801dca1ab9,CVE-2017-9211,https://github.com/torvalds/linux/commit/9933e113c2e87a9f46a40fde8dafbf801dca1ab9,2017-05-23T05:29Z,<S2SV_StartBug> skcipher -> setkey = alg -> setkey ; <S2SV_EndBug>
6490,CWE-000,"void sink ( int argc , char * * argv ) { static buf buffer ; struct stat stb ; enum { yes , no , displayed } wrerr ; buf * bp ; off_t i ; size_t j , count ; int amt , exists , first , mask , mode , ofd , omode ; off_t size , statbytes ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define screwup ( str ) do { why = str ; goto screwup ; } while ( 0 ) setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( ""ambiguous<s2sv_blank>target"" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( stat ( targ , & stb ) == 0 && s_isdir ( stb . st_mode ) ) targisdir = 1 ; for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ; if ( * cp ++ == '\\n' ) screwup ( ""unexpected<s2sv_blank><newline>"" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) screwup ( ""lost<s2sv_blank>connection"" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fprintf ( stderr , ""sink:<s2sv_blank>%s"" , buf ) ; if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { if ( iamremote == 0 ) ( void ) atomicio ( vwrite , stderr_fileno , buf + 1 , strlen ( buf + 1 ) ) ; if ( buf [ 0 ] == '\\02' ) exit ( 1 ) ; ++ errs ; continue ; } if ( buf [ 0 ] == 'e' ) { ( void ) atomicio ( vwrite , remout , """" , 1 ) ; return ; } if ( ch == '\\n' ) * -- cp = 0 ; cp = buf ; if ( * cp == 't' ) { setimes ++ ; cp ++ ; mtime . tv_sec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<s2sv_blank>' ) screwup ( ""mtime.sec<s2sv_blank>not<s2sv_blank>delimited"" ) ; mtime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<s2sv_blank>' ) screwup ( ""mtime.usec<s2sv_blank>not<s2sv_blank>delimited"" ) ; atime . tv_sec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<s2sv_blank>' ) screwup ( ""atime.sec<s2sv_blank>not<s2sv_blank>delimited"" ) ; atime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '\\0' ) screwup ( ""atime.usec<s2sv_blank>not<s2sv_blank>delimited"" ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; continue ; } if ( * cp != 'c' && * cp != 'd' ) { if ( first ) { run_err ( ""%s"" , cp ) ; exit ( 1 ) ; } screwup ( ""expected<s2sv_blank>control<s2sv_blank>record"" ) ; } mode = 0 ; for ( ++ cp ; cp < buf + 5 ; cp ++ ) { if ( * cp < '0' || * cp > '7' ) screwup ( ""bad<s2sv_blank>mode"" ) ; mode = ( mode << 3 ) | ( * cp - '0' ) ; } if ( * cp ++ != '<s2sv_blank>' ) screwup ( ""mode<s2sv_blank>not<s2sv_blank>delimited"" ) ; for ( size = 0 ; isdigit ( * cp ) ; ) size = size * 10 + ( * cp ++ - '0' ) ; if ( * cp ++ != '<s2sv_blank>' ) screwup ( ""size<s2sv_blank>not<s2sv_blank>delimited"" ) ; if ( ( strchr ( cp , '/' ) != null ) || ( strcmp ( cp , "".."" ) == 0 ) ) { run_err ( ""error:<s2sv_blank>unexpected<s2sv_blank>filename:<s2sv_blank>%s"" , cp ) ; exit ( 1 ) ; } if ( targisdir ) { static char * namebuf = null ; static size_t cursize = 0 ; size_t need ; need = strlen ( targ ) + strlen ( cp ) + 250 ; if ( need > cursize ) { if ( namebuf ) xfree ( namebuf ) ; namebuf = xmalloc ( need ) ; cursize = need ; } ( void ) snprintf ( namebuf , need , ""%s%s%s"" , targ , strcmp ( targ , ""/"" ) ? ""/"" : """" , cp ) ; np = namebuf ; } else np = targ ; curfile = cp ; exists = stat ( np , & stb ) == 0 ; if ( buf [ 0 ] == 'd' ) { int mod_flag = pflag ; if ( ! iamrecursive ) screwup ( ""received<s2sv_blank>directory<s2sv_blank>without<s2sv_blank>-r"" ) ; if ( exists ) { if ( ! s_isdir ( stb . st_mode ) ) { errno = enotdir ; goto bad ; } if ( pflag ) ( void ) chmod ( np , mode ) ; } else { mod_flag = 1 ; if ( mkdir ( np , mode | s_irwxu ) < 0 ) goto bad ; } vect [ 0 ] = xstrdup ( np ) ; sink ( 1 , vect ) ; if ( setimes ) { setimes = 0 ; if ( utimes ( vect [ 0 ] , tv ) < 0 ) run_err ( ""%s:<s2sv_blank>set<s2sv_blank>times:<s2sv_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ; } if ( mod_flag ) ( void ) chmod ( vect [ 0 ] , mode ) ; if ( vect [ 0 ] ) xfree ( vect [ 0 ] ) ; continue ; } omode = mode ; mode |= s_iwusr ; if ( ( ofd = open ( np , o_wronly | o_creat , mode ) ) < 0 ) { bad : run_err ( ""%s:<s2sv_blank>%s"" , np , strerror ( errno ) ) ; continue ; } ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( ( bp = allocbuf ( & buffer , ofd , 4096 ) ) == null ) { ( void ) close ( ofd ) ; continue ; } cp = bp -> buf ; wrerr = no ; statbytes = 0 ; # ifdef progress_meter if ( showprogress ) start_progress_meter ( curfile , size , & statbytes ) ; # endif for ( count = i = 0 ; i < size ; i += 4096 ) { amt = 4096 ; if ( i + amt > size ) amt = size - i ; count += amt ; do { j = atomicio ( read , remin , cp , amt ) ; if ( j == 0 ) { run_err ( ""%s"" , j ? strerror ( errno ) : ""dropped<s2sv_blank>connection"" ) ; exit ( 1 ) ; } amt -= j ; cp += j ; statbytes += j ; } while ( amt > 0 ) ; if ( limit_rate ) bwlimit ( 4096 ) ; if ( count == bp -> cnt ) { if ( wrerr == no ) { if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = yes ; wrerrno = errno ; } } count = 0 ; cp = bp -> buf ; } } # ifdef progress_meter if ( showprogress ) stop_progress_meter ( ) ; # endif if ( count != 0 && wrerr == no && atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = yes ; wrerrno = errno ; } if ( wrerr == no && ftruncate ( ofd , size ) != 0 ) { run_err ( ""%s:<s2sv_blank>truncate:<s2sv_blank>%s"" , np , strerror ( errno ) ) ; wrerr = displayed ; } if ( pflag ) { if ( exists || omode != mode ) # ifdef have_fchmod if ( fchmod ( ofd , omode ) ) { # else if ( chmod ( np , omode ) ) { # endif run_err ( ""%s:<s2sv_blank>set<s2sv_blank>mode:<s2sv_blank>%s"" , np , strerror ( errno ) ) ; wrerr = displayed ; } } else { if ( ! exists && omode != mode ) # ifdef have_fchmod if ( fchmod ( ofd , omode & ~ mask ) ) { # else if ( chmod ( np , omode & ~ mask ) ) { # endif run_err ( ""%s:<s2sv_blank>set<s2sv_blank>mode:<s2sv_blank>%s"" , np , strerror ( errno ) ) ; wrerr = displayed ; } } if ( close ( ofd ) == - 1 ) { wrerr = yes ; wrerrno = errno ; } ( void ) response ( ) ; if ( setimes && wrerr == no ) { setimes = 0 ; if ( utimes ( np , tv ) < 0 ) { run_err ( ""%s:<s2sv_blank>set<s2sv_blank>times:<s2sv_blank>%s"" , np , strerror ( errno ) ) ; wrerr = displayed ; } } switch ( wrerr ) { case yes : run_err ( ""%s:<s2sv_blank>%s"" , np , strerror ( wrerrno ) ) ; break ; case no : ( void ) atomicio ( vwrite , remout , """" , 1 ) ; break ; case displayed : break ; } } screwup : run_err ( ""protocol<s2sv_blank>error:<s2sv_blank>%s"" , why ) ; exit ( 1 ) ; }","<S2SV_ModStart> ; if ( * cp == '\\0' || <S2SV_ModEnd> strchr ( cp <S2SV_ModStart> ) != NULL || <S2SV_ModEnd> strcmp ( cp <S2SV_ModStart> ( cp , ""."" ) == 0 || strcmp ( cp , <S2SV_ModStart> ) == 0 <S2SV_ModEnd> ) { run_err
",mkj@dropbear/8f8a3dff705fad774a10864a2e3dbcfa9779ceff,CVE-2020-36254,https://github.com/mkj/dropbear/commit/8f8a3dff705fad774a10864a2e3dbcfa9779ceff,2021-02-25T09:15Z,"<S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) { <S2SV_EndBug>"
4526,CWE-125,"pyobject * ast2obj_comprehension ( void * _o ) { comprehension_ty o = ( comprehension_ty ) _o ; pyobject * result = null , * value = null ; if ( ! o ) { py_incref ( py_none ) ; return py_none ; } result = pytype_genericnew ( comprehension_type , null , null ) ; if ( ! result ) return null ; value = ast2obj_expr ( o -> target ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_target , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> iter ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_iter , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> ifs , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_ifs , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_int ( o -> is_async ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_is_async , value ) == - 1 ) goto failed ; py_decref ( value ) ; return result ; failed : py_xdecref ( value ) ; py_xdecref ( result ) ; return null ; }","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug>
152,CWE-119,"int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = mlx4_vlan_regular ; i < mlx4_max_vlan_num ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( mlx4_vlan_mask & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; } } if ( table -> total == table -> max ) { err = - enospc ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | mlx4_vlan_valid ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , ""failed<s2sv_blank>adding<s2sv_blank>vlan:<s2sv_blank>%u\\n"" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }","<S2SV_ModStart> out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ;
",torvalds@linux/0926f91083f34d047abc74f1ca4fa6a9c161f7db,CVE-2010-5332,https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db,2019-07-27T22:15Z,<S2SV_StartBug> } <S2SV_EndBug>
156,CWE-264,"static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = null ; const char * format = null ; size_t datalen = prep -> datalen ; int ret = 0 ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - einval ; buf = kmalloc ( datalen + 1 , gfp_kernel ) ; if ( ! buf ) return - enomem ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , null , null ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( is_err ( new_epayload ) ) { ret = ptr_err ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kfree ( buf ) ; return ret ; }","<S2SV_ModStart> ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY
",torvalds@linux/096fe9eaea40a17e125569f9e657e34cdb6d73bd,CVE-2015-8539,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,2016-02-08T03:59Z,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug>
2931,CWE-000,"static int ims_pcu_parse_cdc_data ( struct usb_interface * intf , struct ims_pcu * pcu ) { const struct usb_cdc_union_desc * union_desc ; struct usb_host_interface * alt ; union_desc = ims_pcu_get_cdc_union_desc ( intf ) ; if ( ! union_desc ) return - einval ; pcu -> ctrl_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bmasterinterface0 ) ; alt = pcu -> ctrl_intf -> cur_altsetting ; pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ; pcu -> max_ctrl_size = usb_endpoint_maxp ( pcu -> ep_ctrl ) ; pcu -> data_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bslaveinterface0 ) ; alt = pcu -> data_intf -> cur_altsetting ; if ( alt -> desc . bnumendpoints != 2 ) { dev_err ( pcu -> dev , ""incorrect<s2sv_blank>number<s2sv_blank>of<s2sv_blank>endpoints<s2sv_blank>on<s2sv_blank>data<s2sv_blank>interface<s2sv_blank>(%d)\\n"" , alt -> desc . bnumendpoints ) ; return - einval ; } pcu -> ep_out = & alt -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_bulk_out ( pcu -> ep_out ) ) { dev_err ( pcu -> dev , ""first<s2sv_blank>endpoint<s2sv_blank>on<s2sv_blank>data<s2sv_blank>interface<s2sv_blank>is<s2sv_blank>not<s2sv_blank>bulk<s2sv_blank>out\\n"" ) ; return - einval ; } pcu -> max_out_size = usb_endpoint_maxp ( pcu -> ep_out ) ; if ( pcu -> max_out_size < 8 ) { dev_err ( pcu -> dev , ""max<s2sv_blank>out<s2sv_blank>packet<s2sv_blank>size<s2sv_blank>is<s2sv_blank>too<s2sv_blank>small<s2sv_blank>(%zd)\\n"" , pcu -> max_out_size ) ; return - einval ; } pcu -> ep_in = & alt -> endpoint [ 1 ] . desc ; if ( ! usb_endpoint_is_bulk_in ( pcu -> ep_in ) ) { dev_err ( pcu -> dev , ""second<s2sv_blank>endpoint<s2sv_blank>on<s2sv_blank>data<s2sv_blank>interface<s2sv_blank>is<s2sv_blank>not<s2sv_blank>bulk<s2sv_blank>in\\n"" ) ; return - einval ; } pcu -> max_in_size = usb_endpoint_maxp ( pcu -> ep_in ) ; if ( pcu -> max_in_size < 8 ) { dev_err ( pcu -> dev , ""max<s2sv_blank>in<s2sv_blank>packet<s2sv_blank>size<s2sv_blank>is<s2sv_blank>too<s2sv_blank>small<s2sv_blank>(%zd)\\n"" , pcu -> max_in_size ) ; return - einval ; } return 0 ; }","<S2SV_ModStart> bMasterInterface0 ) ; if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> bSlaveInterface0 ) ; if ( ! pcu -> data_intf ) return - EINVAL ;
",torvalds@linux/a0ad220c96692eda76b2e3fd7279f3dcd1d8a8ff,CVE-2016-3689,https://github.com/torvalds/linux/commit/a0ad220c96692eda76b2e3fd7279f3dcd1d8a8ff,2016-05-02T10:59Z,<S2SV_StartBug> alt = pcu -> ctrl_intf -> cur_altsetting ; <S2SV_EndBug> <S2SV_StartBug> alt = pcu -> data_intf -> cur_altsetting ; <S2SV_EndBug>
945,CWE-264,"static void rd_release_device_space ( struct rd_dev * rd_dev ) { u32 i , j , page_count = 0 , sg_per_table ; struct rd_dev_sg_table * sg_table ; struct page * pg ; struct scatterlist * sg ; if ( ! rd_dev -> sg_table_array || ! rd_dev -> sg_table_count ) return ; sg_table = rd_dev -> sg_table_array ; for ( i = 0 ; i < rd_dev -> sg_table_count ; i ++ ) { sg = sg_table [ i ] . sg_table ; sg_per_table = sg_table [ i ] . rd_sg_count ; for ( j = 0 ; j < sg_per_table ; j ++ ) { pg = sg_page ( & sg [ j ] ) ; if ( pg ) { __free_page ( pg ) ; page_count ++ ; } } kfree ( sg ) ; } pr_debug ( ""core_rd[%u]<s2sv_blank>-<s2sv_blank>released<s2sv_blank>device<s2sv_blank>space<s2sv_blank>for<s2sv_blank>ramdisk"" ""<s2sv_blank>device<s2sv_blank>id:<s2sv_blank>%u,<s2sv_blank>pages<s2sv_blank>%u<s2sv_blank>in<s2sv_blank>%u<s2sv_blank>tables<s2sv_blank>total<s2sv_blank>bytes<s2sv_blank>%lu\\n"" , rd_dev -> rd_host -> rd_host_id , rd_dev -> rd_dev_id , page_count , rd_dev -> sg_table_count , ( unsigned long ) page_count * page_size ) ; kfree ( sg_table ) ; rd_dev -> sg_table_array = null ; rd_dev -> sg_table_count = 0 ; }","<S2SV_ModStart> ) { u32 page_count <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; page_count = rd_release_sgl_table ( rd_dev , <S2SV_ModEnd> rd_dev -> sg_table_array <S2SV_ModStart> rd_dev -> sg_table_array , <S2SV_ModEnd> rd_dev -> sg_table_count <S2SV_ModStart> rd_dev -> sg_table_count ) ; <S2SV_ModEnd> pr_debug ( ""CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Released<S2SV_blank>device<S2SV_blank>space<S2SV_blank>for<S2SV_blank>Ramdisk"" <S2SV_ModStart> PAGE_SIZE ) ; <S2SV_ModEnd> rd_dev -> sg_table_array
",torvalds@linux/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,CVE-2014-4027,https://github.com/torvalds/linux/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,2014-06-23T11:21Z,"<S2SV_StartBug> u32 i , j , page_count = 0 , sg_per_table ; <S2SV_EndBug> <S2SV_StartBug> sg_table = rd_dev -> sg_table_array ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < rd_dev -> sg_table_count ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( sg_table ) ; <S2SV_EndBug>"
6578,CWE-20,"int dooneobject ( char * cinput ) { int num , i , num1 , num2 ; char * s , * t , * startclean ; double * argbuf = 0 ; setdefaults ( ) ; s = cinput ; while ( * s != '[' ) s ++ ; s ++ ; t = s ; while ( * t != ']' ) t ++ ; * t ++ = 0 ; while ( * t == '<s2sv_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; outpos = outputbuffer ; outpos += sprintf ( outpos , ""\\\\axo@setobject{%s}%%\\n{%s%c}%%\\n{"" , s , t , termchar ) ; if ( * s == '0' && s [ 1 ] == ']' ) { if ( strcmp ( nameobject , ""axodrawwantspdf"" ) == 0 ) { identification = 1 ; outpos += sprintf ( outpos , ""axohelp<s2sv_blank>version<s2sv_blank>%d.%d.<s2sv_blank>pdf<s2sv_blank>output.}"" , version , subversion ) ; fprintf ( outfile , ""%s"" , outputbuffer ) ; return ( 0 ) ; } else { fprintf ( stderr , ""%s:<s2sv_blank>illegal<s2sv_blank>request<s2sv_blank>in<s2sv_blank>identification<s2sv_blank>string<s2sv_blank>[0]:<s2sv_blank>%s\\n"" , axohelp , nameobject ) ; if ( argbuf ) free ( argbuf ) ; return ( - 1 ) ; } } startclean = outpos ; nameobject = t ; while ( * t != '<s2sv_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<s2sv_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; if ( ( strcmp ( nameobject , ""curve"" ) == 0 ) || ( strcmp ( nameobject , ""polygon"" ) == 0 ) || ( strcmp ( nameobject , ""filledpolygon"" ) == 0 ) ) { if ( ( argbuf = readarray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; if ( num2 - 1 != 0 ) { fprintf ( stderr , ""%s:<s2sv_blank>command<s2sv_blank>%s<s2sv_blank>should<s2sv_blank>have<s2sv_blank>no<s2sv_blank>extra<s2sv_blank>numbers<s2sv_blank>in<s2sv_blank>%s.\\n"" , axohelp , nameobject , inname ) ; free ( argbuf ) ; return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; setlinewidth ( axolinewidth ) ; if ( strcmp ( nameobject , ""curve"" ) == 0 ) { curve ( argbuf , num1 ) ; } else if ( strcmp ( nameobject , ""polygon"" ) == 0 ) { polygon ( argbuf , num1 , 0 ) ; } else if ( strcmp ( nameobject , ""filledpolygon"" ) == 0 ) { polygon ( argbuf , num1 , 1 ) ; } free ( argbuf ) ; } } else if ( strcmp ( nameobject , ""dashcurve"" ) == 0 ) { if ( ( argbuf = readarray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; if ( num2 != 2 ) { fprintf ( stderr , ""%s:<s2sv_blank>command<s2sv_blank>%s<s2sv_blank>does<s2sv_blank>not<s2sv_blank>have<s2sv_blank>two<s2sv_blank>numbers<s2sv_blank>after<s2sv_blank>the<s2sv_blank>coordinates\\n<s2sv_blank><s2sv_blank>in<s2sv_blank>file<s2sv_blank>%s.\\n"" , axohelp , nameobject , inname ) ; free ( argbuf ) ; return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; setlinewidth ( axolinewidth ) ; dashcurve ( argbuf , num1 ) ; free ( argbuf ) ; } } else { if ( ( argbuf = readtail ( t , & num ) ) == 0 ) return ( - 1 ) ; for ( i = 0 ; i < sizeof ( commands ) / sizeof ( keyword ) ; i ++ ) { if ( strcmp ( nameobject , commands [ i ] . name ) == 0 ) { if ( num == commands [ i ] . numargs + 1 ) { axolinewidth = argbuf [ num - 1 ] ; setlinewidth ( axolinewidth ) ; ( * ( commands [ i ] . func ) ) ( argbuf ) ; free ( argbuf ) ; break ; } else { fprintf ( stderr , ""%s:<s2sv_blank>command<s2sv_blank>%s<s2sv_blank>should<s2sv_blank>have<s2sv_blank>%d(+1)<s2sv_blank>arguments<s2sv_blank>in<s2sv_blank>%s.\\n"" , axohelp , nameobject , commands [ i ] . numargs , inname ) ; free ( argbuf ) ; return ( - 1 ) ; } } } if ( i >= sizeof ( commands ) / sizeof ( keyword ) ) { fprintf ( stderr , ""%s:<s2sv_blank>command<s2sv_blank>%s<s2sv_blank>not<s2sv_blank>recognized<s2sv_blank>in<s2sv_blank>file<s2sv_blank>%s.\\n"" , axohelp , nameobject , inname ) ; free ( argbuf ) ; return ( - 1 ) ; } } outpos += sprintf ( outpos , ""}\\n"" ) ; cleanupoutput ( startclean ) ; fprintf ( outfile , ""%s"" , outputbuffer ) ; return ( 0 ) ; }","<S2SV_ModStart> num1 , num2 , retcode <S2SV_ModStart> , * t <S2SV_ModEnd> ; double * <S2SV_ModStart> argbuf = 0 ; retcode = - 1 <S2SV_ModStart> t ++ ; fprintf ( outfile , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_ModStart> = outputbuffer ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> 1 ] == 0 <S2SV_ModEnd> ) { if <S2SV_ModStart> = 1 ; fprintf ( outfile , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output."" <S2SV_ModEnd> , VERSION , <S2SV_ModStart> SUBVERSION ) ; goto SUCCESS ; } else { fprintf ( <S2SV_ModEnd> stderr , ""%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n"" <S2SV_ModStart> nameobject ) ; goto EXIT ; } } <S2SV_ModEnd> if ( ( <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; for ( <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } } <S2SV_ModStart> inname ) ; goto EXIT ; } } SUCCESS : retcode = 0 ; EXIT : if ( argbuf ) { <S2SV_ModStart> argbuf ) ; } fprintf ( outfile , ""}\\n"" ) ; return ( retcode <S2SV_ModEnd> ) ; }
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,"<S2SV_StartBug> int num , i , num1 , num2 ; <S2SV_EndBug> <S2SV_StartBug> char * s , * t , * StartClean ; <S2SV_EndBug> <S2SV_StartBug> double * argbuf = 0 ; <S2SV_EndBug> <S2SV_StartBug> outpos = outputbuffer ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * s == '0' && s [ 1 ] == ']' ) { <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( outfile , ""%s"" , outputbuffer ) ; <S2SV_EndBug> <S2SV_StartBug> if ( argbuf ) free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug>"
7126,CWE-200,"static void slc_bump ( struct slcan * sl ) { struct sk_buff * skb ; struct can_frame cf ; int i , tmp ; u32 tmpid ; char * cmd = sl -> rbuff ; cf . can_id = 0 ; switch ( * cmd ) { case 'r' : cf . can_id = can_rtr_flag ; case 't' : cf . can_dlc = sl -> rbuff [ slc_cmd_len + slc_sff_id_len ] ; sl -> rbuff [ slc_cmd_len + slc_sff_id_len ] = 0 ; cmd += slc_cmd_len + slc_sff_id_len + 1 ; break ; case 'r' : cf . can_id = can_rtr_flag ; case 't' : cf . can_id |= can_eff_flag ; cf . can_dlc = sl -> rbuff [ slc_cmd_len + slc_eff_id_len ] ; sl -> rbuff [ slc_cmd_len + slc_eff_id_len ] = 0 ; cmd += slc_cmd_len + slc_eff_id_len + 1 ; break ; default : return ; } if ( kstrtou32 ( sl -> rbuff + slc_cmd_len , 16 , & tmpid ) ) return ; cf . can_id |= tmpid ; if ( cf . can_dlc >= '0' && cf . can_dlc < '9' ) cf . can_dlc -= '0' ; else return ; * ( u64 * ) ( & cf . data ) = 0 ; if ( ! ( cf . can_id & can_rtr_flag ) ) { for ( i = 0 ; i < cf . can_dlc ; i ++ ) { tmp = hex_to_bin ( * cmd ++ ) ; if ( tmp < 0 ) return ; cf . data [ i ] = ( tmp << 4 ) ; tmp = hex_to_bin ( * cmd ++ ) ; if ( tmp < 0 ) return ; cf . data [ i ] |= tmp ; } } skb = dev_alloc_skb ( sizeof ( struct can_frame ) + sizeof ( struct can_skb_priv ) ) ; if ( ! skb ) return ; skb -> dev = sl -> dev ; skb -> protocol = htons ( eth_p_can ) ; skb -> pkt_type = packet_broadcast ; skb -> ip_summed = checksum_unnecessary ; can_skb_reserve ( skb ) ; can_skb_prv ( skb ) -> ifindex = sl -> dev -> ifindex ; can_skb_prv ( skb ) -> skbcnt = 0 ; skb_put_data ( skb , & cf , sizeof ( struct can_frame ) ) ; sl -> dev -> stats . rx_packets ++ ; sl -> dev -> stats . rx_bytes += cf . can_dlc ; netif_rx_ni ( skb ) ; }","<S2SV_ModStart> -> rbuff ; memset ( & cf , 0 , sizeof ( cf ) ) <S2SV_ModEnd> ; switch ( <S2SV_ModStart> else return ; <S2SV_ModEnd> if ( !
",torvalds@linux/b9258a2cece4ec1f020715fe3554bc2e360f6264,CVE-2020-11494,https://github.com/torvalds/linux/commit/b9258a2cece4ec1f020715fe3554bc2e360f6264,2020-04-02T21:15Z,<S2SV_StartBug> cf . can_id = 0 ; <S2SV_EndBug> <S2SV_StartBug> * ( u64 * ) ( & cf . data ) = 0 ; <S2SV_EndBug>
76,CWE-000,"void sas_init_disc ( struct sas_discovery * disc , struct asd_sas_port * port ) { int i ; static const work_func_t sas_event_fns [ disc_num_events ] = { [ disce_discover_domain ] = sas_discover_domain , [ disce_revalidate_domain ] = sas_revalidate_domain , [ disce_probe ] = sas_probe_devices , [ disce_suspend ] = sas_suspend_devices , [ disce_resume ] = sas_resume_devices , [ disce_destruct ] = sas_destruct_devices , } ; disc -> pending = 0 ; for ( i = 0 ; i < disc_num_events ; i ++ ) { init_sas_work ( & disc -> disc_work [ i ] . work , sas_event_fns [ i ] ) ; disc -> disc_work [ i ] . port = port ; } }","<S2SV_ModStart> sas_revalidate_domain , [ <S2SV_ModEnd> DISCE_SUSPEND ] = <S2SV_ModStart> ] = sas_resume_devices <S2SV_ModEnd> , } ;
",torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z,"<S2SV_StartBug> [ DISCE_PROBE ] = sas_probe_devices , <S2SV_EndBug> <S2SV_StartBug> [ DISCE_RESUME ] = sas_resume_devices , <S2SV_EndBug>"
8205,CWE-190,"static size_t optsize ( lua_state * l , char opt , const char * * fmt ) { switch ( opt ) { case 'b' : case 'b' : return sizeof ( char ) ; case 'h' : case 'h' : return sizeof ( short ) ; case 'l' : case 'l' : return sizeof ( long ) ; case 't' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ; case 'c' : return getnum ( fmt , 1 ) ; case 'i' : case 'i' : { int sz = getnum ( fmt , sizeof ( int ) ) ; if ( sz > maxintsize ) lual_error ( l , ""integral<s2sv_blank>size<s2sv_blank>%d<s2sv_blank>is<s2sv_blank>larger<s2sv_blank>than<s2sv_blank>limit<s2sv_blank>of<s2sv_blank>%d"" , sz , maxintsize ) ; return sz ; } default : return 0 ; } }","<S2SV_ModStart> return getnum ( L , <S2SV_ModStart> = getnum ( L ,
",antirez@redis/ef764dde1cca2f25d00686673d1bc89448819571,CVE-2020-14147,https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571,2020-06-15T18:15Z,"<S2SV_StartBug> case 'c' : return getnum ( fmt , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int sz = getnum ( fmt , sizeof ( int ) ) ; <S2SV_EndBug>"
2108,CWE-200,"static int recv_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; int sz_to_copy , target , needed ; int sz_copied = 0 ; u32 err ; int res = 0 ; if ( unlikely ( ! buf_len ) ) return - einval ; lock_sock ( sk ) ; if ( unlikely ( ( sock -> state == ss_unconnected ) || ( sock -> state == ss_connecting ) ) ) { res = - enotconn ; goto exit ; } target = sock_rcvlowat ( sk , flags & msg_waitall , buf_len ) ; timeout = sock_rcvtimeo ( sk , flags & msg_dontwait ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == ss_disconnecting ) { res = - enotconn ; goto exit ; } if ( timeout <= 0l ) { res = timeout ? timeout : - ewouldblock ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } if ( sz_copied == 0 ) { set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; } if ( ! err ) { u32 offset = ( u32 ) ( unsigned long ) ( tipc_skb_cb ( buf ) -> handle ) ; sz -= offset ; needed = ( buf_len - sz_copied ) ; sz_to_copy = ( sz <= needed ) ? sz : needed ; res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) + offset , m -> msg_iov , sz_to_copy ) ; if ( res ) goto exit ; sz_copied += sz_to_copy ; if ( sz_to_copy < sz ) { if ( ! ( flags & msg_peek ) ) tipc_skb_cb ( buf ) -> handle = ( void * ) ( unsigned long ) ( offset + sz_to_copy ) ; goto exit ; } } else { if ( sz_copied != 0 ) goto exit ; if ( ( err == tipc_conn_shutdown ) || m -> msg_control ) res = 0 ; else res = - econnreset ; } if ( likely ( ! ( flags & msg_peek ) ) ) { if ( unlikely ( ++ tport -> conn_unacked >= tipc_flow_control_win ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } if ( ( sz_copied < buf_len ) && ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || ( sz_copied < target ) ) && ( ! ( flags & msg_peek ) ) && ( ! err ) ) goto restart ; exit : release_sock ( sk ) ; return sz_copied ? sz_copied : res ; }","<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
",torvalds@linux/60085c3d009b0df252547adb336d1ccca5ce52ec,CVE-2013-3235,https://github.com/torvalds/linux/commit/60085c3d009b0df252547adb336d1ccca5ce52ec,2013-04-22T11:41Z,<S2SV_StartBug> } <S2SV_EndBug>
6801,CWE-000,"static stkid rethook ( lua_state * l , callinfo * ci , stkid firstres , int nres ) { ptrdiff_t oldtop = savestack ( l , l -> top ) ; int delta = 0 ; if ( isluacode ( ci ) ) { proto * p = cllvalue ( s2v ( ci -> func ) ) -> p ; if ( p -> is_vararg ) delta = ci -> u . l . nextraargs + p -> numparams + 1 ; if ( l -> top < ci -> top ) l -> top = ci -> top ; } if ( l -> hookmask & lua_maskret ) { int ftransfer ; ci -> func += delta ; ftransfer = cast ( unsigned short , firstres - ci -> func ) ; luad_hook ( l , lua_hookret , - 1 , ftransfer , nres ) ; ci -> func -= delta ; } if ( islua ( ci -> previous ) ) l -> oldpc = ci -> previous -> u . l . savedpc ; return restorestack ( l , oldtop ) ; }","<S2SV_ModStart> * p = ci_func ( ci <S2SV_ModEnd> ) -> p <S2SV_ModStart> isLua ( ci = ci <S2SV_ModStart> -> oldpc = pcRel ( ci <S2SV_ModEnd> -> u . <S2SV_ModStart> l . savedpc , ci_func ( ci ) -> p )
",lua@lua/a2195644d89812e5b157ce7bac35543e06db05e3,CVE-2020-15945,https://github.com/lua/lua/commit/a2195644d89812e5b157ce7bac35543e06db05e3,2020-07-24T21:15Z,<S2SV_StartBug> Proto * p = clLvalue ( s2v ( ci -> func ) ) -> p ; <S2SV_EndBug> <S2SV_StartBug> if ( isLua ( ci -> previous ) ) <S2SV_EndBug> <S2SV_StartBug> L -> oldpc = ci -> previous -> u . l . savedpc ; <S2SV_EndBug>
6355,CWE-476,"static int multiselect ( parse * pparse , select * p , selectdest * pdest ) { int rc = sqlite_ok ; select * pprior ; vdbe * v ; selectdest dest ; select * pdelete = 0 ; sqlite3 * db ; assert ( p && p -> pprior ) ; assert ( ( p -> selflags & sf_recursive ) == 0 || p -> op == tk_all || p -> op == tk_union ) ; assert ( p -> selflags & sf_compound ) ; db = pparse -> db ; pprior = p -> pprior ; dest = * pdest ; if ( pprior -> porderby || pprior -> plimit ) { sqlite3errormsg ( pparse , ""%s<s2sv_blank>clause<s2sv_blank>should<s2sv_blank>come<s2sv_blank>after<s2sv_blank>%s<s2sv_blank>not<s2sv_blank>before"" , pprior -> porderby != 0 ? ""order<s2sv_blank>by"" : ""limit"" , selectopname ( p -> op ) ) ; rc = 1 ; goto multi_select_end ; } v = sqlite3getvdbe ( pparse ) ; assert ( v != 0 ) ; if ( dest . edest == srt_ephemtab ) { assert ( p -> pelist ) ; sqlite3vdbeaddop2 ( v , op_openephemeral , dest . isdparm , p -> pelist -> nexpr ) ; dest . edest = srt_table ; } if ( p -> selflags & sf_multivalue ) { rc = multiselectvalues ( pparse , p , & dest ) ; if ( rc >= 0 ) goto multi_select_end ; rc = sqlite_ok ; } assert ( p -> pelist && pprior -> pelist ) ; assert ( p -> pelist -> nexpr == pprior -> pelist -> nexpr ) ; # ifndef sqlite_omit_cte if ( p -> selflags & sf_recursive ) { generatewithrecursivequery ( pparse , p , & dest ) ; } else # endif if ( p -> porderby ) { return multiselectorderby ( pparse , p , pdest ) ; } else { # ifndef sqlite_omit_explain if ( pprior -> pprior == 0 ) { explainqueryplan ( ( pparse , 1 , ""compound<s2sv_blank>query"" ) ) ; explainqueryplan ( ( pparse , 1 , ""left-most<s2sv_blank>subquery"" ) ) ; } # endif switch ( p -> op ) { case tk_all : { int addr = 0 ; int nlimit ; assert ( ! pprior -> plimit ) ; pprior -> ilimit = p -> ilimit ; pprior -> ioffset = p -> ioffset ; pprior -> plimit = p -> plimit ; rc = sqlite3select ( pparse , pprior , & dest ) ; p -> plimit = 0 ; if ( rc ) { goto multi_select_end ; } p -> pprior = 0 ; p -> ilimit = pprior -> ilimit ; p -> ioffset = pprior -> ioffset ; if ( p -> ilimit ) { addr = sqlite3vdbeaddop1 ( v , op_ifnot , p -> ilimit ) ; vdbecoverage ( v ) ; vdbecomment ( ( v , ""jump<s2sv_blank>ahead<s2sv_blank>if<s2sv_blank>limit<s2sv_blank>reached"" ) ) ; if ( p -> ioffset ) { sqlite3vdbeaddop3 ( v , op_offsetlimit , p -> ilimit , p -> ioffset + 1 , p -> ioffset ) ; } } explainqueryplan ( ( pparse , 1 , ""union<s2sv_blank>all"" ) ) ; rc = sqlite3select ( pparse , p , & dest ) ; testcase ( rc != sqlite_ok ) ; pdelete = p -> pprior ; p -> pprior = pprior ; p -> nselectrow = sqlite3logestadd ( p -> nselectrow , pprior -> nselectrow ) ; if ( pprior -> plimit && sqlite3exprisinteger ( pprior -> plimit -> pleft , & nlimit ) && nlimit > 0 && p -> nselectrow > sqlite3logest ( ( u64 ) nlimit ) ) { p -> nselectrow = sqlite3logest ( ( u64 ) nlimit ) ; } if ( addr ) { sqlite3vdbejumphere ( v , addr ) ; } break ; } case tk_except : case tk_union : { int uniontab ; u8 op = 0 ; int priorop ; expr * plimit ; int addr ; selectdest uniondest ; testcase ( p -> op == tk_except ) ; testcase ( p -> op == tk_union ) ; priorop = srt_union ; if ( dest . edest == priorop ) { assert ( p -> plimit == 0 ) ; uniontab = dest . isdparm ; } else { uniontab = pparse -> ntab ++ ; assert ( p -> porderby == 0 ) ; addr = sqlite3vdbeaddop2 ( v , op_openephemeral , uniontab , 0 ) ; assert ( p -> addropenephm [ 0 ] == - 1 ) ; p -> addropenephm [ 0 ] = addr ; findrightmost ( p ) -> selflags |= sf_usesephemeral ; assert ( p -> pelist ) ; } assert ( ! pprior -> porderby ) ; sqlite3selectdestinit ( & uniondest , priorop , uniontab ) ; rc = sqlite3select ( pparse , pprior , & uniondest ) ; if ( rc ) { goto multi_select_end ; } if ( p -> op == tk_except ) { op = srt_except ; } else { assert ( p -> op == tk_union ) ; op = srt_union ; } p -> pprior = 0 ; plimit = p -> plimit ; p -> plimit = 0 ; uniondest . edest = op ; explainqueryplan ( ( pparse , 1 , ""%s<s2sv_blank>using<s2sv_blank>temp<s2sv_blank>b-tree"" , selectopname ( p -> op ) ) ) ; rc = sqlite3select ( pparse , p , & uniondest ) ; testcase ( rc != sqlite_ok ) ; sqlite3exprlistdelete ( db , p -> porderby ) ; pdelete = p -> pprior ; p -> pprior = pprior ; p -> porderby = 0 ; if ( p -> op == tk_union ) { p -> nselectrow = sqlite3logestadd ( p -> nselectrow , pprior -> nselectrow ) ; } sqlite3exprdelete ( db , p -> plimit ) ; p -> plimit = plimit ; p -> ilimit = 0 ; p -> ioffset = 0 ; assert ( uniontab == dest . isdparm || dest . edest != priorop ) ; if ( dest . edest != priorop ) { int icont , ibreak , istart ; assert ( p -> pelist ) ; ibreak = sqlite3vdbemakelabel ( pparse ) ; icont = sqlite3vdbemakelabel ( pparse ) ; computelimitregisters ( pparse , p , ibreak ) ; sqlite3vdbeaddop2 ( v , op_rewind , uniontab , ibreak ) ; vdbecoverage ( v ) ; istart = sqlite3vdbecurrentaddr ( v ) ; selectinnerloop ( pparse , p , uniontab , 0 , 0 , & dest , icont , ibreak ) ; sqlite3vdberesolvelabel ( v , icont ) ; sqlite3vdbeaddop2 ( v , op_next , uniontab , istart ) ; vdbecoverage ( v ) ; sqlite3vdberesolvelabel ( v , ibreak ) ; sqlite3vdbeaddop2 ( v , op_close , uniontab , 0 ) ; } break ; } default : assert ( p -> op == tk_intersect ) ; { int tab1 , tab2 ; int icont , ibreak , istart ; expr * plimit ; int addr ; selectdest intersectdest ; int r1 ; tab1 = pparse -> ntab ++ ; tab2 = pparse -> ntab ++ ; assert ( p -> porderby == 0 ) ; addr = sqlite3vdbeaddop2 ( v , op_openephemeral , tab1 , 0 ) ; assert ( p -> addropenephm [ 0 ] == - 1 ) ; p -> addropenephm [ 0 ] = addr ; findrightmost ( p ) -> selflags |= sf_usesephemeral ; assert ( p -> pelist ) ; sqlite3selectdestinit ( & intersectdest , srt_union , tab1 ) ; rc = sqlite3select ( pparse , pprior , & intersectdest ) ; if ( rc ) { goto multi_select_end ; } addr = sqlite3vdbeaddop2 ( v , op_openephemeral , tab2 , 0 ) ; assert ( p -> addropenephm [ 1 ] == - 1 ) ; p -> addropenephm [ 1 ] = addr ; p -> pprior = 0 ; plimit = p -> plimit ; p -> plimit = 0 ; intersectdest . isdparm = tab2 ; explainqueryplan ( ( pparse , 1 , ""%s<s2sv_blank>using<s2sv_blank>temp<s2sv_blank>b-tree"" , selectopname ( p -> op ) ) ) ; rc = sqlite3select ( pparse , p , & intersectdest ) ; testcase ( rc != sqlite_ok ) ; pdelete = p -> pprior ; p -> pprior = pprior ; if ( p -> nselectrow > pprior -> nselectrow ) { p -> nselectrow = pprior -> nselectrow ; } sqlite3exprdelete ( db , p -> plimit ) ; p -> plimit = plimit ; assert ( p -> pelist ) ; ibreak = sqlite3vdbemakelabel ( pparse ) ; icont = sqlite3vdbemakelabel ( pparse ) ; computelimitregisters ( pparse , p , ibreak ) ; sqlite3vdbeaddop2 ( v , op_rewind , tab1 , ibreak ) ; vdbecoverage ( v ) ; r1 = sqlite3gettempreg ( pparse ) ; istart = sqlite3vdbeaddop2 ( v , op_rowdata , tab1 , r1 ) ; sqlite3vdbeaddop4int ( v , op_notfound , tab2 , icont , r1 , 0 ) ; vdbecoverage ( v ) ; sqlite3releasetempreg ( pparse , r1 ) ; selectinnerloop ( pparse , p , tab1 , 0 , 0 , & dest , icont , ibreak ) ; sqlite3vdberesolvelabel ( v , icont ) ; sqlite3vdbeaddop2 ( v , op_next , tab1 , istart ) ; vdbecoverage ( v ) ; sqlite3vdberesolvelabel ( v , ibreak ) ; sqlite3vdbeaddop2 ( v , op_close , tab2 , 0 ) ; sqlite3vdbeaddop2 ( v , op_close , tab1 , 0 ) ; break ; } } # ifndef sqlite_omit_explain if ( p -> pnext == 0 ) { explainqueryplanpop ( pparse ) ; } # endif } if ( p -> selflags & sf_usesephemeral ) { int i ; keyinfo * pkeyinfo ; select * ploop ; collseq * * apcoll ; int ncol ; assert ( p -> pnext == 0 ) ; ncol = p -> pelist -> nexpr ; pkeyinfo = sqlite3keyinfoalloc ( db , ncol , 1 ) ; if ( ! pkeyinfo ) { rc = sqlite_nomem_bkpt ; goto multi_select_end ; } for ( i = 0 , apcoll = pkeyinfo -> acoll ; i < ncol ; i ++ , apcoll ++ ) { * apcoll = multiselectcollseq ( pparse , p , i ) ; if ( 0 == * apcoll ) { * apcoll = db -> pdfltcoll ; } } for ( ploop = p ; ploop ; ploop = ploop -> pprior ) { for ( i = 0 ; i < 2 ; i ++ ) { int addr = ploop -> addropenephm [ i ] ; if ( addr < 0 ) { assert ( ploop -> addropenephm [ 1 ] < 0 ) ; break ; } sqlite3vdbechangep2 ( v , addr , ncol ) ; sqlite3vdbechangep4 ( v , addr , ( char * ) sqlite3keyinforef ( pkeyinfo ) , p4_keyinfo ) ; ploop -> addropenephm [ i ] = - 1 ; } } sqlite3keyinfounref ( pkeyinfo ) ; } multi_select_end : pdest -> isdst = dest . isdst ; pdest -> nsdst = dest . nsdst ; sqlite3selectdelete ( db , pdelete ) ; return rc ; }","<S2SV_ModStart> } if ( pParse -> nErr ) goto multi_select_end ; if (
",sqlite@sqlite/8428b3b437569338a9d1e10c4cd8154acbe33089,CVE-2019-19926,https://github.com/sqlite/sqlite/commit/8428b3b437569338a9d1e10c4cd8154acbe33089,2019-12-23T01:15Z,<S2SV_StartBug> if ( p -> selFlags & SF_UsesEphemeral ) { <S2SV_EndBug>
3306,CWE-119,"static ssize_t wdm_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { int rv , cntr ; int i = 0 ; struct wdm_device * desc = file -> private_data ; rv = mutex_lock_interruptible ( & desc -> rlock ) ; if ( rv < 0 ) return - erestartsys ; cntr = access_once ( desc -> length ) ; if ( cntr == 0 ) { desc -> read = 0 ; retry : if ( test_bit ( wdm_disconnecting , & desc -> flags ) ) { rv = - enodev ; goto err ; } i ++ ; if ( file -> f_flags & o_nonblock ) { if ( ! test_bit ( wdm_read , & desc -> flags ) ) { rv = cntr ? cntr : - eagain ; goto err ; } rv = 0 ; } else { rv = wait_event_interruptible ( desc -> wait , test_bit ( wdm_read , & desc -> flags ) ) ; } if ( test_bit ( wdm_disconnecting , & desc -> flags ) ) { rv = - enodev ; goto err ; } if ( test_bit ( wdm_resetting , & desc -> flags ) ) { rv = - eio ; goto err ; } usb_mark_last_busy ( interface_to_usbdev ( desc -> intf ) ) ; if ( rv < 0 ) { rv = - erestartsys ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; if ( desc -> rerr ) { desc -> rerr = 0 ; spin_unlock_irq ( & desc -> iuspin ) ; rv = - eio ; goto err ; } if ( ! test_bit ( wdm_read , & desc -> flags ) ) { spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } if ( ! desc -> reslength ) { dev_dbg ( & desc -> intf -> dev , ""%s:<s2sv_blank>zero<s2sv_blank>length<s2sv_blank>-<s2sv_blank>clearing<s2sv_blank>wdm_read\\n"" , __func__ ) ; clear_bit ( wdm_read , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } cntr = desc -> length ; spin_unlock_irq ( & desc -> iuspin ) ; } if ( cntr > count ) cntr = count ; rv = copy_to_user ( buffer , desc -> ubuf , cntr ) ; if ( rv > 0 ) { rv = - efault ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; for ( i = 0 ; i < desc -> length - cntr ; i ++ ) desc -> ubuf [ i ] = desc -> ubuf [ i + cntr ] ; desc -> length -= cntr ; if ( ! desc -> length ) clear_bit ( wdm_read , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; rv = cntr ; err : mutex_unlock ( & desc -> rlock ) ; return rv ; }","<S2SV_ModStart> err ; } if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; }
",torvalds@linux/c0f5ecee4e741667b2493c742b60b6218d40b3aa,CVE-2013-1860,https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa,2013-03-22T11:59Z,<S2SV_StartBug> i ++ ; <S2SV_EndBug>
5996,CWE-119,"static int psf_close ( sf_private * psf ) { uint32_t k ; int error = 0 ; if ( psf -> codec_close ) { error = psf -> codec_close ( psf ) ; psf -> codec_close = null ; } ; if ( psf -> container_close ) error = psf -> container_close ( psf ) ; error = psf_fclose ( psf ) ; psf_close_rsrc ( psf ) ; free ( psf -> container_data ) ; free ( psf -> codec_data ) ; free ( psf -> interleave ) ; free ( psf -> dither ) ; free ( psf -> peak_info ) ; free ( psf -> broadcast_16k ) ; free ( psf -> loop_info ) ; free ( psf -> instrument ) ; free ( psf -> cues ) ; free ( psf -> channel_map ) ; free ( psf -> format_desc ) ; free ( psf -> strings . storage ) ; if ( psf -> wchunks . chunks ) for ( k = 0 ; k < psf -> wchunks . used ; k ++ ) free ( psf -> wchunks . chunks [ k ] . data ) ; free ( psf -> rchunks . chunks ) ; free ( psf -> wchunks . chunks ) ; free ( psf -> iterator ) ; free ( psf -> cart_16k ) ; memset ( psf , 0 , sizeof ( sf_private ) ) ; free ( psf ) ; return error ; }","<S2SV_ModStart> psf_close_rsrc ( psf ) ; free ( psf -> header . ptr
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,<S2SV_StartBug> psf_close_rsrc ( psf ) ; <S2SV_EndBug>
673,CWE-404,"static int omninet_open ( struct tty_struct * tty , struct usb_serial_port * port ) { struct usb_serial * serial = port -> serial ; struct usb_serial_port * wport ; wport = serial -> port [ 1 ] ; tty_port_tty_set ( & wport -> port , tty ) ; return usb_serial_generic_open ( tty , port ) ; }","<S2SV_ModStart> port ) { <S2SV_ModEnd> return usb_serial_generic_open (
",torvalds@linux/30572418b445d85fcfe6c8fe84c947d2606767d8,CVE-2017-8925,https://github.com/torvalds/linux/commit/30572418b445d85fcfe6c8fe84c947d2606767d8,2017-05-12T21:29Z,<S2SV_StartBug> struct usb_serial * serial = port -> serial ; <S2SV_EndBug>
7359,CWE-352,"static void dopost ( httprequest req , httpresponse res ) { set_content_type ( res , ""text/html"" ) ; if ( action ( run ) ) handle_run ( req , res ) ; else if ( action ( status ) ) print_status ( req , res , 1 ) ; else if ( action ( status2 ) ) print_status ( req , res , 2 ) ; else if ( action ( summary ) ) print_summary ( req , res ) ; else if ( action ( report ) ) _printreport ( req , res ) ; else if ( action ( doaction ) ) handle_do_action ( req , res ) ; else handle_action ( req , res ) ; }","<S2SV_ModStart> ( ACTION ( RUNTIME ) ) handle_runtime_action ( req , res ) ; else if ( ACTION ( VIEWLOG ) ) do_viewlog <S2SV_ModEnd> ( req , <S2SV_ModStart> DOACTION ) ) handle_doaction <S2SV_ModEnd> ( req , <S2SV_ModStart> ) ; else handle_service_action <S2SV_ModEnd> ( req ,
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,"<S2SV_StartBug> if ( ACTION ( RUN ) ) <S2SV_EndBug> <S2SV_StartBug> handle_do_action ( req , res ) ; <S2SV_EndBug> <S2SV_StartBug> handle_action ( req , res ) ; <S2SV_EndBug>"
2161,CWE-20,"void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) { __issue_discard_cmd ( sbi , false ) ; __drop_discard_cmd ( sbi ) ; __wait_discard_cmd ( sbi , false ) ; }","<S2SV_ModStart> f2fs_sb_info * sbi , bool umount <S2SV_ModStart> ( sbi , ! umount <S2SV_ModEnd> ) ; }
",torvalds@linux/638164a2718f337ea224b747cf5977ef143166a4,CVE-2017-18200,https://github.com/torvalds/linux/commit/638164a2718f337ea224b747cf5977ef143166a4,2018-02-26T03:29Z,"<S2SV_StartBug> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) <S2SV_EndBug> <S2SV_StartBug> __wait_discard_cmd ( sbi , false ) ; <S2SV_EndBug>"
220,CWE-310,"int asn1_ber_decoder ( const struct asn1_decoder * decoder , void * context , const unsigned char * data , size_t datalen ) { const unsigned char * machine = decoder -> machine ; const asn1_action_t * actions = decoder -> actions ; size_t machlen = decoder -> machlen ; enum asn1_opcode op ; unsigned char tag = 0 , csp = 0 , jsp = 0 , optag = 0 , hdr = 0 ; const char * errmsg ; size_t pc = 0 , dp = 0 , tdp = 0 , len = 0 ; int ret ; unsigned char flags = 0 ; # define flag_indefinite_length 0x01 # define flag_matched 0x02 # define flag_last_matched 0x04 # define flag_cons 0x20 # define nr_cons_stack 10 unsigned short cons_dp_stack [ nr_cons_stack ] ; unsigned short cons_datalen_stack [ nr_cons_stack ] ; unsigned char cons_hdrlen_stack [ nr_cons_stack ] ; # define nr_jump_stack 10 unsigned char jump_stack [ nr_jump_stack ] ; if ( datalen > 65535 ) return - emsgsize ; next_op : pr_debug ( ""next_op:<s2sv_blank>pc=\\e[32m%zu\\e[m/%zu<s2sv_blank>dp=\\e[33m%zu\\e[m/%zu<s2sv_blank>c=%d<s2sv_blank>j=%d\\n"" , pc , machlen , dp , datalen , csp , jsp ) ; if ( unlikely ( pc >= machlen ) ) goto machine_overrun_error ; op = machine [ pc ] ; if ( unlikely ( pc + asn1_op_lengths [ op ] > machlen ) ) goto machine_overrun_error ; if ( op <= asn1_op__matches_tag ) { unsigned char tmp ; if ( ( op & asn1_op_match__cond && flags & flag_matched ) || dp == datalen ) { flags &= ~ flag_last_matched ; pc += asn1_op_lengths [ op ] ; goto next_op ; } flags = 0 ; hdr = 2 ; if ( unlikely ( dp >= datalen - 1 ) ) goto data_overrun_error ; tag = data [ dp ++ ] ; if ( unlikely ( ( tag & 0x1f ) == asn1_long_tag ) ) goto long_tag_not_supported ; if ( op & asn1_op_match__any ) { pr_debug ( ""-<s2sv_blank>any<s2sv_blank>%02x\\n"" , tag ) ; } else { optag = machine [ pc + 1 ] ; flags |= optag & flag_cons ; tmp = optag ^ tag ; tmp &= ~ ( optag & asn1_cons_bit ) ; pr_debug ( ""-<s2sv_blank>match?<s2sv_blank>%02x<s2sv_blank>%02x<s2sv_blank>%02x\\n"" , tag , optag , tmp ) ; if ( tmp != 0 ) { if ( op & asn1_op_match__skip ) { pc += asn1_op_lengths [ op ] ; dp -- ; goto next_op ; } goto tag_mismatch ; } } flags |= flag_matched ; len = data [ dp ++ ] ; if ( len > 0x7f ) { if ( unlikely ( len == asn1_indefinite_length ) ) { if ( unlikely ( ! ( tag & asn1_cons_bit ) ) ) goto indefinite_len_primitive ; flags |= flag_indefinite_length ; if ( unlikely ( 2 > datalen - dp ) ) goto data_overrun_error ; } else { int n = len - 0x80 ; if ( unlikely ( n > 2 ) ) goto length_too_long ; if ( unlikely ( dp >= datalen - n ) ) goto data_overrun_error ; hdr += n ; for ( len = 0 ; n > 0 ; n -- ) { len <<= 8 ; len |= data [ dp ++ ] ; } if ( unlikely ( len > datalen - dp ) ) goto data_overrun_error ; } } if ( flags & flag_cons ) { if ( unlikely ( csp >= nr_cons_stack ) ) goto cons_stack_overflow ; cons_dp_stack [ csp ] = dp ; cons_hdrlen_stack [ csp ] = hdr ; if ( ! ( flags & flag_indefinite_length ) ) { cons_datalen_stack [ csp ] = datalen ; datalen = dp + len ; } else { cons_datalen_stack [ csp ] = 0 ; } csp ++ ; } pr_debug ( ""-<s2sv_blank>tag:<s2sv_blank>%02x<s2sv_blank>%zu%s\\n"" , tag , len , flags & flag_cons ? ""<s2sv_blank>cons"" : """" ) ; tdp = dp ; } switch ( op ) { case asn1_op_match_any_act : case asn1_op_cond_match_any_act : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case asn1_op_match_act : case asn1_op_match_act_or_skip : case asn1_op_cond_match_act_or_skip : ret = actions [ machine [ pc + 2 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case asn1_op_match : case asn1_op_match_or_skip : case asn1_op_match_any : case asn1_op_cond_match_or_skip : case asn1_op_cond_match_any : skip_data : if ( ! ( flags & flag_cons ) ) { if ( flags & flag_indefinite_length ) { ret = asn1_find_indefinite_length ( data , datalen , & dp , & len , & errmsg ) ; if ( ret < 0 ) goto error ; } else { dp += len ; } pr_debug ( ""-<s2sv_blank>leaf:<s2sv_blank>%zu\\n"" , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case asn1_op_match_jump : case asn1_op_match_jump_or_skip : case asn1_op_cond_match_jump_or_skip : pr_debug ( ""-<s2sv_blank>match_jump\\n"" ) ; if ( unlikely ( jsp == nr_jump_stack ) ) goto jump_stack_overflow ; jump_stack [ jsp ++ ] = pc + asn1_op_lengths [ op ] ; pc = machine [ pc + 2 ] ; goto next_op ; case asn1_op_cond_fail : if ( unlikely ( ! ( flags & flag_matched ) ) ) goto tag_mismatch ; pc += asn1_op_lengths [ op ] ; goto next_op ; case asn1_op_complete : if ( unlikely ( jsp != 0 || csp != 0 ) ) { pr_err ( ""asn.1<s2sv_blank>decoder<s2sv_blank>error:<s2sv_blank>stacks<s2sv_blank>not<s2sv_blank>empty<s2sv_blank>at<s2sv_blank>completion<s2sv_blank>(%u,<s2sv_blank>%u)\\n"" , jsp , csp ) ; return - ebadmsg ; } return 0 ; case asn1_op_end_set : case asn1_op_end_set_act : if ( unlikely ( ! ( flags & flag_matched ) ) ) goto tag_mismatch ; case asn1_op_end_seq : case asn1_op_end_set_of : case asn1_op_end_seq_of : case asn1_op_end_seq_act : case asn1_op_end_set_of_act : case asn1_op_end_seq_of_act : if ( unlikely ( csp <= 0 ) ) goto cons_stack_underflow ; csp -- ; tdp = cons_dp_stack [ csp ] ; hdr = cons_hdrlen_stack [ csp ] ; len = datalen ; datalen = cons_datalen_stack [ csp ] ; pr_debug ( ""-<s2sv_blank>end<s2sv_blank>cons<s2sv_blank>t=%zu<s2sv_blank>dp=%zu<s2sv_blank>l=%zu/%zu\\n"" , tdp , dp , len , datalen ) ; if ( datalen == 0 ) { datalen = len ; if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; if ( data [ dp ++ ] != 0 ) { if ( op & asn1_op_end__of ) { dp -- ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<s2sv_blank>continue\\n"" ) ; goto next_op ; } goto missing_eoc ; } if ( data [ dp ++ ] != 0 ) goto invalid_eoc ; len = dp - tdp - 2 ; } else { if ( dp < len && ( op & asn1_op_end__of ) ) { datalen = len ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<s2sv_blank>continue\\n"" ) ; goto next_op ; } if ( dp != len ) goto cons_length_error ; len -= tdp ; pr_debug ( ""-<s2sv_blank>cons<s2sv_blank>len<s2sv_blank>l=%zu<s2sv_blank>d=%zu\\n"" , len , dp - tdp ) ; } if ( op & asn1_op_end__act ) { unsigned char act ; if ( op & asn1_op_end__of ) act = machine [ pc + 2 ] ; else act = machine [ pc + 1 ] ; ret = actions [ act ] ( context , hdr , 0 , data + tdp , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case asn1_op_maybe_act : if ( ! ( flags & flag_last_matched ) ) { pc += asn1_op_lengths [ op ] ; goto next_op ; } case asn1_op_act : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + tdp , len ) ; if ( ret < 0 ) return ret ; pc += asn1_op_lengths [ op ] ; goto next_op ; case asn1_op_return : if ( unlikely ( jsp <= 0 ) ) goto jump_stack_underflow ; pc = jump_stack [ -- jsp ] ; flags |= flag_matched | flag_last_matched ; goto next_op ; default : break ; } pr_err ( ""asn.1<s2sv_blank>decoder<s2sv_blank>error:<s2sv_blank>found<s2sv_blank>reserved<s2sv_blank>opcode<s2sv_blank>(%u)<s2sv_blank>pc=%zu\\n"" , op , pc ) ; return - ebadmsg ; data_overrun_error : errmsg = ""data<s2sv_blank>overrun<s2sv_blank>error"" ; goto error ; machine_overrun_error : errmsg = ""machine<s2sv_blank>overrun<s2sv_blank>error"" ; goto error ; jump_stack_underflow : errmsg = ""jump<s2sv_blank>stack<s2sv_blank>underflow"" ; goto error ; jump_stack_overflow : errmsg = ""jump<s2sv_blank>stack<s2sv_blank>overflow"" ; goto error ; cons_stack_underflow : errmsg = ""cons<s2sv_blank>stack<s2sv_blank>underflow"" ; goto error ; cons_stack_overflow : errmsg = ""cons<s2sv_blank>stack<s2sv_blank>overflow"" ; goto error ; cons_length_error : errmsg = ""cons<s2sv_blank>length<s2sv_blank>error"" ; goto error ; missing_eoc : errmsg = ""missing<s2sv_blank>eoc<s2sv_blank>in<s2sv_blank>indefinite<s2sv_blank>len<s2sv_blank>cons"" ; goto error ; invalid_eoc : errmsg = ""invalid<s2sv_blank>length<s2sv_blank>eoc"" ; goto error ; length_too_long : errmsg = ""unsupported<s2sv_blank>length"" ; goto error ; indefinite_len_primitive : errmsg = ""indefinite<s2sv_blank>len<s2sv_blank>primitive<s2sv_blank>not<s2sv_blank>permitted"" ; goto error ; tag_mismatch : errmsg = ""unexpected<s2sv_blank>tag"" ; goto error ; long_tag_not_supported : errmsg = ""long<s2sv_blank>tag<s2sv_blank>not<s2sv_blank>supported"" ; error : pr_debug ( ""\\nasn1:<s2sv_blank>%s<s2sv_blank>[m=%zu<s2sv_blank>d=%zu<s2sv_blank>ot=%02x<s2sv_blank>t=%02x<s2sv_blank>l=%zu]\\n"" , errmsg , pc , dp , optag , tag , len ) ; return - ebadmsg ; }","<S2SV_ModStart> FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> dp == datalen )
",torvalds@linux/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,CVE-2016-2053,https://github.com/torvalds/linux/commit/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,2016-05-02T10:59Z,<S2SV_StartBug> dp == datalen ) { <S2SV_EndBug>
6719,CWE-444,"static ngx_int_t ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r ) { ngx_table_elt_t * header ; ngx_list_part_t * part ; ngx_uint_t i ; if ( ngx_list_init ( & sr -> headers_in . headers , sr -> pool , 20 , sizeof ( ngx_table_elt_t ) ) != ngx_ok ) { return ngx_error ; } dd ( ""before:<s2sv_blank>parent<s2sv_blank>req<s2sv_blank>headers<s2sv_blank>count:<s2sv_blank>%d"" , ( int ) r -> headers_in . headers . part . nelts ) ; part = & r -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { if ( part -> next == null ) { break ; } part = part -> next ; header = part -> elts ; i = 0 ; } dd ( ""setting<s2sv_blank>request<s2sv_blank>header<s2sv_blank>%.*s:<s2sv_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == ngx_error ) { return ngx_error ; } } dd ( ""after:<s2sv_blank>parent<s2sv_blank>req<s2sv_blank>headers<s2sv_blank>count:<s2sv_blank>%d"" , ( int ) r -> headers_in . headers . part . nelts ) ; return ngx_ok ; }","<S2SV_ModStart> , ngx_http_request_t * pr , int pr_not_chunked <S2SV_ModEnd> ) { ngx_table_elt_t <S2SV_ModStart> { ngx_table_elt_t * clh , * <S2SV_ModStart> ; ngx_uint_t i ; u_char * p ; off_t len ; dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) pr -> headers_in . headers . part . nelts ) <S2SV_ModStart> NGX_ERROR ; } if ( sr -> request_body && ! pr_not_chunked ) { len = sr -> request_body -> buf ? ngx_buf_size ( sr -> request_body -> buf ) : 0 ; clh = ngx_list_push ( & sr <S2SV_ModEnd> -> headers_in . <S2SV_ModStart> headers_in . headers ) ; if ( clh <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) <S2SV_ModEnd> { return NGX_ERROR <S2SV_ModStart> NGX_ERROR ; } clh -> hash = ngx_http_lua_content_length_hash ; clh -> key = ngx_http_lua_content_length_header_key ; clh -> lowcase_key = ngx_pnalloc ( sr -> pool , clh -> key . len ) ; if ( clh -> lowcase_key == NULL ) { return NGX_ERROR ; } ngx_strlow ( clh -> lowcase_key , clh -> key . data , clh -> key . len ) ; p = ngx_palloc ( sr -> pool , NGX_OFF_T_LEN ) ; if ( p == NULL ) { return NGX_ERROR ; } clh -> value . data = p ; clh -> value . len = ngx_sprintf ( clh -> value . data , ""%O"" , len ) - clh -> value . data ; sr -> headers_in . content_length = clh ; sr -> headers_in . content_length_n = len ; dd ( ""sr<S2SV_blank>crafted<S2SV_blank>content-length:<S2SV_blank>%.*s"" , ( int ) sr -> headers_in . content_length -> value . len , sr -> headers_in . content_length -> value . data ) ; } part = & pr -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { if ( part -> next == NULL ) { break ; } part = part -> next ; header = part -> elts ; i = 0 ; } if ( ! pr_not_chunked && header [ i ] . key . len == sizeof ( ""Content-Length"" ) - 1 && ngx_strncasecmp ( header [ i ] . key . data , ( u_char * ) ""Content-Length"" , sizeof ( ""Content-Length"" ) - 1 ) == 0 ) { continue ; } dd ( ""sr<S2SV_blank>copied<S2SV_blank>req<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; } } dd ( <S2SV_ModEnd> ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( <S2SV_ModStart> ( int ) pr <S2SV_ModEnd> -> headers_in .
",openresty@lua-nginx-module/9ab38e8ee35fc08a57636b1b6190dca70b0076fa,CVE-2020-11724,https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa,2020-04-12T21:15Z,"<S2SV_StartBug> ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r ) <S2SV_EndBug> <S2SV_StartBug> ngx_table_elt_t * header ; <S2SV_EndBug> <S2SV_StartBug> ngx_uint_t i ; <S2SV_EndBug> <S2SV_StartBug> dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug> <S2SV_StartBug> if ( part -> next == NULL ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug>"
2555,CWE-19,"int xfs_attr3_leaf_clearflag ( struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_buf * bp ; int error ; # ifdef debug struct xfs_attr3_icleaf_hdr ichdr ; xfs_attr_leaf_name_local_t * name_loc ; int namelen ; char * name ; # endif trace_xfs_attr_leaf_clearflag ( args ) ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return ( error ) ; leaf = bp -> b_addr ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; assert ( entry -> flags & xfs_attr_incomplete ) ; # ifdef debug xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; assert ( args -> index < ichdr . count ) ; assert ( args -> index >= 0 ) ; if ( entry -> flags & xfs_attr_local ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; namelen = name_loc -> namelen ; name = ( char * ) name_loc -> nameval ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; namelen = name_rmt -> namelen ; name = ( char * ) name_rmt -> name ; } assert ( be32_to_cpu ( entry -> hashval ) == args -> hashval ) ; assert ( namelen == args -> namelen ) ; assert ( memcmp ( name , args -> name , namelen ) == 0 ) ; # endif entry -> flags &= ~ xfs_attr_incomplete ; xfs_trans_log_buf ( args -> trans , bp , xfs_da_logrange ( leaf , entry , sizeof ( * entry ) ) ) ; if ( args -> rmtblkno ) { assert ( ( entry -> flags & xfs_attr_local ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ; name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; xfs_trans_log_buf ( args -> trans , bp , xfs_da_logrange ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ; } return xfs_trans_roll ( & args -> trans , args -> dp ) ; }","<S2SV_ModStart> ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf
",torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z,<S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug>
6804,CWE-401,"static ssize_t qrtr_tun_write_iter ( struct kiocb * iocb , struct iov_iter * from ) { struct file * filp = iocb -> ki_filp ; struct qrtr_tun * tun = filp -> private_data ; size_t len = iov_iter_count ( from ) ; ssize_t ret ; void * kbuf ; kbuf = kzalloc ( len , gfp_kernel ) ; if ( ! kbuf ) return - enomem ; if ( ! copy_from_iter_full ( kbuf , len , from ) ) return - efault ; ret = qrtr_endpoint_post ( & tun -> ep , kbuf , len ) ; return ret < 0 ? ret : len ; }","<S2SV_ModStart> from ) ) { kfree ( kbuf ) ; <S2SV_ModStart> - EFAULT ; } <S2SV_ModStart> len ) ; kfree ( kbuf ) ;
",torvalds@linux/a21b7f0cff1906a93a0130b74713b15a0b36481d,CVE-2019-19079,https://github.com/torvalds/linux/commit/a21b7f0cff1906a93a0130b74713b15a0b36481d,2019-11-18T06:15Z,"<S2SV_StartBug> if ( ! copy_from_iter_full ( kbuf , len , from ) ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> return ret < 0 ? ret : len ; <S2SV_EndBug>"
3439,CWE-000,"static int treo_attach ( struct usb_serial * serial ) { struct usb_serial_port * swap_port ; if ( ! ( ( le16_to_cpu ( serial -> dev -> descriptor . idvendor ) == handspring_vendor_id ) || ( le16_to_cpu ( serial -> dev -> descriptor . idvendor ) == kyocera_vendor_id ) ) || ( serial -> num_interrupt_in == 0 ) ) return 0 ; # define copy_port ( dest , src ) do { int i ; for ( i = 0 ; i < array_size ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointaddress = src -> bulk_in_endpointaddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointaddress = src -> interrupt_in_endpointaddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; swap_port = kmalloc ( sizeof ( * swap_port ) , gfp_kernel ) ; if ( ! swap_port ) return - enomem ; copy_port ( swap_port , serial -> port [ 0 ] ) ; copy_port ( serial -> port [ 0 ] , serial -> port [ 1 ] ) ; copy_port ( serial -> port [ 1 ] , swap_port ) ; kfree ( swap_port ) ; return 0 ; }","<S2SV_ModStart> return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; }
",torvalds@linux/cac9b50b0d75a1d50d6c056ff65c005f3224c8e0,CVE-2016-2782,https://github.com/torvalds/linux/commit/cac9b50b0d75a1d50d6c056ff65c005f3224c8e0,2016-04-27T17:59Z,"<S2SV_StartBug> # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; <S2SV_EndBug>"
235,CWE-264,"void * arm_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) ) return memory ; return __dma_alloc ( dev , size , handle , gfp , prot , false , __builtin_return_address ( 0 ) ) ; }","<S2SV_ModStart> ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void
",torvalds@linux/0ea1ec713f04bdfac343c9702b21cd3a7c711826,CVE-2014-9888,https://github.com/torvalds/linux/commit/0ea1ec713f04bdfac343c9702b21cd3a7c711826,2016-08-06T10:59Z,"<S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug>"
5917,CWE-269,"int main ( int argc , char * * argv ) { const char * safepath = safe_path ; const char * confpath = null ; char * shargv [ ] = { null , null } ; char * sh ; const char * cmd ; char cmdline [ line_max ] ; char myname [ _pw_name_len + 1 ] ; struct passwd * original_pw , * target_pw ; struct rule * rule ; uid_t uid ; uid_t target = 0 ; gid_t groups [ ngroups_max + 1 ] ; int ngroups ; int i , ch ; int sflag = 0 ; int nflag = 0 ; char cwdpath [ path_max ] ; const char * cwd ; char * login_style = null ; char * * envp ; # ifndef linux setprogname ( ""doas"" ) ; # endif # ifndef linux closefrom ( stderr_fileno + 1 ) ; # endif uid = getuid ( ) ; while ( ( ch = getopt ( argc , argv , ""a:c:nsu:"" ) ) != - 1 ) { switch ( ch ) { case 'a' : login_style = optarg ; break ; case 'c' : confpath = optarg ; break ; case 'u' : if ( parseuid ( optarg , & target ) != 0 ) errx ( 1 , ""unknown<s2sv_blank>user"" ) ; break ; case 'n' : nflag = 1 ; break ; case 's' : sflag = 1 ; break ; default : usage ( ) ; break ; } } argv += optind ; argc -= optind ; if ( confpath ) { if ( sflag ) usage ( ) ; } else if ( ( ! sflag && ! argc ) || ( sflag && argc ) ) usage ( ) ; original_pw = getpwuid ( uid ) ; if ( ! original_pw ) err ( 1 , ""getpwuid<s2sv_blank>failed"" ) ; if ( strlcpy ( myname , original_pw -> pw_name , sizeof ( myname ) ) >= sizeof ( myname ) ) errx ( 1 , ""pw_name<s2sv_blank>too<s2sv_blank>long"" ) ; ngroups = getgroups ( ngroups_max , groups ) ; if ( ngroups == - 1 ) err ( 1 , ""can\'t<s2sv_blank>get<s2sv_blank>groups"" ) ; groups [ ngroups ++ ] = getgid ( ) ; if ( sflag ) { sh = getenv ( ""shell"" ) ; if ( sh == null || * sh == '\\0' ) { shargv [ 0 ] = strdup ( original_pw -> pw_shell ) ; if ( shargv [ 0 ] == null ) err ( 1 , null ) ; } else shargv [ 0 ] = sh ; argv = shargv ; argc = 1 ; } if ( confpath ) { checkconfig ( confpath , argc , argv , uid , groups , ngroups , target ) ; exit ( 1 ) ; } if ( geteuid ( ) ) errx ( 1 , ""not<s2sv_blank>installed<s2sv_blank>setuid"" ) ; parseconfig ( doas_conf , 1 ) ; ( void ) strlcpy ( cmdline , argv [ 0 ] , sizeof ( cmdline ) ) ; for ( i = 1 ; i < argc ; i ++ ) { if ( strlcat ( cmdline , ""<s2sv_blank>"" , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; if ( strlcat ( cmdline , argv [ i ] , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; } cmd = argv [ 0 ] ; if ( ! permit ( uid , groups , ngroups , & rule , target , cmd , ( const char * * ) argv + 1 ) ) { syslog ( log_authpriv | log_notice , ""failed<s2sv_blank>command<s2sv_blank>for<s2sv_blank>%s:<s2sv_blank>%s"" , myname , cmdline ) ; errc ( 1 , eperm , null ) ; } if ( ! ( rule -> options & nopass ) ) { if ( nflag ) errx ( 1 , ""authorization<s2sv_blank>required"" ) ; # if defined ( use_bsd_auth ) authuser ( myname , login_style , rule -> options & persist ) ; # elif defined ( use_pam ) # define pam_end ( msg ) do { syslog ( log_err , ""%s:<s2sv_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; warnx ( ""%s:<s2sv_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; pam_end ( pamh , pam_err ) ; exit ( exit_failure ) ; } while ( 0 ) pam_handle_t * pamh = null ; int pam_err ; int temp_stdin ; temp_stdin = dup ( stdin_fileno ) ; if ( temp_stdin == - 1 ) err ( 1 , ""dup"" ) ; close ( stdin_fileno ) ; int temp_stdout = dup ( 1 ) ; if ( temp_stdout == - 1 ) err ( 1 , ""dup"" ) ; close ( 1 ) ; if ( dup2 ( 2 , 1 ) == - 1 ) err ( 1 , ""dup2"" ) ; pam_err = pam_start ( ""doas"" , myname , & pamc , & pamh ) ; if ( pam_err != pam_success ) { if ( pamh != null ) pam_end ( ""pam_start"" ) ; syslog ( log_err , ""pam_start<s2sv_blank>failed:<s2sv_blank>%s"" , pam_strerror ( pamh , pam_err ) ) ; errx ( exit_failure , ""pam_start<s2sv_blank>failed"" ) ; } switch ( pam_err = pam_authenticate ( pamh , pam_silent ) ) { case pam_success : switch ( pam_err = pam_acct_mgmt ( pamh , pam_silent ) ) { case pam_success : break ; case pam_new_authtok_reqd : pam_err = pam_chauthtok ( pamh , pam_silent | pam_change_expired_authtok ) ; if ( pam_err != pam_success ) pam_end ( ""pam_chauthtok"" ) ; break ; case pam_auth_err : case pam_user_unknown : case pam_maxtries : syslog ( log_authpriv | log_notice , ""failed<s2sv_blank>auth<s2sv_blank>for<s2sv_blank>%s"" , myname ) ; errx ( exit_failure , ""second<s2sv_blank>authentication<s2sv_blank>failed"" ) ; break ; default : pam_end ( ""pam_acct_mgmt"" ) ; break ; } break ; case pam_auth_err : case pam_user_unknown : case pam_maxtries : syslog ( log_authpriv | log_notice , ""failed<s2sv_blank>auth<s2sv_blank>for<s2sv_blank>%s"" , myname ) ; errx ( exit_failure , ""authentication<s2sv_blank>failed"" ) ; break ; default : pam_end ( ""pam_authenticate"" ) ; break ; } pam_end ( pamh , pam_err ) ; # ifndef linux if ( dup2 ( temp_stdin , stdin_fileno ) == - 1 ) err ( 1 , ""dup2"" ) ; close ( temp_stdin ) ; # else close ( 1 ) ; if ( dup2 ( temp_stdout , 1 ) == - 1 ) err ( 1 , ""dup2"" ) ; # endif # else # error no auth module ! # endif } target_pw = getpwuid ( target ) ; if ( ! target_pw ) errx ( 1 , ""no<s2sv_blank>passwd<s2sv_blank>entry<s2sv_blank>for<s2sv_blank>target"" ) ; # if defined ( have_login_cap_h ) if ( setusercontext ( null , target_pw , target , login_setgroup | login_setpriority | login_setresources | login_setumask | login_setuser ) != 0 ) errx ( 1 , ""failed<s2sv_blank>to<s2sv_blank>set<s2sv_blank>user<s2sv_blank>context<s2sv_blank>for<s2sv_blank>target"" ) ; # endif if ( getcwd ( cwdpath , sizeof ( cwdpath ) ) == null ) cwd = ""(failed)"" ; else cwd = cwdpath ; # ifndef have_login_cap_h if ( target != 0 ) setuid ( target ) ; if ( geteuid ( ) == root_uid ) setuid ( root_uid ) ; # endif syslog ( log_authpriv | log_info , ""%s<s2sv_blank>ran<s2sv_blank>command<s2sv_blank>%s<s2sv_blank>as<s2sv_blank>%s<s2sv_blank>from<s2sv_blank>%s"" , myname , cmdline , target_pw -> pw_name , cwd ) ; envp = prepenv ( rule , original_pw , target_pw ) ; if ( rule -> cmd ) { if ( setenv ( ""path"" , safepath , 1 ) == - 1 ) err ( 1 , ""failed<s2sv_blank>to<s2sv_blank>set<s2sv_blank>path<s2sv_blank>\'%s\'"" , safepath ) ; } execvpe ( cmd , argv , envp ) ; if ( errno == enoent ) errx ( 1 , ""%s:<s2sv_blank>command<s2sv_blank>not<s2sv_blank>found"" , cmd ) ; err ( 1 , ""%s"" , cmd ) ; }","<S2SV_ModStart> EXIT_FAILURE ) ; \\\n} <S2SV_ModEnd> while ( 0 <S2SV_ModStart> ) ; # else # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresgid ( target_pw -> pw_gid , target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setresgid"" ) ; # else if ( setregid ( target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setregid"" ) ; # endif if ( initgroups ( target_pw -> pw_name , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""initgroups"" ) ; # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresuid ( target , target , target ) == - 1 ) err ( 1 , ""setresuid"" ) ; # else if ( setreuid ( target , target ) == - 1 ) err ( 1 , ""setreuid"" ) ; # endif # <S2SV_ModStart> = cwdpath ; <S2SV_ModEnd> syslog ( LOG_AUTHPRIV
",slicer69@doas/6cf0236184ff6304bf5e267ccf7ef02874069697,CVE-2019-15901,https://github.com/slicer69/doas/commit/6cf0236184ff6304bf5e267ccf7ef02874069697,2019-10-18T16:15Z,"<S2SV_StartBug> # define PAM_END ( msg ) do { syslog ( LOG_ERR , ""%s:<S2SV_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; warnx ( ""%s:<S2SV_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; pam_end ( pamh , pam_err ) ; exit ( EXIT_FAILURE ) ; } while ( 0 ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # ifndef HAVE_LOGIN_CAP_H <S2SV_EndBug>"
3207,CWE-200,"static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = null ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - efault ; goto __err ; } sprintf ( str , ""application<s2sv_blank>%i"" , current -> pid ) ; if ( tselect . id . dev_class != sndrv_timer_class_slave ) tselect . id . dev_sclass = sndrv_timer_sclass_application ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; kfree ( tu -> queue ) ; tu -> queue = null ; kfree ( tu -> tqueue ) ; tu -> tqueue = null ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , gfp_kernel ) ; if ( tu -> tqueue == null ) err = - enomem ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , gfp_kernel ) ; if ( tu -> queue == null ) err = - enomem ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = null ; } else { tu -> timeri -> flags |= sndrv_timer_iflg_fast ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; tu -> timeri -> disconnect = snd_timer_user_disconnect ; } __err : return err ; }","<S2SV_ModStart> goto __err ; tu -> qhead = tu -> qtail = tu -> qused = 0 ;
",torvalds@linux/ba3021b2c79b2fa9114f92790a99deb27a65b728,CVE-2017-1000380,https://github.com/torvalds/linux/commit/ba3021b2c79b2fa9114f92790a99deb27a65b728,2017-06-17T18:29Z,<S2SV_StartBug> kfree ( tu -> queue ) ; <S2SV_EndBug>
8246,CWE-787,"static inline int l2cap_config_req ( struct l2cap_conn * conn , struct l2cap_cmd_hdr * cmd , u16 cmd_len , u8 * data ) { struct l2cap_conf_req * req = ( struct l2cap_conf_req * ) data ; u16 dcid , flags ; u8 rsp [ 64 ] ; struct sock * sk ; int len ; dcid = __le16_to_cpu ( req -> dcid ) ; flags = __le16_to_cpu ( req -> flags ) ; bt_dbg ( ""dcid<s2sv_blank>0x%4.4x<s2sv_blank>flags<s2sv_blank>0x%2.2x"" , dcid , flags ) ; sk = l2cap_get_chan_by_scid ( & conn -> chan_list , dcid ) ; if ( ! sk ) return - enoent ; if ( sk -> sk_state == bt_disconn ) goto unlock ; len = cmd_len - sizeof ( * req ) ; if ( l2cap_pi ( sk ) -> conf_len + len > sizeof ( l2cap_pi ( sk ) -> conf_req ) ) { l2cap_send_cmd ( conn , cmd -> ident , l2cap_conf_rsp , l2cap_build_conf_rsp ( sk , rsp , l2cap_conf_reject , flags ) , rsp ) ; goto unlock ; } memcpy ( l2cap_pi ( sk ) -> conf_req + l2cap_pi ( sk ) -> conf_len , req -> data , len ) ; l2cap_pi ( sk ) -> conf_len += len ; if ( flags & 0x0001 ) { l2cap_send_cmd ( conn , cmd -> ident , l2cap_conf_rsp , l2cap_build_conf_rsp ( sk , rsp , l2cap_conf_success , 0x0001 ) , rsp ) ; goto unlock ; } len = l2cap_parse_conf_req ( sk , rsp ) ; if ( len < 0 ) goto unlock ; l2cap_send_cmd ( conn , cmd -> ident , l2cap_conf_rsp , len , rsp ) ; l2cap_pi ( sk ) -> conf_len = 0 ; if ( ! ( l2cap_pi ( sk ) -> conf_state & l2cap_conf_output_done ) ) goto unlock ; if ( l2cap_pi ( sk ) -> conf_state & l2cap_conf_input_done ) { sk -> sk_state = bt_connected ; l2cap_chan_ready ( sk ) ; goto unlock ; } if ( ! ( l2cap_pi ( sk ) -> conf_state & l2cap_conf_req_sent ) ) { u8 buf [ 64 ] ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , l2cap_conf_req , l2cap_build_conf_req ( sk , buf ) , buf ) ; } unlock : bh_unlock_sock ( sk ) ; return 0 ; }","<S2SV_ModStart> < 0 ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; <S2SV_ModStart> goto unlock ; } <S2SV_ModStart> , rsp ) ; l2cap_pi ( sk ) -> num_conf_rsp ++ <S2SV_ModStart> buf ) ; l2cap_pi ( sk ) -> num_conf_req ++ ;
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z,"<S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , len , rsp ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
5988,CWE-119,"static inline void header_put_le_3byte ( sf_private * psf , int x ) { if ( psf -> headindex < signed_sizeof ( psf -> header ) - 3 ) { psf -> header [ psf -> headindex ++ ] = x ; psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; } ; }","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug>
3524,CWE-264,"static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg , u8 cpl , bool in_task_switch ) { struct desc_struct seg_desc , old_desc ; u8 dpl , rpl ; unsigned err_vec = gp_vector ; u32 err_code = 0 ; bool null_selector = ! ( selector & ~ 0x3 ) ; ulong desc_addr ; int ret ; u16 dummy ; u32 base3 = 0 ; memset ( & seg_desc , 0 , sizeof seg_desc ) ; if ( ctxt -> mode == x86emul_mode_real ) { ctxt -> ops -> get_segment ( ctxt , & dummy , & seg_desc , null , seg ) ; set_desc_base ( & seg_desc , selector << 4 ) ; goto load ; } else if ( seg <= vcpu_sreg_gs && ctxt -> mode == x86emul_mode_vm86 ) { set_desc_base ( & seg_desc , selector << 4 ) ; set_desc_limit ( & seg_desc , 0xffff ) ; seg_desc . type = 3 ; seg_desc . p = 1 ; seg_desc . s = 1 ; seg_desc . dpl = 3 ; goto load ; } rpl = selector & 3 ; if ( ( seg == vcpu_sreg_cs || ( seg == vcpu_sreg_ss && ( ctxt -> mode != x86emul_mode_prot64 || rpl != cpl ) ) || seg == vcpu_sreg_tr ) && null_selector ) goto exception ; if ( seg == vcpu_sreg_tr && ( selector & ( 1 << 2 ) ) ) goto exception ; if ( null_selector ) goto load ; ret = read_segment_descriptor ( ctxt , selector , & seg_desc , & desc_addr ) ; if ( ret != x86emul_continue ) return ret ; err_code = selector & 0xfffc ; err_vec = in_task_switch ? ts_vector : gp_vector ; if ( seg <= vcpu_sreg_gs && ! seg_desc . s ) goto exception ; if ( ! seg_desc . p ) { err_vec = ( seg == vcpu_sreg_ss ) ? ss_vector : np_vector ; goto exception ; } dpl = seg_desc . dpl ; switch ( seg ) { case vcpu_sreg_ss : if ( rpl != cpl || ( seg_desc . type & 0xa ) != 0x2 || dpl != cpl ) goto exception ; break ; case vcpu_sreg_cs : if ( ! ( seg_desc . type & 8 ) ) goto exception ; if ( seg_desc . type & 4 ) { if ( dpl > cpl ) goto exception ; } else { if ( rpl > cpl || dpl != cpl ) goto exception ; } if ( seg_desc . d && seg_desc . l ) { u64 efer = 0 ; ctxt -> ops -> get_msr ( ctxt , msr_efer , & efer ) ; if ( efer & efer_lma ) goto exception ; } selector = ( selector & 0xfffc ) | cpl ; break ; case vcpu_sreg_tr : if ( seg_desc . s || ( seg_desc . type != 1 && seg_desc . type != 9 ) ) goto exception ; old_desc = seg_desc ; seg_desc . type |= 2 ; ret = ctxt -> ops -> cmpxchg_emulated ( ctxt , desc_addr , & old_desc , & seg_desc , sizeof ( seg_desc ) , & ctxt -> exception ) ; if ( ret != x86emul_continue ) return ret ; break ; case vcpu_sreg_ldtr : if ( seg_desc . s || seg_desc . type != 2 ) goto exception ; break ; default : if ( ( seg_desc . type & 0xa ) == 0x8 || ( ( ( seg_desc . type & 0xc ) != 0xc ) && ( rpl > dpl && cpl > dpl ) ) ) goto exception ; break ; } if ( seg_desc . s ) { seg_desc . type |= 1 ; ret = write_segment_descriptor ( ctxt , selector , & seg_desc ) ; if ( ret != x86emul_continue ) return ret ; } else if ( ctxt -> mode == x86emul_mode_prot64 ) { ret = ctxt -> ops -> read_std ( ctxt , desc_addr + 8 , & base3 , sizeof ( base3 ) , & ctxt -> exception ) ; if ( ret != x86emul_continue ) return ret ; } load : ctxt -> ops -> set_segment ( ctxt , selector , & seg_desc , base3 , seg ) ; return x86emul_continue ; exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ; }","<S2SV_ModStart> , bool in_task_switch , struct desc_struct * desc <S2SV_ModStart> seg ) ; if ( desc ) * desc = seg_desc ;
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z,"<S2SV_StartBug> u16 selector , int seg , u8 cpl , bool in_task_switch ) <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug>"
2915,CWE-000,"struct sk_buff * nf_ct_frag6_gather ( struct sk_buff * skb , u32 user ) { struct sk_buff * clone ; struct net_device * dev = skb -> dev ; struct frag_hdr * fhdr ; struct nf_ct_frag6_queue * fq ; struct ipv6hdr * hdr ; int fhoff , nhoff ; u8 prevhdr ; struct sk_buff * ret_skb = null ; if ( ipv6_hdr ( skb ) -> payload_len == 0 ) { pr_debug ( ""payload<s2sv_blank>len<s2sv_blank>=<s2sv_blank>0\\n"" ) ; return skb ; } if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ; clone = skb_clone ( skb , gfp_atomic ) ; if ( clone == null ) { pr_debug ( ""can\'t<s2sv_blank>clone<s2sv_blank>skb\\n"" ) ; return skb ; } nfct_frag6_cb ( clone ) -> orig = skb ; if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) { pr_debug ( ""message<s2sv_blank>is<s2sv_blank>too<s2sv_blank>short.\\n"" ) ; goto ret_orig ; } skb_set_transport_header ( clone , fhoff ) ; hdr = ipv6_hdr ( clone ) ; fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ; if ( ! ( fhdr -> frag_off & htons ( 0xfff9 ) ) ) { pr_debug ( ""invalid<s2sv_blank>fragment<s2sv_blank>offset\\n"" ) ; goto ret_orig ; } if ( atomic_read ( & nf_init_frags . mem ) > nf_init_frags . high_thresh ) nf_ct_frag6_evictor ( ) ; fq = fq_find ( fhdr -> identification , user , & hdr -> saddr , & hdr -> daddr ) ; if ( fq == null ) { pr_debug ( ""can\'t<s2sv_blank>find<s2sv_blank>and<s2sv_blank>can\'t<s2sv_blank>create<s2sv_blank>new<s2sv_blank>queue\\n"" ) ; goto ret_orig ; } spin_lock_bh ( & fq -> q . lock ) ; if ( nf_ct_frag6_queue ( fq , clone , fhdr , nhoff ) < 0 ) { spin_unlock_bh ( & fq -> q . lock ) ; pr_debug ( ""can\'t<s2sv_blank>insert<s2sv_blank>skb<s2sv_blank>to<s2sv_blank>queue\\n"" ) ; fq_put ( fq ) ; goto ret_orig ; } if ( fq -> q . last_in == ( inet_frag_first_in | inet_frag_last_in ) && fq -> q . meat == fq -> q . len ) { ret_skb = nf_ct_frag6_reasm ( fq , dev ) ; if ( ret_skb == null ) pr_debug ( ""can\'t<s2sv_blank>reassemble<s2sv_blank>fragmented<s2sv_blank>packets\\n"" ) ; } spin_unlock_bh ( & fq -> q . lock ) ; fq_put ( fq ) ; return ret_skb ; ret_orig : kfree_skb ( clone ) ; return skb ; }","<S2SV_ModStart> ; if ( <S2SV_ModEnd> atomic_read ( &
",torvalds@linux/9e2dcf72023d1447f09c47d77c99b0c49659e5ce,CVE-2012-2744,https://github.com/torvalds/linux/commit/9e2dcf72023d1447f09c47d77c99b0c49659e5ce,2012-08-09T10:29Z,<S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug>
4875,CWE-362,"static int mptctl_hp_hostinfo ( unsigned long arg , unsigned int data_size ) { hp_host_info_t __user * uarg = ( void __user * ) arg ; mpt_adapter * ioc ; struct pci_dev * pdev ; char * pbuf = null ; dma_addr_t buf_dma ; hp_host_info_t karg ; configparms cfg ; configpageheader_t hdr ; int iocnum ; int rc , cim_rev ; toolboxistwireadwriterequest_t * istwirwrequest ; mpt_frame_hdr * mf = null ; unsigned long timeleft ; int retval ; u32 msgcontext ; if ( data_size == sizeof ( hp_host_info_t ) ) cim_rev = 1 ; else if ( data_size == sizeof ( hp_host_info_rev0_t ) ) cim_rev = 0 ; else return - efault ; if ( copy_from_user ( & karg , uarg , sizeof ( hp_host_info_t ) ) ) { printk ( kern_err mynam ""%s@%d::mptctl_hp_host_info<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>read<s2sv_blank>in<s2sv_blank>hp_host_info<s2sv_blank>struct<s2sv_blank>@<s2sv_blank>%p\\n"" , __file__ , __line__ , uarg ) ; return - efault ; } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == null ) ) { printk ( kern_debug mynam ""%s::mptctl_hp_hostinfo()<s2sv_blank>@%d<s2sv_blank>-<s2sv_blank>ioc%d<s2sv_blank>not<s2sv_blank>found!\\n"" , __file__ , __line__ , iocnum ) ; return - enodev ; } dctlprintk ( ioc , printk ( myioc_s_debug_fmt "":<s2sv_blank>mptctl_hp_hostinfo<s2sv_blank>called.\\n"" , ioc -> name ) ) ; pdev = ( struct pci_dev * ) ioc -> pcidev ; karg . vendor = pdev -> vendor ; karg . device = pdev -> device ; karg . subsystem_id = pdev -> subsystem_device ; karg . subsystem_vendor = pdev -> subsystem_vendor ; karg . devfn = pdev -> devfn ; karg . bus = pdev -> bus -> number ; if ( ioc -> sh != null ) karg . host_no = ioc -> sh -> host_no ; else karg . host_no = - 1 ; snprintf ( karg . fw_version , sizeof ( karg . fw_version ) , ""%.2hhu.%.2hhu.%.2hhu.%.2hhu"" , ioc -> facts . fwversion . struct . major , ioc -> facts . fwversion . struct . minor , ioc -> facts . fwversion . struct . unit , ioc -> facts . fwversion . struct . dev ) ; hdr . pageversion = 0 ; hdr . pagelength = 0 ; hdr . pagenumber = 0 ; hdr . pagetype = mpi_config_pagetype_manufacturing ; cfg . cfghdr . hdr = & hdr ; cfg . physaddr = - 1 ; cfg . pageaddr = 0 ; cfg . action = mpi_config_action_page_header ; cfg . dir = 0 ; cfg . timeout = 10 ; strncpy ( karg . serial_number , ""<s2sv_blank>"" , 24 ) ; if ( mpt_config ( ioc , & cfg ) == 0 ) { if ( cfg . cfghdr . hdr -> pagelength > 0 ) { cfg . action = mpi_config_action_page_read_current ; pbuf = pci_alloc_consistent ( ioc -> pcidev , hdr . pagelength * 4 , & buf_dma ) ; if ( pbuf ) { cfg . physaddr = buf_dma ; if ( mpt_config ( ioc , & cfg ) == 0 ) { manufacturingpage0_t * pdata = ( manufacturingpage0_t * ) pbuf ; if ( strlen ( pdata -> boardtracernumber ) > 1 ) { strlcpy ( karg . serial_number , pdata -> boardtracernumber , 24 ) ; } } pci_free_consistent ( ioc -> pcidev , hdr . pagelength * 4 , pbuf , buf_dma ) ; pbuf = null ; } } } rc = mpt_getiocstate ( ioc , 1 ) ; switch ( rc ) { case mpi_ioc_state_operational : karg . ioc_status = hp_status_ok ; break ; case mpi_ioc_state_fault : karg . ioc_status = hp_status_failed ; break ; case mpi_ioc_state_reset : case mpi_ioc_state_ready : default : karg . ioc_status = hp_status_other ; break ; } karg . base_io_addr = pci_resource_start ( pdev , 0 ) ; if ( ( ioc -> bus_type == sas ) || ( ioc -> bus_type == fc ) ) karg . bus_phys_width = hp_bus_width_unk ; else karg . bus_phys_width = hp_bus_width_16 ; karg . hard_resets = 0 ; karg . soft_resets = 0 ; karg . timeouts = 0 ; if ( ioc -> sh != null ) { mpt_scsi_host * hd = shost_priv ( ioc -> sh ) ; if ( hd && ( cim_rev == 1 ) ) { karg . hard_resets = ioc -> hard_resets ; karg . soft_resets = ioc -> soft_resets ; karg . timeouts = ioc -> timeouts ; } } if ( ( mf = mpt_get_msg_frame ( mptctl_id , ioc ) ) == null ) { dfailprintk ( ioc , printk ( myioc_s_warn_fmt ""%s,<s2sv_blank>no<s2sv_blank>msg<s2sv_blank>frames!!\\n"" , ioc -> name , __func__ ) ) ; goto out ; } istwirwrequest = ( toolboxistwireadwriterequest_t * ) mf ; msgcontext = istwirwrequest -> msgcontext ; memset ( istwirwrequest , 0 , sizeof ( toolboxistwireadwriterequest_t ) ) ; istwirwrequest -> msgcontext = msgcontext ; istwirwrequest -> function = mpi_function_toolbox ; istwirwrequest -> tool = mpi_toolbox_istwi_read_write_tool ; istwirwrequest -> flags = mpi_tb_istwi_flags_read ; istwirwrequest -> numaddressbytes = 0x01 ; istwirwrequest -> datalength = cpu_to_le16 ( 0x04 ) ; if ( pdev -> devfn & 1 ) istwirwrequest -> deviceaddr = 0xb2 ; else istwirwrequest -> deviceaddr = 0xb0 ; pbuf = pci_alloc_consistent ( ioc -> pcidev , 4 , & buf_dma ) ; if ( ! pbuf ) goto out ; ioc -> add_sge ( ( char * ) & istwirwrequest -> sgl , ( mpt_sge_flags_ssimple_read | 4 ) , buf_dma ) ; retval = 0 ; set_mgmt_msg_context ( ioc -> ioctl_cmds . msg_context , istwirwrequest -> msgcontext ) ; initialize_mgmt_status ( ioc -> ioctl_cmds . status ) mpt_put_msg_frame ( mptctl_id , ioc , mf ) ; retry_wait : timeleft = wait_for_completion_timeout ( & ioc -> ioctl_cmds . done , hz * mpt_ioctl_default_timeout ) ; if ( ! ( ioc -> ioctl_cmds . status & mpt_mgmt_status_command_good ) ) { retval = - etime ; printk ( myioc_s_warn_fmt ""%s:<s2sv_blank>failed\\n"" , ioc -> name , __func__ ) ; if ( ioc -> ioctl_cmds . status & mpt_mgmt_status_did_iocreset ) { mpt_free_msg_frame ( ioc , mf ) ; goto out ; } if ( ! timeleft ) { printk ( myioc_s_warn_fmt ""host<s2sv_blank>info<s2sv_blank>command<s2sv_blank>timeout,<s2sv_blank>doorbell=0x%08x\\n"" , ioc -> name , mpt_getiocstate ( ioc , 0 ) ) ; mptctl_timeout_expired ( ioc , mf ) ; } else goto retry_wait ; goto out ; } if ( ioc -> ioctl_cmds . status & mpt_mgmt_status_rf_valid ) karg . rsvd = * ( u32 * ) pbuf ; out : clear_mgmt_status ( ioc -> ioctl_cmds . status ) set_mgmt_msg_context ( ioc -> ioctl_cmds . msg_context , 0 ) ; if ( pbuf ) pci_free_consistent ( ioc -> pcidev , 4 , pbuf , buf_dma ) ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( hp_host_info_t ) ) ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_hpgethostinfo<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>write<s2sv_blank>out<s2sv_blank>hp_host_info<s2sv_blank>@<s2sv_blank>%p\\n"" , ioc -> name , __file__ , __line__ , uarg ) ; return - efault ; } return 0 ; }","<S2SV_ModStart> int mptctl_hp_hostinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> ) arg ; <S2SV_ModEnd> struct pci_dev * <S2SV_ModStart> ; ConfigPageHeader_t hdr <S2SV_ModEnd> ; int rc <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> dctlprintk ( ioc
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,"<S2SV_StartBug> mptctl_hp_hostinfo ( unsigned long arg , unsigned int data_size ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> ConfigPageHeader_t hdr ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug>"
5065,CWE-79,"static void do_viewlog ( httprequest req , httpresponse res ) { if ( is_readonly ( req ) ) { send_error ( req , res , sc_forbidden , ""you<s2sv_blank>do<s2sv_blank>not<s2sv_blank>have<s2sv_blank>sufficient<s2sv_blank>privileges<s2sv_blank>to<s2sv_blank>access<s2sv_blank>this<s2sv_blank>page"" ) ; return ; } do_head ( res , ""_viewlog"" , ""view<s2sv_blank>log"" , 100 ) ; if ( ( run . flags & run_log ) && ! ( run . flags & run_usesyslog ) ) { file * f = fopen ( run . files . log , ""r"" ) ; if ( f ) { size_t n ; char buf [ 512 ] ; stringbuffer_append ( res -> outputbuffer , ""<br><p><form><textarea<s2sv_blank>cols=120<s2sv_blank>rows=30<s2sv_blank>readonly>"" ) ; while ( ( n = fread ( buf , sizeof ( char ) , sizeof ( buf ) - 1 , f ) ) > 0 ) { buf [ n ] = 0 ; stringbuffer_append ( res -> outputbuffer , ""%s"" , buf ) ; } fclose ( f ) ; stringbuffer_append ( res -> outputbuffer , ""</textarea></form>"" ) ; } else { stringbuffer_append ( res -> outputbuffer , ""error<s2sv_blank>opening<s2sv_blank>logfile:<s2sv_blank>%s"" , strerror ) ; } } else { stringbuffer_append ( res -> outputbuffer , ""<b>cannot<s2sv_blank>view<s2sv_blank>logfile:</b><br>"" ) ; if ( ! ( run . flags & run_log ) ) stringbuffer_append ( res -> outputbuffer , ""monit<s2sv_blank>was<s2sv_blank>started<s2sv_blank>without<s2sv_blank>logging"" ) ; else stringbuffer_append ( res -> outputbuffer , ""monit<s2sv_blank>uses<s2sv_blank>syslog"" ) ; } do_foot ( res ) ; }","<S2SV_ModStart> = 0 ; escapeHTML ( res -> outputbuffer <S2SV_ModEnd> , buf )
",tildeslash@monit/328f60773057641c4b2075fab9820145e95b728c,CVE-2019-11454,https://bitbucket.org/tildeslash/monit/commit/328f60773057641c4b2075fab9820145e95b728c,2019-04-22T16:29Z,"<S2SV_StartBug> StringBuffer_append ( res -> outputbuffer , ""%s"" , buf ) ; <S2SV_EndBug>"
8362,CWE-362,"int ip_options_echo ( struct ip_options * dopt , struct sk_buff * skb ) { struct ip_options * sopt ; unsigned char * sptr , * dptr ; int soffset , doffset ; int optlen ; __be32 daddr ; memset ( dopt , 0 , sizeof ( struct ip_options ) ) ; sopt = & ( ipcb ( skb ) -> opt ) ; if ( sopt -> optlen == 0 ) { dopt -> optlen = 0 ; return 0 ; } sptr = skb_network_header ( skb ) ; dptr = dopt -> __data ; daddr = skb_rtable ( skb ) -> rt_spec_dst ; if ( sopt -> rr ) { optlen = sptr [ sopt -> rr + 1 ] ; soffset = sptr [ sopt -> rr + 2 ] ; dopt -> rr = dopt -> optlen + sizeof ( struct iphdr ) ; memcpy ( dptr , sptr + sopt -> rr , optlen ) ; if ( sopt -> rr_needaddr && soffset <= optlen ) { if ( soffset + 3 > optlen ) return - einval ; dptr [ 2 ] = soffset + 4 ; dopt -> rr_needaddr = 1 ; } dptr += optlen ; dopt -> optlen += optlen ; } if ( sopt -> ts ) { optlen = sptr [ sopt -> ts + 1 ] ; soffset = sptr [ sopt -> ts + 2 ] ; dopt -> ts = dopt -> optlen + sizeof ( struct iphdr ) ; memcpy ( dptr , sptr + sopt -> ts , optlen ) ; if ( soffset <= optlen ) { if ( sopt -> ts_needaddr ) { if ( soffset + 3 > optlen ) return - einval ; dopt -> ts_needaddr = 1 ; soffset += 4 ; } if ( sopt -> ts_needtime ) { if ( soffset + 3 > optlen ) return - einval ; if ( ( dptr [ 3 ] & 0xf ) != ipopt_ts_prespec ) { dopt -> ts_needtime = 1 ; soffset += 4 ; } else { dopt -> ts_needtime = 0 ; if ( soffset + 7 <= optlen ) { __be32 addr ; memcpy ( & addr , dptr + soffset - 1 , 4 ) ; if ( inet_addr_type ( dev_net ( skb_dst ( skb ) -> dev ) , addr ) != rtn_unicast ) { dopt -> ts_needtime = 1 ; soffset += 8 ; } } } } dptr [ 2 ] = soffset ; } dptr += optlen ; dopt -> optlen += optlen ; } if ( sopt -> srr ) { unsigned char * start = sptr + sopt -> srr ; __be32 faddr ; optlen = start [ 1 ] ; soffset = start [ 2 ] ; doffset = 0 ; if ( soffset > optlen ) soffset = optlen + 1 ; soffset -= 4 ; if ( soffset > 3 ) { memcpy ( & faddr , & start [ soffset - 1 ] , 4 ) ; for ( soffset -= 4 , doffset = 4 ; soffset > 3 ; soffset -= 4 , doffset += 4 ) memcpy ( & dptr [ doffset - 1 ] , & start [ soffset - 1 ] , 4 ) ; if ( memcmp ( & ip_hdr ( skb ) -> saddr , & start [ soffset + 3 ] , 4 ) == 0 ) doffset -= 4 ; } if ( doffset > 3 ) { memcpy ( & start [ doffset - 1 ] , & daddr , 4 ) ; dopt -> faddr = faddr ; dptr [ 0 ] = start [ 0 ] ; dptr [ 1 ] = doffset + 3 ; dptr [ 2 ] = 4 ; dptr += doffset + 3 ; dopt -> srr = dopt -> optlen + sizeof ( struct iphdr ) ; dopt -> optlen += doffset + 3 ; dopt -> is_strictroute = sopt -> is_strictroute ; } } if ( sopt -> cipso ) { optlen = sptr [ sopt -> cipso + 1 ] ; dopt -> cipso = dopt -> optlen + sizeof ( struct iphdr ) ; memcpy ( dptr , sptr + sopt -> cipso , optlen ) ; dptr += optlen ; dopt -> optlen += optlen ; } while ( dopt -> optlen & 3 ) { * dptr ++ = ipopt_end ; dopt -> optlen ++ ; } return 0 ; }","<S2SV_ModStart> skb ) { const <S2SV_ModStart> == 0 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> sptr = skb_network_header
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> struct ip_options * sopt ; <S2SV_EndBug> <S2SV_StartBug> if ( sopt -> optlen == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
7889,CWE-20,"error_t httpclientaddqueryparam ( httpclientcontext * context , const char_t * name , const char_t * value ) { size_t namelen ; size_t valuelen ; char_t separator ; char_t * p ; if ( context == null || name == null ) return error_invalid_parameter ; if ( name [ 0 ] == '\\0' ) return error_invalid_parameter ; if ( context -> requeststate != http_req_state_format_header ) return error_wrong_state ; if ( context -> bufferlen > http_client_buffer_size ) return error_invalid_syntax ; context -> buffer [ context -> bufferlen ] = '\\0' ; p = strchr ( context -> buffer , '<s2sv_blank>' ) ; if ( p == null ) return error_invalid_syntax ; p = strpbrk ( p + 1 , ""<s2sv_blank>?"" ) ; if ( p == null ) return error_invalid_syntax ; if ( * p == '?' ) { p = strchr ( p + 1 , '<s2sv_blank>' ) ; if ( p == null ) return error_invalid_syntax ; separator = '&' ; } else { separator = '?' ; } namelen = osstrlen ( name ) ; if ( value == null ) { if ( ( context -> bufferlen + namelen + 1 ) > http_client_buffer_size ) return error_buffer_overflow ; osmemmove ( p + namelen + 1 , p , context -> buffer + context -> bufferlen + 1 - p ) ; p [ 0 ] = separator ; osstrncpy ( p + 1 , name , namelen ) ; context -> bufferlen += namelen + 1 ; } else { valuelen = osstrlen ( value ) ; if ( ( context -> bufferlen + namelen + valuelen + 2 ) > http_client_buffer_size ) return error_buffer_overflow ; osmemmove ( p + namelen + valuelen + 2 , p , context -> buffer + context -> bufferlen + 1 - p ) ; p [ 0 ] = separator ; osstrncpy ( p + 1 , name , namelen ) ; p [ namelen + 1 ] = '=' ; osstrncpy ( p + namelen + 2 , value , valuelen ) ; context -> bufferlen += namelen + valuelen + 2 ; } return no_error ; }","<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> { p = osStrchr <S2SV_ModEnd> ( p +
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> <S2SV_StartBug> p = strchr ( p + 1 , '<S2SV_blank>' ) ; <S2SV_EndBug>"
5983,CWE-119,"static int header_gets ( sf_private * psf , char * ptr , int bufsize ) { int k ; for ( k = 0 ; k < bufsize - 1 ; k ++ ) { if ( psf -> headindex < psf -> headend ) { ptr [ k ] = psf -> header [ psf -> headindex ] ; psf -> headindex ++ ; } else { psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , 1 , psf ) ; ptr [ k ] = psf -> header [ psf -> headindex ] ; psf -> headindex = psf -> headend ; } ; if ( ptr [ k ] == '\\n' ) break ; } ; ptr [ k ] = 0 ; return k ; }","<S2SV_ModStart> int k ; if ( psf -> header . indx + bufsize >= psf -> header . len && psf_bump_header_allocation ( psf , bufsize ) ) return 0 ; <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> < psf -> <S2SV_ModStart> < psf -> header . end ) { ptr [ k ] = psf -> header . ptr [ psf -> header . indx ] ; psf -> header . indx <S2SV_ModEnd> ++ ; } <S2SV_ModStart> { psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> psf -> header . ptr [ psf -> header . indx ] ; psf -> header . indx = psf -> header . end <S2SV_ModEnd> ; } ;
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,"<S2SV_StartBug> for ( k = 0 ; k < bufsize - 1 ; k ++ ) <S2SV_EndBug> <S2SV_StartBug> { if ( psf -> headindex < psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> { psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , 1 , psf ) ; <S2SV_EndBug> <S2SV_StartBug> ptr [ k ] = psf -> header [ psf -> headindex ] ; <S2SV_EndBug>"
980,CWE-416,"static struct ipv6_txoptions * ipv6_update_options ( struct sock * sk , struct ipv6_txoptions * opt ) { if ( inet_sk ( sk ) -> is_icsk ) { if ( opt && ! ( ( 1 << sk -> sk_state ) & ( tcpf_listen | tcpf_close ) ) && inet_sk ( sk ) -> inet_daddr != loopback4_ipv6 ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen ; icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } } opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; sk_dst_reset ( sk ) ; return opt ; }","<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * )
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,"<S2SV_StartBug> opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; <S2SV_EndBug>"
47,CWE-200,"static int l2tp_ip6_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) { struct sockaddr_l2tpip6 * lsa = ( struct sockaddr_l2tpip6 * ) uaddr ; struct sock * sk = sock -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct l2tp_ip6_sock * lsk = l2tp_ip6_sk ( sk ) ; lsa -> l2tp_family = af_inet6 ; lsa -> l2tp_flowinfo = 0 ; lsa -> l2tp_scope_id = 0 ; if ( peer ) { if ( ! lsk -> peer_conn_id ) return - enotconn ; lsa -> l2tp_conn_id = lsk -> peer_conn_id ; lsa -> l2tp_addr = np -> daddr ; if ( np -> sndflow ) lsa -> l2tp_flowinfo = np -> flow_label ; } else { if ( ipv6_addr_any ( & np -> rcv_saddr ) ) lsa -> l2tp_addr = np -> saddr ; else lsa -> l2tp_addr = np -> rcv_saddr ; lsa -> l2tp_conn_id = lsk -> conn_id ; } if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & ipv6_addr_linklocal ) lsa -> l2tp_scope_id = sk -> sk_bound_dev_if ; * uaddr_len = sizeof ( * lsa ) ; return 0 ; }","<S2SV_ModStart> = 0 ; lsa -> l2tp_unused = 0 ;
",torvalds@linux/04d4fbca1017c11381e7d82acea21dd741e748bc,CVE-2012-6543,https://github.com/torvalds/linux/commit/04d4fbca1017c11381e7d82acea21dd741e748bc,2013-03-15T20:55Z,<S2SV_StartBug> if ( peer ) { <S2SV_EndBug>
125,CWE-285,"int xfs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error = 0 ; if ( ! acl ) goto set_acl ; error = - e2big ; if ( acl -> a_count > xfs_acl_max_entries ( xfs_m ( inode -> i_sb ) ) ) return error ; if ( type == acl_type_access ) { umode_t mode = inode -> i_mode ; error = posix_acl_equiv_mode ( acl , & mode ) ; if ( error <= 0 ) { acl = null ; if ( error < 0 ) return error ; } error = xfs_set_mode ( inode , mode ) ; if ( error ) return error ; } set_acl : return __xfs_set_acl ( inode , type , acl ) ; }","<S2SV_ModStart> { umode_t mode <S2SV_ModEnd> ; error = <S2SV_ModStart> ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl <S2SV_ModStart> if ( error <S2SV_ModEnd> ) return error <S2SV_ModStart> return error ; <S2SV_ModEnd> error = xfs_set_mode
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
798,CWE-476,"static int nfc_genl_deactivate_target ( struct sk_buff * skb , struct genl_info * info ) { struct nfc_dev * dev ; u32 device_idx , target_idx ; int rc ; if ( ! info -> attrs [ nfc_attr_device_index ] ) return - einval ; device_idx = nla_get_u32 ( info -> attrs [ nfc_attr_device_index ] ) ; dev = nfc_get_device ( device_idx ) ; if ( ! dev ) return - enodev ; target_idx = nla_get_u32 ( info -> attrs [ nfc_attr_target_index ] ) ; rc = nfc_deactivate_target ( dev , target_idx , nfc_target_mode_sleep ) ; nfc_put_device ( dev ) ; return rc ; }","<S2SV_ModStart> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX
",torvalds@linux/385097a3675749cbc9e97c085c0e5dfe4269ca51,CVE-2019-12984,https://github.com/torvalds/linux/commit/385097a3675749cbc9e97c085c0e5dfe4269ca51,2019-06-26T18:15Z,<S2SV_StartBug> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <S2SV_EndBug>
2951,CWE-399,"syscall_define1 ( inotify_init1 , int , flags ) { struct fsnotify_group * group ; struct user_struct * user ; int ret ; build_bug_on ( in_cloexec != o_cloexec ) ; build_bug_on ( in_nonblock != o_nonblock ) ; if ( flags & ~ ( in_cloexec | in_nonblock ) ) return - einval ; user = get_current_user ( ) ; if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - emfile ; goto out_free_uid ; } group = inotify_new_group ( user , inotify_max_queued_events ) ; if ( is_err ( group ) ) { ret = ptr_err ( group ) ; goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( ""inotify"" , & inotify_fops , group , o_rdonly | flags ) ; if ( ret >= 0 ) return ret ; atomic_dec ( & user -> inotify_devs ) ; out_free_uid : free_uid ( user ) ; return ret ; }","<S2SV_ModStart> return ret ; fsnotify_put_group ( group ) ;
",torvalds@linux/a2ae4cc9a16e211c8a128ba10d22a85431f093ab,CVE-2010-4250,https://github.com/torvalds/linux/commit/a2ae4cc9a16e211c8a128ba10d22a85431f093ab,2012-06-21T23:55Z,<S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug>
2878,CWE-119,"static void oz_usb_handle_ep_data ( struct oz_usb_ctx * usb_ctx , struct oz_usb_hdr * usb_hdr , int len ) { struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ; switch ( data_hdr -> format ) { case oz_data_f_multiple_fixed : { struct oz_multiple_fixed * body = ( struct oz_multiple_fixed * ) data_hdr ; u8 * data = body -> data ; int n ; if ( ! body -> unit_size ) break ; n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) / body -> unit_size ; while ( n -- ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , body -> unit_size ) ; data += body -> unit_size ; } } break ; case oz_data_f_isoc_fixed : { struct oz_isoc_fixed * body = ( struct oz_isoc_fixed * ) data_hdr ; int data_len = len - sizeof ( struct oz_isoc_fixed ) + 1 ; int unit_size = body -> unit_size ; u8 * data = body -> data ; int count ; int i ; if ( ! unit_size ) break ; count = data_len / unit_size ; for ( i = 0 ; i < count ; i ++ ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , unit_size ) ; data += unit_size ; } } break ; } }","<S2SV_ModStart> -> data ; unsigned <S2SV_ModStart> body -> unit_size || len < sizeof ( struct oz_multiple_fixed ) - 1 <S2SV_ModStart> ( len - ( <S2SV_ModStart> struct oz_multiple_fixed ) - 1 ) <S2SV_ModEnd> ) / body
",torvalds@linux/9a59029bc218b48eff8b5d4dde5662fd79d3e1a8,CVE-2015-4002,https://github.com/torvalds/linux/commit/9a59029bc218b48eff8b5d4dde5662fd79d3e1a8,2015-06-07T23:59Z,<S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! body -> unit_size ) <S2SV_EndBug> <S2SV_StartBug> n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug>
2510,CWE-000,"static int ghash_final ( struct shash_desc * desc , u8 * dst ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * buf = dctx -> buffer ; ghash_flush ( ctx , dctx ) ; memcpy ( dst , buf , ghash_block_size ) ; return 0 ; }","<S2SV_ModStart> -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ;
",torvalds@linux/7ed47b7d142ec99ad6880bbbec51e9f12b3af74c,CVE-2011-4081,https://github.com/torvalds/linux/commit/7ed47b7d142ec99ad6880bbbec51e9f12b3af74c,2012-05-24T23:55Z,"<S2SV_StartBug> ghash_flush ( ctx , dctx ) ; <S2SV_EndBug>"
1277,CWE-200,"void __ip_select_ident ( struct iphdr * iph , int segs ) { static u32 ip_idents_hashrnd __read_mostly ; u32 hash , id ; net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , iph -> protocol , ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }","<S2SV_ModStart> ip_idents_hashrnd __read_mostly ; static u32 ip_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> sizeof ( ip_idents_hashrnd ) ) ; net_get_random_once ( & ip_idents_hashrnd_extra , sizeof ( ip_idents_hashrnd_extra <S2SV_ModStart> iph -> protocol ^ ip_idents_hashrnd_extra
",torvalds@linux/55f0fc7a02de8f12757f4937143d8d5091b2e40b,CVE-2019-10638,https://github.com/torvalds/linux/commit/55f0fc7a02de8f12757f4937143d8d5091b2e40b,2019-07-05T23:15Z,"<S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> iph -> protocol , <S2SV_EndBug>"
4583,CWE-787,"char * rfbprocessfiletransferreadbuffer ( rfbclientptr cl , uint32_t length ) { char * buffer = null ; int n = 0 ; filexfer_allowed_or_close_and_return ( """" , cl , null ) ; if ( length > 0 ) { buffer = malloc ( ( uint64_t ) length + 1 ) ; if ( buffer != null ) { if ( ( n = rfbreadexact ( cl , ( char * ) buffer , length ) ) <= 0 ) { if ( n != 0 ) rfblogperror ( ""rfbprocessfiletransferreadbuffer:<s2sv_blank>read"" ) ; rfbcloseclient ( cl ) ; if ( buffer != null ) free ( buffer ) ; return null ; } buffer [ length ] = 0 ; } } return buffer ; }","<S2SV_ModStart> if ( length == SIZE_MAX ) { rfbErr ( ""rfbProcessFileTransferReadBuffer:<S2SV_blank>too<S2SV_blank>big<S2SV_blank>file<S2SV_blank>transfer<S2SV_blank>length<S2SV_blank>requested:<S2SV_blank>%u"" , ( unsigned int ) length ) ; rfbCloseClient ( cl ) ; return NULL ; } if ( length <S2SV_ModStart> malloc ( ( size_t <S2SV_ModEnd> ) length +
",LibVNC@libvncserver/15bb719c03cc70f14c36a843dcb16ed69b405707,CVE-2018-20749,https://github.com/LibVNC/libvncserver/commit/15bb719c03cc70f14c36a843dcb16ed69b405707,2019-01-30T18:29Z,<S2SV_StartBug> if ( length > 0 ) { <S2SV_EndBug> <S2SV_StartBug> buffer = malloc ( ( uint64_t ) length + 1 ) ; <S2SV_EndBug>
7726,CWE-000,"static int _nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state * * res ) { struct nfs4_state_owner * sp ; struct nfs4_state * state = null ; struct nfs_server * server = nfs_server ( dir ) ; struct nfs4_opendata * opendata ; int status ; status = - enomem ; if ( ! ( sp = nfs4_get_state_owner ( server , cred ) ) ) { dprintk ( ""nfs4_do_open:<s2sv_blank>nfs4_get_state_owner<s2sv_blank>failed!\\n"" ) ; goto out_err ; } status = nfs4_recover_expired_lease ( server ) ; if ( status != 0 ) goto err_put_state_owner ; if ( path -> dentry -> d_inode != null ) nfs4_return_incompatible_delegation ( path -> dentry -> d_inode , flags & ( fmode_read | fmode_write ) ) ; status = - enomem ; opendata = nfs4_opendata_alloc ( path , sp , flags , sattr ) ; if ( opendata == null ) goto err_put_state_owner ; if ( path -> dentry -> d_inode != null ) opendata -> state = nfs4_get_open_state ( path -> dentry -> d_inode , sp ) ; status = _nfs4_proc_open ( opendata ) ; if ( status != 0 ) goto err_opendata_put ; if ( opendata -> o_arg . open_flags & o_excl ) nfs4_exclusive_attrset ( opendata , sattr ) ; state = nfs4_opendata_to_nfs4_state ( opendata ) ; status = ptr_err ( state ) ; if ( is_err ( state ) ) goto err_opendata_put ; nfs4_opendata_put ( opendata ) ; nfs4_put_state_owner ( sp ) ; * res = state ; return 0 ; err_opendata_put : nfs4_opendata_put ( opendata ) ; err_put_state_owner : nfs4_put_state_owner ( sp ) ; out_err : * res = null ; return status ; }","<S2SV_ModStart> * path , fmode_t fmode , <S2SV_ModStart> -> d_inode , fmode <S2SV_ModEnd> ) ; status <S2SV_ModStart> path , sp , fmode
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static int _nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state * * res ) <S2SV_EndBug> <S2SV_StartBug> nfs4_return_incompatible_delegation ( path -> dentry -> d_inode , flags & ( FMODE_READ | FMODE_WRITE ) ) ; <S2SV_EndBug> <S2SV_StartBug> opendata = nfs4_opendata_alloc ( path , sp , flags , sattr ) ; <S2SV_EndBug>"
6533,CWE-119,void cjson_delete ( cjson * c ) { cjson * next ; while ( c ) { next = c -> next ; if ( ! ( c -> type & cjson_isreference ) && c -> child ) cjson_delete ( c -> child ) ; if ( ! ( c -> type & cjson_isreference ) && c -> valuestring ) cjson_free ( c -> valuestring ) ; if ( c -> string ) cjson_free ( c -> string ) ; cjson_free ( c ) ; c = next ; } },"<S2SV_ModStart> ; if ( ! ( c -> type & cJSON_StringIsConst ) &&
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,<S2SV_StartBug> if ( c -> string ) <S2SV_EndBug>
7162,CWE-401,"static ssize_t rpmsg_eptdev_write_iter ( struct kiocb * iocb , struct iov_iter * from ) { struct file * filp = iocb -> ki_filp ; struct rpmsg_eptdev * eptdev = filp -> private_data ; size_t len = iov_iter_count ( from ) ; void * kbuf ; int ret ; kbuf = kzalloc ( len , gfp_kernel ) ; if ( ! kbuf ) return - enomem ; if ( ! copy_from_iter_full ( kbuf , len , from ) ) return - efault ; if ( mutex_lock_interruptible ( & eptdev -> ept_lock ) ) { ret = - erestartsys ; goto free_kbuf ; } if ( ! eptdev -> ept ) { ret = - epipe ; goto unlock_eptdev ; } if ( filp -> f_flags & o_nonblock ) ret = rpmsg_trysend ( eptdev -> ept , kbuf , len ) ; else ret = rpmsg_send ( eptdev -> ept , kbuf , len ) ; unlock_eptdev : mutex_unlock ( & eptdev -> ept_lock ) ; free_kbuf : kfree ( kbuf ) ; return ret < 0 ? ret : len ; }","<S2SV_ModStart> from ) ) { ret = <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; goto free_kbuf ; }
",torvalds@linux/bbe692e349e2a1edf3fe0a29a0e05899c9c94d51,CVE-2019-19053,https://github.com/torvalds/linux/commit/bbe692e349e2a1edf3fe0a29a0e05899c9c94d51,2019-11-18T06:15Z,<S2SV_StartBug> return - EFAULT ; <S2SV_EndBug>
7838,CWE-20,"error_t rawsocketsendippacket ( socket * socket , const socketmsg * message , uint_t flags ) { error_t error ; size_t offset ; netbuffer * buffer ; netinterface * interface ; ippseudoheader pseudoheader ; nettxancillary ancillary ; interface = socket -> interface ; buffer = ipallocbuffer ( 0 , & offset ) ; if ( buffer == null ) return error_out_of_memory ; do { error = netbufferappend ( buffer , message -> data , message -> length ) ; if ( error ) break ; # if ( ipv4_support == enabled ) if ( message -> destipaddr . length == sizeof ( ipv4addr ) ) { ipv4addr srcipaddr ; error = ipv4selectsourceaddr ( & interface , message -> destipaddr . ipv4addr , & srcipaddr ) ; if ( error ) break ; pseudoheader . length = sizeof ( ipv4pseudoheader ) ; pseudoheader . ipv4data . srcaddr = srcipaddr ; pseudoheader . ipv4data . destaddr = message -> destipaddr . ipv4addr ; pseudoheader . ipv4data . reserved = 0 ; pseudoheader . ipv4data . protocol = socket -> protocol ; pseudoheader . ipv4data . length = htons ( message -> length ) ; } else # endif # if ( ipv6_support == enabled ) if ( message -> destipaddr . length == sizeof ( ipv6addr ) ) { error = ipv6selectsourceaddr ( & interface , & message -> destipaddr . ipv6addr , & pseudoheader . ipv6data . srcaddr ) ; if ( error ) break ; pseudoheader . length = sizeof ( ipv6pseudoheader ) ; pseudoheader . ipv6data . destaddr = message -> destipaddr . ipv6addr ; pseudoheader . ipv6data . length = htonl ( message -> length ) ; pseudoheader . ipv6data . reserved [ 0 ] = 0 ; pseudoheader . ipv6data . reserved [ 1 ] = 0 ; pseudoheader . ipv6data . reserved [ 2 ] = 0 ; pseudoheader . ipv6data . nextheader = socket -> protocol ; } else # endif { error = error_failure ; break ; } ancillary = net_default_tx_ancillary ; if ( message -> ttl != 0 ) { ancillary . ttl = message -> ttl ; } else if ( ipismulticastaddr ( & message -> destipaddr ) ) { ancillary . ttl = socket -> multicastttl ; } else { ancillary . ttl = socket -> ttl ; } if ( flags & socket_flag_dont_route ) { ancillary . dontroute = true ; } # if ( ip_diff_serv_support == enabled ) ancillary . dscp = socket -> dscp ; # endif # if ( eth_support == enabled ) ancillary . srcmacaddr = message -> srcmacaddr ; ancillary . destmacaddr = message -> destmacaddr ; # endif # if ( eth_vlan_support == enabled ) ancillary . vlanpcp = socket -> vlanpcp ; ancillary . vlandei = socket -> vlandei ; # endif # if ( eth_vman_support == enabled ) ancillary . vmanpcp = socket -> vmanpcp ; ancillary . vmandei = socket -> vmandei ; # endif # if ( eth_port_tagging_support == enabled ) ancillary . port = message -> switchport ; # endif # if ( eth_timestamp_support == enabled ) ancillary . timestampid = message -> timestampid ; # endif error = ipsenddatagram ( interface , & pseudoheader , buffer , offset , & ancillary ) ; if ( error ) break ; } while ( 0 ) ; netbufferfree ( buffer ) ; return error ; }","<S2SV_ModStart> NetTxAncillary ancillary ; if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModEnd> buffer = ipAllocBuffer
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> interface = socket -> interface ; <S2SV_EndBug>
1255,CWE-119,"static inline bool unconditional ( const struct ip6t_ip6 * ipv6 ) { static const struct ip6t_ip6 uncond ; return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ; }","<S2SV_ModStart> ( const struct ip6t_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e -> <S2SV_ModEnd> ipv6 , &
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z,"<S2SV_StartBug> static inline bool unconditional ( const struct ip6t_ip6 * ipv6 ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug>"
4532,CWE-125,"pyobject * ast2obj_stmt ( void * _o ) { stmt_ty o = ( stmt_ty ) _o ; pyobject * result = null , * value = null ; if ( ! o ) { py_incref ( py_none ) ; return py_none ; } switch ( o -> kind ) { case functiondef_kind : result = pytype_genericnew ( functiondef_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . functiondef . name ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_name , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_arguments ( o -> v . functiondef . args ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_args , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . functiondef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . functiondef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_decorator_list , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> v . functiondef . returns ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_returns , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_string ( o -> v . functiondef . type_comment ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_type_comment , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case asyncfunctiondef_kind : result = pytype_genericnew ( asyncfunctiondef_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . asyncfunctiondef . name ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_name , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_arguments ( o -> v . asyncfunctiondef . args ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_args , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . asyncfunctiondef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . asyncfunctiondef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_decorator_list , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> v . asyncfunctiondef . returns ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_returns , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_string ( o -> v . asyncfunctiondef . type_comment ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_type_comment , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case classdef_kind : result = pytype_genericnew ( classdef_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . classdef . name ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_name , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . classdef . bases , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_bases , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . classdef . keywords , ast2obj_keyword ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_keywords , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . classdef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . classdef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_decorator_list , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case return_kind : result = pytype_genericnew ( return_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . return . value ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_value , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case delete_kind : result = pytype_genericnew ( delete_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . delete . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_targets , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case assign_kind : result = pytype_genericnew ( assign_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . assign . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_targets , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> v . assign . value ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_value , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_string ( o -> v . assign . type_comment ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_type_comment , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case augassign_kind : result = pytype_genericnew ( augassign_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . augassign . target ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_target , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_operator ( o -> v . augassign . op ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_op , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> v . augassign . value ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_value , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case annassign_kind : result = pytype_genericnew ( annassign_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . annassign . target ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_target , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> v . annassign . annotation ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_annotation , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> v . annassign . value ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_value , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_int ( o -> v . annassign . simple ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_simple , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case for_kind : result = pytype_genericnew ( for_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . for . target ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_target , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> v . for . iter ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_iter , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . for . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . for . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_orelse , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_string ( o -> v . for . type_comment ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_type_comment , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case asyncfor_kind : result = pytype_genericnew ( asyncfor_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . asyncfor . target ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_target , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> v . asyncfor . iter ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_iter , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . asyncfor . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . asyncfor . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_orelse , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_string ( o -> v . asyncfor . type_comment ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_type_comment , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case while_kind : result = pytype_genericnew ( while_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . while . test ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_test , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . while . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . while . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_orelse , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case if_kind : result = pytype_genericnew ( if_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . if . test ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_test , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . if . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . if . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_orelse , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case with_kind : result = pytype_genericnew ( with_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . with . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_items , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . with . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_string ( o -> v . with . type_comment ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_type_comment , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case asyncwith_kind : result = pytype_genericnew ( asyncwith_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . asyncwith . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_items , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . asyncwith . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_string ( o -> v . asyncwith . type_comment ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_type_comment , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case raise_kind : result = pytype_genericnew ( raise_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . raise . exc ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_exc , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> v . raise . cause ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_cause , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case try_kind : result = pytype_genericnew ( try_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . try . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . try . handlers , ast2obj_excepthandler ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_handlers , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . try . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_orelse , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . try . finalbody , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_finalbody , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case assert_kind : result = pytype_genericnew ( assert_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . assert . test ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_test , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> v . assert . msg ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_msg , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case import_kind : result = pytype_genericnew ( import_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . import . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_names , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case importfrom_kind : result = pytype_genericnew ( importfrom_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . importfrom . module ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_module , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . importfrom . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_names , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_int ( o -> v . importfrom . level ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_level , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case global_kind : result = pytype_genericnew ( global_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . global . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_names , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case nonlocal_kind : result = pytype_genericnew ( nonlocal_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . nonlocal . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_names , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case expr_kind : result = pytype_genericnew ( expr_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . expr . value ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_value , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case pass_kind : result = pytype_genericnew ( pass_type , null , null ) ; if ( ! result ) goto failed ; break ; case break_kind : result = pytype_genericnew ( break_type , null , null ) ; if ( ! result ) goto failed ; break ; case continue_kind : result = pytype_genericnew ( continue_type , null , null ) ; if ( ! result ) goto failed ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_lineno , value ) < 0 ) goto failed ; py_decref ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_col_offset , value ) < 0 ) goto failed ; py_decref ( value ) ; return result ; failed : py_xdecref ( value ) ; py_xdecref ( result ) ; return null ; }","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug>
511,CWE-20,"static int net_ctl_permissions ( struct ctl_table_header * head , struct ctl_table * table ) { struct net * net = container_of ( head -> set , struct net , sysctls ) ; kuid_t root_uid = make_kuid ( net -> user_ns , 0 ) ; kgid_t root_gid = make_kgid ( net -> user_ns , 0 ) ; if ( ns_capable ( net -> user_ns , cap_net_admin ) || uid_eq ( root_uid , current_uid ( ) ) ) { int mode = ( table -> mode >> 6 ) & 7 ; return ( mode << 6 ) | ( mode << 3 ) | mode ; } if ( gid_eq ( root_gid , current_gid ( ) ) ) { int mode = ( table -> mode >> 3 ) & 7 ; return ( mode << 3 ) | mode ; } return table -> mode ; }","<S2SV_ModStart> ( root_uid , current_euid <S2SV_ModEnd> ( ) ) <S2SV_ModStart> } if ( in_egroup_p ( root_gid <S2SV_ModEnd> ) ) {
",torvalds@linux/2433c8f094a008895e66f25bd1773cdb01c91d01,CVE-2013-4270,https://github.com/torvalds/linux/commit/2433c8f094a008895e66f25bd1773cdb01c91d01,2013-12-09T18:55Z,"<S2SV_StartBug> uid_eq ( root_uid , current_uid ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( gid_eq ( root_gid , current_gid ( ) ) ) { <S2SV_EndBug>"
7988,CWE-120,"secureelementstatus_t secureelementprocessjoinaccept ( joinreqidentifier_t joinreqtype , uint8_t * joineui , uint16_t devnonce , uint8_t * encjoinaccept , uint8_t encjoinacceptsize , uint8_t * decjoinaccept , uint8_t * versionminor ) { if ( ( encjoinaccept == null ) || ( decjoinaccept == null ) || ( versionminor == null ) ) { return secure_element_error_npe ; } keyidentifier_t enckeyid = nwk_key ; if ( joinreqtype != join_req ) { enckeyid = j_s_enc_key ; } memcpy1 ( decjoinaccept , encjoinaccept , encjoinacceptsize ) ; if ( secureelementaesencrypt ( encjoinaccept + loramac_mhdr_field_size , encjoinacceptsize - loramac_mhdr_field_size , enckeyid , decjoinaccept + loramac_mhdr_field_size ) != secure_element_success ) { return secure_element_fail_encrypt ; } * versionminor = ( ( decjoinaccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; uint32_t mic = 0 ; mic = ( ( uint32_t ) decjoinaccept [ encjoinacceptsize - loramac_mic_field_size ] << 0 ) ; mic |= ( ( uint32_t ) decjoinaccept [ encjoinacceptsize - loramac_mic_field_size + 1 ] << 8 ) ; mic |= ( ( uint32_t ) decjoinaccept [ encjoinacceptsize - loramac_mic_field_size + 2 ] << 16 ) ; mic |= ( ( uint32_t ) decjoinaccept [ encjoinacceptsize - loramac_mic_field_size + 3 ] << 24 ) ; if ( * versionminor == 0 ) { if ( secureelementverifyaescmac ( decjoinaccept , ( encjoinacceptsize - loramac_mic_field_size ) , mic , nwk_key ) != secure_element_success ) { return secure_element_fail_cmac ; } } # if ( use_lrwan_1_1_x_crypto == 1 ) else if ( * versionminor == 1 ) { uint8_t micheader11 [ join_accept_mic_computation_offset ] = { 0 } ; uint16_t bufitr = 0 ; micheader11 [ bufitr ++ ] = ( uint8_t ) joinreqtype ; memcpyr ( micheader11 + bufitr , joineui , loramac_join_eui_field_size ) ; bufitr += loramac_join_eui_field_size ; micheader11 [ bufitr ++ ] = devnonce & 0xff ; micheader11 [ bufitr ++ ] = ( devnonce >> 8 ) & 0xff ; uint8_t localbuffer [ loramac_join_accept_frame_max_size + join_accept_mic_computation_offset ] = { 0 } ; memcpy1 ( localbuffer , micheader11 , join_accept_mic_computation_offset ) ; memcpy1 ( localbuffer + join_accept_mic_computation_offset - 1 , decjoinaccept , encjoinacceptsize ) ; if ( secureelementverifyaescmac ( localbuffer , encjoinacceptsize + join_accept_mic_computation_offset - loramac_mhdr_field_size - loramac_mic_field_size , mic , j_s_int_key ) != secure_element_success ) { return secure_element_fail_cmac ; } } # endif else { return secure_element_error_invalid_lorawam_spec_version ; } return secure_element_success ; }","<S2SV_ModStart> { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE
",Lora-net@LoRaMac-node/e3063a91daa7ad8a687223efa63079f0c24568e4,CVE-2020-11068,https://github.com/Lora-net/LoRaMac-node/commit/e3063a91daa7ad8a687223efa63079f0c24568e4,2020-06-23T17:15Z,<S2SV_StartBug> return SECURE_ELEMENT_ERROR_NPE ; <S2SV_EndBug>
7759,CWE-125,"static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { pyobject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = null ; int i = start ; int j = 0 ; if ( kwonlyargs == null ) { ast_error ( c , child ( n , start ) , ""named<s2sv_blank>arguments<s2sv_blank>must<s2sv_blank>follow<s2sv_blank>bare<s2sv_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != null ) ; while ( i < nch ( n ) ) { ch = child ( n , i ) ; switch ( type ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < nch ( n ) && type ( child ( n , i + 1 ) ) == equal ) { expression = ast_for_expr ( c , child ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_set ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_set ( kwdefaults , j , null ) ; } if ( nch ( ch ) == 3 ) { annotation = ast_for_expr ( c , child ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = null ; } ch = child ( ch , 0 ) ; argname = new_identifier ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , null , lineno ( ch ) , ch -> n_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_set ( kwonlyargs , j ++ , arg ) ; i += 1 ; if ( type ( child ( n , i ) ) == comma ) i += 1 ; break ; case type_comment : arg -> type_comment = new_type_comment ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case doublestar : return i ; default : ast_error ( c , ch , ""unexpected<s2sv_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/dc317ac9cff859aa84eeabe03fb5004982545b3b,CVE-2019-19275,https://github.com/python/typed_ast/commit/dc317ac9cff859aa84eeabe03fb5004982545b3b,2019-11-26T15:15Z,"<S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug>"
2225,CWE-189,"static int efx_probe_all ( struct efx_nic * efx ) { int rc ; rc = efx_probe_nic ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<s2sv_blank>to<s2sv_blank>create<s2sv_blank>nic\\n"" ) ; goto fail1 ; } rc = efx_probe_port ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<s2sv_blank>to<s2sv_blank>create<s2sv_blank>port\\n"" ) ; goto fail2 ; } efx -> rxq_entries = efx -> txq_entries = efx_default_dmaq_size ; rc = efx_probe_channels ( efx ) ; if ( rc ) goto fail3 ; rc = efx_probe_filters ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<s2sv_blank>to<s2sv_blank>create<s2sv_blank>filter<s2sv_blank>tables\\n"" ) ; goto fail4 ; } return 0 ; fail4 : efx_remove_channels ( efx ) ; fail3 : efx_remove_port ( efx ) ; fail2 : efx_remove_nic ( efx ) ; fail1 : return rc ; }","<S2SV_ModStart> fail2 ; } BUILD_BUG_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT ) ; if ( WARN_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT ( efx ) ) ) { rc = - EINVAL ; goto fail3 ; }
",torvalds@linux/68cb695ccecf949d48949e72f8ce591fdaaa325c,CVE-2012-3412,https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c,2012-10-03T11:02Z,<S2SV_StartBug> efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ; <S2SV_EndBug>
2087,CWE-119,"static ssize_t cifs_iovec_write ( struct file * file , const struct iovec * iov , unsigned long nr_segs , loff_t * poffset ) { unsigned long nr_pages , i ; size_t copied , len , cur_len ; ssize_t total_written = 0 ; loff_t offset ; struct iov_iter it ; struct cifsfileinfo * open_file ; struct cifs_tcon * tcon ; struct cifs_sb_info * cifs_sb ; struct cifs_writedata * wdata , * tmp ; struct list_head wdata_list ; int rc ; pid_t pid ; len = iov_length ( iov , nr_segs ) ; if ( ! len ) return 0 ; rc = generic_write_checks ( file , poffset , & len , 0 ) ; if ( rc ) return rc ; init_list_head ( & wdata_list ) ; cifs_sb = cifs_sb ( file -> f_path . dentry -> d_sb ) ; open_file = file -> private_data ; tcon = tlink_tcon ( open_file -> tlink ) ; if ( ! tcon -> ses -> server -> ops -> async_writev ) return - enosys ; offset = * poffset ; if ( cifs_sb -> mnt_cifs_flags & cifs_mount_rwpidforward ) pid = open_file -> pid ; else pid = current -> tgid ; iov_iter_init ( & it , iov , nr_segs , len , 0 ) ; do { size_t save_len ; nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len ) ; wdata = cifs_writedata_alloc ( nr_pages , cifs_uncached_writev_complete ) ; if ( ! wdata ) { rc = - enomem ; break ; } rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages ) ; if ( rc ) { kfree ( wdata ) ; break ; } save_len = cur_len ; for ( i = 0 ; i < nr_pages ; i ++ ) { copied = min_t ( const size_t , cur_len , page_size ) ; copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , 0 , copied ) ; cur_len -= copied ; iov_iter_advance ( & it , copied ) ; } cur_len = save_len - cur_len ; wdata -> sync_mode = wb_sync_all ; wdata -> nr_pages = nr_pages ; wdata -> offset = ( __u64 ) offset ; wdata -> cfile = cifsfileinfo_get ( open_file ) ; wdata -> pid = pid ; wdata -> bytes = cur_len ; wdata -> pagesz = page_size ; wdata -> tailsz = cur_len - ( ( nr_pages - 1 ) * page_size ) ; rc = cifs_uncached_retry_writev ( wdata ) ; if ( rc ) { kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; break ; } list_add_tail ( & wdata -> list , & wdata_list ) ; offset += cur_len ; len -= cur_len ; } while ( len > 0 ) ; if ( ! list_empty ( & wdata_list ) ) rc = 0 ; restart_loop : list_for_each_entry_safe ( wdata , tmp , & wdata_list , list ) { if ( ! rc ) { rc = wait_for_completion_killable ( & wdata -> done ) ; if ( rc ) rc = - eintr ; else if ( wdata -> result ) rc = wdata -> result ; else total_written += wdata -> bytes ; if ( rc == - eagain ) { rc = cifs_uncached_retry_writev ( wdata ) ; goto restart_loop ; } } list_del_init ( & wdata -> list ) ; kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; } if ( total_written > 0 ) * poffset += total_written ; cifs_stats_bytes_written ( tcon , total_written ) ; return total_written ? total_written : ( ssize_t ) rc ; }","<S2SV_ModStart> i ; size_t bytes , <S2SV_ModStart> ++ ) { bytes <S2SV_ModEnd> = min_t ( <S2SV_ModStart> , 0 , bytes <S2SV_ModEnd> ) ; cur_len <S2SV_ModStart> copied ) ; if ( copied < bytes ) break ; <S2SV_ModStart> save_len - cur_len ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] )
",torvalds@linux/5d81de8e8667da7135d3a32a964087c0faf5483f,CVE-2014-0069,https://github.com/torvalds/linux/commit/5d81de8e8667da7135d3a32a964087c0faf5483f,2014-02-28T06:18Z,"<S2SV_StartBug> size_t copied , len , cur_len ; <S2SV_EndBug> <S2SV_StartBug> copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> 0 , copied ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cur_len = save_len - cur_len ; <S2SV_EndBug>"
981,CWE-416,"static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; declare_sockaddr ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct raw6_sock * rp = raw6_sk ( sk ) ; struct ipv6_txoptions * opt = null ; struct ip6_flowlabel * flowlabel = null ; struct dst_entry * dst = null ; struct raw6_frag_vec rfv ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; u16 proto ; int err ; if ( len > int_max ) return - emsgsize ; if ( msg -> msg_flags & msg_oob ) return - eopnotsupp ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( sin6 ) { if ( addr_len < sin6_len_rfc2133 ) return - einval ; if ( sin6 -> sin6_family && sin6 -> sin6_family != af_inet6 ) return - eafnosupport ; proto = ntohs ( sin6 -> sin6_port ) ; if ( ! proto ) proto = inet -> inet_num ; else if ( proto != inet -> inet_num ) return - einval ; if ( proto > 255 ) return - einval ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & ipv6_flowinfo_mask ; if ( fl6 . flowlabel & ipv6_flowlabel_mask ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - einval ; } } if ( sk -> sk_state == tcp_established && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } else { if ( sk -> sk_state != tcp_established ) return - edestaddrreq ; proto = inet -> inet_num ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & ipv6_flowlabel_mask ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - einval ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = null ; } if ( ! opt ) opt = np -> opt ; if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = proto ; rfv . msg = msg ; rfv . hlen = 0 ; err = rawv6_probe_proto_opt ( & rfv , & fl6 ) ; if ( err ) goto out ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; if ( inet -> hdrincl ) fl6 . flowi6_flags |= flowi_flag_known_nh ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( is_err ( dst ) ) { err = ptr_err ( dst ) ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; if ( msg -> msg_flags & msg_confirm ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = rawv6_send_hdrinc ( sk , msg , len , & fl6 , & dst , msg -> msg_flags ) ; else { lock_sock ( sk ) ; err = ip6_append_data ( sk , raw6_getfrag , & rfv , len , 0 , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; if ( err ) ip6_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & msg_more ) ) err = rawv6_push_pending_frames ( sk , & fl6 , rp ) ; release_sock ( sk ) ; } done : dst_release ( dst ) ; out : fl6_sock_release ( flowlabel ) ; return err < 0 ? err : len ; do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & msg_probe ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }","<S2SV_ModStart> len ) { struct ipv6_txoptions * opt_to_free = NULL ; <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> flowlabel ) ; txopt_put ( opt_to_free ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> opt = np -> opt ; <S2SV_EndBug> <S2SV_StartBug> return err < 0 ? err : len ; <S2SV_EndBug>
496,CWE-264,"void setattr_copy ( struct inode * inode , const struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & attr_uid ) inode -> i_uid = attr -> ia_uid ; if ( ia_valid & attr_gid ) inode -> i_gid = attr -> ia_gid ; if ( ia_valid & attr_atime ) inode -> i_atime = timespec_trunc ( attr -> ia_atime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & attr_mtime ) inode -> i_mtime = timespec_trunc ( attr -> ia_mtime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & attr_ctime ) inode -> i_ctime = timespec_trunc ( attr -> ia_ctime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & attr_mode ) { umode_t mode = attr -> ia_mode ; if ( ! in_group_p ( inode -> i_gid ) && ! inode_capable ( inode , cap_fsetid ) ) mode &= ~ s_isgid ; inode -> i_mode = mode ; } }","<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
",torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03,CVE-2014-4014,https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03,2014-06-23T11:21Z,"<S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug>"
5170,CWE-476,rfbclientptr rfbclientiteratornext ( rfbclientiteratorptr i ) { if ( i -> next == 0 ) { lock ( rfbclientlistmutex ) ; i -> next = i -> screen -> clienthead ; unlock ( rfbclientlistmutex ) ; } else { rfbclientptr cl = i -> next ; i -> next = i -> next -> next ; rfbdecrclientref ( cl ) ; } # if defined ( libvncserver_have_libpthread ) || defined ( libvncserver_have_win32threads ) if ( ! i -> closedtoo ) while ( i -> next && i -> next -> sock < 0 ) i -> next = i -> next -> next ; if ( i -> next ) rfbincrclientref ( i -> next ) ; # endif return i -> next ; },"<S2SV_ModStart> i ) { if ( ! i ) return NULL ;
",LibVNC@libvncserver/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0,CVE-2020-14397,https://github.com/LibVNC/libvncserver/commit/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0,2020-06-17T16:15Z,<S2SV_StartBug> { <S2SV_EndBug>
8114,CWE-295,"int context_init ( service_options * section ) { # if openssl_version_number >= 0x10100000l if ( section -> option . client ) section -> ctx = ssl_ctx_new ( tls_client_method ( ) ) ; else section -> ctx = ssl_ctx_new ( tls_server_method ( ) ) ; if ( ! ssl_ctx_set_min_proto_version ( section -> ctx , section -> min_proto_version ) ) { s_log ( log_err , ""failed<s2sv_blank>to<s2sv_blank>set<s2sv_blank>the<s2sv_blank>minimum<s2sv_blank>protocol<s2sv_blank>version<s2sv_blank>0x%x"" , section -> min_proto_version ) ; return 1 ; } if ( ! ssl_ctx_set_max_proto_version ( section -> ctx , section -> max_proto_version ) ) { s_log ( log_err , ""failed<s2sv_blank>to<s2sv_blank>set<s2sv_blank>the<s2sv_blank>maximum<s2sv_blank>protocol<s2sv_blank>version<s2sv_blank>0x%x"" , section -> max_proto_version ) ; return 1 ; } # else if ( section -> option . client ) section -> ctx = ssl_ctx_new ( section -> client_method ) ; else section -> ctx = ssl_ctx_new ( section -> server_method ) ; # endif if ( ! section -> ctx ) { sslerror ( ""ssl_ctx_new"" ) ; return 1 ; } if ( ! ssl_ctx_set_ex_data ( section -> ctx , index_ssl_ctx_opt , section ) ) { sslerror ( ""ssl_ctx_set_ex_data"" ) ; return 1 ; } current_section = section ; if ( section -> cipher_list ) { s_log ( log_debug , ""ciphers:<s2sv_blank>%s"" , section -> cipher_list ) ; if ( ! ssl_ctx_set_cipher_list ( section -> ctx , section -> cipher_list ) ) { sslerror ( ""ssl_ctx_set_cipher_list"" ) ; return 1 ; } } # ifndef openssl_no_tls1_3 if ( section -> ciphersuites ) { s_log ( log_debug , ""tlsv1.3<s2sv_blank>ciphersuites:<s2sv_blank>%s"" , section -> ciphersuites ) ; if ( ! ssl_ctx_set_ciphersuites ( section -> ctx , section -> ciphersuites ) ) { sslerror ( ""ssl_ctx_set_ciphersuites"" ) ; return 1 ; } } # endif ssl_ctx_set_options ( section -> ctx , ssl_op_no_sslv2 | ssl_op_no_sslv3 ) ; # ifdef ssl_op_no_compression ssl_ctx_clear_options ( section -> ctx , ssl_op_no_compression ) ; # endif ssl_ctx_set_options ( section -> ctx , ( ssl_options_type ) ( section -> ssl_options_set ) ) ; # if openssl_version_number >= 0x009080dfl ssl_ctx_clear_options ( section -> ctx , ( ssl_options_type ) ( section -> ssl_options_clear ) ) ; # endif # if openssl_version_number >= 0x009080dfl s_log ( log_debug , ""tls<s2sv_blank>options:<s2sv_blank>0x%08lx<s2sv_blank>(+0x%08lx,<s2sv_blank>-0x%08lx)"" , ssl_ctx_get_options ( section -> ctx ) , section -> ssl_options_set , section -> ssl_options_clear ) ; # else s_log ( log_debug , ""tls<s2sv_blank>options:<s2sv_blank>0x%08lx<s2sv_blank>(+0x%08lx)"" , ssl_ctx_get_options ( section -> ctx ) , section -> ssl_options_set ) ; # endif if ( conf_init ( section ) ) return 1 ; # ifdef ssl_mode_release_buffers ssl_ctx_set_mode ( section -> ctx , ssl_mode_enable_partial_write | ssl_mode_accept_moving_write_buffer | ssl_mode_release_buffers ) ; # else ssl_ctx_set_mode ( section -> ctx , ssl_mode_enable_partial_write | ssl_mode_accept_moving_write_buffer ) ; # endif # if openssl_version_number >= 0x10101000l ssl_ctx_set_session_ticket_cb ( section -> ctx , generate_session_ticket_cb , decrypt_session_ticket_cb , null ) ; # endif # if openssl_version_number >= 0x10000000l if ( ( section -> ticket_key ) && ( section -> ticket_mac ) ) ssl_ctx_set_tlsext_ticket_key_cb ( section -> ctx , ssl_tlsext_ticket_key_cb ) ; # endif if ( ! section -> option . client ) { unsigned servname_len = ( unsigned ) strlen ( section -> servname ) ; if ( servname_len > ssl_max_ssl_session_id_length ) servname_len = ssl_max_ssl_session_id_length ; if ( ! ssl_ctx_set_session_id_context ( section -> ctx , ( unsigned char * ) section -> servname , servname_len ) ) { sslerror ( ""ssl_ctx_set_session_id_context"" ) ; return 1 ; } } ssl_ctx_set_session_cache_mode ( section -> ctx , ssl_sess_cache_both | ssl_sess_cache_no_internal_store ) ; ssl_ctx_sess_set_cache_size ( section -> ctx , section -> session_size ) ; ssl_ctx_set_timeout ( section -> ctx , section -> session_timeout ) ; ssl_ctx_sess_set_new_cb ( section -> ctx , sess_new_cb ) ; ssl_ctx_sess_set_get_cb ( section -> ctx , sess_get_cb ) ; ssl_ctx_sess_set_remove_cb ( section -> ctx , sess_remove_cb ) ; ssl_ctx_set_info_callback ( section -> ctx , info_callback ) ; if ( auth_init ( section ) ) return 1 ; if ( verify_init ( section ) ) return 1 ; if ( ! section -> option . client ) { # ifndef openssl_no_tlsext ssl_ctx_set_tlsext_servername_callback ( section -> ctx , servername_cb ) ; # endif # ifndef openssl_no_dh dh_init ( section ) ; # endif # ifndef openssl_no_ecdh ecdh_init ( section ) ; # endif } return 0 ; }","<S2SV_ModStart> = section ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> security_level >= 0 ) { SSL_CTX_set_security_level ( section -> ctx , section -> security_level ) ; s_log ( LOG_INFO , ""User-specified<S2SV_blank>security<S2SV_blank>level<S2SV_blank>set:<S2SV_blank>%d"" , section -> security_level ) ; } else if ( SSL_CTX_get_security_level ( section -> ctx ) < DEFAULT_SECURITY_LEVEL ) { SSL_CTX_set_security_level ( section -> ctx , DEFAULT_SECURITY_LEVEL ) ; s_log ( LOG_INFO , ""stunnel<S2SV_blank>default<S2SV_blank>security<S2SV_blank>level<S2SV_blank>set:<S2SV_blank>%d"" , DEFAULT_SECURITY_LEVEL ) ; } else { s_log ( LOG_INFO , ""OpenSSL<S2SV_blank>security<S2SV_blank>level<S2SV_blank>is<S2SV_blank>used:<S2SV_blank>%d"" , SSL_CTX_get_security_level ( section -> ctx ) ) ; } # endif <S2SV_ModStart> return 1 ; # ifndef OPENSSL_NO_TLSEXT <S2SV_ModStart> . client ) <S2SV_ModEnd> SSL_CTX_set_tlsext_servername_callback ( section <S2SV_ModStart> ; # endif <S2SV_ModEnd> return 0 ;
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,<S2SV_StartBug> if ( section -> cipher_list ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! section -> option . client ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
3056,CWE-476,"int kvm_vm_ioctl_check_extension ( struct kvm * kvm , long ext ) { int r ; int hv_enabled = kvmppc_hv_ops ? 1 : 0 ; if ( kvm ) { hv_enabled = is_kvmppc_hv_enabled ( kvm ) ; } switch ( ext ) { # ifdef config_booke case kvm_cap_ppc_booke_sregs : case kvm_cap_ppc_booke_watchdog : case kvm_cap_ppc_epr : # else case kvm_cap_ppc_segstate : case kvm_cap_ppc_hior : case kvm_cap_ppc_papr : # endif case kvm_cap_ppc_unset_irq : case kvm_cap_ppc_irq_level : case kvm_cap_enable_cap : case kvm_cap_enable_cap_vm : case kvm_cap_one_reg : case kvm_cap_ioeventfd : case kvm_cap_device_ctrl : case kvm_cap_immediate_exit : r = 1 ; break ; case kvm_cap_ppc_paired_singles : case kvm_cap_ppc_osi : case kvm_cap_ppc_get_pvinfo : # if defined ( config_kvm_e500v2 ) || defined ( config_kvm_e500mc ) case kvm_cap_sw_tlb : # endif r = ! hv_enabled ; break ; # ifdef config_kvm_mpic case kvm_cap_irq_mpic : r = 1 ; break ; # endif # ifdef config_ppc_book3s_64 case kvm_cap_spapr_tce : case kvm_cap_spapr_tce_64 : case kvm_cap_spapr_tce_vfio : case kvm_cap_ppc_rtas : case kvm_cap_ppc_fixup_hcall : case kvm_cap_ppc_enable_hcall : # ifdef config_kvm_xics case kvm_cap_irq_xics : # endif r = 1 ; break ; case kvm_cap_ppc_alloc_htab : r = hv_enabled ; break ; # endif # ifdef config_kvm_book3s_hv_possible case kvm_cap_ppc_smt : r = 0 ; if ( kvm ) { if ( kvm -> arch . emul_smt_mode > 1 ) r = kvm -> arch . emul_smt_mode ; else r = kvm -> arch . smt_mode ; } else if ( hv_enabled ) { if ( cpu_has_feature ( cpu_ftr_arch_300 ) ) r = 1 ; else r = threads_per_subcore ; } break ; case kvm_cap_ppc_smt_possible : r = 1 ; if ( hv_enabled ) { if ( ! cpu_has_feature ( cpu_ftr_arch_300 ) ) r = ( ( threads_per_subcore << 1 ) - 1 ) ; else r = 8 | 4 | 2 | 1 ; } break ; case kvm_cap_ppc_rma : r = 0 ; break ; case kvm_cap_ppc_hwrng : r = kvmppc_hwrng_present ( ) ; break ; case kvm_cap_ppc_mmu_radix : r = ! ! ( hv_enabled && radix_enabled ( ) ) ; break ; case kvm_cap_ppc_mmu_hash_v3 : r = ! ! ( hv_enabled && ! radix_enabled ( ) && cpu_has_feature ( cpu_ftr_arch_300 ) ) ; break ; # endif case kvm_cap_sync_mmu : # ifdef config_kvm_book3s_hv_possible r = hv_enabled ; # elif defined ( kvm_arch_want_mmu_notifier ) r = 1 ; # else r = 0 ; # endif break ; # ifdef config_kvm_book3s_hv_possible case kvm_cap_ppc_htab_fd : r = hv_enabled ; break ; # endif case kvm_cap_nr_vcpus : if ( hv_enabled ) r = num_present_cpus ( ) ; else r = num_online_cpus ( ) ; break ; case kvm_cap_nr_memslots : r = kvm_user_mem_slots ; break ; case kvm_cap_max_vcpus : r = kvm_max_vcpus ; break ; # ifdef config_ppc_book3s_64 case kvm_cap_ppc_get_smmu_info : r = 1 ; break ; case kvm_cap_spapr_multitce : r = 1 ; break ; case kvm_cap_spapr_resize_hpt : r = ! ! hv_enabled && ! cpu_has_feature ( cpu_ftr_arch_300 ) ; break ; # endif # ifdef config_kvm_book3s_hv_possible case kvm_cap_ppc_fwnmi : r = hv_enabled ; break ; # endif case kvm_cap_ppc_htm : r = cpu_has_feature ( cpu_ftr_tm_comp ) && is_kvmppc_hv_enabled ( kvm ) ; break ; default : r = 0 ; break ; } return r ; }","<S2SV_ModStart> CPU_FTR_TM_COMP ) && hv_enabled <S2SV_ModEnd> ; break ;
",torvalds@linux/ac64115a66c18c01745bbd3c47a36b124e5fd8c0,CVE-2017-15306,https://github.com/torvalds/linux/commit/ac64115a66c18c01745bbd3c47a36b124e5fd8c0,2017-11-06T18:29Z,<S2SV_StartBug> is_kvmppc_hv_enabled ( kvm ) ; <S2SV_EndBug>
7469,CWE-476,"static vtermstate * vterm_state_new ( vterm * vt ) { vtermstate * state = vterm_allocator_malloc ( vt , sizeof ( vtermstate ) ) ; state -> vt = vt ; state -> rows = vt -> rows ; state -> cols = vt -> cols ; state -> mouse_col = 0 ; state -> mouse_row = 0 ; state -> mouse_buttons = 0 ; state -> mouse_protocol = mouse_x10 ; state -> callbacks = null ; state -> cbdata = null ; vterm_state_newpen ( state ) ; state -> bold_is_highbright = 0 ; return state ; }","<S2SV_ModStart> VTermState ) ) ; if ( state == NULL ) return NULL
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,"<S2SV_StartBug> VTermState * state = vterm_allocator_malloc ( vt , sizeof ( VTermState ) ) ; <S2SV_EndBug>"
2916,CWE-000,"static struct sk_buff * nf_ct_frag6_reasm ( struct nf_ct_frag6_queue * fq , struct net_device * dev ) { struct sk_buff * fp , * op , * head = fq -> q . fragments ; int payload_len ; fq_kill ( fq ) ; warn_on ( head == null ) ; warn_on ( nfct_frag6_cb ( head ) -> offset != 0 ) ; payload_len = ( ( head -> data - skb_network_header ( head ) ) - sizeof ( struct ipv6hdr ) + fq -> q . len - sizeof ( struct frag_hdr ) ) ; if ( payload_len > ipv6_maxplen ) { pr_debug ( ""payload<s2sv_blank>len<s2sv_blank>is<s2sv_blank>too<s2sv_blank>large.\\n"" ) ; goto out_oversize ; } if ( skb_cloned ( head ) && pskb_expand_head ( head , 0 , 0 , gfp_atomic ) ) { pr_debug ( ""skb<s2sv_blank>is<s2sv_blank>cloned<s2sv_blank>but<s2sv_blank>can\'t<s2sv_blank>expand<s2sv_blank>head"" ) ; goto out_oom ; } if ( skb_has_frags ( head ) ) { struct sk_buff * clone ; int i , plen = 0 ; if ( ( clone = alloc_skb ( 0 , gfp_atomic ) ) == null ) { pr_debug ( ""can\'t<s2sv_blank>alloc<s2sv_blank>skb\\n"" ) ; goto out_oom ; } clone -> next = head -> next ; head -> next = clone ; skb_shinfo ( clone ) -> frag_list = skb_shinfo ( head ) -> frag_list ; skb_frag_list_init ( head ) ; for ( i = 0 ; i < skb_shinfo ( head ) -> nr_frags ; i ++ ) plen += skb_shinfo ( head ) -> frags [ i ] . size ; clone -> len = clone -> data_len = head -> data_len - plen ; head -> data_len -= clone -> len ; head -> len -= clone -> len ; clone -> csum = 0 ; clone -> ip_summed = head -> ip_summed ; nfct_frag6_cb ( clone ) -> orig = null ; atomic_add ( clone -> truesize , & nf_init_frags . mem ) ; } skb_network_header ( head ) [ fq -> nhoffset ] = skb_transport_header ( head ) [ 0 ] ; memmove ( head -> head + sizeof ( struct frag_hdr ) , head -> head , ( head -> data - head -> head ) - sizeof ( struct frag_hdr ) ) ; head -> mac_header += sizeof ( struct frag_hdr ) ; head -> network_header += sizeof ( struct frag_hdr ) ; skb_shinfo ( head ) -> frag_list = head -> next ; skb_reset_transport_header ( head ) ; skb_push ( head , head -> data - skb_network_header ( head ) ) ; atomic_sub ( head -> truesize , & nf_init_frags . mem ) ; for ( fp = head -> next ; fp ; fp = fp -> next ) { head -> data_len += fp -> len ; head -> len += fp -> len ; if ( head -> ip_summed != fp -> ip_summed ) head -> ip_summed = checksum_none ; else if ( head -> ip_summed == checksum_complete ) head -> csum = csum_add ( head -> csum , fp -> csum ) ; head -> truesize += fp -> truesize ; atomic_sub ( fp -> truesize , & nf_init_frags . mem ) ; } head -> next = null ; head -> dev = dev ; head -> tstamp = fq -> q . stamp ; ipv6_hdr ( head ) -> payload_len = htons ( payload_len ) ; if ( head -> ip_summed == checksum_complete ) head -> csum = csum_partial ( skb_network_header ( head ) , skb_network_header_len ( head ) , head -> csum ) ; fq -> q . fragments = null ; fp = skb_shinfo ( head ) -> frag_list ; if ( nfct_frag6_cb ( fp ) -> orig == null ) fp = fp -> next ; op = nfct_frag6_cb ( head ) -> orig ; for ( ; fp ; fp = fp -> next ) { struct sk_buff * orig = nfct_frag6_cb ( fp ) -> orig ; op -> next = orig ; op = orig ; nfct_frag6_cb ( fp ) -> orig = null ; } return head ; out_oversize : if ( net_ratelimit ( ) ) printk ( kern_debug ""nf_ct_frag6_reasm:<s2sv_blank>payload<s2sv_blank>len<s2sv_blank>=<s2sv_blank>%d\\n"" , payload_len ) ; goto out_fail ; out_oom : if ( net_ratelimit ( ) ) printk ( kern_debug ""nf_ct_frag6_reasm:<s2sv_blank>no<s2sv_blank>memory<s2sv_blank>for<s2sv_blank>reassembly\\n"" ) ; out_fail : return null ; }","<S2SV_ModStart> ; if ( fp &&
",torvalds@linux/9e2dcf72023d1447f09c47d77c99b0c49659e5ce,CVE-2012-2744,https://github.com/torvalds/linux/commit/9e2dcf72023d1447f09c47d77c99b0c49659e5ce,2012-08-09T10:29Z,<S2SV_StartBug> if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) <S2SV_EndBug>
2278,CWE-119,"static enum led_brightness k90_backlight_get ( struct led_classdev * led_cdev ) { int ret ; struct k90_led * led = container_of ( led_cdev , struct k90_led , cdev ) ; struct device * dev = led -> cdev . dev -> parent ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int brightness ; char data [ 8 ] ; ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , k90_request_status , usb_dir_in | usb_type_vendor | usb_recip_device , 0 , 0 , data , 8 , usb_ctrl_set_timeout ) ; if ( ret < 0 ) { dev_warn ( dev , ""failed<s2sv_blank>to<s2sv_blank>get<s2sv_blank>k90<s2sv_blank>initial<s2sv_blank>state<s2sv_blank>(error<s2sv_blank>%d).\\n"" , ret ) ; return - eio ; } brightness = data [ 4 ] ; if ( brightness < 0 || brightness > 3 ) { dev_warn ( dev , ""read<s2sv_blank>invalid<s2sv_blank>backlight<s2sv_blank>brightness:<s2sv_blank>%02hhx.\\n"" , data [ 4 ] ) ; return - eio ; } return brightness ; }","<S2SV_ModStart> brightness ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } brightness <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/6d104af38b570d37aa32a5803b04c354f8ed513d,CVE-2017-5547,https://github.com/torvalds/linux/commit/6d104af38b570d37aa32a5803b04c354f8ed513d,2017-02-06T06:59Z,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
2758,CWE-000,"struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( is_err ( map ) ) return map ; bpf_map_inc ( map , true ) ; fdput ( f ) ; return map ; }","<S2SV_ModStart> return map ; map =
",torvalds@linux/92117d8443bc5afacc8d5ba82e541946310f106e,CVE-2016-4558,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,2016-05-23T10:59Z,"<S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug>"
4210,CWE-78,"r_api char * r_socket_http_post ( const char * url , const char * data , int * code , int * rlen ) { rsocket * s ; bool ssl = r_str_startswith ( url , ""https://"" ) ; char * uri = strdup ( url ) ; if ( ! uri ) { return null ; } char * host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; printf ( ""invalid<s2sv_blank>uri"" ) ; return null ; } host += 3 ; char * port = strchr ( host , ':' ) ; if ( ! port ) { port = ( ssl ) ? ""443"" : ""80"" ; } else { * port ++ = 0 ; } char * path = strchr ( host , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { printf ( ""cannot<s2sv_blank>create<s2sv_blank>socket\\n"" ) ; free ( uri ) ; return null ; } if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) { eprintf ( ""cannot<s2sv_blank>connect<s2sv_blank>to<s2sv_blank>%s:%s\\n"" , host , port ) ; free ( uri ) ; return null ; } r_socket_printf ( s , ""post<s2sv_blank>/%s<s2sv_blank>http/1.0\\r\\n"" ""user-agent:<s2sv_blank>radare2<s2sv_blank>"" r2_version ""\\r\\n"" ""accept:<s2sv_blank>*/*\\r\\n"" ""host:<s2sv_blank>%s\\r\\n"" ""content-length:<s2sv_blank>%i\\r\\n"" ""content-type:<s2sv_blank>application/x-www-form-urlencoded\\r\\n"" ""\\r\\n"" , path , host , ( int ) strlen ( data ) ) ; free ( uri ) ; r_socket_write ( s , ( void * ) data , strlen ( data ) ) ; return r_socket_http_answer ( s , code , rlen ) ; }","<S2SV_ModStart> ) ; return socket_http_answer <S2SV_ModEnd> ( s , <S2SV_ModStart> code , rlen , 0
",radareorg@radare2/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,CVE-2020-15121,https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,2020-07-20T18:15Z,"<S2SV_StartBug> return r_socket_http_answer ( s , code , rlen ) ; <S2SV_EndBug>"
19,CWE-125,"static int aes_gcm_ctrl ( evp_cipher_ctx * c , int type , int arg , void * ptr ) { evp_aes_gcm_ctx * gctx = evp_c_data ( evp_aes_gcm_ctx , c ) ; switch ( type ) { case evp_ctrl_init : gctx -> key_set = 0 ; gctx -> iv_set = 0 ; gctx -> ivlen = evp_cipher_ctx_iv_length ( c ) ; gctx -> iv = evp_cipher_ctx_iv_noconst ( c ) ; gctx -> taglen = - 1 ; gctx -> iv_gen = 0 ; gctx -> tls_aad_len = - 1 ; return 1 ; case evp_ctrl_aead_set_ivlen : if ( arg <= 0 ) return 0 ; if ( ( arg > evp_max_iv_length ) && ( arg > gctx -> ivlen ) ) { if ( gctx -> iv != evp_cipher_ctx_iv_noconst ( c ) ) openssl_free ( gctx -> iv ) ; gctx -> iv = openssl_malloc ( arg ) ; if ( gctx -> iv == null ) return 0 ; } gctx -> ivlen = arg ; return 1 ; case evp_ctrl_aead_set_tag : if ( arg <= 0 || arg > 16 || evp_cipher_ctx_encrypting ( c ) ) return 0 ; memcpy ( evp_cipher_ctx_buf_noconst ( c ) , ptr , arg ) ; gctx -> taglen = arg ; return 1 ; case evp_ctrl_aead_get_tag : if ( arg <= 0 || arg > 16 || ! evp_cipher_ctx_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ; memcpy ( ptr , evp_cipher_ctx_buf_noconst ( c ) , arg ) ; return 1 ; case evp_ctrl_gcm_set_iv_fixed : if ( arg == - 1 ) { memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ; gctx -> iv_gen = 1 ; return 1 ; } if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ; if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ; if ( evp_cipher_ctx_encrypting ( c ) && rand_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ; gctx -> iv_gen = 1 ; return 1 ; case evp_ctrl_gcm_iv_gen : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ; crypto_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ; if ( arg <= 0 || arg > gctx -> ivlen ) arg = gctx -> ivlen ; memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ; ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ) ; gctx -> iv_set = 1 ; return 1 ; case evp_ctrl_gcm_set_iv_inv : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || evp_cipher_ctx_encrypting ( c ) ) return 0 ; memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ; crypto_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ; gctx -> iv_set = 1 ; return 1 ; case evp_ctrl_aead_tls1_aad : if ( arg != evp_aead_tls1_aad_len ) return 0 ; memcpy ( evp_cipher_ctx_buf_noconst ( c ) , ptr , arg ) ; gctx -> tls_aad_len = arg ; { unsigned int len = evp_cipher_ctx_buf_noconst ( c ) [ arg - 2 ] << 8 | evp_cipher_ctx_buf_noconst ( c ) [ arg - 1 ] ; len -= evp_gcm_tls_explicit_iv_len ; if ( ! evp_cipher_ctx_encrypting ( c ) ) len -= evp_gcm_tls_tag_len ; evp_cipher_ctx_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ; evp_cipher_ctx_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ; } return evp_gcm_tls_tag_len ; case evp_ctrl_copy : { evp_cipher_ctx * out = ptr ; evp_aes_gcm_ctx * gctx_out = evp_c_data ( evp_aes_gcm_ctx , out ) ; if ( gctx -> gcm . key ) { if ( gctx -> gcm . key != & gctx -> ks ) return 0 ; gctx_out -> gcm . key = & gctx_out -> ks ; } if ( gctx -> iv == evp_cipher_ctx_iv_noconst ( c ) ) gctx_out -> iv = evp_cipher_ctx_iv_noconst ( out ) ; else { gctx_out -> iv = openssl_malloc ( gctx -> ivlen ) ; if ( gctx_out -> iv == null ) return 0 ; memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ; } return 1 ; } default : return - 1 ; } }","<S2SV_ModStart> 1 ] ; if ( len < EVP_GCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> c ) ) { if ( len < EVP_GCM_TLS_TAG_LEN ) return 0 ; <S2SV_ModStart> -= EVP_GCM_TLS_TAG_LEN ; }
",openssl@openssl/00d965474b22b54e4275232bc71ee0c699c5cd21,CVE-2017-3731,https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21,2017-05-04T19:29Z,<S2SV_StartBug> len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= EVP_GCM_TLS_TAG_LEN ; <S2SV_EndBug>
5660,CWE-601,"static int oidc_handle_logout ( request_rec * r , oidc_cfg * c , oidc_session_t * session ) { oidc_provider_t * provider = null ; char * url = null ; oidc_util_get_request_parameter ( r , oidc_redirect_uri_request_logout , & url ) ; oidc_debug ( r , ""enter<s2sv_blank>(url=%s)"" , url ) ; if ( oidc_is_front_channel_logout ( url ) ) { return oidc_handle_logout_request ( r , c , session , url ) ; } else if ( oidc_is_back_channel_logout ( url ) ) { return oidc_handle_logout_backchannel ( r , c ) ; } if ( ( url == null ) || ( apr_strnatcmp ( url , """" ) == 0 ) ) { url = c -> default_slo_url ; } else { const char * error_description = null ; apr_uri_t uri ; if ( apr_uri_parse ( r -> pool , url , & uri ) != apr_success ) { const char * error_description = apr_psprintf ( r -> pool , ""logout<s2sv_blank>url<s2sv_blank>malformed:<s2sv_blank>%s"" , url ) ; oidc_error ( r , ""%s"" , error_description ) ; return oidc_util_html_send_error ( r , c -> error_template , ""malformed<s2sv_blank>url"" , error_description , http_internal_server_error ) ; } const char * c_host = oidc_get_current_url_host ( r ) ; if ( ( uri . hostname != null ) && ( ( strstr ( c_host , uri . hostname ) == null ) || ( strstr ( uri . hostname , c_host ) == null ) ) ) { error_description = apr_psprintf ( r -> pool , ""logout<s2sv_blank>value<s2sv_blank>\\""%s\\""<s2sv_blank>does<s2sv_blank>not<s2sv_blank>match<s2sv_blank>the<s2sv_blank>hostname<s2sv_blank>of<s2sv_blank>the<s2sv_blank>current<s2sv_blank>request<s2sv_blank>\\""%s\\"""" , apr_uri_unparse ( r -> pool , & uri , 0 ) , c_host ) ; oidc_error ( r , ""%s"" , error_description ) ; return oidc_util_html_send_error ( r , c -> error_template , ""invalid<s2sv_blank>request"" , error_description , http_internal_server_error ) ; } if ( ( ( strstr ( url , ""\\n"" ) != null ) || strstr ( url , ""\\r"" ) != null ) ) { error_description = apr_psprintf ( r -> pool , ""logout<s2sv_blank>value<s2sv_blank>\\""%s\\""<s2sv_blank>contains<s2sv_blank>illegal<s2sv_blank>\\""\\n\\""<s2sv_blank>or<s2sv_blank>\\""\\r\\""<s2sv_blank>character(s)"" , url ) ; oidc_error ( r , ""%s"" , error_description ) ; return oidc_util_html_send_error ( r , c -> error_template , ""invalid<s2sv_blank>request"" , error_description , http_internal_server_error ) ; } } oidc_get_provider_from_session ( r , c , session , & provider ) ; if ( ( provider != null ) && ( provider -> end_session_endpoint != null ) ) { const char * id_token_hint = oidc_session_get_idtoken ( r , session ) ; char * logout_request = apr_pstrdup ( r -> pool , provider -> end_session_endpoint ) ; if ( id_token_hint != null ) { logout_request = apr_psprintf ( r -> pool , ""%s%sid_token_hint=%s"" , logout_request , strchr ( logout_request ? logout_request : """" , oidc_char_query ) != null ? oidc_str_amp : oidc_str_query , oidc_util_escape_string ( r , id_token_hint ) ) ; } if ( url != null ) { logout_request = apr_psprintf ( r -> pool , ""%s%spost_logout_redirect_uri=%s"" , logout_request , strchr ( logout_request ? logout_request : """" , oidc_char_query ) != null ? oidc_str_amp : oidc_str_query , oidc_util_escape_string ( r , url ) ) ; } url = logout_request ; } return oidc_handle_logout_request ( r , c , session , url ) ; }","<S2SV_ModStart> = NULL ; char * error_str = NULL ; char * error_description = NULL ; <S2SV_ModStart> } else { if ( oidc_validate_post_logout_url ( r , url , & error_str , & error_description ) == FALSE ) { <S2SV_ModEnd> return oidc_util_html_send_error ( <S2SV_ModStart> -> error_template , error_str , error_description , HTTP_BAD_REQUEST <S2SV_ModEnd> ) ; }
",zmartzone@mod_auth_openidc/5c15dfb08106c2451c2c44ce7ace6813c216ba75,CVE-2019-14857,https://github.com/zmartzone/mod_auth_openidc/commit/5c15dfb08106c2451c2c44ce7ace6813c216ba75,2019-11-26T12:15Z,"<S2SV_StartBug> oidc_util_get_request_parameter ( r , OIDC_REDIRECT_URI_REQUEST_LOGOUT , & url ) ; <S2SV_EndBug> <S2SV_StartBug> const char * error_description = NULL ; <S2SV_EndBug> <S2SV_StartBug> ""Malformed<S2SV_blank>URL"" , error_description , <S2SV_EndBug>"
7837,CWE-20,"error_t rawsocketsendethpacket ( socket * socket , const socketmsg * message , uint_t flags ) { error_t error ; # if ( eth_support == enabled ) size_t length ; netbuffer * buffer ; netinterface * interface ; if ( socket -> interface != null ) { interface = socket -> interface ; } else { interface = netgetdefaultinterface ( ) ; } interface = nicgetphysicalinterface ( interface ) ; if ( interface -> nicdriver != null && interface -> nicdriver -> type == nic_type_ethernet ) { buffer = netbufferalloc ( 0 ) ; if ( buffer == null ) return error_out_of_memory ; length = message -> length ; error = netbufferappend ( buffer , message -> data , length ) ; if ( ! error ) { if ( ! interface -> nicdriver -> autopadding ) { if ( length < ( eth_min_frame_size - eth_crc_size ) ) { size_t n ; n = ( eth_min_frame_size - eth_crc_size ) - length ; error = netbufferappend ( buffer , ethpadding , n ) ; length += n ; } } } if ( ! error ) { if ( ! interface -> nicdriver -> autocrccalc ) { uint32_t crc ; crc = ethcalccrcex ( buffer , 0 , length ) ; crc = htole32 ( crc ) ; error = netbufferappend ( buffer , & crc , sizeof ( crc ) ) ; length += sizeof ( crc ) ; } } if ( ! error ) { nettxancillary ancillary ; ancillary = net_default_tx_ancillary ; # if ( eth_port_tagging_support == enabled ) ancillary . port = message -> switchport ; # endif # if ( eth_timestamp_support == enabled ) ancillary . timestampid = message -> timestampid ; # endif trace_debug ( ""sending<s2sv_blank>raw<s2sv_blank>ethernet<s2sv_blank>frame<s2sv_blank>(%"" priusize ""<s2sv_blank>bytes)...\\r\\n"" , length ) ; error = nicsendpacket ( interface , buffer , 0 , & ancillary ) ; } netbufferfree ( buffer ) ; } else # endif { error = error_invalid_interface ; } return error ; }","<S2SV_ModStart> * interface ; if ( message -> interface != NULL ) { interface = message -> interface ; } else
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> if ( socket -> interface != NULL ) <S2SV_EndBug>
7607,CWE-190,jas_image_t * jas_image_create0 ( ) { jas_image_t * image ; if ( ! ( image = jas_malloc ( sizeof ( jas_image_t ) ) ) ) { return 0 ; } image -> tlx_ = 0 ; image -> tly_ = 0 ; image -> brx_ = 0 ; image -> bry_ = 0 ; image -> clrspc_ = jas_clrspc_unknown ; image -> numcmpts_ = 0 ; image -> maxcmpts_ = 0 ; image -> cmpts_ = 0 ; image -> inmem_ = true ; image -> cmprof_ = 0 ; return image ; },"<S2SV_ModStart> ; image -> <S2SV_ModEnd> cmprof_ = 0
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> image -> inmem_ = true ; <S2SV_EndBug>
3185,CWE-119,"static guint32 parse_wbxml_attribute_list ( proto_tree * tree , tvbuff_t * tvb , guint32 offset , guint32 str_tbl , guint8 level , guint8 * codepage_attr ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; guint32 off = offset ; guint32 len ; guint str_len ; guint32 ent ; guint32 idx ; guint8 peek ; debuglog ( ( ""parse_wbxml_attr<s2sv_blank>(level<s2sv_blank>=<s2sv_blank>%u,<s2sv_blank>offset<s2sv_blank>=<s2sv_blank>%u)\\n"" , level , offset ) ) ; while ( off < tvb_len ) { peek = tvb_get_guint8 ( tvb , off ) ; debuglog ( ( ""attr:<s2sv_blank>(top<s2sv_blank>of<s2sv_blank>while)<s2sv_blank>level<s2sv_blank>=<s2sv_blank>%3u,<s2sv_blank>peek<s2sv_blank>=<s2sv_blank>0x%02x,<s2sv_blank>"" ""off<s2sv_blank>=<s2sv_blank>%u,<s2sv_blank>tvb_len<s2sv_blank>=<s2sv_blank>%u\\n"" , level , peek , off , tvb_len ) ) ; if ( ( peek & 0x3f ) < 5 ) switch ( peek ) { case 0x00 : * codepage_attr = tvb_get_guint8 ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 2 , ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>-->%3d<s2sv_blank>"" ""|<s2sv_blank>switch_page<s2sv_blank>(attr<s2sv_blank>code<s2sv_blank>page)<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>|"" , * codepage_attr ) ; off += 2 ; break ; case 0x01 : off ++ ; debuglog ( ( ""attr:<s2sv_blank>level<s2sv_blank>=<s2sv_blank>%u,<s2sv_blank>return:<s2sv_blank>len<s2sv_blank>=<s2sv_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; case 0x02 : ent = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank>entity<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s\'&#%u;\'"" , level , * codepage_attr , indent ( level ) , ent ) ; off += 1 + len ; break ; case 0x03 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank>str_i<s2sv_blank>(inline<s2sv_blank>string)<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s\\\'%s\\\'"" , level , * codepage_attr , indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x04 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank>literal<s2sv_blank>(literal<s2sv_blank>attribute)<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank>%s<%s<s2sv_blank>/>"" , level , * codepage_attr , indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0x40 : case 0x41 : case 0x42 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank>ext_i_%1x<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>(extension<s2sv_blank>token)<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s(inline<s2sv_blank>string<s2sv_blank>extension:<s2sv_blank>\\\'%s\\\')"" , level , * codepage_attr , peek & 0x0f , indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x80 : case 0x81 : case 0x82 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank>ext_t_%1x<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>(extension<s2sv_blank>token)<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s(extension<s2sv_blank>token,<s2sv_blank>integer<s2sv_blank>value:<s2sv_blank>%u)"" , level , * codepage_attr , peek & 0x0f , indent ( level ) , idx ) ; off += 1 + len ; break ; case 0x83 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank>str_t<s2sv_blank>(tableref<s2sv_blank>string)<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s\\\'%s\\\'"" , level , * codepage_attr , indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0xc0 : case 0xc1 : case 0xc2 : proto_tree_add_text ( tree , tvb , off , 1 , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank>ext_%1x<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>(extension<s2sv_blank>token)<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s(single-byte<s2sv_blank>extension)"" , level , * codepage_attr , peek & 0x0f , indent ( level ) ) ; off ++ ; break ; case 0xc3 : if ( tvb_get_guint8 ( tvb , 0 ) ) { idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len + idx , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank>opaque<s2sv_blank>(opaque<s2sv_blank>data)<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s(%d<s2sv_blank>bytes<s2sv_blank>of<s2sv_blank>opaque<s2sv_blank>data)"" , level , * codepage_attr , indent ( level ) , idx ) ; off += 1 + len + idx ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank>reserved_2<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>(invalid<s2sv_blank>token!)<s2sv_blank>"" ""|<s2sv_blank>wbxml<s2sv_blank>1.0<s2sv_blank>parsing<s2sv_blank>stops<s2sv_blank>here."" , level , * codepage_attr ) ; off = tvb_len ; debuglog ( ( ""attr:<s2sv_blank>level<s2sv_blank>=<s2sv_blank>%u,<s2sv_blank>return:<s2sv_blank>len<s2sv_blank>=<s2sv_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; } break ; default : proto_tree_add_text ( tree , tvb , off , 1 , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank>%-10s<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>(invalid<s2sv_blank>token!)<s2sv_blank>"" ""|<s2sv_blank>wbxml<s2sv_blank>parsing<s2sv_blank>stops<s2sv_blank>here."" , level , * codepage_attr , val_to_str_ext ( peek , & vals_wbxml1x_global_tokens_ext , ""(unknown<s2sv_blank>0x%x)"" ) ) ; off = tvb_len ; break ; } else { if ( peek & 0x80 ) { proto_tree_add_text ( tree , tvb , off , 1 , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank>known<s2sv_blank>attrvalue<s2sv_blank>0x%02x<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%sattrvalue_0x%02x"" , level , * codepage_attr , peek & 0x7f , indent ( level ) , peek ) ; off ++ ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<s2sv_blank><s2sv_blank>%3d<s2sv_blank>|<s2sv_blank><s2sv_blank>attr<s2sv_blank>|<s2sv_blank>a<s2sv_blank>%3d<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank>known<s2sv_blank>attrstart<s2sv_blank>0x%02x<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ""|<s2sv_blank><s2sv_blank><s2sv_blank>%sattrstart_0x%02x"" , level , * codepage_attr , peek & 0x7f , indent ( level ) , peek ) ; off ++ ; } } } debuglog ( ( ""attr:<s2sv_blank>level<s2sv_blank>=<s2sv_blank>%u,<s2sv_blank>return:<s2sv_blank>len<s2sv_blank>=<s2sv_blank>%u<s2sv_blank>(end<s2sv_blank>of<s2sv_blank>function<s2sv_blank>body)\\n"" , level , off - offset ) ) ; return ( off - offset ) ; }","<S2SV_ModStart> off = offset , last_off <S2SV_ModStart> offset ) ) ; last_off = off <S2SV_ModStart> ; } } if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ;
",wireshark@wireshark/b8e0d416898bb975a02c1b55883342edc5b4c9c0,CVE-2016-5359,https://github.com/wireshark/wireshark/commit/b8e0d416898bb975a02c1b55883342edc5b4c9c0,2016-08-07T16:59Z,"<S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> <S2SV_StartBug> DebugLog ( ( ""parse_wbxml_attr<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , level , offset ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
7764,CWE-125,"int pyparser_addtoken ( parser_state * ps , int type , char * str , int lineno , int col_offset , int end_lineno , int end_col_offset , int * expected_ret ) { int ilabel ; int err ; d ( printf ( ""token<s2sv_blank>%s/\'%s\'<s2sv_blank>...<s2sv_blank>"" , _pyparser_tokennames [ type ] , str ) ) ; ilabel = classify ( ps , type , str ) ; if ( ilabel < 0 ) return e_syntax ; for ( ; ; ) { dfa * d = ps -> p_stack . s_top -> s_dfa ; state * s = & d -> d_state [ ps -> p_stack . s_top -> s_state ] ; d ( printf ( ""<s2sv_blank>dfa<s2sv_blank>\'%s\',<s2sv_blank>state<s2sv_blank>%d:"" , d -> d_name , ps -> p_stack . s_top -> s_state ) ) ; if ( s -> s_lower <= ilabel && ilabel < s -> s_upper ) { int x = s -> s_accel [ ilabel - s -> s_lower ] ; if ( x != - 1 ) { if ( x & ( 1 << 7 ) ) { int nt = ( x >> 8 ) + nt_offset ; int arrow = x & ( ( 1 << 7 ) - 1 ) ; dfa * d1 = pygrammar_finddfa ( ps -> p_grammar , nt ) ; if ( ( err = push ( & ps -> p_stack , nt , d1 , arrow , lineno , col_offset , end_lineno , end_col_offset ) ) > 0 ) { d ( printf ( ""<s2sv_blank>memerror:<s2sv_blank>push\\n"" ) ) ; return err ; } d ( printf ( ""<s2sv_blank>push<s2sv_blank>...\\n"" ) ) ; continue ; } if ( ( err = shift ( & ps -> p_stack , type , str , x , lineno , col_offset , end_lineno , end_col_offset ) ) > 0 ) { d ( printf ( ""<s2sv_blank>memerror:<s2sv_blank>shift.\\n"" ) ) ; return err ; } d ( printf ( ""<s2sv_blank>shift.\\n"" ) ) ; while ( s = & d -> d_state [ ps -> p_stack . s_top -> s_state ] , s -> s_accept && s -> s_narcs == 1 ) { d ( printf ( ""<s2sv_blank><s2sv_blank>dfa<s2sv_blank>\'%s\',<s2sv_blank>state<s2sv_blank>%d:<s2sv_blank>"" ""direct<s2sv_blank>pop.\\n"" , d -> d_name , ps -> p_stack . s_top -> s_state ) ) ; # ifdef py_parser_requires_future_keyword # if 0 if ( d -> d_name [ 0 ] == 'i' && strcmp ( d -> d_name , ""import_stmt"" ) == 0 ) future_hack ( ps ) ; # endif # endif s_pop ( & ps -> p_stack ) ; if ( s_empty ( & ps -> p_stack ) ) { d ( printf ( ""<s2sv_blank><s2sv_blank>accept.\\n"" ) ) ; return e_done ; } d = ps -> p_stack . s_top -> s_dfa ; } return e_ok ; } } if ( s -> s_accept ) { # ifdef py_parser_requires_future_keyword # if 0 if ( d -> d_name [ 0 ] == 'i' && strcmp ( d -> d_name , ""import_stmt"" ) == 0 ) future_hack ( ps ) ; # endif # endif s_pop ( & ps -> p_stack ) ; d ( printf ( ""<s2sv_blank>pop<s2sv_blank>...\\n"" ) ) ; if ( s_empty ( & ps -> p_stack ) ) { d ( printf ( ""<s2sv_blank>error:<s2sv_blank>bottom<s2sv_blank>of<s2sv_blank>stack.\\n"" ) ) ; return e_syntax ; } continue ; } d ( printf ( ""<s2sv_blank>error.\\n"" ) ) ; if ( expected_ret ) { if ( s -> s_lower == s -> s_upper - 1 ) { * expected_ret = ps -> p_grammar -> g_ll . ll_label [ s -> s_lower ] . lb_type ; } else * expected_ret = - 1 ; } return e_syntax ; } }","<S2SV_ModStart> dfa * d1 ; if ( nt == func_body_suite && ! ( ps -> p_flags & PyCF_TYPE_COMMENTS ) ) { D ( printf ( ""<S2SV_blank>[switch<S2SV_blank>func_body_suite<S2SV_blank>to<S2SV_blank>suite]"" ) ) ; nt = suite ; } d1 <S2SV_ModStart> ( printf ( ""<S2SV_blank>Push<S2SV_blank>\'%s\'\\n"" , d1 -> d_name <S2SV_ModEnd> ) ) ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> dfa * d1 = PyGrammar_FindDFA ( <S2SV_EndBug> <S2SV_StartBug> D ( printf ( ""<S2SV_blank>Push<S2SV_blank>...\\n"" ) ) ; <S2SV_EndBug>"
7511,CWE-665,"void rfbsendservercuttext ( rfbscreeninfoptr rfbscreen , char * str , int len ) { rfbclientptr cl ; rfbservercuttextmsg sct ; rfbclientiteratorptr iterator ; iterator = rfbgetclientiterator ( rfbscreen ) ; while ( ( cl = rfbclientiteratornext ( iterator ) ) != null ) { sct . type = rfbservercuttext ; sct . length = swap32ifle ( len ) ; lock ( cl -> sendmutex ) ; if ( rfbwriteexact ( cl , ( char * ) & sct , sz_rfbservercuttextmsg ) < 0 ) { rfblogperror ( ""rfbsendservercuttext:<s2sv_blank>write"" ) ; rfbcloseclient ( cl ) ; unlock ( cl -> sendmutex ) ; continue ; } if ( rfbwriteexact ( cl , str , len ) < 0 ) { rfblogperror ( ""rfbsendservercuttext:<s2sv_blank>write"" ) ; rfbcloseclient ( cl ) ; } unlock ( cl -> sendmutex ) ; rfbstatrecordmessagesent ( cl , rfbservercuttext , sz_rfbservercuttextmsg + len , sz_rfbservercuttextmsg + len ) ; } rfbreleaseclientiterator ( iterator ) ; }","<S2SV_ModStart> rfbClientIteratorPtr iterator ; memset ( ( char * ) & sct , 0 , sizeof ( sct ) ) ;
",LibVNC@libvncserver/d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a,CVE-2019-15681,https://github.com/LibVNC/libvncserver/commit/d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a,2019-10-29T19:15Z,<S2SV_StartBug> iterator = rfbGetClientIterator ( rfbScreen ) ; <S2SV_EndBug>
7453,CWE-125,"static void l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) { const uint16_t * ptr = ( const uint16_t * ) dat ; nd_print ( ( ndo , ""%u"" , extract_16bits ( ptr ) & l2tp_proxy_auth_id_mask ) ) ; }","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,"<S2SV_StartBug> l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug>"
23,CWE-200,"static int udf_encode_fh ( struct inode * inode , __u32 * fh , int * lenp , struct inode * parent ) { int len = * lenp ; struct kernel_lb_addr location = udf_i ( inode ) -> i_location ; struct fid * fid = ( struct fid * ) fh ; int type = fileid_udf_without_parent ; if ( parent && ( len < 5 ) ) { * lenp = 5 ; return 255 ; } else if ( len < 3 ) { * lenp = 3 ; return 255 ; } * lenp = 3 ; fid -> udf . block = location . logicalblocknum ; fid -> udf . partref = location . partitionreferencenum ; fid -> udf . generation = inode -> i_generation ; if ( parent ) { location = udf_i ( parent ) -> i_location ; fid -> udf . parent_block = location . logicalblocknum ; fid -> udf . parent_partref = location . partitionreferencenum ; fid -> udf . parent_generation = inode -> i_generation ; * lenp = 5 ; type = fileid_udf_with_parent ; } return type ; }","<S2SV_ModStart> -> udf . parent_partref = 0 ; fid -> udf .
",torvalds@linux/0143fc5e9f6f5aad4764801015bc8d4b4a278200,CVE-2012-6548,https://github.com/torvalds/linux/commit/0143fc5e9f6f5aad4764801015bc8d4b4a278200,2013-03-15T20:55Z,<S2SV_StartBug> fid -> udf . generation = inode -> i_generation ; <S2SV_EndBug>
3273,CWE-399,"int udp_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; declare_sockaddr ( struct sockaddr_in * , sin , msg -> msg_name ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = is_udplite ( sk ) ; bool slow ; if ( flags & msg_errqueue ) return ip_recv_error ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? msg_dontwait : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= msg_trunc ; if ( copied < ulen || udp_skb_cb ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - einval ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; udp_inc_stats_user ( sock_net ( sk ) , udp_mib_inerrors , is_udplite ) ; } goto out_free ; } if ( ! peeked ) udp_inc_stats_user ( sock_net ( sk ) , udp_mib_indatagrams , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = af_inet ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; } if ( inet -> cmsg_flags ) ip_cmsg_recv_offset ( msg , skb , sizeof ( struct udphdr ) ) ; err = copied ; if ( flags & msg_trunc ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { udp_inc_stats_user ( sock_net ( sk ) , udp_mib_csumerrors , is_udplite ) ; udp_inc_stats_user ( sock_net ( sk ) , udp_mib_inerrors , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; if ( noblock ) return - eagain ; msg -> msg_flags &= ~ msg_trunc ; goto try_again ; }","<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
",torvalds@linux/beb39db59d14990e401e235faf66a6b9b31240b0,CVE-2015-5366,https://github.com/torvalds/linux/commit/beb39db59d14990e401e235faf66a6b9b31240b0,2015-08-31T10:59Z,<S2SV_StartBug> if ( noblock ) <S2SV_EndBug>
7186,CWE-552,"static ssize_t _hostsock_sendto ( oe_fd_t * sock_ , const void * buf , size_t count , int flags , const struct oe_sockaddr * dest_addr , oe_socklen_t addrlen ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_errno = 0 ; if ( ! sock || ( count && ! buf ) ) oe_raise_errno ( oe_einval ) ; if ( oe_syscall_sendto_ocall ( & ret , sock -> host_fd , buf , count , flags , ( struct oe_sockaddr * ) dest_addr , addrlen ) != oe_ok ) { oe_raise_errno ( oe_einval ) ; } done : return ret ; }","<S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,<S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug>
2557,CWE-19,"int xfs_attr3_leaf_getvalue ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; int valuelen ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; assert ( ichdr . count < xfs_lbsize ( args -> dp -> i_mount ) / 8 ) ; assert ( args -> index < ichdr . count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( entry -> flags & xfs_attr_local ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; assert ( name_loc -> namelen == args -> namelen ) ; assert ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) == 0 ) ; valuelen = be16_to_cpu ( name_loc -> valuelen ) ; if ( args -> flags & attr_kernoval ) { args -> valuelen = valuelen ; return 0 ; } if ( args -> valuelen < valuelen ) { args -> valuelen = valuelen ; return xfs_error ( erange ) ; } args -> valuelen = valuelen ; memcpy ( args -> value , & name_loc -> nameval [ args -> namelen ] , valuelen ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; assert ( name_rmt -> namelen == args -> namelen ) ; assert ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) == 0 ) ; valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , valuelen ) ; if ( args -> flags & attr_kernoval ) { args -> valuelen = valuelen ; return 0 ; } if ( args -> valuelen < valuelen ) { args -> valuelen = valuelen ; return xfs_error ( erange ) ; } args -> valuelen = valuelen ; } return 0 ; }","<S2SV_ModStart> 0 ) ; args -> rmtvaluelen <S2SV_ModEnd> = be32_to_cpu ( <S2SV_ModStart> -> i_mount , args -> rmtvaluelen <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return 0 <S2SV_ModStart> -> valuelen < args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return XFS_ERROR <S2SV_ModStart> -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; } return
",torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z,<S2SV_StartBug> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> <S2SV_StartBug> if ( args -> valuelen < valuelen ) { <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug>
2378,CWE-416,"static long do_get_mempolicy ( int * policy , nodemask_t * nmask , unsigned long addr , unsigned long flags ) { int err ; struct mm_struct * mm = current -> mm ; struct vm_area_struct * vma = null ; struct mempolicy * pol = current -> mempolicy ; if ( flags & ~ ( unsigned long ) ( mpol_f_node | mpol_f_addr | mpol_f_mems_allowed ) ) return - einval ; if ( flags & mpol_f_mems_allowed ) { if ( flags & ( mpol_f_node | mpol_f_addr ) ) return - einval ; * policy = 0 ; task_lock ( current ) ; * nmask = cpuset_current_mems_allowed ; task_unlock ( current ) ; return 0 ; } if ( flags & mpol_f_addr ) { down_read ( & mm -> mmap_sem ) ; vma = find_vma_intersection ( mm , addr , addr + 1 ) ; if ( ! vma ) { up_read ( & mm -> mmap_sem ) ; return - efault ; } if ( vma -> vm_ops && vma -> vm_ops -> get_policy ) pol = vma -> vm_ops -> get_policy ( vma , addr ) ; else pol = vma -> vm_policy ; } else if ( addr ) return - einval ; if ( ! pol ) pol = & default_policy ; if ( flags & mpol_f_node ) { if ( flags & mpol_f_addr ) { err = lookup_node ( addr ) ; if ( err < 0 ) goto out ; * policy = err ; } else if ( pol == current -> mempolicy && pol -> mode == mpol_interleave ) { * policy = next_node_in ( current -> il_prev , pol -> v . nodes ) ; } else { err = - einval ; goto out ; } } else { * policy = pol == & default_policy ? mpol_default : pol -> mode ; * policy |= ( pol -> flags & mpol_mode_flags ) ; } if ( vma ) { up_read ( & current -> mm -> mmap_sem ) ; vma = null ; } err = 0 ; if ( nmask ) { if ( mpol_store_user_nodemask ( pol ) ) { * nmask = pol -> w . user_nodemask ; } else { task_lock ( current ) ; get_policy_nodemask ( pol , nmask ) ; task_unlock ( current ) ; } } out : mpol_cond_put ( pol ) ; if ( vma ) up_read ( & current -> mm -> mmap_sem ) ; return err ; }","<S2SV_ModStart> ) ; } <S2SV_ModEnd> err = 0
",torvalds@linux/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,CVE-2018-10675,https://github.com/torvalds/linux/commit/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,2018-05-02T18:29Z,<S2SV_StartBug> if ( vma ) { <S2SV_EndBug>
6411,CWE-119,"int imagingflidecode ( imaging im , imagingcodecstate state , uint8 * buf , int bytes ) { uint8 * ptr ; int framesize ; int c , chunks ; int l , lines ; int i , j , x = 0 , y , ymax ; if ( bytes < 4 ) return 0 ; ptr = buf ; framesize = i32 ( ptr ) ; if ( framesize < i32 ( ptr ) ) return 0 ; if ( i16 ( ptr + 4 ) != 0xf1fa ) { state -> errcode = imaging_codec_unknown ; return - 1 ; } chunks = i16 ( ptr + 6 ) ; ptr += 16 ; for ( c = 0 ; c < chunks ; c ++ ) { uint8 * data = ptr + 6 ; switch ( i16 ( ptr + 4 ) ) { case 4 : case 11 : break ; case 7 : lines = i16 ( data ) ; data += 2 ; for ( l = y = 0 ; l < lines && y < state -> ysize ; l ++ , y ++ ) { uint8 * buf = ( uint8 * ) im -> image [ y ] ; int p , packets ; packets = i16 ( data ) ; data += 2 ; while ( packets & 0x8000 ) { if ( packets & 0x4000 ) { y += 65536 - packets ; if ( y >= state -> ysize ) { state -> errcode = imaging_codec_overrun ; return - 1 ; } buf = ( uint8 * ) im -> image [ y ] ; } else { buf [ state -> xsize - 1 ] = ( uint8 ) packets ; } packets = i16 ( data ) ; data += 2 ; } for ( p = x = 0 ; p < packets ; p ++ ) { x += data [ 0 ] ; if ( data [ 1 ] >= 128 ) { i = 256 - data [ 1 ] ; if ( x + i + i > state -> xsize ) break ; for ( j = 0 ; j < i ; j ++ ) { buf [ x ++ ] = data [ 2 ] ; buf [ x ++ ] = data [ 3 ] ; } data += 2 + 2 ; } else { i = 2 * ( int ) data [ 1 ] ; if ( x + i > state -> xsize ) break ; memcpy ( buf + x , data + 2 , i ) ; data += 2 + i ; x += i ; } } if ( p < packets ) break ; } if ( l < lines ) { state -> errcode = imaging_codec_overrun ; return - 1 ; } break ; case 12 : y = i16 ( data ) ; ymax = y + i16 ( data + 2 ) ; data += 4 ; for ( ; y < ymax && y < state -> ysize ; y ++ ) { uint8 * out = ( uint8 * ) im -> image [ y ] ; int p , packets = * data ++ ; for ( p = x = 0 ; p < packets ; p ++ , x += i ) { x += data [ 0 ] ; if ( data [ 1 ] & 0x80 ) { i = 256 - data [ 1 ] ; if ( x + i > state -> xsize ) break ; memset ( out + x , data [ 2 ] , i ) ; data += 3 ; } else { i = data [ 1 ] ; if ( x + i > state -> xsize ) break ; memcpy ( out + x , data + 2 , i ) ; data += i + 2 ; } } if ( p < packets ) break ; } if ( y < ymax ) { state -> errcode = imaging_codec_overrun ; return - 1 ; } break ; case 13 : for ( y = 0 ; y < state -> ysize ; y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ; break ; case 15 : for ( y = 0 ; y < state -> ysize ; y ++ ) { uint8 * out = ( uint8 * ) im -> image [ y ] ; data += 1 ; for ( x = 0 ; x < state -> xsize ; x += i ) { if ( data [ 0 ] & 0x80 ) { i = 256 - data [ 0 ] ; if ( x + i > state -> xsize ) break ; memcpy ( out + x , data + 1 , i ) ; data += i + 1 ; } else { i = data [ 0 ] ; if ( x + i > state -> xsize ) break ; memset ( out + x , data [ 1 ] , i ) ; data += 2 ; } } if ( x != state -> xsize ) { state -> errcode = imaging_codec_overrun ; return - 1 ; } } break ; case 16 : for ( y = 0 ; y < state -> ysize ; y ++ ) { uint8 * buf = ( uint8 * ) im -> image [ y ] ; memcpy ( buf + x , data , state -> xsize ) ; data += state -> xsize ; } break ; case 18 : break ; default : state -> errcode = imaging_codec_unknown ; return - 1 ; } ptr += i32 ( ptr ) ; } return - 1 ; }","<S2SV_ModStart> memcpy ( buf <S2SV_ModEnd> , data ,
",python-pillow@Pillow/893a40850c2d5da41537958e40569c029a6e127b,CVE-2016-0775,https://github.com/python-pillow/Pillow/commit/893a40850c2d5da41537958e40569c029a6e127b,2016-04-13T16:59Z,"<S2SV_StartBug> memcpy ( buf + x , data , state -> xsize ) ; <S2SV_EndBug>"
6813,CWE-401,"static int rtl8xxxu_submit_int_urb ( struct ieee80211_hw * hw ) { struct rtl8xxxu_priv * priv = hw -> priv ; struct urb * urb ; u32 val32 ; int ret ; urb = usb_alloc_urb ( 0 , gfp_kernel ) ; if ( ! urb ) return - enomem ; usb_fill_int_urb ( urb , priv -> udev , priv -> pipe_interrupt , priv -> int_buf , usb_intr_content_length , rtl8xxxu_int_complete , priv , 1 ) ; usb_anchor_urb ( urb , & priv -> int_anchor ) ; ret = usb_submit_urb ( urb , gfp_kernel ) ; if ( ret ) { usb_unanchor_urb ( urb ) ; goto error ; } val32 = rtl8xxxu_read32 ( priv , reg_usb_himr ) ; val32 |= usb_himr_cpwm ; rtl8xxxu_write32 ( priv , reg_usb_himr , val32 ) ; error : return ret ; }","<S2SV_ModStart> urb ) ; usb_free_urb ( urb ) ;
",torvalds@linux/a2cdd07488e666aa93a49a3fc9c9b1299e27ef3c,CVE-2019-19068,https://github.com/torvalds/linux/commit/a2cdd07488e666aa93a49a3fc9c9b1299e27ef3c,2019-11-18T06:15Z,<S2SV_StartBug> goto error ; <S2SV_EndBug>
3201,CWE-200,"void iov_iter_pipe ( struct iov_iter * i , int direction , struct pipe_inode_info * pipe , size_t count ) { bug_on ( direction != iter_pipe ) ; i -> type = direction ; i -> pipe = pipe ; i -> idx = ( pipe -> curbuf + pipe -> nrbufs ) & ( pipe -> buffers - 1 ) ; i -> iov_offset = 0 ; i -> count = count ; }","<S2SV_ModStart> direction != ITER_PIPE ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers
",torvalds@linux/b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb,CVE-2017-5550,https://github.com/torvalds/linux/commit/b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb,2017-02-06T06:59Z,<S2SV_StartBug> BUG_ON ( direction != ITER_PIPE ) ; <S2SV_EndBug>
151,CWE-119,"int mlx4_register_mac ( struct mlx4_dev * dev , u8 port , u64 mac , int * index ) { struct mlx4_mac_table * table = & mlx4_priv ( dev ) -> port [ port ] . mac_table ; int i , err = 0 ; int free = - 1 ; mlx4_dbg ( dev , ""registering<s2sv_blank>mac:<s2sv_blank>0x%llx\\n"" , ( unsigned long long ) mac ) ; mutex_lock ( & table -> mutex ) ; for ( i = 0 ; i < mlx4_max_mac_num - 1 ; i ++ ) { if ( free < 0 && ! table -> refs [ i ] ) { free = i ; continue ; } if ( mac == ( mlx4_mac_mask & be64_to_cpu ( table -> entries [ i ] ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; } } mlx4_dbg ( dev , ""free<s2sv_blank>mac<s2sv_blank>index<s2sv_blank>is<s2sv_blank>%d\\n"" , free ) ; if ( table -> total == table -> max ) { err = - enospc ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be64 ( mac | mlx4_mac_valid ) ; err = mlx4_set_port_mac_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_err ( dev , ""failed<s2sv_blank>adding<s2sv_blank>mac:<s2sv_blank>0x%llx\\n"" , ( unsigned long long ) mac ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }","<S2SV_ModStart> ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ; }
",torvalds@linux/0926f91083f34d047abc74f1ca4fa6a9c161f7db,CVE-2010-5332,https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db,2019-07-27T22:15Z,"<S2SV_StartBug> mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n"" , free ) ; <S2SV_EndBug>"
8159,CWE-119,"static void update_read_synchronize ( rdpupdate * update , wstream * s ) { winpr_unused ( update ) ; stream_seek_uint16 ( s ) ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> update_read_synchronize ( rdpUpdate <S2SV_ModStart> update ) ; return Stream_SafeSeek ( s , 2 <S2SV_ModEnd> ) ; }
",FreeRDP@FreeRDP/ed53cd148f43cbab905eaa0f5308c2bf3c48cc37,CVE-2020-11046,https://github.com/FreeRDP/FreeRDP/commit/ed53cd148f43cbab905eaa0f5308c2bf3c48cc37,2020-05-07T19:15Z,"<S2SV_StartBug> static void update_read_synchronize ( rdpUpdate * update , wStream * s ) <S2SV_EndBug> <S2SV_StartBug> Stream_Seek_UINT16 ( s ) ; <S2SV_EndBug>"
7888,CWE-20,"void ftpserverprocesslist ( ftpclientconnection * connection , char_t * param ) { error_t error ; uint_t perm ; if ( ! connection -> userloggedin ) { osstrcpy ( connection -> response , ""530<s2sv_blank>not<s2sv_blank>logged<s2sv_blank>in\\r\\n"" ) ; return ; } while ( * param == '-' ) { while ( * param != '<s2sv_blank>' && * param != '\\0' ) param ++ ; while ( * param == '<s2sv_blank>' ) param ++ ; } if ( * param == '\\0' ) { osstrcpy ( connection -> path , connection -> currentdir ) ; } else { error = ftpservergetpath ( connection , param , connection -> path , ftp_server_max_path_len ) ; if ( error ) { osstrcpy ( connection -> response , ""501<s2sv_blank>invalid<s2sv_blank>parameter\\r\\n"" ) ; return ; } } perm = ftpservergetfilepermissions ( connection , connection -> path ) ; if ( ( perm & ftp_file_perm_read ) == 0 ) { osstrcpy ( connection -> response , ""550<s2sv_blank>access<s2sv_blank>denied\\r\\n"" ) ; return ; } connection -> dir = fsopendir ( connection -> path ) ; if ( ! connection -> dir ) { osstrcpy ( connection -> response , ""550<s2sv_blank>directory<s2sv_blank>not<s2sv_blank>found\\r\\n"" ) ; return ; } if ( connection -> passivemode ) { if ( connection -> datachannel . state == ftp_channel_state_idle ) connection -> datachannel . state = ftp_channel_state_send ; } else { error = ftpserveropendatachannel ( connection ) ; if ( error ) { fsclosedir ( connection -> dir ) ; osstrcpy ( connection -> response , ""450<s2sv_blank>can\'t<s2sv_blank>open<s2sv_blank>data<s2sv_blank>connection\\r\\n"" ) ; return ; } connection -> datachannel . state = ftp_channel_state_send ; } connection -> bufferlength = 0 ; connection -> bufferpos = 0 ; connection -> controlchannel . state = ftp_channel_state_list ; osstrcpy ( connection -> response , ""150<s2sv_blank>opening<s2sv_blank>data<s2sv_blank>connection\\r\\n"" ) ; }","<S2SV_ModStart> != '\\0' ) { <S2SV_ModStart> param ++ ; } <S2SV_ModStart> == '<S2SV_blank>' ) { <S2SV_ModStart> param ++ ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> param ++ ; <S2SV_EndBug> <S2SV_StartBug> while ( * param == '<S2SV_blank>' ) <S2SV_EndBug> <S2SV_StartBug> param ++ ; <S2SV_EndBug>
5306,CWE-125,"static void exif_mnote_data_fuji_load ( exifmnotedata * en , const unsigned char * buf , unsigned int buf_size ) { exifmnotedatafuji * n = ( exifmnotedatafuji * ) en ; exiflong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , exif_log_code_corrupt_data , ""exifmnotedatafuji"" , ""short<s2sv_blank>makernote"" ) ; return ; } datao = 6 + n -> offset ; if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) { exif_log ( en -> log , exif_log_code_corrupt_data , ""exifmnotedatafuji"" , ""short<s2sv_blank>makernote"" ) ; return ; } n -> order = exif_byte_order_intel ; datao += exif_get_long ( buf + datao + 8 , exif_byte_order_intel ) ; if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || ( datao + 2 > buf_size ) ) { exif_log ( en -> log , exif_log_code_corrupt_data , ""exifmnotedatafuji"" , ""short<s2sv_blank>makernote"" ) ; return ; } c = exif_get_short ( buf + datao , exif_byte_order_intel ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( mnotefujientry ) * c ) ; if ( ! n -> entries ) { exif_log_no_memory ( en -> log , ""exifmnotedatafuji"" , sizeof ( mnotefujientry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { exif_log ( en -> log , exif_log_code_corrupt_data , ""exifmnotedatafuji"" , ""short<s2sv_blank>makernote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , exif_log_code_debug , ""exifmnotedatafuji"" , ""loading<s2sv_blank>entry<s2sv_blank>0x%x<s2sv_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ; if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || ( dataofs + s >= buf_size ) ) { exif_log ( en -> log , exif_log_code_corrupt_data , ""exifmnotedatafuji"" , ""tag<s2sv_blank>data<s2sv_blank>past<s2sv_blank>end<s2sv_blank>of<s2sv_blank>"" ""buffer<s2sv_blank>(%u<s2sv_blank>>=<s2sv_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { exif_log_no_memory ( en -> log , ""exifmnotedatafuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }","<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 12 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> , s )
",libexif@libexif/435e21f05001fb03f9f186fa7cbc69454afd00d1,CVE-2020-13112,https://github.com/libexif/libexif/commit/435e21f05001fb03f9f186fa7cbc69454afd00d1,2020-05-21T16:15Z,"<S2SV_StartBug> if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug>"
1131,CWE-20,"static int ssl_scan_clienthello_tlsext ( ssl * s , packet * pkt , int * al ) { unsigned int type ; int renegotiate_seen = 0 ; packet extensions ; * al = ssl_ad_decode_error ; s -> servername_done = 0 ; s -> tlsext_status_type = - 1 ; # ifndef openssl_no_nextprotoneg s -> s3 -> next_proto_neg_seen = 0 ; # endif openssl_free ( s -> s3 -> alpn_selected ) ; s -> s3 -> alpn_selected = null ; s -> s3 -> alpn_selected_len = 0 ; openssl_free ( s -> s3 -> alpn_proposed ) ; s -> s3 -> alpn_proposed = null ; s -> s3 -> alpn_proposed_len = 0 ; # ifndef openssl_no_heartbeats s -> tlsext_heartbeat &= ~ ( ssl_dtlsext_hb_enabled | ssl_dtlsext_hb_dont_send_requests ) ; # endif # ifndef openssl_no_ec if ( s -> options & ssl_op_safari_ecdhe_ecdsa_bug ) ssl_check_for_safari ( s , pkt ) ; # endif openssl_free ( s -> s3 -> tmp . peer_sigalgs ) ; s -> s3 -> tmp . peer_sigalgs = null ; s -> s3 -> flags &= ~ tls1_flags_encrypt_then_mac ; # ifndef openssl_no_srp openssl_free ( s -> srp_ctx . login ) ; s -> srp_ctx . login = null ; # endif s -> srtp_profile = null ; if ( packet_remaining ( pkt ) == 0 ) goto ri_check ; if ( ! packet_as_length_prefixed_2 ( pkt , & extensions ) ) return 0 ; if ( ! tls1_check_duplicate_extensions ( & extensions ) ) return 0 ; while ( packet_get_net_2 ( & extensions , & type ) ) { packet extension ; if ( ! packet_get_length_prefixed_2 ( & extensions , & extension ) ) return 0 ; if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 0 , type , packet_data ( & extension ) , packet_remaining ( & extension ) , s -> tlsext_debug_arg ) ; if ( type == tlsext_type_renegotiate ) { if ( ! ssl_parse_clienthello_renegotiate_ext ( s , & extension , al ) ) return 0 ; renegotiate_seen = 1 ; } else if ( s -> version == ssl3_version ) { } else if ( type == tlsext_type_server_name ) { unsigned int servname_type ; packet sni , hostname ; if ( ! packet_as_length_prefixed_2 ( & extension , & sni ) || packet_remaining ( & sni ) == 0 ) { return 0 ; } if ( ! packet_get_1 ( & sni , & servname_type ) || servname_type != tlsext_nametype_host_name || ! packet_as_length_prefixed_2 ( & sni , & hostname ) ) { return 0 ; } if ( ! s -> hit ) { if ( packet_remaining ( & hostname ) > tlsext_maxlen_host_name ) { * al = tls1_ad_unrecognized_name ; return 0 ; } if ( packet_contains_zero_byte ( & hostname ) ) { * al = tls1_ad_unrecognized_name ; return 0 ; } if ( ! packet_strndup ( & hostname , & s -> session -> tlsext_hostname ) ) { * al = tls1_ad_internal_error ; return 0 ; } s -> servername_done = 1 ; } else { s -> servername_done = s -> session -> tlsext_hostname && packet_equal ( & hostname , s -> session -> tlsext_hostname , strlen ( s -> session -> tlsext_hostname ) ) ; } } # ifndef openssl_no_srp else if ( type == tlsext_type_srp ) { packet srp_i ; if ( ! packet_as_length_prefixed_1 ( & extension , & srp_i ) ) return 0 ; if ( packet_contains_zero_byte ( & srp_i ) ) return 0 ; if ( ! packet_strndup ( & srp_i , & s -> srp_ctx . login ) ) { * al = tls1_ad_internal_error ; return 0 ; } } # endif # ifndef openssl_no_ec else if ( type == tlsext_type_ec_point_formats ) { packet ec_point_format_list ; if ( ! packet_as_length_prefixed_1 ( & extension , & ec_point_format_list ) || packet_remaining ( & ec_point_format_list ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! packet_memdup ( & ec_point_format_list , & s -> session -> tlsext_ecpointformatlist , & s -> session -> tlsext_ecpointformatlist_length ) ) { * al = tls1_ad_internal_error ; return 0 ; } } } else if ( type == tlsext_type_elliptic_curves ) { packet elliptic_curve_list ; if ( ! packet_as_length_prefixed_2 ( & extension , & elliptic_curve_list ) || packet_remaining ( & elliptic_curve_list ) == 0 || ( packet_remaining ( & elliptic_curve_list ) % 2 ) != 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! packet_memdup ( & elliptic_curve_list , & s -> session -> tlsext_ellipticcurvelist , & s -> session -> tlsext_ellipticcurvelist_length ) ) { * al = tls1_ad_internal_error ; return 0 ; } } } # endif else if ( type == tlsext_type_session_ticket ) { if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , packet_data ( & extension ) , packet_remaining ( & extension ) , s -> tls_session_ticket_ext_cb_arg ) ) { * al = tls1_ad_internal_error ; return 0 ; } } else if ( type == tlsext_type_signature_algorithms ) { packet supported_sig_algs ; if ( ! packet_as_length_prefixed_2 ( & extension , & supported_sig_algs ) || ( packet_remaining ( & supported_sig_algs ) % 2 ) != 0 || packet_remaining ( & supported_sig_algs ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! tls1_save_sigalgs ( s , packet_data ( & supported_sig_algs ) , packet_remaining ( & supported_sig_algs ) ) ) { return 0 ; } } } else if ( type == tlsext_type_status_request ) { if ( ! packet_get_1 ( & extension , ( unsigned int * ) & s -> tlsext_status_type ) ) { return 0 ; } # ifndef openssl_no_ocsp if ( s -> tlsext_status_type == tlsext_statustype_ocsp ) { const unsigned char * ext_data ; packet responder_id_list , exts ; if ( ! packet_get_length_prefixed_2 ( & extension , & responder_id_list ) ) return 0 ; sk_ocsp_respid_pop_free ( s -> tlsext_ocsp_ids , ocsp_respid_free ) ; if ( packet_remaining ( & responder_id_list ) > 0 ) { s -> tlsext_ocsp_ids = sk_ocsp_respid_new_null ( ) ; if ( s -> tlsext_ocsp_ids == null ) { * al = ssl_ad_internal_error ; return 0 ; } } else { s -> tlsext_ocsp_ids = null ; } while ( packet_remaining ( & responder_id_list ) > 0 ) { ocsp_respid * id ; packet responder_id ; const unsigned char * id_data ; if ( ! packet_get_length_prefixed_2 ( & responder_id_list , & responder_id ) || packet_remaining ( & responder_id ) == 0 ) { return 0 ; } id_data = packet_data ( & responder_id ) ; id = d2i_ocsp_respid ( null , & id_data , packet_remaining ( & responder_id ) ) ; if ( id == null ) return 0 ; if ( id_data != packet_end ( & responder_id ) ) { ocsp_respid_free ( id ) ; return 0 ; } if ( ! sk_ocsp_respid_push ( s -> tlsext_ocsp_ids , id ) ) { ocsp_respid_free ( id ) ; * al = ssl_ad_internal_error ; return 0 ; } } if ( ! packet_as_length_prefixed_2 ( & extension , & exts ) ) return 0 ; if ( packet_remaining ( & exts ) > 0 ) { ext_data = packet_data ( & exts ) ; sk_x509_extension_pop_free ( s -> tlsext_ocsp_exts , x509_extension_free ) ; s -> tlsext_ocsp_exts = d2i_x509_extensions ( null , & ext_data , packet_remaining ( & exts ) ) ; if ( s -> tlsext_ocsp_exts == null || ext_data != packet_end ( & exts ) ) { return 0 ; } } } else # endif { s -> tlsext_status_type = - 1 ; } } # ifndef openssl_no_heartbeats else if ( ssl_is_dtls ( s ) && type == tlsext_type_heartbeat ) { unsigned int hbtype ; if ( ! packet_get_1 ( & extension , & hbtype ) || packet_remaining ( & extension ) ) { * al = ssl_ad_decode_error ; return 0 ; } switch ( hbtype ) { case 0x01 : s -> tlsext_heartbeat |= ssl_dtlsext_hb_enabled ; break ; case 0x02 : s -> tlsext_heartbeat |= ssl_dtlsext_hb_enabled ; s -> tlsext_heartbeat |= ssl_dtlsext_hb_dont_send_requests ; break ; default : * al = ssl_ad_illegal_parameter ; return 0 ; } } # endif # ifndef openssl_no_nextprotoneg else if ( type == tlsext_type_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) { s -> s3 -> next_proto_neg_seen = 1 ; } # endif else if ( type == tlsext_type_application_layer_protocol_negotiation && s -> s3 -> tmp . finish_md_len == 0 ) { if ( ! tls1_alpn_handle_client_hello ( s , & extension , al ) ) return 0 ; } # ifndef openssl_no_srtp else if ( ssl_is_dtls ( s ) && ssl_get_srtp_profiles ( s ) && type == tlsext_type_use_srtp ) { if ( ssl_parse_clienthello_use_srtp_ext ( s , & extension , al ) ) return 0 ; } # endif else if ( type == tlsext_type_encrypt_then_mac ) s -> s3 -> flags |= tls1_flags_encrypt_then_mac ; else if ( ! s -> hit ) { if ( custom_ext_parse ( s , 1 , type , packet_data ( & extension ) , packet_remaining ( & extension ) , al ) <= 0 ) return 0 ; } } if ( packet_remaining ( pkt ) != 0 ) { * al = ssl_ad_internal_error ; return 0 ; } ri_check : if ( ! renegotiate_seen && s -> renegotiate && ! ( s -> options & ssl_op_allow_unsafe_legacy_renegotiation ) ) { * al = ssl_ad_handshake_failure ; sslerr ( ssl_f_ssl_scan_clienthello_tlsext , ssl_r_unsafe_legacy_renegotiation_disabled ) ; return 0 ; } return 1 ; }","<S2SV_ModStart> ; s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; # ifndef <S2SV_ModStart> ) s -> tlsext_use_etm = 1 <S2SV_ModEnd> ; else if
",openssl@openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,CVE-2017-3733,https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,2017-05-04T19:29Z,<S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug>
6555,CWE-119,"static char * print_number ( cjson * item ) { char * str ; double f , f2 ; int64_t i ; str = ( char * ) cjson_malloc ( 64 ) ; if ( str ) { f = item -> valuefloat ; i = f ; f2 = i ; if ( f2 == f && item -> valueint >= llong_min && item -> valueint <= llong_max ) sprintf ( str , ""%lld"" , ( long long ) item -> valueint ) ; else sprintf ( str , ""%g"" , item -> valuefloat ) ; } return str ; }","<S2SV_ModStart> cJSON * item , printbuffer * p ) { char * str = 0 ; double d <S2SV_ModEnd> = item -> <S2SV_ModStart> = item -> valuedouble ; if ( d == 0 ) { if ( p ) str = ensure ( p , 2 ) ; else str = ( char * ) cJSON_malloc ( 2 ) ; if ( str ) strcpy ( str , ""0"" ) ; } else if ( fabs ( ( ( double ) <S2SV_ModEnd> item -> valueint <S2SV_ModStart> item -> valueint ) - d ) <= DBL_EPSILON && d <= LLONG_MAX && d >= LLONG_MIN ) { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) sprintf ( str , ""%lld"" , ( long long ) <S2SV_ModEnd> item -> valueint <S2SV_ModStart> item -> valueint ) ; } else { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) { if ( fpclassify ( d ) != FP_ZERO && ! isnormal ( d ) ) sprintf ( str , ""null"" ) ; else if ( fabs ( floor ( d ) - d ) <= DBL_EPSILON && fabs ( d ) < 1.0e60 ) sprintf ( str , ""%.0f"" , d ) ; else if ( fabs ( d ) < 1.0e-6 || fabs ( d ) > 1.0e9 ) sprintf ( str , ""%e"" , d ) ; else sprintf ( str , ""%f"" , d ) ; } <S2SV_ModEnd> } return str
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,<S2SV_StartBug> static char * print_number ( cJSON * item ) <S2SV_EndBug> <S2SV_StartBug> f = item -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint <= LLONG_MAX ) <S2SV_EndBug>
2290,CWE-362,"void sock_release ( struct socket * sock ) { if ( sock -> ops ) { struct module * owner = sock -> ops -> owner ; sock -> ops -> release ( sock ) ; sock -> ops = null ; module_put ( owner ) ; } if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) pr_err ( ""%s:<s2sv_blank>fasync<s2sv_blank>list<s2sv_blank>not<s2sv_blank>empty!\\n"" , __func__ ) ; if ( ! sock -> file ) { iput ( sock_inode ( sock ) ) ; return ; } sock -> file = null ; }","<S2SV_ModStart> sock ) { __sock_release ( sock , NULL <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/6d8c50dcb029872b298eea68cc6209c866fd3e14,CVE-2018-12232,https://github.com/torvalds/linux/commit/6d8c50dcb029872b298eea68cc6209c866fd3e14,2018-06-12T12:29Z,"<S2SV_StartBug> if ( sock -> ops ) { <S2SV_EndBug> <S2SV_StartBug> if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) <S2SV_EndBug>"
7365,CWE-352,"static boolean_t is_authenticated ( httprequest req , httpresponse res ) { if ( run . httpd . credentials ) { if ( ! basic_authenticate ( req ) ) { send_error ( req , res , sc_unauthorized , ""you<s2sv_blank>are<s2sv_blank>not<s2sv_blank>authorized<s2sv_blank>to<s2sv_blank>access<s2sv_blank>monit.<s2sv_blank>either<s2sv_blank>you<s2sv_blank>supplied<s2sv_blank>the<s2sv_blank>wrong<s2sv_blank>credentials<s2sv_blank>(e.g.<s2sv_blank>bad<s2sv_blank>password),<s2sv_blank>or<s2sv_blank>your<s2sv_blank>browser<s2sv_blank>doesn\'t<s2sv_blank>understand<s2sv_blank>how<s2sv_blank>to<s2sv_blank>supply<s2sv_blank>the<s2sv_blank>credentials<s2sv_blank>required"" ) ; set_header ( res , ""www-authenticate"" , ""basic<s2sv_blank>realm=\\""monit\\"""" ) ; return false ; } } return true ; }","<S2SV_ModStart> ; } } if ( IS ( req -> method , METHOD_POST ) ) { const char * cookie = get_header ( req , ""Cookie"" ) ; const char * token = get_parameter ( req , ""securitytoken"" ) ; if ( ! cookie ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>cookie\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( ! token ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>parameter\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( ! Str_startsWith ( cookie , ""securitytoken="" ) ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>no<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>cookie\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( Str_compareConstantTime ( cookie + 14 , token ) ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>mismatch\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } }
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,<S2SV_StartBug> return true ; <S2SV_EndBug>
909,CWE-399,"struct scm_fp_list * scm_fp_dup ( struct scm_fp_list * fpl ) { struct scm_fp_list * new_fpl ; int i ; if ( ! fpl ) return null ; new_fpl = kmemdup ( fpl , offsetof ( struct scm_fp_list , fp [ fpl -> count ] ) , gfp_kernel ) ; if ( new_fpl ) { for ( i = 0 ; i < fpl -> count ; i ++ ) get_file ( fpl -> fp [ i ] ) ; new_fpl -> max = new_fpl -> count ; } return new_fpl ; }","<S2SV_ModStart> -> count ; new_fpl -> user = get_uid ( fpl -> user ) ;
",torvalds@linux/415e3d3e90ce9e18727e8843ae343eda5a58fad6,CVE-2016-2550,https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6,2016-04-27T17:59Z,<S2SV_StartBug> } <S2SV_EndBug>
1162,CWE-862,"static struct key * construct_key_and_link ( struct keyring_search_context * ctx , const char * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct key_user * user ; struct key * key ; int ret ; kenter ( """" ) ; if ( ctx -> index_key . type == & key_type_keyring ) return err_ptr ( - eperm ) ; user = key_user_lookup ( current_fsuid ( ) ) ; if ( ! user ) return err_ptr ( - enomem ) ; construct_get_dest_keyring ( & dest_keyring ) ; ret = construct_alloc_key ( ctx , dest_keyring , flags , user , & key ) ; key_user_put ( user ) ; if ( ret == 0 ) { ret = construct_key ( key , callout_info , callout_len , aux , dest_keyring ) ; if ( ret < 0 ) { kdebug ( ""cons<s2sv_blank>failed"" ) ; goto construction_failed ; } } else if ( ret == - einprogress ) { ret = 0 ; } else { goto couldnt_alloc_key ; } key_put ( dest_keyring ) ; kleave ( ""<s2sv_blank>=<s2sv_blank>key<s2sv_blank>%d"" , key_serial ( key ) ) ; return key ; construction_failed : key_negate_and_link ( key , key_negative_timeout , null , null ) ; key_put ( key ) ; couldnt_alloc_key : key_put ( dest_keyring ) ; kleave ( ""<s2sv_blank>=<s2sv_blank>%d"" , ret ) ; return err_ptr ( ret ) ; }","<S2SV_ModStart> EPERM ) ; ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> ! user ) { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> ret = construct_alloc_key <S2SV_ModStart> else { goto error_put_dest_keyring <S2SV_ModEnd> ; } key_put <S2SV_ModStart> key ) ; error_put_dest_keyring <S2SV_ModEnd> : key_put ( <S2SV_ModStart> dest_keyring ) ; error :
",torvalds@linux/4dca6ea1d9432052afb06baf2e3ae78188a4410b,CVE-2017-17807,https://github.com/torvalds/linux/commit/4dca6ea1d9432052afb06baf2e3ae78188a4410b,2017-12-20T23:29Z,<S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ERR_PTR ( - ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> goto couldnt_alloc_key ; <S2SV_EndBug> <S2SV_StartBug> couldnt_alloc_key : <S2SV_EndBug> <S2SV_StartBug> key_put ( dest_keyring ) ; <S2SV_EndBug>
4855,CWE-22,"static int target_xcopy_locate_se_dev_e4_iter ( struct se_device * se_dev , void * data ) { struct xcopy_dev_search_info * info = data ; unsigned char tmp_dev_wwn [ xcopy_naa_ieee_regex_len ] ; int rc ; if ( ! se_dev -> dev_attrib . emulate_3pc ) return 0 ; memset ( & tmp_dev_wwn [ 0 ] , 0 , xcopy_naa_ieee_regex_len ) ; target_xcopy_gen_naa_ieee ( se_dev , & tmp_dev_wwn [ 0 ] ) ; rc = memcmp ( & tmp_dev_wwn [ 0 ] , info -> dev_wwn , xcopy_naa_ieee_regex_len ) ; if ( rc != 0 ) return 0 ; info -> found_dev = se_dev ; pr_debug ( ""xcopy<s2sv_blank>0xe4:<s2sv_blank>located<s2sv_blank>se_dev:<s2sv_blank>%p\\n"" , se_dev ) ; rc = target_depend_item ( & se_dev -> dev_group . cg_item ) ; if ( rc != 0 ) { pr_err ( ""configfs_depend_item<s2sv_blank>attempt<s2sv_blank>failed:<s2sv_blank>%d<s2sv_blank>for<s2sv_blank>se_dev:<s2sv_blank>%p\\n"" , rc , se_dev ) ; return rc ; } pr_debug ( ""called<s2sv_blank>configfs_depend_item<s2sv_blank>for<s2sv_blank>se_dev:<s2sv_blank>%p<s2sv_blank>se_dev->se_dev_group:<s2sv_blank>%p\\n"" , se_dev , & se_dev -> dev_group ) ; return 1 ; }","<S2SV_ModStart> * se_dev , const unsigned char * dev_wwn ) { <S2SV_ModEnd> unsigned char tmp_dev_wwn <S2SV_ModStart> . emulate_3pc ) { pr_debug ( ""XCOPY:<S2SV_blank>emulate_3pc<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>se_dev<S2SV_blank>%p\\n"" , se_dev ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> 0 ] , <S2SV_ModEnd> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN <S2SV_ModStart> != 0 ) { pr_debug ( ""XCOPY:<S2SV_blank>skip<S2SV_blank>non-matching:<S2SV_blank>%*ph\\n"" , XCOPY_NAA_IEEE_REGEX_LEN , tmp_dev_wwn ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModEnd> pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" <S2SV_ModStart> se_dev ) ; <S2SV_ModEnd> return 1 ;
",torvalds@linux/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,CVE-2020-28374,https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,2021-01-13T04:15Z,"<S2SV_StartBug> void * data ) <S2SV_EndBug> <S2SV_StartBug> if ( ! se_dev -> dev_attrib . emulate_3pc ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> rc = memcmp ( & tmp_dev_wwn [ 0 ] , info -> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc != 0 ) <S2SV_EndBug> <S2SV_StartBug> info -> found_dev = se_dev ; <S2SV_EndBug> <S2SV_StartBug> rc = target_depend_item ( & se_dev -> dev_group . cg_item ) ; <S2SV_EndBug>"
2376,CWE-119,"int au1100fb_fb_mmap ( struct fb_info * fbi , struct vm_area_struct * vma ) { struct au1100fb_device * fbdev ; unsigned int len ; unsigned long start = 0 , off ; fbdev = to_au1100fb_device ( fbi ) ; if ( vma -> vm_pgoff > ( ~ 0ul >> page_shift ) ) { return - einval ; } start = fbdev -> fb_phys & page_mask ; len = page_align ( ( start & ~ page_mask ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << page_shift ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - einval ; } off += start ; vma -> vm_pgoff = off >> page_shift ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= ( 6 << 9 ) ; if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> page_shift , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) { return - eagain ; } return 0 ; }","<S2SV_ModStart> * fbdev ; <S2SV_ModEnd> fbdev = to_au1100fb_device <S2SV_ModStart> ( fbi ) <S2SV_ModEnd> ; vma -> <S2SV_ModStart> 9 ) ; return vm_iomap_memory <S2SV_ModEnd> ( vma , <S2SV_ModStart> ( vma , fbdev -> fb_phys , fbdev -> fb_len ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/7314e613d5ff9f0934f7a0f74ed7973b903315d1,CVE-2013-6763,https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1,2013-11-12T14:35Z,"<S2SV_StartBug> unsigned int len ; <S2SV_EndBug> <S2SV_StartBug> fbdev = to_au1100fb_device ( fbi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug>"
3293,CWE-476,"struct key * key_get_instantiation_authkey ( key_serial_t target_id ) { char description [ 16 ] ; struct keyring_search_context ctx = { . index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = user_match , . match_data . raw_data = description , . match_data . lookup_type = keyring_search_lookup_direct , } ; struct key * authkey ; key_ref_t authkey_ref ; sprintf ( description , ""%x"" , target_id ) ; authkey_ref = search_process_keyrings ( & ctx ) ; if ( is_err ( authkey_ref ) ) { authkey = err_cast ( authkey_ref ) ; if ( authkey == err_ptr ( - eagain ) ) authkey = err_ptr ( - enokey ) ; goto error ; } authkey = key_ref_to_ptr ( authkey_ref ) ; if ( test_bit ( key_flag_revoked , & authkey -> flags ) ) { key_put ( authkey ) ; authkey = err_ptr ( - ekeyrevoked ) ; } error : return authkey ; }","<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
",torvalds@linux/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,CVE-2017-2647,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,2017-03-31T04:59Z,"<S2SV_StartBug> . match_data . cmp = user_match , <S2SV_EndBug>"
2721,CWE-362,"static int raw_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct net * net = sock_net ( sk ) ; struct ipcm_cookie ipc ; struct rtable * rt = null ; struct flowi4 fl4 ; int free = 0 ; __be32 daddr ; __be32 saddr ; u8 tos ; int err ; struct ip_options_data opt_copy ; struct raw_frag_vec rfv ; err = - emsgsize ; if ( len > 0xffff ) goto out ; err = - eopnotsupp ; if ( msg -> msg_flags & msg_oob ) goto out ; if ( msg -> msg_namelen ) { declare_sockaddr ( struct sockaddr_in * , usin , msg -> msg_name ) ; err = - einval ; if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ; if ( usin -> sin_family != af_inet ) { pr_info_once ( ""%s:<s2sv_blank>%s<s2sv_blank>forgot<s2sv_blank>to<s2sv_blank>set<s2sv_blank>af_inet.<s2sv_blank>fix<s2sv_blank>it!\\n"" , __func__ , current -> comm ) ; err = - eafnosupport ; if ( usin -> sin_family ) goto out ; } daddr = usin -> sin_addr . s_addr ; } else { err = - edestaddrreq ; if ( sk -> sk_state != tcp_established ) goto out ; daddr = inet -> inet_daddr ; } ipc . sockc . tsflags = sk -> sk_tsflags ; ipc . addr = inet -> inet_saddr ; ipc . opt = null ; ipc . tx_flags = 0 ; ipc . ttl = 0 ; ipc . tos = - 1 ; ipc . oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sk , msg , & ipc , false ) ; if ( unlikely ( err ) ) { kfree ( ipc . opt ) ; goto out ; } if ( ipc . opt ) free = 1 ; } saddr = ipc . addr ; ipc . addr = daddr ; if ( ! ipc . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } if ( ipc . opt ) { err = - einval ; if ( inet -> hdrincl ) goto done ; if ( ipc . opt -> opt . srr ) { if ( ! daddr ) goto done ; daddr = ipc . opt -> opt . faddr ; } } tos = get_rtconn_flags ( & ipc , sk ) ; if ( msg -> msg_flags & msg_dontroute ) tos |= rto_onlink ; if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; } else if ( ! ipc . oif ) ipc . oif = inet -> uc_index ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , rt_scope_universe , inet -> hdrincl ? ipproto_raw : sk -> sk_protocol , inet_sk_flowi_flags ( sk ) | ( inet -> hdrincl ? flowi_flag_known_nh : 0 ) , daddr , saddr , 0 , 0 , sk -> sk_uid ) ; if ( ! inet -> hdrincl ) { rfv . msg = msg ; rfv . hlen = 0 ; err = raw_probe_proto_opt ( & rfv , & fl4 ) ; if ( err ) goto done ; } security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( is_err ( rt ) ) { err = ptr_err ( rt ) ; rt = null ; goto done ; } err = - eacces ; if ( rt -> rt_flags & rtcf_broadcast && ! sock_flag ( sk , sock_broadcast ) ) goto done ; if ( msg -> msg_flags & msg_confirm ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ; else { sock_tx_timestamp ( sk , ipc . sockc . tsflags , & ipc . tx_flags ) ; if ( ! ipc . addr ) ipc . addr = fl4 . daddr ; lock_sock ( sk ) ; err = ip_append_data ( sk , & fl4 , raw_getfrag , & rfv , len , 0 , & ipc , & rt , msg -> msg_flags ) ; if ( err ) ip_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & msg_more ) ) { err = ip_push_pending_frames ( sk , & fl4 ) ; if ( err == - enobufs && ! inet -> recverr ) err = 0 ; } release_sock ( sk ) ; } done : if ( free ) kfree ( ipc . opt ) ; ip_rt_put ( rt ) ; out : if ( err < 0 ) return err ; return len ; do_confirm : if ( msg -> msg_flags & msg_probe ) dst_confirm_neigh ( & rt -> dst , & fl4 . daddr ) ; if ( ! ( msg -> msg_flags & msg_probe ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }","<S2SV_ModStart> raw_frag_vec rfv ; int hdrincl ; <S2SV_ModStart> ) goto out ; hdrincl = inet -> hdrincl <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdrincl ) goto <S2SV_ModStart> , RT_SCOPE_UNIVERSE , <S2SV_ModEnd> hdrincl ? IPPROTO_RAW <S2SV_ModStart> ) | ( <S2SV_ModEnd> hdrincl ? FLOWI_FLAG_KNOWN_NH <S2SV_ModStart> if ( ! <S2SV_ModEnd> hdrincl ) { <S2SV_ModStart> : if ( <S2SV_ModEnd> hdrincl ) err
",torvalds@linux/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483,CVE-2017-17712,https://github.com/torvalds/linux/commit/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483,2017-12-16T01:29Z,"<S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> <S2SV_StartBug> inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , <S2SV_EndBug> <S2SV_StartBug> ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , <S2SV_EndBug> <S2SV_StartBug> if ( ! inet -> hdrincl ) { <S2SV_EndBug> <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug>"
4613,CWE-787,"static int cbs_jpeg_split_fragment ( codedbitstreamcontext * ctx , codedbitstreamfragment * frag , int header ) { avbufferref * data_ref ; uint8_t * data ; size_t data_size ; int unit , start , end , marker , next_start , next_marker ; int err , i , j , length ; if ( frag -> data_size < 4 ) { return averror_invaliddata ; } for ( i = 0 ; i + 1 < frag -> data_size && frag -> data [ i ] != 0xff ; i ++ ) ; if ( i > 0 ) { av_log ( ctx -> log_ctx , av_log_warning , ""discarding<s2sv_blank>%d<s2sv_blank>bytes<s2sv_blank>at<s2sv_blank>"" ""beginning<s2sv_blank>of<s2sv_blank>image.\\n"" , i ) ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size && frag -> data [ i ] ) { av_log ( ctx -> log_ctx , av_log_error , ""invalid<s2sv_blank>jpeg<s2sv_blank>image:<s2sv_blank>"" ""no<s2sv_blank>soi<s2sv_blank>marker<s2sv_blank>found.\\n"" ) ; return averror_invaliddata ; } marker = frag -> data [ i ] ; if ( marker != jpeg_marker_soi ) { av_log ( ctx -> log_ctx , av_log_error , ""invalid<s2sv_blank>jpeg<s2sv_blank>image:<s2sv_blank>first<s2sv_blank>"" ""marker<s2sv_blank>is<s2sv_blank>%02x,<s2sv_blank>should<s2sv_blank>be<s2sv_blank>soi.\\n"" , marker ) ; return averror_invaliddata ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx , av_log_error , ""invalid<s2sv_blank>jpeg<s2sv_blank>image:<s2sv_blank>"" ""no<s2sv_blank>image<s2sv_blank>content<s2sv_blank>found.\\n"" ) ; return averror_invaliddata ; } marker = frag -> data [ i ] ; start = i + 1 ; for ( unit = 0 ; ; unit ++ ) { if ( marker == jpeg_marker_eoi ) { break ; } else if ( marker == jpeg_marker_sos ) { for ( i = start ; i + 1 < frag -> data_size ; i ++ ) { if ( frag -> data [ i ] != 0xff ) continue ; end = i ; for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { if ( frag -> data [ i ] == 0x00 ) continue ; next_marker = frag -> data [ i ] ; next_start = i + 1 ; } break ; } } else { i = start ; if ( i + 2 > frag -> data_size ) { av_log ( ctx -> log_ctx , av_log_error , ""invalid<s2sv_blank>jpeg<s2sv_blank>image:<s2sv_blank>"" ""truncated<s2sv_blank>at<s2sv_blank>%02x<s2sv_blank>marker.\\n"" , marker ) ; return averror_invaliddata ; } length = av_rb16 ( frag -> data + i ) ; if ( i + length > frag -> data_size ) { av_log ( ctx -> log_ctx , av_log_error , ""invalid<s2sv_blank>jpeg<s2sv_blank>image:<s2sv_blank>"" ""truncated<s2sv_blank>at<s2sv_blank>%02x<s2sv_blank>marker<s2sv_blank>segment.\\n"" , marker ) ; return averror_invaliddata ; } end = start + length ; i = end ; if ( frag -> data [ i ] != 0xff ) { next_marker = - 1 ; } else { for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { next_marker = frag -> data [ i ] ; next_start = i + 1 ; } } } if ( marker == jpeg_marker_sos ) { length = av_rb16 ( frag -> data + start ) ; data_ref = null ; data = av_malloc ( end - start + av_input_buffer_padding_size ) ; if ( ! data ) return averror ( enomem ) ; memcpy ( data , frag -> data + start , length ) ; for ( i = start + length , j = length ; i < end ; i ++ , j ++ ) { if ( frag -> data [ i ] == 0xff ) { while ( frag -> data [ i ] == 0xff ) ++ i ; data [ j ] = 0xff ; } else { data [ j ] = frag -> data [ i ] ; } } data_size = j ; memset ( data + data_size , 0 , av_input_buffer_padding_size ) ; } else { data = frag -> data + start ; data_size = end - start ; data_ref = frag -> data_ref ; } err = ff_cbs_insert_unit_data ( ctx , frag , unit , marker , data , data_size , data_ref ) ; if ( err < 0 ) return err ; if ( next_marker == - 1 ) break ; marker = next_marker ; start = next_start ; } return 0 ; }","<S2SV_ModStart> start ) ; if ( length > end - start ) return AVERROR_INVALIDDATA ;
",FFmpeg@FFmpeg/1812352d767ccf5431aa440123e2e260a4db2726,CVE-2020-12284,https://github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726,2020-04-28T06:15Z,<S2SV_StartBug> data_ref = NULL ; <S2SV_EndBug>
3958,CWE-000,"static struct file * path_openat ( int dfd , struct filename * pathname , struct nameidata * nd , const struct open_flags * op , int flags ) { struct file * file ; struct path path ; int opened = 0 ; int error ; file = get_empty_filp ( ) ; if ( is_err ( file ) ) return file ; file -> f_flags = op -> open_flag ; if ( unlikely ( file -> f_flags & __o_tmpfile ) ) { error = do_tmpfile ( dfd , pathname , nd , flags , op , file , & opened ) ; goto out ; } error = path_init ( dfd , pathname , flags , nd ) ; if ( unlikely ( error ) ) goto out ; error = do_last ( nd , & path , file , op , & opened , pathname ) ; while ( unlikely ( error > 0 ) ) { struct path link = path ; void * cookie ; if ( ! ( nd -> flags & lookup_follow ) ) { path_put_conditional ( & path , nd ) ; path_put ( & nd -> path ) ; error = - eloop ; break ; } error = may_follow_link ( & link , nd ) ; if ( unlikely ( error ) ) break ; nd -> flags |= lookup_parent ; nd -> flags &= ~ ( lookup_open | lookup_create | lookup_excl ) ; error = follow_link ( & link , nd , & cookie ) ; if ( unlikely ( error ) ) break ; error = do_last ( nd , & path , file , op , & opened , pathname ) ; put_link ( nd , & link , cookie ) ; } out : path_cleanup ( nd ) ; if ( ! ( opened & file_opened ) ) { bug_on ( ! error ) ; put_filp ( file ) ; } if ( unlikely ( error ) ) { if ( error == - eopenstale ) { if ( flags & lookup_rcu ) error = - echild ; else error = - estale ; } file = err_ptr ( error ) ; } return file ; }","<S2SV_ModStart> ) ; goto out2 <S2SV_ModEnd> ; } error <S2SV_ModStart> nd ) ; out2 :
",torvalds@linux/f15133df088ecadd141ea1907f2c96df67c729f0,CVE-2015-5706,https://github.com/torvalds/linux/commit/f15133df088ecadd141ea1907f2c96df67c729f0,2015-08-31T10:59Z,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( opened & FILE_OPENED ) ) { <S2SV_EndBug>
5499,CWE-59,"int add_mibfile ( const char * tmpstr , const char * d_name , file * ip ) { file * fp ; char token [ maxtoken ] , token2 [ maxtoken ] ; if ( ( fp = fopen ( tmpstr , ""r"" ) ) == null ) { snmp_log_perror ( tmpstr ) ; return 1 ; } debugmsgtl ( ( ""parse-mibs"" , ""checking<s2sv_blank>file:<s2sv_blank>%s...\\n"" , tmpstr ) ) ; mibline = 1 ; file = tmpstr ; if ( get_token ( fp , token , maxtoken ) != label ) { fclose ( fp ) ; return 1 ; } if ( get_token ( fp , token2 , maxtoken ) == definitions ) { new_module ( token , tmpstr ) ; if ( ip ) fprintf ( ip , ""%s<s2sv_blank>%s\\n"" , token , d_name ) ; fclose ( fp ) ; return 0 ; } else { fclose ( fp ) ; return 1 ; } }","<S2SV_ModStart> char * d_name <S2SV_ModEnd> ) { FILE <S2SV_ModStart> tmpstr ) ; <S2SV_ModEnd> fclose ( fp
",net-snmp@net-snmp/4fd9a450444a434a993bc72f7c3486ccce41f602,CVE-2020-15861,https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602,2020-08-20T01:17Z,"<S2SV_StartBug> add_mibfile ( const char * tmpstr , const char * d_name , FILE * ip ) <S2SV_EndBug> <S2SV_StartBug> if ( ip ) <S2SV_EndBug>"
452,CWE-119,"static int nl80211_start_sched_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_sched_scan_request * request ; struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; u32 interval ; enum ieee80211_band band ; size_t ie_len ; if ( ! ( rdev -> wiphy . flags & wiphy_flag_supports_sched_scan ) || ! rdev -> ops -> sched_scan_start ) return - eopnotsupp ; if ( ! is_valid_ie_attr ( info -> attrs [ nl80211_attr_ie ] ) ) return - einval ; if ( rdev -> sched_scan_req ) return - einprogress ; if ( ! info -> attrs [ nl80211_attr_sched_scan_interval ] ) return - einval ; interval = nla_get_u32 ( info -> attrs [ nl80211_attr_sched_scan_interval ] ) ; if ( interval == 0 ) return - einval ; wiphy = & rdev -> wiphy ; if ( info -> attrs [ nl80211_attr_scan_frequencies ] ) { n_channels = validate_scan_freqs ( info -> attrs [ nl80211_attr_scan_frequencies ] ) ; if ( ! n_channels ) return - einval ; } else { n_channels = 0 ; for ( band = 0 ; band < ieee80211_num_bands ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ nl80211_attr_scan_ssids ] ) nla_for_each_nested ( attr , info -> attrs [ nl80211_attr_scan_ssids ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - einval ; if ( info -> attrs [ nl80211_attr_ie ] ) ie_len = nla_len ( info -> attrs [ nl80211_attr_ie ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - einval ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , gfp_kernel ) ; if ( ! request ) return - enomem ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ nl80211_attr_scan_frequencies ] ) { nla_for_each_nested ( attr , info -> attrs [ nl80211_attr_scan_frequencies ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - einval ; goto out_free ; } if ( chan -> flags & ieee80211_chan_disabled ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < ieee80211_num_bands ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & ieee80211_chan_disabled ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - einval ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ nl80211_attr_scan_ssids ] ) { nla_for_each_nested ( attr , info -> attrs [ nl80211_attr_scan_ssids ] , tmp ) { if ( request -> ssids [ i ] . ssid_len > ieee80211_max_ssid_len ) { err = - einval ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; i ++ ; } } if ( info -> attrs [ nl80211_attr_ie ] ) { request -> ie_len = nla_len ( info -> attrs [ nl80211_attr_ie ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ nl80211_attr_ie ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; request -> interval = interval ; err = rdev -> ops -> sched_scan_start ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { rdev -> sched_scan_req = request ; nl80211_send_sched_scan ( rdev , dev , nl80211_cmd_start_sched_scan ) ; goto out ; } out_free : kfree ( request ) ; out : return err ; }","<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
",torvalds@linux/208c72f4fe44fe09577e7975ba0e7fa0278f3d03,CVE-2011-2517,https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03,2012-05-24T23:55Z,<S2SV_StartBug> if ( request -> ssids [ i ] . ssid_len > <S2SV_EndBug> <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug>
5448,CWE-787,"static void process_demand_active ( stream s ) { uint8 type ; uint16 len_src_descriptor , len_combined_caps ; rd_create_ui ( ) ; in_uint32_le ( s , g_rdp_shareid ) ; in_uint16_le ( s , len_src_descriptor ) ; in_uint16_le ( s , len_combined_caps ) ; in_uint8s ( s , len_src_descriptor ) ; logger ( protocol , debug , ""process_demand_active(),<s2sv_blank>shareid=0x%x"" , g_rdp_shareid ) ; rdp_process_server_caps ( s , len_combined_caps ) ; rdp_send_confirm_active ( ) ; rdp_send_synchronise ( ) ; rdp_send_control ( rdp_ctl_cooperate ) ; rdp_send_control ( rdp_ctl_request_control ) ; rdp_recv ( & type ) ; rdp_recv ( & type ) ; rdp_recv ( & type ) ; rdp_send_input ( 0 , rdp_input_synchronize , 0 , g_numlock_sync ? ui_get_numlock_state ( read_keyboard_state ( ) ) : 0 , 0 ) ; if ( g_rdp_version >= rdp_v5 ) { rdp_enum_bmpcache2 ( ) ; rdp_send_fonts ( 3 ) ; } else { rdp_send_fonts ( 1 ) ; rdp_send_fonts ( 2 ) ; } rdp_recv ( & type ) ; reset_order_state ( ) ; }","<S2SV_ModStart> , len_combined_caps ; struct stream packet = * s ; <S2SV_ModStart> len_combined_caps ) ; if ( ! s_check_rem ( s , len_src_descriptor ) ) { rdp_protocol_error ( ""rdp_demand_active(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>source<S2SV_blank>descriptor<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,"<S2SV_StartBug> rd_create_ui ( ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint16_le ( s , len_combined_caps ) ; <S2SV_EndBug>"
5157,CWE-674,"static void renametablefunc ( sqlite3_context * context , int notused , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; const char * zdb = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zinput = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * zold = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; const char * znew = ( const char * ) sqlite3_value_text ( argv [ 5 ] ) ; int btemp = sqlite3_value_int ( argv [ 6 ] ) ; unused_parameter ( notused ) ; if ( zinput && zold && znew ) { parse sparse ; int rc ; int bquote = 1 ; renamectx sctx ; walker swalker ; # ifndef sqlite_omit_authorization sqlite3_xauth xauth = db -> xauth ; db -> xauth = 0 ; # endif sqlite3btreeenterall ( db ) ; memset ( & sctx , 0 , sizeof ( renamectx ) ) ; sctx . ptab = sqlite3findtable ( db , zold , zdb ) ; memset ( & swalker , 0 , sizeof ( walker ) ) ; swalker . pparse = & sparse ; swalker . xexprcallback = renametableexprcb ; swalker . xselectcallback = renametableselectcb ; swalker . u . prename = & sctx ; rc = renameparsesql ( & sparse , zdb , 1 , db , zinput , btemp ) ; if ( rc == sqlite_ok ) { int islegacy = ( db -> flags & sqlite_legacyalter ) ; if ( sparse . pnewtable ) { table * ptab = sparse . pnewtable ; if ( ptab -> pselect ) { if ( islegacy == 0 ) { namecontext snc ; memset ( & snc , 0 , sizeof ( snc ) ) ; snc . pparse = & sparse ; sqlite3selectprep ( & sparse , ptab -> pselect , & snc ) ; if ( sparse . nerr ) rc = sparse . rc ; sqlite3walkselect ( & swalker , ptab -> pselect ) ; } } else { # ifndef sqlite_omit_foreign_key if ( islegacy == 0 || ( db -> flags & sqlite_foreignkeys ) ) { fkey * pfkey ; for ( pfkey = ptab -> pfkey ; pfkey ; pfkey = pfkey -> pnextfrom ) { if ( sqlite3_stricmp ( pfkey -> zto , zold ) == 0 ) { renametokenfind ( & sparse , & sctx , ( void * ) pfkey -> zto ) ; } } } # endif if ( sqlite3_stricmp ( zold , ptab -> zname ) == 0 ) { sctx . ptab = ptab ; if ( islegacy == 0 ) { sqlite3walkexprlist ( & swalker , ptab -> pcheck ) ; } renametokenfind ( & sparse , & sctx , ptab -> zname ) ; } } } else if ( sparse . pnewindex ) { renametokenfind ( & sparse , & sctx , sparse . pnewindex -> zname ) ; if ( islegacy == 0 ) { sqlite3walkexpr ( & swalker , sparse . pnewindex -> ppartidxwhere ) ; } } # ifndef sqlite_omit_trigger else { trigger * ptrigger = sparse . pnewtrigger ; triggerstep * pstep ; if ( 0 == sqlite3_stricmp ( sparse . pnewtrigger -> table , zold ) && sctx . ptab -> pschema == ptrigger -> ptabschema ) { renametokenfind ( & sparse , & sctx , sparse . pnewtrigger -> table ) ; } if ( islegacy == 0 ) { rc = renameresolvetrigger ( & sparse , btemp ? 0 : zdb ) ; if ( rc == sqlite_ok ) { renamewalktrigger ( & swalker , ptrigger ) ; for ( pstep = ptrigger -> step_list ; pstep ; pstep = pstep -> pnext ) { if ( pstep -> ztarget && 0 == sqlite3_stricmp ( pstep -> ztarget , zold ) ) { renametokenfind ( & sparse , & sctx , pstep -> ztarget ) ; } } } } } # endif } if ( rc == sqlite_ok ) { rc = renameeditsql ( context , & sctx , zinput , znew , bquote ) ; } if ( rc != sqlite_ok ) { if ( sparse . zerrmsg ) { renamecolumnparseerror ( context , 0 , argv [ 1 ] , argv [ 2 ] , & sparse ) ; } else { sqlite3_result_error_code ( context , rc ) ; } } renameparsecleanup ( & sparse ) ; renametokenfree ( db , sctx . plist ) ; sqlite3btreeleaveall ( db ) ; # ifndef sqlite_omit_authorization db -> xauth = xauth ; # endif } return ; }","<S2SV_ModStart> 0 ) { Select * pSelect = pTab -> pSelect ; <S2SV_ModStart> = & sParse ; assert ( pSelect -> selFlags & SF_View ) ; pSelect -> selFlags &= ~ SF_View
",sqlite@sqlite/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,CVE-2019-19645,https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,2019-12-09T16:15Z,<S2SV_StartBug> NameContext sNC ; <S2SV_EndBug> <S2SV_StartBug> sNC . pParse = & sParse ; <S2SV_EndBug>
7671,CWE-119,"int class parse_jpeg ( int offset ) { int len , save , hlen , mark ; fseek ( ifp , offset , seek_set ) ; if ( fgetc ( ifp ) != 0xff || fgetc ( ifp ) != 0xd8 ) return 0 ; while ( fgetc ( ifp ) == 0xff && ( mark = fgetc ( ifp ) ) != 0xda ) { order = 0x4d4d ; len = get2 ( ) - 2 ; save = ftell ( ifp ) ; if ( mark == 0xc0 || mark == 0xc3 || mark == 0xc9 ) { fgetc ( ifp ) ; raw_height = get2 ( ) ; raw_width = get2 ( ) ; } order = get2 ( ) ; hlen = get4 ( ) ; if ( get4 ( ) == 0x48454150 ) { # ifdef libraw_library_build imgdata . lens . makernotes . cameramount = libraw_mount_fixedlens ; imgdata . lens . makernotes . lensmount = libraw_mount_fixedlens ; # endif parse_ciff ( save + hlen , len - hlen , 0 ) ; } if ( parse_tiff ( save + 6 ) ) apply_tiff ( ) ; fseek ( ifp , save + len , seek_set ) ; } return 1 ; }","<S2SV_ModStart> ) == 0x48454150 <S2SV_ModEnd> # ifdef LIBRAW_LIBRARY_BUILD <S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD && ( save + hlen ) >= 0 && ( save + hlen ) <= ifp -> size ( ) # endif ) { # ifdef LIBRAW_LIBRARY_BUILD
",LibRaw@LibRaw/d7c3d2cb460be10a3ea7b32e9443a83c243b2251,CVE-2017-6887,https://github.com/LibRaw/LibRaw/commit/d7c3d2cb460be10a3ea7b32e9443a83c243b2251,2017-05-16T16:29Z,<S2SV_StartBug> if ( get4 ( ) == 0x48454150 ) <S2SV_EndBug> <S2SV_StartBug> imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; <S2SV_EndBug>
328,CWE-416,"static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( sigpipe , current , 0 ) ; if ( ! ret ) ret = - epipe ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; pipe_buf_get ( ipipe , ibuf ) ; obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ pipe_buf_flag_gift ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & splice_f_nonblock ) ) ret = - eagain ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }","<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe
",torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug>"
8418,CWE-94,"int streamtcppacket ( threadvars * tv , packet * p , streamtcpthread * stt , packetqueue * pq ) { scenter ( ) ; debug_assert_flow_locked ( p -> flow ) ; sclogdebug ( ""p->pcap_cnt<s2sv_blank>%"" priu64 , p -> pcap_cnt ) ; handlethreadid ( tv , p , stt ) ; tcpsession * ssn = ( tcpsession * ) p -> flow -> protoctx ; if ( ssn != null ) { ssn -> tcp_packet_flags |= p -> tcph -> th_flags ; if ( pkt_is_toserver ( p ) ) ssn -> client . tcp_flags |= p -> tcph -> th_flags ; else if ( pkt_is_toclient ( p ) ) ssn -> server . tcp_flags |= p -> tcph -> th_flags ; if ( ssn -> flags & streamtcp_flag_async && ssn -> client . tcp_flags != 0 && ssn -> server . tcp_flags != 0 ) { sclogdebug ( ""ssn<s2sv_blank>%p:<s2sv_blank>removing<s2sv_blank>async<s2sv_blank>flag<s2sv_blank>as<s2sv_blank>we<s2sv_blank>have<s2sv_blank>packets<s2sv_blank>on<s2sv_blank>both<s2sv_blank>sides"" , ssn ) ; ssn -> flags &= ~ streamtcp_flag_async ; } } if ( ( p -> tcph -> th_flags & ( th_syn | th_ack ) ) == ( th_syn | th_ack ) ) { statsincr ( tv , stt -> counter_tcp_synack ) ; } else if ( p -> tcph -> th_flags & ( th_syn ) ) { statsincr ( tv , stt -> counter_tcp_syn ) ; } if ( p -> tcph -> th_flags & ( th_rst ) ) { statsincr ( tv , stt -> counter_tcp_rst ) ; } if ( ! ( p -> tcph -> th_flags & th_ack ) && tcp_get_ack ( p ) != 0 ) { streamtcpsetevent ( p , stream_pkt_broken_ack ) ; } if ( streamtcpcheckflowdrops ( p ) == 1 ) { sclogdebug ( ""this<s2sv_blank>flow/stream<s2sv_blank>triggered<s2sv_blank>a<s2sv_blank>drop<s2sv_blank>rule"" ) ; flowsetnopacketinspectionflag ( p -> flow ) ; decodesetnopacketinspectionflag ( p ) ; streamtcpdisableapplayer ( p -> flow ) ; packet_drop ( p ) ; streamtcpsessionpktfree ( p ) ; screturnint ( 0 ) ; } if ( ssn == null || ssn -> state == tcp_none ) { if ( streamtcppacketstatenone ( tv , p , stt , ssn , & stt -> pseudo_queue ) == - 1 ) { goto error ; } if ( ssn != null ) sclogdebug ( ""ssn->alproto<s2sv_blank>%"" priu16 """" , p -> flow -> alproto ) ; } else { if ( p -> flags & pkt_pseudo_stream_end ) { if ( pkt_is_toclient ( p ) ) { ssn -> client . last_ack = tcp_get_ack ( p ) ; streamtcpreassemblehandlesegment ( tv , stt -> ra_ctx , ssn , & ssn -> server , p , pq ) ; } else { ssn -> server . last_ack = tcp_get_ack ( p ) ; streamtcpreassemblehandlesegment ( tv , stt -> ra_ctx , ssn , & ssn -> client , p , pq ) ; } goto skip ; } if ( p -> flow -> flags & flow_wrong_thread || ssn -> client . flags & streamtcp_stream_flag_gap || ssn -> server . flags & streamtcp_stream_flag_gap ) { p -> flags |= pkt_stream_no_events ; } if ( streamtcppacketiskeepalive ( ssn , p ) == 1 ) { goto skip ; } if ( streamtcppacketiskeepaliveack ( ssn , p ) == 1 ) { streamtcpclearkeepaliveflag ( ssn , p ) ; goto skip ; } streamtcpclearkeepaliveflag ( ssn , p ) ; if ( streamtcppacketisfinshutdownack ( ssn , p ) == 0 ) if ( streamtcppacketiswindowupdate ( ssn , p ) == 0 ) if ( streamtcppacketisbadwindowupdate ( ssn , p ) ) goto skip ; if ( streamtcpstatedispatch ( tv , p , stt , ssn , & stt -> pseudo_queue , ssn -> state ) < 0 ) goto error ; skip : streamtcppacketcheckpostrst ( ssn , p ) ; if ( ssn -> state >= tcp_established ) { p -> flags |= pkt_stream_est ; } } if ( ssn != null ) { while ( stt -> pseudo_queue . len > 0 ) { sclogdebug ( ""processing<s2sv_blank>pseudo<s2sv_blank>packet<s2sv_blank>/<s2sv_blank>stream<s2sv_blank>end"" ) ; packet * np = packetdequeue ( & stt -> pseudo_queue ) ; if ( np != null ) { if ( pkt_is_toserver ( np ) ) { sclogdebug ( ""pseudo<s2sv_blank>packet<s2sv_blank>is<s2sv_blank>to<s2sv_blank>server"" ) ; streamtcpreassemblehandlesegment ( tv , stt -> ra_ctx , ssn , & ssn -> client , np , null ) ; } else { sclogdebug ( ""pseudo<s2sv_blank>packet<s2sv_blank>is<s2sv_blank>to<s2sv_blank>client"" ) ; streamtcpreassemblehandlesegment ( tv , stt -> ra_ctx , ssn , & ssn -> server , np , null ) ; } packetenqueue ( pq , np ) ; } sclogdebug ( ""processing<s2sv_blank>pseudo<s2sv_blank>packet<s2sv_blank>/<s2sv_blank>stream<s2sv_blank>end<s2sv_blank>done"" ) ; } if ( p -> flags & pkt_stream_modified ) { recalculatechecksum ( p ) ; } if ( ( ssn -> client . flags & streamtcp_stream_flag_depth_reached ) || ( ssn -> server . flags & streamtcp_stream_flag_depth_reached ) ) { if ( streamtcpbypassenabled ( ) ) { packetbypasscallback ( p ) ; } } if ( ( ssn -> client . flags & streamtcp_stream_flag_depth_reached ) || ( ssn -> server . flags & streamtcp_stream_flag_depth_reached ) ) { p -> flags |= pkt_stream_nopcaplog ; } if ( ( pkt_is_toserver ( p ) && ( ssn -> client . flags & streamtcp_stream_flag_noreassembly ) ) || ( pkt_is_toclient ( p ) && ( ssn -> server . flags & streamtcp_stream_flag_noreassembly ) ) ) { p -> flags |= pkt_stream_nopcaplog ; } if ( ssn -> flags & streamtcp_flag_bypass ) { if ( streamtcpbypassenabled ( ) ) { packetbypasscallback ( p ) ; } } else if ( g_detect_disabled && ( ssn -> client . flags & streamtcp_stream_flag_noreassembly ) && ( ssn -> server . flags & streamtcp_stream_flag_noreassembly ) && streamtcpbypassenabled ( ) ) { sclogdebug ( ""bypass<s2sv_blank>as<s2sv_blank>stream<s2sv_blank>is<s2sv_blank>dead<s2sv_blank>and<s2sv_blank>we<s2sv_blank>have<s2sv_blank>no<s2sv_blank>rules"" ) ; packetbypasscallback ( p ) ; } } screturnint ( 0 ) ; error : while ( stt -> pseudo_queue . len > 0 ) { packet * np = packetdequeue ( & stt -> pseudo_queue ) ; if ( np != null ) { packetenqueue ( pq , np ) ; } } if ( p -> flags & pkt_stream_modified ) { recalculatechecksum ( p ) ; } if ( streamtcpinlinedropinvalid ( ) ) { decodesetnopayloadinspectionflag ( p ) ; packet_drop ( p ) ; } screturnint ( - 1 ) ; }","<S2SV_ModStart> , STREAM_PKT_BROKEN_ACK ) ; goto error
",OISF@suricata/fa692df37a796c3330c81988d15ef1a219afc006,CVE-2019-18792,https://github.com/OISF/suricata/commit/fa692df37a796c3330c81988d15ef1a219afc006,2020-01-06T18:15Z,"<S2SV_StartBug> StreamTcpSetEvent ( p , STREAM_PKT_BROKEN_ACK ) ; <S2SV_EndBug>"
5585,CWE-399,"int cib_remote_perform_op ( cib_t * cib , const char * op , const char * host , const char * section , xmlnode * data , xmlnode * * output_data , int call_options , const char * name ) { int rc = pcmk_ok ; xmlnode * op_msg = null ; xmlnode * op_reply = null ; cib_remote_opaque_t * private = cib -> variant_opaque ; if ( sync_timer == null ) { sync_timer = calloc ( 1 , sizeof ( struct timer_rec_s ) ) ; } if ( cib -> state == cib_disconnected ) { return - enotconn ; } if ( output_data != null ) { * output_data = null ; } if ( op == null ) { crm_err ( ""no<s2sv_blank>operation<s2sv_blank>specified"" ) ; return - einval ; } cib -> call_id ++ ; if ( cib -> call_id < 1 ) { cib -> call_id = 1 ; } op_msg = cib_create_op ( cib -> call_id , private -> callback . token , op , host , section , data , call_options , null ) ; if ( op_msg == null ) { return - eproto ; } crm_trace ( ""sending<s2sv_blank>%s<s2sv_blank>message<s2sv_blank>to<s2sv_blank>cib<s2sv_blank>service"" , op ) ; crm_send_remote_msg ( private -> command . session , op_msg , private -> command . encrypted ) ; free_xml ( op_msg ) ; if ( ( call_options & cib_discard_reply ) ) { crm_trace ( ""discarding<s2sv_blank>reply"" ) ; return pcmk_ok ; } else if ( ! ( call_options & cib_sync_call ) ) { return cib -> call_id ; } crm_trace ( ""waiting<s2sv_blank>for<s2sv_blank>a<s2sv_blank>syncronous<s2sv_blank>reply"" ) ; if ( cib -> call_timeout > 0 ) { timer_expired = false ; sync_timer -> call_id = cib -> call_id ; sync_timer -> timeout = cib -> call_timeout * 1000 ; sync_timer -> ref = g_timeout_add ( sync_timer -> timeout , cib_timeout_handler , sync_timer ) ; } while ( timer_expired == false ) { int reply_id = - 1 ; int msg_id = cib -> call_id ; op_reply = crm_recv_remote_msg ( private -> command . session , private -> command . encrypted ) ; if ( op_reply == null ) { break ; } crm_element_value_int ( op_reply , f_cib_callid , & reply_id ) ; crm_check ( reply_id > 0 , free_xml ( op_reply ) ; if ( sync_timer -> ref > 0 ) { g_source_remove ( sync_timer -> ref ) ; sync_timer -> ref = 0 ; } return - enomsg ) ; if ( reply_id == msg_id ) { break ; } else if ( reply_id < msg_id ) { crm_debug ( ""received<s2sv_blank>old<s2sv_blank>reply:<s2sv_blank>%d<s2sv_blank>(wanted<s2sv_blank>%d)"" , reply_id , msg_id ) ; crm_log_xml_trace ( op_reply , ""old<s2sv_blank>reply"" ) ; } else if ( ( reply_id - 10000 ) > msg_id ) { crm_debug ( ""received<s2sv_blank>old<s2sv_blank>reply:<s2sv_blank>%d<s2sv_blank>(wanted<s2sv_blank>%d)"" , reply_id , msg_id ) ; crm_log_xml_trace ( op_reply , ""old<s2sv_blank>reply"" ) ; } else { crm_err ( ""received<s2sv_blank>a<s2sv_blank>__future__<s2sv_blank>reply:"" ""<s2sv_blank>%d<s2sv_blank>(wanted<s2sv_blank>%d)"" , reply_id , msg_id ) ; } free_xml ( op_reply ) ; op_reply = null ; } if ( sync_timer -> ref > 0 ) { g_source_remove ( sync_timer -> ref ) ; sync_timer -> ref = 0 ; } if ( timer_expired ) { return - etime ; } if ( op_reply == null ) { crm_err ( ""no<s2sv_blank>reply<s2sv_blank>message<s2sv_blank>-<s2sv_blank>empty"" ) ; return - enomsg ; } crm_trace ( ""syncronous<s2sv_blank>reply<s2sv_blank>received"" ) ; if ( crm_element_value_int ( op_reply , f_cib_rc , & rc ) != 0 ) { rc = - eproto ; } if ( rc == - pcmk_err_diff_resync ) { rc = pcmk_ok ; } if ( rc == pcmk_ok || rc == - eperm ) { crm_log_xml_debug ( op_reply , ""passed"" ) ; } else { crm_err ( ""call<s2sv_blank>failed:<s2sv_blank>%s"" , pcmk_strerror ( rc ) ) ; crm_log_xml_warn ( op_reply , ""failed"" ) ; } if ( output_data == null ) { } else if ( ! ( call_options & cib_discard_reply ) ) { xmlnode * tmp = get_message_xml ( op_reply , f_cib_calldata ) ; if ( tmp == null ) { crm_trace ( ""no<s2sv_blank>output<s2sv_blank>in<s2sv_blank>reply<s2sv_blank>to<s2sv_blank>\\""%s\\""<s2sv_blank>command<s2sv_blank>%d"" , op , cib -> call_id - 1 ) ; } else { * output_data = copy_xml ( tmp ) ; } } free_xml ( op_reply ) ; return rc ; }","<S2SV_ModStart> = pcmk_ok ; int disconnected = 0 ; int remaining_time = 0 ; time_t start_time ; <S2SV_ModStart> -> variant_opaque ; <S2SV_ModEnd> if ( cib <S2SV_ModStart> op ) ; if ( ! ( call_options & cib_sync_call ) ) { <S2SV_ModStart> ( private -> callback . session , op_msg , private -> command . encrypted ) ; } else { crm_send_remote_msg ( private -> command . <S2SV_ModEnd> session , op_msg <S2SV_ModStart> encrypted ) ; } <S2SV_ModStart> ""Waiting<S2SV_blank>for<S2SV_blank>a<S2SV_blank>syncronous<S2SV_blank>reply"" ) ; start_time = time ( NULL ) ; remaining_time = <S2SV_ModEnd> cib -> call_timeout <S2SV_ModStart> cib -> call_timeout ? cib -> call_timeout : 60 ; while ( remaining_time > 0 && ! disconnected <S2SV_ModEnd> ) { int <S2SV_ModStart> -> call_id ; <S2SV_ModEnd> crm_recv_remote_msg ( private <S2SV_ModStart> . session , & <S2SV_ModStart> -> command . recv_buf , private -> command . encrypted , remaining_time * 1000 , & disconnected ) ; op_reply = crm_parse_remote_buffer ( & private -> command . recv_buf ) ; if ( ! op_reply <S2SV_ModEnd> ) { break <S2SV_ModStart> , & reply_id <S2SV_ModEnd> ) ; if <S2SV_ModStart> = NULL ; remaining_time = time ( NULL ) - start_time ; } if ( disconnected ) { crm_err ( ""Disconnected<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>reply."" ) ; return - ENOTCONN ; } else <S2SV_ModEnd> if ( op_reply
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z,"<S2SV_StartBug> xmlNode * op_msg = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( sync_timer == NULL ) { <S2SV_EndBug> <S2SV_StartBug> crm_send_remote_msg ( private -> command . session , op_msg , private -> command . encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cib -> call_timeout > 0 ) { <S2SV_EndBug> <S2SV_StartBug> op_reply = crm_recv_remote_msg ( private -> command . session , private -> command . encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> crm_element_value_int ( op_reply , F_CIB_CALLID , & reply_id ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
3990,CWE-20,"int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; int copied , error = - einval ; msg -> msg_namelen = 0 ; if ( sock -> state != ss_connected ) return - enotconn ; if ( flags & ~ ( msg_dontwait | msg_peek ) ) return - eopnotsupp ; vcc = atm_sd ( sock ) ; if ( test_bit ( atm_vf_released , & vcc -> flags ) || test_bit ( atm_vf_close , & vcc -> flags ) || ! test_bit ( atm_vf_ready , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & msg_dontwait , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= msg_trunc ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & msg_peek ) ) { pr_debug ( ""%d<s2sv_blank>-=<s2sv_blank>%d\\n"" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }","<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; if (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,"<S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug>"
2213,CWE-200,"static void * __alloc_from_pool ( size_t size , struct page * * ret_page , gfp_t flags ) { unsigned long val ; void * ptr = null ; if ( ! atomic_pool ) { warn ( 1 , ""coherent<s2sv_blank>pool<s2sv_blank>not<s2sv_blank>initialised!\\n"" ) ; return null ; } val = gen_pool_alloc ( atomic_pool , size ) ; if ( val ) { phys_addr_t phys = gen_pool_virt_to_phys ( atomic_pool , val ) ; * ret_page = phys_to_page ( phys ) ; ptr = ( void * ) val ; if ( flags & __gfp_zero ) memset ( ptr , 0 , size ) ; } return ptr ; }","<S2SV_ModStart> ) val ; <S2SV_ModEnd> memset ( ptr
",torvalds@linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5,CVE-2015-8950,https://github.com/torvalds/linux/commit/6829e274a623187c24f7cfc0e3d35f25d087fcc5,2016-10-10T10:59Z,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug>
8131,CWE-295,"int main_configure ( char * arg1 , char * arg2 ) { int cmdline_status ; cmdline_status = options_cmdline ( arg1 , arg2 ) ; if ( cmdline_status ) return cmdline_status ; options_apply ( ) ; str_canary_init ( ) ; log_open ( sink_syslog ) ; if ( bind_ports ( ) ) return 1 ; # ifdef have_chroot if ( change_root ( ) ) return 1 ; # endif if ( drop_privileges ( 1 ) ) return 1 ; if ( log_open ( sink_outfile ) ) return 1 ; # ifndef use_fork num_clients = 0 ; # endif log_flush ( log_mode_configured ) ; return 0 ; }","<S2SV_ModStart> int cmdline_status ; log_flush ( LOG_MODE_BUFFER ) ; <S2SV_ModStart> ( cmdline_status ) { log_flush ( LOG_MODE_ERROR ) ; return cmdline_status ; } options_free ( 1 ) <S2SV_ModEnd> ; options_apply ( <S2SV_ModStart> ( ) ) { unbind_ports ( ) ; options_free ( 1 ) ; options_defaults ( ) ; options_apply ( ) ; log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> # ifdef HAVE_CHROOT <S2SV_ModStart> ( ) ) { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> # endif if <S2SV_ModStart> 1 ) ) { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> if ( log_open <S2SV_ModStart> SINK_OUTFILE ) ) { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> # ifndef USE_FORK
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,"<S2SV_StartBug> cmdline_status = options_cmdline ( arg1 , arg2 ) ; <S2SV_EndBug> <S2SV_StartBug> return cmdline_status ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug>"
1069,CWE-20,"static int netbk_count_requests ( struct xenvif * vif , struct xen_netif_tx_request * first , struct xen_netif_tx_request * txp , int work_to_do ) { ring_idx cons = vif -> tx . req_cons ; int frags = 0 ; if ( ! ( first -> flags & xen_nettxf_more_data ) ) return 0 ; do { if ( frags >= work_to_do ) { netdev_dbg ( vif -> dev , ""need<s2sv_blank>more<s2sv_blank>frags\\n"" ) ; return - frags ; } if ( unlikely ( frags >= max_skb_frags ) ) { netdev_dbg ( vif -> dev , ""too<s2sv_blank>many<s2sv_blank>frags\\n"" ) ; return - frags ; } memcpy ( txp , ring_get_request ( & vif -> tx , cons + frags ) , sizeof ( * txp ) ) ; if ( txp -> size > first -> size ) { netdev_dbg ( vif -> dev , ""frags<s2sv_blank>galore\\n"" ) ; return - frags ; } first -> size -= txp -> size ; frags ++ ; if ( unlikely ( ( txp -> offset + txp -> size ) > page_size ) ) { netdev_dbg ( vif -> dev , ""txp->offset:<s2sv_blank>%x,<s2sv_blank>size:<s2sv_blank>%u\\n"" , txp -> offset , txp -> size ) ; return - frags ; } } while ( ( txp ++ ) -> flags & xen_nettxf_more_data ) ; return frags ; }","<S2SV_ModStart> work_to_do ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> size ) { netdev_err ( vif -> dev , ""Frag<S2SV_blank>is<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>frame.\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> txp -> size ) ; netbk_fatal_tx_err ( vif
",torvalds@linux/48856286b64e4b66ec62b94e504d0b29c1ade664,CVE-2013-0216,https://github.com/torvalds/linux/commit/48856286b64e4b66ec62b94e504d0b29c1ade664,2013-02-18T04:41Z,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n"" , <S2SV_EndBug> <S2SV_StartBug> txp -> offset , txp -> size ) ; <S2SV_EndBug>"
1275,CWE-119,"static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) { int ret ; ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , pegasus_req_set_regs , pegasus_reqt_write , 0 , indx , data , size , 100 ) ; if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<s2sv_blank>returned<s2sv_blank>%d\\n"" , __func__ , ret ) ; return ret ; }","<S2SV_ModStart> __u16 size , const <S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
",torvalds@linux/5593523f968bc86d42a035c6df47d5e0979b5ace,CVE-2017-8068,https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace,2017-04-23T05:59Z,"<S2SV_StartBug> static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , data , size , 100 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug>"
216,CWE-20,"int ptrace_setxregs ( struct task_struct * child , void __user * uregs ) { struct thread_info * ti = task_thread_info ( child ) ; struct pt_regs * regs = task_pt_regs ( child ) ; elf_xtregs_t * xtregs = uregs ; int ret = 0 ; # if xtensa_have_coprocessors coprocessor_flush_all ( ti ) ; coprocessor_release_all ( ti ) ; ret |= __copy_from_user ( & ti -> xtregs_cp , & xtregs -> cp0 , sizeof ( xtregs_coprocessor_t ) ) ; # endif ret |= __copy_from_user ( & regs -> xtregs_opt , & xtregs -> opt , sizeof ( xtregs -> opt ) ) ; ret |= __copy_from_user ( & ti -> xtregs_user , & xtregs -> user , sizeof ( xtregs -> user ) ) ; return ret ? - efault : 0 ; }","<S2SV_ModStart> ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
",torvalds@linux/0d0138ebe24b94065580bd2601f8bb7eb6152f56,CVE-2011-2707,https://github.com/torvalds/linux/commit/0d0138ebe24b94065580bd2601f8bb7eb6152f56,2012-05-24T23:55Z,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug>
3640,CWE-20,"static void handle_rx ( struct vhost_net * net ) { struct vhost_net_virtqueue * nvq = & net -> vqs [ vhost_net_vq_rx ] ; struct vhost_virtqueue * vq = & nvq -> vq ; unsigned uninitialized_var ( in ) , log ; struct vhost_log * vq_log ; struct msghdr msg = { . msg_name = null , . msg_namelen = 0 , . msg_control = null , . msg_controllen = 0 , . msg_iov = vq -> iov , . msg_flags = msg_dontwait , } ; struct virtio_net_hdr_mrg_rxbuf hdr = { . hdr . flags = 0 , . hdr . gso_type = virtio_net_hdr_gso_none } ; size_t total_len = 0 ; int err , mergeable ; s16 headcount ; size_t vhost_hlen , sock_hlen ; size_t vhost_len , sock_len ; struct socket * sock ; mutex_lock ( & vq -> mutex ) ; sock = vq -> private_data ; if ( ! sock ) goto out ; vhost_disable_notify ( & net -> dev , vq ) ; vhost_hlen = nvq -> vhost_hlen ; sock_hlen = nvq -> sock_hlen ; vq_log = unlikely ( vhost_has_feature ( & net -> dev , vhost_f_log_all ) ) ? vq -> log : null ; mergeable = vhost_has_feature ( & net -> dev , virtio_net_f_mrg_rxbuf ) ; while ( ( sock_len = peek_head_len ( sock -> sk ) ) ) { sock_len += sock_hlen ; vhost_len = sock_len + vhost_hlen ; headcount = get_rx_bufs ( vq , vq -> heads , vhost_len , & in , vq_log , & log , likely ( mergeable ) ? uio_maxiov : 1 ) ; if ( unlikely ( headcount < 0 ) ) break ; if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( null , sock , & msg , sock_len , msg_dontwait | msg_trunc ) ; if ( unlikely ( err != sock_len ) ) { pr_debug ( ""discarded<s2sv_blank>rx<s2sv_blank>packet:<s2sv_blank>"" ""<s2sv_blank>len<s2sv_blank>%d,<s2sv_blank>expected<s2sv_blank>%zd\\n"" , err , sock_len ) ; vhost_discard_vq_desc ( vq , headcount ) ; continue ; } if ( unlikely ( vhost_hlen ) && memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & hdr , 0 , vhost_hlen ) ) { vq_err ( vq , ""unable<s2sv_blank>to<s2sv_blank>write<s2sv_blank>vnet_hdr<s2sv_blank>at<s2sv_blank>addr<s2sv_blank>%p\\n"" , vq -> iov -> iov_base ) ; break ; } if ( likely ( mergeable ) && memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & headcount , offsetof ( typeof ( hdr ) , num_buffers ) , sizeof hdr . num_buffers ) ) { vq_err ( vq , ""failed<s2sv_blank>num_buffers<s2sv_blank>write"" ) ; vhost_discard_vq_desc ( vq , headcount ) ; break ; } vhost_add_used_and_signal_n ( & net -> dev , vq , vq -> heads , headcount ) ; if ( unlikely ( vq_log ) ) vhost_log_write ( vq , vq_log , log , vhost_len ) ; total_len += vhost_len ; if ( unlikely ( total_len >= vhost_net_weight ) ) { vhost_poll_queue ( & vq -> poll ) ; break ; } } out : mutex_unlock ( & vq -> mutex ) ; }","<S2SV_ModStart> ; if ( unlikely ( headcount > UIO_MAXIOV ) ) { <S2SV_ModEnd> msg . msg_iovlen <S2SV_ModStart> . msg_iovlen = 1 <S2SV_ModEnd> ; err = <S2SV_ModStart> & msg , 1 <S2SV_ModEnd> , MSG_DONTWAIT | <S2SV_ModStart> MSG_TRUNC ) ; pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\n"" , sock_len ) ; continue ; } if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;
",torvalds@linux/d8316f3991d207fe32881a9ac20241be8fa2bad0,CVE-2014-0077,https://github.com/torvalds/linux/commit/d8316f3991d207fe32881a9ac20241be8fa2bad0,2014-04-14T23:55Z,"<S2SV_StartBug> if ( ! headcount ) { <S2SV_EndBug> <S2SV_StartBug> msg . msg_iovlen = in ; <S2SV_EndBug> <S2SV_StartBug> sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err != sock_len ) ) { <S2SV_EndBug>"
441,CWE-200,"static int copy_to_user_tmpl ( struct xfrm_policy * xp , struct sk_buff * skb ) { struct xfrm_user_tmpl vec [ xfrm_max_depth ] ; int i ; if ( xp -> xfrm_nr == 0 ) return 0 ; for ( i = 0 ; i < xp -> xfrm_nr ; i ++ ) { struct xfrm_user_tmpl * up = & vec [ i ] ; struct xfrm_tmpl * kp = & xp -> xfrm_vec [ i ] ; memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; up -> family = kp -> encap_family ; memcpy ( & up -> saddr , & kp -> saddr , sizeof ( up -> saddr ) ) ; up -> reqid = kp -> reqid ; up -> mode = kp -> mode ; up -> share = kp -> share ; up -> optional = kp -> optional ; up -> aalgos = kp -> aalgos ; up -> ealgos = kp -> ealgos ; up -> calgos = kp -> calgos ; } return nla_put ( skb , xfrma_tmpl , sizeof ( struct xfrm_user_tmpl ) * xp -> xfrm_nr , vec ) ; }","<S2SV_ModStart> i ] ; memset ( up , 0 , sizeof ( * up ) ) ;
",torvalds@linux/1f86840f897717f86d523a13e99a447e6a5d2fa5,CVE-2012-6537,https://github.com/torvalds/linux/commit/1f86840f897717f86d523a13e99a447e6a5d2fa5,2013-03-15T20:55Z,"<S2SV_StartBug> memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; <S2SV_EndBug>"
2079,CWE-264,"struct crypto_alg * crypto_larval_lookup ( const char * name , u32 type , u32 mask ) { struct crypto_alg * alg ; if ( ! name ) return err_ptr ( - enoent ) ; mask &= ~ ( crypto_alg_larval | crypto_alg_dead ) ; type &= mask ; alg = crypto_alg_lookup ( name , type , mask ) ; if ( ! alg ) { request_module ( ""%s"" , name ) ; if ( ! ( ( type ^ crypto_alg_need_fallback ) & mask & crypto_alg_need_fallback ) ) request_module ( ""%s-all"" , name ) ; alg = crypto_alg_lookup ( name , type , mask ) ; } if ( alg ) return crypto_is_larval ( alg ) ? crypto_larval_wait ( alg ) : alg ; return crypto_larval_add ( name , type , mask ) ; }","<S2SV_ModStart> { request_module ( ""crypto-%s"" <S2SV_ModEnd> , name ) <S2SV_ModStart> ) request_module ( ""crypto-%s-all"" <S2SV_ModEnd> , name )
",torvalds@linux/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,CVE-2013-7421,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,2015-03-02T11:59Z,"<S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> <S2SV_StartBug> request_module ( ""%s-all"" , name ) ; <S2SV_EndBug>"
8428,CWE-74,"static int smtp_open ( struct connection * conn , bool esmtp ) { int rc ; if ( mutt_socket_open ( conn ) ) return - 1 ; rc = smtp_get_resp ( conn ) ; if ( rc != 0 ) return rc ; rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; # ifdef use_ssl enum quadoption ans = mutt_no ; if ( conn -> ssf ) ans = mutt_no ; else if ( c_sslforcetls ) ans = mutt_yes ; else if ( ( capabilities & smtp_cap_starttls ) && ( ( ans = query_quadoption ( c_sslstarttls , _ ( ""secure<s2sv_blank>connection<s2sv_blank>with<s2sv_blank>tls?"" ) ) ) == mutt_abort ) ) { return - 1 ; } if ( ans == mutt_yes ) { if ( mutt_socket_send ( conn , ""starttls\\r\\n"" ) < 0 ) return smtp_err_write ; rc = smtp_get_resp ( conn ) ; if ( rc != 0 ) return rc ; if ( mutt_ssl_starttls ( conn ) ) { mutt_error ( _ ( ""could<s2sv_blank>not<s2sv_blank>negotiate<s2sv_blank>tls<s2sv_blank>connection"" ) ) ; return - 1 ; } rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; } # endif if ( conn -> account . flags & mutt_acct_user ) { if ( ! ( capabilities & smtp_cap_auth ) ) { mutt_error ( _ ( ""smtp<s2sv_blank>server<s2sv_blank>does<s2sv_blank>not<s2sv_blank>support<s2sv_blank>authentication"" ) ) ; return - 1 ; } return smtp_auth ( conn ) ; } return 0 ; }","<S2SV_ModStart> rc = smtp_get_resp ( conn ) ; mutt_socket_empty
",neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc,CVE-2020-14954,https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc,2020-06-21T17:15Z,<S2SV_StartBug> rc = smtp_get_resp ( conn ) ; <S2SV_EndBug>
2902,CWE-310,"static noinline int create_pending_snapshot ( struct btrfs_trans_handle * trans , struct btrfs_fs_info * fs_info , struct btrfs_pending_snapshot * pending ) { struct btrfs_key key ; struct btrfs_root_item * new_root_item ; struct btrfs_root * tree_root = fs_info -> tree_root ; struct btrfs_root * root = pending -> root ; struct btrfs_root * parent_root ; struct btrfs_block_rsv * rsv ; struct inode * parent_inode ; struct btrfs_path * path ; struct btrfs_dir_item * dir_item ; struct dentry * parent ; struct dentry * dentry ; struct extent_buffer * tmp ; struct extent_buffer * old ; struct timespec cur_time = current_time ; int ret ; u64 to_reserve = 0 ; u64 index = 0 ; u64 objectid ; u64 root_flags ; uuid_le new_uuid ; path = btrfs_alloc_path ( ) ; if ( ! path ) { ret = pending -> error = - enomem ; goto path_alloc_fail ; } new_root_item = kmalloc ( sizeof ( * new_root_item ) , gfp_nofs ) ; if ( ! new_root_item ) { ret = pending -> error = - enomem ; goto root_item_alloc_fail ; } ret = btrfs_find_free_objectid ( tree_root , & objectid ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } btrfs_reloc_pre_snapshot ( trans , pending , & to_reserve ) ; if ( to_reserve > 0 ) { ret = btrfs_block_rsv_add ( root , & pending -> block_rsv , to_reserve , btrfs_reserve_no_flush ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } } ret = btrfs_qgroup_inherit ( trans , fs_info , root -> root_key . objectid , objectid , pending -> inherit ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } key . objectid = objectid ; key . offset = ( u64 ) - 1 ; key . type = btrfs_root_item_key ; rsv = trans -> block_rsv ; trans -> block_rsv = & pending -> block_rsv ; dentry = pending -> dentry ; parent = dget_parent ( dentry ) ; parent_inode = parent -> d_inode ; parent_root = btrfs_i ( parent_inode ) -> root ; record_root_in_trans ( trans , parent_root ) ; ret = btrfs_set_inode_index ( parent_inode , & index ) ; bug_on ( ret ) ; dir_item = btrfs_lookup_dir_item ( null , parent_root , path , btrfs_ino ( parent_inode ) , dentry -> d_name . name , dentry -> d_name . len , 0 ) ; if ( dir_item != null && ! is_err ( dir_item ) ) { pending -> error = - eexist ; goto fail ; } else if ( is_err ( dir_item ) ) { ret = ptr_err ( dir_item ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_release_path ( path ) ; ret = btrfs_run_delayed_items ( trans , root ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } record_root_in_trans ( trans , root ) ; btrfs_set_root_last_snapshot ( & root -> root_item , trans -> transid ) ; memcpy ( new_root_item , & root -> root_item , sizeof ( * new_root_item ) ) ; btrfs_check_and_init_root_item ( new_root_item ) ; root_flags = btrfs_root_flags ( new_root_item ) ; if ( pending -> readonly ) root_flags |= btrfs_root_subvol_rdonly ; else root_flags &= ~ btrfs_root_subvol_rdonly ; btrfs_set_root_flags ( new_root_item , root_flags ) ; btrfs_set_root_generation_v2 ( new_root_item , trans -> transid ) ; uuid_le_gen ( & new_uuid ) ; memcpy ( new_root_item -> uuid , new_uuid . b , btrfs_uuid_size ) ; memcpy ( new_root_item -> parent_uuid , root -> root_item . uuid , btrfs_uuid_size ) ; new_root_item -> otime . sec = cpu_to_le64 ( cur_time . tv_sec ) ; new_root_item -> otime . nsec = cpu_to_le32 ( cur_time . tv_nsec ) ; btrfs_set_root_otransid ( new_root_item , trans -> transid ) ; memset ( & new_root_item -> stime , 0 , sizeof ( new_root_item -> stime ) ) ; memset ( & new_root_item -> rtime , 0 , sizeof ( new_root_item -> rtime ) ) ; btrfs_set_root_stransid ( new_root_item , 0 ) ; btrfs_set_root_rtransid ( new_root_item , 0 ) ; old = btrfs_lock_root_node ( root ) ; ret = btrfs_cow_block ( trans , root , old , null , 0 , & old ) ; if ( ret ) { btrfs_tree_unlock ( old ) ; free_extent_buffer ( old ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_set_lock_blocking ( old ) ; ret = btrfs_copy_root ( trans , root , old , & tmp , objectid ) ; btrfs_tree_unlock ( old ) ; free_extent_buffer ( old ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } root -> force_cow = 1 ; smp_wmb ( ) ; btrfs_set_root_node ( new_root_item , tmp ) ; key . offset = trans -> transid ; ret = btrfs_insert_root ( trans , tree_root , & key , new_root_item ) ; btrfs_tree_unlock ( tmp ) ; free_extent_buffer ( tmp ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_add_root_ref ( trans , tree_root , objectid , parent_root -> root_key . objectid , btrfs_ino ( parent_inode ) , index , dentry -> d_name . name , dentry -> d_name . len ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } key . offset = ( u64 ) - 1 ; pending -> snap = btrfs_read_fs_root_no_name ( root -> fs_info , & key ) ; if ( is_err ( pending -> snap ) ) { ret = ptr_err ( pending -> snap ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_reloc_post_snapshot ( trans , pending ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_run_delayed_refs ( trans , root , ( unsigned long ) - 1 ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_insert_dir_item ( trans , parent_root , dentry -> d_name . name , dentry -> d_name . len , parent_inode , & key , btrfs_ft_dir , index ) ; bug_on ( ret == - eexist ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + dentry -> d_name . len * 2 ) ; parent_inode -> i_mtime = parent_inode -> i_ctime = current_time ; ret = btrfs_update_inode_fallback ( trans , parent_root , parent_inode ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; fail : dput ( parent ) ; trans -> block_rsv = rsv ; no_free_objectid : kfree ( new_root_item ) ; root_item_alloc_fail : btrfs_free_path ( path ) ; path_alloc_fail : btrfs_block_rsv_release ( root , & pending -> block_rsv , ( u64 ) - 1 ) ; return ret ; }","<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
",torvalds@linux/9c52057c698fb96f8f07e7a4bcf4801a092bda89,CVE-2012-5375,https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89,2013-02-18T11:56Z,<S2SV_StartBug> BUG_ON ( ret == - EEXIST ) ; <S2SV_EndBug>
7253,CWE-401,"int crypto_reportstat ( struct sk_buff * in_skb , struct nlmsghdr * in_nlh , struct nlattr * * attrs ) { struct net * net = sock_net ( in_skb -> sk ) ; struct crypto_user_alg * p = nlmsg_data ( in_nlh ) ; struct crypto_alg * alg ; struct sk_buff * skb ; struct crypto_dump_info info ; int err ; if ( ! null_terminated ( p -> cru_name ) || ! null_terminated ( p -> cru_driver_name ) ) return - einval ; alg = crypto_alg_match ( p , 0 ) ; if ( ! alg ) return - enoent ; err = - enomem ; skb = nlmsg_new ( nlmsg_default_size , gfp_atomic ) ; if ( ! skb ) goto drop_alg ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = in_nlh -> nlmsg_seq ; info . nlmsg_flags = 0 ; err = crypto_reportstat_alg ( alg , & info ) ; drop_alg : crypto_mod_put ( alg ) ; if ( err ) return err ; return nlmsg_unicast ( net -> crypto_nlsk , skb , netlink_cb ( in_skb ) . portid ) ; }","<S2SV_ModStart> ( err ) { kfree_skb ( skb ) ; return err ; } <S2SV_ModEnd> return nlmsg_unicast (
",torvalds@linux/c03b04dcdba1da39903e23cc4d072abf8f68f2dd,CVE-2019-19050,https://github.com/torvalds/linux/commit/c03b04dcdba1da39903e23cc4d072abf8f68f2dd,2019-11-18T06:15Z,<S2SV_StartBug> return err ; <S2SV_EndBug>
7111,CWE-125,"static void printflow ( u_int16_t id , struct ndpi_flow_info * flow , u_int16_t thread_id ) { file * out = results_file ? results_file : stdout ; u_int8_t known_tls ; char buf [ 32 ] , buf1 [ 64 ] ; u_int i ; double dos_ge_score ; double dos_slow_score ; double dos_hulk_score ; double ddos_score ; double hearthbleed_score ; double ftp_patator_score ; double ssh_patator_score ; double inf_score ; if ( csv_fp != null ) { float data_ratio = ndpi_data_ratio ( flow -> src2dst_bytes , flow -> dst2src_bytes ) ; double f = ( double ) flow -> first_seen , l = ( double ) flow -> last_seen ; dos_ge_score = dos_goldeneye_score ( flow ) ; dos_slow_score = dos_slow_score ( flow ) ; dos_hulk_score = dos_hulk_score ( flow ) ; ddos_score = ddos_score ( flow ) ; hearthbleed_score = hearthbleed_score ( flow ) ; ftp_patator_score = ftp_patator_score ( flow ) ; ssh_patator_score = ssh_patator_score ( flow ) ; inf_score = infiltration_score ( flow ) ; double benign_score = dos_ge_score < 1 && dos_slow_score < 1 && dos_hulk_score < 1 && ddos_score < 1 && hearthbleed_score < 1 && ftp_patator_score < 1 && ssh_patator_score < 1 && inf_score < 1 ? 1.1 : 0 ; fprintf ( csv_fp , ""%u,%u,%.3f,%.3f,%.3f,%s,%u,%s,%u,"" , flow -> flow_id , flow -> protocol , f / 1000.0 , l / 1000.0 , ( l - f ) / 1000.0 , flow -> src_name , ntohs ( flow -> src_port ) , flow -> dst_name , ntohs ( flow -> dst_port ) ) ; fprintf ( csv_fp , ""%s,"" , ndpi_protocol2id ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) ) ; fprintf ( csv_fp , ""%s,%s,"" , ndpi_protocol2name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) , flow -> host_server_name ) ; fprintf ( csv_fp , ""%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,"" , benign_score , dos_slow_score , dos_ge_score , dos_hulk_score , ddos_score , hearthbleed_score , ftp_patator_score , ssh_patator_score , inf_score ) ; fprintf ( csv_fp , ""%u,%llu,%llu,"" , flow -> src2dst_packets , ( long long unsigned int ) flow -> src2dst_bytes , ( long long unsigned int ) flow -> src2dst_goodput_bytes ) ; fprintf ( csv_fp , ""%u,%llu,%llu,"" , flow -> dst2src_packets , ( long long unsigned int ) flow -> dst2src_bytes , ( long long unsigned int ) flow -> dst2src_goodput_bytes ) ; fprintf ( csv_fp , ""%.3f,%s,"" , data_ratio , ndpi_data_ratio2str ( data_ratio ) ) ; fprintf ( csv_fp , ""%.1f,%.1f,"" , 100.0 * ( ( float ) flow -> src2dst_goodput_bytes / ( float ) ( flow -> src2dst_bytes + 1 ) ) , 100.0 * ( ( float ) flow -> dst2src_goodput_bytes / ( float ) ( flow -> dst2src_bytes + 1 ) ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> iat_flow ) , ndpi_data_average ( flow -> iat_flow ) , ndpi_data_max ( flow -> iat_flow ) , ndpi_data_stddev ( flow -> iat_flow ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> iat_c_to_s ) , ndpi_data_average ( flow -> iat_c_to_s ) , ndpi_data_max ( flow -> iat_c_to_s ) , ndpi_data_stddev ( flow -> iat_c_to_s ) , ndpi_data_min ( flow -> iat_s_to_c ) , ndpi_data_average ( flow -> iat_s_to_c ) , ndpi_data_max ( flow -> iat_s_to_c ) , ndpi_data_stddev ( flow -> iat_s_to_c ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> pktlen_c_to_s ) , ndpi_data_average ( flow -> pktlen_c_to_s ) , ndpi_data_max ( flow -> pktlen_c_to_s ) , ndpi_data_stddev ( flow -> pktlen_c_to_s ) , ndpi_data_min ( flow -> pktlen_s_to_c ) , ndpi_data_average ( flow -> pktlen_s_to_c ) , ndpi_data_max ( flow -> pktlen_s_to_c ) , ndpi_data_stddev ( flow -> pktlen_s_to_c ) ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> cwr_count , flow -> ece_count , flow -> urg_count , flow -> ack_count , flow -> psh_count , flow -> rst_count , flow -> syn_count , flow -> fin_count ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> src2dst_cwr_count , flow -> src2dst_ece_count , flow -> src2dst_urg_count , flow -> src2dst_ack_count , flow -> src2dst_psh_count , flow -> src2dst_rst_count , flow -> src2dst_syn_count , flow -> src2dst_fin_count ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> dst2src_cwr_count , flow -> ece_count , flow -> urg_count , flow -> ack_count , flow -> psh_count , flow -> rst_count , flow -> syn_count , flow -> fin_count ) ; fprintf ( csv_fp , ""%u,%u,"" , flow -> c_to_s_init_win , flow -> s_to_c_init_win ) ; fprintf ( csv_fp , ""%s,%s,"" , ( flow -> ssh_tls . client_requested_server_name [ 0 ] != '\\0' ) ? flow -> ssh_tls . client_requested_server_name : """" , ( flow -> ssh_tls . server_info [ 0 ] != '\\0' ) ? flow -> ssh_tls . server_info : """" ) ; fprintf ( csv_fp , ""%s,%s,%s,%s,%s,"" , ( flow -> ssh_tls . ssl_version != 0 ) ? ndpi_ssl_version2str ( flow -> ssh_tls . ssl_version , & known_tls ) : ""0"" , ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) ? flow -> ssh_tls . ja3_client : """" , ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) ? is_unsafe_cipher ( flow -> ssh_tls . client_unsafe_cipher ) : ""0"" , ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) ? flow -> ssh_tls . ja3_server : """" , ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) ? is_unsafe_cipher ( flow -> ssh_tls . server_unsafe_cipher ) : ""0"" ) ; fprintf ( csv_fp , ""%s,%s,"" , flow -> ssh_tls . tls_alpn ? flow -> ssh_tls . tls_alpn : """" , flow -> ssh_tls . tls_supported_versions ? flow -> ssh_tls . tls_supported_versions : """" ) ; fprintf ( csv_fp , ""%s,%s,"" , flow -> ssh_tls . tls_issuerdn ? flow -> ssh_tls . tls_issuerdn : """" , flow -> ssh_tls . tls_subjectdn ? flow -> ssh_tls . tls_subjectdn : """" ) ; fprintf ( csv_fp , ""%s,%s"" , ( flow -> ssh_tls . client_hassh [ 0 ] != '\\0' ) ? flow -> ssh_tls . client_hassh : """" , ( flow -> ssh_tls . server_hassh [ 0 ] != '\\0' ) ? flow -> ssh_tls . server_hassh : """" ) ; fprintf ( csv_fp , "",%s"" , flow -> info ) ; } if ( ( verbose != 1 ) && ( verbose != 2 ) ) { if ( csv_fp && enable_joy_stats ) { flowgetbdmeanandvariance ( flow ) ; } if ( csv_fp ) fprintf ( csv_fp , ""\\n"" ) ; return ; } if ( csv_fp || ( verbose > 1 ) ) { # if 1 fprintf ( out , ""\\t%u"" , id ) ; # else fprintf ( out , ""\\t%u(%u)"" , id , flow -> flow_id ) ; # endif fprintf ( out , ""\\t%s<s2sv_blank>"" , ipproto2name ( flow -> protocol ) ) ; fprintf ( out , ""%s%s%s:%u<s2sv_blank>%s<s2sv_blank>%s%s%s:%u<s2sv_blank>"" , ( flow -> ip_version == 6 ) ? ""["" : """" , flow -> src_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> src_port ) , flow -> bidirectional ? ""<->"" : ""->"" , ( flow -> ip_version == 6 ) ? ""["" : """" , flow -> dst_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> dst_port ) ) ; if ( flow -> vlan_id > 0 ) fprintf ( out , ""[vlan:<s2sv_blank>%u]"" , flow -> vlan_id ) ; if ( enable_payload_analyzer ) fprintf ( out , ""[flowid:<s2sv_blank>%u]"" , flow -> flow_id ) ; } if ( enable_joy_stats ) { flowgetbdmeanandvariance ( flow ) ; fflush ( out ) ; fprintf ( out , ""[score:<s2sv_blank>%.4f]"" , flow -> entropy . score ) ; } if ( csv_fp ) fprintf ( csv_fp , ""\\n"" ) ; fprintf ( out , ""[proto:<s2sv_blank>"" ) ; if ( flow -> tunnel_type != ndpi_no_tunnel ) fprintf ( out , ""%s:"" , ndpi_tunnel2str ( flow -> tunnel_type ) ) ; fprintf ( out , ""%s/%s]"" , ndpi_protocol2id ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) , ndpi_protocol2name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf1 , sizeof ( buf1 ) ) ) ; if ( flow -> detected_protocol . category != 0 ) fprintf ( out , ""[cat:<s2sv_blank>%s/%u]"" , ndpi_category_get_name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol . category ) , ( unsigned int ) flow -> detected_protocol . category ) ; fprintf ( out , ""[%u<s2sv_blank>pkts/%llu<s2sv_blank>bytes<s2sv_blank>"" , flow -> src2dst_packets , ( long long unsigned int ) flow -> src2dst_bytes ) ; fprintf ( out , ""%s<s2sv_blank>%u<s2sv_blank>pkts/%llu<s2sv_blank>bytes]"" , ( flow -> dst2src_packets > 0 ) ? ""<->"" : ""->"" , flow -> dst2src_packets , ( long long unsigned int ) flow -> dst2src_bytes ) ; fprintf ( out , ""[goodput<s2sv_blank>ratio:<s2sv_blank>%.0f/%.0f]"" , 100.0 * ( ( float ) flow -> src2dst_goodput_bytes / ( float ) ( flow -> src2dst_bytes + 1 ) ) , 100.0 * ( ( float ) flow -> dst2src_goodput_bytes / ( float ) ( flow -> dst2src_bytes + 1 ) ) ) ; if ( flow -> last_seen > flow -> first_seen ) fprintf ( out , ""[%.2f<s2sv_blank>sec]"" , ( ( float ) ( flow -> last_seen - flow -> first_seen ) ) / ( float ) 1000 ) ; else fprintf ( out , ""[<<s2sv_blank>1<s2sv_blank>sec]"" ) ; if ( flow -> telnet . username [ 0 ] != '\\0' ) fprintf ( out , ""[username:<s2sv_blank>%s]"" , flow -> telnet . username ) ; if ( flow -> telnet . password [ 0 ] != '\\0' ) fprintf ( out , ""[password:<s2sv_blank>%s]"" , flow -> telnet . password ) ; if ( flow -> host_server_name [ 0 ] != '\\0' ) fprintf ( out , ""[host:<s2sv_blank>%s]"" , flow -> host_server_name ) ; if ( flow -> info [ 0 ] != '\\0' ) fprintf ( out , ""[%s]"" , flow -> info ) ; if ( flow -> flow_extra_info [ 0 ] != '\\0' ) fprintf ( out , ""[%s]"" , flow -> flow_extra_info ) ; if ( ( flow -> src2dst_packets + flow -> dst2src_packets ) > 5 ) { if ( flow -> iat_c_to_s && flow -> iat_s_to_c ) { float data_ratio = ndpi_data_ratio ( flow -> src2dst_bytes , flow -> dst2src_bytes ) ; fprintf ( out , ""[bytes<s2sv_blank>ratio:<s2sv_blank>%.3f<s2sv_blank>(%s)]"" , data_ratio , ndpi_data_ratio2str ( data_ratio ) ) ; fprintf ( out , ""[iat<s2sv_blank>c2s/s2c<s2sv_blank>min/avg/max/stddev:<s2sv_blank>%u/%u<s2sv_blank>%.0f/%.0f<s2sv_blank>%u/%u<s2sv_blank>%.0f/%.0f]"" , ndpi_data_min ( flow -> iat_c_to_s ) , ndpi_data_min ( flow -> iat_s_to_c ) , ( float ) ndpi_data_average ( flow -> iat_c_to_s ) , ( float ) ndpi_data_average ( flow -> iat_s_to_c ) , ndpi_data_max ( flow -> iat_c_to_s ) , ndpi_data_max ( flow -> iat_s_to_c ) , ( float ) ndpi_data_stddev ( flow -> iat_c_to_s ) , ( float ) ndpi_data_stddev ( flow -> iat_s_to_c ) ) ; fprintf ( out , ""[pkt<s2sv_blank>len<s2sv_blank>c2s/s2c<s2sv_blank>min/avg/max/stddev:<s2sv_blank>%u/%u<s2sv_blank>%.0f/%.0f<s2sv_blank>%u/%u<s2sv_blank>%.0f/%.0f]"" , ndpi_data_min ( flow -> pktlen_c_to_s ) , ndpi_data_min ( flow -> pktlen_s_to_c ) , ndpi_data_average ( flow -> pktlen_c_to_s ) , ndpi_data_average ( flow -> pktlen_s_to_c ) , ndpi_data_max ( flow -> pktlen_c_to_s ) , ndpi_data_max ( flow -> pktlen_s_to_c ) , ndpi_data_stddev ( flow -> pktlen_c_to_s ) , ndpi_data_stddev ( flow -> pktlen_s_to_c ) ) ; } } if ( flow -> http . url [ 0 ] != '\\0' ) { ndpi_risk_enum risk = ndpi_validate_url ( flow -> http . url ) ; if ( risk != ndpi_no_risk ) ndpi_set_bit ( flow -> risk , risk ) ; fprintf ( out , ""[url:<s2sv_blank>%s[statuscode:<s2sv_blank>%u]"" , flow -> http . url , flow -> http . response_status_code ) ; if ( flow -> http . content_type [ 0 ] != '\\0' ) fprintf ( out , ""[contenttype:<s2sv_blank>%s]"" , flow -> http . content_type ) ; if ( flow -> http . user_agent [ 0 ] != '\\0' ) fprintf ( out , ""[useragent:<s2sv_blank>%s]"" , flow -> http . user_agent ) ; } if ( flow -> risk ) { u_int i ; fprintf ( out , ""[risk:<s2sv_blank>"" ) ; for ( i = 0 ; i < ndpi_max_risk ; i ++ ) if ( ndpi_isset_bit ( flow -> risk , i ) ) fprintf ( out , ""**<s2sv_blank>%s<s2sv_blank>**"" , ndpi_risk2str ( i ) ) ; fprintf ( out , ""]"" ) ; } if ( flow -> ssh_tls . ssl_version != 0 ) fprintf ( out , ""[%s]"" , ndpi_ssl_version2str ( flow -> ssh_tls . ssl_version , & known_tls ) ) ; if ( flow -> ssh_tls . client_requested_server_name [ 0 ] != '\\0' ) fprintf ( out , ""[client:<s2sv_blank>%s]"" , flow -> ssh_tls . client_requested_server_name ) ; if ( flow -> ssh_tls . client_hassh [ 0 ] != '\\0' ) fprintf ( out , ""[hassh-c:<s2sv_blank>%s]"" , flow -> ssh_tls . client_hassh ) ; if ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) fprintf ( out , ""[ja3c:<s2sv_blank>%s%s]"" , flow -> ssh_tls . ja3_client , print_cipher ( flow -> ssh_tls . client_unsafe_cipher ) ) ; if ( flow -> ssh_tls . server_info [ 0 ] != '\\0' ) fprintf ( out , ""[server:<s2sv_blank>%s]"" , flow -> ssh_tls . server_info ) ; if ( flow -> ssh_tls . server_names ) fprintf ( out , ""[servernames:<s2sv_blank>%s]"" , flow -> ssh_tls . server_names ) ; if ( flow -> ssh_tls . server_hassh [ 0 ] != '\\0' ) fprintf ( out , ""[hassh-s:<s2sv_blank>%s]"" , flow -> ssh_tls . server_hassh ) ; if ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) fprintf ( out , ""[ja3s:<s2sv_blank>%s%s]"" , flow -> ssh_tls . ja3_server , print_cipher ( flow -> ssh_tls . server_unsafe_cipher ) ) ; if ( flow -> ssh_tls . tls_issuerdn ) fprintf ( out , ""[issuer:<s2sv_blank>%s]"" , flow -> ssh_tls . tls_issuerdn ) ; if ( flow -> ssh_tls . tls_subjectdn ) fprintf ( out , ""[subject:<s2sv_blank>%s]"" , flow -> ssh_tls . tls_subjectdn ) ; if ( ( flow -> detected_protocol . master_protocol == ndpi_protocol_tls ) || ( flow -> detected_protocol . app_protocol == ndpi_protocol_tls ) ) { if ( flow -> ssh_tls . sha1_cert_fingerprint_set ) { fprintf ( out , ""[certificate<s2sv_blank>sha-1:<s2sv_blank>"" ) ; for ( i = 0 ; i < 20 ; i ++ ) fprintf ( out , ""%s%02x"" , ( i > 0 ) ? "":"" : """" , flow -> ssh_tls . sha1_cert_fingerprint [ i ] & 0xff ) ; fprintf ( out , ""]"" ) ; } } if ( flow -> ssh_tls . notbefore && flow -> ssh_tls . notafter ) { char notbefore [ 32 ] , notafter [ 32 ] ; struct tm a , b ; struct tm * before = gmtime_r ( & flow -> ssh_tls . notbefore , & a ) ; struct tm * after = gmtime_r ( & flow -> ssh_tls . notafter , & b ) ; strftime ( notbefore , sizeof ( notbefore ) , ""%f<s2sv_blank>%t"" , before ) ; strftime ( notafter , sizeof ( notafter ) , ""%f<s2sv_blank>%t"" , after ) ; fprintf ( out , ""[validity:<s2sv_blank>%s<s2sv_blank>-<s2sv_blank>%s]"" , notbefore , notafter ) ; } if ( flow -> ssh_tls . server_cipher != '\\0' ) fprintf ( out , ""[cipher:<s2sv_blank>%s]"" , ndpi_cipher2str ( flow -> ssh_tls . server_cipher ) ) ; if ( flow -> bittorent_hash [ 0 ] != '\\0' ) fprintf ( out , ""[bt<s2sv_blank>hash:<s2sv_blank>%s]"" , flow -> bittorent_hash ) ; if ( flow -> dhcp_fingerprint [ 0 ] != '\\0' ) fprintf ( out , ""[dhcp<s2sv_blank>fingerprint:<s2sv_blank>%s]"" , flow -> dhcp_fingerprint ) ; if ( flow -> has_human_readeable_strings ) fprintf ( out , ""[plain<s2sv_blank>text<s2sv_blank>(%s)]"" , flow -> human_readeable_string_buffer ) ; fprintf ( out , ""\\n"" ) ; }","<S2SV_ModStart> ( out , ""[URL:<S2SV_blank>%s][StatusCode:<S2SV_blank>%u]"" <S2SV_ModEnd> , flow -> <S2SV_ModStart> ( out , ""[Content-Type:<S2SV_blank>%s]"" <S2SV_ModEnd> , flow -> <S2SV_ModStart> ( out , ""[User-Agent:<S2SV_blank>%s]"" <S2SV_ModEnd> , flow ->
",ntop@nDPI/b7e666e465f138ae48ab81976726e67deed12701,CVE-2020-15472,https://github.com/ntop/nDPI/commit/b7e666e465f138ae48ab81976726e67deed12701,2020-07-01T11:15Z,"<S2SV_StartBug> fprintf ( out , ""[URL:<S2SV_blank>%s[StatusCode:<S2SV_blank>%u]"" , <S2SV_EndBug> <S2SV_StartBug> fprintf ( out , ""[ContentType:<S2SV_blank>%s]"" , flow -> http . content_type ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( out , ""[UserAgent:<S2SV_blank>%s]"" , flow -> http . user_agent ) ; <S2SV_EndBug>"
912,CWE-399,"void unix_inflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; spin_lock ( & unix_gc_lock ) ; if ( s ) { struct unix_sock * u = unix_sk ( s ) ; if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { bug_on ( ! list_empty ( & u -> link ) ) ; list_add_tail ( & u -> link , & gc_inflight_list ) ; } else { bug_on ( list_empty ( & u -> link ) ) ; } unix_tot_inflight ++ ; } fp -> f_cred -> user -> unix_inflight ++ ; spin_unlock ( & unix_gc_lock ) ; }","<S2SV_ModStart> void unix_inflight ( struct user_struct * user , <S2SV_ModStart> ++ ; } <S2SV_ModEnd> user -> unix_inflight
",torvalds@linux/415e3d3e90ce9e18727e8843ae343eda5a58fad6,CVE-2016-2550,https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6,2016-04-27T17:59Z,<S2SV_StartBug> void unix_inflight ( struct file * fp ) <S2SV_EndBug> <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_EndBug>
5291,CWE-476,"jas_image_t * jp2_decode ( jas_stream_t * in , const char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; jas_dbglog ( 100 , ( ""jp2_decode(%p,<s2sv_blank>\\""%s\\"")\\n"" , in , optstr ) ) ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( ""error:<s2sv_blank>cannot<s2sv_blank>get<s2sv_blank>box\\n"" ) ; goto error ; } if ( box -> type != jp2_box_jp ) { jas_eprintf ( ""error:<s2sv_blank>expecting<s2sv_blank>signature<s2sv_blank>box\\n"" ) ; goto error ; } if ( box -> data . jp . magic != jp2_jp_magic ) { jas_eprintf ( ""incorrect<s2sv_blank>magic<s2sv_blank>number\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != jp2_box_ftyp ) { jas_eprintf ( ""expecting<s2sv_blank>file<s2sv_blank>type<s2sv_blank>box\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( ""got<s2sv_blank>box<s2sv_blank>type<s2sv_blank>%s\\n"" , box -> info -> name ) ; } switch ( box -> type ) { case jp2_box_jp2c : found = 1 ; break ; case jp2_box_ihdr : if ( ! dec -> ihdr ) { dec -> ihdr = box ; box = 0 ; } break ; case jp2_box_bpcc : if ( ! dec -> bpcc ) { dec -> bpcc = box ; box = 0 ; } break ; case jp2_box_cdef : if ( ! dec -> cdef ) { dec -> cdef = box ; box = 0 ; } break ; case jp2_box_pclr : if ( ! dec -> pclr ) { dec -> pclr = box ; box = 0 ; } break ; case jp2_box_cmap : if ( ! dec -> cmap ) { dec -> cmap = box ; box = 0 ; } break ; case jp2_box_colr : if ( ! dec -> colr ) { dec -> colr = box ; box = 0 ; } break ; } if ( box ) { jp2_box_destroy ( box ) ; box = 0 ; } if ( found ) { break ; } } if ( ! found ) { jas_eprintf ( ""error:<s2sv_blank>no<s2sv_blank>code<s2sv_blank>stream<s2sv_blank>found\\n"" ) ; goto error ; } if ( ! ( dec -> image = jpc_decode ( in , optstr ) ) ) { jas_eprintf ( ""error:<s2sv_blank>cannot<s2sv_blank>decode<s2sv_blank>code<s2sv_blank>stream\\n"" ) ; goto error ; } if ( ! dec -> ihdr ) { jas_eprintf ( ""error:<s2sv_blank>missing<s2sv_blank>ihdr<s2sv_blank>box\\n"" ) ; goto error ; } if ( dec -> ihdr -> data . ihdr . numcmpts != jas_cast ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""warning:<s2sv_blank>number<s2sv_blank>of<s2sv_blank>components<s2sv_blank>mismatch\\n"" ) ; } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<s2sv_blank>no<s2sv_blank>components\\n"" ) ; goto error ; } samedtype = true ; dtype = jas_image_cmptdtype ( dec -> image , 0 ) ; for ( i = 1 ; i < jas_cast ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) { samedtype = false ; break ; } } if ( ( samedtype && dec -> ihdr -> data . ihdr . bpc != jp2_dtypetobpc ( dtype ) ) || ( ! samedtype && dec -> ihdr -> data . ihdr . bpc != jp2_ihdr_bpcnull ) ) { jas_eprintf ( ""warning:<s2sv_blank>component<s2sv_blank>data<s2sv_blank>type<s2sv_blank>mismatch<s2sv_blank>(ihdr)\\n"" ) ; } if ( dec -> ihdr -> data . ihdr . comptype != jp2_ihdr_comptype ) { jas_eprintf ( ""error:<s2sv_blank>unsupported<s2sv_blank>compression<s2sv_blank>type\\n"" ) ; goto error ; } if ( dec -> bpcc ) { if ( dec -> bpcc -> data . bpcc . numcmpts != jas_cast ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""warning:<s2sv_blank>number<s2sv_blank>of<s2sv_blank>components<s2sv_blank>mismatch\\n"" ) ; } if ( ! samedtype ) { for ( i = 0 ; i < jas_cast ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != jp2_bpctodtype ( dec -> bpcc -> data . bpcc . bpcs [ i ] ) ) { jas_eprintf ( ""warning:<s2sv_blank>component<s2sv_blank>data<s2sv_blank>type<s2sv_blank>mismatch<s2sv_blank>(bpcc)\\n"" ) ; } } } else { jas_eprintf ( ""warning:<s2sv_blank>superfluous<s2sv_blank>bpcc<s2sv_blank>box\\n"" ) ; } } if ( ! dec -> colr ) { jas_eprintf ( ""error:<s2sv_blank>no<s2sv_blank>colr<s2sv_blank>box\\n"" ) ; goto error ; } switch ( dec -> colr -> data . colr . method ) { case jp2_colr_enum : jas_image_setclrspc ( dec -> image , jp2_getcs ( & dec -> colr -> data . colr ) ) ; break ; case jp2_colr_icc : iccprof = jas_iccprof_createfrombuf ( dec -> colr -> data . colr . iccp , dec -> colr -> data . colr . iccplen ) ; if ( ! iccprof ) { jas_eprintf ( ""error:<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>parse<s2sv_blank>icc<s2sv_blank>profile\\n"" ) ; goto error ; } jas_iccprof_gethdr ( iccprof , & icchdr ) ; jas_eprintf ( ""icc<s2sv_blank>profile<s2sv_blank>cs<s2sv_blank>%08x\\n"" , icchdr . colorspc ) ; jas_image_setclrspc ( dec -> image , fromiccpcs ( icchdr . colorspc ) ) ; dec -> image -> cmprof_ = jas_cmprof_createfromiccprof ( iccprof ) ; if ( ! dec -> image -> cmprof_ ) { jas_iccprof_destroy ( iccprof ) ; goto error ; } jas_iccprof_destroy ( iccprof ) ; break ; } if ( dec -> cmap && ! dec -> pclr ) { jas_eprintf ( ""warning:<s2sv_blank>missing<s2sv_blank>pclr<s2sv_blank>box<s2sv_blank>or<s2sv_blank>superfluous<s2sv_blank>cmap<s2sv_blank>box\\n"" ) ; jp2_box_destroy ( dec -> cmap ) ; dec -> cmap = 0 ; } if ( ! dec -> cmap && dec -> pclr ) { jas_eprintf ( ""warning:<s2sv_blank>missing<s2sv_blank>cmap<s2sv_blank>box<s2sv_blank>or<s2sv_blank>superfluous<s2sv_blank>pclr<s2sv_blank>box\\n"" ) ; jp2_box_destroy ( dec -> pclr ) ; dec -> pclr = 0 ; } dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans : jas_cast ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; if ( dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= jas_cast ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""error:<s2sv_blank>invalid<s2sv_blank>component<s2sv_blank>number<s2sv_blank>in<s2sv_blank>cmap<s2sv_blank>box\\n"" ) ; goto error ; } if ( dec -> cmap -> data . cmap . ents [ i ] . pcol >= dec -> pclr -> data . pclr . numchans ) { jas_eprintf ( ""error:<s2sv_blank>invalid<s2sv_blank>cmap<s2sv_blank>lut<s2sv_blank>index\\n"" ) ; goto error ; } } } if ( ! ( dec -> chantocmptlut = jas_alloc2 ( dec -> numchans , sizeof ( uint_fast16_t ) ) ) ) { jas_eprintf ( ""error:<s2sv_blank>no<s2sv_blank>memory\\n"" ) ; goto error ; } if ( ! dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { dec -> chantocmptlut [ i ] = i ; } } else { cmapd = & dec -> cmap -> data . cmap ; pclrd = & dec -> pclr -> data . pclr ; cdefd = & dec -> cdef -> data . cdef ; for ( channo = 0 ; channo < cmapd -> numchans ; ++ channo ) { cmapent = & cmapd -> ents [ channo ] ; if ( cmapent -> map == jp2_cmap_direct ) { dec -> chantocmptlut [ channo ] = channo ; } else if ( cmapent -> map == jp2_cmap_palette ) { if ( ! pclrd -> numlutents ) { goto error ; } lutents = jas_alloc2 ( pclrd -> numlutents , sizeof ( int_fast32_t ) ) ; if ( ! lutents ) { goto error ; } for ( i = 0 ; i < pclrd -> numlutents ; ++ i ) { lutents [ i ] = pclrd -> lutdata [ cmapent -> pcol + i * pclrd -> numchans ] ; } newcmptno = jas_image_numcmpts ( dec -> image ) ; jas_image_depalettize ( dec -> image , cmapent -> cmptno , pclrd -> numlutents , lutents , jp2_bpctodtype ( pclrd -> bpc [ cmapent -> pcol ] ) , newcmptno ) ; dec -> chantocmptlut [ channo ] = newcmptno ; jas_free ( lutents ) ; # if 0 if ( dec -> cdef ) { cdefent = jp2_cdef_lookup ( cdefd , channo ) ; if ( ! cdefent ) { abort ( ) ; } jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , cdefent -> type , cdefent -> assoc ) ) ; } else { jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , channo + 1 ) ) ; } # else ( void ) cdefd ; # endif } else { jas_eprintf ( ""error:<s2sv_blank>invalid<s2sv_blank>mtyp<s2sv_blank>in<s2sv_blank>cmap<s2sv_blank>box\\n"" ) ; goto error ; } } } if ( dec -> numchans != jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<s2sv_blank>mismatch<s2sv_blank>in<s2sv_blank>number<s2sv_blank>of<s2sv_blank>components<s2sv_blank>(%d<s2sv_blank>!=<s2sv_blank>%d)\\n"" , dec -> numchans , jas_image_numcmpts ( dec -> image ) ) ; goto error ; } for ( i = 0 ; i < jas_cast ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { jas_image_setcmpttype ( dec -> image , i , jas_image_ct_unknown ) ; } if ( dec -> cdef ) { for ( i = 0 ; i < dec -> cdef -> data . cdef . numchans ; ++ i ) { if ( dec -> cdef -> data . cdef . ents [ i ] . channo >= dec -> numchans ) { jas_eprintf ( ""error:<s2sv_blank>invalid<s2sv_blank>channel<s2sv_blank>number<s2sv_blank>in<s2sv_blank>cdef<s2sv_blank>box\\n"" ) ; goto error ; } jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ dec -> cdef -> data . cdef . ents [ i ] . channo ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , dec -> cdef -> data . cdef . ents [ i ] . type , dec -> cdef -> data . cdef . ents [ i ] . assoc ) ) ; } } else { for ( i = 0 ; i < dec -> numchans ; ++ i ) { jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ i ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , i + 1 ) ) ; } } for ( i = jas_image_numcmpts ( dec -> image ) ; i > 0 ; -- i ) { if ( jas_image_cmpttype ( dec -> image , i - 1 ) == jas_image_ct_unknown ) { jas_image_delcmpt ( dec -> image , i - 1 ) ; } } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<s2sv_blank>no<s2sv_blank>components\\n"" ) ; goto error ; } # if 0 jas_eprintf ( ""no<s2sv_blank>of<s2sv_blank>components<s2sv_blank>is<s2sv_blank>%d\\n"" , jas_image_numcmpts ( dec -> image ) ) ; # endif image = dec -> image ; dec -> image = 0 ; jp2_dec_destroy ( dec ) ; return image ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( dec ) { jp2_dec_destroy ( dec ) ; } return 0 ; }","<S2SV_ModStart> { jas_eprintf ( ""error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> { jas_eprintf ( ""error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> { jas_eprintf ( ""error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; goto error <S2SV_ModEnd> ; } }
",jasper-software@jasper/41f214b121b837fa30d9ca5f2430212110f5cd9b,CVE-2021-26927,https://github.com/jasper-software/jasper/commit/41f214b121b837fa30d9ca5f2430212110f5cd9b,2021-02-23T20:15Z,"<S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> dec -> image ) ) ) { <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; <S2SV_EndBug>"
94,CWE-119,"static int create_qp_common ( struct mlx5_ib_dev * dev , struct ib_pd * pd , struct ib_qp_init_attr * init_attr , struct ib_udata * udata , struct mlx5_ib_qp * qp ) { struct mlx5_ib_resources * devr = & dev -> devr ; int inlen = mlx5_st_sz_bytes ( create_qp_in ) ; struct mlx5_core_dev * mdev = dev -> mdev ; struct mlx5_ib_create_qp_resp resp ; struct mlx5_ib_cq * send_cq ; struct mlx5_ib_cq * recv_cq ; unsigned long flags ; u32 uidx = mlx5_ib_default_uidx ; struct mlx5_ib_create_qp ucmd ; struct mlx5_ib_qp_base * base ; int mlx5_st ; void * qpc ; u32 * in ; int err ; mutex_init ( & qp -> mutex ) ; spin_lock_init ( & qp -> sq . lock ) ; spin_lock_init ( & qp -> rq . lock ) ; mlx5_st = to_mlx5_st ( init_attr -> qp_type ) ; if ( mlx5_st < 0 ) return - einval ; if ( init_attr -> rwq_ind_tbl ) { if ( ! udata ) return - enosys ; err = create_rss_raw_qp_tir ( dev , qp , pd , init_attr , udata ) ; return err ; } if ( init_attr -> create_flags & ib_qp_create_block_multicast_loopback ) { if ( ! mlx5_cap_gen ( mdev , block_lb_mc ) ) { mlx5_ib_dbg ( dev , ""block<s2sv_blank>multicast<s2sv_blank>loopback<s2sv_blank>isn\'t<s2sv_blank>supported\\n"" ) ; return - einval ; } else { qp -> flags |= mlx5_ib_qp_block_multicast_loopback ; } } if ( init_attr -> create_flags & ( ib_qp_create_cross_channel | ib_qp_create_managed_send | ib_qp_create_managed_recv ) ) { if ( ! mlx5_cap_gen ( mdev , cd ) ) { mlx5_ib_dbg ( dev , ""cross-channel<s2sv_blank>isn\'t<s2sv_blank>supported\\n"" ) ; return - einval ; } if ( init_attr -> create_flags & ib_qp_create_cross_channel ) qp -> flags |= mlx5_ib_qp_cross_channel ; if ( init_attr -> create_flags & ib_qp_create_managed_send ) qp -> flags |= mlx5_ib_qp_managed_send ; if ( init_attr -> create_flags & ib_qp_create_managed_recv ) qp -> flags |= mlx5_ib_qp_managed_recv ; } if ( init_attr -> qp_type == ib_qpt_ud && ( init_attr -> create_flags & ib_qp_create_ipoib_ud_lso ) ) if ( ! mlx5_cap_gen ( mdev , ipoib_basic_offloads ) ) { mlx5_ib_dbg ( dev , ""ipoib<s2sv_blank>ud<s2sv_blank>lso<s2sv_blank>qp<s2sv_blank>isn\'t<s2sv_blank>supported\\n"" ) ; return - eopnotsupp ; } if ( init_attr -> create_flags & ib_qp_create_scatter_fcs ) { if ( init_attr -> qp_type != ib_qpt_raw_packet ) { mlx5_ib_dbg ( dev , ""scatter<s2sv_blank>fcs<s2sv_blank>is<s2sv_blank>supported<s2sv_blank>only<s2sv_blank>for<s2sv_blank>raw<s2sv_blank>packet<s2sv_blank>qps"" ) ; return - eopnotsupp ; } if ( ! mlx5_cap_gen ( dev -> mdev , eth_net_offloads ) || ! mlx5_cap_eth ( dev -> mdev , scatter_fcs ) ) { mlx5_ib_dbg ( dev , ""scatter<s2sv_blank>fcs<s2sv_blank>isn\'t<s2sv_blank>supported\\n"" ) ; return - eopnotsupp ; } qp -> flags |= mlx5_ib_qp_cap_scatter_fcs ; } if ( init_attr -> sq_sig_type == ib_signal_all_wr ) qp -> sq_signal_bits = mlx5_wqe_ctrl_cq_update ; if ( init_attr -> create_flags & ib_qp_create_cvlan_stripping ) { if ( ! ( mlx5_cap_gen ( dev -> mdev , eth_net_offloads ) && mlx5_cap_eth ( dev -> mdev , vlan_cap ) ) || ( init_attr -> qp_type != ib_qpt_raw_packet ) ) return - eopnotsupp ; qp -> flags |= mlx5_ib_qp_cvlan_stripping ; } if ( pd && pd -> uobject ) { if ( ib_copy_from_udata ( & ucmd , udata , sizeof ( ucmd ) ) ) { mlx5_ib_dbg ( dev , ""copy<s2sv_blank>failed\\n"" ) ; return - efault ; } err = get_qp_user_index ( to_mucontext ( pd -> uobject -> context ) , & ucmd , udata -> inlen , & uidx ) ; if ( err ) return err ; qp -> wq_sig = ! ! ( ucmd . flags & mlx5_qp_flag_signature ) ; qp -> scat_cqe = ! ! ( ucmd . flags & mlx5_qp_flag_scatter_cqe ) ; if ( ucmd . flags & mlx5_qp_flag_tunnel_offloads ) { if ( init_attr -> qp_type != ib_qpt_raw_packet || ! tunnel_offload_supported ( mdev ) ) { mlx5_ib_dbg ( dev , ""tunnel<s2sv_blank>offload<s2sv_blank>isn\'t<s2sv_blank>supported\\n"" ) ; return - eopnotsupp ; } qp -> tunnel_offload_en = true ; } if ( init_attr -> create_flags & ib_qp_create_source_qpn ) { if ( init_attr -> qp_type != ib_qpt_ud || ( mlx5_cap_gen ( dev -> mdev , port_type ) != mlx5_cap_port_type_ib ) || ! mlx5_get_flow_namespace ( dev -> mdev , mlx5_flow_namespace_bypass ) ) { mlx5_ib_dbg ( dev , ""source<s2sv_blank>qp<s2sv_blank>option<s2sv_blank>isn\'t<s2sv_blank>supported\\n"" ) ; return - eopnotsupp ; } qp -> flags |= mlx5_ib_qp_underlay ; qp -> underlay_qpn = init_attr -> source_qpn ; } } else { qp -> wq_sig = ! ! wq_signature ; } base = ( init_attr -> qp_type == ib_qpt_raw_packet || qp -> flags & mlx5_ib_qp_underlay ) ? & qp -> raw_packet_qp . rq . base : & qp -> trans_qp . base ; qp -> has_rq = qp_has_rq ( init_attr ) ; err = set_rq_size ( dev , & init_attr -> cap , qp -> has_rq , qp , ( pd && pd -> uobject ) ? & ucmd : null ) ; if ( err ) { mlx5_ib_dbg ( dev , ""err<s2sv_blank>%d\\n"" , err ) ; return err ; } if ( pd ) { if ( pd -> uobject ) { __u32 max_wqes = 1 << mlx5_cap_gen ( mdev , log_max_qp_sz ) ; mlx5_ib_dbg ( dev , ""requested<s2sv_blank>sq_wqe_count<s2sv_blank>(%d)\\n"" , ucmd . sq_wqe_count ) ; if ( ucmd . rq_wqe_shift != qp -> rq . wqe_shift || ucmd . rq_wqe_count != qp -> rq . wqe_cnt ) { mlx5_ib_dbg ( dev , ""invalid<s2sv_blank>rq<s2sv_blank>params\\n"" ) ; return - einval ; } if ( ucmd . sq_wqe_count > max_wqes ) { mlx5_ib_dbg ( dev , ""requested<s2sv_blank>sq_wqe_count<s2sv_blank>(%d)<s2sv_blank>><s2sv_blank>max<s2sv_blank>allowed<s2sv_blank>(%d)\\n"" , ucmd . sq_wqe_count , max_wqes ) ; return - einval ; } if ( init_attr -> create_flags & mlx5_ib_create_qp_sqpn_qp1 ( ) ) { mlx5_ib_dbg ( dev , ""user-space<s2sv_blank>is<s2sv_blank>not<s2sv_blank>allowed<s2sv_blank>to<s2sv_blank>create<s2sv_blank>ud<s2sv_blank>qps<s2sv_blank>spoofing<s2sv_blank>as<s2sv_blank>qp1\\n"" ) ; return - einval ; } err = create_user_qp ( dev , pd , qp , udata , init_attr , & in , & resp , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , ""err<s2sv_blank>%d\\n"" , err ) ; } else { err = create_kernel_qp ( dev , init_attr , qp , & in , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , ""err<s2sv_blank>%d\\n"" , err ) ; } if ( err ) return err ; } else { in = kvzalloc ( inlen , gfp_kernel ) ; if ( ! in ) return - enomem ; qp -> create_type = mlx5_qp_empty ; } if ( is_sqp ( init_attr -> qp_type ) ) qp -> port = init_attr -> port_num ; qpc = mlx5_addr_of ( create_qp_in , in , qpc ) ; mlx5_set ( qpc , qpc , st , mlx5_st ) ; mlx5_set ( qpc , qpc , pm_state , mlx5_qp_pm_migrated ) ; if ( init_attr -> qp_type != mlx5_ib_qpt_reg_umr ) mlx5_set ( qpc , qpc , pd , to_mpd ( pd ? pd : devr -> p0 ) -> pdn ) ; else mlx5_set ( qpc , qpc , latency_sensitive , 1 ) ; if ( qp -> wq_sig ) mlx5_set ( qpc , qpc , wq_signature , 1 ) ; if ( qp -> flags & mlx5_ib_qp_block_multicast_loopback ) mlx5_set ( qpc , qpc , block_lb_mc , 1 ) ; if ( qp -> flags & mlx5_ib_qp_cross_channel ) mlx5_set ( qpc , qpc , cd_master , 1 ) ; if ( qp -> flags & mlx5_ib_qp_managed_send ) mlx5_set ( qpc , qpc , cd_slave_send , 1 ) ; if ( qp -> flags & mlx5_ib_qp_managed_recv ) mlx5_set ( qpc , qpc , cd_slave_receive , 1 ) ; if ( qp -> scat_cqe && is_connected ( init_attr -> qp_type ) ) { int rcqe_sz ; int scqe_sz ; rcqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> recv_cq ) ; scqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> send_cq ) ; if ( rcqe_sz == 128 ) mlx5_set ( qpc , qpc , cs_res , mlx5_res_scat_data64_cqe ) ; else mlx5_set ( qpc , qpc , cs_res , mlx5_res_scat_data32_cqe ) ; if ( init_attr -> sq_sig_type == ib_signal_all_wr ) { if ( scqe_sz == 128 ) mlx5_set ( qpc , qpc , cs_req , mlx5_req_scat_data64_cqe ) ; else mlx5_set ( qpc , qpc , cs_req , mlx5_req_scat_data32_cqe ) ; } } if ( qp -> rq . wqe_cnt ) { mlx5_set ( qpc , qpc , log_rq_stride , qp -> rq . wqe_shift - 4 ) ; mlx5_set ( qpc , qpc , log_rq_size , ilog2 ( qp -> rq . wqe_cnt ) ) ; } mlx5_set ( qpc , qpc , rq_type , get_rx_type ( qp , init_attr ) ) ; if ( qp -> sq . wqe_cnt ) { mlx5_set ( qpc , qpc , log_sq_size , ilog2 ( qp -> sq . wqe_cnt ) ) ; } else { mlx5_set ( qpc , qpc , no_sq , 1 ) ; if ( init_attr -> srq && init_attr -> srq -> srq_type == ib_srqt_tm ) mlx5_set ( qpc , qpc , offload_type , mlx5_qpc_offload_type_rndv ) ; } switch ( init_attr -> qp_type ) { case ib_qpt_xrc_tgt : mlx5_set ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; mlx5_set ( qpc , qpc , cqn_snd , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; mlx5_set ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; mlx5_set ( qpc , qpc , xrcd , to_mxrcd ( init_attr -> xrcd ) -> xrcdn ) ; break ; case ib_qpt_xrc_ini : mlx5_set ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; mlx5_set ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; mlx5_set ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; break ; default : if ( init_attr -> srq ) { mlx5_set ( qpc , qpc , xrcd , to_mxrcd ( devr -> x0 ) -> xrcdn ) ; mlx5_set ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( init_attr -> srq ) -> msrq . srqn ) ; } else { mlx5_set ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; mlx5_set ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s1 ) -> msrq . srqn ) ; } } if ( init_attr -> send_cq ) mlx5_set ( qpc , qpc , cqn_snd , to_mcq ( init_attr -> send_cq ) -> mcq . cqn ) ; if ( init_attr -> recv_cq ) mlx5_set ( qpc , qpc , cqn_rcv , to_mcq ( init_attr -> recv_cq ) -> mcq . cqn ) ; mlx5_set64 ( qpc , qpc , dbr_addr , qp -> db . dma ) ; if ( mlx5_cap_gen ( mdev , cqe_version ) == mlx5_cqe_version_v1 ) mlx5_set ( qpc , qpc , user_index , uidx ) ; if ( init_attr -> qp_type == ib_qpt_ud && ( init_attr -> create_flags & ib_qp_create_ipoib_ud_lso ) ) { mlx5_set ( qpc , qpc , ulp_stateless_offload_mode , 1 ) ; qp -> flags |= mlx5_ib_qp_lso ; } if ( init_attr -> create_flags & ib_qp_create_pci_write_end_padding ) { if ( ! mlx5_cap_gen ( dev -> mdev , end_pad ) ) { mlx5_ib_dbg ( dev , ""scatter<s2sv_blank>end<s2sv_blank>padding<s2sv_blank>is<s2sv_blank>not<s2sv_blank>supported\\n"" ) ; err = - eopnotsupp ; goto err ; } else if ( init_attr -> qp_type != ib_qpt_raw_packet ) { mlx5_set ( qpc , qpc , end_padding_mode , mlx5_wq_end_pad_mode_align ) ; } else { qp -> flags |= mlx5_ib_qp_pci_write_end_padding ; } } if ( inlen < 0 ) { err = - einval ; goto err ; } if ( init_attr -> qp_type == ib_qpt_raw_packet || qp -> flags & mlx5_ib_qp_underlay ) { qp -> raw_packet_qp . sq . ubuffer . buf_addr = ucmd . sq_buf_addr ; raw_packet_qp_copy_info ( qp , & qp -> raw_packet_qp ) ; err = create_raw_packet_qp ( dev , qp , in , inlen , pd ) ; } else { err = mlx5_core_create_qp ( dev -> mdev , & base -> mqp , in , inlen ) ; } if ( err ) { mlx5_ib_dbg ( dev , ""create<s2sv_blank>qp<s2sv_blank>failed\\n"" ) ; goto err_create ; } kvfree ( in ) ; base -> container_mibqp = qp ; base -> mqp . event = mlx5_ib_qp_event ; get_cqs ( init_attr -> qp_type , init_attr -> send_cq , init_attr -> recv_cq , & send_cq , & recv_cq ) ; spin_lock_irqsave ( & dev -> reset_flow_resource_lock , flags ) ; mlx5_ib_lock_cqs ( send_cq , recv_cq ) ; list_add_tail ( & qp -> qps_list , & dev -> qp_list ) ; if ( send_cq ) list_add_tail ( & qp -> cq_send_list , & send_cq -> list_send_qp ) ; if ( recv_cq ) list_add_tail ( & qp -> cq_recv_list , & recv_cq -> list_recv_qp ) ; mlx5_ib_unlock_cqs ( send_cq , recv_cq ) ; spin_unlock_irqrestore ( & dev -> reset_flow_resource_lock , flags ) ; return 0 ; err_create : if ( qp -> create_type == mlx5_qp_user ) destroy_qp_user ( dev , pd , qp , base ) ; else if ( qp -> create_type == mlx5_qp_kernel ) destroy_qp_kernel ( dev , qp ) ; err : kvfree ( in ) ; return err ; }","<S2SV_ModStart> struct mlx5_ib_create_qp_resp resp = { }
",torvalds@linux/0625b4ba1a5d4703c7fb01c497bd6c156908af00,CVE-2018-20855,https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00,2019-07-26T05:15Z,<S2SV_StartBug> struct mlx5_ib_create_qp_resp resp ; <S2SV_EndBug>
4843,CWE-787,"static int track_header ( vividasdemuxcontext * viv , avformatcontext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; aviocontext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , null , null , null , null ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return averror_eof ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return averror_eof ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , seek_set ) ; if ( num_video != 1 ) { av_log ( s , av_log_error , ""number<s2sv_blank>of<s2sv_blank>video<s2sv_blank>tracks<s2sv_blank>%d<s2sv_blank>is<s2sv_blank>not<s2sv_blank>1\\n"" , num_video ) ; return averror_patchwelcome ; } for ( i = 0 ; i < num_video ; i ++ ) { avstream * st = avformat_new_stream ( s , null ) ; int num , den ; if ( ! st ) return averror ( enomem ) ; st -> id = i ; st -> codecpar -> codec_type = avmedia_type_video ; st -> codecpar -> codec_id = av_codec_id_vp6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , seek_set ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , seek_set ) ; if ( viv -> num_audio != 1 ) av_log ( s , av_log_warning , ""number<s2sv_blank>of<s2sv_blank>audio<s2sv_blank>tracks<s2sv_blank>%d<s2sv_blank>is<s2sv_blank>not<s2sv_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; avstream * st = avformat_new_stream ( s , null ) ; if ( ! st ) return averror ( enomem ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = avmedia_type_audio ; st -> codecpar -> codec_id = av_codec_id_vorbis ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , seek_cur ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , seek_cur ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ; int xd_size = 0 ; int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > int_max / 2 - xd_size ) { return averror_invaliddata ; } data_len [ j ] = len ; xd_size += len ; } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ; if ( delta > data_len [ j ] ) { return averror_invaliddata ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; } offset += data_len [ j ] ; } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }","<S2SV_ModStart> int xd_size = 1 <S2SV_ModEnd> ; int data_len <S2SV_ModStart> xd_size += len + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ] ) ; av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> offset += delta <S2SV_ModStart> break ; } av_assert0 ( data_len [ j ] <= xd_size - offset ) ;
",FFmpeg@FFmpeg/27a99e2c7d450fef15594671eef4465c8a166bd7,CVE-2020-35964,https://github.com/FFmpeg/FFmpeg/commit/27a99e2c7d450fef15594671eef4465c8a166bd7,2021-01-03T19:15Z,<S2SV_StartBug> int xd_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> xd_size += len ; <S2SV_EndBug> <S2SV_StartBug> if ( delta > data_len [ j ] ) { <S2SV_EndBug> <S2SV_StartBug> offset += data_len [ j ] ; <S2SV_EndBug>
2874,CWE-200,"static void snd_timer_user_ccallback ( struct snd_timer_instance * timeri , int event , struct timespec * tstamp , unsigned long resolution ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread r1 ; unsigned long flags ; if ( event >= sndrv_timer_event_start && event <= sndrv_timer_event_pause ) tu -> tstamp = * tstamp ; if ( ( tu -> filter & ( 1 << event ) ) == 0 || ! tu -> tread ) return ; r1 . event = event ; r1 . tstamp = * tstamp ; r1 . val = resolution ; spin_lock_irqsave ( & tu -> qlock , flags ) ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; spin_unlock_irqrestore ( & tu -> qlock , flags ) ; kill_fasync ( & tu -> fasync , sigio , poll_in ) ; wake_up ( & tu -> qchange_sleep ) ; }","<S2SV_ModStart> ) return ; memset ( & r1 , 0 , sizeof ( r1 ) ) ;
",torvalds@linux/9a47e9cff994f37f7f0dbd9ae23740d0f64f9fe6,CVE-2016-4578,https://github.com/torvalds/linux/commit/9a47e9cff994f37f7f0dbd9ae23740d0f64f9fe6,2016-05-23T10:59Z,<S2SV_StartBug> r1 . event = event ; <S2SV_EndBug>
3063,CWE-119,"static int logi_dj_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * data , int size ) { struct dj_receiver_dev * djrcv_dev = hid_get_drvdata ( hdev ) ; struct dj_report * dj_report = ( struct dj_report * ) data ; unsigned long flags ; bool report_processed = false ; dbg_hid ( ""%s,<s2sv_blank>size:%d\\n"" , __func__ , size ) ; spin_lock_irqsave ( & djrcv_dev -> lock , flags ) ; if ( dj_report -> report_id == report_id_dj_short ) { switch ( dj_report -> report_type ) { case report_type_notif_device_paired : case report_type_notif_device_unpaired : logi_dj_recv_queue_notification ( djrcv_dev , dj_report ) ; break ; case report_type_notif_connection_status : if ( dj_report -> report_params [ connection_status_param_status ] == status_linkloss ) { logi_dj_recv_forward_null_report ( djrcv_dev , dj_report ) ; } break ; default : logi_dj_recv_forward_report ( djrcv_dev , dj_report ) ; } report_processed = true ; } spin_unlock_irqrestore ( & djrcv_dev -> lock , flags ) ; return report_processed ; }","<S2SV_ModStart> size ) ; if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n"" , __func__ , dj_report -> device_index ) ; return false ; }
",torvalds@linux/ad3e14d7c5268c2e24477c6ef54bbdf88add5d36,CVE-2014-3182,https://github.com/torvalds/linux/commit/ad3e14d7c5268c2e24477c6ef54bbdf88add5d36,2014-09-28T10:55Z,"<S2SV_StartBug> dbg_hid ( ""%s,<S2SV_blank>size:%d\\n"" , __func__ , size ) ; <S2SV_EndBug>"
4442,CWE-401,"struct resource_pool * dce112_create_resource_pool ( uint8_t num_virtual_links , struct dc * dc ) { struct dce110_resource_pool * pool = kzalloc ( sizeof ( struct dce110_resource_pool ) , gfp_kernel ) ; if ( ! pool ) return null ; if ( construct ( num_virtual_links , dc , pool ) ) return & pool -> base ; break_to_debugger ( ) ; return null ; }","<S2SV_ModStart> -> base ; kfree ( pool ) ;
",torvalds@linux/104c307147ad379617472dd91a5bcb368d72bd6d,CVE-2019-19082,https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d,2019-11-18T06:15Z,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug>
8084,CWE-400,"static int evtchn_fifo_percpu_deinit ( unsigned int cpu ) { __evtchn_fifo_handle_events ( cpu , true ) ; return 0 ; }","<S2SV_ModStart> ( cpu , NULL <S2SV_ModEnd> ) ; return
",torvalds@linux/e99502f76271d6bc4e374fe368c50c67a1fd3070,CVE-2020-27673,https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070,2020-10-22T21:15Z,"<S2SV_StartBug> __evtchn_fifo_handle_events ( cpu , true ) ; <S2SV_EndBug>"
679,CWE-362,"static bool add_free_nid ( struct f2fs_sb_info * sbi , nid_t nid , bool build ) { struct f2fs_nm_info * nm_i = nm_i ( sbi ) ; struct free_nid * i ; struct nat_entry * ne ; int err ; if ( unlikely ( nid == 0 ) ) return false ; if ( build ) { ne = __lookup_nat_cache ( nm_i , nid ) ; if ( ne && ( ! get_nat_flag ( ne , is_checkpointed ) || nat_get_blkaddr ( ne ) != null_addr ) ) return false ; } i = f2fs_kmem_cache_alloc ( free_nid_slab , gfp_nofs ) ; i -> nid = nid ; i -> state = nid_new ; if ( radix_tree_preload ( gfp_nofs ) ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } spin_lock ( & nm_i -> nid_list_lock ) ; err = __insert_nid_to_list ( sbi , i , free_nid_list , true ) ; spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; if ( err ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } return true ; }","<S2SV_ModStart> free_nid * i , * e <S2SV_ModStart> ; int err = - EINVAL ; bool ret = false <S2SV_ModStart> return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/30a61ddf8117c26ac5b295e1233eaa9629a94ca3,CVE-2017-18249,https://github.com/torvalds/linux/commit/30a61ddf8117c26ac5b295e1233eaa9629a94ca3,2018-03-26T20:29Z,<S2SV_StartBug> struct free_nid * i ; <S2SV_EndBug> <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( build ) { <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug>
4444,CWE-401,"struct resource_pool * dcn10_create_resource_pool ( const struct dc_init_data * init_data , struct dc * dc ) { struct dcn10_resource_pool * pool = kzalloc ( sizeof ( struct dcn10_resource_pool ) , gfp_kernel ) ; if ( ! pool ) return null ; if ( construct ( init_data -> num_virtual_links , dc , pool ) ) return & pool -> base ; break_to_debugger ( ) ; return null ; }","<S2SV_ModStart> -> base ; kfree ( pool ) ;
",torvalds@linux/104c307147ad379617472dd91a5bcb368d72bd6d,CVE-2019-19082,https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d,2019-11-18T06:15Z,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug>
7772,CWE-125,"stmt_ty asyncfunctiondef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq * decorator_list , expr_ty returns , int lineno , int col_offset , int end_lineno , int end_col_offset , pyarena * arena ) { stmt_ty p ; if ( ! name ) { pyerr_setstring ( pyexc_valueerror , ""field<s2sv_blank>name<s2sv_blank>is<s2sv_blank>required<s2sv_blank>for<s2sv_blank>asyncfunctiondef"" ) ; return null ; } if ( ! args ) { pyerr_setstring ( pyexc_valueerror , ""field<s2sv_blank>args<s2sv_blank>is<s2sv_blank>required<s2sv_blank>for<s2sv_blank>asyncfunctiondef"" ) ; return null ; } p = ( stmt_ty ) pyarena_malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return null ; p -> kind = asyncfunctiondef_kind ; p -> v . asyncfunctiondef . name = name ; p -> v . asyncfunctiondef . args = args ; p -> v . asyncfunctiondef . body = body ; p -> v . asyncfunctiondef . decorator_list = decorator_list ; p -> v . asyncfunctiondef . returns = returns ; p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","<S2SV_ModStart> expr_ty returns , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> returns = returns ; p -> v . AsyncFunctionDef . type_comment = type_comment
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> * decorator_list , expr_ty returns , int lineno , int col_offset , <S2SV_EndBug> <S2SV_StartBug> p -> v . AsyncFunctionDef . returns = returns ; <S2SV_EndBug>"
3573,CWE-20,"static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = null , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= page_size ) ) return - einval ; kbuf = memdup_user_nul ( buf , count ) ; if ( is_err ( kbuf ) ) return ptr_err ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - eperm ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , cap_sys_admin ) ) goto out ; ret = - einval ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = null ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent . first == ( u32 ) - 1 ) || ( extent . lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent . first + extent . count ) <= extent . first ) goto out ; if ( ( extent . lower_first + extent . count ) <= extent . lower_first ) goto out ; if ( mappings_overlap ( & new_map , & extent ) ) goto out ; if ( ( new_map . nr_extents + 1 ) == uid_gid_map_max_extents && ( next_line != null ) ) goto out ; ret = insert_extent ( & new_map , & extent ) ; if ( ret < 0 ) goto out ; ret = - einval ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - eperm ; if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) goto out ; ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ret = - eperm ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { struct uid_gid_extent * e ; u32 lower_first ; if ( new_map . nr_extents <= uid_gid_map_max_base_extents ) e = & new_map . extent [ idx ] ; else e = & new_map . forward [ idx ] ; lower_first = map_id_range_down ( parent_map , e -> lower_first , e -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; e -> lower_first = lower_first ; } if ( new_map . nr_extents <= uid_gid_map_max_base_extents ) { memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; } else { map -> forward = new_map . forward ; map -> reverse = new_map . reverse ; } smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : if ( ret < 0 && new_map . nr_extents > uid_gid_map_max_base_extents ) { kfree ( new_map . forward ) ; kfree ( new_map . reverse ) ; map -> forward = null ; map -> reverse = null ; map -> nr_extents = 0 ; } mutex_unlock ( & userns_state_mutex ) ; kfree ( kbuf ) ; return ret ; }","<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
",torvalds@linux/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,CVE-2018-18955,https://github.com/torvalds/linux/commit/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,2018-11-16T20:29Z,"<S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug>"
5470,CWE-362,"int mi_repair_parallel ( mi_check * param , register mi_info * info , const char * name , int rep_quick ) { int got_error ; uint i , key , total_key_length , istep ; ulong rec_length ; ha_rows start_records ; my_off_t new_header_length , del ; file new_file ; mi_sort_param * sort_param = 0 ; myisam_share * share = info -> s ; ulong * rec_per_key_part ; ha_keyseg * keyseg ; char llbuff [ 22 ] ; io_cache new_data_cache ; io_cache_share io_share ; sort_info sort_info ; ulonglong uninit_var ( key_map ) ; pthread_attr_t thr_attr ; ulong max_pack_reclength ; int error ; dbug_enter ( ""mi_repair_parallel"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & t_unpack ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & t_silent ) ) { printf ( ""-<s2sv_blank>parallel<s2sv_blank>recovering<s2sv_blank>(with<s2sv_blank>sort)<s2sv_blank>myisam-table<s2sv_blank>\'%s\'\\n"" , name ) ; printf ( ""data<s2sv_blank>records:<s2sv_blank>%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= t_rep ; if ( info -> s -> options & ( ha_option_checksum | ha_option_compress_record ) ) param -> testflag |= t_calc_checksum ; dbug_print ( ""info"" , ( ""is<s2sv_blank>quick<s2sv_blank>repair:<s2sv_blank>%d"" , rep_quick ) ) ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; mysql_mutex_init ( mi_key_mutex_mi_sort_info_mutex , & sort_info . mutex , my_mutex_init_fast ) ; mysql_cond_init ( mi_key_cond_mi_sort_info_cond , & sort_info . cond , 0 ) ; mysql_mutex_init ( mi_key_mutex_mi_check_print_msg , & param -> print_msg_mutex , my_mutex_init_fast ) ; param -> need_print_msg_lock = 1 ; if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , read_cache , share -> pack . header_length , 1 , myf ( my_wme ) ) || ( ! rep_quick && ( init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , write_cache , new_header_length , 1 , myf ( my_wme | my_wait_if_full ) & param -> myf_rw ) || init_io_cache ( & new_data_cache , - 1 , ( uint ) param -> write_buffer_length , read_cache , new_header_length , 1 , myf ( my_wme | my_dont_check_filesize ) ) ) ) ) goto err ; sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ; info -> opt_flag |= write_cache_used ; info -> rec_cache . file = info -> dfile ; if ( ! rep_quick ) { if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , data_tmp_ext , 2 + 4 ) , 0 , param -> tmpfile_createflag , myf ( 0 ) ) ) < 0 ) { mi_check_print_error ( param , ""can\'t<s2sv_blank>create<s2sv_blank>new<s2sv_blank>tempfile:<s2sv_blank>\'%s\'"" , param -> temp_filename ) ; goto err ; } if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0l , new_header_length , ""datafile-header"" ) ) goto err ; if ( param -> testflag & t_unpack ) { share -> options &= ~ ha_option_compress_record ; mi_int2store ( share -> state . header . options , share -> options ) ; } share -> state . dellink = ha_offset_error ; info -> rec_cache . file = new_file ; } info -> update = ( short ) ( ha_state_changed | ha_state_row_changed ) ; mi_drop_all_indexes ( param , info , false ) ; key_map = share -> state . key_map ; if ( param -> testflag & t_create_missing_keys ) { key_map = ~ key_map ; } sort_info . info = info ; sort_info . param = param ; set_data_file_type ( & sort_info , share ) ; sort_info . dupp = 0 ; sort_info . buff = 0 ; param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0l , my_seek_end , myf ( 0 ) ) ; if ( share -> data_file_type == dynamic_record ) rec_length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ; else if ( share -> data_file_type == compressed_record ) rec_length = share -> base . min_block_length ; else rec_length = share -> base . pack_reclength ; sort_info . max_records = ( ( param -> testflag & t_create_missing_keys ) ? info -> state -> records + 1 : ( ha_rows ) ( sort_info . filelength / rec_length + 1 ) ) ; del = info -> state -> del ; param -> glob_crc = 0 ; max_pack_reclength = share -> base . pack_reclength ; if ( share -> options & ha_option_compress_record ) set_if_bigger ( max_pack_reclength , share -> max_pack_length ) ; if ( ! ( sort_param = ( mi_sort_param * ) my_malloc ( ( uint ) share -> base . keys * ( sizeof ( mi_sort_param ) + max_pack_reclength ) , myf ( my_zerofill ) ) ) ) { mi_check_print_error ( param , ""not<s2sv_blank>enough<s2sv_blank>memory<s2sv_blank>for<s2sv_blank>key!"" ) ; goto err ; } total_key_length = 0 ; rec_per_key_part = param -> rec_per_key_part ; info -> state -> records = info -> state -> del = share -> state . split = 0 ; info -> state -> empty = 0 ; for ( i = key = 0 , istep = 1 ; key < share -> base . keys ; rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) { sort_param [ i ] . key = key ; sort_param [ i ] . keyinfo = share -> keyinfo + key ; sort_param [ i ] . seg = sort_param [ i ] . keyinfo -> seg ; if ( ! mi_is_key_active ( key_map , key ) ) { memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ; istep = 0 ; continue ; } istep = 1 ; if ( ( ! ( param -> testflag & t_silent ) ) ) printf ( ""-<s2sv_blank>fixing<s2sv_blank>index<s2sv_blank>%d\\n"" , key + 1 ) ; if ( sort_param [ i ] . keyinfo -> flag & ha_fulltext ) { sort_param [ i ] . key_read = sort_ft_key_read ; sort_param [ i ] . key_write = sort_ft_key_write ; } else { sort_param [ i ] . key_read = sort_key_read ; sort_param [ i ] . key_write = sort_key_write ; } sort_param [ i ] . key_cmp = sort_key_cmp ; sort_param [ i ] . lock_in_memory = lock_memory ; sort_param [ i ] . tmpdir = param -> tmpdir ; sort_param [ i ] . sort_info = & sort_info ; sort_param [ i ] . master = 0 ; sort_param [ i ] . fix_datafile = 0 ; sort_param [ i ] . calc_checksum = 0 ; sort_param [ i ] . filepos = new_header_length ; sort_param [ i ] . max_pos = sort_param [ i ] . pos = share -> pack . header_length ; sort_param [ i ] . record = ( ( ( uchar * ) ( sort_param + share -> base . keys ) ) + ( max_pack_reclength * i ) ) ; if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param [ i ] . rec_buff ) ) { mi_check_print_error ( param , ""not<s2sv_blank>enough<s2sv_blank>memory!"" ) ; goto err ; } sort_param [ i ] . key_length = share -> rec_reflength ; for ( keyseg = sort_param [ i ] . seg ; keyseg -> type != ha_keytype_end ; keyseg ++ ) { sort_param [ i ] . key_length += keyseg -> length ; if ( keyseg -> flag & ha_space_pack ) sort_param [ i ] . key_length += get_pack_length ( keyseg -> length ) ; if ( keyseg -> flag & ( ha_blob_part | ha_var_length_part ) ) sort_param [ i ] . key_length += 2 + test ( keyseg -> length >= 127 ) ; if ( keyseg -> flag & ha_null_part ) sort_param [ i ] . key_length ++ ; } total_key_length += sort_param [ i ] . key_length ; if ( sort_param [ i ] . keyinfo -> flag & ha_fulltext ) { uint ft_max_word_len_for_sort = ft_max_word_len_for_sort * sort_param [ i ] . keyinfo -> seg -> charset -> mbmaxlen ; sort_param [ i ] . key_length += ft_max_word_len_for_sort - ha_ft_maxbytelen ; init_alloc_root ( & sort_param [ i ] . wordroot , ftparser_memroot_alloc_size , 0 ) ; } } sort_info . total_keys = i ; sort_param [ 0 ] . master = 1 ; sort_param [ 0 ] . fix_datafile = ( my_bool ) ( ! rep_quick ) ; sort_param [ 0 ] . calc_checksum = test ( param -> testflag & t_calc_checksum ) ; if ( ! ftparser_alloc_param ( info ) ) goto err ; sort_info . got_error = 0 ; mysql_mutex_lock ( & sort_info . mutex ) ; if ( i > 1 ) { if ( rep_quick ) init_io_cache_share ( & param -> read_cache , & io_share , null , i ) ; else init_io_cache_share ( & new_data_cache , & io_share , & info -> rec_cache , i ) ; } else io_share . total_threads = 0 ; ( void ) pthread_attr_init ( & thr_attr ) ; ( void ) pthread_attr_setdetachstate ( & thr_attr , pthread_create_detached ) ; for ( i = 0 ; i < sort_info . total_keys ; i ++ ) { sort_param [ i ] . read_cache = ( ( rep_quick || ! i ) ? param -> read_cache : new_data_cache ) ; dbug_print ( ""io_cache_share"" , ( ""thread:<s2sv_blank>%u<s2sv_blank><s2sv_blank>read_cache:<s2sv_blank>0x%lx"" , i , ( long ) & sort_param [ i ] . read_cache ) ) ; sort_param [ i ] . sortbuff_size = # ifndef using_second_approach param -> sort_buffer_length / sort_info . total_keys ; # else param -> sort_buffer_length * sort_param [ i ] . key_length / total_key_length ; # endif if ( ( error = mysql_thread_create ( mi_key_thread_find_all_keys , & sort_param [ i ] . thr , & thr_attr , thr_find_all_keys , ( void * ) ( sort_param + i ) ) ) ) { mi_check_print_error ( param , ""cannot<s2sv_blank>start<s2sv_blank>a<s2sv_blank>repair<s2sv_blank>thread<s2sv_blank>(errno=<s2sv_blank>%d)"" , error ) ; if ( io_share . total_threads ) remove_io_thread ( & sort_param [ i ] . read_cache ) ; dbug_print ( ""error"" , ( ""cannot<s2sv_blank>start<s2sv_blank>a<s2sv_blank>repair<s2sv_blank>thread"" ) ) ; sort_info . got_error = 1 ; } else sort_info . threads_running ++ ; } ( void ) pthread_attr_destroy ( & thr_attr ) ; while ( sort_info . threads_running ) mysql_cond_wait ( & sort_info . cond , & sort_info . mutex ) ; mysql_mutex_unlock ( & sort_info . mutex ) ; if ( ( got_error = thr_write_keys ( sort_param ) ) ) { param -> retry_repair = 1 ; goto err ; } got_error = 1 ; if ( sort_param [ 0 ] . fix_datafile ) { if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ; if ( param -> testflag & t_safe_repair ) { if ( info -> state -> records + 1 < start_records ) { info -> state -> records = start_records ; goto err ; } } share -> state . state . data_file_length = info -> state -> data_file_length = sort_param -> filepos ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; mysql_file_close ( info -> dfile , myf ( 0 ) ) ; info -> dfile = new_file ; share -> data_file_type = sort_info . new_data_file_type ; share -> pack . header_length = ( ulong ) new_header_length ; } else info -> state -> data_file_length = sort_param -> max_pos ; if ( rep_quick && del + sort_info . dupp != info -> state -> del ) { mi_check_print_error ( param , ""couldn\'t<s2sv_blank>fix<s2sv_blank>table<s2sv_blank>with<s2sv_blank>quick<s2sv_blank>recovery:<s2sv_blank>found<s2sv_blank>wrong<s2sv_blank>number<s2sv_blank>of<s2sv_blank>deleted<s2sv_blank>records"" ) ; mi_check_print_error ( param , ""run<s2sv_blank>recovery<s2sv_blank>again<s2sv_blank>without<s2sv_blank>-q"" ) ; param -> retry_repair = 1 ; param -> testflag |= t_retry_without_quick ; goto err ; } if ( rep_quick & t_force_uniqueness ) { my_off_t skr = info -> state -> data_file_length + ( share -> options & ha_option_compress_record ? memmap_extra_margin : 0 ) ; # ifdef use_reloc if ( share -> data_file_type == static_record && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ; # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , myf ( 0 ) ) ) mi_check_print_warning ( param , ""can\'t<s2sv_blank>change<s2sv_blank>size<s2sv_blank>of<s2sv_blank>datafile,<s2sv_blank><s2sv_blank>error:<s2sv_blank>%d"" , my_errno ) ; } if ( param -> testflag & t_calc_checksum ) info -> state -> checksum = param -> glob_crc ; if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , myf ( 0 ) ) ) mi_check_print_warning ( param , ""can\'t<s2sv_blank>change<s2sv_blank>size<s2sv_blank>of<s2sv_blank>indexfile,<s2sv_blank>error:<s2sv_blank>%d"" , my_errno ) ; if ( ! ( param -> testflag & t_silent ) ) { if ( start_records != info -> state -> records ) printf ( ""data<s2sv_blank>records:<s2sv_blank>%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<s2sv_blank>records<s2sv_blank>have<s2sv_blank>been<s2sv_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ; } got_error = 0 ; if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ; err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & info -> rec_cache ) ; if ( ! rep_quick ) ( void ) end_io_cache ( & new_data_cache ) ; if ( ! got_error ) { if ( new_file >= 0 ) { mysql_file_close ( new_file , myf ( 0 ) ) ; info -> dfile = new_file = - 1 ; if ( change_to_newfile ( share -> data_file_name , mi_name_dext , data_tmp_ext , ( param -> testflag & t_backup_data ? myf ( my_redel_make_backup ) : myf ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ; } } if ( got_error ) { if ( ! param -> error_printed ) mi_check_print_error ( param , ""%d<s2sv_blank>when<s2sv_blank>fixing<s2sv_blank>table"" , my_errno ) ; if ( new_file >= 0 ) { ( void ) mysql_file_close ( new_file , myf ( 0 ) ) ; ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , myf ( my_wme ) ) ; if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ; } mi_mark_crashed_on_repair ( info ) ; } else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ state_not_optimized_keys ; share -> state . changed |= state_not_sorted_pages ; mysql_cond_destroy ( & sort_info . cond ) ; mysql_mutex_destroy ( & sort_info . mutex ) ; mysql_mutex_destroy ( & param -> print_msg_mutex ) ; param -> need_print_msg_lock = 0 ; my_free ( sort_info . ft_buf ) ; my_free ( sort_info . key_block ) ; my_free ( sort_param ) ; my_free ( sort_info . buff ) ; ( void ) end_io_cache ( & param -> read_cache ) ; info -> opt_flag &= ~ ( read_cache_used | write_cache_used ) ; if ( ! got_error && ( param -> testflag & t_unpack ) ) { share -> state . header . options [ 0 ] &= ( uchar ) ~ ha_option_compress_record ; share -> pack . header_length = 0 ; } dbug_return ( got_error ) ; }","<S2SV_ModStart> , int rep_quick , my_bool no_copy_stat <S2SV_ModStart> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> , DATA_TMP_EXT , flags <S2SV_ModEnd> ) || mi_open_datafile
",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z,"<S2SV_StartBug> const char * name , int rep_quick ) <S2SV_EndBug> <S2SV_StartBug> mysql_file_close ( new_file , MYF ( 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( param -> testflag & T_BACKUP_DATA ? <S2SV_EndBug>"
233,CWE-399,"int ext4_orphan_del ( handle_t * handle , struct inode * inode ) { struct list_head * prev ; struct ext4_inode_info * ei = ext4_i ( inode ) ; struct ext4_sb_info * sbi ; __u32 ino_next ; struct ext4_iloc iloc ; int err = 0 ; if ( ! ext4_sb ( inode -> i_sb ) -> s_journal ) return 0 ; mutex_lock ( & ext4_sb ( inode -> i_sb ) -> s_orphan_lock ) ; if ( list_empty ( & ei -> i_orphan ) ) goto out ; ino_next = next_orphan ( inode ) ; prev = ei -> i_orphan . prev ; sbi = ext4_sb ( inode -> i_sb ) ; jbd_debug ( 4 , ""remove<s2sv_blank>inode<s2sv_blank>%lu<s2sv_blank>from<s2sv_blank>orphan<s2sv_blank>list\\n"" , inode -> i_ino ) ; list_del_init ( & ei -> i_orphan ) ; if ( ! handle ) goto out ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_err ; if ( prev == & sbi -> s_orphan ) { jbd_debug ( 4 , ""superblock<s2sv_blank>will<s2sv_blank>point<s2sv_blank>to<s2sv_blank>%u\\n"" , ino_next ) ; buffer_trace ( sbi -> s_sbh , ""get_write_access"" ) ; err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ; if ( err ) goto out_brelse ; sbi -> s_es -> s_last_orphan = cpu_to_le32 ( ino_next ) ; err = ext4_handle_dirty_super ( handle , inode -> i_sb ) ; } else { struct ext4_iloc iloc2 ; struct inode * i_prev = & list_entry ( prev , struct ext4_inode_info , i_orphan ) -> vfs_inode ; jbd_debug ( 4 , ""orphan<s2sv_blank>inode<s2sv_blank>%lu<s2sv_blank>will<s2sv_blank>point<s2sv_blank>to<s2sv_blank>%u\\n"" , i_prev -> i_ino , ino_next ) ; err = ext4_reserve_inode_write ( handle , i_prev , & iloc2 ) ; if ( err ) goto out_brelse ; next_orphan ( i_prev ) = ino_next ; err = ext4_mark_iloc_dirty ( handle , i_prev , & iloc2 ) ; } if ( err ) goto out_brelse ; next_orphan ( inode ) = 0 ; err = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; out_err : ext4_std_error ( inode -> i_sb , err ) ; out : mutex_unlock ( & ext4_sb ( inode -> i_sb ) -> s_orphan_lock ) ; return err ; out_brelse : brelse ( iloc . bh ) ; goto out_err ; }","<S2SV_ModStart> ; if ( ( <S2SV_ModStart> ) -> s_journal ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS )
",torvalds@linux/0e9a9a1ad619e7e987815d20262d36a2f95717ca,CVE-2013-2015,https://github.com/torvalds/linux/commit/0e9a9a1ad619e7e987815d20262d36a2f95717ca,2013-04-29T14:55Z,<S2SV_StartBug> if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) <S2SV_EndBug>
2826,CWE-255,"int vt_reset_keyboard ( int fd ) { int kb ; kb = vt_default_utf8 ( ) != 0 ? k_unicode : k_xlate ; if ( ioctl ( fd , kdskbmode , kb ) < 0 ) return - errno ; return 0 ; }","<S2SV_ModStart> { int kb , r <S2SV_ModStart> K_UNICODE : K_XLATE ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_debug_errno ( r , ""Keyboard<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>XLATE<S2SV_blank>or<S2SV_blank>UNICODE<S2SV_blank>mode,<S2SV_blank>not<S2SV_blank>resetting:<S2SV_blank>%m"" ) ; return 0 ; } else if ( r < 0 ) return r
",systemd@systemd/9725f1a10f80f5e0ae7d9b60547458622aeb322f,CVE-2018-20839,https://github.com/systemd/systemd/commit/9725f1a10f80f5e0ae7d9b60547458622aeb322f,2019-05-17T04:29Z,<S2SV_StartBug> int kb ; <S2SV_EndBug> <S2SV_StartBug> kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ; <S2SV_EndBug>
2207,CWE-119,"static __u8 * nci_extract_rf_params_nfcf_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcf_poll * nfcf_poll , __u8 * data ) { nfcf_poll -> bit_rate = * data ++ ; nfcf_poll -> sensf_res_len = * data ++ ; pr_debug ( ""bit_rate<s2sv_blank>%d,<s2sv_blank>sensf_res_len<s2sv_blank>%d\\n"" , nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ; memcpy ( nfcf_poll -> sensf_res , data , nfcf_poll -> sensf_res_len ) ; data += nfcf_poll -> sensf_res_len ; return data ; }","<S2SV_ModStart> -> sensf_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSF_RES_MAXSIZE )
",torvalds@linux/67de956ff5dc1d4f321e16cfbd63f5be3b691b43,CVE-2012-3364,https://github.com/torvalds/linux/commit/67de956ff5dc1d4f321e16cfbd63f5be3b691b43,2013-01-22T23:55Z,<S2SV_StartBug> nfcf_poll -> sensf_res_len = * data ++ ; <S2SV_EndBug>
7898,CWE-20,"void httpparseauthorizationfield ( httpconnection * connection , char_t * value ) { char_t * p ; char_t * token ; token = osstrtok_r ( value , ""<s2sv_blank>\\t"" , & p ) ; if ( token == null ) { return ; } # if ( http_server_basic_auth_support == enabled ) else if ( ! osstrcasecmp ( token , ""basic"" ) ) { error_t error ; size_t n ; char_t * separator ; connection -> request . auth . mode = http_auth_mode_basic ; token = osstrtok_r ( null , ""<s2sv_blank>\\t"" , & p ) ; if ( token != null ) { error = base64decode ( token , osstrlen ( token ) , token , & n ) ; if ( ! error ) { token [ n ] = '\\0' ; separator = strchr ( token , ':' ) ; if ( separator != null ) { * separator = '\\0' ; strsafecopy ( connection -> request . auth . user , token , http_server_username_max_len ) ; token = separator + 1 ; connection -> request . auth . password = token ; } } } trace_debug ( ""authorization<s2sv_blank>header:\\r\\n"" ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>username:<s2sv_blank>%s\\r\\n"" , connection -> request . auth . user ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>password:<s2sv_blank>%s\\r\\n"" , connection -> request . auth . password ) ; } # endif # if ( http_server_digest_auth_support == enabled ) else if ( ! osstrcasecmp ( token , ""digest"" ) ) { size_t n ; char_t * separator ; char_t * name ; connection -> request . auth . mode = http_auth_mode_digest ; token = osstrtok_r ( null , "","" , & p ) ; while ( token != null ) { separator = strchr ( token , '=' ) ; if ( separator != null ) { * separator = '\\0' ; name = strtrimwhitespace ( token ) ; value = strtrimwhitespace ( separator + 1 ) ; n = osstrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osstrcasecmp ( name , ""username"" ) ) { strsafecopy ( connection -> request . auth . user , value , http_server_username_max_len ) ; } else if ( ! osstrcasecmp ( name , ""realm"" ) ) { connection -> request . auth . realm = value ; } else if ( ! osstrcasecmp ( name , ""nonce"" ) ) { connection -> request . auth . nonce = value ; } else if ( ! osstrcasecmp ( name , ""uri"" ) ) { connection -> request . auth . uri = value ; } else if ( ! osstrcasecmp ( name , ""qop"" ) ) { connection -> request . auth . qop = value ; } else if ( ! osstrcasecmp ( name , ""nc"" ) ) { connection -> request . auth . nc = value ; } else if ( ! osstrcasecmp ( name , ""cnonce"" ) ) { connection -> request . auth . cnonce = value ; } else if ( ! osstrcasecmp ( name , ""response"" ) ) { connection -> request . auth . response = value ; } else if ( ! osstrcasecmp ( name , ""opaque"" ) ) { connection -> request . auth . opaque = value ; } token = osstrtok_r ( null , "","" , & p ) ; } } trace_debug ( ""authorization<s2sv_blank>header:\\r\\n"" ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>username:<s2sv_blank>%s\\r\\n"" , connection -> request . auth . user ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>realm:<s2sv_blank>%s\\r\\n"" , connection -> request . auth . realm ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>nonce:<s2sv_blank>%s\\r\\n"" , connection -> request . auth . nonce ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>uri:<s2sv_blank>%s\\r\\n"" , connection -> request . auth . uri ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>qop:<s2sv_blank>%s\\r\\n"" , connection -> request . auth . qop ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>nc:<s2sv_blank>%s\\r\\n"" , connection -> request . auth . nc ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>cnonce:<s2sv_blank>%s\\r\\n"" , connection -> request . auth . cnonce ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>response:<s2sv_blank>%s\\r\\n"" , connection -> request . auth . response ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>opaque:<s2sv_blank>%s\\r\\n"" , connection -> request . auth . opaque ) ; } # endif else { return ; } # if ( http_server_basic_auth_support == enabled || http_server_digest_auth_support == enabled ) connection -> request . auth . found = true ; if ( connection -> settings -> authcallback != null ) { connection -> status = connection -> settings -> authcallback ( connection , connection -> request . auth . user , connection -> request . uri ) ; } else { connection -> status = http_access_allowed ; } # endif }","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> separator = strchr ( token , ':' ) ; <S2SV_EndBug> <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug>"
124,CWE-285,"static int __reiserfs_set_acl ( struct reiserfs_transaction_handle * th , struct inode * inode , int type , struct posix_acl * acl ) { char * name ; void * value = null ; size_t size = 0 ; int error ; switch ( type ) { case acl_type_access : name = xattr_name_posix_acl_access ; if ( acl ) { error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; if ( error < 0 ) return error ; else { if ( error == 0 ) acl = null ; } } break ; case acl_type_default : name = xattr_name_posix_acl_default ; if ( ! s_isdir ( inode -> i_mode ) ) return acl ? - eacces : 0 ; break ; default : return - einval ; } if ( acl ) { value = reiserfs_posix_acl_to_disk ( acl , & size ) ; if ( is_err ( value ) ) return ( int ) ptr_err ( value ) ; } error = reiserfs_xattr_set_handle ( th , inode , name , value , size , 0 ) ; if ( error == - enodata ) { error = 0 ; if ( type == acl_type_access ) { inode -> i_ctime = current_time_sec ; mark_inode_dirty ( inode ) ; } } kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> } break ;
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug>"
3495,CWE-200,"static int snd_timer_user_params ( struct file * file , struct snd_timer_params __user * _params ) { struct snd_timer_user * tu ; struct snd_timer_params params ; struct snd_timer * t ; struct snd_timer_read * tr ; struct snd_timer_tread * ttr ; int err ; tu = file -> private_data ; if ( ! tu -> timeri ) return - ebadfd ; t = tu -> timeri -> timer ; if ( ! t ) return - ebadfd ; if ( copy_from_user ( & params , _params , sizeof ( params ) ) ) return - efault ; if ( ! ( t -> hw . flags & sndrv_timer_hw_slave ) && params . ticks < 1 ) { err = - einval ; goto _end ; } if ( params . queue_size > 0 && ( params . queue_size < 32 || params . queue_size > 1024 ) ) { err = - einval ; goto _end ; } if ( params . filter & ~ ( ( 1 << sndrv_timer_event_resolution ) | ( 1 << sndrv_timer_event_tick ) | ( 1 << sndrv_timer_event_start ) | ( 1 << sndrv_timer_event_stop ) | ( 1 << sndrv_timer_event_continue ) | ( 1 << sndrv_timer_event_pause ) | ( 1 << sndrv_timer_event_suspend ) | ( 1 << sndrv_timer_event_resume ) | ( 1 << sndrv_timer_event_mstart ) | ( 1 << sndrv_timer_event_mstop ) | ( 1 << sndrv_timer_event_mcontinue ) | ( 1 << sndrv_timer_event_mpause ) | ( 1 << sndrv_timer_event_msuspend ) | ( 1 << sndrv_timer_event_mresume ) ) ) { err = - einval ; goto _end ; } snd_timer_stop ( tu -> timeri ) ; spin_lock_irq ( & t -> lock ) ; tu -> timeri -> flags &= ~ ( sndrv_timer_iflg_auto | sndrv_timer_iflg_exclusive | sndrv_timer_iflg_early_event ) ; if ( params . flags & sndrv_timer_psflg_auto ) tu -> timeri -> flags |= sndrv_timer_iflg_auto ; if ( params . flags & sndrv_timer_psflg_exclusive ) tu -> timeri -> flags |= sndrv_timer_iflg_exclusive ; if ( params . flags & sndrv_timer_psflg_early_event ) tu -> timeri -> flags |= sndrv_timer_iflg_early_event ; spin_unlock_irq ( & t -> lock ) ; if ( params . queue_size > 0 && ( unsigned int ) tu -> queue_size != params . queue_size ) { if ( tu -> tread ) { ttr = kmalloc ( params . queue_size * sizeof ( * ttr ) , gfp_kernel ) ; if ( ttr ) { kfree ( tu -> tqueue ) ; tu -> queue_size = params . queue_size ; tu -> tqueue = ttr ; } } else { tr = kmalloc ( params . queue_size * sizeof ( * tr ) , gfp_kernel ) ; if ( tr ) { kfree ( tu -> queue ) ; tu -> queue_size = params . queue_size ; tu -> queue = tr ; } } } tu -> qhead = tu -> qtail = tu -> qused = 0 ; if ( tu -> timeri -> flags & sndrv_timer_iflg_early_event ) { if ( tu -> tread ) { struct snd_timer_tread tread ; tread . event = sndrv_timer_event_early ; tread . tstamp . tv_sec = 0 ; tread . tstamp . tv_nsec = 0 ; tread . val = 0 ; snd_timer_user_append_to_tqueue ( tu , & tread ) ; } else { struct snd_timer_read * r = & tu -> queue [ 0 ] ; r -> resolution = 0 ; r -> ticks = 0 ; tu -> qused ++ ; tu -> qtail ++ ; } } tu -> filter = params . filter ; tu -> ticks = params . ticks ; err = 0 ; _end : if ( copy_to_user ( _params , & params , sizeof ( params ) ) ) return - efault ; return err ; }","<S2SV_ModStart> snd_timer_tread tread ; memset ( & tread , 0 , sizeof ( tread ) ) ;
",torvalds@linux/cec8f96e49d9be372fdb0c3836dcf31ec71e457e,CVE-2016-4569,https://github.com/torvalds/linux/commit/cec8f96e49d9be372fdb0c3836dcf31ec71e457e,2016-05-23T10:59Z,<S2SV_StartBug> tread . event = SNDRV_TIMER_EVENT_EARLY ; <S2SV_EndBug>
8335,CWE-264,"static int perf_event_read_group ( struct perf_event * event , u64 read_format , char __user * buf ) { struct perf_event * leader = event -> group_leader , * sub ; int n = 0 , size = 0 , ret = - efault ; struct perf_event_context * ctx = leader -> ctx ; u64 values [ 5 ] ; u64 count , enabled , running ; mutex_lock ( & ctx -> mutex ) ; count = perf_event_read_value ( leader , & enabled , & running ) ; values [ n ++ ] = 1 + leader -> nr_siblings ; if ( read_format & perf_format_total_time_enabled ) values [ n ++ ] = enabled ; if ( read_format & perf_format_total_time_running ) values [ n ++ ] = running ; values [ n ++ ] = count ; if ( read_format & perf_format_id ) values [ n ++ ] = primary_event_id ( leader ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf , values , size ) ) goto unlock ; ret = size ; list_for_each_entry ( sub , & leader -> sibling_list , group_entry ) { n = 0 ; values [ n ++ ] = perf_event_read_value ( sub , & enabled , & running ) ; if ( read_format & perf_format_id ) values [ n ++ ] = primary_event_id ( sub ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf + ret , values , size ) ) { ret = - efault ; goto unlock ; } ret += size ; } unlock : mutex_unlock ( & ctx -> mutex ) ; return ret ; }","<S2SV_ModStart> * sub ; struct perf_event_context * ctx = leader -> ctx ; <S2SV_ModStart> 0 , ret ; u64 count , enabled , running ; u64 values [ 5 ] ; lockdep_assert_held ( & ctx -> mutex ) ; count = perf_event_read_value ( leader , & enabled , & running ) ; values [ n ++ ] = 1 + leader -> nr_siblings ; if ( read_format & PERF_FORMAT_TOTAL_TIME_ENABLED ) values [ n ++ ] = enabled ; if ( read_format & PERF_FORMAT_TOTAL_TIME_RUNNING ) values [ n ++ ] = running ; values [ n ++ ] = count ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( leader ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf , values , size ) ) return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ret = size <S2SV_ModStart> ) ) { return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> } ret += <S2SV_ModStart> size ; } <S2SV_ModEnd> return ret ;
",torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b,CVE-2016-6787,https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b,2016-12-28T07:59Z,"<S2SV_StartBug> int n = 0 , size = 0 , ret = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> struct perf_event_context * ctx = leader -> ctx ; <S2SV_EndBug> <S2SV_StartBug> ret = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> goto unlock ; <S2SV_EndBug> <S2SV_StartBug> unlock : <S2SV_EndBug>"
5497,CWE-59,void shutdown_mib ( void ) { unload_all_mibs ( ) ; if ( tree_top ) { if ( tree_top -> label ) snmp_free ( tree_top -> label ) ; snmp_free ( tree_top ) ; } tree_head = null ; mib = null ; if ( _mibindexes ) { int i ; for ( i = 0 ; i < _mibindex ; ++ i ) snmp_free ( _mibindexes [ i ] ) ; free ( _mibindexes ) ; _mibindex = 0 ; _mibindex_max = 0 ; _mibindexes = null ; } if ( prefix != null && prefix != & standard_prefix [ 0 ] ) snmp_free ( prefix ) ; if ( prefix ) prefix = null ; snmp_free ( confmibs ) ; snmp_free ( confmibdir ) ; },"<S2SV_ModStart> ; if ( <S2SV_ModEnd> Prefix != NULL
",net-snmp@net-snmp/4fd9a450444a434a993bc72f7c3486ccce41f602,CVE-2020-15861,https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602,2020-08-20T01:17Z,<S2SV_StartBug> if ( _mibindexes ) { <S2SV_EndBug>
3084,CWE-787,"static int hmac_create ( struct crypto_template * tmpl , struct rtattr * * tb ) { struct shash_instance * inst ; struct crypto_alg * alg ; struct shash_alg * salg ; int err ; int ds ; int ss ; err = crypto_check_attr_type ( tb , crypto_alg_type_shash ) ; if ( err ) return err ; salg = shash_attr_alg ( tb [ 1 ] , 0 , 0 ) ; if ( is_err ( salg ) ) return ptr_err ( salg ) ; err = - einval ; ds = salg -> digestsize ; ss = salg -> statesize ; alg = & salg -> base ; if ( ds > alg -> cra_blocksize || ss < alg -> cra_blocksize ) goto out_put_alg ; inst = shash_alloc_instance ( ""hmac"" , alg ) ; err = ptr_err ( inst ) ; if ( is_err ( inst ) ) goto out_put_alg ; err = crypto_init_shash_spawn ( shash_instance_ctx ( inst ) , salg , shash_crypto_instance ( inst ) ) ; if ( err ) goto out_free_inst ; inst -> alg . base . cra_priority = alg -> cra_priority ; inst -> alg . base . cra_blocksize = alg -> cra_blocksize ; inst -> alg . base . cra_alignmask = alg -> cra_alignmask ; ss = align ( ss , alg -> cra_alignmask + 1 ) ; inst -> alg . digestsize = ds ; inst -> alg . statesize = ss ; inst -> alg . base . cra_ctxsize = sizeof ( struct hmac_ctx ) + align ( ss * 2 , crypto_tfm_ctx_alignment ( ) ) ; inst -> alg . base . cra_init = hmac_init_tfm ; inst -> alg . base . cra_exit = hmac_exit_tfm ; inst -> alg . init = hmac_init ; inst -> alg . update = hmac_update ; inst -> alg . final = hmac_final ; inst -> alg . finup = hmac_finup ; inst -> alg . export = hmac_export ; inst -> alg . import = hmac_import ; inst -> alg . setkey = hmac_setkey ; err = shash_register_instance ( tmpl , inst ) ; if ( err ) { out_free_inst : shash_free_instance ( shash_crypto_instance ( inst ) ) ; } out_put_alg : crypto_mod_put ( alg ) ; return err ; }","<S2SV_ModStart> salg ) ; alg = & salg -> base ; <S2SV_ModStart> - EINVAL ; if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ; <S2SV_ModStart> salg -> statesize <S2SV_ModEnd> ; if (
",torvalds@linux/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,CVE-2017-17806,https://github.com/torvalds/linux/commit/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,2017-12-20T23:29Z,<S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> ds = salg -> digestsize ; <S2SV_EndBug> <S2SV_StartBug> ss = salg -> statesize ; <S2SV_EndBug>
4555,CWE-125,"mod_ty ta3ast_fromnodeobject ( const node * n , pycompilerflags * flags , pyobject * filename , int feature_version , pyarena * arena ) { int i , j , k , num ; asdl_seq * stmts = null ; asdl_seq * type_ignores = null ; stmt_ty s ; node * ch ; struct compiling c ; mod_ty res = null ; asdl_seq * argtypes = null ; expr_ty ret , arg ; c . c_arena = arena ; c . c_filename = filename ; c . c_normalize = null ; c . c_normalize_args = null ; c . c_feature_version = feature_version ; if ( type ( n ) == encoding_decl ) n = child ( n , 0 ) ; k = 0 ; switch ( type ( n ) ) { case file_input : stmts = _ta3_asdl_seq_new ( num_stmts ( n ) , arena ) ; if ( ! stmts ) goto out ; for ( i = 0 ; i < nch ( n ) - 1 ; i ++ ) { ch = child ( n , i ) ; if ( type ( ch ) == newline ) continue ; req ( ch , stmt ) ; num = num_stmts ( ch ) ; if ( num == 1 ) { s = ast_for_stmt ( & c , ch ) ; if ( ! s ) goto out ; asdl_seq_set ( stmts , k ++ , s ) ; } else { ch = child ( ch , 0 ) ; req ( ch , simple_stmt ) ; for ( j = 0 ; j < num ; j ++ ) { s = ast_for_stmt ( & c , child ( ch , j * 2 ) ) ; if ( ! s ) goto out ; asdl_seq_set ( stmts , k ++ , s ) ; } } } ch = child ( n , nch ( n ) - 1 ) ; req ( ch , endmarker ) ; num = nch ( ch ) ; type_ignores = _ta3_asdl_seq_new ( num , arena ) ; if ( ! type_ignores ) goto out ; for ( i = 0 ; i < num ; i ++ ) { type_ignore_ty ti = typeignore ( lineno ( child ( ch , i ) ) , arena ) ; if ( ! ti ) goto out ; asdl_seq_set ( type_ignores , i , ti ) ; } res = module ( stmts , type_ignores , arena ) ; break ; case eval_input : { expr_ty testlist_ast ; testlist_ast = ast_for_testlist ( & c , child ( n , 0 ) ) ; if ( ! testlist_ast ) goto out ; res = expression ( testlist_ast , arena ) ; break ; } case single_input : if ( type ( child ( n , 0 ) ) == newline ) { stmts = _ta3_asdl_seq_new ( 1 , arena ) ; if ( ! stmts ) goto out ; asdl_seq_set ( stmts , 0 , pass ( n -> n_lineno , n -> n_col_offset , arena ) ) ; if ( ! asdl_seq_get ( stmts , 0 ) ) goto out ; res = interactive ( stmts , arena ) ; } else { n = child ( n , 0 ) ; num = num_stmts ( n ) ; stmts = _ta3_asdl_seq_new ( num , arena ) ; if ( ! stmts ) goto out ; if ( num == 1 ) { s = ast_for_stmt ( & c , n ) ; if ( ! s ) goto out ; asdl_seq_set ( stmts , 0 , s ) ; } else { req ( n , simple_stmt ) ; for ( i = 0 ; i < nch ( n ) ; i += 2 ) { if ( type ( child ( n , i ) ) == newline ) break ; s = ast_for_stmt ( & c , child ( n , i ) ) ; if ( ! s ) goto out ; asdl_seq_set ( stmts , i / 2 , s ) ; } } res = interactive ( stmts , arena ) ; } break ; case func_type_input : n = child ( n , 0 ) ; req ( n , func_type ) ; if ( type ( child ( n , 1 ) ) == typelist ) { ch = child ( n , 1 ) ; num = 0 ; for ( i = 0 ; i < nch ( ch ) ; i ++ ) { if ( type ( child ( ch , i ) ) == test ) num ++ ; } argtypes = _ta3_asdl_seq_new ( num , arena ) ; j = 0 ; for ( i = 0 ; i < nch ( ch ) ; i ++ ) { if ( type ( child ( ch , i ) ) == test ) { arg = ast_for_expr ( & c , child ( ch , i ) ) ; if ( ! arg ) goto out ; asdl_seq_set ( argtypes , j ++ , arg ) ; } } } else argtypes = _ta3_asdl_seq_new ( 0 , arena ) ; ret = ast_for_expr ( & c , child ( n , nch ( n ) - 1 ) ) ; if ( ! ret ) goto out ; res = functiontype ( argtypes , ret , arena ) ; break ; default : pyerr_format ( pyexc_systemerror , ""invalid<s2sv_blank>node<s2sv_blank>%d<s2sv_blank>for<s2sv_blank>ta3ast_fromnode"" , type ( n ) ) ; goto out ; } out : if ( c . c_normalize ) { py_decref ( c . c_normalize ) ; pytuple_set_item ( c . c_normalize_args , 1 , null ) ; py_decref ( c . c_normalize_args ) ; } return res ; }","<S2SV_ModStart> ; c . <S2SV_ModEnd> c_feature_version = feature_version <S2SV_ModStart> c_normalize ) ; <S2SV_ModEnd> } return res
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> c . c_normalize_args = NULL ; <S2SV_EndBug> <S2SV_StartBug> PyTuple_SET_ITEM ( c . c_normalize_args , 1 , NULL ) ; <S2SV_EndBug>"
6522,CWE-119,cjson * cjson_createbool ( int b ) { cjson * item = cjson_new_item ( ) ; if ( item ) item -> type = b ? cjson_true : cjson_false ; return item ; },"
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,
2703,CWE-119,"static __init int sctp_init ( void ) { int i ; int status = - einval ; unsigned long goal ; unsigned long limit ; int max_share ; int order ; sock_skb_cb_check_size ( sizeof ( struct sctp_ulpevent ) ) ; status = - enobufs ; sctp_bucket_cachep = kmem_cache_create ( ""sctp_bind_bucket"" , sizeof ( struct sctp_bind_bucket ) , 0 , slab_hwcache_align , null ) ; if ( ! sctp_bucket_cachep ) goto out ; sctp_chunk_cachep = kmem_cache_create ( ""sctp_chunk"" , sizeof ( struct sctp_chunk ) , 0 , slab_hwcache_align , null ) ; if ( ! sctp_chunk_cachep ) goto err_chunk_cachep ; status = percpu_counter_init ( & sctp_sockets_allocated , 0 , gfp_kernel ) ; if ( status ) goto err_percpu_counter_init ; sctp_max_instreams = sctp_default_instreams ; sctp_max_outstreams = sctp_default_outstreams ; idr_init ( & sctp_assocs_id ) ; limit = nr_free_buffer_pages ( ) / 8 ; limit = max ( limit , 128ul ) ; sysctl_sctp_mem [ 0 ] = limit / 4 * 3 ; sysctl_sctp_mem [ 1 ] = limit ; sysctl_sctp_mem [ 2 ] = sysctl_sctp_mem [ 0 ] * 2 ; limit = ( sysctl_sctp_mem [ 1 ] ) << ( page_shift - 7 ) ; max_share = min ( 4ul * 1024 * 1024 , limit ) ; sysctl_sctp_rmem [ 0 ] = sk_mem_quantum ; sysctl_sctp_rmem [ 1 ] = 1500 * skb_truesize ( 1 ) ; sysctl_sctp_rmem [ 2 ] = max ( sysctl_sctp_rmem [ 1 ] , max_share ) ; sysctl_sctp_wmem [ 0 ] = sk_mem_quantum ; sysctl_sctp_wmem [ 1 ] = 16 * 1024 ; sysctl_sctp_wmem [ 2 ] = max ( 64 * 1024 , max_share ) ; if ( totalram_pages >= ( 128 * 1024 ) ) goal = totalram_pages >> ( 22 - page_shift ) ; else goal = totalram_pages >> ( 24 - page_shift ) ; for ( order = 0 ; ( 1ul << order ) < goal ; order ++ ) ; do { sctp_assoc_hashsize = ( 1ul << order ) * page_size / sizeof ( struct sctp_hashbucket ) ; if ( ( sctp_assoc_hashsize > ( 64 * 1024 ) ) && order > 0 ) continue ; sctp_assoc_hashtable = ( struct sctp_hashbucket * ) __get_free_pages ( gfp_atomic | __gfp_nowarn , order ) ; } while ( ! sctp_assoc_hashtable && -- order > 0 ) ; if ( ! sctp_assoc_hashtable ) { pr_err ( ""failed<s2sv_blank>association<s2sv_blank>hash<s2sv_blank>alloc\\n"" ) ; status = - enomem ; goto err_ahash_alloc ; } for ( i = 0 ; i < sctp_assoc_hashsize ; i ++ ) { rwlock_init ( & sctp_assoc_hashtable [ i ] . lock ) ; init_hlist_head ( & sctp_assoc_hashtable [ i ] . chain ) ; } sctp_ep_hashsize = 64 ; sctp_ep_hashtable = kmalloc ( 64 * sizeof ( struct sctp_hashbucket ) , gfp_kernel ) ; if ( ! sctp_ep_hashtable ) { pr_err ( ""failed<s2sv_blank>endpoint_hash<s2sv_blank>alloc\\n"" ) ; status = - enomem ; goto err_ehash_alloc ; } for ( i = 0 ; i < sctp_ep_hashsize ; i ++ ) { rwlock_init ( & sctp_ep_hashtable [ i ] . lock ) ; init_hlist_head ( & sctp_ep_hashtable [ i ] . chain ) ; } do { sctp_port_hashsize = ( 1ul << order ) * page_size / sizeof ( struct sctp_bind_hashbucket ) ; if ( ( sctp_port_hashsize > ( 64 * 1024 ) ) && order > 0 ) continue ; sctp_port_hashtable = ( struct sctp_bind_hashbucket * ) __get_free_pages ( gfp_atomic | __gfp_nowarn , order ) ; } while ( ! sctp_port_hashtable && -- order > 0 ) ; if ( ! sctp_port_hashtable ) { pr_err ( ""failed<s2sv_blank>bind<s2sv_blank>hash<s2sv_blank>alloc\\n"" ) ; status = - enomem ; goto err_bhash_alloc ; } for ( i = 0 ; i < sctp_port_hashsize ; i ++ ) { spin_lock_init ( & sctp_port_hashtable [ i ] . lock ) ; init_hlist_head ( & sctp_port_hashtable [ i ] . chain ) ; } pr_info ( ""hash<s2sv_blank>tables<s2sv_blank>configured<s2sv_blank>(established<s2sv_blank>%d<s2sv_blank>bind<s2sv_blank>%d)\\n"" , sctp_assoc_hashsize , sctp_port_hashsize ) ; sctp_sysctl_register ( ) ; init_list_head ( & sctp_address_families ) ; sctp_v4_pf_init ( ) ; sctp_v6_pf_init ( ) ; status = sctp_v4_protosw_init ( ) ; if ( status ) goto err_protosw_init ; status = sctp_v6_protosw_init ( ) ; if ( status ) goto err_v6_protosw_init ; status = register_pernet_subsys ( & sctp_net_ops ) ; if ( status ) goto err_register_pernet_subsys ; status = sctp_v4_add_protocol ( ) ; if ( status ) goto err_add_protocol ; status = sctp_v6_add_protocol ( ) ; if ( status ) goto err_v6_add_protocol ; out : return status ; err_v6_add_protocol : sctp_v4_del_protocol ( ) ; err_add_protocol : unregister_pernet_subsys ( & sctp_net_ops ) ; err_register_pernet_subsys : sctp_v6_protosw_exit ( ) ; err_v6_protosw_init : sctp_v4_protosw_exit ( ) ; err_protosw_init : sctp_v4_pf_exit ( ) ; sctp_v6_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; err_bhash_alloc : kfree ( sctp_ep_hashtable ) ; err_ehash_alloc : free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; err_ahash_alloc : percpu_counter_destroy ( & sctp_sockets_allocated ) ; err_percpu_counter_init : kmem_cache_destroy ( sctp_chunk_cachep ) ; err_chunk_cachep : kmem_cache_destroy ( sctp_bucket_cachep ) ; goto out ; }","<S2SV_ModStart> ; status = register_pernet_subsys ( & sctp_defaults_ops ) ; if ( status ) goto err_register_defaults ; status = <S2SV_ModStart> register_pernet_subsys ( & sctp_ctrlsock_ops ) ; if ( status ) goto err_register_ctrlsock <S2SV_ModEnd> ; status = <S2SV_ModStart> unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ; err_register_ctrlsock <S2SV_ModEnd> : sctp_v6_protosw_exit ( <S2SV_ModStart> ) ; err_protosw_init : unregister_pernet_subsys ( & sctp_defaults_ops ) ; err_register_defaults
",torvalds@linux/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4,CVE-2015-5283,https://github.com/torvalds/linux/commit/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4,2015-10-19T10:59Z,<S2SV_StartBug> status = sctp_v4_protosw_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> status = register_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> err_protosw_init : <S2SV_EndBug>
6412,CWE-787,"gf_err tenc_box_read ( gf_box * s , gf_bitstream * bs ) { u8 iv_size ; gf_trackencryptionbox * ptr = ( gf_trackencryptionbox * ) s ; isom_decrease_size ( ptr , 3 ) ; gf_bs_read_u8 ( bs ) ; if ( ! ptr -> version ) { gf_bs_read_u8 ( bs ) ; } else { ptr -> crypt_byte_block = gf_bs_read_int ( bs , 4 ) ; ptr -> skip_byte_block = gf_bs_read_int ( bs , 4 ) ; } ptr -> isprotected = gf_bs_read_u8 ( bs ) ; isom_decrease_size ( ptr , 17 ) ; ptr -> key_info [ 0 ] = 0 ; ptr -> key_info [ 1 ] = 0 ; ptr -> key_info [ 2 ] = 0 ; ptr -> key_info [ 3 ] = iv_size = gf_bs_read_u8 ( bs ) ; gf_bs_read_data ( bs , ptr -> key_info + 4 , 16 ) ; if ( ! iv_size && ptr -> isprotected ) { isom_decrease_size ( ptr , 1 ) ; iv_size = ptr -> key_info [ 20 ] = gf_bs_read_u8 ( bs ) ; isom_decrease_size ( ptr , ptr -> key_info [ 20 ] ) ; gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ; } return gf_ok ; }","<S2SV_ModStart> ] ) ; if ( ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>constant<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; ptr -> key_info [ 20 ] = 16 ; return GF_NON_COMPLIANT_BITSTREAM ; } <S2SV_ModStart> ) ; } else if ( ( iv_size != 0 ) && ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; return GF_NON_COMPLIANT_BITSTREAM ; }
",gpac@gpac/8986422c21fbd9a7bf6561cae65aae42077447e8,CVE-2021-31254,https://github.com/gpac/gpac/commit/8986422c21fbd9a7bf6561cae65aae42077447e8,2021-04-19T19:15Z,"<S2SV_StartBug> gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ; <S2SV_EndBug> <S2SV_StartBug> return GF_OK ; <S2SV_EndBug>"
799,CWE-772,"int virtio_gpu_object_create ( struct virtio_gpu_device * vgdev , unsigned long size , bool kernel , bool pinned , struct virtio_gpu_object * * bo_ptr ) { struct virtio_gpu_object * bo ; enum ttm_bo_type type ; size_t acc_size ; int ret ; if ( kernel ) type = ttm_bo_type_kernel ; else type = ttm_bo_type_device ; * bo_ptr = null ; acc_size = ttm_bo_dma_acc_size ( & vgdev -> mman . bdev , size , sizeof ( struct virtio_gpu_object ) ) ; bo = kzalloc ( sizeof ( struct virtio_gpu_object ) , gfp_kernel ) ; if ( bo == null ) return - enomem ; size = roundup ( size , page_size ) ; ret = drm_gem_object_init ( vgdev -> ddev , & bo -> gem_base , size ) ; if ( ret != 0 ) return ret ; bo -> dumb = false ; virtio_gpu_init_ttm_placement ( bo , pinned ) ; ret = ttm_bo_init ( & vgdev -> mman . bdev , & bo -> tbo , size , type , & bo -> placement , 0 , ! kernel , null , acc_size , null , null , & virtio_gpu_ttm_bo_destroy ) ; if ( ret != 0 ) return ret ; * bo_ptr = bo ; return 0 ; }","<S2SV_ModStart> != 0 ) { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> bo -> dumb
",torvalds@linux/385aee965b4e4c36551c362a334378d2985b722a,CVE-2017-10810,https://github.com/torvalds/linux/commit/385aee965b4e4c36551c362a334378d2985b722a,2017-07-04T20:29Z,<S2SV_StartBug> return ret ; <S2SV_EndBug>
6433,CWE-78,"static char_u * do_one_cmd ( char_u * * cmdlinep , int sourcing , # ifdef feat_eval struct condstack * cstack , # endif char_u * ( * fgetline ) ( int , void * , int ) , void * cookie ) { char_u * p ; linenr_t lnum ; long n ; char * errormsg = null ; char_u * after_modifier = null ; exarg_t ea ; int save_msg_scroll = msg_scroll ; cmdmod_t save_cmdmod ; int ni ; char_u * cmd ; vim_memset ( & ea , 0 , sizeof ( ea ) ) ; ea . line1 = 1 ; ea . line2 = 1 ; # ifdef feat_eval ++ ex_nesting_level ; # endif if ( quitmore # ifdef feat_eval && ! getline_equal ( fgetline , cookie , get_func_line ) # endif && ! getline_equal ( fgetline , cookie , getnextac ) ) -- quitmore ; save_cmdmod = cmdmod ; if ( ( * cmdlinep ) [ 0 ] == '#' && ( * cmdlinep ) [ 1 ] == '!' ) goto doend ; ea . cmd = * cmdlinep ; ea . cmdlinep = cmdlinep ; ea . getline = fgetline ; ea . cookie = cookie ; # ifdef feat_eval ea . cstack = cstack ; # endif if ( parse_command_modifiers ( & ea , & errormsg , false ) == fail ) goto doend ; after_modifier = ea . cmd ; # ifdef feat_eval ea . skip = did_emsg || got_int || did_throw || ( cstack -> cs_idx >= 0 && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & csf_active ) ) ; # else ea . skip = ( if_level > 0 ) ; # endif cmd = ea . cmd ; ea . cmd = skip_range ( ea . cmd , null ) ; if ( * ea . cmd == '*' && vim_strchr ( p_cpo , cpo_star ) == null ) ea . cmd = skipwhite ( ea . cmd + 1 ) ; p = find_command ( & ea , null ) ; # ifdef feat_eval # ifdef feat_profile if ( do_profiling == prof_yes && ( ! ea . skip || cstack -> cs_idx == 0 || ( cstack -> cs_idx > 0 && ( cstack -> cs_flags [ cstack -> cs_idx - 1 ] & csf_active ) ) ) ) { int skip = did_emsg || got_int || did_throw ; if ( ea . cmdidx == cmd_catch ) skip = ! skip && ! ( cstack -> cs_idx >= 0 && ( cstack -> cs_flags [ cstack -> cs_idx ] & csf_thrown ) && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & csf_caught ) ) ; else if ( ea . cmdidx == cmd_else || ea . cmdidx == cmd_elseif ) skip = skip || ! ( cstack -> cs_idx >= 0 && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & ( csf_active | csf_true ) ) ) ; else if ( ea . cmdidx == cmd_finally ) skip = false ; else if ( ea . cmdidx != cmd_endif && ea . cmdidx != cmd_endfor && ea . cmdidx != cmd_endtry && ea . cmdidx != cmd_endwhile ) skip = ea . skip ; if ( ! skip ) { if ( getline_equal ( fgetline , cookie , get_func_line ) ) func_line_exec ( getline_cookie ( fgetline , cookie ) ) ; else if ( getline_equal ( fgetline , cookie , getsourceline ) ) script_line_exec ( ) ; } } # endif dbg_check_breakpoint ( & ea ) ; if ( ! ea . skip && got_int ) { ea . skip = true ; ( void ) do_intthrow ( cstack ) ; } # endif if ( ! is_user_cmdidx ( ea . cmdidx ) ) { if ( ea . cmdidx != cmd_size ) ea . addr_type = cmdnames [ ( int ) ea . cmdidx ] . cmd_addr_type ; else ea . addr_type = addr_lines ; if ( ea . cmdidx == cmd_wincmd && p != null ) get_wincmd_addr_type ( skipwhite ( p ) , & ea ) ; } ea . cmd = cmd ; if ( parse_cmd_address ( & ea , & errormsg , false ) == fail ) goto doend ; ea . cmd = skipwhite ( ea . cmd ) ; while ( * ea . cmd == ':' ) ea . cmd = skipwhite ( ea . cmd + 1 ) ; if ( * ea . cmd == nul || * ea . cmd == \'""\' || ( ea . nextcmd = check_nextcmd ( ea . cmd ) ) != null ) { if ( ea . skip ) goto doend ; if ( * ea . cmd == '|' || ( exmode_active && ea . line1 != ea . line2 ) ) { ea . cmdidx = cmd_print ; ea . argt = range + count + trlbar ; if ( ( errormsg = invalid_range ( & ea ) ) == null ) { correct_range ( & ea ) ; ex_print ( & ea ) ; } } else if ( ea . addr_count != 0 ) { if ( ea . line2 > curbuf -> b_ml . ml_line_count ) { if ( vim_strchr ( p_cpo , cpo_minus ) != null ) ea . line2 = - 1 ; else ea . line2 = curbuf -> b_ml . ml_line_count ; } if ( ea . line2 < 0 ) errormsg = _ ( e_invrange ) ; else { if ( ea . line2 == 0 ) curwin -> w_cursor . lnum = 1 ; else curwin -> w_cursor . lnum = ea . line2 ; beginline ( bl_sol | bl_fix ) ; } } goto doend ; } if ( p != null && ea . cmdidx == cmd_size && ! ea . skip && ascii_isupper ( * ea . cmd ) && has_cmdundefined ( ) ) { int ret ; p = ea . cmd ; while ( ascii_isalnum ( * p ) ) ++ p ; p = vim_strnsave ( ea . cmd , ( int ) ( p - ea . cmd ) ) ; ret = apply_autocmds ( event_cmdundefined , p , p , true , null ) ; vim_free ( p ) ; p = ( ret # ifdef feat_eval && ! aborting ( ) # endif ) ? find_command ( & ea , null ) : ea . cmd ; } # ifdef feat_usr_cmds if ( p == null ) { if ( ! ea . skip ) errormsg = _ ( ""e464:<s2sv_blank>ambiguous<s2sv_blank>use<s2sv_blank>of<s2sv_blank>user-defined<s2sv_blank>command"" ) ; goto doend ; } if ( * p == '!' && ea . cmd [ 1 ] == 0151 && ea . cmd [ 0 ] == 78 && ! is_user_cmdidx ( ea . cmdidx ) ) { errormsg = uc_fun_cmd ( ) ; goto doend ; } # endif if ( ea . cmdidx == cmd_size ) { if ( ! ea . skip ) { strcpy ( iobuff , _ ( ""e492:<s2sv_blank>not<s2sv_blank>an<s2sv_blank>editor<s2sv_blank>command"" ) ) ; if ( ! sourcing ) { if ( after_modifier != null ) append_command ( after_modifier ) ; else append_command ( * cmdlinep ) ; } errormsg = ( char * ) iobuff ; did_emsg_syntax = true ; } goto doend ; } ni = ( ! is_user_cmdidx ( ea . cmdidx ) && ( cmdnames [ ea . cmdidx ] . cmd_func == ex_ni # ifdef have_ex_script_ni || cmdnames [ ea . cmdidx ] . cmd_func == ex_script_ni # endif ) ) ; # ifndef feat_eval if ( ea . cmdidx == cmd_if ) ++ if_level ; if ( if_level ) { if ( ea . cmdidx == cmd_endif ) -- if_level ; goto doend ; } # endif if ( * p == '!' && ea . cmdidx != cmd_substitute && ea . cmdidx != cmd_smagic && ea . cmdidx != cmd_snomagic ) { ++ p ; ea . forceit = true ; } else ea . forceit = false ; if ( ! is_user_cmdidx ( ea . cmdidx ) ) ea . argt = ( long ) cmdnames [ ( int ) ea . cmdidx ] . cmd_argt ; if ( ! ea . skip ) { # ifdef have_sandbox if ( sandbox != 0 && ! ( ea . argt & sboxok ) ) { errormsg = _ ( e_sandbox ) ; goto doend ; } # endif if ( ! curbuf -> b_p_ma && ( ea . argt & modify ) ) { errormsg = _ ( e_modifiable ) ; goto doend ; } if ( text_locked ( ) && ! ( ea . argt & cmdwin ) && ! is_user_cmdidx ( ea . cmdidx ) ) { errormsg = _ ( get_text_locked_msg ( ) ) ; goto doend ; } if ( ! ( ea . argt & cmdwin ) && ea . cmdidx != cmd_checktime && ea . cmdidx != cmd_edit && ea . cmdidx != cmd_file && ! is_user_cmdidx ( ea . cmdidx ) && curbuf_locked ( ) ) goto doend ; if ( ! ni && ! ( ea . argt & range ) && ea . addr_count > 0 ) { errormsg = _ ( e_norange ) ; goto doend ; } } if ( ! ni && ! ( ea . argt & bang ) && ea . forceit ) { errormsg = _ ( e_nobang ) ; goto doend ; } if ( ! ea . skip && ! ni ) { if ( ! global_busy && ea . line1 > ea . line2 ) { if ( msg_silent == 0 ) { if ( sourcing || exmode_active ) { errormsg = _ ( ""e493:<s2sv_blank>backwards<s2sv_blank>range<s2sv_blank>given"" ) ; goto doend ; } if ( ask_yesno ( ( char_u * ) _ ( ""backwards<s2sv_blank>range<s2sv_blank>given,<s2sv_blank>ok<s2sv_blank>to<s2sv_blank>swap"" ) , false ) != 'y' ) goto doend ; } lnum = ea . line1 ; ea . line1 = ea . line2 ; ea . line2 = lnum ; } if ( ( errormsg = invalid_range ( & ea ) ) != null ) goto doend ; } if ( ( ea . argt & notadr ) && ea . addr_count == 0 ) ea . line2 = 1 ; correct_range ( & ea ) ; # ifdef feat_folding if ( ( ( ea . argt & wholefold ) || ea . addr_count >= 2 ) && ! global_busy && ea . addr_type == addr_lines ) { ( void ) hasfolding ( ea . line1 , & ea . line1 , null ) ; ( void ) hasfolding ( ea . line2 , null , & ea . line2 ) ; } # endif # ifdef feat_quickfix p = replace_makeprg ( & ea , p , cmdlinep ) ; if ( p == null ) goto doend ; # endif if ( ea . cmdidx == cmd_bang ) ea . arg = p ; else ea . arg = skipwhite ( p ) ; if ( ea . cmdidx == cmd_file && * ea . arg != nul && curbuf_locked ( ) ) goto doend ; if ( ea . argt & argopt ) while ( ea . arg [ 0 ] == '+' && ea . arg [ 1 ] == '+' ) if ( getargopt ( & ea ) == fail && ! ni ) { errormsg = _ ( e_invarg ) ; goto doend ; } if ( ea . cmdidx == cmd_write || ea . cmdidx == cmd_update ) { if ( * ea . arg == '>' ) { if ( * ++ ea . arg != '>' ) { errormsg = _ ( ""e494:<s2sv_blank>use<s2sv_blank>w<s2sv_blank>or<s2sv_blank>w>>"" ) ; goto doend ; } ea . arg = skipwhite ( ea . arg + 1 ) ; ea . append = true ; } else if ( * ea . arg == '!' && ea . cmdidx == cmd_write ) { ++ ea . arg ; ea . usefilter = true ; } } if ( ea . cmdidx == cmd_read ) { if ( ea . forceit ) { ea . usefilter = true ; ea . forceit = false ; } else if ( * ea . arg == '!' ) { ++ ea . arg ; ea . usefilter = true ; } } if ( ea . cmdidx == cmd_lshift || ea . cmdidx == cmd_rshift ) { ea . amount = 1 ; while ( * ea . arg == * ea . cmd ) { ++ ea . arg ; ++ ea . amount ; } ea . arg = skipwhite ( ea . arg ) ; } if ( ( ea . argt & editcmd ) && ! ea . usefilter ) ea . do_ecmd_cmd = getargcmd ( & ea . arg ) ; if ( ( ea . argt & trlbar ) && ! ea . usefilter ) separate_nextcmd ( & ea ) ; else if ( ea . cmdidx == cmd_bang || ea . cmdidx == cmd_terminal || ea . cmdidx == cmd_global || ea . cmdidx == cmd_vglobal || ea . usefilter ) { for ( p = ea . arg ; * p ; ++ p ) { if ( * p == '\\\\' && p [ 1 ] == '\\n' ) strmove ( p , p + 1 ) ; else if ( * p == '\\n' ) { ea . nextcmd = p + 1 ; * p = nul ; break ; } } } if ( ( ea . argt & dflall ) && ea . addr_count == 0 ) { buf_t * buf ; ea . line1 = 1 ; switch ( ea . addr_type ) { case addr_lines : ea . line2 = curbuf -> b_ml . ml_line_count ; break ; case addr_loaded_buffers : buf = firstbuf ; while ( buf -> b_next != null && buf -> b_ml . ml_mfp == null ) buf = buf -> b_next ; ea . line1 = buf -> b_fnum ; buf = lastbuf ; while ( buf -> b_prev != null && buf -> b_ml . ml_mfp == null ) buf = buf -> b_prev ; ea . line2 = buf -> b_fnum ; break ; case addr_buffers : ea . line1 = firstbuf -> b_fnum ; ea . line2 = lastbuf -> b_fnum ; break ; case addr_windows : ea . line2 = last_win_nr ; break ; case addr_tabs : ea . line2 = last_tab_nr ; break ; case addr_tabs_relative : ea . line2 = 1 ; break ; case addr_arguments : if ( argcount == 0 ) ea . line1 = ea . line2 = 0 ; else ea . line2 = argcount ; break ; # ifdef feat_quickfix case addr_quickfix : ea . line2 = qf_get_size ( & ea ) ; if ( ea . line2 == 0 ) ea . line2 = 1 ; break ; # endif } } if ( ( ea . argt & regstr ) && * ea . arg != nul && ( ! is_user_cmdidx ( ea . cmdidx ) || * ea . arg != '=' ) && ! ( ( ea . argt & count ) && vim_isdigit ( * ea . arg ) ) ) { # ifndef feat_clipboard if ( * ea . arg == '*' || * ea . arg == '+' ) { errormsg = _ ( e_invalidreg ) ; goto doend ; } # endif if ( valid_yank_reg ( * ea . arg , ( ea . cmdidx != cmd_put && ! is_user_cmdidx ( ea . cmdidx ) ) ) ) { ea . regname = * ea . arg ++ ; # ifdef feat_eval if ( ea . arg [ - 1 ] == '=' && ea . arg [ 0 ] != nul ) { set_expr_line ( vim_strsave ( ea . arg ) ) ; ea . arg += strlen ( ea . arg ) ; } # endif ea . arg = skipwhite ( ea . arg ) ; } } if ( ( ea . argt & count ) && vim_isdigit ( * ea . arg ) && ( ! ( ea . argt & bufname ) || * ( p = skipdigits ( ea . arg ) ) == nul || vim_iswhite ( * p ) ) ) { n = getdigits ( & ea . arg ) ; ea . arg = skipwhite ( ea . arg ) ; if ( n <= 0 && ! ni && ( ea . argt & zeror ) == 0 ) { errormsg = _ ( e_zerocount ) ; goto doend ; } if ( ea . argt & notadr ) { ea . line2 = n ; if ( ea . addr_count == 0 ) ea . addr_count = 1 ; } else { ea . line1 = ea . line2 ; ea . line2 += n - 1 ; ++ ea . addr_count ; if ( ea . addr_type == addr_lines && ea . line2 > curbuf -> b_ml . ml_line_count ) ea . line2 = curbuf -> b_ml . ml_line_count ; } } if ( ea . argt & exflags ) get_flags ( & ea ) ; if ( ! ni && ! ( ea . argt & extra ) && * ea . arg != nul && * ea . arg != \'""\' && ( * ea . arg != '|' || ( ea . argt & trlbar ) == 0 ) ) { errormsg = _ ( e_trailing ) ; goto doend ; } if ( ! ni && ( ea . argt & needarg ) && * ea . arg == nul ) { errormsg = _ ( e_argreq ) ; goto doend ; } # ifdef feat_eval if ( ea . skip ) { switch ( ea . cmdidx ) { case cmd_while : case cmd_endwhile : case cmd_for : case cmd_endfor : case cmd_if : case cmd_elseif : case cmd_else : case cmd_endif : case cmd_try : case cmd_catch : case cmd_finally : case cmd_endtry : case cmd_function : break ; case cmd_aboveleft : case cmd_and : case cmd_belowright : case cmd_botright : case cmd_browse : case cmd_call : case cmd_confirm : case cmd_delfunction : case cmd_djump : case cmd_dlist : case cmd_dsearch : case cmd_dsplit : case cmd_echo : case cmd_echoerr : case cmd_echomsg : case cmd_echon : case cmd_execute : case cmd_filter : case cmd_help : case cmd_hide : case cmd_ijump : case cmd_ilist : case cmd_isearch : case cmd_isplit : case cmd_keepalt : case cmd_keepjumps : case cmd_keepmarks : case cmd_keeppatterns : case cmd_leftabove : case cmd_let : case cmd_lockmarks : case cmd_lua : case cmd_match : case cmd_mzscheme : case cmd_noautocmd : case cmd_noswapfile : case cmd_perl : case cmd_psearch : case cmd_python : case cmd_py3 : case cmd_python3 : case cmd_return : case cmd_rightbelow : case cmd_ruby : case cmd_silent : case cmd_smagic : case cmd_snomagic : case cmd_substitute : case cmd_syntax : case cmd_tab : case cmd_tcl : case cmd_throw : case cmd_tilde : case cmd_topleft : case cmd_unlet : case cmd_verbose : case cmd_vertical : case cmd_wincmd : break ; default : goto doend ; } } # endif if ( ea . argt & xfile ) { if ( expand_filename ( & ea , cmdlinep , & errormsg ) == fail ) goto doend ; } if ( ( ea . argt & bufname ) && * ea . arg != nul && ea . addr_count == 0 && ! is_user_cmdidx ( ea . cmdidx ) ) { if ( ea . cmdidx == cmd_bdelete || ea . cmdidx == cmd_bwipeout || ea . cmdidx == cmd_bunload ) p = skiptowhite_esc ( ea . arg ) ; else { p = ea . arg + strlen ( ea . arg ) ; while ( p > ea . arg && vim_iswhite ( p [ - 1 ] ) ) -- p ; } ea . line2 = buflist_findpat ( ea . arg , p , ( ea . argt & bufunl ) != 0 , false , false ) ; if ( ea . line2 < 0 ) goto doend ; ea . addr_count = 1 ; ea . arg = skipwhite ( p ) ; } if ( ea . cmdidx == cmd_try && ea . did_esilent > 0 ) { emsg_silent -= ea . did_esilent ; if ( emsg_silent < 0 ) emsg_silent = 0 ; ea . did_esilent = 0 ; } # ifdef feat_usr_cmds if ( is_user_cmdidx ( ea . cmdidx ) ) { do_ucmd ( & ea ) ; } else # endif { ea . errmsg = null ; ( cmdnames [ ea . cmdidx ] . cmd_func ) ( & ea ) ; if ( ea . errmsg != null ) errormsg = _ ( ea . errmsg ) ; } # ifdef feat_eval if ( need_rethrow ) do_throw ( cstack ) ; else if ( check_cstack ) { if ( source_finished ( fgetline , cookie ) ) do_finish ( & ea , true ) ; else if ( getline_equal ( fgetline , cookie , get_func_line ) && current_func_returned ( ) ) do_return ( & ea , true , false , null ) ; } need_rethrow = check_cstack = false ; # endif doend : if ( curwin -> w_cursor . lnum == 0 ) { curwin -> w_cursor . lnum = 1 ; curwin -> w_cursor . col = 0 ; } if ( errormsg != null && * errormsg != nul && ! did_emsg ) { if ( sourcing ) { if ( errormsg != ( char * ) iobuff ) { strcpy ( iobuff , errormsg ) ; errormsg = ( char * ) iobuff ; } append_command ( * cmdlinep ) ; } emsg ( errormsg ) ; } # ifdef feat_eval do_errthrow ( cstack , ( ea . cmdidx != cmd_size && ! is_user_cmdidx ( ea . cmdidx ) ) ? cmdnames [ ( int ) ea . cmdidx ] . cmd_name : ( char_u * ) null ) ; # endif if ( ea . verbose_save >= 0 ) p_verbose = ea . verbose_save ; free_cmdmod ( ) ; cmdmod = save_cmdmod ; if ( ea . save_msg_silent != - 1 ) { if ( ! did_emsg || msg_silent > ea . save_msg_silent ) msg_silent = ea . save_msg_silent ; emsg_silent -= ea . did_esilent ; if ( emsg_silent < 0 ) emsg_silent = 0 ; msg_scroll = save_msg_scroll ; if ( redirecting ( ) ) msg_col = 0 ; } # ifdef have_sandbox if ( ea . did_sandbox ) -- sandbox ; # endif if ( ea . nextcmd && * ea . nextcmd == nul ) ea . nextcmd = null ; # ifdef feat_eval -- ex_nesting_level ; # endif return ea . nextcmd ; }","<S2SV_ModStart> endif if ( restricted != 0 && ( ea . argt & RESTRICT ) ) { errormsg = _ ( ""E981:<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ; goto doend ; } if (
",vim@vim/8c62a08faf89663e5633dc5036cd8695c80f1075,CVE-2019-20807,https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075,2020-05-28T14:15Z,<S2SV_StartBug> if ( ! curbuf -> b_p_ma && ( ea . argt & MODIFY ) ) <S2SV_EndBug>
6338,CWE-772,"gpol_ret * get_policy_2_svc ( gpol_arg * arg , struct svc_req * rqstp ) { static gpol_ret ret ; kadm5_ret_t ret2 ; char * prime_arg , * funcname ; gss_buffer_desc client_name , service_name ; om_uint32 minor_stat ; kadm5_principal_ent_rec caller_ent ; kadm5_server_handle_t handle ; const char * errmsg = null ; xdr_free ( xdr_gpol_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_get_policy"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = kadm5_failure ; goto exit_func ; } prime_arg = arg -> name ; ret . code = kadm5_auth_get ; if ( ! changepw_service ( rqstp ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , acl_inquire , null , null ) ) ret . code = kadm5_ok ; else { ret . code = kadm5_get_principal ( handle -> lhandle , handle -> current_caller , & caller_ent , kadm5_principal_normal_mask ) ; if ( ret . code == kadm5_ok ) { if ( caller_ent . aux_attributes & kadm5_policy && strcmp ( caller_ent . policy , arg -> name ) == 0 ) { ret . code = kadm5_ok ; } else ret . code = kadm5_auth_get ; ret2 = kadm5_free_principal_ent ( handle -> lhandle , & caller_ent ) ; ret . code = ret . code ? ret . code : ret2 ; } } if ( ret . code == kadm5_ok ) { ret . code = kadm5_get_policy ( handle , arg -> name , & ret . rec ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , ( ( prime_arg == null ) ? ""(null)"" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != null ) krb5_free_error_message ( handle -> context , errmsg ) ; } else { log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; } gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug>"
2209,CWE-000,"static int iwch_l2t_send ( struct t3cdev * tdev , struct sk_buff * skb , struct l2t_entry * l2e ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - eio ; } error = l2t_send ( tdev , skb , l2e ) ; if ( error < 0 ) kfree_skb ( skb ) ; return error ; }","<S2SV_ModStart> ; return error < 0 ? error : 0
",torvalds@linux/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3,CVE-2015-8812,https://github.com/torvalds/linux/commit/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3,2016-04-27T17:59Z,<S2SV_StartBug> return error ; <S2SV_EndBug>
7519,CWE-416,"static int do_last ( struct nameidata * nd , struct file * file , const struct open_flags * op ) { struct dentry * dir = nd -> path . dentry ; int open_flag = op -> open_flag ; bool will_truncate = ( open_flag & o_trunc ) != 0 ; bool got_write = false ; int acc_mode = op -> acc_mode ; unsigned seq ; struct inode * inode ; struct path path ; int error ; nd -> flags &= ~ lookup_parent ; nd -> flags |= op -> intent ; if ( nd -> last_type != last_norm ) { error = handle_dots ( nd , nd -> last_type ) ; if ( unlikely ( error ) ) return error ; goto finish_open ; } if ( ! ( open_flag & o_creat ) ) { if ( nd -> last . name [ nd -> last . len ] ) nd -> flags |= lookup_follow | lookup_directory ; error = lookup_fast ( nd , & path , & inode , & seq ) ; if ( likely ( error > 0 ) ) goto finish_lookup ; if ( error < 0 ) return error ; bug_on ( nd -> inode != dir -> d_inode ) ; bug_on ( nd -> flags & lookup_rcu ) ; } else { error = complete_walk ( nd ) ; if ( error ) return error ; audit_inode ( nd -> name , dir , audit_inode_parent ) ; if ( unlikely ( nd -> last . name [ nd -> last . len ] ) ) return - eisdir ; } if ( open_flag & ( o_creat | o_trunc | o_wronly | o_rdwr ) ) { error = mnt_want_write ( nd -> path . mnt ) ; if ( ! error ) got_write = true ; } if ( open_flag & o_creat ) inode_lock ( dir -> d_inode ) ; else inode_lock_shared ( dir -> d_inode ) ; error = lookup_open ( nd , & path , file , op , got_write ) ; if ( open_flag & o_creat ) inode_unlock ( dir -> d_inode ) ; else inode_unlock_shared ( dir -> d_inode ) ; if ( error ) goto out ; if ( file -> f_mode & fmode_opened ) { if ( ( file -> f_mode & fmode_created ) || ! s_isreg ( file_inode ( file ) -> i_mode ) ) will_truncate = false ; audit_inode ( nd -> name , file -> f_path . dentry , 0 ) ; goto opened ; } if ( file -> f_mode & fmode_created ) { open_flag &= ~ o_trunc ; will_truncate = false ; acc_mode = 0 ; path_to_nameidata ( & path , nd ) ; goto finish_open_created ; } if ( got_write ) { mnt_drop_write ( nd -> path . mnt ) ; got_write = false ; } error = follow_managed ( & path , nd ) ; if ( unlikely ( error < 0 ) ) return error ; audit_inode ( nd -> name , path . dentry , 0 ) ; if ( unlikely ( ( open_flag & ( o_excl | o_creat ) ) == ( o_excl | o_creat ) ) ) { path_to_nameidata ( & path , nd ) ; return - eexist ; } seq = 0 ; inode = d_backing_inode ( path . dentry ) ; finish_lookup : error = step_into ( nd , & path , 0 , inode , seq ) ; if ( unlikely ( error ) ) return error ; finish_open : error = complete_walk ( nd ) ; if ( error ) return error ; audit_inode ( nd -> name , nd -> path . dentry , 0 ) ; if ( open_flag & o_creat ) { error = - eisdir ; if ( d_is_dir ( nd -> path . dentry ) ) goto out ; error = may_create_in_sticky ( dir , d_backing_inode ( nd -> path . dentry ) ) ; if ( unlikely ( error ) ) goto out ; } error = - enotdir ; if ( ( nd -> flags & lookup_directory ) && ! d_can_lookup ( nd -> path . dentry ) ) goto out ; if ( ! d_is_reg ( nd -> path . dentry ) ) will_truncate = false ; if ( will_truncate ) { error = mnt_want_write ( nd -> path . mnt ) ; if ( error ) goto out ; got_write = true ; } finish_open_created : error = may_open ( & nd -> path , acc_mode , open_flag ) ; if ( error ) goto out ; bug_on ( file -> f_mode & fmode_opened ) ; error = vfs_open ( & nd -> path , file ) ; if ( error ) goto out ; opened : error = ima_file_check ( file , op -> acc_mode ) ; if ( ! error && will_truncate ) error = handle_truncate ( file ) ; out : if ( unlikely ( error > 0 ) ) { warn_on ( 1 ) ; error = - einval ; } if ( got_write ) mnt_drop_write ( nd -> path . mnt ) ; return error ; }","<S2SV_ModStart> path . dentry ; kuid_t dir_uid = dir -> d_inode -> i_uid ; umode_t dir_mode = dir -> d_inode -> i_mode <S2SV_ModStart> = may_create_in_sticky ( dir_mode , dir_uid <S2SV_ModEnd> , d_backing_inode (
",torvalds@linux/d0cb50185ae942b03c4327be322055d622dc79f6,CVE-2020-8428,https://github.com/torvalds/linux/commit/d0cb50185ae942b03c4327be322055d622dc79f6,2020-01-29T00:15Z,"<S2SV_StartBug> struct dentry * dir = nd -> path . dentry ; <S2SV_EndBug> <S2SV_StartBug> error = may_create_in_sticky ( dir , <S2SV_EndBug>"
2249,CWE-416,"static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( sigpipe , current , 0 ) ; if ( ! ret ) ret = - epipe ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & splice_f_nonblock ) { ret = - eagain ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = null ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { pipe_buf_get ( ipipe , ibuf ) ; * obuf = * ibuf ; obuf -> flags &= ~ pipe_buf_flag_gift ; pipe_buf_mark_unmergeable ( obuf ) ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }","<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
",torvalds@linux/6b3a707736301c2128ca85ce85fb13f60b5e350a,CVE-2019-11487,https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a,2019-04-23T22:29Z,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug>"
7366,CWE-352,"void set_content_type ( httpresponse res , const char * mime ) { set_header ( res , ""content-type"" , mime ) ; }","<S2SV_ModStart> , ""Content-Type"" , ""%s"" ,
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,"<S2SV_StartBug> set_header ( res , ""Content-Type"" , mime ) ; <S2SV_EndBug>"
8115,CWE-295,"dh * get_dh2048 ( void ) { static unsigned char dhp_2048 [ ] = { 0xd5 , 0x75 , 0xf1 , 0x23 , 0xc1 , 0x81 , 0x4b , 0x44 , 0x23 , 0xbe , 0x97 , 0x81 , 0x7a , 0xda , 0x97 , 0x1f , 0x1f , 0x0d , 0xd5 , 0xec , 0xc5 , 0x5f , 0x86 , 0x42 , 0x7f , 0x38 , 0xa3 , 0x95 , 0xee , 0xa0 , 0x52 , 0x2c , 0xb7 , 0x20 , 0x29 , 0xc1 , 0xc7 , 0xe6 , 0x8e , 0x6f , 0xe5 , 0xc1 , 0x0d , 0xdd , 0x8a , 0xef , 0x8d , 0xe7 , 0xa8 , 0x63 , 0xb4 , 0xf7 , 0x58 , 0x32 , 0x0e , 0x24 , 0xac , 0x30 , 0x94 , 0xf5 , 0xc7 , 0x02 , 0x81 , 0x1b , 0xc7 , 0x68 , 0xe5 , 0x71 , 0xd7 , 0x1e , 0x3d , 0xe4 , 0x2e , 0x2f , 0xc0 , 0x0a , 0xed , 0x34 , 0xac , 0xc0 , 0x1f , 0x0a , 0x56 , 0xa4 , 0x12 , 0x02 , 0xfd , 0x68 , 0xd2 , 0x4d , 0x5e , 0x0a , 0x5d , 0x78 , 0xe3 , 0xa0 , 0x85 , 0x75 , 0xd2 , 0xa9 , 0xc1 , 0xf2 , 0xad , 0x65 , 0x11 , 0xde , 0xe8 , 0x05 , 0x68 , 0x36 , 0x4c , 0x92 , 0x99 , 0x21 , 0xb9 , 0x69 , 0xd0 , 0x6f , 0xd8 , 0xa3 , 0xea , 0x35 , 0x13 , 0x93 , 0xdc , 0x1b , 0x13 , 0x16 , 0xb2 , 0x15 , 0x8e , 0x10 , 0x22 , 0xce , 0x01 , 0x1f , 0x1c , 0x09 , 0x86 , 0xd5 , 0xe7 , 0xcb , 0xcf , 0xfa , 0xed , 0x2f , 0xe2 , 0x3a , 0x65 , 0x14 , 0xc9 , 0xfa , 0x70 , 0x99 , 0xf7 , 0xe0 , 0x30 , 0xbf , 0x7f , 0xea , 0x84 , 0x14 , 0x8a , 0x51 , 0xc9 , 0xe9 , 0x85 , 0x73 , 0x7f , 0xa1 , 0xb0 , 0xc3 , 0x33 , 0x9a , 0xab , 0x69 , 0x4e , 0x75 , 0xfb , 0x12 , 0xb0 , 0x9e , 0xb1 , 0xd9 , 0xd1 , 0xb9 , 0x32 , 0x1d , 0xc6 , 0xd9 , 0x2c , 0xaa , 0xb0 , 0xc5 , 0x3e , 0x69 , 0x56 , 0xa2 , 0xb3 , 0xa2 , 0x81 , 0xca , 0x9d , 0x77 , 0xbb , 0x52 , 0x44 , 0xa2 , 0xed , 0xe0 , 0xf0 , 0x2a , 0x81 , 0x85 , 0x90 , 0xb6 , 0x04 , 0x60 , 0xeb , 0x09 , 0x72 , 0x08 , 0x44 , 0xaf , 0x28 , 0xf5 , 0x15 , 0x34 , 0x87 , 0x5c , 0x8a , 0xb4 , 0x5b , 0x15 , 0x6a , 0xad , 0x27 , 0x4e , 0xa0 , 0xde , 0x99 , 0x22 , 0xcf , 0xab , 0x4c , 0xfd , 0x75 , 0x10 , 0x5d , 0xff , 0xe8 , 0x81 , 0x50 , 0xc4 , 0xc0 , 0x4b } ; static unsigned char dhg_2048 [ ] = { 0x02 } ; dh * dh = dh_new ( ) ; bignum * p , * g ; if ( dh == null ) return null ; p = bn_bin2bn ( dhp_2048 , sizeof ( dhp_2048 ) , null ) ; g = bn_bin2bn ( dhg_2048 , sizeof ( dhg_2048 ) , null ) ; if ( p == null || g == null || ! dh_set0_pqg ( dh , p , null , g ) ) { dh_free ( dh ) ; bn_free ( p ) ; bn_free ( g ) ; return null ; } return dh ; }","<S2SV_ModStart> ] = { 0xCF , 0x9F , 0x3A , 0x9C , 0xC5 , 0xA5 , 0x89 , 0x27 , 0x6D , 0x2C , 0x2C , 0xF3 , 0xA6 , 0x00 , 0xD2 , 0x7C , 0xEA , 0xFA , 0xF2 , 0x43 , 0x4F , 0x49 , 0x0A , 0xFC , 0xA6 , 0xE7 , 0x75 , 0xCA , 0x07 , 0xDC , 0xA5 , 0xF2 , 0x83 , 0x4E , 0x5A , 0xA0 , 0xA0 , 0xF5 , 0x9C , 0xFD , 0x02 , 0xE6 , 0x9E , 0xFC , 0x01 , 0x59 , 0xD7 , 0xB6 , 0xC1 , 0x4E , 0xC0 , 0xB6 , 0x71 , 0x49 , 0xF0 , 0xC7 , 0xD5 , 0x2F , 0x8D , 0xDF , 0xD3 , 0xF1 , 0x82 , 0x82 , 0x23 , 0x33 , 0x13 , 0x93 , 0xEB , 0x50 , 0x29 , 0xFD , 0x1B , 0x5A , 0x2F , 0xD5 , 0x08 , 0x99 , 0x64 , 0xE9 , 0x7B , 0x1A , 0xDD , 0x68 , 0x16 , 0x08 , 0xD0 , 0x13 , 0x82 , 0xB6 , 0x86 , 0x62 , 0x76 , 0xAA , 0x16 , 0x14 , 0xCC , 0x86 , 0x72 , 0x26 , 0x45 , 0x8E , 0x2A , 0x82 , 0x5B , 0x6F , 0xC1 , 0xDF , 0xAA , 0x18 , 0x43 , 0xB8 , 0xAD , 0x84 , 0x52 , 0xF2 , 0xD9 , 0x9C , 0xC0 , 0x47 , 0x52 , 0x1B , 0x8E , 0x42 , 0xC4 , 0xD3 , 0x61 , 0x7B , 0x65 , 0xA7 , 0x69 , 0x03 , 0xB5 , 0xD4 , 0x6C , 0x83 , 0x6A , 0x46 , 0x73 , 0xAF , 0x76 , 0x77 , 0x70 , 0xC2 , 0xD0 , 0x74 , 0xFE , 0x78 , 0xF5 , 0x75 , 0x3B , 0xCE , 0xE2 , 0xB6 , 0xA0 , 0x25 , 0xE9 , 0xE8 , 0x4B , 0xA2 , 0xF1 , 0x20 , 0x88 , 0x13 , 0x07 , 0xED , 0x66 , 0xBC , 0x46 , 0xA1 , 0xB3 , 0x44 , 0xAF , 0x2C , 0xED , 0x73 , 0x75 , 0x3D , 0x14 , 0x6E , 0x43 , 0x92 , 0x40 , 0x99 , 0xB0 , 0xD1 , 0xBF , 0x2C , 0x4D , 0x0F , 0x2A , 0x63 , 0xF4 , 0x85 , 0x7B , 0x1B , 0x0E , 0x48 , 0x5A , 0x06 , 0x02 , 0xA6 , 0x3D , 0x9E , 0x78 , 0x05 , 0xA8 , 0x7C , 0xAD , 0x54 , 0x49 , 0xDE , 0x7A , 0xE6 , 0x36 , 0x5C , 0x50 , 0xFC , 0x09 <S2SV_ModEnd> , 0x81 , <S2SV_ModStart> , 0x81 , 0x9E , 0x83 , 0x53 , 0x8C <S2SV_ModEnd> , 0x42 , <S2SV_ModStart> , 0x42 , 0xEF , 0x12 , 0x36 , 0x4F , 0x22 , 0x16 , 0x2A , 0x15 , 0x88 , 0x83 , 0xA9 , 0x00 , 0x66 , 0x9E , 0xD1 , 0xDC , 0x0F , 0x54 , 0xC0 , 0x32 , 0x5C , 0x4C , 0x5E , 0xE2 , 0x3D , 0xBC , 0x56 , 0x89 , 0x75 , 0x28 , 0xA3 <S2SV_ModEnd> } ; static
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,"<S2SV_StartBug> 0xD5 , 0x75 , 0xF1 , 0x23 , 0xC1 , 0x81 , 0x4B , 0x44 , 0x23 , 0xBE , <S2SV_EndBug> <S2SV_StartBug> 0xC5 , 0x5F , 0x86 , 0x42 , 0x7F , 0x38 , 0xA3 , 0x95 , 0xEE , 0xA0 , <S2SV_EndBug>"
7692,CWE-834,"static unsigned int xbminteger ( image * image , short int * hex_digits ) { int c ; unsigned int value ; do { c = readblobbyte ( image ) ; if ( c == eof ) return ( 0 ) ; } while ( ( c == '<s2sv_blank>' ) || ( c == '\\t' ) || ( c == '\\n' ) || ( c == '\\r' ) ) ; value = 0 ; do { if ( value > ( unsigned int ) ( int_max / 10 ) ) break ; value *= 16 ; c &= 0xff ; if ( value > ( unsigned int ) ( int_max - hex_digits [ c ] ) ) break ; value += hex_digits [ c ] ; c = readblobbyte ( image ) ; if ( c == eof ) return ( 0 ) ; } while ( hex_digits [ c ] >= 0 ) ; return ( value ) ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModEnd> int XBMInteger ( <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; return ( ( int )
",ImageMagick@ImageMagick/d9a8234d211da30baf9526fbebe9a8438ea7e11c,CVE-2017-14175,https://github.com/ImageMagick/ImageMagick/commit/d9a8234d211da30baf9526fbebe9a8438ea7e11c,2017-09-07T06:29Z,"<S2SV_StartBug> static unsigned int XBMInteger ( Image * image , short int * hex_digits ) <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( value ) ; <S2SV_EndBug>"
2117,CWE-119,"static int su3000_i2c_transfer ( struct i2c_adapter * adap , struct i2c_msg msg [ ] , int num ) { struct dvb_usb_device * d = i2c_get_adapdata ( adap ) ; u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ; if ( ! d ) return - enodev ; if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) return - eagain ; switch ( num ) { case 1 : switch ( msg [ 0 ] . addr ) { case su3000_stream_ctrl : obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ; obuf [ 1 ] = 3 ; obuf [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 ) err ( ""i2c<s2sv_blank>transfer<s2sv_blank>failed."" ) ; break ; case dw2102_rc_query : obuf [ 0 ] = 0x10 ; if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 ) err ( ""i2c<s2sv_blank>transfer<s2sv_blank>failed."" ) ; msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ; msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ; break ; default : obuf [ 0 ] = 0x08 ; obuf [ 1 ] = msg [ 0 ] . addr ; obuf [ 2 ] = msg [ 0 ] . len ; memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 , ibuf , 1 , 0 ) < 0 ) err ( ""i2c<s2sv_blank>transfer<s2sv_blank>failed."" ) ; } break ; case 2 : obuf [ 0 ] = 0x09 ; obuf [ 1 ] = msg [ 0 ] . len ; obuf [ 2 ] = msg [ 1 ] . len ; obuf [ 3 ] = msg [ 0 ] . addr ; memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 , ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 ) err ( ""i2c<s2sv_blank>transfer<s2sv_blank>failed."" ) ; memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ; break ; default : warn ( ""more<s2sv_blank>than<s2sv_blank>2<s2sv_blank>i2c<s2sv_blank>messages<s2sv_blank>at<s2sv_blank>a<s2sv_blank>time<s2sv_blank>is<s2sv_blank>not<s2sv_blank>handled<s2sv_blank>yet."" ) ; break ; } mutex_unlock ( & d -> i2c_mutex ) ; return num ; }","<S2SV_ModStart> adap ) ; struct dw2102_state * state <S2SV_ModEnd> ; if ( <S2SV_ModStart> - ENODEV ; state = d -> priv ; <S2SV_ModStart> - EAGAIN ; if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> case SU3000_STREAM_CTRL : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> + 0x36 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 3 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 0 , <S2SV_ModStart> case DW2102_RC_QUERY : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 2 , <S2SV_ModStart> 1 ] = state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> 0 ] = state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> ; default : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x08 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> . addr ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> case 2 : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x09 ; state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> . len ; state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 4 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 4 , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> buf , & state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> & d -> data_mutex ) ; mutex_unlock ( & d ->
",torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125,CVE-2017-8062,https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125,2017-04-23T05:59Z,"<S2SV_StartBug> u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> switch ( num ) { <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 3 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x10 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x08 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 , <S2SV_EndBug> <S2SV_StartBug> ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x09 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 3 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 , <S2SV_EndBug> <S2SV_StartBug> ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & d -> i2c_mutex ) ; <S2SV_EndBug>"
7691,CWE-834,"static image * readxbmimage ( const imageinfo * image_info , exceptioninfo * exception ) { char buffer [ magickpathextent ] , name [ magickpathextent ] ; image * image ; magickbooleantype status ; register ssize_t i , x ; register quantum * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length , padding , value , version , width ; assert ( image_info != ( const imageinfo * ) null ) ; assert ( image_info -> signature == magickcoresignature ) ; if ( image_info -> debug != magickfalse ) ( void ) logmagickevent ( traceevent , getmagickmodule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( exceptioninfo * ) null ) ; assert ( exception -> signature == magickcoresignature ) ; image = acquireimage ( image_info , exception ) ; status = openblob ( image_info , image , readbinaryblobmode , exception ) ; if ( status == magickfalse ) { image = destroyimagelist ( image ) ; return ( ( image * ) null ) ; } width = 0 ; height = 0 ; while ( readblobstring ( image , buffer ) != ( char * ) null ) if ( sscanf ( buffer , ""#define<s2sv_blank>%32s<s2sv_blank>%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( localecompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( readblobstring ( image , buffer ) != ( char * ) null ) if ( sscanf ( buffer , ""#define<s2sv_blank>%32s<s2sv_blank>%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( localecompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = pseudoclass ; image -> colors = 2 ; version = 11 ; while ( readblobstring ( image , buffer ) != ( char * ) null ) { if ( sscanf ( buffer , ""static<s2sv_blank>short<s2sv_blank>%32s<s2sv_blank>=<s2sv_blank>{"" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , ""static<s2sv_blank>unsigned<s2sv_blank>char<s2sv_blank>%32s<s2sv_blank>=<s2sv_blank>{"" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , ""static<s2sv_blank>char<s2sv_blank>%32s<s2sv_blank>=<s2sv_blank>{"" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) null ) p = ( unsigned char * ) name ; else p ++ ; if ( localecompare ( ""bits[]"" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( eofblob ( image ) != magickfalse ) ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; if ( acquireimagecolormap ( image , image -> colors , exception ) == magickfalse ) throwreaderexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; image -> colormap [ 0 ] . red = quantumrange ; image -> colormap [ 0 ] . green = quantumrange ; image -> colormap [ 0 ] . blue = quantumrange ; image -> colormap [ 1 ] . red = ( quantum ) 0 ; image -> colormap [ 1 ] . green = ( quantum ) 0 ; image -> colormap [ 1 ] . blue = ( quantum ) 0 ; if ( image_info -> ping != magickfalse ) { ( void ) closeblob ( image ) ; return ( getfirstimageinlist ( image ) ) ; } status = setimageextent ( image , image -> columns , image -> rows , exception ) ; if ( status == magickfalse ) return ( destroyimagelist ( image ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<s2sv_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) acquirequantummemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) null ) throwreaderexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) { value = xbminteger ( image , hex_digits ) ; * p ++ = ( unsigned char ) value ; if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) * p ++ = ( unsigned char ) ( value >> 8 ) ; } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { value = xbminteger ( image , hex_digits ) ; * p ++ = ( unsigned char ) value ; } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = queueauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 ) byte = ( size_t ) ( * p ++ ) ; setpixelindex ( image , ( quantum ) ( ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) , q ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; q += getpixelchannels ( image ) ; } if ( syncauthenticpixels ( image , exception ) == magickfalse ) break ; status = setimageprogress ( image , loadimagetag , ( magickoffsettype ) y , image -> rows ) ; if ( status == magickfalse ) break ; } data = ( unsigned char * ) relinquishmagickmemory ( data ) ; ( void ) syncimage ( image , exception ) ; ( void ) closeblob ( image ) ; return ( getfirstimageinlist ( image ) ) ; }","<S2SV_ModStart> Image * image ; int c <S2SV_ModStart> , padding , <S2SV_ModEnd> version , width <S2SV_ModStart> . red = ( MagickRealType ) <S2SV_ModStart> . green = ( MagickRealType ) <S2SV_ModStart> . blue = ( MagickRealType ) <S2SV_ModStart> . red = 0.0 <S2SV_ModEnd> ; image -> <S2SV_ModStart> . green = 0.0 <S2SV_ModEnd> ; image -> <S2SV_ModStart> . blue = 0.0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c <S2SV_ModEnd> ; if ( <S2SV_ModStart> char ) ( c <S2SV_ModEnd> >> 8 ) <S2SV_ModStart> ++ ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) <S2SV_ModEnd> ; } p <S2SV_ModStart> byte = ( unsigned int <S2SV_ModEnd> ) ( *
",ImageMagick@ImageMagick/d9a8234d211da30baf9526fbebe9a8438ea7e11c,CVE-2017-14175,https://github.com/ImageMagick/ImageMagick/commit/d9a8234d211da30baf9526fbebe9a8438ea7e11c,2017-09-07T06:29Z,"<S2SV_StartBug> * image ; <S2SV_EndBug> <S2SV_StartBug> value , <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . red = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . green = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . blue = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . red = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . green = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) ( value >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> byte = ( size_t ) ( * p ++ ) ; <S2SV_EndBug>"
2107,CWE-200,"static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - einval ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == ss_unconnected ) ) { res = - enotconn ; goto exit ; } timeout = sock_rcvtimeo ( sk , flags & msg_dontwait ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == ss_disconnecting ) { res = - enotconn ; goto exit ; } if ( timeout <= 0l ) { res = timeout ? timeout : - ewouldblock ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= msg_trunc ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; } else { if ( ( sock -> state == ss_ready ) || ( ( err == tipc_conn_shutdown ) || m -> msg_control ) ) res = 0 ; else res = - econnreset ; } if ( likely ( ! ( flags & msg_peek ) ) ) { if ( ( sock -> state != ss_ready ) && ( ++ tport -> conn_unacked >= tipc_flow_control_win ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } exit : release_sock ( sk ) ; return res ; }","<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
",torvalds@linux/60085c3d009b0df252547adb336d1ccca5ce52ec,CVE-2013-3235,https://github.com/torvalds/linux/commit/60085c3d009b0df252547adb336d1ccca5ce52ec,2013-04-22T11:41Z,"<S2SV_StartBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <S2SV_EndBug>"
4774,CWE-119,"int l2tp_recv ( int fd , struct l2tp_packet_t * * p , struct in_pktinfo * pkt_info , const char * secret , size_t secret_len ) { int n , length ; uint8_t * buf ; struct l2tp_hdr_t * hdr ; struct l2tp_avp_t * avp ; struct l2tp_dict_attr_t * da ; struct l2tp_attr_t * attr , * rv = null ; uint8_t * ptr ; struct l2tp_packet_t * pack ; struct sockaddr_in addr ; socklen_t len = sizeof ( addr ) ; struct msghdr msg ; char msg_control [ 128 ] ; struct cmsghdr * cmsg ; uint16_t orig_avp_len ; void * orig_avp_val ; * p = null ; if ( pkt_info ) { memset ( & msg , 0 , sizeof ( msg ) ) ; msg . msg_control = msg_control ; msg . msg_controllen = 128 ; n = recvmsg ( fd , & msg , msg_peek ) ; if ( n < 0 ) { if ( errno == eagain ) return - 1 ; log_error ( ""l2tp:<s2sv_blank>recvmsg:<s2sv_blank>%s\\n"" , strerror ( errno ) ) ; return 0 ; } for ( cmsg = cmsg_firsthdr ( & msg ) ; cmsg != null ; cmsg = cmsg_nxthdr ( & msg , cmsg ) ) { if ( cmsg -> cmsg_level == ipproto_ip && cmsg -> cmsg_type == ip_pktinfo ) { memcpy ( pkt_info , cmsg_data ( cmsg ) , sizeof ( * pkt_info ) ) ; break ; } } } buf = mempool_alloc ( buf_pool ) ; if ( ! buf ) { log_emerg ( ""l2tp:<s2sv_blank>out<s2sv_blank>of<s2sv_blank>memory\\n"" ) ; return 0 ; } hdr = ( struct l2tp_hdr_t * ) buf ; ptr = ( uint8_t * ) ( hdr + 1 ) ; n = recvfrom ( fd , buf , l2tp_max_packet_size , 0 , & addr , & len ) ; if ( n < 0 ) { mempool_free ( buf ) ; if ( errno == eagain ) { return - 1 ; } else if ( errno == econnrefused ) { return - 2 ; } log_error ( ""l2tp:<s2sv_blank>recv:<s2sv_blank>%s\\n"" , strerror ( errno ) ) ; return 0 ; } if ( n < 6 ) { if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>short<s2sv_blank>packet<s2sv_blank>received<s2sv_blank>(%i/%zu)\\n"" , n , sizeof ( * hdr ) ) ; goto out_err_hdr ; } if ( hdr -> t == 0 ) goto out_err_hdr ; if ( n < ntohs ( hdr -> length ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>short<s2sv_blank>packet<s2sv_blank>received<s2sv_blank>(%i/%i)\\n"" , n , ntohs ( hdr -> length ) ) ; goto out_err_hdr ; } if ( hdr -> ver == 2 ) { if ( hdr -> l == 0 ) { if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>incorrect<s2sv_blank>message<s2sv_blank>received<s2sv_blank>(l=0)\\n"" ) ; if ( ! conf_avp_permissive ) goto out_err_hdr ; } if ( hdr -> s == 0 ) { if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>incorrect<s2sv_blank>message<s2sv_blank>received<s2sv_blank>(s=0)\\n"" ) ; if ( ! conf_avp_permissive ) goto out_err_hdr ; } if ( hdr -> o == 1 ) { if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>incorrect<s2sv_blank>message<s2sv_blank>received<s2sv_blank>(o=1)\\n"" ) ; if ( ! conf_avp_permissive ) goto out_err_hdr ; } } else if ( hdr -> ver != 3 ) { if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>protocol<s2sv_blank>version<s2sv_blank>%i<s2sv_blank>is<s2sv_blank>not<s2sv_blank>supported\\n"" , hdr -> ver ) ; goto out_err_hdr ; } pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) { log_emerg ( ""l2tp:<s2sv_blank>out<s2sv_blank>of<s2sv_blank>memory\\n"" ) ; goto out_err_hdr ; } memset ( pack , 0 , sizeof ( * pack ) ) ; init_list_head ( & pack -> attrs ) ; memcpy ( & pack -> addr , & addr , sizeof ( addr ) ) ; memcpy ( & pack -> hdr , hdr , sizeof ( * hdr ) ) ; length = ntohs ( hdr -> length ) - sizeof ( * hdr ) ; while ( length ) { * ( uint16_t * ) ptr = ntohs ( * ( uint16_t * ) ptr ) ; avp = ( struct l2tp_avp_t * ) ptr ; if ( avp -> length > length ) { if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>incorrect<s2sv_blank>avp<s2sv_blank>received<s2sv_blank>(exceeds<s2sv_blank>message<s2sv_blank>length)\\n"" ) ; goto out_err ; } if ( avp -> vendor ) goto skip ; da = l2tp_dict_find_attr_by_id ( ntohs ( avp -> type ) ) ; if ( ! da ) { if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>unknown<s2sv_blank>avp<s2sv_blank>received<s2sv_blank>(type=%i,<s2sv_blank>m=%u)\\n"" , ntohs ( avp -> type ) , avp -> m ) ; if ( avp -> m && ! conf_avp_permissive ) goto out_err ; } else { if ( da -> m != - 1 && da -> m != avp -> m ) { if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>incorrect<s2sv_blank>avp<s2sv_blank>received<s2sv_blank>(type=%i,<s2sv_blank>m=%i,<s2sv_blank>must<s2sv_blank>be<s2sv_blank>%i)\\n"" , ntohs ( avp -> type ) , avp -> m , da -> m ) ; if ( ! conf_avp_permissive ) goto out_err ; } if ( da -> h != - 1 && da -> h != avp -> h ) { if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>incorrect<s2sv_blank>avp<s2sv_blank>received<s2sv_blank>(type=%i,<s2sv_blank>h=%i,<s2sv_blank>must<s2sv_blank>be<s2sv_blank>%i)\\n"" , ntohs ( avp -> type ) , avp -> h , da -> h ) ; if ( ! conf_avp_permissive ) goto out_err ; } if ( avp -> h ) { if ( ! rv ) { if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>incorrect<s2sv_blank>avp<s2sv_blank>received<s2sv_blank>(type=%i,<s2sv_blank>h=1,<s2sv_blank>but<s2sv_blank>random-vector<s2sv_blank>is<s2sv_blank>not<s2sv_blank>received)\\n"" , ntohs ( avp -> type ) ) ; goto out_err ; } if ( secret == null || secret_len == 0 ) { log_error ( ""l2tp:<s2sv_blank>impossible<s2sv_blank>to<s2sv_blank>decode"" ""<s2sv_blank>hidden<s2sv_blank>avp<s2sv_blank>(type<s2sv_blank>%hu):<s2sv_blank>no"" ""<s2sv_blank>secret<s2sv_blank>set)\\n"" , ntohs ( avp -> type ) ) ; goto out_err ; } if ( decode_avp ( avp , rv , secret , secret_len ) < 0 ) goto out_err ; } attr = mempool_alloc ( attr_pool ) ; memset ( attr , 0 , sizeof ( * attr ) ) ; list_add_tail ( & attr -> entry , & pack -> attrs ) ; if ( avp -> h ) { orig_avp_len = ntohs ( * ( uint16_t * ) avp -> val ) + sizeof ( * avp ) ; orig_avp_val = avp -> val + sizeof ( uint16_t ) ; } else { orig_avp_len = avp -> length ; orig_avp_val = avp -> val ; } attr -> attr = da ; attr -> m = avp -> m ; attr -> h = 0 ; attr -> length = orig_avp_len - sizeof ( * avp ) ; if ( attr -> attr -> id == random_vector ) rv = attr ; switch ( da -> type ) { case attr_type_int16 : if ( orig_avp_len != sizeof ( * avp ) + 2 ) goto out_err_len ; attr -> val . uint16 = ntohs ( * ( uint16_t * ) orig_avp_val ) ; break ; case attr_type_int32 : if ( orig_avp_len != sizeof ( * avp ) + 4 ) goto out_err_len ; attr -> val . uint32 = ntohl ( * ( uint32_t * ) orig_avp_val ) ; break ; case attr_type_int64 : if ( orig_avp_len != sizeof ( * avp ) + 8 ) goto out_err_len ; attr -> val . uint64 = be64toh ( * ( uint64_t * ) orig_avp_val ) ; break ; case attr_type_octets : attr -> val . octets = _malloc ( attr -> length ) ; if ( ! attr -> val . octets ) goto out_err_mem ; memcpy ( attr -> val . octets , orig_avp_val , attr -> length ) ; break ; case attr_type_string : attr -> val . string = _malloc ( attr -> length + 1 ) ; if ( ! attr -> val . string ) goto out_err_mem ; memcpy ( attr -> val . string , orig_avp_val , attr -> length ) ; attr -> val . string [ attr -> length ] = 0 ; break ; } } skip : ptr += avp -> length ; length -= avp -> length ; } * p = pack ; mempool_free ( buf ) ; return 0 ; out_err : l2tp_packet_free ( pack ) ; out_err_hdr : mempool_free ( buf ) ; return 0 ; out_err_len : if ( conf_verbose ) log_warn ( ""l2tp:<s2sv_blank>incorrect<s2sv_blank>avp<s2sv_blank>received<s2sv_blank>(type=%i,<s2sv_blank>incorrect<s2sv_blank>length<s2sv_blank>%i)\\n"" , ntohs ( avp -> type ) , orig_avp_len ) ; goto out_err ; out_err_mem : log_emerg ( ""l2tp:<s2sv_blank>out<s2sv_blank>of<s2sv_blank>memory\\n"" ) ; goto out_err ; }","<S2SV_ModStart> secret_len ) { struct l2tp_packet_t * pack <S2SV_ModEnd> ; struct l2tp_hdr_t <S2SV_ModStart> avp ; struct l2tp_attr_t * <S2SV_ModEnd> RV = NULL <S2SV_ModStart> RV = NULL <S2SV_ModEnd> ; struct sockaddr_in <S2SV_ModStart> addr ; socklen_t addr_len ; uint16_t orig_avp_len ; void * orig_avp_val ; uint8_t * buf , * ptr ; int n , length ; * p = NULL ; if ( pkt_info ) { <S2SV_ModEnd> struct msghdr msg <S2SV_ModStart> struct msghdr msg ; struct cmsghdr * cmsg <S2SV_ModStart> 128 ] ; <S2SV_ModEnd> memset ( & <S2SV_ModStart> . msg_controllen = sizeof ( msg_control ) <S2SV_ModEnd> ; n = <S2SV_ModStart> 1 ) ; addr_len = sizeof ( addr ) ; <S2SV_ModStart> addr , & addr_len <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( n < sizeof ( * hdr ) <S2SV_ModEnd> ) { if <S2SV_ModStart> out_err_hdr ; } hdr -> flags = ntohs ( hdr -> flags ) ; if ( ! ( hdr -> flags & L2TP_FLAG_T ) <S2SV_ModEnd> ) goto out_err_hdr <S2SV_ModStart> goto out_err_hdr ; if ( ! ( hdr -> flags & L2TP_FLAG_L ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\n"" ) ; goto out_err_hdr ; } if ( ! ( hdr -> flags & L2TP_FLAG_S ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(S=0)\\n"" ) ; goto out_err_hdr ; } switch ( hdr -> flags & L2TP_VER_MASK ) { case 2 : if ( hdr -> flags & L2TP_FLAG_O ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(O=1)\\n"" ) ; goto out_err_hdr ; } break ; case 3 : break ; default : if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>%i<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" , hdr -> flags & L2TP_VER_MASK ) ; goto out_err_hdr ; } length = ntohs ( hdr -> length ) ; if ( length < sizeof ( * hdr ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%zu)\\n"" , length , sizeof ( * hdr ) ) ; goto out_err_hdr ; } else <S2SV_ModStart> ( n < length ) <S2SV_ModEnd> { if ( <S2SV_ModStart> , n , length ) <S2SV_ModEnd> ; goto out_err_hdr <S2SV_ModStart> out_err_hdr ; } pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) { log_emerg ( ""l2tp:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; goto out_err_hdr ; } memset ( pack , 0 , sizeof ( * pack ) ) ; INIT_LIST_HEAD ( & pack -> attrs ) ; memcpy ( & pack -> addr , & addr , sizeof ( addr ) ) ; memcpy ( & pack -> hdr , hdr , sizeof ( * hdr ) ) ; length -= sizeof ( * hdr ) ; while ( length > 0 ) { struct l2tp_dict_attr_t * da ; struct l2tp_attr_t * attr ; uint16_t avp_len ; if ( length < sizeof ( * avp ) <S2SV_ModEnd> ) { if <S2SV_ModStart> ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>avp<S2SV_blank>received\\n"" ) ; goto out_err ; } <S2SV_ModEnd> avp = ( <S2SV_ModStart> ) ptr ; avp -> flags = ntohs ( avp -> flags ) ; avp_len = avp -> flags & L2TP_AVP_LEN_MASK ; if ( avp_len < sizeof ( * avp ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>avp<S2SV_blank>received\\n"" ) ; goto out_err ; } else if ( length < avp_len <S2SV_ModEnd> ) { if <S2SV_ModStart> ( conf_verbose ) { <S2SV_ModStart> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) ; } if ( ( avp -> flags & L2TP_AVP_FLAG_M ) <S2SV_ModEnd> && ! conf_avp_permissive <S2SV_ModStart> - 1 && ! <S2SV_ModStart> -> M != ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) { if ( conf_verbose ) { log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n"" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) , da <S2SV_ModEnd> -> M ) <S2SV_ModStart> -> M ) ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> - 1 && ! <S2SV_ModStart> -> H != ! ( avp -> flags & L2TP_AVP_FLAG_H ) ) { if ( conf_verbose ) { log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>H=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n"" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_H ) , da <S2SV_ModEnd> -> H ) <S2SV_ModStart> -> H ) ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( avp -> flags & L2TP_AVP_FLAG_H <S2SV_ModEnd> ) { if <S2SV_ModStart> goto out_err ; <S2SV_ModEnd> orig_avp_len = ntohs <S2SV_ModStart> { orig_avp_len = avp_len <S2SV_ModEnd> ; orig_avp_val = <S2SV_ModStart> ; } attr = mempool_alloc ( attr_pool ) ; memset ( attr , 0 , sizeof ( * attr ) ) ; attr <S2SV_ModStart> -> M = ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) <S2SV_ModEnd> ; attr -> <S2SV_ModStart> ( * avp ) ; list_add_tail ( & attr -> entry , & pack -> attrs <S2SV_ModStart> : ptr += avp_len <S2SV_ModEnd> ; length -= <S2SV_ModStart> ; length -= avp_len <S2SV_ModEnd> ; } *
",accel-ppp@accel-ppp/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,CVE-2020-15173,https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,2020-09-09T23:15Z,"<S2SV_StartBug> int n , length ; <S2SV_EndBug> <S2SV_StartBug> struct l2tp_dict_attr_t * da ; <S2SV_EndBug> <S2SV_StartBug> struct l2tp_attr_t * attr , * RV = NULL ; <S2SV_EndBug> <S2SV_StartBug> socklen_t len = sizeof ( addr ) ; <S2SV_EndBug> <S2SV_StartBug> struct msghdr msg ; <S2SV_EndBug> <S2SV_StartBug> struct cmsghdr * cmsg ; <S2SV_EndBug> <S2SV_StartBug> msg . msg_controllen = 128 ; <S2SV_EndBug> <S2SV_StartBug> n = recvfrom ( fd , buf , L2TP_MAX_PACKET_SIZE , 0 , & addr , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( n < 6 ) { <S2SV_EndBug> <S2SV_StartBug> if ( hdr -> T == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( n < ntohs ( hdr -> length ) ) { <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%i)\\n"" , n , ntohs ( hdr -> length ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( hdr -> ver == 2 ) { <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( avp -> length > length ) { <S2SV_EndBug> <S2SV_StartBug> if ( conf_verbose ) <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>unknown<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%u)\\n"" , ntohs ( avp -> type ) , avp -> M ) ; <S2SV_EndBug> <S2SV_StartBug> if ( da -> M != - 1 && da -> M != avp -> M ) { <S2SV_EndBug> <S2SV_StartBug> if ( da -> H != - 1 && da -> H != avp -> H ) { <S2SV_EndBug> <S2SV_StartBug> if ( avp -> H ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> orig_avp_len = avp -> length ; <S2SV_EndBug> <S2SV_StartBug> attr -> attr = da ; <S2SV_EndBug> <S2SV_StartBug> attr -> M = avp -> M ; <S2SV_EndBug> <S2SV_StartBug> attr -> length = orig_avp_len - sizeof ( * avp ) ; <S2SV_EndBug> <S2SV_StartBug> ptr += avp -> length ; <S2SV_EndBug> <S2SV_StartBug> length -= avp -> length ; <S2SV_EndBug>"
5556,CWE-835,"int lookup ( struct sip_msg * _m , char * _t , char * _f , char * _s ) { unsigned int flags ; urecord_t * r ; str aor , uri ; ucontact_t * ptr , * it ; int res ; int ret ; str path_dst ; str flags_s ; pv_value_t val ; int_str istr ; str sip_instance = { 0 , 0 } , call_id = { 0 , 0 } ; flags = 0 ; if ( _f && _f [ 0 ] != 0 ) { if ( fixup_get_svalue ( _m , ( gparam_p ) _f , & flags_s ) != 0 ) { lm_err ( ""invalid<s2sv_blank>owner<s2sv_blank>uri<s2sv_blank>parameter"" ) ; return - 1 ; } for ( res = 0 ; res < flags_s . len ; res ++ ) { switch ( flags_s . s [ res ] ) { case 'm' : flags |= reg_lookup_methodfilter_flag ; break ; case 'b' : flags |= reg_lookup_nobranch_flag ; break ; default : lm_warn ( ""unsuported<s2sv_blank>flag<s2sv_blank>%c<s2sv_blank>\\n"" , flags_s . s [ res ] ) ; } } } if ( _s ) { if ( pv_get_spec_value ( _m , ( pv_spec_p ) _s , & val ) != 0 ) { lm_err ( ""failed<s2sv_blank>to<s2sv_blank>get<s2sv_blank>pv<s2sv_blank>value\\n"" ) ; return - 1 ; } if ( ( val . flags & pv_val_str ) == 0 ) { lm_err ( ""pv<s2sv_blank>vals<s2sv_blank>is<s2sv_blank>not<s2sv_blank>string\\n"" ) ; return - 1 ; } uri = val . rs ; } else { if ( _m -> new_uri . s ) uri = _m -> new_uri ; else uri = _m -> first_line . u . request . uri ; } if ( extract_aor ( & uri , & aor , & sip_instance , & call_id ) < 0 ) { lm_err ( ""failed<s2sv_blank>to<s2sv_blank>extract<s2sv_blank>address<s2sv_blank>of<s2sv_blank>record\\n"" ) ; return - 3 ; } get_act_time ( ) ; ul . lock_udomain ( ( udomain_t * ) _t , & aor ) ; res = ul . get_urecord ( ( udomain_t * ) _t , & aor , & r ) ; if ( res > 0 ) { lm_dbg ( ""\'%.*s\'<s2sv_blank>not<s2sv_blank>found<s2sv_blank>in<s2sv_blank>usrloc\\n"" , aor . len , zsw ( aor . s ) ) ; ul . unlock_udomain ( ( udomain_t * ) _t , & aor ) ; return - 1 ; } ptr = r -> contacts ; ret = - 1 ; search_valid_contact : while ( ( ptr ) && ! ( valid_contact ( ptr , act_time ) && ( ret = - 2 ) && allowed_method ( _m , ptr , flags ) ) ) ptr = ptr -> next ; if ( ptr == 0 ) { lm_dbg ( ""nothing<s2sv_blank>found<s2sv_blank>!\\n"" ) ; goto done ; } if ( sip_instance . len && sip_instance . s ) { lm_dbg ( ""ruri<s2sv_blank>has<s2sv_blank>gruu<s2sv_blank>in<s2sv_blank>lookup\\n"" ) ; if ( ptr -> instance . len - 2 != sip_instance . len || memcmp ( ptr -> instance . s + 1 , sip_instance . s , sip_instance . len ) ) { lm_dbg ( ""no<s2sv_blank>match<s2sv_blank>to<s2sv_blank>sip<s2sv_blank>instace<s2sv_blank>-<s2sv_blank>[%.*s]<s2sv_blank>-<s2sv_blank>[%.*s]\\n"" , ptr -> instance . len - 2 , ptr -> instance . s + 1 , sip_instance . len , sip_instance . s ) ; ptr = ptr -> next ; goto search_valid_contact ; } lm_dbg ( ""matched<s2sv_blank>sip<s2sv_blank>instace\\n"" ) ; } if ( call_id . len && call_id . s ) { if ( ptr -> callid . len != call_id . len || memcmp ( ptr -> callid . s , call_id . s , call_id . len ) ) { lm_dbg ( ""no<s2sv_blank>match<s2sv_blank>to<s2sv_blank>call<s2sv_blank>id<s2sv_blank>-<s2sv_blank>[%.*s]<s2sv_blank>-<s2sv_blank>[%.*s]\\n"" , ptr -> callid . len , ptr -> callid . s , call_id . len , call_id . s ) ; ptr = ptr -> next ; goto search_valid_contact ; } it = ptr -> next ; while ( it ) { if ( valid_contact ( it , act_time ) ) { if ( it -> instance . len - 2 == sip_instance . len && memcmp ( it -> instance . s + 1 , sip_instance . s , sip_instance . len ) == 0 ) if ( it -> last_modified > ptr -> last_modified ) { break ; } } } if ( it != null ) { ret = - 1 ; goto done ; } } lm_dbg ( ""found<s2sv_blank>a<s2sv_blank>complete<s2sv_blank>match\\n"" ) ; ret = 1 ; if ( ptr ) { lm_dbg ( ""setting<s2sv_blank>as<s2sv_blank>ruri<s2sv_blank><%.*s>\\n"" , ptr -> c . len , ptr -> c . s ) ; if ( set_ruri ( _m , & ptr -> c ) < 0 ) { lm_err ( ""unable<s2sv_blank>to<s2sv_blank>rewrite<s2sv_blank>request-uri\\n"" ) ; ret = - 3 ; goto done ; } if ( ptr -> path . s && ptr -> path . len ) { if ( get_path_dst_uri ( & ptr -> path , & path_dst ) < 0 ) { lm_err ( ""failed<s2sv_blank>to<s2sv_blank>get<s2sv_blank>dst_uri<s2sv_blank>for<s2sv_blank>path\\n"" ) ; ret = - 3 ; goto done ; } if ( set_path_vector ( _m , & ptr -> path ) < 0 ) { lm_err ( ""failed<s2sv_blank>to<s2sv_blank>set<s2sv_blank>path<s2sv_blank>vector\\n"" ) ; ret = - 3 ; goto done ; } if ( set_dst_uri ( _m , & path_dst ) < 0 ) { lm_err ( ""failed<s2sv_blank>to<s2sv_blank>set<s2sv_blank>dst_uri<s2sv_blank>of<s2sv_blank>path\\n"" ) ; ret = - 3 ; goto done ; } } else if ( ptr -> received . s && ptr -> received . len ) { if ( set_dst_uri ( _m , & ptr -> received ) < 0 ) { ret = - 3 ; goto done ; } } set_ruri_q ( ptr -> q ) ; setbflag ( 0 , ptr -> cflags ) ; if ( ptr -> sock ) _m -> force_send_socket = ptr -> sock ; if ( attr_avp_name != - 1 ) { istr . s = ptr -> attr ; if ( add_avp_last ( avp_val_str , attr_avp_name , istr ) != 0 ) { lm_err ( ""failed<s2sv_blank>to<s2sv_blank>populate<s2sv_blank>attr<s2sv_blank>avp!\\n"" ) ; } } ptr = ptr -> next ; } if ( flags & reg_lookup_nobranch_flag || ( sip_instance . len && sip_instance . s ) ) goto done ; lm_dbg ( ""looking<s2sv_blank>for<s2sv_blank>branches\\n"" ) ; for ( ; ptr ; ptr = ptr -> next ) { if ( valid_contact ( ptr , act_time ) && allowed_method ( _m , ptr , flags ) ) { path_dst . len = 0 ; if ( ptr -> path . s && ptr -> path . len && get_path_dst_uri ( & ptr -> path , & path_dst ) < 0 ) { lm_err ( ""failed<s2sv_blank>to<s2sv_blank>get<s2sv_blank>dst_uri<s2sv_blank>for<s2sv_blank>path\\n"" ) ; continue ; } lm_dbg ( ""setting<s2sv_blank>branch<s2sv_blank><%.*s>\\n"" , ptr -> c . len , ptr -> c . s ) ; if ( append_branch ( _m , & ptr -> c , path_dst . len ? & path_dst : & ptr -> received , & ptr -> path , ptr -> q , ptr -> cflags , ptr -> sock ) == - 1 ) { lm_err ( ""failed<s2sv_blank>to<s2sv_blank>append<s2sv_blank>a<s2sv_blank>branch\\n"" ) ; continue ; } if ( attr_avp_name != - 1 ) { istr . s = ptr -> attr ; if ( add_avp_last ( avp_val_str , attr_avp_name , istr ) != 0 ) { lm_err ( ""failed<s2sv_blank>to<s2sv_blank>populate<s2sv_blank>attr<s2sv_blank>avp!\\n"" ) ; } } } } done : ul . release_urecord ( r ) ; ul . unlock_udomain ( ( udomain_t * ) _t , & aor ) ; return ret ; }","<S2SV_ModStart> ; } } it = it -> next ;
",OpenSIPS@opensips/54e027adfa486cfcf993828512b2e273aeb163c2,CVE-2013-3722,https://github.com/OpenSIPS/opensips/commit/54e027adfa486cfcf993828512b2e273aeb163c2,2020-02-17T17:15Z,<S2SV_StartBug> } <S2SV_EndBug>
617,CWE-20,"static void dissect_rpcap_packet ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * top_tree , proto_tree * parent_tree , gint offset , proto_item * top_item ) { proto_tree * tree ; proto_item * ti ; nstime_t ts ; tvbuff_t * new_tvb ; guint caplen , len , frame_no ; gint reported_length_remaining ; ti = proto_tree_add_item ( parent_tree , hf_packet , tvb , offset , 20 , enc_na ) ; tree = proto_item_add_subtree ( ti , ett_packet ) ; ts . secs = tvb_get_ntohl ( tvb , offset ) ; ts . nsecs = tvb_get_ntohl ( tvb , offset + 4 ) * 1000 ; proto_tree_add_time ( tree , hf_timestamp , tvb , offset , 8 , & ts ) ; offset += 8 ; caplen = tvb_get_ntohl ( tvb , offset ) ; ti = proto_tree_add_item ( tree , hf_caplen , tvb , offset , 4 , enc_big_endian ) ; offset += 4 ; len = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_len , tvb , offset , 4 , enc_big_endian ) ; offset += 4 ; frame_no = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_npkt , tvb , offset , 4 , enc_big_endian ) ; offset += 4 ; proto_item_append_text ( ti , "",<s2sv_blank>frame<s2sv_blank>%u"" , frame_no ) ; proto_item_append_text ( top_item , ""<s2sv_blank>frame<s2sv_blank>%u"" , frame_no ) ; reported_length_remaining = tvb_reported_length_remaining ( tvb , offset ) ; if ( caplen > ( guint ) reported_length_remaining ) { expert_add_info ( pinfo , ti , & ei_caplen_too_big ) ; return ; } new_tvb = tvb_new_subset ( tvb , offset , caplen , len ) ; if ( decode_content && linktype != wtap_encap_unknown ) { dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; if ( ! info_added ) { col_prepend_fence_fstr ( pinfo -> cinfo , col_protocol , ""r|"" ) ; col_prepend_fence_fstr ( pinfo -> cinfo , col_info , ""remote<s2sv_blank>|<s2sv_blank>"" ) ; info_added = true ; register_frame_end_routine ( pinfo , rpcap_frame_end ) ; } } else { if ( linktype == wtap_encap_unknown ) { proto_item_append_text ( ti , "",<s2sv_blank>unknown<s2sv_blank>link-layer<s2sv_blank>type"" ) ; } call_dissector ( data_handle , new_tvb , pinfo , top_tree ) ; } }","<S2SV_ModStart> ; gint reported_length_remaining ; struct eth_phdr eth ; void * phdr <S2SV_ModStart> WTAP_ENCAP_UNKNOWN ) { switch ( linktype ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> pinfo , top_tree , TRUE , phdr
",wireshark@wireshark/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,CVE-2016-5358,https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,2016-08-07T16:59Z,"<S2SV_StartBug> gint reported_length_remaining ; <S2SV_EndBug> <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; <S2SV_EndBug>"
7468,CWE-476,"vtermstate * vterm_obtain_state ( vterm * vt ) { vtermstate * state ; if ( vt -> state ) return vt -> state ; state = vterm_state_new ( vt ) ; vt -> state = state ; state -> combine_chars_size = 16 ; state -> combine_chars = vterm_allocator_malloc ( state -> vt , state -> combine_chars_size * sizeof ( state -> combine_chars [ 0 ] ) ) ; state -> tabstops = vterm_allocator_malloc ( state -> vt , ( state -> cols + 7 ) / 8 ) ; state -> lineinfo = vterm_allocator_malloc ( state -> vt , state -> rows * sizeof ( vtermlineinfo ) ) ; state -> encoding_utf8 . enc = vterm_lookup_encoding ( enc_utf8 , 'u' ) ; if ( * state -> encoding_utf8 . enc -> init != null ) ( * state -> encoding_utf8 . enc -> init ) ( state -> encoding_utf8 . enc , state -> encoding_utf8 . data ) ; vterm_parser_set_callbacks ( vt , & parser_callbacks , state ) ; return state ; }","<S2SV_ModStart> ( vt ) ; if ( state == NULL ) return NULL
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,<S2SV_StartBug> state = vterm_state_new ( vt ) ; <S2SV_EndBug>
3025,CWE-399,"static int misaligned_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_sign_extend ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } perf_sw_event ( perf_count_sw_alignment_faults , 1 , 0 , regs , address ) ; destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( verify_read , ( unsigned long ) address , 1ul << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } switch ( width_shift ) { case 1 : if ( do_sign_extend ) { regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s16 * ) & buffer ; } else { regs -> regs [ destreg ] = ( __u64 ) * ( __u16 * ) & buffer ; } break ; case 2 : regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s32 * ) & buffer ; break ; case 3 : regs -> regs [ destreg ] = buffer ; break ; default : printk ( ""unexpected<s2sv_blank>width_shift<s2sv_blank>%d<s2sv_blank>in<s2sv_blank>misaligned_load,<s2sv_blank>pc=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } else { __u64 lo , hi ; switch ( width_shift ) { case 1 : misaligned_kernel_word_load ( address , do_sign_extend , & regs -> regs [ destreg ] ) ; break ; case 2 : asm ( ""ldlo.l<s2sv_blank>%1,<s2sv_blank>0,<s2sv_blank>%0"" : ""=r"" ( lo ) : ""r"" ( address ) ) ; asm ( ""ldhi.l<s2sv_blank>%1,<s2sv_blank>3,<s2sv_blank>%0"" : ""=r"" ( hi ) : ""r"" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; case 3 : asm ( ""ldlo.q<s2sv_blank>%1,<s2sv_blank>0,<s2sv_blank>%0"" : ""=r"" ( lo ) : ""r"" ( address ) ) ; asm ( ""ldhi.q<s2sv_blank>%1,<s2sv_blank>7,<s2sv_blank>%0"" : ""=r"" ( hi ) : ""r"" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; default : printk ( ""unexpected<s2sv_blank>width_shift<s2sv_blank>%d<s2sv_blank>in<s2sv_blank>misaligned_load,<s2sv_blank>pc=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } return 0 ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug>"
2251,CWE-416,"static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags , struct dev_pagemap * * pgmap ) { struct mm_struct * mm = vma -> vm_mm ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & foll_migration ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & foll_numa ) && pte_protnone ( pte ) ) goto no_page ; if ( ( flags & foll_write ) && ! can_follow_write_pte ( pte , flags ) ) { pte_unmap_unlock ( ptep , ptl ) ; return null ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & foll_get ) ) { * pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ; if ( * pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & foll_dump ) { page = err_ptr ( - efault ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = err_ptr ( ret ) ; goto out ; } } if ( flags & foll_split && pagetranscompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return err_ptr ( ret ) ; goto retry ; } if ( flags & foll_get ) get_page ( page ) ; if ( flags & foll_touch ) { if ( ( flags & foll_write ) && ! pte_dirty ( pte ) && ! pagedirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & foll_mlock ) && ( vma -> vm_flags & vm_locked ) ) { if ( pagetranscompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return null ; return no_page_table ( vma , flags ) ; }","<S2SV_ModStart> & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags
",torvalds@linux/6b3a707736301c2128ca85ce85fb13f60b5e350a,CVE-2019-11487,https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a,2019-04-23T22:29Z,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug>
2318,CWE-20,"static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = null ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = null ; struct futex_hash_bucket * hb ; union futex_key key2 = futex_key_init ; struct futex_q q = futex_q_init ; int res , ret ; if ( ! bitset ) return - einval ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & flags_clockrt ) ? clock_realtime : clock_monotonic , hrtimer_mode_abs ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; rt_waiter . task = null ; ret = get_futex_key ( uaddr2 , flags & flags_shared , & key2 , verify_write ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; futex_wait_queue_me ( hb , & q , to ) ; spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { warn_on ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - efault ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - eintr ) { ret = - ewouldblock ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }","<S2SV_ModStart> res , ret ; if ( uaddr == uaddr2 ) return - EINVAL
",torvalds@linux/6f7b0a2a5c0fb03be7c25bd1745baa50582348ef,CVE-2012-6647,https://github.com/torvalds/linux/commit/6f7b0a2a5c0fb03be7c25bd1745baa50582348ef,2014-05-26T22:55Z,"<S2SV_StartBug> int res , ret ; <S2SV_EndBug>"
1300,CWE-476,"int nfc_llcp_send_cc ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * miux_tlv = null , miux_tlv_length ; u8 * rw_tlv = null , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( ""sending<s2sv_blank>cc\\n"" ) ; local = sock -> local ; if ( local == null ) return - enodev ; miux = be16_to_cpu ( sock -> miux ) > llcp_max_miux ? local -> miux : sock -> miux ; rw = sock -> rw > llcp_max_rw ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( llcp_tlv_miux , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; size += miux_tlv_length ; rw_tlv = nfc_llcp_build_tlv ( llcp_tlv_rw , & rw , 0 , & rw_tlv_length ) ; size += rw_tlv_length ; skb = llcp_allocate_pdu ( sock , llcp_pdu_cc , size ) ; if ( skb == null ) { err = - enomem ; goto error_tlv ; } llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( ""error<s2sv_blank>%d\\n"" , err ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }","<S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
",torvalds@linux/58bdd544e2933a21a51eecf17c3f5f94038261b5,CVE-2019-12818,https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5,2019-06-14T02:29Z,<S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug>
3129,CWE-399,"static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) { guint32 size ; int end_offset ; if ( di -> conformant_run ) return offset ; offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ; end_offset = offset + ( size * 2 ) ; if ( end_offset < offset ) { end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ; } while ( offset < end_offset ) offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , null , hf_keybuffer ) ; return offset ; }","<S2SV_ModStart> while ( offset > 0 && offset <S2SV_ModStart> < end_offset ) { <S2SV_ModStart> hf_keybuffer ) ; }
",wireshark@wireshark/b4d16b4495b732888e12baf5b8a7e9bf2665e22b,CVE-2016-5350,https://github.com/wireshark/wireshark/commit/b4d16b4495b732888e12baf5b8a7e9bf2665e22b,2016-08-07T16:59Z,<S2SV_StartBug> while ( offset < end_offset ) <S2SV_EndBug> <S2SV_StartBug> return offset ; <S2SV_EndBug>
8201,CWE-79,"void interprete ( char * lbook , char * path ) { int status , i , j , n , message_id , inactive ; char list [ 1000 ] , section [ 256 ] , str [ name_length ] , str1 [ name_length ] , str2 [ name_length ] , edit_id [ 80 ] , file_name [ 256 ] , command [ 256 ] , enc_path [ 256 ] , dec_path [ 256 ] , uname [ 80 ] , full_name [ 256 ] , user_email [ 256 ] , logbook [ 256 ] , logbook_enc [ 256 ] , * experiment , group [ 256 ] , css [ 256 ] , * pfile , attachment [ max_path_length ] , str3 [ name_length ] , thumb_name [ 256 ] , sid [ 32 ] , error_str [ 256 ] , subdir [ 256 ] , * s ; logbook * lbs ; file * f ; strcpy ( dec_path , path ) ; url_decode ( dec_path ) ; strcpy ( enc_path , dec_path ) ; url_encode ( enc_path , sizeof ( enc_path ) ) ; strencode2 ( command , isparam ( ""cmd"" ) ? getparam ( ""cmd"" ) : """" , sizeof ( command ) ) ; strencode2 ( group , isparam ( ""group"" ) ? getparam ( ""group"" ) : """" , sizeof ( group ) ) ; experiment = getparam ( ""exp"" ) ; if ( getcfg ( lbook , ""logging<s2sv_blank>level"" , str , sizeof ( str ) ) ) _logging_level = atoi ( str ) ; else _logging_level = 2 ; set_condition ( """" ) ; message_id = atoi ( dec_path ) ; if ( isparam ( ""jcmd"" ) && * getparam ( ""jcmd"" ) ) strlcpy ( command , getparam ( ""jcmd"" ) , sizeof ( command ) ) ; if ( stricmp ( command , ""loc"" ) == 0 ) { show_http_header ( null , false , null ) ; if ( isparam ( ""value"" ) && * getparam ( ""value"" ) ) rsputs ( loc ( getparam ( ""value"" ) ) ) ; s = loc ( ""drop<s2sv_blank>attachments<s2sv_blank>here..."" ) ; s = loc ( ""insert<s2sv_blank>timestamp"" ) ; if ( s ) s = null ; return ; } if ( experiment && experiment [ 0 ] ) { strcpy ( logbook_enc , experiment ) ; strcpy ( logbook , experiment ) ; url_decode ( logbook ) ; for ( i = 0 ; ; i ++ ) { if ( ! enumgrp ( i , str ) ) break ; if ( strieq ( logbook , str ) ) break ; } if ( ! strieq ( logbook , str ) ) { sprintf ( str , ""error:<s2sv_blank>logbook<s2sv_blank>\\""%s\\""<s2sv_blank>not<s2sv_blank>defined<s2sv_blank>in<s2sv_blank>%s"" , logbook_enc , cfgfile ) ; show_error ( str ) ; return ; } } else { strcpy ( logbook_enc , lbook ) ; strcpy ( logbook , lbook ) ; url_decode ( logbook ) ; } setcfg_topgroup ( """" ) ; sprintf ( str , ""top<s2sv_blank>group<s2sv_blank>%s"" , logbook ) ; if ( getcfg ( ""global"" , str , list , sizeof ( list ) ) ) { setcfg_topgroup ( logbook ) ; logbook [ 0 ] = 0 ; } for ( i = j = 0 ; ; i ++ ) { if ( ! enumgrp ( i , str ) ) break ; if ( is_logbook ( str ) ) { if ( ! strieq ( str , lb_list [ j ++ ] . name ) ) { el_index_logbooks ( ) ; break ; } } } if ( lb_list [ j ] . name [ 0 ] != 0 ) el_index_logbooks ( ) ; if ( ! logbook [ 0 ] ) { if ( getcfg ( group , ""self<s2sv_blank>register"" , str , sizeof ( str ) ) && atoi ( str ) > 0 ) { if ( ! do_self_register ( null , getparam ( ""cmd"" ) ) ) return ; } if ( strieq ( command , loc ( ""activate"" ) ) && isparam ( ""new_user_name"" ) && isparam ( ""code"" ) ) { if ( ! activate_user ( null , getparam ( ""new_user_name"" ) , atoi ( getparam ( ""code"" ) ) ) ) return ; setparam ( ""cfg_user"" , getparam ( ""new_user_name"" ) ) ; get_user_line ( null , getparam ( ""new_user_name"" ) , null , full_name , user_email , null , null , null ) ; sprintf ( str , ""%s<s2sv_blank><b>&lt;%s&gt;</b>"" , full_name , user_email ) ; sprintf ( str2 , loc ( ""activation<s2sv_blank>notice<s2sv_blank>has<s2sv_blank>been<s2sv_blank>sent<s2sv_blank>to<s2sv_blank>%s"" ) , str ) ; setparam ( ""notice"" , str2 ) ; show_config_page ( null ) ; return ; } if ( strieq ( command , loc ( ""save"" ) ) ) { if ( isparam ( ""config"" ) ) { if ( ! isparam ( ""config"" ) || ! save_user_config ( null , getparam ( ""config"" ) , false ) ) return ; } redirect ( null , ""."" ) ; return ; } if ( isparam ( ""cmd"" ) || isparam ( ""newpwd"" ) ) { if ( isparam ( ""newpwd"" ) || strieq ( command , loc ( ""change<s2sv_blank>password"" ) ) ) { if ( sid_check ( getparam ( ""sid"" ) , uname ) ) setparam ( ""unm"" , uname ) ; show_change_pwd_page ( null ) ; return ; } } if ( isparam ( ""uname"" ) && isparam ( ""upassword"" ) ) { strlcpy ( uname , getparam ( ""uname"" ) , sizeof ( uname ) ) ; sprintf ( str , ""login<s2sv_blank>user<s2sv_blank>\\""%s\\""<s2sv_blank>(attempt)<s2sv_blank>for<s2sv_blank>logbook<s2sv_blank>selection<s2sv_blank>page"" , uname ) ; write_logfile ( null , str ) ; if ( isparam ( ""redir"" ) ) strlcpy ( str , getparam ( ""redir"" ) , sizeof ( str ) ) ; else strlcpy ( str , isparam ( ""cmdline"" ) ? getparam ( ""cmdline"" ) : """" , sizeof ( str ) ) ; if ( ! auth_verify_password ( null , uname , getparam ( ""upassword"" ) , error_str , sizeof ( error_str ) ) ) { if ( error_str [ 0 ] ) show_error ( error_str ) ; else show_login_page ( null , str , 1 ) ; return ; } if ( get_user_line ( null , uname , null , full_name , null , null , null , null ) == 2 ) { if ( ! getcfg ( group , ""self<s2sv_blank>register"" , str , sizeof ( str ) ) || atoi ( str ) == 0 ) { show_login_page ( null , str , 1 ) ; return ; } # ifdef have_pam getcfg ( null , ""authentication"" , str , sizeof ( str ) ) ; if ( stristr ( str , ""pam"" ) ) { show_new_user_page ( null , uname ) ; return ; } # endif } set_user_password ( null , uname , getparam ( ""upassword"" ) ) ; sprintf ( str , ""login<s2sv_blank>user<s2sv_blank>\\""%s\\""<s2sv_blank>(success)"" , uname ) ; write_logfile ( null , str ) ; sid_new ( null , uname , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; set_sid_cookie ( null , sid , full_name ) ; return ; } if ( ! logbook [ 0 ] && getcfg ( ""global"" , ""selection<s2sv_blank>page"" , str , sizeof ( str ) ) ) { if ( strstr ( str , ""http://"" ) || strstr ( str , ""https://"" ) ) { redirect ( null , str ) ; return ; } if ( str [ 0 ] == dir_separator || str [ 1 ] == ':' ) strlcpy ( file_name , str , sizeof ( file_name ) ) ; else { strlcpy ( file_name , logbook_dir , sizeof ( file_name ) ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } send_file_direct ( file_name ) ; return ; } if ( strieq ( command , ""synchronize"" ) ) { synchronize ( null , sync_html ) ; return ; } } for ( n = 0 ; lb_list [ n ] . name [ 0 ] ; n ++ ) ; if ( ! logbook [ 0 ] && ! path [ 0 ] ) { if ( n > 1 ) { if ( strieq ( command , loc ( ""forgot"" ) ) ) { show_forgot_pwd_page ( null ) ; return ; } show_selection_page ( ) ; return ; } strcpy ( logbook , lb_list [ 0 ] . name ) ; strcpy ( logbook_enc , logbook ) ; url_encode ( logbook_enc , sizeof ( logbook_enc ) ) ; } for ( i = 0 ; lb_list [ i ] . name [ 0 ] ; i ++ ) if ( strieq ( logbook , lb_list [ i ] . name ) ) break ; lbs = & lb_list [ i ] ; if ( lbs -> top_group [ 0 ] ) setcfg_topgroup ( lbs -> top_group ) ; if ( getcfg ( logbook , ""theme"" , str , sizeof ( str ) ) ) strlcpy ( theme_name , str , sizeof ( theme_name ) ) ; else strlcpy ( theme_name , ""default"" , sizeof ( theme_name ) ) ; lbs = lb_list + i ; lbs -> n_attr = scan_attributes ( lbs -> name ) ; if ( lbs -> n_attr < 0 ) return ; if ( isparam ( ""acmd"" ) && * getparam ( ""acmd"" ) ) { if ( strieq ( getparam ( ""acmd"" ) , ""upload"" ) ) show_uploader_json ( lbs ) ; return ; } getcfg ( lbs -> name , ""authentication"" , str , sizeof ( str ) ) ; if ( stristr ( str , ""webserver"" ) ) { if ( http_user [ 0 ] ) { if ( ! sid_check ( getparam ( ""sid"" ) , http_user ) ) { sid_new ( lbs , http_user , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; set_sid_cookie ( lbs , sid , http_user ) ; } } else { sprintf ( str , ""error:<s2sv_blank>misconfigured<s2sv_blank>webserver,<s2sv_blank>did<s2sv_blank>not<s2sv_blank>get<s2sv_blank>x-forwarded-user<s2sv_blank>from<s2sv_blank>it."" ) ; show_error ( str ) ; return ; } } if ( isparam ( ""uname"" ) && isparam ( ""upassword"" ) ) { strlcpy ( uname , getparam ( ""uname"" ) , sizeof ( uname ) ) ; sprintf ( str , ""login<s2sv_blank>user<s2sv_blank>\\""%s\\""<s2sv_blank>(attempt)"" , uname ) ; write_logfile ( lbs , str ) ; if ( isparam ( ""redir"" ) ) strlcpy ( str , getparam ( ""redir"" ) , sizeof ( str ) ) ; else strlcpy ( str , isparam ( ""cmdline"" ) ? getparam ( ""cmdline"" ) : """" , sizeof ( str ) ) ; if ( ! auth_verify_password ( lbs , uname , getparam ( ""upassword"" ) , error_str , sizeof ( error_str ) ) ) { if ( error_str [ 0 ] ) show_error ( error_str ) ; else show_login_page ( lbs , str , 1 ) ; return ; } if ( get_user_line ( lbs , uname , null , full_name , null , null , null , & inactive ) == 2 ) { if ( ! getcfg ( lbs -> name , ""self<s2sv_blank>register"" , str , sizeof ( str ) ) || atoi ( str ) == 0 ) { show_login_page ( lbs , str , 1 ) ; return ; } # ifdef have_pam getcfg ( lbs -> name , ""authentication"" , str , sizeof ( str ) ) ; if ( stristr ( str , ""pam"" ) ) { show_new_user_page ( lbs , uname ) ; return ; } # endif } if ( inactive ) { show_error ( ""this<s2sv_blank>account<s2sv_blank>is<s2sv_blank>currently<s2sv_blank>deactivated"" ) ; return ; } if ( ! check_login_user ( lbs , getparam ( ""uname"" ) ) ) { show_error ( ""user<s2sv_blank>has<s2sv_blank>no<s2sv_blank>access<s2sv_blank>to<s2sv_blank>this<s2sv_blank>logbook"" ) ; return ; } set_user_password ( lbs , uname , getparam ( ""upassword"" ) ) ; sprintf ( str , ""login<s2sv_blank>user<s2sv_blank>\\""%s\\""<s2sv_blank>(success)"" , uname ) ; write_logfile ( lbs , str ) ; sid_new ( lbs , uname , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; set_sid_cookie ( lbs , sid , full_name ) ; return ; } if ( chkext ( path , "".gif"" ) || chkext ( path , "".jpg"" ) || chkext ( path , "".png"" ) || chkext ( path , "".ico"" ) || chkext ( path , "".htm"" ) || chkext ( path , "".css"" ) ) { strlcpy ( str , resource_dir , sizeof ( str ) ) ; strlcat ( str , path , sizeof ( str ) ) ; if ( exist_file ( str ) ) { send_file_direct ( str ) ; return ; } else { strlcpy ( str , resource_dir , sizeof ( str ) ) ; strlcat ( str , ""themes"" , sizeof ( str ) ) ; strlcat ( str , dir_separator_str , sizeof ( str ) ) ; strlcat ( str , theme_name , sizeof ( str ) ) ; strlcat ( str , dir_separator_str , sizeof ( str ) ) ; strlcat ( str , path , sizeof ( str ) ) ; if ( exist_file ( str ) ) { send_file_direct ( str ) ; return ; } } } if ( ! logbook [ 0 ] ) { strencode2 ( str2 , path , sizeof ( str2 ) ) ; sprintf ( str , ""%s:<s2sv_blank><b>%s</b>"" , loc ( ""invalid<s2sv_blank>url"" ) , str2 ) ; show_error ( str ) ; return ; } if ( strieq ( command , loc ( ""activate"" ) ) && isparam ( ""unm"" ) && isparam ( ""code"" ) && ! isparam ( ""new_user_name"" ) ) { strlcpy ( uname , getparam ( ""unm"" ) , sizeof ( uname ) ) ; if ( ! activate_user ( lbs , uname , atoi ( getparam ( ""code"" ) ) ) ) return ; sprintf ( str , ""activate<s2sv_blank>user<s2sv_blank>\\""%s\\""<s2sv_blank>(success)"" , uname ) ; write_logfile ( lbs , str ) ; sid_new ( lbs , uname , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; sprintf ( str , ""?cmd=%s&notice=%s.<s2sv_blank>%s"" , loc ( ""config"" ) , loc ( ""your<s2sv_blank>account<s2sv_blank>has<s2sv_blank>been<s2sv_blank>activated"" ) , loc ( ""please<s2sv_blank>subscribe<s2sv_blank>to<s2sv_blank>logbooks<s2sv_blank>if<s2sv_blank>you<s2sv_blank>want<s2sv_blank>to<s2sv_blank>receive<s2sv_blank>automatic<s2sv_blank>email<s2sv_blank>notifications"" ) ) ; setparam ( ""redir"" , str ) ; set_sid_cookie ( lbs , sid , uname ) ; return ; } # ifdef have_pam if ( strieq ( command , loc ( ""save"" ) ) && isparam ( ""new_user_name"" ) && ! isparam ( ""config"" ) ) { save_user_config ( null , getparam ( ""new_user_name"" ) , 1 ) ; redirect ( lbs , """" ) ; check_login ( lbs , null ) ; return ; } # endif if ( getcfg ( lbs -> name , ""password<s2sv_blank>file"" , str , sizeof ( str ) ) ) { strlcpy ( css , ""elog.css"" , sizeof ( css ) ) ; if ( lbs != null && getcfg ( lbs -> name , ""css"" , str , sizeof ( str ) ) ) strlcpy ( css , str , sizeof ( css ) ) ; else if ( lbs == null && getcfg ( ""global"" , ""css"" , str , sizeof ( str ) ) ) strlcpy ( css , str , sizeof ( css ) ) ; if ( getcfg ( lbs -> name , ""guest<s2sv_blank>menu<s2sv_blank>commands"" , str , sizeof ( str ) ) ) { if ( sid_check ( getparam ( ""sid"" ) , uname ) ) setparam ( ""unm"" , uname ) ; } if ( uname [ 0 ] && ! isparam ( ""new_user_name"" ) ) { if ( ! set_user_login_time ( lbs , uname ) ) { show_error ( loc ( ""file<s2sv_blank>system<s2sv_blank>full,<s2sv_blank>elog<s2sv_blank>cannot<s2sv_blank>continue<s2sv_blank>to<s2sv_blank>work"" ) ) ; return ; } } if ( ! ( getcfg ( lbs -> name , ""guest<s2sv_blank>menu<s2sv_blank>commands"" , str , sizeof ( str ) ) && ! isparam ( ""fail"" ) ) ) { if ( strcmp ( path , css ) != 0 ) { if ( getcfg ( lbs -> name , ""self<s2sv_blank>register"" , str , sizeof ( str ) ) && atoi ( str ) > 0 ) { if ( ! do_self_register ( lbs , command ) ) return ; } if ( ! check_login ( lbs , getparam ( ""sid"" ) ) ) return ; } } } if ( strieq ( command , loc ( ""login"" ) ) ) { check_login ( lbs , """" ) ; return ; } if ( strieq ( command , loc ( ""new"" ) ) || strieq ( command , loc ( ""edit"" ) ) || strieq ( command , loc ( ""reply"" ) ) || strieq ( command , loc ( ""duplicate"" ) ) || strieq ( command , loc ( ""delete"" ) ) || strieq ( command , loc ( ""upload"" ) ) || strieq ( command , loc ( ""submit"" ) ) || strieq ( command , loc ( ""preview"" ) ) ) { sprintf ( str , ""%s?cmd=%s"" , path , command ) ; } if ( strieq ( command , loc ( ""delete"" ) ) || strieq ( command , loc ( ""config"" ) ) || strieq ( command , loc ( ""copy<s2sv_blank>to"" ) ) || strieq ( command , loc ( ""move<s2sv_blank>to"" ) ) ) { sprintf ( str , ""%s?cmd=%s"" , path , command ) ; } if ( strieq ( command , loc ( ""back"" ) ) ) { if ( isparam ( ""edit_id"" ) ) { el_lock_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , null , false ) ; el_draft_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , null , false ) ; strlcpy ( edit_id , getparam ( ""edit_id"" ) , sizeof ( edit_id ) ) ; sprintf ( str , ""../%s/%s"" , logbook_enc , edit_id ) ; } else sprintf ( str , ""../%s/"" , logbook_enc ) ; if ( getcfg ( lbs -> name , ""back<s2sv_blank>to<s2sv_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) strcpy ( str , ""../"" ) ; redirect ( lbs , str ) ; return ; } if ( strieq ( command , ""xdelete"" ) ) { if ( getparam ( ""edit_id"" ) ) { status = el_delete_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , true , null , true , true ) ; if ( status != el_success ) { sprintf ( str , ""%s<s2sv_blank>=<s2sv_blank>%d"" , loc ( ""error<s2sv_blank>deleting<s2sv_blank>message:<s2sv_blank>status"" ) , status ) ; show_error ( str ) ; return ; } } redirect ( lbs , """" ) ; return ; } if ( strieq ( command , ""unlock"" ) ) { if ( isparam ( ""edit_id"" ) ) { el_lock_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , null , false ) ; strlcpy ( edit_id , getparam ( ""edit_id"" ) , sizeof ( edit_id ) ) ; sprintf ( str , ""../%s/%s"" , logbook_enc , edit_id ) ; } else sprintf ( str , ""../%s/"" , logbook_enc ) ; if ( getcfg ( lbs -> name , ""back<s2sv_blank>to<s2sv_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) strcpy ( str , ""../"" ) ; redirect ( lbs , str ) ; return ; } if ( strieq ( command , loc ( ""list"" ) ) ) { if ( getcfg ( lbs -> name , ""back<s2sv_blank>to<s2sv_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) { redirect ( lbs , ""../"" ) ; return ; } show_elog_list ( lbs , 0 , 0 , 0 , true , null ) ; return ; } if ( strieq ( command , loc ( ""cancel"" ) ) ) { sprintf ( str , ""../%s/%s"" , logbook_enc , path ) ; redirect ( lbs , str ) ; return ; } strlcpy ( str , isparam ( ""last"" ) ? getparam ( ""last"" ) : """" , sizeof ( str ) ) ; if ( strchr ( str , '<s2sv_blank>' ) ) { i = atoi ( strchr ( str , '<s2sv_blank>' ) ) ; sprintf ( str , ""last%d"" , i ) ; if ( isparam ( ""mode"" ) ) { sprintf ( str + strlen ( str ) , ""?mode="" ) ; strlcat ( str , getparam ( ""mode"" ) , sizeof ( str ) ) ; } redirect ( lbs , str ) ; return ; } strlcpy ( str , isparam ( ""past"" ) ? getparam ( ""past"" ) : """" , sizeof ( str ) ) ; if ( strchr ( str , '<s2sv_blank>' ) ) { i = atoi ( strchr ( str , '<s2sv_blank>' ) ) ; sprintf ( str , ""past%d"" , i ) ; redirect ( lbs , str ) ; return ; } if ( strncmp ( path , ""past"" , 4 ) == 0 && ( isdigit ( path [ 4 ] ) || isdigit ( path [ 5 ] ) ) && isparam ( ""cmd"" ) == 0 ) { show_elog_list ( lbs , atoi ( path + 4 ) , 0 , 0 , false , null ) ; return ; } if ( strncmp ( path , ""last"" , 4 ) == 0 && ! chkext ( path , "".png"" ) && ( ! isparam ( ""cmd"" ) || strieq ( getparam ( ""cmd"" ) , loc ( ""select"" ) ) ) && ! isparam ( ""newpwd"" ) && atoi ( path + 4 ) > 0 ) { show_elog_list ( lbs , 0 , atoi ( path + 4 ) , 0 , false , null ) ; return ; } if ( strncmp ( path , ""page"" , 4 ) == 0 && isparam ( ""cmd"" ) == 0 ) { if ( ! path [ 4 ] ) show_elog_list ( lbs , 0 , 0 , - 1 , false , null ) ; else show_elog_list ( lbs , 0 , 0 , atoi ( path + 4 ) , false , null ) ; return ; } if ( strieq ( dec_path , ""cal.html"" ) ) { show_calendar ( lbs ) ; return ; } if ( strieq ( dec_path , ""elog.rdf"" ) ) { show_rss_feed ( lbs ) ; return ; } if ( strieq ( dec_path , ""upload.html"" ) ) { show_uploader ( lbs ) ; return ; } if ( isparam ( ""jcmd"" ) && isparam ( ""jcmd"" ) && strieq ( getparam ( ""jcmd"" ) , ""jupload"" ) ) { show_uploader_finished ( lbs ) ; return ; } pfile = dec_path ; if ( strchr ( pfile , '/' ) && pfile [ 13 ] != '/' && isdigit ( pfile [ 0 ] ) ) pfile = strchr ( pfile , '/' ) + 1 ; if ( ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '_' ) || ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '/' ) || chkext ( pfile , "".gif"" ) || chkext ( pfile , "".ico"" ) || chkext ( pfile , "".jpg"" ) || chkext ( pfile , "".jpeg"" ) || chkext ( pfile , "".png"" ) || chkext ( pfile , "".css"" ) || chkext ( pfile , "".js"" ) || chkext ( pfile , "".html"" ) ) { if ( ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '_' ) || ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '/' ) ) { if ( pfile [ 13 ] == '/' ) pfile [ 13 ] = '_' ; strlcpy ( file_name , lbs -> data_dir , sizeof ( file_name ) ) ; generate_subdir_name ( pfile , subdir , sizeof ( subdir ) ) ; strlcat ( file_name , subdir , sizeof ( file_name ) ) ; strlcat ( file_name , pfile , sizeof ( file_name ) ) ; } else { strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; if ( file_name [ 0 ] && file_name [ strlen ( file_name ) - 1 ] != dir_separator ) strlcat ( file_name , dir_separator_str , sizeof ( file_name ) ) ; strlcat ( file_name , ""themes"" , sizeof ( file_name ) ) ; strlcat ( file_name , dir_separator_str , sizeof ( file_name ) ) ; if ( theme_name [ 0 ] ) { strlcat ( file_name , theme_name , sizeof ( file_name ) ) ; strlcat ( file_name , dir_separator_str , sizeof ( file_name ) ) ; } strlcat ( file_name , pfile , sizeof ( file_name ) ) ; } if ( isparam ( ""thumb"" ) ) { get_thumb_name ( file_name , thumb_name , sizeof ( thumb_name ) , 0 ) ; if ( thumb_name [ 0 ] ) send_file_direct ( thumb_name ) ; else send_file_direct ( file_name ) ; } else send_file_direct ( file_name ) ; return ; } if ( ! logbook [ 0 ] ) { show_selection_page ( ) ; return ; } if ( strchr ( dec_path , '/' ) ) { message_id = atoi ( dec_path ) ; n = atoi ( strchr ( dec_path , '/' ) + 1 ) - 1 ; status = el_retrieve_attachment ( lbs , message_id , n , attachment ) ; if ( status != el_success || n >= max_attachments ) { sprintf ( str , ""attachment<s2sv_blank>#%d<s2sv_blank>of<s2sv_blank>entry<s2sv_blank>#%d<s2sv_blank>not<s2sv_blank>found"" , n + 1 , message_id ) ; show_error ( str ) ; } else { if ( isparam ( ""thumb"" ) ) strlcat ( attachment , ""?thumb=1"" , sizeof ( attachment ) ) ; redirect ( lbs , attachment ) ; } return ; } if ( getcfg ( lbs -> name , ""types"" , str , sizeof ( str ) ) ) { show_upgrade_page ( lbs ) ; return ; } if ( isparam ( ""cmd_first.x"" ) ) strcpy ( command , loc ( ""first"" ) ) ; if ( isparam ( ""cmd_previous.x"" ) ) strcpy ( command , loc ( ""previous"" ) ) ; if ( isparam ( ""cmd_next.x"" ) ) strcpy ( command , loc ( ""next"" ) ) ; if ( isparam ( ""cmd_last.x"" ) ) strcpy ( command , loc ( ""last"" ) ) ; if ( command [ 0 ] && ! is_user_allowed ( lbs , command ) ) { if ( isparam ( ""uname"" ) ) get_full_name ( lbs , getparam ( ""uname"" ) , full_name ) ; else full_name [ 0 ] = 0 ; strencode2 ( str2 , command , sizeof ( str2 ) ) ; strencode2 ( str3 , full_name , sizeof ( str3 ) ) ; sprintf ( str , loc ( ""error:<s2sv_blank>command<s2sv_blank>\\""<b>%s</b>\\""<s2sv_blank>is<s2sv_blank>not<s2sv_blank>allowed<s2sv_blank>for<s2sv_blank>user<s2sv_blank>\\""<b>%s</b>\\"""" ) , str2 , str3 ) ; show_error ( str ) ; return ; } if ( ! is_command_allowed ( lbs , command , message_id ) ) { if ( strieq ( command , loc ( ""new"" ) ) && ! isparam ( ""unm"" ) ) { show_login_page ( lbs , _cmdline , 0 ) ; return ; } strencode2 ( str2 , command , sizeof ( str3 ) ) ; sprintf ( str , loc ( ""error:<s2sv_blank>command<s2sv_blank>\\""<b>%s</b>\\""<s2sv_blank>not<s2sv_blank>allowed"" ) , str2 ) ; show_error ( str ) ; return ; } if ( strieq ( command , loc ( ""help"" ) ) ) { if ( getcfg ( lbs -> name , ""help<s2sv_blank>url"" , str , sizeof ( str ) ) ) { if ( strstr ( str , ""http://"" ) || strstr ( str , ""https://"" ) ) { redirect ( lbs , str ) ; return ; } strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , ""resources"" , sizeof ( file_name ) ) ; strlcat ( file_name , dir_separator_str , sizeof ( file_name ) ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; f = fopen ( file_name , ""r"" ) ; if ( f == null ) { sprintf ( str , ""cannot<s2sv_blank>find<s2sv_blank>file<s2sv_blank>\\""%s\\"""" , file_name ) ; show_error ( str ) ; } else { fclose ( f ) ; send_file_direct ( file_name ) ; } return ; } strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , ""resources"" , sizeof ( file_name ) ) ; strlcat ( file_name , dir_separator_str , sizeof ( file_name ) ) ; strlcat ( file_name , ""eloghelp_"" , sizeof ( file_name ) ) ; if ( getcfg ( ""global"" , ""language"" , str , sizeof ( str ) ) ) { for ( i = 0 ; i < ( int ) strlen ( str ) ; i ++ ) str [ i ] = my_tolower ( str [ i ] ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } else strlcat ( file_name , ""english"" , sizeof ( file_name ) ) ; strlcat ( file_name , "".html"" , sizeof ( file_name ) ) ; f = fopen ( file_name , ""r"" ) ; if ( f == null ) redirect ( lbs , ""https://elog.psi.ch/elog/eloghelp_english.html"" ) ; else { fclose ( f ) ; send_file_direct ( file_name ) ; } return ; } if ( strieq ( command , loc ( ""helpelcode"" ) ) ) { strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , ""resources"" , sizeof ( file_name ) ) ; strlcat ( file_name , dir_separator_str , sizeof ( file_name ) ) ; strlcat ( file_name , ""elcode_"" , sizeof ( file_name ) ) ; if ( getcfg ( ""global"" , ""language"" , str , sizeof ( str ) ) ) { for ( i = 0 ; i < ( int ) strlen ( str ) ; i ++ ) str [ i ] = my_tolower ( str [ i ] ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } else strlcat ( file_name , ""english"" , sizeof ( file_name ) ) ; strlcat ( file_name , "".html"" , sizeof ( file_name ) ) ; f = fopen ( file_name , ""r"" ) ; if ( f == null ) redirect ( lbs , ""https://elog.psi.ch/elog/elcode_english.html"" ) ; else { fclose ( f ) ; send_file_direct ( file_name ) ; } return ; } if ( strieq ( command , loc ( ""new"" ) ) ) { if ( check_drafts ( lbs ) ) return ; show_edit_form ( lbs , 0 , false , false , false , false , false , false ) ; return ; } for ( i = 0 ; i < max_attachments ; i ++ ) { sprintf ( str , ""delatt%d"" , i ) ; if ( isparam ( str ) || ( isparam ( ""smcmd"" ) && stricmp ( getparam ( ""smcmd"" ) , str ) == 0 ) ) { sprintf ( str , ""attachment%d"" , i ) ; strlcpy ( file_name , getparam ( str ) , sizeof ( file_name ) ) ; el_delete_attachment ( lbs , file_name ) ; for ( j = i ; j < max_attachments ; j ++ ) { sprintf ( str , ""attachment%d"" , j + 1 ) ; if ( isparam ( str ) ) strlcpy ( file_name , getparam ( str ) , sizeof ( file_name ) ) ; else file_name [ 0 ] = 0 ; sprintf ( str , ""attachment%d"" , j ) ; if ( file_name [ 0 ] ) setparam ( str , file_name ) ; else unsetparam ( str ) ; } show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , false , true , true , false , false , false ) ; return ; } } if ( strieq ( command , loc ( ""upload"" ) ) || strieq ( command , ""upload"" ) ) { show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , false , true , true , false , false , false ) ; return ; } if ( strieq ( command , loc ( ""edit"" ) ) ) { if ( message_id ) { show_edit_form ( lbs , message_id , false , true , false , false , false , false ) ; return ; } else if ( isparam ( ""nsel"" ) ) { show_edit_form ( lbs , 0 , false , true , false , false , false , false ) ; return ; } } if ( strieq ( command , loc ( ""reply"" ) ) ) { show_edit_form ( lbs , message_id , true , false , false , false , false , false ) ; return ; } if ( strieq ( command , loc ( ""update"" ) ) ) { show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , false , true , false , true , false , false ) ; return ; } if ( ( strieq ( command , loc ( ""save"" ) ) || strieq ( command , ""save"" ) ) && ! isparam ( ""cfgpage"" ) && ! isparam ( ""new_user_name"" ) ) { if ( isparam ( ""unm"" ) ) strlcpy ( str , getparam ( ""unm"" ) , sizeof ( str ) ) ; else strlcpy ( str , loc ( ""user"" ) , sizeof ( str ) ) ; setparam ( ""draft"" , str ) ; submit_elog ( lbs ) ; return ; } if ( strieq ( command , loc ( ""duplicate"" ) ) ) { if ( message_id ) { show_edit_form ( lbs , message_id , false , false , false , false , true , false ) ; return ; } } if ( strieq ( command , loc ( ""preview"" ) ) ) { show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , false , true , false , true , false , true ) ; return ; } if ( strieq ( command , loc ( ""submit"" ) ) || strieq ( command , ""submit"" ) ) { if ( isparam ( ""mirror_id"" ) ) submit_elog_mirror ( lbs ) ; else submit_elog ( lbs ) ; if ( isparam ( ""sidclose"" ) ) sid_remove ( getparam ( ""sid"" ) ) ; return ; } if ( strieq ( command , loc ( ""find"" ) ) ) { if ( dec_path [ 0 ] ) { sprintf ( str , ""../%s/?cmd=%s"" , lbs -> name_enc , loc ( ""find"" ) ) ; redirect ( lbs , str ) ; return ; } show_find_form ( lbs ) ; return ; } if ( strieq ( command , loc ( ""search"" ) ) ) { if ( dec_path [ 0 ] && atoi ( dec_path ) == 0 && strchr ( dec_path , '/' ) != null ) { strencode2 ( str2 , dec_path , sizeof ( str2 ) ) ; sprintf ( str , ""%s:<s2sv_blank><b>%s</b>"" , loc ( ""invalid<s2sv_blank>url"" ) , str2 ) ; show_error ( str ) ; return ; } show_elog_list ( lbs , 0 , 0 , 0 , true , null ) ; return ; } if ( strieq ( command , loc ( ""last<s2sv_blank>day"" ) ) ) { redirect ( lbs , ""past1"" ) ; return ; } if ( strieq ( command , loc ( ""last<s2sv_blank>10"" ) ) ) { redirect ( lbs , ""last10"" ) ; return ; } if ( strieq ( command , loc ( ""copy<s2sv_blank>to"" ) ) ) { copy_to ( lbs , message_id , isparam ( ""destc"" ) ? getparam ( ""destc"" ) : """" , 0 , 0 ) ; return ; } if ( strieq ( command , loc ( ""move<s2sv_blank>to"" ) ) ) { copy_to ( lbs , message_id , isparam ( ""destm"" ) ? getparam ( ""destm"" ) : """" , 1 , 0 ) ; return ; } if ( strieq ( command , loc ( ""admin"" ) ) || strieq ( command , loc ( ""change<s2sv_blank>config<s2sv_blank>file"" ) ) ) { show_admin_page ( lbs , null ) ; return ; } sprintf ( str , loc ( ""change<s2sv_blank>%s"" ) , ""[global]"" ) ; if ( strieq ( command , str ) ) { show_admin_page ( lbs , ""global"" ) ; return ; } sprintf ( str2 , ""[global<s2sv_blank>%s]"" , lbs -> top_group ) ; sprintf ( str , loc ( ""change<s2sv_blank>%s"" ) , str2 ) ; if ( strieq ( command , str ) ) { show_admin_page ( lbs , lbs -> top_group ) ; return ; } if ( strieq ( command , loc ( ""delete<s2sv_blank>this<s2sv_blank>logbook"" ) ) ) { show_logbook_delete ( lbs ) ; return ; } if ( strieq ( command , loc ( ""rename<s2sv_blank>this<s2sv_blank>logbook"" ) ) ) { show_logbook_rename ( lbs ) ; return ; } if ( strieq ( command , loc ( ""create<s2sv_blank>new<s2sv_blank>logbook"" ) ) ) { if ( isparam ( ""tmp"" ) && strieq ( getparam ( ""tmp"" ) , ""cancel"" ) ) { if ( getcfg ( lbs -> name , ""password<s2sv_blank>file"" , str , sizeof ( str ) ) ) sprintf ( str , ""?cmd=%s"" , loc ( ""change<s2sv_blank>config<s2sv_blank>file"" ) ) ; else sprintf ( str , ""?cmd=%s"" , loc ( ""config"" ) ) ; redirect ( lbs , str ) ; return ; } show_logbook_new ( lbs ) ; return ; } if ( strieq ( command , ""getpwdfile"" ) ) { char allow [ 256 ] ; allow [ 0 ] = 0 ; getcfg ( ""global"" , ""allow<s2sv_blank>clone"" , allow , sizeof ( allow ) ) ; if ( atoi ( allow ) == 1 ) { if ( get_password_file ( lbs , file_name , sizeof ( file_name ) ) ) send_file_direct ( file_name ) ; } else { show_http_header ( null , false , null ) ; rsputs ( loc ( ""cloning<s2sv_blank>not<s2sv_blank>allowed.<s2sv_blank>set<s2sv_blank>\\""allow<s2sv_blank>clone<s2sv_blank>=<s2sv_blank>1\\""<s2sv_blank>to<s2sv_blank>enable<s2sv_blank>cloning."" ) ) ; rsputs ( ""\\r\\n"" ) ; return ; } return ; } if ( strieq ( command , loc ( ""change<s2sv_blank>password"" ) ) || ( isparam ( ""newpwd"" ) && ! strieq ( command , loc ( ""cancel"" ) ) && ! strieq ( command , loc ( ""save"" ) ) ) ) { show_change_pwd_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""save"" ) ) && ( isparam ( ""cfgpage"" ) || isparam ( ""new_user_name"" ) ) ) { if ( isparam ( ""config"" ) && isparam ( ""new_user_name"" ) ) { if ( ! strieq ( getparam ( ""config"" ) , getparam ( ""new_user_name"" ) ) ) { if ( get_user_line ( lbs , getparam ( ""new_user_name"" ) , null , null , null , null , null , null ) == 1 ) { sprintf ( str , ""%s<s2sv_blank>\\""%s\\""<s2sv_blank>%s"" , loc ( ""login<s2sv_blank>name"" ) , getparam ( ""new_user_name"" ) , loc ( ""exists<s2sv_blank>already"" ) ) ; show_error ( str ) ; return ; } } if ( ! save_user_config ( lbs , isparam ( ""config"" ) ? getparam ( ""config"" ) : """" , false ) ) return ; redirect ( lbs , """" ) ; return ; } else if ( isparam ( ""new_user_name"" ) ) { if ( ! save_user_config ( lbs , getparam ( ""new_user_name"" ) , true ) ) return ; } else { if ( isparam ( ""global"" ) ) { if ( strieq ( getparam ( ""global"" ) , ""global"" ) ) strcpy ( section , ""global"" ) ; else { sprintf ( section , ""global<s2sv_blank>"" ) ; strlcat ( section , getparam ( ""global"" ) , sizeof ( section ) ) ; } } else strlcpy ( section , lbs -> name , sizeof ( section ) ) ; if ( ! save_admin_config ( section , _mtext , str ) ) { show_error ( str ) ; return ; } } if ( lbs ) sprintf ( str , ""../%s/"" , lbs -> name_enc ) ; else sprintf ( str , ""."" ) ; if ( isparam ( ""new_user_name"" ) ) { sprintf ( str + strlen ( str ) , ""?cmd=%s&cfg_user="" , loc ( ""config"" ) ) ; strlcat ( str , getparam ( ""new_user_name"" ) , sizeof ( str ) ) ; } else if ( isparam ( ""cfg_user"" ) ) { sprintf ( str + strlen ( str ) , ""?cmd=%s&cfg_user="" , loc ( ""config"" ) ) ; strlcat ( str , getparam ( ""cfg_user"" ) , sizeof ( str ) ) ; } else if ( getcfg ( lbs -> name , ""password<s2sv_blank>file"" , str2 , sizeof ( str2 ) ) ) sprintf ( str + strlen ( str ) , ""?cmd=%s"" , loc ( ""config"" ) ) ; redirect ( lbs , str ) ; return ; } if ( strieq ( command , loc ( ""activate"" ) ) && isparam ( ""new_user_name"" ) && isparam ( ""code"" ) ) { if ( ! activate_user ( lbs , getparam ( ""new_user_name"" ) , atoi ( getparam ( ""code"" ) ) ) ) return ; setparam ( ""cfg_user"" , getparam ( ""new_user_name"" ) ) ; get_user_line ( lbs , getparam ( ""new_user_name"" ) , null , full_name , user_email , null , null , null ) ; sprintf ( str , ""%s<s2sv_blank><b>&lt;%s&gt;</b>"" , full_name , user_email ) ; sprintf ( str2 , loc ( ""activation<s2sv_blank>notice<s2sv_blank>has<s2sv_blank>been<s2sv_blank>sent<s2sv_blank>to<s2sv_blank>%s"" ) , str ) ; setparam ( ""notice"" , str2 ) ; show_config_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""remove<s2sv_blank>user"" ) ) && isparam ( ""config"" ) ) { if ( ! remove_user ( lbs , getparam ( ""config"" ) ) ) return ; if ( isparam ( ""unm"" ) && strieq ( getparam ( ""config"" ) , getparam ( ""unm"" ) ) ) { write_logfile ( lbs , ""logout"" ) ; sid_remove ( getparam ( ""sid"" ) ) ; set_sid_cookie ( lbs , """" , """" ) ; } unsetparam ( ""cfg_user"" ) ; show_config_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""new<s2sv_blank>user"" ) ) ) { show_new_user_page ( lbs , null ) ; return ; } if ( strieq ( command , loc ( ""forgot"" ) ) ) { show_forgot_pwd_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""config"" ) ) ) { if ( ! getcfg ( lbs -> name , ""password<s2sv_blank>file"" , str , sizeof ( str ) ) ) show_admin_page ( lbs , null ) ; else show_config_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""download"" ) ) || strieq ( command , ""download"" ) ) { show_download_page ( lbs , dec_path ) ; return ; } if ( strieq ( command , loc ( ""import"" ) ) ) { strcpy ( str , loc ( ""csv<s2sv_blank>import"" ) ) ; url_encode ( str , sizeof ( str ) ) ; sprintf ( str1 , ""?cmd=%s"" , str ) ; strcpy ( str , loc ( ""xml<s2sv_blank>import"" ) ) ; url_encode ( str , sizeof ( str ) ) ; sprintf ( str2 , ""?cmd=%s"" , str ) ; show_query ( lbs , loc ( ""elog<s2sv_blank>import"" ) , loc ( ""please<s2sv_blank>choose<s2sv_blank>format<s2sv_blank>to<s2sv_blank>import:"" ) , ""csv"" , str1 , ""xml"" , str2 ) ; return ; } if ( strieq ( command , loc ( ""csv<s2sv_blank>import"" ) ) ) { show_import_page_csv ( lbs ) ; return ; } if ( strieq ( command , loc ( ""xml<s2sv_blank>import"" ) ) ) { show_import_page_xml ( lbs ) ; return ; } if ( strieq ( command , ""getmd5"" ) ) { show_md5_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""synchronize"" ) ) ) { synchronize ( lbs , sync_html ) ; return ; } if ( strieq ( command , loc ( ""logout"" ) ) ) { write_logfile ( lbs , ""logout"" ) ; if ( getcfg ( lbs -> name , ""logout<s2sv_blank>to<s2sv_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) { sprintf ( str , ""../"" ) ; setparam ( ""redir"" , str ) ; } else { if ( getcfg ( lbs -> name , ""logout<s2sv_blank>to<s2sv_blank>url"" , str , sizeof ( str ) ) ) setparam ( ""redir"" , str ) ; } set_sid_cookie ( lbs , """" , """" ) ; sid_remove ( getparam ( ""sid"" ) ) ; return ; } if ( strieq ( command , loc ( ""delete"" ) ) ) { show_elog_delete ( lbs , message_id ) ; return ; } if ( strieq ( command , ""im"" ) ) { call_image_magick ( lbs ) ; return ; } if ( ! _cmdline [ 0 ] && getcfg ( lbs -> name , ""welcome<s2sv_blank>page"" , str , sizeof ( str ) ) && str [ 0 ] ) { if ( str [ 0 ] == dir_separator || str [ 1 ] == ':' ) strcpy ( file_name , str ) ; else { strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } send_file_direct ( file_name ) ; return ; } if ( ! _cmdline [ 0 ] && getcfg ( lbs -> name , ""start<s2sv_blank>page"" , str , sizeof ( str ) ) && str [ 0 ] ) { redirect ( lbs , str ) ; return ; } if ( dec_path [ 0 ] == 0 ) show_elog_list ( lbs , 0 , 0 , 0 , true , null ) ; else show_elog_entry ( lbs , dec_path , command ) ; return ; }","<S2SV_ModStart> ""value"" ) ) { strencode2 ( str , getparam ( ""value"" ) , sizeof ( str ) ) ; <S2SV_ModStart> ( loc ( str ) ) ; } <S2SV_ModEnd> s = loc
",ritt@elog/eefdabb714f26192f585083ef96c8413e459a1d1,CVE-2019-20375,https://bitbucket.org/ritt/elog/commit/eefdabb714f26192f585083ef96c8413e459a1d1,2020-01-10T05:15Z,"<S2SV_StartBug> if ( isparam ( ""value"" ) && * getparam ( ""value"" ) ) <S2SV_EndBug> <S2SV_StartBug> rsputs ( loc ( getparam ( ""value"" ) ) ) ; <S2SV_EndBug>"
371,CWE-362,"static int faultin_page ( struct task_struct * tsk , struct vm_area_struct * vma , unsigned long address , unsigned int * flags , int * nonblocking ) { unsigned int fault_flags = 0 ; int ret ; if ( ( * flags & ( foll_populate | foll_mlock ) ) == foll_mlock ) return - enoent ; if ( ( * flags & foll_populate ) && ( stack_guard_page_start ( vma , address ) || stack_guard_page_end ( vma , address + page_size ) ) ) return - enoent ; if ( * flags & foll_write ) fault_flags |= fault_flag_write ; if ( * flags & foll_remote ) fault_flags |= fault_flag_remote ; if ( nonblocking ) fault_flags |= fault_flag_allow_retry ; if ( * flags & foll_nowait ) fault_flags |= fault_flag_allow_retry | fault_flag_retry_nowait ; if ( * flags & foll_tried ) { vm_warn_on_once ( fault_flags & fault_flag_allow_retry ) ; fault_flags |= fault_flag_tried ; } ret = handle_mm_fault ( vma , address , fault_flags ) ; if ( ret & vm_fault_error ) { if ( ret & vm_fault_oom ) return - enomem ; if ( ret & ( vm_fault_hwpoison | vm_fault_hwpoison_large ) ) return * flags & foll_hwpoison ? - ehwpoison : - efault ; if ( ret & ( vm_fault_sigbus | vm_fault_sigsegv ) ) return - efault ; bug ( ) ; } if ( tsk ) { if ( ret & vm_fault_major ) tsk -> maj_flt ++ ; else tsk -> min_flt ++ ; } if ( ret & vm_fault_retry ) { if ( nonblocking ) * nonblocking = 0 ; return - ebusy ; } if ( ( ret & vm_fault_write ) && ! ( vma -> vm_flags & vm_write ) ) * flags &= ~ foll_write ; return 0 ; }","<S2SV_ModStart> ) * flags |= FOLL_COW <S2SV_ModEnd> ; return 0
",torvalds@linux/19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619,CVE-2016-5195,https://github.com/torvalds/linux/commit/19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619,2016-11-10T21:59Z,<S2SV_StartBug> * flags &= ~ FOLL_WRITE ; <S2SV_EndBug>
3337,CWE-119,"int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case msr_amd64_nb_cfg : case msr_ia32_ucode_rev : case msr_ia32_ucode_write : case msr_vm_hsave_pa : case msr_amd64_patch_loader : case msr_amd64_bu_cfg2 : break ; case msr_efer : return set_efer ( vcpu , data ) ; case msr_k7_hwcr : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<s2sv_blank>hwcr<s2sv_blank>wrmsr:<s2sv_blank>0x%llx\\n"" , data ) ; return 1 ; } break ; case msr_fam10h_mmio_conf_base : if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<s2sv_blank>mmio_conf_base<s2sv_blank>wrmsr:<s2sv_blank>"" ""0x%llx\\n"" , data ) ; return 1 ; } break ; case msr_ia32_debugctlmsr : if ( ! data ) { break ; } else if ( data & ~ ( debugctlmsr_lbr | debugctlmsr_btf ) ) { return 1 ; } vcpu_unimpl ( vcpu , ""%s:<s2sv_blank>msr_ia32_debugctlmsr<s2sv_blank>0x%llx,<s2sv_blank>nop\\n"" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case msr_ia32_apicbase : kvm_set_apic_base ( vcpu , data ) ; break ; case apic_base_msr ... apic_base_msr + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case msr_ia32_tscdeadline : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case msr_ia32_tsc_adjust : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case msr_ia32_misc_enable : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case msr_kvm_wall_clock_new : case msr_kvm_wall_clock : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case msr_kvm_system_time_new : case msr_kvm_system_time : { kvmclock_reset ( vcpu ) ; vcpu -> arch . time = data ; kvm_make_request ( kvm_req_clock_update , vcpu ) ; if ( ! ( data & 1 ) ) break ; vcpu -> arch . time_offset = data & ~ ( page_mask | 1 ) ; vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> page_shift ) ; if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = null ; break ; } case msr_kvm_async_pf_en : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case msr_kvm_steal_time : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & kvm_steal_reserved_mask ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & kvm_steal_valid_bits ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & kvm_msr_enabled ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( kvm_req_steal_update , vcpu ) ; break ; case msr_kvm_pv_eoi_en : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case msr_ia32_mcg_ctl : case msr_ia32_mcg_status : case msr_ia32_mc0_ctl ... msr_ia32_mc0_ctl + 4 * kvm_max_mce_banks - 1 : return set_msr_mce ( vcpu , msr , data ) ; case msr_k7_evntsel0 : case msr_k7_evntsel1 : case msr_k7_evntsel2 : case msr_k7_evntsel3 : if ( data != 0 ) vcpu_unimpl ( vcpu , ""unimplemented<s2sv_blank>perfctr<s2sv_blank>wrmsr:<s2sv_blank>"" ""0x%x<s2sv_blank>data<s2sv_blank>0x%llx\\n"" , msr , data ) ; break ; case msr_k7_perfctr0 : case msr_k7_perfctr1 : case msr_k7_perfctr2 : case msr_k7_perfctr3 : vcpu_unimpl ( vcpu , ""unimplemented<s2sv_blank>perfctr<s2sv_blank>wrmsr:<s2sv_blank>"" ""0x%x<s2sv_blank>data<s2sv_blank>0x%llx\\n"" , msr , data ) ; break ; case msr_p6_perfctr0 : case msr_p6_perfctr1 : pr = true ; case msr_p6_evntsel0 : case msr_p6_evntsel1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , ""disabled<s2sv_blank>perfctr<s2sv_blank>wrmsr:<s2sv_blank>"" ""0x%x<s2sv_blank>data<s2sv_blank>0x%llx\\n"" , msr , data ) ; break ; case msr_k7_clk_ctl : break ; case hv_x64_msr_guest_os_id ... hv_x64_msr_sint15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case msr_ia32_bbl_cr_ctl3 : vcpu_unimpl ( vcpu , ""ignored<s2sv_blank>wrmsr:<s2sv_blank>0x%x<s2sv_blank>data<s2sv_blank>%llx\\n"" , msr , data ) ; break ; case msr_amd64_osvw_id_length : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case msr_amd64_osvw_status : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , ""unhandled<s2sv_blank>wrmsr:<s2sv_blank>0x%x<s2sv_blank>data<s2sv_blank>%llx\\n"" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , ""ignored<s2sv_blank>wrmsr:<s2sv_blank>0x%x<s2sv_blank>data<s2sv_blank>%llx\\n"" , msr , data ) ; break ; } } return 0 ; }","<S2SV_ModStart> | 1 ) ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break
",torvalds@linux/c300aa64ddf57d9c5d9c898a64b36877345dd4a9,CVE-2013-1796,https://github.com/torvalds/linux/commit/c300aa64ddf57d9c5d9c898a64b36877345dd4a9,2013-03-22T11:59Z,<S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug>
5817,CWE-000,"static int ext4_split_unwritten_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags ) { struct ext4_extent * ex , newex , orig_ex ; struct ext4_extent * ex1 = null ; struct ext4_extent * ex2 = null ; struct ext4_extent * ex3 = null ; ext4_lblk_t ee_block , eof_block ; unsigned int allocated , ee_len , depth ; ext4_fsblk_t newblock ; int err = 0 ; int may_zeroout ; ext_debug ( ""ext4_split_unwritten_extents:<s2sv_blank>inode<s2sv_blank>%lu,<s2sv_blank>logical"" ""block<s2sv_blank>%llu,<s2sv_blank>max_blocks<s2sv_blank>%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len ) ; eof_block = ( inode -> i_size + inode -> i_sb -> s_blocksize - 1 ) >> inode -> i_sb -> s_blocksize_bits ; if ( eof_block < map -> m_lblk + map -> m_len ) eof_block = map -> m_lblk + map -> m_len ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; allocated = ee_len - ( map -> m_lblk - ee_block ) ; newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ; ex2 = ex ; orig_ex . ee_block = ex -> ee_block ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_store_pblock ( & orig_ex , ext4_ext_pblock ( ex ) ) ; may_zeroout = ee_block + ee_len <= eof_block ; if ( ( map -> m_lblk == ee_block ) && ( allocated <= map -> m_len ) ) return allocated ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; if ( map -> m_lblk > ee_block ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } if ( ! ex1 && allocated > map -> m_len ) ex2 -> ee_len = cpu_to_le16 ( map -> m_len ) ; if ( allocated > map -> m_len ) { unsigned int newdepth ; ex3 = & newex ; ex3 -> ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; ext4_ext_store_pblock ( ex3 , newblock + map -> m_len ) ; ex3 -> ee_len = cpu_to_le16 ( allocated - map -> m_len ) ; ext4_ext_mark_uninitialized ( ex3 ) ; err = ext4_ext_insert_extent ( handle , inode , path , ex3 , flags ) ; if ( err == - enospc && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; newdepth = ext_depth ( inode ) ; ee_len -= ext4_ext_get_actual_len ( ex3 ) ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; may_zeroout = ee_block + ee_len <= eof_block ; depth = newdepth ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( is_err ( path ) ) { err = ptr_err ( path ) ; goto out ; } ex = path [ depth ] . p_ext ; if ( ex2 != & newex ) ex2 = ex ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; allocated = map -> m_len ; } if ( ex1 && ex1 != ex ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } ex2 -> ee_block = cpu_to_le32 ( map -> m_lblk ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; ex2 -> ee_len = cpu_to_le16 ( allocated ) ; ext4_ext_mark_uninitialized ( ex2 ) ; if ( ex2 != ex ) goto insert ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; ext_debug ( ""out<s2sv_blank>here\\n"" ) ; goto out ; insert : err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err == - enospc && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ? err : allocated ; fix_extent_len : ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }","<S2SV_ModStart> flags ) { ext4_lblk_t eof_block ; ext4_lblk_t ee_block ; <S2SV_ModStart> ext4_extent * ex <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> ; unsigned int ee_len ; int split_flag = 0 , depth <S2SV_ModEnd> ; ext_debug ( <S2SV_ModStart> ex ) ; split_flag |= <S2SV_ModEnd> ee_block + ee_len <S2SV_ModStart> ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 ; split_flag |= EXT4_EXT_MARK_UNINIT2 ; flags |= EXT4_GET_BLOCKS_PRE_IO ; return ext4_split_extent <S2SV_ModEnd> ( handle , <S2SV_ModStart> inode , path , map , split_flag <S2SV_ModEnd> , flags ) <S2SV_ModStart> , flags ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3,CVE-2011-3638,https://github.com/torvalds/linux/commit/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3,2013-03-01T12:37Z,"<S2SV_StartBug> struct ext4_extent * ex , newex , orig_ex ; <S2SV_EndBug> <S2SV_StartBug> unsigned int allocated , ee_len , depth ; <S2SV_EndBug> <S2SV_StartBug> allocated = ee_len - ( map -> m_lblk - ee_block ) ; <S2SV_EndBug> <S2SV_StartBug> may_zeroout = ee_block + ee_len <= eof_block ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_get_access ( handle , inode , path + depth ) ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_insert_extent ( handle , inode , path , ex3 , flags ) ; <S2SV_EndBug>"
4029,CWE-119,"static struct dentry * proc_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data ) { int err ; struct super_block * sb ; struct pid_namespace * ns ; char * options ; if ( flags & ms_kernmount ) { ns = ( struct pid_namespace * ) data ; options = null ; } else { ns = task_active_pid_ns ( current ) ; options = data ; if ( ! ns_capable ( ns -> user_ns , cap_sys_admin ) ) return err_ptr ( - eperm ) ; } sb = sget ( fs_type , proc_test_super , proc_set_super , flags , ns ) ; if ( is_err ( sb ) ) return err_cast ( sb ) ; if ( ! proc_parse_options ( options , ns ) ) { deactivate_locked_super ( sb ) ; return err_ptr ( - einval ) ; } if ( ! sb -> s_root ) { err = proc_fill_super ( sb ) ; if ( err ) { deactivate_locked_super ( sb ) ; return err_ptr ( err ) ; } sb -> s_flags |= ms_active ; sb -> s_iflags |= sb_i_noexec ; } return dget ( sb -> s_root ) ; }","<S2SV_ModStart> sb ) ; sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ;
",torvalds@linux/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d,CVE-2016-1583,https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d,2016-06-27T10:59Z,"<S2SV_StartBug> if ( ! proc_parse_options ( options , ns ) ) { <S2SV_EndBug>"
7612,CWE-190,"void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 , int c0 , int r1 , int c1 ) { int i ; if ( mat0 -> data_ ) { if ( ! ( mat0 -> flags_ & jas_matrix_ref ) ) { jas_free ( mat0 -> data_ ) ; } mat0 -> data_ = 0 ; mat0 -> datasize_ = 0 ; } if ( mat0 -> rows_ ) { jas_free ( mat0 -> rows_ ) ; mat0 -> rows_ = 0 ; } mat0 -> flags_ |= jas_matrix_ref ; mat0 -> numrows_ = r1 - r0 + 1 ; mat0 -> numcols_ = c1 - c0 + 1 ; mat0 -> maxrows_ = mat0 -> numrows_ ; if ( ! ( mat0 -> rows_ = jas_alloc2 ( mat0 -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { abort ( ) ; } for ( i = 0 ; i < mat0 -> numrows_ ; ++ i ) { mat0 -> rows_ [ i ] = mat1 -> rows_ [ r0 + i ] + c0 ; } mat0 -> xstart_ = mat1 -> xstart_ + c0 ; mat0 -> ystart_ = mat1 -> ystart_ + r0 ; mat0 -> xend_ = mat0 -> xstart_ + mat0 -> numcols_ ; mat0 -> yend_ = mat0 -> ystart_ + mat0 -> numrows_ ; }","<S2SV_ModStart> * mat1 , jas_matind_t r0 , jas_matind_t c0 , jas_matind_t r1 , jas_matind_t <S2SV_ModEnd> c1 ) { <S2SV_ModStart> c1 ) { jas_matind_t <S2SV_ModEnd> i ; if
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,"<S2SV_StartBug> void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 , <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug>"
4097,CWE-189,"static struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; int count , i ; count = be32_to_cpu ( aclp -> acl_cnt ) ; acl = posix_acl_alloc ( count , gfp_kernel ) ; if ( ! acl ) return err_ptr ( - enomem ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case acl_user : case acl_group : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case acl_user_obj : case acl_group_obj : case acl_mask : case acl_other : acl_e -> e_id = acl_undefined_id ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return err_ptr ( - einval ) ; }","<S2SV_ModStart> aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED
",torvalds@linux/fa8b18edd752a8b4e9d1ee2cd615b82c93cf8bba,CVE-2012-0038,https://github.com/torvalds/linux/commit/fa8b18edd752a8b4e9d1ee2cd615b82c93cf8bba,2012-05-17T11:00Z,<S2SV_StartBug> count = be32_to_cpu ( aclp -> acl_cnt ) ; <S2SV_EndBug>
2885,CWE-20,"static int airpdcapscanforkeys ( pairpdcap_context ctx , const guint8 * data , const guint mac_header_len , const guint tot_len , airpdcap_sec_association_id id ) { const uchar * addr ; guint bodylength ; pairpdcap_sec_association sta_sa ; pairpdcap_sec_association sa ; guint offset = 0 ; const guint8 dot1x_header [ ] = { 0xaa , 0xaa , 0x03 , 0x00 , 0x00 , 0x00 , 0x88 , 0x8e } ; const guint8 bt_dot1x_header [ ] = { 0xaa , 0xaa , 0x03 , 0x00 , 0x19 , 0x58 , 0x00 , 0x03 } ; const guint8 tdls_header [ ] = { 0xaa , 0xaa , 0x03 , 0x00 , 0x00 , 0x00 , 0x89 , 0x0d , 0x02 , 0x0c } ; const eapol_rsn_key * peapkey ; # ifdef _debug # define msgbuf_len 255 char msgbuf [ msgbuf_len ] ; # endif airpdcap_debug_trace_start ( ""airpdcapscanforkeys"" ) ; offset = mac_header_len ; if ( memcmp ( data + offset , dot1x_header , 8 ) == 0 || memcmp ( data + offset , bt_dot1x_header , 8 ) == 0 ) { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""authentication:<s2sv_blank>eapol<s2sv_blank>packet"" , airpdcap_debug_level_3 ) ; offset += 8 ; if ( data [ offset + 1 ] != 3 ) { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""not<s2sv_blank>eapol-key"" , airpdcap_debug_level_3 ) ; return airpdcap_ret_no_valid_handshake ; } bodylength = pntoh16 ( data + offset + 2 ) ; if ( ( tot_len - offset - 4 ) < bodylength ) { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""eapol<s2sv_blank>body<s2sv_blank>too<s2sv_blank>short"" , airpdcap_debug_level_3 ) ; return airpdcap_ret_no_valid_handshake ; } offset += 4 ; peapkey = ( const eapol_rsn_key * ) ( data + offset ) ; if ( peapkey -> type != airpdcap_rsn_wpa2_key_descriptor && peapkey -> type != airpdcap_rsn_wpa_key_descriptor ) { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""not<s2sv_blank>valid<s2sv_blank>key<s2sv_blank>descriptor<s2sv_blank>type"" , airpdcap_debug_level_3 ) ; return airpdcap_ret_no_valid_handshake ; } offset += 1 ; sa = airpdcapgetsaptr ( ctx , & id ) ; if ( sa == null ) { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""no<s2sv_blank>sa<s2sv_blank>for<s2sv_blank>bssid<s2sv_blank>found"" , airpdcap_debug_level_3 ) ; return airpdcap_ret_req_data ; } if ( airpdcaprsna4whandshake ( ctx , data , sa , offset , tot_len ) == airpdcap_ret_success_handshake ) return airpdcap_ret_success_handshake ; if ( mac_header_len + group_key_payload_len_min > tot_len ) { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""message<s2sv_blank>too<s2sv_blank>short<s2sv_blank>for<s2sv_blank>group<s2sv_blank>key"" , airpdcap_debug_level_3 ) ; return airpdcap_ret_no_valid_handshake ; } if ( airpdcap_eap_key ( data [ offset + 1 ] ) != 0 || airpdcap_eap_ack ( data [ offset + 1 ] ) != 1 || airpdcap_eap_mic ( data [ offset ] ) != 1 || airpdcap_eap_sec ( data [ offset ] ) != 1 ) { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""key<s2sv_blank>bitfields<s2sv_blank>not<s2sv_blank>correct<s2sv_blank>for<s2sv_blank>group<s2sv_blank>key"" , airpdcap_debug_level_3 ) ; return airpdcap_ret_no_valid_handshake ; } memcpy ( id . sta , broadcast_mac , airpdcap_mac_len ) ; sa = airpdcapgetsaptr ( ctx , & id ) ; if ( sa == null ) { return airpdcap_ret_req_data ; } if ( ( addr = airpdcapgetstaaddress ( ( const airpdcap_mac_frame_addr4 * ) ( data ) ) ) != null ) { memcpy ( id . sta , addr , airpdcap_mac_len ) ; # ifdef _debug g_snprintf ( msgbuf , msgbuf_len , ""st_mac:<s2sv_blank>%2x.%2x.%2x.%2x.%2x.%2x\\t"" , id . sta [ 0 ] , id . sta [ 1 ] , id . sta [ 2 ] , id . sta [ 3 ] , id . sta [ 4 ] , id . sta [ 5 ] ) ; # endif airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , msgbuf , airpdcap_debug_level_3 ) ; } else { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""sa<s2sv_blank>not<s2sv_blank>found"" , airpdcap_debug_level_5 ) ; return airpdcap_ret_req_data ; } sta_sa = airpdcapgetsaptr ( ctx , & id ) ; if ( sta_sa == null ) { return airpdcap_ret_req_data ; } return ( airpdcapdecryptwpabroadcastkey ( peapkey , sta_sa -> wpa . ptk + 16 , sa , tot_len - offset + 1 ) ) ; } else if ( memcmp ( data + offset , tdls_header , 10 ) == 0 ) { const guint8 * initiator , * responder ; guint8 action ; guint status , offset_rsne = 0 , offset_fte = 0 , offset_link = 0 , offset_timeout = 0 ; airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""authentication:<s2sv_blank>tdls<s2sv_blank>action<s2sv_blank>frame"" , airpdcap_debug_level_3 ) ; offset += 10 ; action = data [ offset ] ; if ( action != 1 && action != 2 ) { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""not<s2sv_blank>response<s2sv_blank>nor<s2sv_blank>confirm"" , airpdcap_debug_level_3 ) ; return airpdcap_ret_no_valid_handshake ; } offset ++ ; status = pntoh16 ( data + offset ) ; if ( status != 0 ) { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""tdls<s2sv_blank>setup<s2sv_blank>not<s2sv_blank>successfull"" , airpdcap_debug_level_3 ) ; return airpdcap_ret_no_valid_handshake ; } offset += 5 ; while ( offset < ( tot_len - 2 ) ) { if ( data [ offset ] == 48 ) { offset_rsne = offset ; } else if ( data [ offset ] == 55 ) { offset_fte = offset ; } else if ( data [ offset ] == 56 ) { offset_timeout = offset ; } else if ( data [ offset ] == 101 ) { offset_link = offset ; } if ( tot_len < offset + data [ offset + 1 ] + 2 ) { return airpdcap_ret_no_valid_handshake ; } offset += data [ offset + 1 ] + 2 ; } if ( offset_rsne == 0 || offset_fte == 0 || offset_timeout == 0 || offset_link == 0 ) { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""cannot<s2sv_blank>find<s2sv_blank>all<s2sv_blank>necessary<s2sv_blank>ies"" , airpdcap_debug_level_3 ) ; return airpdcap_ret_no_valid_handshake ; } airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""found<s2sv_blank>rsne/fast<s2sv_blank>bss/timeout<s2sv_blank>interval/link<s2sv_blank>ies"" , airpdcap_debug_level_3 ) ; initiator = & data [ offset_link + 8 ] ; responder = & data [ offset_link + 14 ] ; if ( memcmp ( initiator , responder , airpdcap_mac_len ) < 0 ) { memcpy ( id . sta , initiator , airpdcap_mac_len ) ; memcpy ( id . bssid , responder , airpdcap_mac_len ) ; } else { memcpy ( id . sta , responder , airpdcap_mac_len ) ; memcpy ( id . bssid , initiator , airpdcap_mac_len ) ; } sa = airpdcapgetsaptr ( ctx , & id ) ; if ( sa == null ) { return airpdcap_ret_req_data ; } if ( sa -> validkey ) { if ( memcmp ( sa -> wpa . nonce , data + offset_fte + 52 , airpdcap_wpa_nonce_len ) == 0 ) { return airpdcap_ret_success_handshake ; } else { airpdcap_sec_association * tmp_sa = g_new ( airpdcap_sec_association , 1 ) ; memcpy ( tmp_sa , sa , sizeof ( airpdcap_sec_association ) ) ; sa -> next = tmp_sa ; sa -> validkey = false ; } } if ( airpdcaptdlsderivekey ( sa , data , offset_rsne , offset_fte , offset_timeout , offset_link , action ) == airpdcap_ret_success ) { airpdcap_debug_trace_end ( ""airpdcapscanforkeys"" ) ; return airpdcap_ret_success_handshake ; } } else { airpdcap_debug_print_line ( ""airpdcapscanforkeys"" , ""skipping:<s2sv_blank>not<s2sv_blank>an<s2sv_blank>eapol<s2sv_blank>packet"" , airpdcap_debug_level_3 ) ; } airpdcap_debug_trace_end ( ""airpdcapscanforkeys"" ) ; return airpdcap_ret_no_valid_handshake ; }","<S2SV_ModStart> if ( ( ( <S2SV_ModStart> ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) )
",wireshark@wireshark/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4,CVE-2016-5351,https://github.com/wireshark/wireshark/commit/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4,2016-08-07T16:59Z,<S2SV_StartBug> if ( ( tot_len - offset - 4 ) < bodyLength ) { <S2SV_EndBug>
2162,CWE-20,"static void f2fs_put_super ( struct super_block * sb ) { struct f2fs_sb_info * sbi = f2fs_sb ( sb ) ; int i ; f2fs_quota_off_umount ( sb ) ; mutex_lock ( & sbi -> umount_mutex ) ; if ( is_sbi_flag_set ( sbi , sbi_is_dirty ) || ! is_set_ckpt_flags ( sbi , cp_umount_flag ) ) { struct cp_control cpc = { . reason = cp_umount , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_wait_discard_bios ( sbi ) ; if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = { . reason = cp_umount | cp_trimmed , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_destroy_stats ( sbi ) ; release_ino_entry ( sbi , true ) ; f2fs_leave_shrinker ( sbi ) ; mutex_unlock ( & sbi -> umount_mutex ) ; f2fs_flush_merged_writes ( sbi ) ; iput ( sbi -> node_inode ) ; iput ( sbi -> meta_inode ) ; destroy_node_manager ( sbi ) ; destroy_segment_manager ( sbi ) ; kfree ( sbi -> ckpt ) ; f2fs_unregister_sysfs ( sbi ) ; sb -> s_fs_info = null ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> raw_super ) ; destroy_device_list ( sbi ) ; mempool_destroy ( sbi -> write_io_dummy ) ; # ifdef config_quota for ( i = 0 ; i < maxquotas ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif destroy_percpu_info ( sbi ) ; for ( i = 0 ; i < nr_page_type ; i ++ ) kfree ( sbi -> write_io [ i ] ) ; kfree ( sbi ) ; }","<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , true
",torvalds@linux/638164a2718f337ea224b747cf5977ef143166a4,CVE-2017-18200,https://github.com/torvalds/linux/commit/638164a2718f337ea224b747cf5977ef143166a4,2018-02-26T03:29Z,<S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug>
2829,CWE-255,"static int toggle_utf8 ( const char * name , int fd , bool utf8 ) { int r ; struct termios tc = { } ; assert ( name ) ; r = ioctl ( fd , kdskbmode , utf8 ? k_unicode : k_xlate ) ; if ( r < 0 ) return log_warning_errno ( errno , ""failed<s2sv_blank>to<s2sv_blank>%s<s2sv_blank>utf-8<s2sv_blank>kbdmode<s2sv_blank>on<s2sv_blank>%s:<s2sv_blank>%m"" , enable_disable ( utf8 ) , name ) ; r = loop_write ( fd , utf8 ? ""\\033%g"" : ""\\033%@"" , 3 , false ) ; if ( r < 0 ) return log_warning_errno ( r , ""failed<s2sv_blank>to<s2sv_blank>%s<s2sv_blank>utf-8<s2sv_blank>term<s2sv_blank>processing<s2sv_blank>on<s2sv_blank>%s:<s2sv_blank>%m"" , enable_disable ( utf8 ) , name ) ; r = tcgetattr ( fd , & tc ) ; if ( r >= 0 ) { set_flag ( tc . c_iflag , iutf8 , utf8 ) ; r = tcsetattr ( fd , tcsanow , & tc ) ; } if ( r < 0 ) return log_warning_errno ( errno , ""failed<s2sv_blank>to<s2sv_blank>%s<s2sv_blank>iutf8<s2sv_blank>flag<s2sv_blank>on<s2sv_blank>%s:<s2sv_blank>%m"" , enable_disable ( utf8 ) , name ) ; log_debug ( ""utf-8<s2sv_blank>kbdmode<s2sv_blank>%sd<s2sv_blank>on<s2sv_blank>%s"" , enable_disable ( utf8 ) , name ) ; return 0 ; }","<S2SV_ModStart> ; assert ( name ) ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_warning_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m"" , name ) ; return 0 ; } else if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" ,
",systemd@systemd/9725f1a10f80f5e0ae7d9b60547458622aeb322f,CVE-2018-20839,https://github.com/systemd/systemd/commit/9725f1a10f80f5e0ae7d9b60547458622aeb322f,2019-05-17T04:29Z,<S2SV_StartBug> assert ( name ) ; <S2SV_EndBug>
3296,CWE-399,"void br_mdb_notify ( struct net_device * dev , struct net_bridge_port * port , struct br_ip * group , int type ) { struct br_mdb_entry entry ; entry . ifindex = port -> dev -> ifindex ; entry . addr . proto = group -> proto ; entry . addr . u . ip4 = group -> u . ip4 ; # if is_enabled ( config_ipv6 ) entry . addr . u . ip6 = group -> u . ip6 ; # endif __br_mdb_notify ( dev , & entry , type ) ; }","<S2SV_ModStart> struct br_mdb_entry entry ; memset ( & entry , 0 , sizeof ( entry ) )
",torvalds@linux/c085c49920b2f900ba716b4ca1c1a55ece9872cc,CVE-2013-2636,https://github.com/torvalds/linux/commit/c085c49920b2f900ba716b4ca1c1a55ece9872cc,2013-03-22T11:59Z,<S2SV_StartBug> struct br_mdb_entry entry ; <S2SV_EndBug>
6534,CWE-119,"cjson * cjson_detachitemfromarray ( cjson * array , int which ) { cjson * c = array -> child ; while ( c && which > 0 ) { c = c -> next ; -- which ; } if ( ! c ) return 0 ; if ( c -> prev ) c -> prev -> next = c -> next ; if ( c -> next ) c -> next -> prev = c -> prev ; if ( c == array -> child ) array -> child = c -> next ; c -> prev = c -> next = 0 ; return c ; }","<S2SV_ModStart> > 0 ) <S2SV_ModEnd> c = c <S2SV_ModStart> c -> next , which -- ; <S2SV_ModEnd> if ( !
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,<S2SV_StartBug> while ( c && which > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = c -> next ; <S2SV_EndBug>
3596,CWE-476,"int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) { dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; struct flush_cmd_control * fcc ; int err = 0 ; if ( sm_i ( sbi ) -> fcc_info ) { fcc = sm_i ( sbi ) -> fcc_info ; goto init_thread ; } fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , gfp_kernel ) ; if ( ! fcc ) return - enomem ; atomic_set ( & fcc -> issued_flush , 0 ) ; atomic_set ( & fcc -> issing_flush , 0 ) ; init_waitqueue_head ( & fcc -> flush_wait_queue ) ; init_llist_head ( & fcc -> issue_list ) ; sm_i ( sbi ) -> fcc_info = fcc ; init_thread : fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , ""f2fs_flush-%u:%u"" , major ( dev ) , minor ( dev ) ) ; if ( is_err ( fcc -> f2fs_issue_flush ) ) { err = ptr_err ( fcc -> f2fs_issue_flush ) ; kfree ( fcc ) ; sm_i ( sbi ) -> fcc_info = null ; return err ; } return err ; }","<S2SV_ModStart> = fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;
",torvalds@linux/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,CVE-2017-18241,https://github.com/torvalds/linux/commit/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,2018-03-21T16:29Z,<S2SV_StartBug> init_thread : <S2SV_EndBug>
3428,CWE-404,"long keyctl_set_reqkey_keyring ( int reqkey_defl ) { struct cred * new ; int ret , old_setting ; old_setting = current_cred_xxx ( jit_keyring ) ; if ( reqkey_defl == key_reqkey_defl_no_change ) return old_setting ; new = prepare_creds ( ) ; if ( ! new ) return - enomem ; switch ( reqkey_defl ) { case key_reqkey_defl_thread_keyring : ret = install_thread_keyring_to_cred ( new ) ; if ( ret < 0 ) goto error ; goto set ; case key_reqkey_defl_process_keyring : ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { if ( ret != - eexist ) goto error ; ret = 0 ; } goto set ; case key_reqkey_defl_default : case key_reqkey_defl_session_keyring : case key_reqkey_defl_user_keyring : case key_reqkey_defl_user_session_keyring : case key_reqkey_defl_requestor_keyring : goto set ; case key_reqkey_defl_no_change : case key_reqkey_defl_group_keyring : default : ret = - einval ; goto error ; } set : new -> jit_keyring = reqkey_defl ; commit_creds ( new ) ; return old_setting ; error : abort_creds ( new ) ; return ret ; }","<S2SV_ModStart> < 0 ) goto error ; <S2SV_ModEnd> goto set ;
",torvalds@linux/c9f838d104fed6f2f61d68164712e3204bf5271b,CVE-2017-7472,https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b,2017-05-11T19:29Z,<S2SV_StartBug> if ( ret < 0 ) { <S2SV_EndBug>
5651,CWE-119,"static void scalar32_min_max_or ( struct bpf_reg_state * dst_reg , struct bpf_reg_state * src_reg ) { bool src_known = tnum_subreg_is_const ( src_reg -> var_off ) ; bool dst_known = tnum_subreg_is_const ( dst_reg -> var_off ) ; struct tnum var32_off = tnum_subreg ( dst_reg -> var_off ) ; s32 smin_val = src_reg -> smin_value ; u32 umin_val = src_reg -> umin_value ; if ( src_known && dst_known ) return ; dst_reg -> u32_min_value = max ( dst_reg -> u32_min_value , umin_val ) ; dst_reg -> u32_max_value = var32_off . value | var32_off . mask ; if ( dst_reg -> s32_min_value < 0 || smin_val < 0 ) { dst_reg -> s32_min_value = s32_min ; dst_reg -> s32_max_value = s32_max ; } else { dst_reg -> s32_min_value = dst_reg -> umin_value ; dst_reg -> s32_max_value = dst_reg -> umax_value ; } }","<S2SV_ModStart> = src_reg -> s32_min_value <S2SV_ModEnd> ; u32 umin_val <S2SV_ModStart> = src_reg -> u32_min_value <S2SV_ModEnd> ; if ( <S2SV_ModStart> = dst_reg -> u32_min_value <S2SV_ModEnd> ; dst_reg -> <S2SV_ModStart> = dst_reg -> u32_max_value <S2SV_ModEnd> ; } }
",torvalds@linux/5b9fbeb75b6a98955f628e205ac26689bcb1383e,CVE-2020-27194,https://github.com/torvalds/linux/commit/5b9fbeb75b6a98955f628e205ac26689bcb1383e,2020-10-16T21:15Z,<S2SV_StartBug> s32 smin_val = src_reg -> smin_value ; <S2SV_EndBug> <S2SV_StartBug> u32 umin_val = src_reg -> umin_value ; <S2SV_EndBug> <S2SV_StartBug> dst_reg -> s32_min_value = dst_reg -> umin_value ; <S2SV_EndBug> <S2SV_StartBug> dst_reg -> s32_max_value = dst_reg -> umax_value ; <S2SV_EndBug>
3069,CWE-416,"static void lo_release ( struct gendisk * disk , fmode_t mode ) { struct loop_device * lo = disk -> private_data ; int err ; if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ; mutex_lock ( & lo -> lo_ctl_mutex ) ; if ( lo -> lo_flags & lo_flags_autoclear ) { err = loop_clr_fd ( lo ) ; if ( ! err ) return ; } else if ( lo -> lo_state == lo_bound ) { blk_mq_freeze_queue ( lo -> lo_queue ) ; blk_mq_unfreeze_queue ( lo -> lo_queue ) ; } mutex_unlock ( & lo -> lo_ctl_mutex ) ; }","<S2SV_ModStart> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> disk -> private_data <S2SV_ModStart> disk -> private_data ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> mutex_unlock ( & loop_index_mutex <S2SV_ModEnd> ) ; }
",torvalds@linux/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,CVE-2018-5344,https://github.com/torvalds/linux/commit/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,2018-01-12T09:29Z,<S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug>
7104,CWE-119,"static int cac_cac1_get_certificate ( sc_card_t * card , u8 * * out_buf , size_t * out_len ) { u8 buf [ cac_max_size ] ; u8 * out_ptr ; size_t size = 0 ; size_t left = 0 ; size_t len , next_len ; sc_apdu_t apdu ; int r = sc_success ; sc_func_called ( card -> ctx , sc_log_debug_verbose ) ; size = left = * out_buf ? * out_len : sizeof ( buf ) ; out_ptr = * out_buf ? * out_buf : buf ; sc_format_apdu ( card , & apdu , sc_apdu_case_2_short , cac_ins_get_certificate , 0 , 0 ) ; next_len = min ( left , 100 ) ; for ( ; left > 0 ; left -= len , out_ptr += len ) { len = next_len ; apdu . resp = out_ptr ; apdu . le = len ; apdu . resplen = left ; r = sc_transmit_apdu ( card , & apdu ) ; if ( r < 0 ) { break ; } if ( apdu . resplen == 0 ) { r = sc_error_internal ; break ; } if ( apdu . sw1 != 0x63 || apdu . sw2 < 1 ) { r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; left -= len ; break ; } next_len = min ( left , apdu . sw2 ) ; } if ( r < 0 ) { sc_func_return ( card -> ctx , sc_log_debug_verbose , r ) ; } r = size - left ; if ( * out_buf == null ) { * out_buf = malloc ( r ) ; if ( * out_buf == null ) { sc_func_return ( card -> ctx , sc_log_debug_verbose , sc_error_out_of_memory ) ; } memcpy ( * out_buf , buf , r ) ; } * out_len = r ; sc_func_return ( card -> ctx , sc_log_debug_verbose , r ) ; }","<S2SV_ModStart> ; size_t len <S2SV_ModEnd> ; sc_apdu_t apdu <S2SV_ModStart> 0 ) ; len <S2SV_ModEnd> = MIN ( <S2SV_ModStart> > 0 ; ) { <S2SV_ModEnd> apdu . resp <S2SV_ModStart> break ; } left -= len ; out_ptr += len ; len <S2SV_ModEnd> = MIN (
",OpenSC@OpenSC/b75c002cfb1fd61cd20ec938ff4937d7b1a94278,CVE-2019-19481,https://github.com/OpenSC/OpenSC/commit/b75c002cfb1fd61cd20ec938ff4937d7b1a94278,2019-12-01T23:15Z,"<S2SV_StartBug> size_t len , next_len ; <S2SV_EndBug> <S2SV_StartBug> next_len = MIN ( left , 100 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ; left > 0 ; left -= len , out_ptr += len ) { <S2SV_EndBug> <S2SV_StartBug> next_len = MIN ( left , apdu . sw2 ) ; <S2SV_EndBug>"
6239,CWE-000,"static void addformvars ( cchar * buf ) { char * pair , * tok ; pair = stok ( sclone ( buf ) , ""&"" , & tok ) ; while ( pair != 0 ) { mpradditem ( app -> formdata , sclone ( pair ) ) ; pair = stok ( 0 , ""&"" , & tok ) ; } }","<S2SV_ModStart> while ( pair <S2SV_ModEnd> ) { mprAddItem
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,<S2SV_StartBug> while ( pair != 0 ) { <S2SV_EndBug>
2447,CWE-119,"int copy_creds ( struct task_struct * p , unsigned long clone_flags ) { # ifdef config_keys struct thread_group_cred * tgcred ; # endif struct cred * new ; int ret ; if ( # ifdef config_keys ! p -> cred -> thread_keyring && # endif clone_flags & clone_thread ) { p -> real_cred = get_cred ( p -> cred ) ; get_cred ( p -> cred ) ; alter_cred_subscribers ( p -> cred , 2 ) ; kdebug ( ""share_creds(%p{%d,%d})"" , p -> cred , atomic_read ( & p -> cred -> usage ) , read_cred_subscribers ( p -> cred ) ) ; atomic_inc ( & p -> cred -> user -> processes ) ; return 0 ; } new = prepare_creds ( ) ; if ( ! new ) return - enomem ; if ( clone_flags & clone_newuser ) { ret = create_user_ns ( new ) ; if ( ret < 0 ) goto error_put ; } new -> user_ns = new -> user -> user_ns ; # ifdef config_keys if ( new -> thread_keyring ) { key_put ( new -> thread_keyring ) ; new -> thread_keyring = null ; if ( clone_flags & clone_thread ) install_thread_keyring_to_cred ( new ) ; } if ( ! ( clone_flags & clone_thread ) ) { tgcred = kmalloc ( sizeof ( * tgcred ) , gfp_kernel ) ; if ( ! tgcred ) { ret = - enomem ; goto error_put ; } atomic_set ( & tgcred -> usage , 1 ) ; spin_lock_init ( & tgcred -> lock ) ; tgcred -> process_keyring = null ; tgcred -> session_keyring = key_get ( new -> tgcred -> session_keyring ) ; release_tgcred ( new ) ; new -> tgcred = tgcred ; } # endif atomic_inc ( & new -> user -> processes ) ; p -> cred = p -> real_cred = get_cred ( new ) ; alter_cred_subscribers ( new , 2 ) ; validate_creds ( new ) ; return 0 ; error_put : put_cred ( new ) ; return ret ; }","<S2SV_ModStart> int ret ; p -> replacement_session_keyring = NULL ;
",torvalds@linux/79549c6dfda0603dba9a70a53467ce62d9335c33,CVE-2012-2745,https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33,2012-08-09T10:29Z,<S2SV_StartBug> if ( <S2SV_EndBug>
5588,CWE-399,"static int cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection ) { int sock ; cib_remote_opaque_t * private = cib -> variant_opaque ; struct sockaddr_in addr ; int rc = 0 ; char * server = private -> server ; int ret_ga ; struct addrinfo * res ; struct addrinfo hints ; xmlnode * answer = null ; xmlnode * login = null ; static struct mainloop_fd_callbacks cib_fd_callbacks = { . dispatch = cib_remote_dispatch , . destroy = cib_remote_connection_destroy , } ; connection -> socket = 0 ; connection -> session = null ; sock = socket ( pf_inet , sock_stream , ipproto_tcp ) ; if ( sock == - 1 ) { crm_perror ( log_err , ""socket<s2sv_blank>creation<s2sv_blank>failed"" ) ; return - 1 ; } bzero ( & hints , sizeof ( struct addrinfo ) ) ; hints . ai_flags = ai_canonname ; hints . ai_family = af_inet ; hints . ai_socktype = sock_raw ; if ( hints . ai_family == af_inet6 ) { hints . ai_protocol = ipproto_icmpv6 ; } else { hints . ai_protocol = ipproto_icmp ; } crm_debug ( ""looking<s2sv_blank>up<s2sv_blank>%s"" , server ) ; ret_ga = getaddrinfo ( server , null , & hints , & res ) ; if ( ret_ga ) { crm_err ( ""getaddrinfo:<s2sv_blank>%s"" , gai_strerror ( ret_ga ) ) ; close ( sock ) ; return - 1 ; } if ( res -> ai_canonname ) { server = res -> ai_canonname ; } crm_debug ( ""got<s2sv_blank>address<s2sv_blank>%s<s2sv_blank>for<s2sv_blank>%s"" , server , private -> server ) ; if ( ! res -> ai_addr ) { fprintf ( stderr , ""getaddrinfo<s2sv_blank>failed"" ) ; crm_exit ( 1 ) ; } # if 1 memcpy ( & addr , res -> ai_addr , res -> ai_addrlen ) ; # else memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = af_inet ; addr . sin_addr . s_addr = inet_addr ( server ) ; # endif addr . sin_port = htons ( private -> port ) ; if ( connect ( sock , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) { crm_perror ( log_err , ""connection<s2sv_blank>to<s2sv_blank>%s:%d<s2sv_blank>failed"" , server , private -> port ) ; close ( sock ) ; return - 1 ; } if ( connection -> encrypted ) { # ifdef have_gnutls_gnutls_h gnutls_global_init ( ) ; gnutls_anon_allocate_client_credentials ( & anon_cred_c ) ; connection -> session = create_tls_session ( sock , gnutls_client ) ; if ( connection -> session == null ) { crm_perror ( log_err , ""session<s2sv_blank>creation<s2sv_blank>for<s2sv_blank>%s:%d<s2sv_blank>failed"" , server , private -> port ) ; close ( sock ) ; cib_tls_close ( cib ) ; return - 1 ; } # else return - eprotonosupport ; # endif } else { connection -> session = guint_to_pointer ( sock ) ; } login = create_xml_node ( null , ""cib_command"" ) ; crm_xml_add ( login , ""op"" , ""authenticate"" ) ; crm_xml_add ( login , ""user"" , private -> user ) ; crm_xml_add ( login , ""password"" , private -> passwd ) ; crm_xml_add ( login , ""hidden"" , ""password"" ) ; crm_send_remote_msg ( connection -> session , login , connection -> encrypted ) ; free_xml ( login ) ; answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ; crm_log_xml_trace ( answer , ""reply"" ) ; if ( answer == null ) { rc = - eproto ; } else { const char * msg_type = crm_element_value ( answer , f_cib_operation ) ; const char * tmp_ticket = crm_element_value ( answer , f_cib_clientid ) ; if ( safe_str_neq ( msg_type , crm_op_register ) ) { crm_err ( ""invalid<s2sv_blank>registration<s2sv_blank>message:<s2sv_blank>%s"" , msg_type ) ; rc = - eproto ; } else if ( tmp_ticket == null ) { rc = - eproto ; } else { connection -> token = strdup ( tmp_ticket ) ; } } if ( rc != 0 ) { cib_tls_close ( cib ) ; } connection -> socket = sock ; connection -> source = mainloop_add_fd ( ""cib-remote"" , g_priority_high , connection -> socket , cib , & cib_fd_callbacks ) ; return rc ; }","<S2SV_ModStart> remote_connection_s * connection , gboolean event_channel <S2SV_ModStart> -> variant_opaque ; <S2SV_ModEnd> int rc = <S2SV_ModStart> = 0 ; int disconnected = 0 <S2SV_ModEnd> ; xmlNode * <S2SV_ModStart> mainloop_fd_callbacks cib_fd_callbacks = { 0 , } ; cib_fd_callbacks <S2SV_ModEnd> . dispatch = <S2SV_ModStart> . dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch ; cib_fd_callbacks <S2SV_ModEnd> . destroy = <S2SV_ModStart> destroy = cib_remote_connection_destroy <S2SV_ModEnd> ; connection -> <S2SV_ModStart> ; sock = crm_remote_tcp_connect ( private -> server , private -> port ) ; if ( sock <= 0 ) { crm_perror ( LOG_ERR , ""remote<S2SV_blank>tcp<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> server , private -> port ) ; } connection -> socket = sock ; <S2SV_ModEnd> if ( connection <S2SV_ModStart> # ifdef HAVE_GNUTLS_GNUTLS_H if ( remote_gnutls_credentials_init == FALSE ) { <S2SV_ModStart> anon_cred_c ) ; remote_gnutls_credentials_init = TRUE ; } connection -> session = crm_create_anon_tls_session <S2SV_ModEnd> ( sock , <S2SV_ModStart> sock , GNUTLS_CLIENT , anon_cred_c ) ; if ( crm_initiate_client_tls_handshake ( connection -> session , DEFAULT_CLIENT_HANDSHAKE_TIMEOUT ) != 0 ) { crm_err ( ""Session<S2SV_blank>creation<S2SV_blank>for<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> <S2SV_ModEnd> server , private <S2SV_ModStart> port ) ; gnutls_deinit ( * connection -> session ) ; gnutls_free ( connection -> session ) ; connection -> session = NULL <S2SV_ModEnd> ; cib_tls_close ( <S2SV_ModStart> login ) ; <S2SV_ModEnd> crm_recv_remote_msg ( connection <S2SV_ModStart> -> session , & connection -> recv_buf , <S2SV_ModStart> connection -> encrypted , - 1 , & disconnected ) ; if ( disconnected ) { rc = - ENOTCONN ; } answer = crm_parse_remote_buffer ( & connection -> recv_buf <S2SV_ModStart> ; } } free_xml ( answer ) ; answer = NULL ; <S2SV_ModStart> cib ) ; return rc ; } crm_trace ( ""remote<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>established"" ) <S2SV_ModEnd> ; connection ->
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z,"<S2SV_StartBug> cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection ) <S2SV_EndBug> <S2SV_StartBug> struct sockaddr_in addr ; <S2SV_EndBug> <S2SV_StartBug> char * server = private -> server ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> . dispatch = cib_remote_dispatch , <S2SV_EndBug> <S2SV_StartBug> . destroy = cib_remote_connection_destroy , <S2SV_EndBug> <S2SV_StartBug> sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ; <S2SV_EndBug> <S2SV_StartBug> gnutls_global_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ; <S2SV_EndBug> <S2SV_StartBug> close ( sock ) ; <S2SV_EndBug> <S2SV_StartBug> answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc != 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
5877,CWE-416,"static void ndpi_reset_packet_line_info ( struct ndpi_packet_struct * packet ) { packet -> parsed_lines = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = null , packet -> host_line . len = 0 , packet -> referer_line . ptr = null , packet -> referer_line . len = 0 , packet -> content_line . ptr = null , packet -> content_line . len = 0 , packet -> accept_line . ptr = null , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = null , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = null , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = null , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = null , packet -> http_transfer_encoding . len = 0 , packet -> http_contentlen . ptr = null , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = null , packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = null , packet -> http_x_session_type . ptr = null , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = null , packet -> server_line . len = 0 , packet -> http_method . ptr = null , packet -> http_method . len = 0 , packet -> http_response . ptr = null , packet -> http_response . len = 0 , packet -> http_num_headers = 0 ; }","<S2SV_ModStart> , packet -> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet ->
",ntop@nDPI/6a9f5e4f7c3fd5ddab3e6727b071904d76773952,CVE-2020-15475,https://github.com/ntop/nDPI/commit/6a9f5e4f7c3fd5ddab3e6727b071904d76773952,2020-07-01T11:15Z,"<S2SV_StartBug> packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , <S2SV_EndBug>"
252,CWE-119,"static int dtls1_buffer_record ( ssl * s , record_pqueue * queue , unsigned char * priority ) { dtls1_record_data * rdata ; pitem * item ; if ( pqueue_size ( queue -> q ) >= 100 ) return 0 ; rdata = openssl_malloc ( sizeof ( dtls1_record_data ) ) ; item = pitem_new ( priority , rdata ) ; if ( rdata == null || item == null ) { if ( rdata != null ) openssl_free ( rdata ) ; if ( item != null ) pitem_free ( item ) ; sslerr ( ssl_f_dtls1_buffer_record , err_r_internal_error ) ; return ( 0 ) ; } rdata -> packet = s -> packet ; rdata -> packet_length = s -> packet_length ; memcpy ( & ( rdata -> rbuf ) , & ( s -> s3 -> rbuf ) , sizeof ( ssl3_buffer ) ) ; memcpy ( & ( rdata -> rrec ) , & ( s -> s3 -> rrec ) , sizeof ( ssl3_record ) ) ; item -> data = rdata ; # ifndef openssl_no_sctp if ( bio_dgram_is_sctp ( ssl_get_rbio ( s ) ) && ( s -> state == ssl3_st_sr_finished_a || s -> state == ssl3_st_cr_finished_a ) ) { bio_ctrl ( ssl_get_rbio ( s ) , bio_ctrl_dgram_sctp_get_rcvinfo , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif s -> packet = null ; s -> packet_length = 0 ; memset ( & ( s -> s3 -> rbuf ) , 0 , sizeof ( ssl3_buffer ) ) ; memset ( & ( s -> s3 -> rrec ) , 0 , sizeof ( ssl3_record ) ) ; if ( ! ssl3_setup_buffers ( s ) ) { sslerr ( ssl_f_dtls1_buffer_record , err_r_internal_error ) ; openssl_free ( rdata ) ; pitem_free ( item ) ; return ( 0 ) ; } if ( pqueue_insert ( queue -> q , item ) == null ) { sslerr ( ssl_f_dtls1_buffer_record , err_r_internal_error ) ; openssl_free ( rdata ) ; pitem_free ( item ) ; return ( 0 ) ; } return ( 1 ) ; }","<S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
",openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f,CVE-2015-0206,https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f,2015-01-09T02:59Z,<S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug>
971,CWE-416,"int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( is_err ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - ptr_err ( dst ) ; return ptr_err ( dst ) ; } __ip6_dst_store ( sk , dst , null , null ) ; } return 0 ; }","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; dst
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug>"
3203,CWE-000,"static int sanity_check_raw_super ( struct f2fs_sb_info * sbi , struct buffer_head * bh ) { struct f2fs_super_block * raw_super = ( struct f2fs_super_block * ) ( bh -> b_data + f2fs_super_offset ) ; struct super_block * sb = sbi -> sb ; unsigned int blocksize ; if ( f2fs_super_magic != le32_to_cpu ( raw_super -> magic ) ) { f2fs_msg ( sb , kern_info , ""magic<s2sv_blank>mismatch,<s2sv_blank>valid(0x%x)<s2sv_blank>-<s2sv_blank>read(0x%x)"" , f2fs_super_magic , le32_to_cpu ( raw_super -> magic ) ) ; return 1 ; } if ( f2fs_blksize != page_size ) { f2fs_msg ( sb , kern_info , ""invalid<s2sv_blank>page_cache_size<s2sv_blank>(%lu),<s2sv_blank>supports<s2sv_blank>only<s2sv_blank>4kb\\n"" , page_size ) ; return 1 ; } blocksize = 1 << le32_to_cpu ( raw_super -> log_blocksize ) ; if ( blocksize != f2fs_blksize ) { f2fs_msg ( sb , kern_info , ""invalid<s2sv_blank>blocksize<s2sv_blank>(%u),<s2sv_blank>supports<s2sv_blank>only<s2sv_blank>4kb\\n"" , blocksize ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_blocks_per_seg ) != 9 ) { f2fs_msg ( sb , kern_info , ""invalid<s2sv_blank>log<s2sv_blank>blocks<s2sv_blank>per<s2sv_blank>segment<s2sv_blank>(%u)\\n"" , le32_to_cpu ( raw_super -> log_blocks_per_seg ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectorsize ) > f2fs_max_log_sector_size || le32_to_cpu ( raw_super -> log_sectorsize ) < f2fs_min_log_sector_size ) { f2fs_msg ( sb , kern_info , ""invalid<s2sv_blank>log<s2sv_blank>sectorsize<s2sv_blank>(%u)"" , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectors_per_block ) + le32_to_cpu ( raw_super -> log_sectorsize ) != f2fs_max_log_sector_size ) { f2fs_msg ( sb , kern_info , ""invalid<s2sv_blank>log<s2sv_blank>sectors<s2sv_blank>per<s2sv_blank>block(%u)<s2sv_blank>log<s2sv_blank>sectorsize(%u)"" , le32_to_cpu ( raw_super -> log_sectors_per_block ) , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> node_ino ) != 1 || le32_to_cpu ( raw_super -> meta_ino ) != 2 || le32_to_cpu ( raw_super -> root_ino ) != 3 ) { f2fs_msg ( sb , kern_info , ""invalid<s2sv_blank>fs<s2sv_blank>meta<s2sv_blank>ino:<s2sv_blank>node(%u)<s2sv_blank>meta(%u)<s2sv_blank>root(%u)"" , le32_to_cpu ( raw_super -> node_ino ) , le32_to_cpu ( raw_super -> meta_ino ) , le32_to_cpu ( raw_super -> root_ino ) ) ; return 1 ; } if ( sanity_check_area_boundary ( sbi , bh ) ) return 1 ; return 0 ; }","<S2SV_ModStart> } if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if (
",torvalds@linux/b9dd46188edc2f0d1f37328637860bb65a771124,CVE-2017-10662,https://github.com/torvalds/linux/commit/b9dd46188edc2f0d1f37328637860bb65a771124,2017-08-19T18:29Z,"<S2SV_StartBug> if ( sanity_check_area_boundary ( sbi , bh ) ) <S2SV_EndBug>"
8330,CWE-476,"static const char * escape_xml ( const char * text ) { static char * escaped ; static size_t escaped_size ; char * out ; size_t len ; for ( out = escaped , len = 0 ; * text ; ++ len , ++ out , ++ text ) { if ( ( len + 8 ) > escaped_size ) { char * bigger_escaped ; escaped_size += 128 ; bigger_escaped = realloc ( escaped , escaped_size ) ; if ( ! bigger_escaped ) { free ( escaped ) ; escaped = null ; escaped_size = 0 ; return "">>><s2sv_blank>out<s2sv_blank>of<s2sv_blank>memory<s2sv_blank><<<"" ; } out = bigger_escaped + len ; escaped = bigger_escaped ; } switch ( * text ) { case '&' : strcpy ( out , ""&amp;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '<' : strcpy ( out , ""&lt;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '>' : strcpy ( out , ""&gt;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; default : * out = * text ; break ; } } * out = '\\x0' ; return escaped ; }","<S2SV_ModStart> size_t len ; if ( ! strlen ( text ) ) return ""empty<S2SV_blank>string"" ;
",libexif@exif/f6334d9d32437ef13dc902f0a88a2be0063d9d1c,CVE-2021-27815,https://github.com/libexif/exif/commit/f6334d9d32437ef13dc902f0a88a2be0063d9d1c,2021-04-14T14:15Z,"<S2SV_StartBug> for ( out = escaped , len = 0 ; * text ; ++ len , ++ out , ++ text ) { <S2SV_EndBug>"
6718,CWE-444,"static ngx_int_t ngx_http_lua_adjust_subrequest ( ngx_http_request_t * sr , ngx_uint_t method , int always_forward_body , ngx_http_request_body_t * body , unsigned vars_action , ngx_array_t * extra_vars ) { ngx_http_request_t * r ; ngx_int_t rc ; ngx_http_core_main_conf_t * cmcf ; size_t size ; r = sr -> parent ; sr -> header_in = r -> header_in ; if ( body ) { sr -> request_body = body ; rc = ngx_http_lua_set_content_length_header ( sr , body -> buf ? ngx_buf_size ( body -> buf ) : 0 ) ; if ( rc != ngx_ok ) { return ngx_error ; } } else if ( ! always_forward_body && method != ngx_http_put && method != ngx_http_post && r -> headers_in . content_length_n > 0 ) { rc = ngx_http_lua_set_content_length_header ( sr , 0 ) ; if ( rc != ngx_ok ) { return ngx_error ; } # if 1 sr -> request_body = null ; # endif } else { if ( ngx_http_lua_copy_request_headers ( sr , r ) != ngx_ok ) { return ngx_error ; } if ( sr -> request_body ) { if ( sr -> request_body -> temp_file ) { if ( ngx_http_lua_copy_in_file_request_body ( sr ) != ngx_ok ) { return ngx_error ; } } } } sr -> method = method ; switch ( method ) { case ngx_http_get : sr -> method_name = ngx_http_lua_get_method ; break ; case ngx_http_post : sr -> method_name = ngx_http_lua_post_method ; break ; case ngx_http_put : sr -> method_name = ngx_http_lua_put_method ; break ; case ngx_http_head : sr -> method_name = ngx_http_lua_head_method ; break ; case ngx_http_delete : sr -> method_name = ngx_http_lua_delete_method ; break ; case ngx_http_options : sr -> method_name = ngx_http_lua_options_method ; break ; case ngx_http_mkcol : sr -> method_name = ngx_http_lua_mkcol_method ; break ; case ngx_http_copy : sr -> method_name = ngx_http_lua_copy_method ; break ; case ngx_http_move : sr -> method_name = ngx_http_lua_move_method ; break ; case ngx_http_propfind : sr -> method_name = ngx_http_lua_propfind_method ; break ; case ngx_http_proppatch : sr -> method_name = ngx_http_lua_proppatch_method ; break ; case ngx_http_lock : sr -> method_name = ngx_http_lua_lock_method ; break ; case ngx_http_unlock : sr -> method_name = ngx_http_lua_unlock_method ; break ; case ngx_http_patch : sr -> method_name = ngx_http_lua_patch_method ; break ; case ngx_http_trace : sr -> method_name = ngx_http_lua_trace_method ; break ; default : ngx_log_error ( ngx_log_err , r -> connection -> log , 0 , ""unsupported<s2sv_blank>http<s2sv_blank>method:<s2sv_blank>%u"" , ( unsigned ) method ) ; return ngx_error ; } if ( ! ( vars_action & ngx_http_lua_share_all_vars ) ) { cmcf = ngx_http_get_module_main_conf ( sr , ngx_http_core_module ) ; size = cmcf -> variables . nelts * sizeof ( ngx_http_variable_value_t ) ; if ( vars_action & ngx_http_lua_copy_all_vars ) { sr -> variables = ngx_palloc ( sr -> pool , size ) ; if ( sr -> variables == null ) { return ngx_error ; } ngx_memcpy ( sr -> variables , r -> variables , size ) ; } else { sr -> variables = ngx_pcalloc ( sr -> pool , size ) ; if ( sr -> variables == null ) { return ngx_error ; } } } return ngx_http_lua_subrequest_add_extra_vars ( sr , extra_vars ) ; }","<S2SV_ModStart> * r ; <S2SV_ModEnd> ngx_http_core_main_conf_t * cmcf <S2SV_ModStart> * cmcf ; int pr_not_chunked = 0 ; <S2SV_ModStart> = body ; <S2SV_ModEnd> } else if <S2SV_ModStart> 0 ) { sr -> request_body = NULL ; } else { if ( ! r -> headers_in . chunked ) { pr_not_chunked = 1 ; } if ( sr -> request_body && sr -> request_body -> temp_file ) { if ( ngx_http_lua_copy_in_file_request_body ( sr ) <S2SV_ModEnd> != NGX_OK ) <S2SV_ModStart> NGX_ERROR ; } } } <S2SV_ModEnd> if ( ngx_http_lua_copy_request_headers <S2SV_ModStart> sr , r , pr_not_chunked <S2SV_ModStart> return NGX_ERROR ; <S2SV_ModEnd> } sr ->
",openresty@lua-nginx-module/9ab38e8ee35fc08a57636b1b6190dca70b0076fa,CVE-2020-11724,https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa,2020-04-12T21:15Z,"<S2SV_StartBug> ngx_int_t rc ; <S2SV_EndBug> <S2SV_StartBug> size_t size ; <S2SV_EndBug> <S2SV_StartBug> rc = ngx_http_lua_set_content_length_header ( sr , <S2SV_EndBug> <S2SV_StartBug> rc = ngx_http_lua_set_content_length_header ( sr , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> # if 1 <S2SV_EndBug> <S2SV_StartBug> if ( ngx_http_lua_copy_request_headers ( sr , r ) != NGX_OK ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
3665,CWE-125,"static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; if ( g -> sect <= 0 || g -> head <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> fd_sizecode ( g ) ) == 0 || g -> track <= 0 || g -> track > udp -> tracks >> stretch ( g ) || ( g -> stretch & ~ ( fd_stretch | fd_swapsides | fd_sectbasemask ) ) != 0 ) return - einval ; if ( type ) { if ( ! capable ( cap_sys_admin ) ) return - eperm ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - eintr ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = ""user<s2sv_blank>format"" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < n_drive ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || itype ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldstretch ; if ( lock_fdc ( drive ) ) return - eintr ; if ( cmd != fddefprm ) { if ( poll_drive ( true , fd_raw_need_disk ) == - eintr ) return - eintr ; } oldstretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) supbound ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == fddefprm ) drs -> keep_data = - 1 ; else drs -> keep_data = 1 ; if ( drs -> maxblock > user_params [ drive ] . sect || drs -> maxtrack || ( ( user_params [ drive ] . sect ^ oldstretch ) & ( fd_swapsides | fd_sectbasemask ) ) ) invalidate_drive ( bdev ) ; else process_fd_request ( ) ; } return 0 ; }","<S2SV_ModStart> ; if ( ( int ) <S2SV_ModStart> <= 0 || ( int ) <S2SV_ModStart> g -> head <= 0 || ( int ) ( g -> sect * g -> head )
",torvalds@linux/da99466ac243f15fbba65bd261bfc75ffa1532b6,CVE-2019-14283,https://github.com/torvalds/linux/commit/da99466ac243f15fbba65bd261bfc75ffa1532b6,2019-07-26T13:15Z,<S2SV_StartBug> if ( g -> sect <= 0 || <S2SV_EndBug> <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug>
4510,CWE-125,"node * ta3parser_parsestringobject ( const char * s , pyobject * filename , grammar * g , int start , perrdetail * err_ret , int * flags ) { struct tok_state * tok ; int exec_input = start == file_input ; if ( initerr ( err_ret , filename ) < 0 ) return null ; if ( * flags & pyparse_ignore_cookie ) tok = ta3tokenizer_fromutf8 ( s , exec_input ) ; else tok = ta3tokenizer_fromstring ( s , exec_input ) ; if ( tok == null ) { err_ret -> error = pyerr_occurred ( ) ? e_decode : e_nomem ; return null ; } # ifndef pgen py_incref ( err_ret -> filename ) ; tok -> filename = err_ret -> filename ; # endif return parsetok ( tok , g , start , err_ret , flags ) ; }","<S2SV_ModStart> ; # endif if ( * flags & PyPARSE_ASYNC_ALWAYS ) tok -> async_always = 1 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> return parsetok ( tok , g , start , err_ret , flags ) ; <S2SV_EndBug>"
6424,CWE-000,"int fdt_find_regions ( const void * fdt , char * const inc [ ] , int inc_count , char * const exc_prop [ ] , int exc_prop_count , struct fdt_region region [ ] , int max_regions , char * path , int path_len , int add_string_tab ) { int stack [ fdt_max_depth ] = { 0 } ; char * end ; int nextoffset = 0 ; uint32_t tag ; int count = 0 ; int start = - 1 ; int depth = - 1 ; int want = 0 ; int base = fdt_off_dt_struct ( fdt ) ; end = path ; * end = '\\0' ; do { const struct fdt_property * prop ; const char * name ; const char * str ; int include = 0 ; int stop_at = 0 ; int offset ; int len ; offset = nextoffset ; tag = fdt_next_tag ( fdt , offset , & nextoffset ) ; stop_at = nextoffset ; switch ( tag ) { case fdt_prop : include = want >= 2 ; stop_at = offset ; prop = fdt_get_property_by_offset ( fdt , offset , null ) ; str = fdt_string ( fdt , fdt32_to_cpu ( prop -> nameoff ) ) ; if ( ! str ) return - fdt_err_badstructure ; if ( str_in_list ( str , exc_prop , exc_prop_count ) ) include = 0 ; break ; case fdt_nop : include = want >= 2 ; stop_at = offset ; break ; case fdt_begin_node : depth ++ ; if ( depth == fdt_max_depth ) return - fdt_err_badstructure ; name = fdt_get_name ( fdt , offset , & len ) ; if ( end - path + 2 + len >= path_len ) return - fdt_err_nospace ; if ( end != path + 1 ) * end ++ = '/' ; strcpy ( end , name ) ; end += len ; stack [ depth ] = want ; if ( want == 1 ) stop_at = offset ; if ( str_in_list ( path , inc , inc_count ) ) want = 2 ; else if ( want ) want -- ; else stop_at = offset ; include = want ; break ; case fdt_end_node : if ( depth < 0 ) return - fdt_err_badstructure ; include = want ; want = stack [ depth -- ] ; while ( end > path && * -- end != '/' ) ; * end = '\\0' ; break ; case fdt_end : include = 1 ; break ; } if ( include && start == - 1 ) { if ( count && count <= max_regions && offset == region [ count - 1 ] . offset + region [ count - 1 ] . size - base ) start = region [ -- count ] . offset - base ; else start = offset ; } if ( ! include && start != - 1 ) { if ( count < max_regions ) { region [ count ] . offset = base + start ; region [ count ] . size = stop_at - start ; } count ++ ; start = - 1 ; } } while ( tag != fdt_end ) ; if ( nextoffset != fdt_size_dt_struct ( fdt ) ) return - fdt_err_badlayout ; if ( count < max_regions ) { region [ count ] . offset = base + start ; region [ count ] . size = nextoffset - start ; if ( add_string_tab ) region [ count ] . size += fdt_size_dt_strings ( fdt ) ; } count ++ ; return count ; }","<S2SV_ModStart> fdt ) ; bool expect_end = false ; <S2SV_ModStart> = nextoffset ; if ( expect_end && tag != FDT_END ) return - FDT_ERR_BADLAYOUT ; <S2SV_ModStart> & len ) ; if ( ! depth && * name ) return - FDT_ERR_BADLAYOUT <S2SV_ModStart> = '\\0' ; if ( depth == - 1 ) expect_end = true ;
",u-boot@u-boot/8a7d4cf9820ea16fabd25a6379351b4dc291204b,CVE-2021-27097,https://github.com/u-boot/u-boot/commit/8a7d4cf9820ea16fabd25a6379351b4dc291204b,2021-02-17T23:15Z,"<S2SV_StartBug> end = path ; <S2SV_EndBug> <S2SV_StartBug> switch ( tag ) { <S2SV_EndBug> <S2SV_StartBug> name = fdt_get_name ( fdt , offset , & len ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug>"
116,CWE-285,"static int __ext4_set_acl ( handle_t * handle , struct inode * inode , int type , struct posix_acl * acl ) { int name_index ; void * value = null ; size_t size = 0 ; int error ; switch ( type ) { case acl_type_access : name_index = ext4_xattr_index_posix_acl_access ; if ( acl ) { error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; if ( error < 0 ) return error ; else { inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; if ( error == 0 ) acl = null ; } } break ; case acl_type_default : name_index = ext4_xattr_index_posix_acl_default ; if ( ! s_isdir ( inode -> i_mode ) ) return acl ? - eacces : 0 ; break ; default : return - einval ; } if ( acl ) { value = ext4_acl_to_disk ( acl , & size ) ; if ( is_err ( value ) ) return ( int ) ptr_err ( value ) ; } error = ext4_xattr_set_handle ( handle , inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug>"
143,CWE-189,"static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( sprn_pmc5 ) , mfspr ( sprn_pmc6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; if ( ( int ) val < 0 ) write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }","<S2SV_ModStart> ; if ( pmc_overflow ( val ) <S2SV_ModEnd> ) write_pmc (
",torvalds@linux/0837e3242c73566fc1c0196b4ec61779c25ffc93,CVE-2011-4611,https://github.com/torvalds/linux/commit/0837e3242c73566fc1c0196b4ec61779c25ffc93,2012-05-17T11:00Z,<S2SV_StartBug> if ( ( int ) val < 0 ) <S2SV_EndBug>
456,CWE-189,"static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ nfs4acl_maxpages ] = { null , } ; struct nfs_getaclargs args = { . fh = nfs_fh ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ nfsproc4_clnt_getacl ] , . rpc_argp = & args , . rpc_resp = & res , } ; int ret = - enomem , npages , i , acl_len = 0 ; npages = ( buflen + page_size - 1 ) >> page_shift ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( gfp_kernel ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { res . acl_scratch = alloc_page ( gfp_kernel ) ; if ( ! res . acl_scratch ) goto out_free ; } args . acl_len = npages * page_size ; args . acl_pgbase = 0 ; if ( buf == null ) res . acl_flags |= nfs4_acl_len_request ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( ""%s<s2sv_blank><s2sv_blank>buf<s2sv_blank>%p<s2sv_blank>buflen<s2sv_blank>%zu<s2sv_blank>npages<s2sv_blank>%d<s2sv_blank>args.acl_len<s2sv_blank>%zu\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( nfs_server ( inode ) -> client , nfs_server ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , null , acl_len ) ; else nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , acl_len ) ; if ( buf ) { ret = - erange ; if ( acl_len > buflen ) goto out_free ; _copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ; } ret = acl_len ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ; if ( res . acl_scratch ) __free_page ( res . acl_scratch ) ; return ret ; }","<S2SV_ModStart> . acl_data_offset , <S2SV_ModEnd> acl_len ) ;
",torvalds@linux/20e0fa98b751facf9a1101edaefbc19c82616a68,CVE-2012-2375,https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68,2012-06-13T10:24Z,<S2SV_StartBug> res . acl_len ) ; <S2SV_EndBug>
5479,CWE-416,"static void ext4_clamp_want_extra_isize ( struct super_block * sb ) { struct ext4_sb_info * sbi = ext4_sb ( sb ) ; struct ext4_super_block * es = sbi -> s_es ; if ( sbi -> s_inode_size > ext4_good_old_inode_size && sbi -> s_want_extra_isize == 0 ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - ext4_good_old_inode_size ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( ext4_good_old_inode_size + sbi -> s_want_extra_isize > sbi -> s_inode_size ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - ext4_good_old_inode_size ; ext4_msg ( sb , kern_info , ""required<s2sv_blank>extra<s2sv_blank>inode<s2sv_blank>space<s2sv_blank>not<s2sv_blank>available"" ) ; } }","<S2SV_ModStart> -> s_es ; unsigned def_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; <S2SV_ModStart> sbi -> s_inode_size == EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = 0 ; return ; } if ( sbi -> s_want_extra_isize < 4 ) { sbi -> s_want_extra_isize = def_extra_isize ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( ( sbi -> s_want_extra_isize > sbi -> s_inode_size ) || <S2SV_ModEnd> ( EXT4_GOOD_OLD_INODE_SIZE + <S2SV_ModStart> -> s_inode_size ) ) { sbi -> s_want_extra_isize = def_extra_isize <S2SV_ModEnd> ; ext4_msg (
",torvalds@linux/4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a,CVE-2019-19767,https://github.com/torvalds/linux/commit/4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a,2019-12-12T20:15Z,<S2SV_StartBug> if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE && <S2SV_EndBug> <S2SV_StartBug> sbi -> s_inode_size ) { <S2SV_EndBug>
6588,CWE-20,"void settransfermatrix ( double x11 , double x12 , double x21 , double x22 , double x , double y ) { if ( ( fabs ( x11 - 1. ) > 0.001 ) || ( fabs ( x22 - 1. ) > 0.001 ) || ( fabs ( x12 ) > 0.001 ) || ( fabs ( x21 ) > 0.001 ) || ( fabs ( x ) > 0.001 ) || ( fabs ( y ) > 0.001 ) ) { outpos += sprintf ( outpos , ""%12.3f<s2sv_blank>%12.3f<s2sv_blank>%12.3f<s2sv_blank>%12.3f<s2sv_blank>%12.3f<s2sv_blank>%12.3f<s2sv_blank>cm\\n"" , x11 , x12 , x21 , x22 , x , y ) ; } }","<S2SV_ModStart> ) ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , <S2SV_ModStart> y ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
6927,CWE-400,"int do_mathemu ( struct pt_regs * regs , struct task_struct * fpt ) { int i ; int retcode = 0 ; unsigned long insn ; perf_sw_event ( perf_count_sw_emulation_faults , 1 , 0 , regs , 0 ) ; # ifdef debug_mathemu printk ( ""in<s2sv_blank>do_mathemu()...<s2sv_blank>pc<s2sv_blank>is<s2sv_blank>%08lx\\n"" , regs -> pc ) ; printk ( ""fpqdepth<s2sv_blank>is<s2sv_blank>%ld\\n"" , fpt -> thread . fpqdepth ) ; for ( i = 0 ; i < fpt -> thread . fpqdepth ; i ++ ) printk ( ""%d:<s2sv_blank>%08lx<s2sv_blank>at<s2sv_blank>%08lx\\n"" , i , fpt -> thread . fpqueue [ i ] . insn , ( unsigned long ) fpt -> thread . fpqueue [ i ] . insn_addr ) ; # endif if ( fpt -> thread . fpqdepth == 0 ) { # ifdef debug_mathemu printk ( ""precise<s2sv_blank>trap<s2sv_blank>at<s2sv_blank>%08lx\\n"" , regs -> pc ) ; # endif if ( ! get_user ( insn , ( u32 __user * ) regs -> pc ) ) { retcode = do_one_mathemu ( insn , & fpt -> thread . fsr , fpt -> thread . float_regs ) ; if ( retcode ) { regs -> pc = regs -> npc ; regs -> npc += 4 ; } } return retcode ; } for ( i = 0 ; i < fpt -> thread . fpqdepth ; i ++ ) { retcode = do_one_mathemu ( fpt -> thread . fpqueue [ i ] . insn , & ( fpt -> thread . fsr ) , fpt -> thread . float_regs ) ; if ( ! retcode ) break ; } if ( retcode ) fpt -> thread . fsr &= ~ ( 0x3000 | fsr_cexc_mask ) ; else fpt -> thread . fsr &= ~ 0x3000 ; fpt -> thread . fpqdepth = 0 ; return retcode ; }","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug>"
4766,CWE-787,"gf_err adts_dmx_process ( gf_filter * filter ) { gf_adtsdmxctx * ctx = gf_filter_get_udta ( filter ) ; gf_filterpacket * pck , * dst_pck ; u8 * data , * output ; u8 * start ; u32 pck_size , remain , prev_pck_size ; u64 cts = gf_filter_no_ts ; if ( ! ctx -> duration . num ) adts_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return gf_ok ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> adts_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = null ; return gf_eos ; } } else { return gf_ok ; } } prev_pck_size = ctx -> adts_buffer_size ; if ( pck && ! ctx -> resume_from ) { data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; if ( ! pck_size ) { gf_filter_pid_drop_packet ( ctx -> ipid ) ; return gf_ok ; } if ( ctx -> byte_offset != gf_filter_no_bo ) { u64 byte_offset = gf_filter_pck_get_byte_offset ( pck ) ; if ( ! ctx -> adts_buffer_size ) { ctx -> byte_offset = byte_offset ; } else if ( ctx -> byte_offset + ctx -> adts_buffer_size != byte_offset ) { ctx -> byte_offset = gf_filter_no_bo ; if ( ( byte_offset != gf_filter_no_bo ) && ( byte_offset > ctx -> adts_buffer_size ) ) { ctx -> byte_offset = byte_offset - ctx -> adts_buffer_size ; } } } if ( ctx -> adts_buffer_size + pck_size > ctx -> adts_buffer_alloc ) { ctx -> adts_buffer_alloc = ctx -> adts_buffer_size + pck_size ; ctx -> adts_buffer = gf_realloc ( ctx -> adts_buffer , ctx -> adts_buffer_alloc ) ; } memcpy ( ctx -> adts_buffer + ctx -> adts_buffer_size , data , pck_size ) ; ctx -> adts_buffer_size += pck_size ; } if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } if ( cts == gf_filter_no_ts ) { prev_pck_size = 0 ; } remain = ctx -> adts_buffer_size ; start = ctx -> adts_buffer ; if ( ctx -> resume_from ) { start += ctx -> resume_from - 1 ; remain -= ctx -> resume_from - 1 ; ctx -> resume_from = 0 ; } while ( remain ) { u8 * sync ; u32 sync_pos , size , offset , bytes_to_drop = 0 , nb_blocks_per_frame ; if ( ! ctx -> tag_size && ( remain > 3 ) ) { if ( start [ 0 ] == 'i' && start [ 1 ] == 'd' && start [ 2 ] == '3' ) { if ( remain < 10 ) return gf_ok ; ctx -> tag_size = ( ( start [ 9 ] & 0x7f ) + ( ( start [ 8 ] & 0x7f ) << 7 ) + ( ( start [ 7 ] & 0x7f ) << 14 ) + ( ( start [ 6 ] & 0x7f ) << 21 ) ) ; bytes_to_drop = 10 ; if ( ctx -> id3_buffer_alloc < ctx -> tag_size + 10 ) { ctx -> id3_buffer = gf_realloc ( ctx -> id3_buffer , ctx -> tag_size + 10 ) ; ctx -> id3_buffer_alloc = ctx -> tag_size + 10 ; } memcpy ( ctx -> id3_buffer , start , 10 ) ; ctx -> id3_buffer_size = 10 ; goto drop_byte ; } } if ( ctx -> tag_size ) { if ( ctx -> tag_size > remain ) { bytes_to_drop = remain ; ctx -> tag_size -= remain ; } else { bytes_to_drop = ctx -> tag_size ; ctx -> tag_size = 0 ; } memcpy ( ctx -> id3_buffer + ctx -> id3_buffer_size , start , bytes_to_drop ) ; ctx -> id3_buffer_size += bytes_to_drop ; if ( ! ctx -> tag_size && ctx -> opid ) { id3dmx_flush ( filter , ctx -> id3_buffer , ctx -> id3_buffer_size , ctx -> opid , ctx -> expart ? & ctx -> vpid : null ) ; ctx -> id3_buffer_size = 0 ; } goto drop_byte ; } sync = memchr ( start , 0xff , remain ) ; sync_pos = ( u32 ) ( sync ? sync - start : remain ) ; if ( remain - sync_pos < 7 ) { break ; } if ( ( sync [ 1 ] & 0xf0 ) != 0xf0 ) { gf_log ( ctx -> nb_frames ? gf_log_warning : gf_log_debug , gf_log_parser , ( ""[adtsdmx]<s2sv_blank>invalid<s2sv_blank>adts<s2sv_blank>sync<s2sv_blank>bytes,<s2sv_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } if ( ! ctx -> bs ) { ctx -> bs = gf_bs_new ( sync + 1 , remain - sync_pos - 1 , gf_bitstream_read ) ; } else { gf_bs_reassign_buffer ( ctx -> bs , sync + 1 , remain - sync_pos - 1 ) ; } gf_bs_read_int ( ctx -> bs , 4 ) ; ctx -> hdr . is_mp2 = ( bool ) gf_bs_read_int ( ctx -> bs , 1 ) ; ctx -> hdr . is_mp2 = 0 ; gf_bs_read_int ( ctx -> bs , 2 ) ; ctx -> hdr . no_crc = ( bool ) gf_bs_read_int ( ctx -> bs , 1 ) ; ctx -> hdr . profile = 1 + gf_bs_read_int ( ctx -> bs , 2 ) ; ctx -> hdr . sr_idx = gf_bs_read_int ( ctx -> bs , 4 ) ; gf_bs_read_int ( ctx -> bs , 1 ) ; ctx -> hdr . nb_ch = gf_bs_read_int ( ctx -> bs , 3 ) ; gf_bs_read_int ( ctx -> bs , 4 ) ; ctx -> hdr . frame_size = gf_bs_read_int ( ctx -> bs , 13 ) ; gf_bs_read_int ( ctx -> bs , 11 ) ; nb_blocks_per_frame = gf_bs_read_int ( ctx -> bs , 2 ) ; ctx -> hdr . hdr_size = 7 ; if ( ! ctx -> hdr . no_crc ) { u32 skip ; if ( ! nb_blocks_per_frame ) { skip = 2 ; } else { skip = 2 + 2 * nb_blocks_per_frame ; } ctx -> hdr . hdr_size += skip ; gf_bs_skip_bytes ( ctx -> bs , skip ) ; } if ( ! ctx -> hdr . frame_size || ! gf_m4asamplerates [ ctx -> hdr . sr_idx ] ) { gf_log ( gf_log_debug , gf_log_parser , ( ""[adtsdmx]<s2sv_blank>invalid<s2sv_blank>adts<s2sv_blank>frame<s2sv_blank>header,<s2sv_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } if ( ( nb_blocks_per_frame > 2 ) || ( nb_blocks_per_frame && ctx -> hdr . nb_ch ) ) { gf_log ( gf_log_error , gf_log_parser , ( ""[adtsdmx]<s2sv_blank>unsupported<s2sv_blank>multi-block<s2sv_blank>adts<s2sv_blank>frame<s2sv_blank>header<s2sv_blank>-<s2sv_blank>patch<s2sv_blank>welcome\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } else if ( ! nb_blocks_per_frame ) { if ( ctx -> aacchcfg < 0 ) ctx -> hdr . nb_ch = - ctx -> aacchcfg ; else if ( ! ctx -> hdr . nb_ch ) ctx -> hdr . nb_ch = ctx -> aacchcfg ; if ( ! ctx -> hdr . nb_ch ) { gf_log ( gf_log_warning , gf_log_parser , ( ""[adtsdmx]<s2sv_blank>missing<s2sv_blank>channel<s2sv_blank>configuration<s2sv_blank>in<s2sv_blank>adts<s2sv_blank>frame<s2sv_blank>header,<s2sv_blank>defaulting<s2sv_blank>to<s2sv_blank>stereo<s2sv_blank>-<s2sv_blank>use<s2sv_blank>`--aacchcfg`<s2sv_blank>to<s2sv_blank>force<s2sv_blank>config\\n"" ) ) ; ctx -> hdr . nb_ch = ctx -> aacchcfg = 2 ; } } if ( nb_blocks_per_frame == 2 ) { u32 pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; gf_m4a_parse_program_config_element ( ctx -> bs , & ctx -> acfg ) ; if ( ! ctx -> hdr . no_crc ) gf_bs_skip_bytes ( ctx -> bs , 2 ) ; ctx -> hdr . hdr_size += ( u32 ) gf_bs_get_position ( ctx -> bs ) - pos ; } if ( ctx -> hdr . nb_ch == 7 ) ctx -> hdr . nb_ch = 8 ; if ( ctx -> hdr . frame_size + 1 < remain ) { u32 next_frame = ctx -> hdr . frame_size ; if ( ( sync [ next_frame ] != 0xff ) || ( ( sync [ next_frame + 1 ] & 0xf0 ) != 0xf0 ) ) { gf_log ( ctx -> nb_frames ? gf_log_warning : gf_log_debug , gf_log_parser , ( ""[adtsdmx]<s2sv_blank>invalid<s2sv_blank>next<s2sv_blank>adts<s2sv_blank>frame<s2sv_blank>sync,<s2sv_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } } else if ( pck ) { if ( ctx -> timescale && ! prev_pck_size && ( cts != gf_filter_no_ts ) ) { ctx -> cts = cts ; } break ; } adts_dmx_check_pid ( filter , ctx ) ; if ( ! ctx -> is_playing ) { ctx -> resume_from = 1 + ctx -> adts_buffer_size - remain ; return gf_ok ; } ctx -> nb_frames ++ ; size = ctx -> hdr . frame_size - ctx -> hdr . hdr_size ; offset = ctx -> hdr . hdr_size ; if ( ( nb_blocks_per_frame == 2 ) && ! ctx -> hdr . no_crc ) size -= 2 ; if ( ctx -> in_seek ) { u64 nb_samples_at_seek = ( u64 ) ( ctx -> start_range * gf_m4asamplerates [ ctx -> sr_idx ] ) ; if ( ctx -> cts + ctx -> dts_inc >= nb_samples_at_seek ) { ctx -> in_seek = gf_false ; } } bytes_to_drop = ctx -> hdr . frame_size ; if ( ctx -> timescale && ! prev_pck_size && ( cts != gf_filter_no_ts ) ) { ctx -> cts = cts ; cts = gf_filter_no_ts ; } if ( ! ctx -> in_seek ) { dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; memcpy ( output , sync + offset , size ) ; gf_filter_pck_set_dts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_duration ( dst_pck , ctx -> dts_inc ) ; gf_filter_pck_set_framing ( dst_pck , gf_true , gf_true ) ; gf_filter_pck_set_sap ( dst_pck , gf_filter_sap_1 ) ; if ( ctx -> byte_offset != gf_filter_no_bo ) { gf_filter_pck_set_byte_offset ( dst_pck , ctx -> byte_offset + ctx -> hdr . hdr_size ) ; } gf_filter_pck_send ( dst_pck ) ; } adts_dmx_update_cts ( ctx ) ; if ( bytes_to_drop > remain ) { gf_log ( gf_log_warning , gf_log_parser , ( ""[adtsdmx]<s2sv_blank>truncated<s2sv_blank>adts<s2sv_blank>frame!\\n"" ) ) ; bytes_to_drop = remain ; } drop_byte : if ( ! bytes_to_drop ) { bytes_to_drop = 1 ; } start += bytes_to_drop ; remain -= bytes_to_drop ; if ( prev_pck_size ) { if ( prev_pck_size > bytes_to_drop ) prev_pck_size -= bytes_to_drop ; else { prev_pck_size = 0 ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = pck ; if ( pck ) gf_filter_pck_ref_props ( & ctx -> src_pck ) ; } } if ( ctx -> byte_offset != gf_filter_no_bo ) ctx -> byte_offset += bytes_to_drop ; } if ( ! pck ) { ctx -> adts_buffer_size = 0 ; return adts_dmx_process ( filter ) ; } else { if ( remain ) { memmove ( ctx -> adts_buffer , start , remain ) ; } ctx -> adts_buffer_size = remain ; gf_filter_pid_drop_packet ( ctx -> ipid ) ; } return gf_ok ; }","<S2SV_ModStart> break ; } if ( ctx -> hdr . frame_size < ctx -> hdr . hdr_size ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>Corrupted<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header,<S2SV_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; }
",gpac@gpac/22774aa9e62f586319c8f107f5bae950fed900bc,CVE-2021-30019,https://github.com/gpac/gpac/commit/22774aa9e62f586319c8f107f5bae950fed900bc,2021-04-19T20:15Z,"<S2SV_StartBug> adts_dmx_check_pid ( filter , ctx ) ; <S2SV_EndBug>"
7084,CWE-787,"static void insertrow ( image * image , unsigned char * p , ssize_t y , int bpp , exceptioninfo * exception ) { int bit ; quantum index ; register quantum * q ; ssize_t x ; switch ( bpp ) { case 1 : { q = queueauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += getpixelchannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += getpixelchannels ( image ) ; } p ++ ; } if ( ! syncauthenticpixels ( image , exception ) ) break ; break ; } case 2 : { q = queueauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = constraincolormapindex ( image , ( * p >> 6 ) & 0x3 , exception ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += getpixelchannels ( image ) ; index = constraincolormapindex ( image , ( * p >> 4 ) & 0x3 , exception ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += getpixelchannels ( image ) ; index = constraincolormapindex ( image , ( * p >> 2 ) & 0x3 , exception ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += getpixelchannels ( image ) ; index = constraincolormapindex ( image , ( * p ) & 0x3 , exception ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += getpixelchannels ( image ) ; } if ( ( image -> columns % 4 ) != 0 ) { index = constraincolormapindex ( image , ( * p >> 6 ) & 0x3 , exception ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += getpixelchannels ( image ) ; if ( ( image -> columns % 4 ) >= 1 ) { index = constraincolormapindex ( image , ( * p >> 4 ) & 0x3 , exception ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += getpixelchannels ( image ) ; if ( ( image -> columns % 4 ) >= 2 ) { index = constraincolormapindex ( image , ( * p >> 2 ) & 0x3 , exception ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += getpixelchannels ( image ) ; } } p ++ ; } if ( syncauthenticpixels ( image , exception ) == magickfalse ) break ; break ; } case 4 : { q = queueauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = constraincolormapindex ( image , ( * p >> 4 ) & 0x0f , exception ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += getpixelchannels ( image ) ; index = constraincolormapindex ( image , ( * p ) & 0x0f , exception ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += getpixelchannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) { index = constraincolormapindex ( image , ( * p >> 4 ) & 0x0f , exception ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += getpixelchannels ( image ) ; } if ( syncauthenticpixels ( image , exception ) == magickfalse ) break ; break ; } case 8 : { q = queueauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = constraincolormapindex ( image , * p , exception ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += getpixelchannels ( image ) ; } if ( syncauthenticpixels ( image , exception ) == magickfalse ) break ; } break ; case 24 : q = queueauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { setpixelred ( image , scalechartoquantum ( * p ++ ) , q ) ; setpixelgreen ( image , scalechartoquantum ( * p ++ ) , q ) ; setpixelblue ( image , scalechartoquantum ( * p ++ ) , q ) ; q += getpixelchannels ( image ) ; } if ( ! syncauthenticpixels ( image , exception ) ) break ; break ; } }","<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index
",ImageMagick@ImageMagick/b60d1ed0af37c50b91a40937825b4c61e8458095,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/b60d1ed0af37c50b91a40937825b4c61e8458095,2017-04-20T18:59Z,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug>
6806,CWE-476,"static int cit_get_packet_size ( struct gspca_dev * gspca_dev ) { struct usb_host_interface * alt ; struct usb_interface * intf ; intf = usb_ifnum_to_if ( gspca_dev -> dev , gspca_dev -> iface ) ; alt = usb_altnum_to_altsetting ( intf , gspca_dev -> alt ) ; if ( ! alt ) { pr_err ( ""couldn\'t<s2sv_blank>get<s2sv_blank>altsetting\\n"" ) ; return - eio ; } return le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wmaxpacketsize ) ; }","<S2SV_ModStart> EIO ; } if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;
",torvalds@linux/a246b4d547708f33ff4d4b9a7a5dbac741dc89d8,CVE-2020-11668,https://github.com/torvalds/linux/commit/a246b4d547708f33ff4d4b9a7a5dbac741dc89d8,2020-04-09T21:15Z,<S2SV_StartBug> return le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug>
4245,CWE-401,"struct clock_source * dce110_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , gfp_kernel ) ; if ( ! clk_src ) return null ; if ( dce110_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } break_to_debugger ( ) ; return null ; }","<S2SV_ModStart> base ; } kfree ( clk_src ) ;
",torvalds@linux/055e547478a11a6360c7ce05e2afc3e366968a12,CVE-2019-19083,https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12,2019-11-18T06:15Z,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug>
3158,CWE-20,void exit_io_context ( void ) { struct io_context * ioc ; task_lock ( current ) ; ioc = current -> io_context ; current -> io_context = null ; task_unlock ( current ) ; if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; },"<S2SV_ModStart> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; ioc <S2SV_ModStart> ; ioc = task <S2SV_ModEnd> -> io_context ; <S2SV_ModStart> -> io_context ; task <S2SV_ModEnd> -> io_context = <S2SV_ModStart> ; task_unlock ( task <S2SV_ModEnd> ) ; if
",torvalds@linux/b69f2292063d2caf37ca9aec7d63ded203701bf3,CVE-2012-0879,https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3,2012-05-17T11:00Z,<S2SV_StartBug> void exit_io_context ( void ) <S2SV_EndBug> <S2SV_StartBug> task_lock ( current ) ; <S2SV_EndBug> <S2SV_StartBug> ioc = current -> io_context ; <S2SV_EndBug> <S2SV_StartBug> current -> io_context = NULL ; <S2SV_EndBug> <S2SV_StartBug> task_unlock ( current ) ; <S2SV_EndBug>
8300,CWE-20,"static int x25_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct x25_sock * x25 = x25_sk ( sk ) ; struct sockaddr_x25 * sx25 = ( struct sockaddr_x25 * ) msg -> msg_name ; size_t copied ; int qbit , header_len ; struct sk_buff * skb ; unsigned char * asmptr ; int rc = - enotconn ; lock_sock ( sk ) ; if ( x25 -> neighbour == null ) goto out ; header_len = x25 -> neighbour -> extended ? x25_ext_min_len : x25_std_min_len ; if ( sk -> sk_state != tcp_established ) goto out ; if ( flags & msg_oob ) { rc = - einval ; if ( sock_flag ( sk , sock_urginline ) || ! skb_peek ( & x25 -> interrupt_in_queue ) ) goto out ; skb = skb_dequeue ( & x25 -> interrupt_in_queue ) ; if ( ! pskb_may_pull ( skb , x25_std_min_len ) ) goto out_free_dgram ; skb_pull ( skb , x25_std_min_len ) ; if ( test_bit ( x25_q_bit_flag , & x25 -> flags ) ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = 0x00 ; } msg -> msg_flags |= msg_oob ; } else { release_sock ( sk ) ; skb = skb_recv_datagram ( sk , flags & ~ msg_dontwait , flags & msg_dontwait , & rc ) ; lock_sock ( sk ) ; if ( ! skb ) goto out ; if ( ! pskb_may_pull ( skb , header_len ) ) goto out_free_dgram ; qbit = ( skb -> data [ 0 ] & x25_q_bit ) == x25_q_bit ; skb_pull ( skb , header_len ) ; if ( test_bit ( x25_q_bit_flag , & x25 -> flags ) ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= msg_trunc ; } msg -> msg_flags |= msg_eor ; rc = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( rc ) goto out_free_dgram ; if ( sx25 ) { sx25 -> sx25_family = af_x25 ; sx25 -> sx25_addr = x25 -> dest_addr ; } msg -> msg_namelen = sizeof ( struct sockaddr_x25 ) ; x25_check_rbuf ( sk ) ; rc = copied ; out_free_dgram : skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return rc ; }","<S2SV_ModStart> -> dest_addr ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> = sizeof ( * sx25 ) ; } <S2SV_ModEnd> x25_check_rbuf ( sk
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = sizeof ( struct sockaddr_x25 ) ; <S2SV_EndBug>
714,CWE-416,"static int l2tp_ip6_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_l2tpip6 * addr = ( struct sockaddr_l2tpip6 * ) uaddr ; struct net * net = sock_net ( sk ) ; __be32 v4addr = 0 ; int addr_type ; int err ; if ( ! sock_flag ( sk , sock_zapped ) ) return - einval ; if ( addr -> l2tp_family != af_inet6 ) return - einval ; if ( addr_len < sizeof ( * addr ) ) return - einval ; addr_type = ipv6_addr_type ( & addr -> l2tp_addr ) ; if ( addr_type == ipv6_addr_mapped ) return - eaddrnotavail ; if ( addr_type & ipv6_addr_multicast ) return - eaddrnotavail ; err = - eaddrinuse ; read_lock_bh ( & l2tp_ip6_lock ) ; if ( __l2tp_ip6_bind_lookup ( net , & addr -> l2tp_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip6_lock ) ; lock_sock ( sk ) ; err = - einval ; if ( sk -> sk_state != tcp_close ) goto out_unlock ; rcu_read_lock ( ) ; if ( addr_type != ipv6_addr_any ) { struct net_device * dev = null ; if ( addr_type & ipv6_addr_linklocal ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && addr -> l2tp_scope_id ) { sk -> sk_bound_dev_if = addr -> l2tp_scope_id ; } if ( ! sk -> sk_bound_dev_if ) goto out_unlock_rcu ; err = - enodev ; dev = dev_get_by_index_rcu ( sock_net ( sk ) , sk -> sk_bound_dev_if ) ; if ( ! dev ) goto out_unlock_rcu ; } v4addr = loopback4_ipv6 ; err = - eaddrnotavail ; if ( ! ipv6_chk_addr ( sock_net ( sk ) , & addr -> l2tp_addr , dev , 0 ) ) goto out_unlock_rcu ; } rcu_read_unlock ( ) ; inet -> inet_rcv_saddr = inet -> inet_saddr = v4addr ; sk -> sk_v6_rcv_saddr = addr -> l2tp_addr ; np -> saddr = addr -> l2tp_addr ; l2tp_ip6_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip6_lock ) ; sk_add_bind_node ( sk , & l2tp_ip6_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip6_lock ) ; sock_reset_flag ( sk , sock_zapped ) ; release_sock ( sk ) ; return 0 ; out_unlock_rcu : rcu_read_unlock ( ) ; out_unlock : release_sock ( sk ) ; return err ; out_in_use : read_unlock_bh ( & l2tp_ip6_lock ) ; return err ; }","<S2SV_ModStart> ; if ( <S2SV_ModEnd> addr -> l2tp_family <S2SV_ModStart> ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ; if (
",torvalds@linux/32c231164b762dddefa13af5a0101032c70b50ef,CVE-2016-10200,https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef,2017-03-07T21:59Z,"<S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> <S2SV_StartBug> if ( sk -> sk_state != TCP_CLOSE ) <S2SV_EndBug>"
3194,CWE-119,"static int zerocopy_sg_from_iovec ( struct sk_buff * skb , const struct iovec * from , int offset , size_t count ) { int len = iov_length ( from , count ) - offset ; int copy = skb_headlen ( skb ) ; int size , offset1 = 0 ; int i = 0 ; while ( count && ( offset >= from -> iov_len ) ) { offset -= from -> iov_len ; ++ from ; -- count ; } while ( count && ( copy > 0 ) ) { size = min_t ( unsigned int , copy , from -> iov_len - offset ) ; if ( copy_from_user ( skb -> data + offset1 , from -> iov_base + offset , size ) ) return - efault ; if ( copy > size ) { ++ from ; -- count ; offset = 0 ; } else offset += size ; copy -= size ; offset1 += size ; } if ( len == offset1 ) return 0 ; while ( count -- ) { struct page * page [ max_skb_frags ] ; int num_pages ; unsigned long base ; unsigned long truesize ; len = from -> iov_len - offset ; if ( ! len ) { offset = 0 ; ++ from ; continue ; } base = ( unsigned long ) from -> iov_base + offset ; size = ( ( base & ~ page_mask ) + len + ~ page_mask ) >> page_shift ; num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; if ( ( num_pages != size ) || ( num_pages > max_skb_frags - skb_shinfo ( skb ) -> nr_frags ) ) { for ( i = 0 ; i < num_pages ; i ++ ) put_page ( page [ i ] ) ; return - efault ; } truesize = size * page_size ; skb -> data_len += len ; skb -> len += len ; skb -> truesize += truesize ; atomic_add ( truesize , & skb -> sk -> sk_wmem_alloc ) ; while ( len ) { int off = base & ~ page_mask ; int size = min_t ( int , len , page_size - off ) ; __skb_fill_page_desc ( skb , i , page [ i ] , off , size ) ; skb_shinfo ( skb ) -> nr_frags ++ ; base += size ; len -= size ; i ++ ; } offset = 0 ; ++ from ; } return 0 ; }","<S2SV_ModStart> >> PAGE_SHIFT ; if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> num_pages != size <S2SV_ModStart> num_pages != size <S2SV_ModEnd> ) { for
",torvalds@linux/b92946e2919134ebe2a4083e4302236295ea2a73,CVE-2012-2119,https://github.com/torvalds/linux/commit/b92946e2919134ebe2a4083e4302236295ea2a73,2013-01-22T23:55Z,"<S2SV_StartBug> num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( num_pages != size ) || <S2SV_EndBug>"
6882,CWE-74,"static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , gkeyfile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , gcancellable * cancellable , gerror * * error ) { gboolean ret = false ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( ""export-desktop-xxxxxx"" ) ; g_autoptr ( goutputstream ) out_stream = null ; g_autofree gchar * data = null ; gsize data_len ; g_autofree gchar * new_data = null ; gsize new_data_len ; g_autoptr ( gkeyfile ) keyfile = null ; g_autofree gchar * old_exec = null ; gint old_argc ; g_auto ( gstrv ) old_argv = null ; g_auto ( gstrv ) groups = null ; gstring * new_exec = null ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , g_key_file_keep_translations , error ) ) goto out ; if ( g_str_has_suffix ( name , "".service"" ) ) { g_autofree gchar * dbus_name = null ; g_autofree gchar * expected_dbus_name = g_strndup ( name , strlen ( name ) - strlen ( "".service"" ) ) ; dbus_name = g_key_file_get_string ( keyfile , ""d-bus<s2sv_blank>service"" , ""name"" , null ) ; if ( dbus_name == null || strcmp ( dbus_name , expected_dbus_name ) != 0 ) { return flatpak_fail_error ( error , flatpak_error_export_failed , _ ( ""d-bus<s2sv_blank>service<s2sv_blank>file<s2sv_blank>\'%s\'<s2sv_blank>has<s2sv_blank>wrong<s2sv_blank>name"" ) , name ) ; } } if ( g_str_has_suffix ( name , "".desktop"" ) ) { gsize length ; g_auto ( gstrv ) tags = g_key_file_get_string_list ( metadata , ""application"" , ""tags"" , & length , null ) ; if ( tags != null ) { g_key_file_set_string_list ( keyfile , g_key_file_desktop_group , ""x-flatpak-tags"" , ( const char * const * ) tags , length ) ; } g_key_file_set_string ( keyfile , g_key_file_desktop_group , ""x-flatpak"" , app ) ; if ( previous_ids != null ) { const char * x_flatpak_renamed_from = ""x-flatpak-renamedfrom"" ; g_auto ( gstrv ) renamed_from = g_key_file_get_string_list ( keyfile , g_key_file_desktop_group , x_flatpak_renamed_from , null , null ) ; g_autoptr ( gptrarray ) merged = g_ptr_array_new_with_free_func ( g_free ) ; g_autoptr ( ghashtable ) seen = g_hash_table_new ( g_str_hash , g_str_equal ) ; const char * new_suffix ; for ( i = 0 ; renamed_from != null && renamed_from [ i ] != null ; i ++ ) { if ( ! g_hash_table_contains ( seen , renamed_from [ i ] ) ) { gchar * copy = g_strdup ( renamed_from [ i ] ) ; g_hash_table_insert ( seen , copy , copy ) ; g_ptr_array_add ( merged , g_steal_pointer ( & copy ) ) ; } } g_assert ( g_str_has_prefix ( name , app ) ) ; new_suffix = name + strlen ( app ) ; for ( i = 0 ; previous_ids [ i ] != null ; i ++ ) { g_autofree gchar * previous_desktop = g_strconcat ( previous_ids [ i ] , new_suffix , null ) ; if ( ! g_hash_table_contains ( seen , previous_desktop ) ) { g_hash_table_insert ( seen , previous_desktop , previous_desktop ) ; g_ptr_array_add ( merged , g_steal_pointer ( & previous_desktop ) ) ; } } if ( merged -> len > 0 ) { g_ptr_array_add ( merged , null ) ; g_key_file_set_string_list ( keyfile , g_key_file_desktop_group , x_flatpak_renamed_from , ( const char * const * ) merged -> pdata , merged -> len - 1 ) ; } } } groups = g_key_file_get_groups ( keyfile , null ) ; for ( i = 0 ; groups [ i ] != null ; i ++ ) { g_auto ( gstrv ) flatpak_run_opts = g_key_file_get_string_list ( keyfile , groups [ i ] , ""x-flatpak-runoptions"" , null , null ) ; g_autofree char * flatpak_run_args = format_flatpak_run_args_from_run_opts ( flatpak_run_opts ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""x-flatpak-runoptions"" , null ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""tryexec"" , null ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""x-gnome-bugzilla-extrainfoscript"" , null ) ; new_exec = g_string_new ( """" ) ; g_string_append_printf ( new_exec , flatpak_bindir ""/flatpak<s2sv_blank>run<s2sv_blank>--branch=%s<s2sv_blank>--arch=%s"" , escaped_branch , escaped_arch ) ; if ( flatpak_run_args != null ) g_string_append_printf ( new_exec , ""%s"" , flatpak_run_args ) ; old_exec = g_key_file_get_string ( keyfile , groups [ i ] , ""exec"" , null ) ; if ( old_exec && g_shell_parse_argv ( old_exec , & old_argc , & old_argv , null ) && old_argc >= 1 ) { int j ; g_autofree char * command = maybe_quote ( old_argv [ 0 ] ) ; g_string_append_printf ( new_exec , ""<s2sv_blank>--command=%s"" , command ) ; for ( j = 1 ; j < old_argc ; j ++ ) { if ( strcasecmp ( old_argv [ j ] , ""%f"" ) == 0 || strcasecmp ( old_argv [ j ] , ""%u"" ) == 0 ) { g_string_append ( new_exec , ""<s2sv_blank>--file-forwarding"" ) ; break ; } } g_string_append ( new_exec , ""<s2sv_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; for ( j = 1 ; j < old_argc ; j ++ ) { g_autofree char * arg = maybe_quote ( old_argv [ j ] ) ; if ( strcasecmp ( arg , ""%f"" ) == 0 ) g_string_append_printf ( new_exec , ""<s2sv_blank>@@<s2sv_blank>%s<s2sv_blank>@@"" , arg ) ; else if ( strcasecmp ( arg , ""%u"" ) == 0 ) g_string_append_printf ( new_exec , ""<s2sv_blank>@@u<s2sv_blank>%s<s2sv_blank>@@"" , arg ) ; else if ( g_str_has_prefix ( arg , ""@@"" ) ) g_print ( _ ( ""skipping<s2sv_blank>invalid<s2sv_blank>exec<s2sv_blank>argument<s2sv_blank>%s\\n"" ) , arg ) ; else g_string_append_printf ( new_exec , ""<s2sv_blank>%s"" , arg ) ; } } else { g_string_append ( new_exec , ""<s2sv_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; } g_key_file_set_string ( keyfile , groups [ i ] , g_key_file_desktop_key_exec , new_exec -> str ) ; } new_data = g_key_file_to_data ( keyfile , & new_data_len , error ) ; if ( new_data == null ) goto out ; if ( ! flatpak_open_in_tmpdir_at ( parent_fd , 0755 , tmpfile_name , & out_stream , cancellable , error ) ) goto out ; if ( ! g_output_stream_write_all ( out_stream , new_data , new_data_len , null , cancellable , error ) ) goto out ; if ( ! g_output_stream_close ( out_stream , cancellable , error ) ) goto out ; if ( target ) * target = g_steal_pointer ( & tmpfile_name ) ; ret = true ; out : if ( new_exec != null ) g_string_free ( new_exec , true ) ; return ret ; }","<S2SV_ModStart> ""@@"" ) ) { flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""Invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s"" <S2SV_ModEnd> ) , arg <S2SV_ModStart> arg ) ; goto out ; }
",flatpak@flatpak/a7401e638bf0c03102039e216ab1081922f140ae,CVE-2021-21381,https://github.com/flatpak/flatpak/commit/a7401e638bf0c03102039e216ab1081922f140ae,2021-03-11T17:15Z,"<S2SV_StartBug> g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ; <S2SV_EndBug>"
2481,CWE-120,"void mwifiex_set_wmm_params ( struct mwifiex_private * priv , struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { const u8 * vendor_ie ; const u8 * wmm_ie ; u8 wmm_oui [ ] = { 0x00 , 0x50 , 0xf2 , 0x02 } ; vendor_ie = cfg80211_find_vendor_ie ( wlan_oui_microsoft , wlan_oui_type_microsoft_wmm , params -> beacon . tail , params -> beacon . tail_len ) ; if ( vendor_ie ) { wmm_ie = vendor_ie ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; priv -> wmm_enabled = 1 ; } else { memset ( & bss_cfg -> wmm_info , 0 , sizeof ( bss_cfg -> wmm_info ) ) ; memcpy ( & bss_cfg -> wmm_info . oui , wmm_oui , sizeof ( wmm_oui ) ) ; bss_cfg -> wmm_info . subtype = mwifiex_wmm_subtype ; bss_cfg -> wmm_info . version = mwifiex_wmm_version ; priv -> wmm_enabled = 0 ; } bss_cfg -> qos_info = 0x00 ; return ; }","<S2SV_ModStart> = vendor_ie ; if ( <S2SV_ModEnd> * ( wmm_ie <S2SV_ModStart> + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 )
",torvalds@linux/7caac62ed598a196d6ddf8d9c121e12e082cac3a,CVE-2019-14814,https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a,2019-09-20T19:15Z,"<S2SV_StartBug> memcpy ( & bss_cfg -> wmm_info , wmm_ie + <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; <S2SV_EndBug>"
2614,CWE-264,"static int wrmsr_interception ( struct vcpu_svm * svm ) { struct msr_data msr ; u32 ecx = svm -> vcpu . arch . regs [ vcpu_regs_rcx ] ; u64 data = ( svm -> vcpu . arch . regs [ vcpu_regs_rax ] & - 1u ) | ( ( u64 ) ( svm -> vcpu . arch . regs [ vcpu_regs_rdx ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; svm -> next_rip = kvm_rip_read ( & svm -> vcpu ) + 2 ; if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( & svm -> vcpu , 0 ) ; } else { trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( & svm -> vcpu ) ; } return 1 ; }","<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( & svm
",torvalds@linux/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,CVE-2014-3610,https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,2014-11-10T11:55Z,"<S2SV_StartBug> if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { <S2SV_EndBug>"
120,CWE-285,"int jffs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int rc , xprefix ; switch ( type ) { case acl_type_access : xprefix = jffs2_xprefix_acl_access ; if ( acl ) { umode_t mode = inode -> i_mode ; rc = posix_acl_equiv_mode ( acl , & mode ) ; if ( rc < 0 ) return rc ; if ( inode -> i_mode != mode ) { struct iattr attr ; attr . ia_valid = attr_mode | attr_ctime ; attr . ia_mode = mode ; attr . ia_ctime = current_time_sec ; rc = jffs2_do_setattr ( inode , & attr ) ; if ( rc < 0 ) return rc ; } if ( rc == 0 ) acl = null ; } break ; case acl_type_default : xprefix = jffs2_xprefix_acl_default ; if ( ! s_isdir ( inode -> i_mode ) ) return acl ? - eacces : 0 ; break ; default : return - einval ; } rc = __jffs2_set_acl ( inode , xprefix , acl ) ; if ( ! rc ) set_cached_acl ( inode , type , acl ) ; return rc ; }","<S2SV_ModStart> { umode_t mode ; rc = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( rc <S2SV_ModEnd> ) return rc <S2SV_ModStart> rc ; } <S2SV_ModEnd> } break ;
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc == 0 ) <S2SV_EndBug>"
7191,CWE-552,"static long _syscall ( long num , long arg1 , long arg2 , long arg3 , long arg4 , long arg5 , long arg6 ) { long ret = - 1 ; oe_errno = 0 ; switch ( num ) { # if defined ( oe_sys_creat ) case oe_sys_creat : { const char * pathname = ( const char * ) arg1 ; oe_mode_t mode = ( oe_mode_t ) arg2 ; int flags = ( oe_o_creat | oe_o_wronly | oe_o_trunc ) ; ret = oe_open ( pathname , flags , mode ) ; if ( oe_errno == oe_enoent ) { oe_errno = oe_enosys ; goto done ; } goto done ; } # endif # if defined ( oe_sys_open ) case oe_sys_open : { const char * pathname = ( const char * ) arg1 ; int flags = ( int ) arg2 ; uint32_t mode = ( uint32_t ) arg3 ; ret = oe_open ( pathname , flags , mode ) ; if ( ret < 0 && oe_errno == oe_enoent ) goto done ; goto done ; } # endif case oe_sys_openat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; int flags = ( int ) arg3 ; uint32_t mode = ( uint32_t ) arg4 ; if ( dirfd != oe_at_fdcwd ) { oe_errno = oe_ebadf ; goto done ; } ret = oe_open ( pathname , flags , mode ) ; if ( ret < 0 && oe_errno == oe_enoent ) goto done ; goto done ; } case oe_sys_lseek : { int fd = ( int ) arg1 ; ssize_t off = ( ssize_t ) arg2 ; int whence = ( int ) arg3 ; ret = oe_lseek ( fd , off , whence ) ; goto done ; } case oe_sys_pread64 : { const int fd = ( int ) arg1 ; void * const buf = ( void * ) arg2 ; const size_t count = ( size_t ) arg3 ; const oe_off_t offset = ( oe_off_t ) arg4 ; ret = oe_pread ( fd , buf , count , offset ) ; goto done ; } case oe_sys_pwrite64 : { const int fd = ( int ) arg1 ; const void * const buf = ( void * ) arg2 ; const size_t count = ( size_t ) arg3 ; const oe_off_t offset = ( oe_off_t ) arg4 ; ret = oe_pwrite ( fd , buf , count , offset ) ; goto done ; } case oe_sys_readv : { int fd = ( int ) arg1 ; const struct oe_iovec * iov = ( const struct oe_iovec * ) arg2 ; int iovcnt = ( int ) arg3 ; ret = oe_readv ( fd , iov , iovcnt ) ; goto done ; } case oe_sys_writev : { int fd = ( int ) arg1 ; const struct oe_iovec * iov = ( const struct oe_iovec * ) arg2 ; int iovcnt = ( int ) arg3 ; ret = oe_writev ( fd , iov , iovcnt ) ; goto done ; } case oe_sys_read : { int fd = ( int ) arg1 ; void * buf = ( void * ) arg2 ; size_t count = ( size_t ) arg3 ; ret = oe_read ( fd , buf , count ) ; goto done ; } case oe_sys_write : { int fd = ( int ) arg1 ; const void * buf = ( void * ) arg2 ; size_t count = ( size_t ) arg3 ; ret = oe_write ( fd , buf , count ) ; goto done ; } case oe_sys_close : { int fd = ( int ) arg1 ; ret = oe_close ( fd ) ; goto done ; } case oe_sys_dup : { int fd = ( int ) arg1 ; ret = oe_dup ( fd ) ; goto done ; } case oe_sys_flock : { int fd = ( int ) arg1 ; int operation = ( int ) arg2 ; ret = oe_flock ( fd , operation ) ; goto done ; } case oe_sys_fsync : { const int fd = ( int ) arg1 ; ret = oe_fsync ( fd ) ; goto done ; } case oe_sys_fdatasync : { const int fd = ( int ) arg1 ; ret = oe_fdatasync ( fd ) ; goto done ; } # if defined ( oe_sys_dup2 ) case oe_sys_dup2 : { int oldfd = ( int ) arg1 ; int newfd = ( int ) arg2 ; ret = oe_dup2 ( oldfd , newfd ) ; goto done ; } # endif case oe_sys_dup3 : { int oldfd = ( int ) arg1 ; int newfd = ( int ) arg2 ; int flags = ( int ) arg3 ; if ( flags != 0 ) { oe_errno = oe_einval ; goto done ; } ret = oe_dup2 ( oldfd , newfd ) ; goto done ; } # if defined ( oe_sys_stat ) case oe_sys_stat : { const char * pathname = ( const char * ) arg1 ; struct oe_stat_t * buf = ( struct oe_stat_t * ) arg2 ; ret = oe_stat ( pathname , buf ) ; goto done ; } # endif case oe_sys_newfstatat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; struct oe_stat_t * buf = ( struct oe_stat_t * ) arg3 ; int flags = ( int ) arg4 ; if ( dirfd != oe_at_fdcwd ) { oe_errno = oe_ebadf ; goto done ; } if ( flags != 0 ) { oe_errno = oe_einval ; goto done ; } ret = oe_stat ( pathname , buf ) ; goto done ; } case oe_sys_fstat : { const int fd = ( int ) arg1 ; struct oe_stat_t * const buf = ( struct oe_stat_t * ) arg2 ; ret = oe_fstat ( fd , buf ) ; goto done ; } # if defined ( oe_sys_link ) case oe_sys_link : { const char * oldpath = ( const char * ) arg1 ; const char * newpath = ( const char * ) arg2 ; ret = oe_link ( oldpath , newpath ) ; goto done ; } # endif case oe_sys_linkat : { int olddirfd = ( int ) arg1 ; const char * oldpath = ( const char * ) arg2 ; int newdirfd = ( int ) arg3 ; const char * newpath = ( const char * ) arg4 ; int flags = ( int ) arg5 ; if ( olddirfd != oe_at_fdcwd ) { oe_errno = oe_ebadf ; goto done ; } if ( newdirfd != oe_at_fdcwd ) { oe_errno = oe_ebadf ; goto done ; } if ( flags != 0 ) { oe_errno = oe_einval ; goto done ; } ret = oe_link ( oldpath , newpath ) ; goto done ; } # if defined ( oe_sys_unlink ) case oe_sys_unlink : { const char * pathname = ( const char * ) arg1 ; ret = oe_unlink ( pathname ) ; goto done ; } # endif case oe_sys_unlinkat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; int flags = ( int ) arg3 ; if ( dirfd != oe_at_fdcwd ) { oe_errno = oe_ebadf ; goto done ; } if ( flags != oe_at_removedir && flags != 0 ) { oe_errno = oe_einval ; goto done ; } if ( flags == oe_at_removedir ) ret = oe_rmdir ( pathname ) ; else ret = oe_unlink ( pathname ) ; goto done ; } # if defined ( oe_sys_rename ) case oe_sys_rename : { const char * oldpath = ( const char * ) arg1 ; const char * newpath = ( const char * ) arg2 ; ret = oe_rename ( oldpath , newpath ) ; goto done ; } # endif case oe_sys_renameat : { int olddirfd = ( int ) arg1 ; const char * oldpath = ( const char * ) arg2 ; int newdirfd = ( int ) arg3 ; const char * newpath = ( const char * ) arg4 ; int flags = ( int ) arg5 ; if ( olddirfd != oe_at_fdcwd ) { oe_errno = oe_ebadf ; goto done ; } if ( newdirfd != oe_at_fdcwd ) { oe_errno = oe_ebadf ; goto done ; } if ( flags != 0 ) { oe_errno = oe_einval ; goto done ; } ret = oe_rename ( oldpath , newpath ) ; goto done ; } case oe_sys_truncate : { const char * path = ( const char * ) arg1 ; ssize_t length = ( ssize_t ) arg2 ; ret = oe_truncate ( path , length ) ; goto done ; } # if defined ( oe_sys_mkdir ) case oe_sys_mkdir : { const char * pathname = ( const char * ) arg1 ; uint32_t mode = ( uint32_t ) arg2 ; ret = oe_mkdir ( pathname , mode ) ; goto done ; } # endif case oe_sys_mkdirat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; uint32_t mode = ( uint32_t ) arg3 ; if ( dirfd != oe_at_fdcwd ) { oe_errno = oe_ebadf ; goto done ; } ret = oe_mkdir ( pathname , mode ) ; goto done ; } # if defined ( oe_sys_rmdir ) case oe_sys_rmdir : { const char * pathname = ( const char * ) arg1 ; ret = oe_rmdir ( pathname ) ; goto done ; } # endif # if defined ( oe_sys_access ) case oe_sys_access : { const char * pathname = ( const char * ) arg1 ; int mode = ( int ) arg2 ; ret = oe_access ( pathname , mode ) ; goto done ; } # endif case oe_sys_faccessat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; int mode = ( int ) arg3 ; int flags = ( int ) arg4 ; if ( dirfd != oe_at_fdcwd ) { oe_errno = oe_ebadf ; goto done ; } if ( flags != 0 ) { oe_errno = oe_einval ; goto done ; } ret = oe_access ( pathname , mode ) ; goto done ; } case oe_sys_getdents64 : { unsigned int fd = ( unsigned int ) arg1 ; struct oe_dirent * ent = ( struct oe_dirent * ) arg2 ; unsigned int count = ( unsigned int ) arg3 ; ret = oe_getdents64 ( fd , ent , count ) ; goto done ; } case oe_sys_ioctl : { int fd = ( int ) arg1 ; unsigned long request = ( unsigned long ) arg2 ; long p1 = arg3 ; long p2 = arg4 ; long p3 = arg5 ; long p4 = arg6 ; ret = oe_ioctl ( fd , request , p1 , p2 , p3 , p4 ) ; goto done ; } case oe_sys_fcntl : { int fd = ( int ) arg1 ; int cmd = ( int ) arg2 ; uint64_t arg = ( uint64_t ) arg3 ; ret = oe_fcntl ( fd , cmd , arg ) ; goto done ; } case oe_sys_mount : { const char * source = ( const char * ) arg1 ; const char * target = ( const char * ) arg2 ; const char * fstype = ( const char * ) arg3 ; unsigned long flags = ( unsigned long ) arg4 ; void * data = ( void * ) arg5 ; ret = oe_mount ( source , target , fstype , flags , data ) ; goto done ; } case oe_sys_umount2 : { const char * target = ( const char * ) arg1 ; int flags = ( int ) arg2 ; ( void ) flags ; ret = oe_umount ( target ) ; goto done ; } case oe_sys_getcwd : { char * buf = ( char * ) arg1 ; size_t size = ( size_t ) arg2 ; if ( ! oe_getcwd ( buf , size ) ) { ret = - 1 ; } else { ret = ( long ) size ; } goto done ; } case oe_sys_chdir : { char * path = ( char * ) arg1 ; ret = oe_chdir ( path ) ; goto done ; } case oe_sys_socket : { int domain = ( int ) arg1 ; int type = ( int ) arg2 ; int protocol = ( int ) arg3 ; ret = oe_socket ( domain , type , protocol ) ; goto done ; } case oe_sys_connect : { int sd = ( int ) arg1 ; const struct oe_sockaddr * addr = ( const struct oe_sockaddr * ) arg2 ; oe_socklen_t addrlen = ( oe_socklen_t ) arg3 ; ret = oe_connect ( sd , addr , addrlen ) ; goto done ; } case oe_sys_setsockopt : { int sockfd = ( int ) arg1 ; int level = ( int ) arg2 ; int optname = ( int ) arg3 ; void * optval = ( void * ) arg4 ; oe_socklen_t optlen = ( oe_socklen_t ) arg5 ; ret = oe_setsockopt ( sockfd , level , optname , optval , optlen ) ; goto done ; } case oe_sys_getsockopt : { int sockfd = ( int ) arg1 ; int level = ( int ) arg2 ; int optname = ( int ) arg3 ; void * optval = ( void * ) arg4 ; oe_socklen_t * optlen = ( oe_socklen_t * ) arg5 ; ret = oe_getsockopt ( sockfd , level , optname , optval , optlen ) ; goto done ; } case oe_sys_getpeername : { int sockfd = ( int ) arg1 ; struct sockaddr * addr = ( struct sockaddr * ) arg2 ; oe_socklen_t * addrlen = ( oe_socklen_t * ) arg3 ; ret = oe_getpeername ( sockfd , ( struct oe_sockaddr * ) addr , addrlen ) ; goto done ; } case oe_sys_getsockname : { int sockfd = ( int ) arg1 ; struct sockaddr * addr = ( struct sockaddr * ) arg2 ; oe_socklen_t * addrlen = ( oe_socklen_t * ) arg3 ; ret = oe_getsockname ( sockfd , ( struct oe_sockaddr * ) addr , addrlen ) ; goto done ; } case oe_sys_bind : { int sockfd = ( int ) arg1 ; struct oe_sockaddr * addr = ( struct oe_sockaddr * ) arg2 ; oe_socklen_t addrlen = ( oe_socklen_t ) arg3 ; ret = oe_bind ( sockfd , addr , addrlen ) ; goto done ; } case oe_sys_listen : { int sockfd = ( int ) arg1 ; int backlog = ( int ) arg2 ; ret = oe_listen ( sockfd , backlog ) ; goto done ; } case oe_sys_accept : { int sockfd = ( int ) arg1 ; struct oe_sockaddr * addr = ( struct oe_sockaddr * ) arg2 ; oe_socklen_t * addrlen = ( oe_socklen_t * ) arg3 ; ret = oe_accept ( sockfd , addr , addrlen ) ; goto done ; } case oe_sys_sendto : { int sockfd = ( int ) arg1 ; const void * buf = ( void * ) arg2 ; size_t len = ( size_t ) arg3 ; int flags = ( int ) arg4 ; const struct oe_sockaddr * dest_add = ( const struct oe_sockaddr * ) arg5 ; oe_socklen_t addrlen = ( oe_socklen_t ) arg6 ; ret = oe_sendto ( sockfd , buf , len , flags , dest_add , addrlen ) ; goto done ; } case oe_sys_recvfrom : { int sockfd = ( int ) arg1 ; void * buf = ( void * ) arg2 ; size_t len = ( size_t ) arg3 ; int flags = ( int ) arg4 ; const struct oe_sockaddr * dest_add = ( const struct oe_sockaddr * ) arg5 ; oe_socklen_t * addrlen = ( oe_socklen_t * ) arg6 ; ret = oe_recvfrom ( sockfd , buf , len , flags , dest_add , addrlen ) ; goto done ; } case oe_sys_sendmsg : { int sockfd = ( int ) arg1 ; struct msghdr * buf = ( struct msghdr * ) arg2 ; int flags = ( int ) arg3 ; ret = oe_sendmsg ( sockfd , ( struct oe_msghdr * ) buf , flags ) ; goto done ; } case oe_sys_recvmsg : { int sockfd = ( int ) arg1 ; struct msghdr * buf = ( struct msghdr * ) arg2 ; int flags = ( int ) arg3 ; ret = oe_recvmsg ( sockfd , ( struct oe_msghdr * ) buf , flags ) ; goto done ; } case oe_sys_socketpair : { int domain = ( int ) arg1 ; int type = ( int ) arg2 ; int protocol = ( int ) arg3 ; int * sv = ( int * ) arg4 ; ret = oe_socketpair ( domain , type , protocol , sv ) ; goto done ; } case oe_sys_shutdown : { int sockfd = ( int ) arg1 ; int how = ( int ) arg2 ; ret = oe_shutdown ( sockfd , how ) ; goto done ; } case oe_sys_uname : { struct oe_utsname * buf = ( struct oe_utsname * ) arg1 ; ret = oe_uname ( buf ) ; goto done ; } # if defined ( oe_sys_select ) case oe_sys_select : { int nfds = ( int ) arg1 ; oe_fd_set * readfds = ( oe_fd_set * ) arg2 ; oe_fd_set * writefds = ( oe_fd_set * ) arg3 ; oe_fd_set * efds = ( oe_fd_set * ) arg4 ; struct oe_timeval * timeout = ( struct oe_timeval * ) arg5 ; ret = oe_select ( nfds , readfds , writefds , efds , timeout ) ; goto done ; } # endif case oe_sys_pselect6 : { int nfds = ( int ) arg1 ; oe_fd_set * readfds = ( oe_fd_set * ) arg2 ; oe_fd_set * writefds = ( oe_fd_set * ) arg3 ; oe_fd_set * exceptfds = ( oe_fd_set * ) arg4 ; struct oe_timespec * ts = ( struct oe_timespec * ) arg5 ; struct oe_timeval buf ; struct oe_timeval * tv = null ; if ( ts ) { tv = & buf ; tv -> tv_sec = ts -> tv_sec ; tv -> tv_usec = ts -> tv_nsec / 1000 ; } ret = oe_select ( nfds , readfds , writefds , exceptfds , tv ) ; goto done ; } # if defined ( oe_sys_poll ) case oe_sys_poll : { struct oe_pollfd * fds = ( struct oe_pollfd * ) arg1 ; oe_nfds_t nfds = ( oe_nfds_t ) arg2 ; int millis = ( int ) arg3 ; ret = oe_poll ( fds , nfds , millis ) ; goto done ; } # endif case oe_sys_ppoll : { struct oe_pollfd * fds = ( struct oe_pollfd * ) arg1 ; oe_nfds_t nfds = ( oe_nfds_t ) arg2 ; struct oe_timespec * ts = ( struct oe_timespec * ) arg3 ; void * sigmask = ( void * ) arg4 ; int timeout = - 1 ; if ( sigmask != null ) { oe_errno = oe_einval ; goto done ; } if ( ts ) { int64_t mul ; int64_t div ; int64_t sum ; if ( oe_safe_mul_s64 ( ts -> tv_sec , 1000 , & mul ) != oe_ok ) { oe_errno = oe_einval ; goto done ; } div = ts -> tv_nsec / 1000000 ; if ( oe_safe_add_s64 ( mul , div , & sum ) != oe_ok ) { oe_errno = oe_einval ; goto done ; } if ( sum < oe_int_min || sum > oe_int_max ) { oe_errno = oe_einval ; goto done ; } timeout = ( int ) sum ; } ret = oe_poll ( fds , nfds , timeout ) ; goto done ; } # if defined ( oe_sys_epoll_create ) case oe_sys_epoll_create : { int size = ( int ) arg1 ; ret = oe_epoll_create ( size ) ; goto done ; } # endif case oe_sys_epoll_create1 : { int flags = ( int ) arg1 ; ret = oe_epoll_create1 ( flags ) ; goto done ; } # if defined ( oe_sys_epoll_wait ) case oe_sys_epoll_wait : { int epfd = ( int ) arg1 ; struct oe_epoll_event * events = ( struct oe_epoll_event * ) arg2 ; int maxevents = ( int ) arg3 ; int timeout = ( int ) arg4 ; ret = oe_epoll_wait ( epfd , events , maxevents , timeout ) ; goto done ; } # endif case oe_sys_epoll_pwait : { int epfd = ( int ) arg1 ; struct oe_epoll_event * events = ( struct oe_epoll_event * ) arg2 ; int maxevents = ( int ) arg3 ; int timeout = ( int ) arg4 ; const oe_sigset_t * sigmask = ( const oe_sigset_t * ) arg5 ; ret = oe_epoll_pwait ( epfd , events , maxevents , timeout , sigmask ) ; goto done ; } case oe_sys_epoll_ctl : { int epfd = ( int ) arg1 ; int op = ( int ) arg2 ; int fd = ( int ) arg3 ; struct oe_epoll_event * event = ( struct oe_epoll_event * ) arg4 ; ret = oe_epoll_ctl ( epfd , op , fd , event ) ; goto done ; } case oe_sys_exit_group : { ret = 0 ; goto done ; } case oe_sys_exit : { int status = ( int ) arg1 ; oe_exit ( status ) ; goto done ; } case oe_sys_getpid : { ret = ( long ) oe_getpid ( ) ; goto done ; } case oe_sys_getuid : { ret = ( long ) oe_getuid ( ) ; goto done ; } case oe_sys_geteuid : { ret = ( long ) oe_geteuid ( ) ; goto done ; } case oe_sys_getgid : { ret = ( long ) oe_getgid ( ) ; goto done ; } case oe_sys_getpgid : { int pid = ( int ) arg1 ; ret = ( long ) oe_getpgid ( pid ) ; goto done ; } case oe_sys_getgroups : { int size = ( int ) arg1 ; oe_gid_t * list = ( oe_gid_t * ) arg2 ; ret = ( long ) oe_getgroups ( size , list ) ; goto done ; } case oe_sys_getegid : { ret = ( long ) oe_getegid ( ) ; goto done ; } case oe_sys_getppid : { ret = ( long ) oe_getppid ( ) ; goto done ; } # if defined ( oe_sys_getpgrp ) case oe_sys_getpgrp : { ret = ( long ) oe_getpgrp ( ) ; goto done ; } # endif case oe_sys_nanosleep : { struct oe_timespec * req = ( struct oe_timespec * ) arg1 ; struct oe_timespec * rem = ( struct oe_timespec * ) arg2 ; ret = ( long ) oe_nanosleep ( req , rem ) ; goto done ; } default : { oe_errno = oe_enosys ; oe_trace_warning ( ""syscall<s2sv_blank>num=%ld<s2sv_blank>not<s2sv_blank>handled"" , num ) ; goto done ; } } done : return ret ; }","<S2SV_ModStart> ) arg4 ; <S2SV_ModEnd> struct oe_sockaddr * <S2SV_ModStart> * dest_add = ( <S2SV_ModEnd> struct oe_sockaddr *
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,<S2SV_StartBug> const struct oe_sockaddr * dest_add = <S2SV_EndBug> <S2SV_StartBug> ( const struct oe_sockaddr * ) arg5 ; <S2SV_EndBug>
7993,CWE-787,"rfbbool rfbhandleauthresult ( rfbclient * client ) { uint32_t authresult = 0 , reasonlen = 0 ; char * reason = null ; if ( ! readfromrfbserver ( client , ( char * ) & authresult , 4 ) ) return false ; authresult = rfbclientswap32ifle ( authresult ) ; switch ( authresult ) { case rfbvncauthok : rfbclientlog ( ""vnc<s2sv_blank>authentication<s2sv_blank>succeeded\\n"" ) ; return true ; break ; case rfbvncauthfailed : if ( client -> major == 3 && client -> minor > 7 ) { if ( ! readfromrfbserver ( client , ( char * ) & reasonlen , 4 ) ) return false ; reasonlen = rfbclientswap32ifle ( reasonlen ) ; reason = malloc ( ( uint64_t ) reasonlen + 1 ) ; if ( ! readfromrfbserver ( client , reason , reasonlen ) ) { free ( reason ) ; return false ; } reason [ reasonlen ] = 0 ; rfbclientlog ( ""vnc<s2sv_blank>connection<s2sv_blank>failed:<s2sv_blank>%s\\n"" , reason ) ; free ( reason ) ; return false ; } rfbclientlog ( ""vnc<s2sv_blank>authentication<s2sv_blank>failed\\n"" ) ; return false ; case rfbvncauthtoomany : rfbclientlog ( ""vnc<s2sv_blank>authentication<s2sv_blank>failed<s2sv_blank>-<s2sv_blank>too<s2sv_blank>many<s2sv_blank>tries\\n"" ) ; return false ; } rfbclientlog ( ""unknown<s2sv_blank>vnc<s2sv_blank>authentication<s2sv_blank>result:<s2sv_blank>%d\\n"" , ( int ) authresult ) ; return false ; }","<S2SV_ModStart> authResult = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> 7 ) { ReadReason ( client <S2SV_ModEnd> ) ; return
",LibVNC@libvncserver/e34bcbb759ca5bef85809967a268fdf214c1ad2c,CVE-2018-20748,https://github.com/LibVNC/libvncserver/commit/e34bcbb759ca5bef85809967a268fdf214c1ad2c,2019-01-30T18:29Z,"<S2SV_StartBug> uint32_t authResult = 0 , reasonLen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return FALSE ; <S2SV_EndBug>"
3759,CWE-287,"static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = null ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( null == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - eopnotsupp ; if ( msg -> msg_flags & msg_oob ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == tcp_established ? - eisconn : - eopnotsupp ; goto out_err ; } else { err = - enotconn ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & send_shutdown ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > skb_max_alloc ) size = skb_max_alloc ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & msg_dontwait , & err ) ; if ( skb == null ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , sock_dead ) || ( other -> sk_shutdown & rcv_shutdown ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = null ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & msg_nosignal ) ) send_sig ( sigpipe , current , 0 ) ; err = - epipe ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = null ; return sent ? : err ; }","<S2SV_ModStart> siocb -> scm , false
",torvalds@linux/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,CVE-2012-3520,https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,2012-10-03T11:02Z,"<S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug>"
5490,CWE-787,"static int strncat_from_utf8_libarchive2 ( struct archive_string * as , const void * _p , size_t len , struct archive_string_conv * sc ) { const char * s ; int n ; char * p ; char * end ; uint32_t unicode ; # if have_wcrtomb mbstate_t shift_state ; memset ( & shift_state , 0 , sizeof ( shift_state ) ) ; # else wctomb ( null , l'\\0' ) ; # endif ( void ) sc ; if ( archive_string_ensure ( as , as -> length + len + 1 ) == null ) return ( - 1 ) ; s = ( const char * ) _p ; p = as -> s + as -> length ; end = as -> s + as -> buffer_length - mb_cur_max - 1 ; while ( ( n = _utf8_to_unicode ( & unicode , s , len ) ) != 0 ) { wchar_t wc ; if ( p >= end ) { as -> length = p - as -> s ; if ( archive_string_ensure ( as , as -> length + len * 2 + 1 ) == null ) return ( - 1 ) ; p = as -> s + as -> length ; end = as -> s + as -> buffer_length - mb_cur_max - 1 ; } if ( n < 0 ) { n *= - 1 ; wc = l'?' ; } else wc = ( wchar_t ) unicode ; s += n ; len -= n ; # if have_wcrtomb n = ( int ) wcrtomb ( p , wc , & shift_state ) ; # else n = ( int ) wctomb ( p , wc ) ; # endif if ( n == - 1 ) return ( - 1 ) ; p += n ; } as -> length = p - as -> s ; as -> s [ as -> length ] = '\\0' ; return ( 0 ) ; }","<S2SV_ModStart> -> length + max ( <S2SV_ModStart> len * 2 , ( size_t ) MB_CUR_MAX )
",libarchive@libarchive/4f085eea879e2be745f4d9bf57e8513ae48157f4,CVE-2020-21674,https://github.com/libarchive/libarchive/commit/4f085eea879e2be745f4d9bf57e8513ae48157f4,2020-10-15T15:15Z,<S2SV_StartBug> as -> length + len * 2 + 1 ) == NULL ) <S2SV_EndBug>
2819,CWE-704,"static void n_tty_set_termios ( struct tty_struct * tty , struct ktermios * old ) { struct n_tty_data * ldata = tty -> disc_data ; if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & icanon ) { bitmap_zero ( ldata -> read_flags , n_tty_buf_size ) ; ldata -> line_start = ldata -> read_tail ; if ( ! l_icanon ( tty ) || ! read_cnt ( ldata ) ) { ldata -> canon_head = ldata -> read_tail ; ldata -> push = 0 ; } else { set_bit ( ( ldata -> read_head - 1 ) & ( n_tty_buf_size - 1 ) , ldata -> read_flags ) ; ldata -> canon_head = ldata -> read_head ; ldata -> push = 1 ; } ldata -> commit_head = ldata -> read_head ; ldata -> erasing = 0 ; ldata -> lnext = 0 ; } ldata -> icanon = ( l_icanon ( tty ) != 0 ) ; if ( i_istrip ( tty ) || i_iuclc ( tty ) || i_igncr ( tty ) || i_icrnl ( tty ) || i_inlcr ( tty ) || l_icanon ( tty ) || i_ixon ( tty ) || l_isig ( tty ) || l_echo ( tty ) || i_parmrk ( tty ) ) { bitmap_zero ( ldata -> char_map , 256 ) ; if ( i_igncr ( tty ) || i_icrnl ( tty ) ) set_bit ( '\\r' , ldata -> char_map ) ; if ( i_inlcr ( tty ) ) set_bit ( '\\n' , ldata -> char_map ) ; if ( l_icanon ( tty ) ) { set_bit ( erase_char ( tty ) , ldata -> char_map ) ; set_bit ( kill_char ( tty ) , ldata -> char_map ) ; set_bit ( eof_char ( tty ) , ldata -> char_map ) ; set_bit ( '\\n' , ldata -> char_map ) ; set_bit ( eol_char ( tty ) , ldata -> char_map ) ; if ( l_iexten ( tty ) ) { set_bit ( werase_char ( tty ) , ldata -> char_map ) ; set_bit ( lnext_char ( tty ) , ldata -> char_map ) ; set_bit ( eol2_char ( tty ) , ldata -> char_map ) ; if ( l_echo ( tty ) ) set_bit ( reprint_char ( tty ) , ldata -> char_map ) ; } } if ( i_ixon ( tty ) ) { set_bit ( start_char ( tty ) , ldata -> char_map ) ; set_bit ( stop_char ( tty ) , ldata -> char_map ) ; } if ( l_isig ( tty ) ) { set_bit ( intr_char ( tty ) , ldata -> char_map ) ; set_bit ( quit_char ( tty ) , ldata -> char_map ) ; set_bit ( susp_char ( tty ) , ldata -> char_map ) ; } clear_bit ( __disabled_char , ldata -> char_map ) ; ldata -> raw = 0 ; ldata -> real_raw = 0 ; } else { ldata -> raw = 1 ; if ( ( i_ignbrk ( tty ) || ( ! i_brkint ( tty ) && ! i_parmrk ( tty ) ) ) && ( i_ignpar ( tty ) || ! i_inpck ( tty ) ) && ( tty -> driver -> flags & tty_driver_real_raw ) ) ldata -> real_raw = 1 ; else ldata -> real_raw = 0 ; } if ( ! i_ixon ( tty ) && old && ( old -> c_iflag & ixon ) && ! tty -> flow_stopped ) { start_tty ( tty ) ; process_echoes ( tty ) ; } wake_up_interruptible ( & tty -> write_wait ) ; wake_up_interruptible ( & tty -> read_wait ) ; }","<S2SV_ModStart> c_lflag ) & ( ICANON | EXTPROC ) <S2SV_ModEnd> ) { bitmap_zero
",torvalds@linux/966031f340185eddd05affcf72b740549f056348,CVE-2018-18386,https://github.com/torvalds/linux/commit/966031f340185eddd05affcf72b740549f056348,2018-10-17T20:29Z,<S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug>
3721,CWE-362,"static int ext4_split_extent_at ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , ext4_lblk_t split , int split_flag , int flags ) { ext4_fsblk_t newblock ; ext4_lblk_t ee_block ; struct ext4_extent * ex , newex , orig_ex ; struct ext4_extent * ex2 = null ; unsigned int ee_len , depth ; int err = 0 ; ext_debug ( ""ext4_split_extents_at:<s2sv_blank>inode<s2sv_blank>%lu,<s2sv_blank>logical"" ""block<s2sv_blank>%llu\\n"" , inode -> i_ino , ( unsigned long long ) split ) ; ext4_ext_show_leaf ( inode , path ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; newblock = split - ee_block + ext4_ext_pblock ( ex ) ; bug_on ( split < ee_block || split >= ( ee_block + ee_len ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; if ( split == ee_block ) { if ( split_flag & ext4_ext_mark_uninit2 ) ext4_ext_mark_uninitialized ( ex ) ; else ext4_ext_mark_initialized ( ex ) ; if ( ! ( flags & ext4_get_blocks_pre_io ) ) ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } memcpy ( & orig_ex , ex , sizeof ( orig_ex ) ) ; ex -> ee_len = cpu_to_le16 ( split - ee_block ) ; if ( split_flag & ext4_ext_mark_uninit1 ) ext4_ext_mark_uninitialized ( ex ) ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; if ( err ) goto fix_extent_len ; ex2 = & newex ; ex2 -> ee_block = cpu_to_le32 ( split ) ; ex2 -> ee_len = cpu_to_le16 ( ee_len - ( split - ee_block ) ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; if ( split_flag & ext4_ext_mark_uninit2 ) ext4_ext_mark_uninitialized ( ex2 ) ; err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err == - enospc && ( ext4_ext_may_zeroout & split_flag ) ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; fix_extent_len : ex -> ee_len = orig_ex . ee_len ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }","<S2SV_ModStart> err = 0 ; BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) <S2SV_ModStart> ) ) { if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) { if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ; else err = ext4_ext_zeroout ( inode , ex ) ; } else
",torvalds@linux/dee1f973ca341c266229faa5a1a5bb268bed3531,CVE-2012-4508,https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531,2012-12-21T11:47Z,"<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug>"
2934,CWE-200,"static long __tun_chr_ioctl ( struct file * file , unsigned int cmd , unsigned long arg , int ifreq_len ) { struct tun_file * tfile = file -> private_data ; struct tun_struct * tun ; void __user * argp = ( void __user * ) arg ; struct sock_fprog fprog ; struct ifreq ifr ; int sndbuf ; int vnet_hdr_sz ; int ret ; if ( cmd == tunsetiff || _ioc_type ( cmd ) == 0x89 ) if ( copy_from_user ( & ifr , argp , ifreq_len ) ) return - efault ; if ( cmd == tungetfeatures ) { return put_user ( iff_tun | iff_tap | iff_no_pi | iff_one_queue | iff_vnet_hdr , ( unsigned int __user * ) argp ) ; } rtnl_lock ( ) ; tun = __tun_get ( tfile ) ; if ( cmd == tunsetiff && ! tun ) { ifr . ifr_name [ ifnamsiz - 1 ] = '\\0' ; ret = tun_set_iff ( tfile -> net , file , & ifr ) ; if ( ret ) goto unlock ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - efault ; goto unlock ; } ret = - ebadfd ; if ( ! tun ) goto unlock ; tun_debug ( kern_info , tun , ""tun_chr_ioctl<s2sv_blank>cmd<s2sv_blank>%d\\n"" , cmd ) ; ret = 0 ; switch ( cmd ) { case tungetiff : ret = tun_get_iff ( current -> nsproxy -> net_ns , tun , & ifr ) ; if ( ret ) break ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - efault ; break ; case tunsetnocsum : tun_debug ( kern_info , tun , ""ignored:<s2sv_blank>set<s2sv_blank>checksum<s2sv_blank>%s\\n"" , arg ? ""disabled"" : ""enabled"" ) ; break ; case tunsetpersist : if ( arg ) tun -> flags |= tun_persist ; else tun -> flags &= ~ tun_persist ; tun_debug ( kern_info , tun , ""persist<s2sv_blank>%s\\n"" , arg ? ""enabled"" : ""disabled"" ) ; break ; case tunsetowner : tun -> owner = ( uid_t ) arg ; tun_debug ( kern_info , tun , ""owner<s2sv_blank>set<s2sv_blank>to<s2sv_blank>%d\\n"" , tun -> owner ) ; break ; case tunsetgroup : tun -> group = ( gid_t ) arg ; tun_debug ( kern_info , tun , ""group<s2sv_blank>set<s2sv_blank>to<s2sv_blank>%d\\n"" , tun -> group ) ; break ; case tunsetlink : if ( tun -> dev -> flags & iff_up ) { tun_debug ( kern_info , tun , ""linktype<s2sv_blank>set<s2sv_blank>failed<s2sv_blank>because<s2sv_blank>interface<s2sv_blank>is<s2sv_blank>up\\n"" ) ; ret = - ebusy ; } else { tun -> dev -> type = ( int ) arg ; tun_debug ( kern_info , tun , ""linktype<s2sv_blank>set<s2sv_blank>to<s2sv_blank>%d\\n"" , tun -> dev -> type ) ; ret = 0 ; } break ; # ifdef tun_debug case tunsetdebug : tun -> debug = arg ; break ; # endif case tunsetoffload : ret = set_offload ( tun , arg ) ; break ; case tunsettxfilter : ret = - einval ; if ( ( tun -> flags & tun_type_mask ) != tun_tap_dev ) break ; ret = update_filter ( & tun -> txflt , ( void __user * ) arg ) ; break ; case siocgifhwaddr : memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , eth_alen ) ; ifr . ifr_hwaddr . sa_family = tun -> dev -> type ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - efault ; break ; case siocsifhwaddr : tun_debug ( kern_debug , tun , ""set<s2sv_blank>hw<s2sv_blank>address:<s2sv_blank>%pm\\n"" , ifr . ifr_hwaddr . sa_data ) ; ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ) ; break ; case tungetsndbuf : sndbuf = tun -> socket . sk -> sk_sndbuf ; if ( copy_to_user ( argp , & sndbuf , sizeof ( sndbuf ) ) ) ret = - efault ; break ; case tunsetsndbuf : if ( copy_from_user ( & sndbuf , argp , sizeof ( sndbuf ) ) ) { ret = - efault ; break ; } tun -> socket . sk -> sk_sndbuf = sndbuf ; break ; case tungetvnethdrsz : vnet_hdr_sz = tun -> vnet_hdr_sz ; if ( copy_to_user ( argp , & vnet_hdr_sz , sizeof ( vnet_hdr_sz ) ) ) ret = - efault ; break ; case tunsetvnethdrsz : if ( copy_from_user ( & vnet_hdr_sz , argp , sizeof ( vnet_hdr_sz ) ) ) { ret = - efault ; break ; } if ( vnet_hdr_sz < ( int ) sizeof ( struct virtio_net_hdr ) ) { ret = - einval ; break ; } tun -> vnet_hdr_sz = vnet_hdr_sz ; break ; case tunattachfilter : ret = - einval ; if ( ( tun -> flags & tun_type_mask ) != tun_tap_dev ) break ; ret = - efault ; if ( copy_from_user ( & fprog , argp , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , tun -> socket . sk ) ; break ; case tundetachfilter : ret = - einval ; if ( ( tun -> flags & tun_type_mask ) != tun_tap_dev ) break ; ret = sk_detach_filter ( tun -> socket . sk ) ; break ; default : ret = - einval ; break ; } unlock : rtnl_unlock ( ) ; if ( tun ) tun_put ( tun ) ; return ret ; }","<S2SV_ModStart> == 0x89 ) { <S2SV_ModStart> return - EFAULT ; } else memset ( & ifr , 0 , sizeof ( ifr ) )
",torvalds@linux/a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc,CVE-2012-6547,https://github.com/torvalds/linux/commit/a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc,2013-03-15T20:55Z,<S2SV_StartBug> if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug>
2611,CWE-476,"static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - einval ; tmp = ! ! tmp ; if ( ! test_bit ( o2nm_node_attr_address , & node -> nd_set_attributes ) || ! test_bit ( o2nm_node_attr_num , & node -> nd_set_attributes ) || ! test_bit ( o2nm_node_attr_port , & node -> nd_set_attributes ) ) return - einval ; if ( tmp && tmp == cluster -> cl_has_local && cluster -> cl_local_node != node -> nd_num ) return - ebusy ; if ( tmp && ! cluster -> cl_has_local ) { ret = o2net_start_listening ( node ) ; if ( ret ) return ret ; } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = o2nm_invalid_node_num ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } return count ; }","<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> -> nd_num ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; goto out ; } <S2SV_ModStart> ( ret ) goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> nd_num ; } ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,CVE-2017-18216,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,2018-03-05T18:29Z,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> return count ; <S2SV_EndBug>
8130,CWE-295,"void main_cleanup ( ) { # ifdef use_os_threads cli * c ; unsigned i , threads ; thread_id * thread_list ; crypto_thread_write_lock ( stunnel_locks [ lock_thread_list ] ) ; threads = 0 ; for ( c = thread_head ; c ; c = c -> thread_next ) threads ++ ; thread_list = str_alloc ( ( threads + 1 ) * sizeof ( thread_id ) ) ; i = 0 ; for ( c = thread_head ; c ; c = c -> thread_next ) { thread_list [ i ++ ] = c -> thread_id ; s_log ( log_debug , ""terminating<s2sv_blank>a<s2sv_blank>thread<s2sv_blank>for<s2sv_blank>[%s]"" , c -> opt -> servname ) ; } if ( cron_thread_id ) { thread_list [ threads ++ ] = cron_thread_id ; s_log ( log_debug , ""terminating<s2sv_blank>the<s2sv_blank>cron<s2sv_blank>thread"" ) ; } crypto_thread_unlock ( stunnel_locks [ lock_thread_list ] ) ; if ( threads ) { s_log ( log_notice , ""terminating<s2sv_blank>%u<s2sv_blank>service<s2sv_blank>thread(s)"" , threads ) ; writesocket ( terminate_pipe [ 1 ] , """" , 1 ) ; for ( i = 0 ; i < threads ; ++ i ) { # ifdef use_pthread if ( pthread_join ( thread_list [ i ] , null ) ) s_log ( log_err , ""pthread_join()<s2sv_blank>failed"" ) ; # endif # ifdef use_win32 if ( waitforsingleobject ( thread_list [ i ] , infinite ) == wait_failed ) ioerror ( ""waitforsingleobject"" ) ; if ( ! closehandle ( thread_list [ i ] ) ) ioerror ( ""closehandle"" ) ; # endif } s_log ( log_notice , ""service<s2sv_blank>threads<s2sv_blank>terminated"" ) ; } str_free ( thread_list ) ; # endif unbind_ports ( ) ; s_poll_free ( fds ) ; fds = null ; # if 0 str_stats ( ) ; # endif log_flush ( log_mode_error ) ; log_close ( sink_syslog | sink_outfile ) ; }","<S2SV_ModStart> endif log_flush ( LOG_MODE_BUFFER <S2SV_ModEnd> ) ; log_close
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,<S2SV_StartBug> log_flush ( LOG_MODE_ERROR ) ; <S2SV_EndBug>
7325,CWE-20,"static char * base64_decode_string ( const char * enc ) { if ( enc == null ) return null ; char * dec = g_strdup ( enc ) ; gsize len ; g_base64_decode_inplace ( dec , & len ) ; dec [ len ] = '\\0' ; return dec ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> static gchar <S2SV_ModEnd> * base64_decode_string ( <S2SV_ModStart> enc ) { gchar * dec ; gsize len ; <S2SV_ModStart> return NULL ; dec = ( gchar * ) g_base64_decode ( enc <S2SV_ModEnd> , & len <S2SV_ModStart> len ) ; if ( dec )
",cockpit-project@cockpit/c51f6177576d7e12614c64d316cf0b67addd17c9,CVE-2019-3804,https://github.com/cockpit-project/cockpit/commit/c51f6177576d7e12614c64d316cf0b67addd17c9,2019-03-26T18:29Z,"<S2SV_StartBug> static char * <S2SV_EndBug> <S2SV_StartBug> if ( enc == NULL ) <S2SV_EndBug> <S2SV_StartBug> char * dec = g_strdup ( enc ) ; <S2SV_EndBug> <S2SV_StartBug> g_base64_decode_inplace ( dec , & len ) ; <S2SV_EndBug>"
5327,CWE-125,"static void ttm_put_pages ( struct page * * pages , unsigned npages , int flags , enum ttm_caching_state cstate ) { struct ttm_page_pool * pool = ttm_get_pool ( flags , false , cstate ) ; # ifdef config_transparent_hugepage struct ttm_page_pool * huge = ttm_get_pool ( flags , true , cstate ) ; # endif unsigned long irq_flags ; unsigned i ; if ( pool == null ) { i = 0 ; while ( i < npages ) { # ifdef config_transparent_hugepage struct page * p = pages [ i ] ; # endif unsigned order = 0 , j ; if ( ! pages [ i ] ) { ++ i ; continue ; } # ifdef config_transparent_hugepage if ( ! ( flags & ttm_page_flag_dma32 ) && ( npages - i ) >= hpage_pmd_nr ) { for ( j = 1 ; j < hpage_pmd_nr ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j == hpage_pmd_nr ) order = hpage_pmd_order ; } # endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""erroneous<s2sv_blank>page<s2sv_blank>count.<s2sv_blank>leaking<s2sv_blank>pages.\\n"" ) ; __free_pages ( pages [ i ] , order ) ; j = 1 << order ; while ( j ) { pages [ i ++ ] = null ; -- j ; } } return ; } i = 0 ; # ifdef config_transparent_hugepage if ( huge ) { unsigned max_size , n2free ; spin_lock_irqsave ( & huge -> lock , irq_flags ) ; while ( ( npages - i ) >= hpage_pmd_nr ) { struct page * p = pages [ i ] ; unsigned j ; if ( ! p ) break ; for ( j = 1 ; j < hpage_pmd_nr ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j != hpage_pmd_nr ) break ; list_add_tail ( & pages [ i ] -> lru , & huge -> list ) ; for ( j = 0 ; j < hpage_pmd_nr ; ++ j ) pages [ i ++ ] = null ; huge -> npages ++ ; } max_size = _manager -> options . max_size ; max_size /= hpage_pmd_nr ; if ( huge -> npages > max_size ) n2free = huge -> npages - max_size ; else n2free = 0 ; spin_unlock_irqrestore ( & huge -> lock , irq_flags ) ; if ( n2free ) ttm_page_pool_free ( huge , n2free , false ) ; } # endif spin_lock_irqsave ( & pool -> lock , irq_flags ) ; while ( i < npages ) { if ( pages [ i ] ) { if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""erroneous<s2sv_blank>page<s2sv_blank>count.<s2sv_blank>leaking<s2sv_blank>pages.\\n"" ) ; list_add_tail ( & pages [ i ] -> lru , & pool -> list ) ; pages [ i ] = null ; pool -> npages ++ ; } ++ i ; } npages = 0 ; if ( pool -> npages > _manager -> options . max_size ) { npages = pool -> npages - _manager -> options . max_size ; if ( npages < num_pages_to_alloc ) npages = num_pages_to_alloc ; } spin_unlock_irqrestore ( & pool -> lock , irq_flags ) ; if ( npages ) ttm_page_pool_free ( pool , npages , false ) ; }","<S2SV_ModStart> ) if ( ++ p <S2SV_ModEnd> != pages [ <S2SV_ModStart> ) if ( ++ p <S2SV_ModEnd> != pages [
",torvalds@linux/453393369dc9806d2455151e329c599684762428,CVE-2019-19927,https://github.com/torvalds/linux/commit/453393369dc9806d2455151e329c599684762428,2019-12-31T02:15Z,<S2SV_StartBug> if ( p ++ != pages [ i + j ] ) <S2SV_EndBug> <S2SV_StartBug> if ( p ++ != pages [ i + j ] ) <S2SV_EndBug>
3109,CWE-20,"static int dccp_packet ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info ctinfo , u_int8_t pf , unsigned int hooknum , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; enum ip_conntrack_dir dir = ctinfo2dir ( ctinfo ) ; struct dccp_hdr _dh , * dh ; u_int8_t type , old_state , new_state ; enum ct_dccp_roles role ; dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; bug_on ( dh == null ) ; type = dh -> dccph_type ; if ( type == dccp_pkt_reset && ! test_bit ( ips_seen_reply_bit , & ct -> status ) ) { nf_ct_kill_acct ( ct , ctinfo , skb ) ; return nf_accept ; } spin_lock_bh ( & ct -> lock ) ; role = ct -> proto . dccp . role [ dir ] ; old_state = ct -> proto . dccp . state ; new_state = dccp_state_table [ role ] [ type ] [ old_state ] ; switch ( new_state ) { case ct_dccp_request : if ( old_state == ct_dccp_timewait && role == ct_dccp_role_server ) { ct -> proto . dccp . role [ dir ] = ct_dccp_role_client ; ct -> proto . dccp . role [ ! dir ] = ct_dccp_role_server ; } break ; case ct_dccp_respond : if ( old_state == ct_dccp_request ) ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; break ; case ct_dccp_partopen : if ( old_state == ct_dccp_respond && type == dccp_pkt_ack && dccp_ack_seq ( dh ) == ct -> proto . dccp . handshake_seq ) set_bit ( ips_assured_bit , & ct -> status ) ; break ; case ct_dccp_ignore : if ( ct -> proto . dccp . last_dir == ! dir && ct -> proto . dccp . last_pkt == dccp_pkt_request && type == dccp_pkt_response ) { ct -> proto . dccp . role [ ! dir ] = ct_dccp_role_client ; ct -> proto . dccp . role [ dir ] = ct_dccp_role_server ; ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; new_state = ct_dccp_respond ; break ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; spin_unlock_bh ( & ct -> lock ) ; if ( log_invalid ( net , ipproto_dccp ) ) nf_log_packet ( net , pf , 0 , skb , null , null , null , ""nf_ct_dccp:<s2sv_blank>invalid<s2sv_blank>packet<s2sv_blank>ignored<s2sv_blank>"" ) ; return nf_accept ; case ct_dccp_invalid : spin_unlock_bh ( & ct -> lock ) ; if ( log_invalid ( net , ipproto_dccp ) ) nf_log_packet ( net , pf , 0 , skb , null , null , null , ""nf_ct_dccp:<s2sv_blank>invalid<s2sv_blank>state<s2sv_blank>transition<s2sv_blank>"" ) ; return - nf_accept ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; ct -> proto . dccp . state = new_state ; spin_unlock_bh ( & ct -> lock ) ; if ( new_state != old_state ) nf_conntrack_event_cache ( ipct_protoinfo , ct ) ; nf_ct_refresh_acct ( ct , ctinfo , skb , timeouts [ new_state ] ) ; return nf_accept ; }","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
",torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug>"
3167,CWE-189,"int midi_synth_load_patch ( int dev , int format , const char __user * addr , int offs , int count , int pmgr_flag ) { int orig_dev = synth_devs [ dev ] -> midi_dev ; struct sysex_info sysex ; int i ; unsigned long left , src_offs , eox_seen = 0 ; int first_byte = 1 ; int hdr_size = ( unsigned long ) & sysex . data [ 0 ] - ( unsigned long ) & sysex ; leave_sysex ( dev ) ; if ( ! prefix_cmd ( orig_dev , 0xf0 ) ) return 0 ; if ( format != sysex_patch ) { return - einval ; } if ( count < hdr_size ) { return - einval ; } count -= hdr_size ; if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) ) return - efault ; if ( count < sysex . len ) { sysex . len = count ; } left = sysex . len ; src_offs = 0 ; for ( i = 0 ; i < left && ! signal_pending ( current ) ; i ++ ) { unsigned char data ; if ( get_user ( data , ( unsigned char __user * ) ( addr + hdr_size + i ) ) ) return - efault ; eox_seen = ( i > 0 && data & 0x80 ) ; if ( eox_seen && data != 0xf7 ) data = 0xf7 ; if ( i == 0 ) { if ( data != 0xf0 ) { printk ( kern_warning ""midi_synth:<s2sv_blank>sysex<s2sv_blank>start<s2sv_blank>missing\\n"" ) ; return - einval ; } } while ( ! midi_devs [ orig_dev ] -> outputc ( orig_dev , ( unsigned char ) ( data & 0xff ) ) && ! signal_pending ( current ) ) schedule ( ) ; if ( ! first_byte && data & 0x80 ) return 0 ; first_byte = 0 ; } if ( ! eox_seen ) midi_outc ( orig_dev , 0xf7 ) ; return 0 ; }","<S2SV_ModStart> * addr , <S2SV_ModEnd> int count , <S2SV_ModStart> != SYSEX_PATCH ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> if ( count <S2SV_ModStart> < hdr_size ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> count -= hdr_size <S2SV_ModStart> copy_from_user ( & sysex , addr , hdr_size <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( ( unsigned ) count < ( unsigned ) <S2SV_ModEnd> sysex . len <S2SV_ModStart> . len ) <S2SV_ModEnd> sysex . len <S2SV_ModStart> = count ; <S2SV_ModEnd> left = sysex
",torvalds@linux/b769f49463711205d57286e64cf535ed4daf59e9,CVE-2011-1476,https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9,2012-06-21T23:55Z,"<S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) ) <S2SV_EndBug> <S2SV_StartBug> if ( count < sysex . len ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
5511,CWE-190,"static s32 gf_hevc_read_sps_bs_internal ( gf_bitstream * bs , hevcstate * hevc , u8 layer_id , u32 * vui_flag_pos ) { s32 vps_id , sps_id = - 1 ; u32 i , nb_ctus , depth ; hevc_sps * sps ; hevc_vps * vps ; hevc_profiletierlevel ptl ; bool multilayerextspsflag ; u8 sps_ext_or_max_sub_layers_minus1 , max_sub_layers_minus1 ; if ( vui_flag_pos ) * vui_flag_pos = 0 ; vps_id = gf_bs_read_int_log ( bs , 4 , ""vps_id"" ) ; if ( vps_id >= 16 ) { return - 1 ; } memset ( & ptl , 0 , sizeof ( ptl ) ) ; max_sub_layers_minus1 = 0 ; sps_ext_or_max_sub_layers_minus1 = 0 ; if ( layer_id == 0 ) max_sub_layers_minus1 = gf_bs_read_int_log ( bs , 3 , ""max_sub_layers_minus1"" ) ; else sps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log ( bs , 3 , ""sps_ext_or_max_sub_layers_minus1"" ) ; multilayerextspsflag = ( layer_id != 0 ) && ( sps_ext_or_max_sub_layers_minus1 == 7 ) ; if ( ! multilayerextspsflag ) { gf_bs_read_int_log ( bs , 1 , ""temporal_id_nesting_flag"" ) ; hevc_profile_tier_level ( bs , 1 , max_sub_layers_minus1 , & ptl , 0 ) ; } sps_id = gf_bs_read_ue_log ( bs , ""sps_id"" ) ; if ( ( sps_id < 0 ) || ( sps_id >= 16 ) ) { return - 1 ; } sps = & hevc -> sps [ sps_id ] ; if ( ! sps -> state ) { sps -> state = 1 ; sps -> id = sps_id ; sps -> vps_id = vps_id ; } sps -> ptl = ptl ; vps = & hevc -> vps [ vps_id ] ; sps -> max_sub_layers_minus1 = 0 ; sps -> sps_ext_or_max_sub_layers_minus1 = 0 ; sps -> colour_primaries = 2 ; sps -> transfer_characteristic = 2 ; sps -> matrix_coeffs = 2 ; if ( multilayerextspsflag ) { sps -> update_rep_format_flag = gf_bs_read_int_log ( bs , 1 , ""update_rep_format_flag"" ) ; if ( sps -> update_rep_format_flag ) { sps -> rep_format_idx = gf_bs_read_int_log ( bs , 8 , ""rep_format_idx"" ) ; } else { sps -> rep_format_idx = vps -> rep_format_idx [ layer_id ] ; } sps -> width = vps -> rep_formats [ sps -> rep_format_idx ] . pic_width_luma_samples ; sps -> height = vps -> rep_formats [ sps -> rep_format_idx ] . pic_height_luma_samples ; sps -> chroma_format_idc = vps -> rep_formats [ sps -> rep_format_idx ] . chroma_format_idc ; sps -> bit_depth_luma = vps -> rep_formats [ sps -> rep_format_idx ] . bit_depth_luma ; sps -> bit_depth_chroma = vps -> rep_formats [ sps -> rep_format_idx ] . bit_depth_chroma ; sps -> separate_colour_plane_flag = vps -> rep_formats [ sps -> rep_format_idx ] . separate_colour_plane_flag ; sps -> ptl = vps -> ext_ptl [ 0 ] ; } else { sps -> chroma_format_idc = gf_bs_read_ue_log ( bs , ""chroma_format_idc"" ) ; if ( sps -> chroma_format_idc == 3 ) sps -> separate_colour_plane_flag = gf_bs_read_int_log ( bs , 1 , ""separate_colour_plane_flag"" ) ; sps -> width = gf_bs_read_ue_log ( bs , ""width"" ) ; sps -> height = gf_bs_read_ue_log ( bs , ""height"" ) ; if ( ( sps -> cw_flag = gf_bs_read_int_log ( bs , 1 , ""conformance_window_flag"" ) ) ) { u32 subwidthc , subheightc ; if ( sps -> chroma_format_idc == 1 ) { subwidthc = subheightc = 2 ; } else if ( sps -> chroma_format_idc == 2 ) { subwidthc = 2 ; subheightc = 1 ; } else { subwidthc = subheightc = 1 ; } sps -> cw_left = gf_bs_read_ue_log ( bs , ""conformance_window_left"" ) ; sps -> cw_right = gf_bs_read_ue_log ( bs , ""conformance_window_right"" ) ; sps -> cw_top = gf_bs_read_ue_log ( bs , ""conformance_window_top"" ) ; sps -> cw_bottom = gf_bs_read_ue_log ( bs , ""conformance_window_bottom"" ) ; sps -> width -= subwidthc * ( sps -> cw_left + sps -> cw_right ) ; sps -> height -= subheightc * ( sps -> cw_top + sps -> cw_bottom ) ; } sps -> bit_depth_luma = 8 + gf_bs_read_ue_log ( bs , ""bit_depth_luma_minus8"" ) ; sps -> bit_depth_chroma = 8 + gf_bs_read_ue_log ( bs , ""bit_depth_chroma_minus8"" ) ; } sps -> log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log ( bs , ""log2_max_pic_order_cnt_lsb_minus4"" ) ; if ( ! multilayerextspsflag ) { sps -> sub_layer_ordering_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""sub_layer_ordering_info_present_flag"" ) ; for ( i = sps -> sub_layer_ordering_info_present_flag ? 0 : sps -> max_sub_layers_minus1 ; i <= sps -> max_sub_layers_minus1 ; i ++ ) { gf_bs_read_ue_log_idx ( bs , ""max_dec_pic_buffering"" , i ) ; gf_bs_read_ue_log_idx ( bs , ""num_reorder_pics"" , i ) ; gf_bs_read_ue_log_idx ( bs , ""max_latency_increase"" , i ) ; } } sps -> log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log ( bs , ""log2_min_luma_coding_block_size_minus3"" ) ; sps -> log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log ( bs , ""log2_diff_max_min_luma_coding_block_size"" ) ; sps -> max_cu_width = ( 1 << ( sps -> log2_min_luma_coding_block_size + sps -> log2_diff_max_min_luma_coding_block_size ) ) ; sps -> max_cu_height = ( 1 << ( sps -> log2_min_luma_coding_block_size + sps -> log2_diff_max_min_luma_coding_block_size ) ) ; sps -> log2_min_transform_block_size = 2 + gf_bs_read_ue_log ( bs , ""log2_min_transform_block_size_minus2"" ) ; sps -> log2_max_transform_block_size = sps -> log2_min_transform_block_size + gf_bs_read_ue_log ( bs , ""log2_max_transform_block_size"" ) ; depth = 0 ; sps -> max_transform_hierarchy_depth_inter = gf_bs_read_ue_log ( bs , ""max_transform_hierarchy_depth_inter"" ) ; sps -> max_transform_hierarchy_depth_intra = gf_bs_read_ue_log ( bs , ""max_transform_hierarchy_depth_intra"" ) ; while ( ( u32 ) ( sps -> max_cu_width >> sps -> log2_diff_max_min_luma_coding_block_size ) > ( u32 ) ( 1 << ( sps -> log2_min_transform_block_size + depth ) ) ) { depth ++ ; } sps -> max_cu_depth = sps -> log2_diff_max_min_luma_coding_block_size + depth ; nb_ctus = ( ( sps -> width + sps -> max_cu_width - 1 ) / sps -> max_cu_width ) * ( ( sps -> height + sps -> max_cu_height - 1 ) / sps -> max_cu_height ) ; sps -> bitsslicesegmentaddress = 0 ; while ( nb_ctus > ( u32 ) ( 1 << sps -> bitsslicesegmentaddress ) ) { sps -> bitsslicesegmentaddress ++ ; } sps -> scaling_list_enable_flag = gf_bs_read_int_log ( bs , 1 , ""scaling_list_enable_flag"" ) ; if ( sps -> scaling_list_enable_flag ) { sps -> infer_scaling_list_flag = 0 ; sps -> scaling_list_ref_layer_id = 0 ; if ( multilayerextspsflag ) { sps -> infer_scaling_list_flag = gf_bs_read_int_log ( bs , 1 , ""infer_scaling_list_flag"" ) ; } if ( sps -> infer_scaling_list_flag ) { sps -> scaling_list_ref_layer_id = gf_bs_read_int_log ( bs , 6 , ""scaling_list_ref_layer_id"" ) ; } else { sps -> scaling_list_data_present_flag = gf_bs_read_int_log ( bs , 1 , ""scaling_list_data_present_flag"" ) ; if ( sps -> scaling_list_data_present_flag ) { hevc_scaling_list_data ( bs ) ; } } } sps -> asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""asymmetric_motion_partitions_enabled_flag"" ) ; sps -> sample_adaptive_offset_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""sample_adaptive_offset_enabled_flag"" ) ; if ( ( sps -> pcm_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""pcm_enabled_flag"" ) ) ) { sps -> pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log ( bs , 4 , ""pcm_sample_bit_depth_luma_minus1"" ) ; sps -> pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log ( bs , 4 , ""pcm_sample_bit_depth_chroma_minus1"" ) ; sps -> log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log ( bs , ""log2_min_pcm_luma_coding_block_size_minus3"" ) ; sps -> log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log ( bs , ""log2_diff_max_min_pcm_luma_coding_block_size"" ) ; sps -> pcm_loop_filter_disable_flag = gf_bs_read_int_log ( bs , 1 , ""pcm_loop_filter_disable_flag"" ) ; } sps -> num_short_term_ref_pic_sets = gf_bs_read_ue_log ( bs , ""num_short_term_ref_pic_sets"" ) ; if ( sps -> num_short_term_ref_pic_sets > 64 ) { gf_log ( gf_log_error , gf_log_coding , ( ""[hevc]<s2sv_blank>invalid<s2sv_blank>number<s2sv_blank>of<s2sv_blank>short<s2sv_blank>term<s2sv_blank>reference<s2sv_blank>picture<s2sv_blank>sets<s2sv_blank>%d\\n"" , sps -> num_short_term_ref_pic_sets ) ) ; return - 1 ; } for ( i = 0 ; i < sps -> num_short_term_ref_pic_sets ; i ++ ) { bool ret = hevc_parse_short_term_ref_pic_set ( bs , sps , i ) ; if ( ! ret ) { gf_log ( gf_log_error , gf_log_coding , ( ""[hevc]<s2sv_blank>invalid<s2sv_blank>short_term_ref_pic_set\\n"" ) ) ; return - 1 ; } } sps -> long_term_ref_pics_present_flag = gf_bs_read_int_log ( bs , 1 , ""long_term_ref_pics_present_flag"" ) ; if ( sps -> long_term_ref_pics_present_flag ) { sps -> num_long_term_ref_pic_sps = gf_bs_read_ue_log ( bs , ""num_long_term_ref_pic_sps"" ) ; for ( i = 0 ; i < sps -> num_long_term_ref_pic_sps ; i ++ ) { gf_bs_read_int_log_idx ( bs , sps -> log2_max_pic_order_cnt_lsb , ""lt_ref_pic_poc_lsb_sps"" , i ) ; gf_bs_read_int_log_idx ( bs , 1 , ""used_by_curr_pic_lt_sps_flag"" , i ) ; } } sps -> temporal_mvp_enable_flag = gf_bs_read_int_log ( bs , 1 , ""temporal_mvp_enable_flag"" ) ; sps -> strong_intra_smoothing_enable_flag = gf_bs_read_int_log ( bs , 1 , ""strong_intra_smoothing_enable_flag"" ) ; if ( vui_flag_pos ) * vui_flag_pos = ( u32 ) gf_bs_get_bit_offset ( bs ) ; if ( ( sps -> vui_parameters_present_flag = gf_bs_read_int_log ( bs , 1 , ""vui_parameters_present_flag"" ) ) ) { sps -> aspect_ratio_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""aspect_ratio_info_present_flag"" ) ; if ( sps -> aspect_ratio_info_present_flag ) { sps -> sar_idc = gf_bs_read_int_log ( bs , 8 , ""aspect_ratio_idc"" ) ; if ( sps -> sar_idc == 255 ) { sps -> sar_width = gf_bs_read_int_log ( bs , 16 , ""aspect_ratio_width"" ) ; sps -> sar_height = gf_bs_read_int_log ( bs , 16 , ""aspect_ratio_height"" ) ; } else if ( sps -> sar_idc < 17 ) { sps -> sar_width = hevc_sar [ sps -> sar_idc ] . w ; sps -> sar_height = hevc_sar [ sps -> sar_idc ] . h ; } } if ( ( sps -> overscan_info_present = gf_bs_read_int_log ( bs , 1 , ""overscan_info_present"" ) ) ) sps -> overscan_appropriate = gf_bs_read_int_log ( bs , 1 , ""overscan_appropriate"" ) ; sps -> video_signal_type_present_flag = gf_bs_read_int_log ( bs , 1 , ""video_signal_type_present_flag"" ) ; if ( sps -> video_signal_type_present_flag ) { sps -> video_format = gf_bs_read_int_log ( bs , 3 , ""video_format"" ) ; sps -> video_full_range_flag = gf_bs_read_int_log ( bs , 1 , ""video_full_range_flag"" ) ; if ( ( sps -> colour_description_present_flag = gf_bs_read_int_log ( bs , 1 , ""colour_description_present_flag"" ) ) ) { sps -> colour_primaries = gf_bs_read_int_log ( bs , 8 , ""colour_primaries"" ) ; sps -> transfer_characteristic = gf_bs_read_int_log ( bs , 8 , ""transfer_characteristic"" ) ; sps -> matrix_coeffs = gf_bs_read_int_log ( bs , 8 , ""matrix_coefficients"" ) ; } } if ( ( sps -> chroma_loc_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""chroma_loc_info_present_flag"" ) ) ) { sps -> chroma_sample_loc_type_top_field = gf_bs_read_ue_log ( bs , ""chroma_sample_loc_type_top_field"" ) ; sps -> chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log ( bs , ""chroma_sample_loc_type_bottom_field"" ) ; } sps -> neutra_chroma_indication_flag = gf_bs_read_int_log ( bs , 1 , ""neutra_chroma_indication_flag"" ) ; sps -> field_seq_flag = gf_bs_read_int_log ( bs , 1 , ""field_seq_flag"" ) ; sps -> frame_field_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""frame_field_info_present_flag"" ) ; if ( ( sps -> default_display_window_flag = gf_bs_read_int_log ( bs , 1 , ""default_display_window_flag"" ) ) ) { sps -> left_offset = gf_bs_read_ue_log ( bs , ""display_window_left_offset"" ) ; sps -> right_offset = gf_bs_read_ue_log ( bs , ""display_window_right_offset"" ) ; sps -> top_offset = gf_bs_read_ue_log ( bs , ""display_window_top_offset"" ) ; sps -> bottom_offset = gf_bs_read_ue_log ( bs , ""display_window_bottom_offset"" ) ; } sps -> has_timing_info = gf_bs_read_int_log ( bs , 1 , ""has_timing_info"" ) ; if ( sps -> has_timing_info ) { sps -> num_units_in_tick = gf_bs_read_int_log ( bs , 32 , ""num_units_in_tick"" ) ; sps -> time_scale = gf_bs_read_int_log ( bs , 32 , ""time_scale"" ) ; sps -> poc_proportional_to_timing_flag = gf_bs_read_int_log ( bs , 1 , ""poc_proportional_to_timing_flag"" ) ; if ( sps -> poc_proportional_to_timing_flag ) sps -> num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log ( bs , ""num_ticks_poc_diff_one_minus1"" ) ; if ( ( sps -> hrd_parameters_present_flag = gf_bs_read_int_log ( bs , 1 , ""hrd_parameters_present_flag"" ) ) ) { return sps_id ; } } if ( gf_bs_read_int_log ( bs , 1 , ""bitstream_restriction_flag"" ) ) { gf_bs_read_int_log ( bs , 1 , ""tiles_fixed_structure_flag"" ) ; gf_bs_read_int_log ( bs , 1 , ""motion_vectors_over_pic_boundaries_flag"" ) ; gf_bs_read_int_log ( bs , 1 , ""restricted_ref_pic_lists_flag"" ) ; gf_bs_read_ue_log ( bs , ""min_spatial_segmentation_idc"" ) ; gf_bs_read_ue_log ( bs , ""max_bytes_per_pic_denom"" ) ; gf_bs_read_ue_log ( bs , ""max_bits_per_min_cu_denom"" ) ; gf_bs_read_ue_log ( bs , ""log2_max_mv_length_horizontal"" ) ; gf_bs_read_ue_log ( bs , ""log2_max_mv_length_vertical"" ) ; } } if ( gf_bs_read_int_log ( bs , 1 , ""sps_extension_flag"" ) ) { # if 0 while ( gf_bs_available ( bs ) ) { gf_bs_read_int ( bs , 1 ) ; } # endif } return sps_id ; }","<S2SV_ModStart> ; if ( ( vps_id < 0 ) || ( <S2SV_ModStart> vps_id >= 16 )
",gpac@gpac/51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,CVE-2021-30022,https://github.com/gpac/gpac/commit/51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,2021-04-19T20:15Z,<S2SV_StartBug> if ( vps_id >= 16 ) { <S2SV_EndBug>
8373,CWE-362,"static int raw_sendmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipcm_cookie ipc ; struct rtable * rt = null ; int free = 0 ; __be32 daddr ; __be32 saddr ; u8 tos ; int err ; err = - emsgsize ; if ( len > 0xffff ) goto out ; err = - eopnotsupp ; if ( msg -> msg_flags & msg_oob ) goto out ; if ( msg -> msg_namelen ) { struct sockaddr_in * usin = ( struct sockaddr_in * ) msg -> msg_name ; err = - einval ; if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ; if ( usin -> sin_family != af_inet ) { static int complained ; if ( ! complained ++ ) printk ( kern_info ""%s<s2sv_blank>forgot<s2sv_blank>to<s2sv_blank>set<s2sv_blank>af_inet<s2sv_blank>in<s2sv_blank>"" ""raw<s2sv_blank>sendmsg.<s2sv_blank>fix<s2sv_blank>it!\\n"" , current -> comm ) ; err = - eafnosupport ; if ( usin -> sin_family ) goto out ; } daddr = usin -> sin_addr . s_addr ; } else { err = - edestaddrreq ; if ( sk -> sk_state != tcp_established ) goto out ; daddr = inet -> inet_daddr ; } ipc . addr = inet -> inet_saddr ; ipc . opt = null ; ipc . tx_flags = 0 ; ipc . oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sock_net ( sk ) , msg , & ipc ) ; if ( err ) goto out ; if ( ipc . opt ) free = 1 ; } saddr = ipc . addr ; ipc . addr = daddr ; if ( ! ipc . opt ) ipc . opt = inet -> opt ; if ( ipc . opt ) { err = - einval ; if ( inet -> hdrincl ) goto done ; if ( ipc . opt -> srr ) { if ( ! daddr ) goto done ; daddr = ipc . opt -> faddr ; } } tos = rt_conn_flags ( sk ) ; if ( msg -> msg_flags & msg_dontroute ) tos |= rto_onlink ; if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; } { struct flowi4 fl4 ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , rt_scope_universe , inet -> hdrincl ? ipproto_raw : sk -> sk_protocol , flowi_flag_can_sleep , daddr , saddr , 0 , 0 ) ; if ( ! inet -> hdrincl ) { err = raw_probe_proto_opt ( & fl4 , msg ) ; if ( err ) goto done ; } security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( sock_net ( sk ) , & fl4 , sk ) ; if ( is_err ( rt ) ) { err = ptr_err ( rt ) ; rt = null ; goto done ; } } err = - eacces ; if ( rt -> rt_flags & rtcf_broadcast && ! sock_flag ( sk , sock_broadcast ) ) goto done ; if ( msg -> msg_flags & msg_confirm ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = raw_send_hdrinc ( sk , msg -> msg_iov , len , & rt , msg -> msg_flags ) ; else { if ( ! ipc . addr ) ipc . addr = rt -> rt_dst ; lock_sock ( sk ) ; err = ip_append_data ( sk , ip_generic_getfrag , msg -> msg_iov , len , 0 , & ipc , & rt , msg -> msg_flags ) ; if ( err ) ip_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & msg_more ) ) { err = ip_push_pending_frames ( sk ) ; if ( err == - enobufs && ! inet -> recverr ) err = 0 ; } release_sock ( sk ) ; } done : if ( free ) kfree ( ipc . opt ) ; ip_rt_put ( rt ) ; out : if ( err < 0 ) return err ; return len ; do_confirm : dst_confirm ( & rt -> dst ) ; if ( ! ( msg -> msg_flags & msg_probe ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }","<S2SV_ModStart> int err ; struct ip_options_data opt_copy ; <S2SV_ModStart> . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } <S2SV_ModEnd> if ( ipc <S2SV_ModStart> . opt -> opt . <S2SV_ModStart> . opt -> opt .
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> <S2SV_StartBug> ipc . opt = inet -> opt ; <S2SV_EndBug> <S2SV_StartBug> if ( ipc . opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> daddr = ipc . opt -> faddr ; <S2SV_EndBug>
2208,CWE-000,"int iwch_cxgb3_ofld_send ( struct t3cdev * tdev , struct sk_buff * skb ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - eio ; } error = cxgb3_ofld_send ( tdev , skb ) ; if ( error < 0 ) kfree_skb ( skb ) ; return error ; }","<S2SV_ModStart> ; return error < 0 ? error : 0
",torvalds@linux/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3,CVE-2015-8812,https://github.com/torvalds/linux/commit/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3,2016-04-27T17:59Z,<S2SV_StartBug> return error ; <S2SV_EndBug>
4046,CWE-362,"static struct sock * dccp_v6_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * ireq6 = inet6_rsk ( req ) ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; struct ipv6_txoptions * opt ; if ( skb -> protocol == htons ( eth_p_ip ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst ) ; if ( newsk == null ) return null ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = null ; newnp -> opt = null ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( dst == null ) { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = ipproto_dccp ; ipv6_addr_copy ( & fl6 . daddr , & ireq6 -> rmt_addr ) ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; ipv6_addr_copy ( & fl6 . saddr , & ireq6 -> loc_addr ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = inet_rsk ( req ) -> rmt_port ; fl6 . fl6_sport = inet_rsk ( req ) -> loc_port ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p , false ) ; if ( is_err ( dst ) ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == null ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , null , null ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( netif_f_ip_csum | netif_f_tso ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & ireq6 -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & ireq6 -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & ireq6 -> loc_addr ) ; newsk -> sk_bound_dev_if = ireq6 -> iif ; newinet -> opt = null ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = null ; if ( ireq6 -> pktopts != null ) { newnp -> pktoptions = skb_clone ( ireq6 -> pktopts , gfp_atomic ) ; kfree_skb ( ireq6 -> pktopts ) ; ireq6 -> pktopts = null ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = null ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt != null ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt != null ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = loopback4_ipv6 ; newinet -> inet_rcv_saddr = loopback4_ipv6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , null ) ; return newsk ; out_overflow : net_inc_stats_bh ( sock_net ( sk ) , linux_mib_listenoverflows ) ; out_nonewsk : dst_release ( dst ) ; out : net_inc_stats_bh ( sock_net ( sk ) , linux_mib_listendrops ) ; if ( opt != null && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; return null ; }","<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug>
4552,CWE-125,"static int fstringparser_concatfstring ( fstringparser * state , const char * * str , const char * end , int raw , int recurse_lvl , struct compiling * c , const node * n ) { fstringparser_check_invariants ( state ) ; while ( 1 ) { pyobject * literal = null ; expr_ty expression = null ; int result = fstring_find_literal_and_expr ( str , end , raw , recurse_lvl , & literal , & expression , c , n ) ; if ( result < 0 ) return - 1 ; if ( ! literal ) { } else if ( ! state -> last_str ) { state -> last_str = literal ; literal = null ; } else { assert ( pyunicode_get_length ( literal ) != 0 ) ; if ( fstringparser_concatanddel ( state , literal ) < 0 ) return - 1 ; literal = null ; } assert ( ! state -> last_str || pyunicode_get_length ( state -> last_str ) != 0 ) ; assert ( literal == null ) ; if ( result == 1 ) continue ; if ( ! expression ) break ; if ( ! state -> last_str ) { } else { expr_ty str = make_str_node_and_del ( & state -> last_str , c , n ) ; if ( ! str || exprlist_append ( & state -> expr_list , str ) < 0 ) return - 1 ; } if ( exprlist_append ( & state -> expr_list , expression ) < 0 ) return - 1 ; } if ( recurse_lvl == 0 && * str < end - 1 ) { ast_error ( c , n , ""f-string:<s2sv_blank>unexpected<s2sv_blank>end<s2sv_blank>of<s2sv_blank>string"" ) ; return - 1 ; } if ( recurse_lvl != 0 && * * str != '}' ) { ast_error ( c , n , ""f-string:<s2sv_blank>expecting<s2sv_blank>\'}\'"" ) ; return - 1 ; } fstringparser_check_invariants ( state ) ; return 0 ; }","<S2SV_ModStart> state ) ; state -> fmode = 1 ; <S2SV_ModStart> } assert ( <S2SV_ModEnd> literal == NULL
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> while ( 1 ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! state -> last_str || <S2SV_EndBug>
4867,CWE-362,"static int mptctl_do_mpt_command ( struct mpt_ioctl_command karg , void __user * mfptr ) { mpt_adapter * ioc ; mpt_frame_hdr * mf = null ; mpiheader_t * hdr ; char * psge ; struct buflist bufin ; struct buflist bufout ; dma_addr_t dma_addr_in ; dma_addr_t dma_addr_out ; int sgsize = 0 ; int iocnum , flagslength ; int sz , rc = 0 ; int msgcontext ; u16 req_idx ; ulong timeout ; unsigned long timeleft ; struct scsi_device * sdev ; unsigned long flags ; u8 function ; bufin . kptr = bufout . kptr = null ; bufin . len = bufout . len = 0 ; if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == null ) ) { printk ( kern_debug mynam ""%s::mptctl_do_mpt_command()<s2sv_blank>@%d<s2sv_blank>-<s2sv_blank>ioc%d<s2sv_blank>not<s2sv_blank>found!\\n"" , __file__ , __line__ , iocnum ) ; return - enodev ; } spin_lock_irqsave ( & ioc -> taskmgmt_lock , flags ) ; if ( ioc -> ioc_reset_in_progress ) { spin_unlock_irqrestore ( & ioc -> taskmgmt_lock , flags ) ; printk ( kern_err mynam ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""busy<s2sv_blank>with<s2sv_blank>diagnostic<s2sv_blank>reset\\n"" , __file__ , __line__ ) ; return - ebusy ; } spin_unlock_irqrestore ( & ioc -> taskmgmt_lock , flags ) ; if ( karg . maxreplybytes < 0 || karg . datainsize < 0 || karg . dataoutsize < 0 || karg . datasgeoffset < 0 || karg . maxsensebytes < 0 || karg . datasgeoffset > ioc -> req_sz / 4 ) return - einval ; sz = karg . datasgeoffset * 4 ; if ( karg . datainsize > 0 ) sz += ioc -> sge_size ; if ( karg . dataoutsize > 0 ) sz += ioc -> sge_size ; if ( sz > ioc -> req_sz ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""request<s2sv_blank>frame<s2sv_blank>too<s2sv_blank>large<s2sv_blank>(%d)<s2sv_blank>maximum<s2sv_blank>(%d)\\n"" , ioc -> name , __file__ , __line__ , sz , ioc -> req_sz ) ; return - efault ; } if ( ( mf = mpt_get_msg_frame ( mptctl_id , ioc ) ) == null ) return - eagain ; hdr = ( mpiheader_t * ) mf ; msgcontext = le32_to_cpu ( hdr -> msgcontext ) ; req_idx = le16_to_cpu ( mf -> u . frame . hwhdr . msgctxu . fld . req_idx ) ; if ( copy_from_user ( mf , mfptr , karg . datasgeoffset * 4 ) ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>read<s2sv_blank>mf<s2sv_blank>from<s2sv_blank>mpt_ioctl_command<s2sv_blank>struct<s2sv_blank>@<s2sv_blank>%p\\n"" , ioc -> name , __file__ , __line__ , mfptr ) ; function = - 1 ; rc = - efault ; goto done_free_mem ; } hdr -> msgcontext = cpu_to_le32 ( msgcontext ) ; function = hdr -> function ; dctlprintk ( ioc , printk ( myioc_s_debug_fmt ""sending<s2sv_blank>mpi<s2sv_blank>function<s2sv_blank>(0x%02x),<s2sv_blank>req=%p\\n"" , ioc -> name , hdr -> function , mf ) ) ; switch ( function ) { case mpi_function_ioc_facts : case mpi_function_port_facts : karg . dataoutsize = karg . datainsize = 0 ; break ; case mpi_function_config : { config_t * config_frame ; config_frame = ( config_t * ) mf ; dctlprintk ( ioc , printk ( myioc_s_debug_fmt ""\\ttype=0x%02x<s2sv_blank>ext_type=0x%02x<s2sv_blank>"" ""number=0x%02x<s2sv_blank>action=0x%02x\\n"" , ioc -> name , config_frame -> header . pagetype , config_frame -> extpagetype , config_frame -> header . pagenumber , config_frame -> action ) ) ; break ; } case mpi_function_fc_common_transport_send : case mpi_function_fc_ex_link_srvc_send : case mpi_function_fw_upload : case mpi_function_scsi_enclosure_processor : case mpi_function_fw_download : case mpi_function_fc_primitive_send : case mpi_function_toolbox : case mpi_function_sas_io_unit_control : break ; case mpi_function_scsi_io_request : if ( ioc -> sh ) { scsiiorequest_t * pscsireq = ( scsiiorequest_t * ) mf ; int qtag = mpi_scsiio_control_untagged ; int scsidir = 0 ; int datasize ; u32 id ; id = ( ioc -> devices_per_bus == 0 ) ? 256 : ioc -> devices_per_bus ; if ( pscsireq -> targetid > id ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""target<s2sv_blank>id<s2sv_blank>out<s2sv_blank>of<s2sv_blank>bounds.<s2sv_blank>\\n"" , ioc -> name , __file__ , __line__ ) ; rc = - enodev ; goto done_free_mem ; } if ( pscsireq -> bus >= ioc -> number_of_buses ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""target<s2sv_blank>bus<s2sv_blank>out<s2sv_blank>of<s2sv_blank>bounds.<s2sv_blank>\\n"" , ioc -> name , __file__ , __line__ ) ; rc = - enodev ; goto done_free_mem ; } pscsireq -> msgflags &= ~ mpi_scsiio_msgflgs_sense_width ; pscsireq -> msgflags |= mpt_msg_flags ( ioc ) ; if ( karg . maxsensebytes > mpt_sense_buffer_size ) pscsireq -> sensebufferlength = mpt_sense_buffer_size ; else pscsireq -> sensebufferlength = karg . maxsensebytes ; pscsireq -> sensebufferlowaddr = cpu_to_le32 ( ioc -> sense_buf_low_dma + ( req_idx * mpt_sense_buffer_alloc ) ) ; shost_for_each_device ( sdev , ioc -> sh ) { struct scsi_target * starget = scsi_target ( sdev ) ; virttarget * vtarget = starget -> hostdata ; if ( vtarget == null ) continue ; if ( ( pscsireq -> targetid == vtarget -> id ) && ( pscsireq -> bus == vtarget -> channel ) && ( vtarget -> tflags & mpt_target_flags_q_yes ) ) qtag = mpi_scsiio_control_simpleq ; } if ( karg . dataoutsize > 0 ) { scsidir = mpi_scsiio_control_write ; datasize = karg . dataoutsize ; } else { scsidir = mpi_scsiio_control_read ; datasize = karg . datainsize ; } pscsireq -> control = cpu_to_le32 ( scsidir | qtag ) ; pscsireq -> datalength = cpu_to_le32 ( datasize ) ; } else { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""scsi<s2sv_blank>driver<s2sv_blank>is<s2sv_blank>not<s2sv_blank>loaded.<s2sv_blank>\\n"" , ioc -> name , __file__ , __line__ ) ; rc = - efault ; goto done_free_mem ; } break ; case mpi_function_smp_passthrough : break ; case mpi_function_sata_passthrough : if ( ! ioc -> sh ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""scsi<s2sv_blank>driver<s2sv_blank>is<s2sv_blank>not<s2sv_blank>loaded.<s2sv_blank>\\n"" , ioc -> name , __file__ , __line__ ) ; rc = - efault ; goto done_free_mem ; } break ; case mpi_function_raid_action : break ; case mpi_function_raid_scsi_io_passthrough : if ( ioc -> sh ) { scsiiorequest_t * pscsireq = ( scsiiorequest_t * ) mf ; int qtag = mpi_scsiio_control_simpleq ; int scsidir = mpi_scsiio_control_read ; int datasize ; pscsireq -> msgflags &= ~ mpi_scsiio_msgflgs_sense_width ; pscsireq -> msgflags |= mpt_msg_flags ( ioc ) ; if ( karg . maxsensebytes > mpt_sense_buffer_size ) pscsireq -> sensebufferlength = mpt_sense_buffer_size ; else pscsireq -> sensebufferlength = karg . maxsensebytes ; pscsireq -> sensebufferlowaddr = cpu_to_le32 ( ioc -> sense_buf_low_dma + ( req_idx * mpt_sense_buffer_alloc ) ) ; if ( karg . dataoutsize > 0 ) { scsidir = mpi_scsiio_control_write ; datasize = karg . dataoutsize ; } else { scsidir = mpi_scsiio_control_read ; datasize = karg . datainsize ; } pscsireq -> control = cpu_to_le32 ( scsidir | qtag ) ; pscsireq -> datalength = cpu_to_le32 ( datasize ) ; } else { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""scsi<s2sv_blank>driver<s2sv_blank>is<s2sv_blank>not<s2sv_blank>loaded.<s2sv_blank>\\n"" , ioc -> name , __file__ , __line__ ) ; rc = - efault ; goto done_free_mem ; } break ; case mpi_function_scsi_task_mgmt : { scsitaskmgmt_t * pscsitm ; pscsitm = ( scsitaskmgmt_t * ) mf ; dctlprintk ( ioc , printk ( myioc_s_debug_fmt ""\\ttasktype=0x%x<s2sv_blank>msgflags=0x%x<s2sv_blank>"" ""taskmsgcontext=0x%x<s2sv_blank>id=%d<s2sv_blank>channel=%d\\n"" , ioc -> name , pscsitm -> tasktype , le32_to_cpu ( pscsitm -> taskmsgcontext ) , pscsitm -> msgflags , pscsitm -> targetid , pscsitm -> bus ) ) ; break ; } case mpi_function_ioc_init : { iocinit_t * pinit = ( iocinit_t * ) mf ; u32 high_addr , sense_high ; if ( sizeof ( dma_addr_t ) == sizeof ( u64 ) ) { high_addr = cpu_to_le32 ( ( u32 ) ( ( u64 ) ioc -> req_frames_dma >> 32 ) ) ; sense_high = cpu_to_le32 ( ( u32 ) ( ( u64 ) ioc -> sense_buf_pool_dma >> 32 ) ) ; } else { high_addr = 0 ; sense_high = 0 ; } if ( ( pinit -> flags != 0 ) || ( pinit -> maxdevices != ioc -> facts . maxdevices ) || ( pinit -> maxbuses != ioc -> facts . maxbuses ) || ( pinit -> replyframesize != cpu_to_le16 ( ioc -> reply_sz ) ) || ( pinit -> hostmfahighaddr != high_addr ) || ( pinit -> sensebufferhighaddr != sense_high ) ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""ioc_init<s2sv_blank>issued<s2sv_blank>with<s2sv_blank>1<s2sv_blank>or<s2sv_blank>more<s2sv_blank>incorrect<s2sv_blank>parameters.<s2sv_blank>rejected.\\n"" , ioc -> name , __file__ , __line__ ) ; rc = - efault ; goto done_free_mem ; } } break ; default : printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""illegal<s2sv_blank>request<s2sv_blank>(function<s2sv_blank>0x%x)<s2sv_blank>\\n"" , ioc -> name , __file__ , __line__ , hdr -> function ) ; rc = - efault ; goto done_free_mem ; } psge = ( char * ) ( ( ( int * ) mf ) + karg . datasgeoffset ) ; flagslength = 0 ; if ( karg . dataoutsize > 0 ) sgsize ++ ; if ( karg . datainsize > 0 ) sgsize ++ ; if ( sgsize > 0 ) { if ( karg . dataoutsize > 0 ) { if ( karg . datainsize > 0 ) { flagslength = ( mpi_sge_flags_simple_element | mpi_sge_flags_end_of_buffer | mpi_sge_flags_direction ) << mpi_sge_flags_shift ; } else { flagslength = mpt_sge_flags_ssimple_write ; } flagslength |= karg . dataoutsize ; bufout . len = karg . dataoutsize ; bufout . kptr = pci_alloc_consistent ( ioc -> pcidev , bufout . len , & dma_addr_out ) ; if ( bufout . kptr == null ) { rc = - enomem ; goto done_free_mem ; } else { ioc -> add_sge ( psge , flagslength , dma_addr_out ) ; psge += ioc -> sge_size ; if ( copy_from_user ( bufout . kptr , karg . dataoutbufptr , bufout . len ) ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>unable<s2sv_blank>"" ""to<s2sv_blank>read<s2sv_blank>user<s2sv_blank>data<s2sv_blank>"" ""struct<s2sv_blank>@<s2sv_blank>%p\\n"" , ioc -> name , __file__ , __line__ , karg . dataoutbufptr ) ; rc = - efault ; goto done_free_mem ; } } } if ( karg . datainsize > 0 ) { flagslength = mpt_sge_flags_ssimple_read ; flagslength |= karg . datainsize ; bufin . len = karg . datainsize ; bufin . kptr = pci_alloc_consistent ( ioc -> pcidev , bufin . len , & dma_addr_in ) ; if ( bufin . kptr == null ) { rc = - enomem ; goto done_free_mem ; } else { ioc -> add_sge ( psge , flagslength , dma_addr_in ) ; } } } else { ioc -> add_sge ( psge , flagslength , ( dma_addr_t ) - 1 ) ; } set_mgmt_msg_context ( ioc -> ioctl_cmds . msg_context , hdr -> msgcontext ) ; initialize_mgmt_status ( ioc -> ioctl_cmds . status ) if ( hdr -> function == mpi_function_scsi_task_mgmt ) { mutex_lock ( & ioc -> taskmgmt_cmds . mutex ) ; if ( mpt_set_taskmgmt_in_progress_flag ( ioc ) != 0 ) { mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; goto done_free_mem ; } dbg_dump_tm_request_frame ( ioc , ( u32 * ) mf ) ; if ( ( ioc -> facts . ioccapabilities & mpi_iocfacts_capability_high_pri_q ) && ( ioc -> facts . msgversion >= mpi_version_01_05 ) ) mpt_put_msg_frame_hi_pri ( mptctl_id , ioc , mf ) ; else { rc = mpt_send_handshake_request ( mptctl_id , ioc , sizeof ( scsitaskmgmt_t ) , ( u32 * ) mf , can_sleep ) ; if ( rc != 0 ) { dfailprintk ( ioc , printk ( myioc_s_err_fmt ""send_handshake<s2sv_blank>failed!<s2sv_blank>(ioc<s2sv_blank>%p,<s2sv_blank>mf<s2sv_blank>%p)\\n"" , ioc -> name , ioc , mf ) ) ; mpt_clear_taskmgmt_in_progress_flag ( ioc ) ; rc = - enodata ; mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; goto done_free_mem ; } } } else mpt_put_msg_frame ( mptctl_id , ioc , mf ) ; timeout = ( karg . timeout > 0 ) ? karg . timeout : mpt_ioctl_default_timeout ; retry_wait : timeleft = wait_for_completion_timeout ( & ioc -> ioctl_cmds . done , hz * timeout ) ; if ( ! ( ioc -> ioctl_cmds . status & mpt_mgmt_status_command_good ) ) { rc = - etime ; dfailprintk ( ioc , printk ( myioc_s_err_fmt ""%s:<s2sv_blank>timed<s2sv_blank>out!\\n"" , ioc -> name , __func__ ) ) ; if ( ioc -> ioctl_cmds . status & mpt_mgmt_status_did_iocreset ) { if ( function == mpi_function_scsi_task_mgmt ) mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; goto done_free_mem ; } if ( ! timeleft ) { printk ( myioc_s_warn_fmt ""mpt<s2sv_blank>cmd<s2sv_blank>timeout,<s2sv_blank>doorbell=0x%08x"" ""<s2sv_blank>function=0x%x\\n"" , ioc -> name , mpt_getiocstate ( ioc , 0 ) , function ) ; if ( function == mpi_function_scsi_task_mgmt ) mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; mptctl_timeout_expired ( ioc , mf ) ; mf = null ; } else goto retry_wait ; goto done_free_mem ; } if ( function == mpi_function_scsi_task_mgmt ) mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; mf = null ; if ( ioc -> ioctl_cmds . status & mpt_mgmt_status_rf_valid ) { if ( karg . maxreplybytes < ioc -> reply_sz ) { sz = min ( karg . maxreplybytes , 4 * ioc -> ioctl_cmds . reply [ 2 ] ) ; } else { sz = min ( ioc -> reply_sz , 4 * ioc -> ioctl_cmds . reply [ 2 ] ) ; } if ( sz > 0 ) { if ( copy_to_user ( karg . replyframebufptr , ioc -> ioctl_cmds . reply , sz ) ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>write<s2sv_blank>out<s2sv_blank>reply<s2sv_blank>frame<s2sv_blank>%p\\n"" , ioc -> name , __file__ , __line__ , karg . replyframebufptr ) ; rc = - enodata ; goto done_free_mem ; } } } if ( ioc -> ioctl_cmds . status & mpt_mgmt_status_sense_valid ) { sz = min ( karg . maxsensebytes , mpt_sense_buffer_size ) ; if ( sz > 0 ) { if ( copy_to_user ( karg . sensedataptr , ioc -> ioctl_cmds . sense , sz ) ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>write<s2sv_blank>sense<s2sv_blank>data<s2sv_blank>to<s2sv_blank>user<s2sv_blank>%p\\n"" , ioc -> name , __file__ , __line__ , karg . sensedataptr ) ; rc = - enodata ; goto done_free_mem ; } } } if ( ( ioc -> ioctl_cmds . status & mpt_mgmt_status_command_good ) && ( karg . datainsize > 0 ) && ( bufin . kptr ) ) { if ( copy_to_user ( karg . datainbufptr , bufin . kptr , karg . datainsize ) ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_do_mpt_command<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>write<s2sv_blank>data<s2sv_blank>to<s2sv_blank>user<s2sv_blank>%p\\n"" , ioc -> name , __file__ , __line__ , karg . datainbufptr ) ; rc = - enodata ; } } done_free_mem : clear_mgmt_status ( ioc -> ioctl_cmds . status ) set_mgmt_msg_context ( ioc -> ioctl_cmds . msg_context , 0 ) ; if ( bufout . kptr != null ) { pci_free_consistent ( ioc -> pcidev , bufout . len , ( void * ) bufout . kptr , dma_addr_out ) ; } if ( bufin . kptr != null ) { pci_free_consistent ( ioc -> pcidev , bufin . len , ( void * ) bufin . kptr , dma_addr_in ) ; } if ( mf ) mpt_free_msg_frame ( ioc , mf ) ; return rc ; }","<S2SV_ModStart> int mptctl_do_mpt_command ( MPT_ADAPTER * ioc , <S2SV_ModStart> mfPtr ) { <S2SV_ModEnd> MPT_FRAME_HDR * mf <S2SV_ModStart> 0 ; int <S2SV_ModEnd> flagsLength ; int <S2SV_ModStart> = 0 ; <S2SV_ModEnd> spin_lock_irqsave ( &
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,"<S2SV_StartBug> mptctl_do_mpt_command ( struct mpt_ioctl_command karg , void __user * mfPtr ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> int iocnum , flagsLength ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug>"
6346,CWE-772,"generic_ret * modify_principal_2_svc ( mprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; gss_buffer_desc client_name , service_name ; om_uint32 minor_stat ; kadm5_server_handle_t handle ; restriction_t * rp ; const char * errmsg = null ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = kadm5_failure ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> rec . principal , & prime_arg ) ) { ret . code = kadm5_bad_principal ; goto exit_func ; } if ( changepw_service ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , acl_modify , arg -> rec . principal , & rp ) || kadm5int_acl_impose_restrictions ( handle -> context , & arg -> rec , & arg -> mask , rp ) ) { ret . code = kadm5_auth_modify ; log_unauth ( ""kadm5_modify_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_modify_principal ( ( void * ) handle , & arg -> rec , arg -> mask ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_modify_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != null ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug>"
2740,CWE-399,"static void free_huge_page ( struct page * page ) { struct hstate * h = page_hstate ( page ) ; int nid = page_to_nid ( page ) ; struct address_space * mapping ; mapping = ( struct address_space * ) page_private ( page ) ; set_page_private ( page , 0 ) ; page -> mapping = null ; bug_on ( page_count ( page ) ) ; bug_on ( page_mapcount ( page ) ) ; init_list_head ( & page -> lru ) ; spin_lock ( & hugetlb_lock ) ; if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < max_order ) { update_and_free_page ( h , page ) ; h -> surplus_huge_pages -- ; h -> surplus_huge_pages_node [ nid ] -- ; } else { enqueue_huge_page ( h , page ) ; } spin_unlock ( & hugetlb_lock ) ; if ( mapping ) hugetlb_put_quota ( mapping , 1 ) ; }","<S2SV_ModStart> ) ; struct hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> * ) page_private <S2SV_ModStart> hugetlb_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , 1 )
",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z,<S2SV_StartBug> struct address_space * mapping ; <S2SV_EndBug> <S2SV_StartBug> if ( mapping ) <S2SV_EndBug>
3695,CWE-399,"static long vhost_net_set_backend ( struct vhost_net * n , unsigned index , int fd ) { struct socket * sock , * oldsock ; struct vhost_virtqueue * vq ; struct vhost_net_virtqueue * nvq ; struct vhost_net_ubuf_ref * ubufs , * oldubufs = null ; int r ; mutex_lock ( & n -> dev . mutex ) ; r = vhost_dev_check_owner ( & n -> dev ) ; if ( r ) goto err ; if ( index >= vhost_net_vq_max ) { r = - enobufs ; goto err ; } vq = & n -> vqs [ index ] . vq ; nvq = & n -> vqs [ index ] ; mutex_lock ( & vq -> mutex ) ; if ( ! vhost_vq_access_ok ( vq ) ) { r = - efault ; goto err_vq ; } sock = get_socket ( fd ) ; if ( is_err ( sock ) ) { r = ptr_err ( sock ) ; goto err_vq ; } oldsock = rcu_dereference_protected ( vq -> private_data , lockdep_is_held ( & vq -> mutex ) ) ; if ( sock != oldsock ) { ubufs = vhost_net_ubuf_alloc ( vq , sock && vhost_sock_zcopy ( sock ) ) ; if ( is_err ( ubufs ) ) { r = ptr_err ( ubufs ) ; goto err_ubufs ; } vhost_net_disable_vq ( n , vq ) ; rcu_assign_pointer ( vq -> private_data , sock ) ; r = vhost_init_used ( vq ) ; if ( r ) goto err_used ; r = vhost_net_enable_vq ( n , vq ) ; if ( r ) goto err_used ; oldubufs = nvq -> ubufs ; nvq -> ubufs = ubufs ; n -> tx_packets = 0 ; n -> tx_zcopy_err = 0 ; n -> tx_flush = false ; } mutex_unlock ( & vq -> mutex ) ; if ( oldubufs ) { vhost_net_ubuf_put_and_wait ( oldubufs ) ; mutex_lock ( & vq -> mutex ) ; vhost_zerocopy_signal_used ( n , vq ) ; mutex_unlock ( & vq -> mutex ) ; } if ( oldsock ) { vhost_net_flush_vq ( n , index ) ; fput ( oldsock -> file ) ; } mutex_unlock ( & n -> dev . mutex ) ; return 0 ; err_used : rcu_assign_pointer ( vq -> private_data , oldsock ) ; vhost_net_enable_vq ( n , vq ) ; if ( ubufs ) vhost_net_ubuf_put_and_wait ( ubufs ) ; err_ubufs : fput ( sock -> file ) ; err_vq : mutex_unlock ( & vq -> mutex ) ; err : mutex_unlock ( & n -> dev . mutex ) ; return r ; }","<S2SV_ModStart> oldubufs ) { vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( oldubufs ) <S2SV_ModStart> ( ubufs ) vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( ubufs )
",torvalds@linux/dd7633ecd553a5e304d349aa6f8eb8a0417098c5,CVE-2013-4127,https://github.com/torvalds/linux/commit/dd7633ecd553a5e304d349aa6f8eb8a0417098c5,2013-07-29T13:59Z,<S2SV_StartBug> vhost_net_ubuf_put_and_wait ( oldubufs ) ; <S2SV_EndBug> <S2SV_StartBug> vhost_net_ubuf_put_and_wait ( ubufs ) ; <S2SV_EndBug>
6558,CWE-119,"static char * print_string_ptr ( const char * str ) { const char * ptr ; char * ptr2 , * out ; int len = 0 ; unsigned char token ; if ( ! str ) return cjson_strdup ( """" ) ; ptr = str ; while ( ( token = * ptr ) && ++ len ) { if ( strchr ( ""\\""\\\\\\b\\f\\n\\r\\t"" , token ) ) ++ len ; else if ( token < 32 ) len += 5 ; ++ ptr ; } if ( ! ( out = ( char * ) cjson_malloc ( len + 3 ) ) ) return 0 ; ptr2 = out ; ptr = str ; * ptr2 ++ = \'\\""\' ; while ( * ptr ) { if ( ( unsigned char ) * ptr > 31 && * ptr != \'\\""\' && * ptr != '\\\\' ) * ptr2 ++ = * ptr ++ ; else { * ptr2 ++ = '\\\\' ; switch ( token = * ptr ++ ) { case '\\\\' : * ptr2 ++ = '\\\\' ; break ; case \'\\""\' : * ptr2 ++ = \'\\""\' ; break ; case '\\b' : * ptr2 ++ = 'b' ; break ; case '\\f' : * ptr2 ++ = 'f' ; break ; case '\\n' : * ptr2 ++ = 'n' ; break ; case '\\r' : * ptr2 ++ = 'r' ; break ; case '\\t' : * ptr2 ++ = 't' ; break ; default : sprintf ( ptr2 , ""u%04x"" , token ) ; ptr2 += 5 ; break ; } } } * ptr2 ++ = \'\\""\' ; * ptr2 ++ = 0 ; return out ; }","<S2SV_ModStart> char * str , printbuffer * p <S2SV_ModStart> * ptr ; char * ptr2 , * out ; <S2SV_ModEnd> int len = <S2SV_ModStart> len = 0 , flag = 0 ; <S2SV_ModEnd> unsigned char token <S2SV_ModStart> ! str ) { if ( p ) out = ensure ( p , 3 ) ; else out = ( char * ) cJSON_malloc ( 3 ) ; if ( ! out ) return 0 ; strcpy ( out , ""\\""\\"""" ) ; return out ; } for ( ptr = str ; * ptr ; ptr ++ ) flag |= ( ( * ptr > 0 && * ptr < 32 ) || ( * ptr == \'\\""\' ) || ( * ptr == '\\\\' ) ) ? 1 : 0 ; if ( ! flag ) { len = ptr - str ; if ( p ) out = ensure ( p , len + 3 ) ; else out = ( char * ) cJSON_malloc ( len + 3 ) ; if ( ! out ) return 0 ; ptr2 = out ; * ptr2 ++ = \'\\""\' ; strcpy ( ptr2 , str ) ; ptr2 [ len ] = \'\\""\' ; ptr2 [ len + 1 ] = 0 ; return out ; } ptr = str ; <S2SV_ModEnd> while ( ( <S2SV_ModStart> token ) ) len ++ ; <S2SV_ModEnd> else if ( <S2SV_ModStart> += 5 ; ptr ++ ; } if ( p ) out = ensure ( p , <S2SV_ModEnd> len + 3 <S2SV_ModStart> + 3 ) ; else out = ( char * ) cJSON_malloc ( len + 3 ) ; if ( ! out ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> += 5 ; break ; } } } * ptr2 ++ = \'\\""\' ; <S2SV_ModEnd> * ptr2 ++
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,"<S2SV_StartBug> static char * print_string_ptr ( const char * str ) <S2SV_EndBug> <S2SV_StartBug> char * ptr2 , * out ; <S2SV_EndBug> <S2SV_StartBug> int len = 0 ; <S2SV_EndBug> <S2SV_StartBug> return cJSON_strdup ( """" ) ; <S2SV_EndBug> <S2SV_StartBug> ++ len ; <S2SV_EndBug> <S2SV_StartBug> ++ ptr ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( out = ( char * ) cJSON_malloc ( len + 3 ) ) ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug>"
2490,CWE-000,"static void unix_release_sock ( struct sock * sk , int embrion ) { struct unix_sock * u = unix_sk ( sk ) ; struct path path ; struct sock * skpair ; struct sk_buff * skb ; int state ; unix_remove_socket ( sk ) ; unix_state_lock ( sk ) ; sock_orphan ( sk ) ; sk -> sk_shutdown = shutdown_mask ; path = u -> path ; u -> path . dentry = null ; u -> path . mnt = null ; state = sk -> sk_state ; sk -> sk_state = tcp_close ; unix_state_unlock ( sk ) ; wake_up_interruptible_all ( & u -> peer_wait ) ; skpair = unix_peer ( sk ) ; if ( skpair != null ) { if ( sk -> sk_type == sock_stream || sk -> sk_type == sock_seqpacket ) { unix_state_lock ( skpair ) ; skpair -> sk_shutdown = shutdown_mask ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || embrion ) skpair -> sk_err = econnreset ; unix_state_unlock ( skpair ) ; skpair -> sk_state_change ( skpair ) ; sk_wake_async ( skpair , sock_wake_waitd , poll_hup ) ; } sock_put ( skpair ) ; unix_peer ( sk ) = null ; } while ( ( skb = skb_dequeue ( & sk -> sk_receive_queue ) ) != null ) { if ( state == tcp_listen ) unix_release_sock ( skb -> sk , 1 ) ; unixcb ( skb ) . consumed = skb -> len ; kfree_skb ( skb ) ; } if ( path . dentry ) path_put ( & path ) ; sock_put ( sk ) ; if ( unix_tot_inflight ) unix_gc ( ) ; }","<S2SV_ModStart> ) ; } unix_dgram_peer_wake_disconnect ( sk , skpair ) ;
",torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c,CVE-2013-7446,https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c,2015-12-28T11:59Z,<S2SV_StartBug> sock_put ( skpair ) ; <S2SV_EndBug>
2467,CWE-119,"static void unqueue_me_pi ( struct futex_q * q ) { warn_on ( plist_node_empty ( & q -> list ) ) ; plist_del ( & q -> list , & q -> list . plist ) ; bug_on ( ! q -> pi_state ) ; free_pi_state ( q -> pi_state ) ; q -> pi_state = null ; spin_unlock ( q -> lock_ptr ) ; drop_futex_key_refs ( & q -> key ) ; }","<S2SV_ModStart> lock_ptr ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/7ada876a8703f23befbb20a7465a702ee39b1704,CVE-2014-0205,https://github.com/torvalds/linux/commit/7ada876a8703f23befbb20a7465a702ee39b1704,2014-09-28T19:55Z,<S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug>
5366,CWE-401,"static int8_t parse_ext_option ( uint16_t * dst , uint8_t * * packet_data_pptr , uint8_t * packet_data_start_ptr , uint16_t packet_len , uint16_t * message_left ) { uint16_t option_number = * dst ; if ( option_number == 13 ) { uint8_t option_ext ; int8_t read_result = sn_coap_parser_read_packet_u8 ( & option_ext , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( ""sn_coap_parser_options_parse<s2sv_blank>-<s2sv_blank>**packet_data_pptr<s2sv_blank>overflow<s2sv_blank>!"" ) ; return - 1 ; } else { option_number += option_ext ; * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; } } else if ( option_number == 14 ) { int8_t read_result = sn_coap_parser_read_packet_u16 ( & option_number , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( ""sn_coap_parser_options_parse<s2sv_blank>-<s2sv_blank>**packet_data_pptr<s2sv_blank>overflow<s2sv_blank>!"" ) ; return - 1 ; } else { option_number += 269 ; * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 2 ) ; } } else if ( option_number == 15 ) { tr_error ( ""sn_coap_parser_options_parse<s2sv_blank>-<s2sv_blank>invalid<s2sv_blank>option<s2sv_blank>number(15)!"" ) ; return - 1 ; } * dst = option_number ; return 0 ; }","<S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , option_ext , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left = <S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , 269 , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left =
",mjurczak@mbed-coap/4647a68e364401e81dbd370728127d844f221d93,CVE-2020-12887,https://github.com/mjurczak/mbed-coap/commit/4647a68e364401e81dbd370728127d844f221d93,2020-06-18T19:15Z,<S2SV_StartBug> option_number += option_ext ; <S2SV_EndBug> <S2SV_StartBug> option_number += 269 ; <S2SV_EndBug>
3885,CWE-264,"static int multipath_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct multipath * m = ( struct multipath * ) ti -> private ; struct block_device * bdev = null ; fmode_t mode = 0 ; unsigned long flags ; int r = 0 ; spin_lock_irqsave ( & m -> lock , flags ) ; if ( ! m -> current_pgpath ) __choose_pgpath ( m , 0 ) ; if ( m -> current_pgpath ) { bdev = m -> current_pgpath -> path . dev -> bdev ; mode = m -> current_pgpath -> path . dev -> mode ; } if ( m -> queue_io ) r = - eagain ; else if ( ! bdev ) r = - eio ; spin_unlock_irqrestore ( & m -> lock , flags ) ; return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; }","<S2SV_ModStart> flags ) ; if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;
",torvalds@linux/ec8013beddd717d1740cfefb1a9b900deef85462,CVE-2011-4127,https://github.com/torvalds/linux/commit/ec8013beddd717d1740cfefb1a9b900deef85462,2012-07-03T16:40Z,"<S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug>"
7743,CWE-000,"static struct nfs4_state * nfs4_opendata_to_nfs4_state ( struct nfs4_opendata * data ) { struct inode * inode ; struct nfs4_state * state = null ; struct nfs_delegation * delegation ; int ret ; if ( ! data -> rpc_done ) { state = nfs4_try_open_cached ( data ) ; goto out ; } ret = - eagain ; if ( ! ( data -> f_attr . valid & nfs_attr_fattr ) ) goto err ; inode = nfs_fhget ( data -> dir -> d_sb , & data -> o_res . fh , & data -> f_attr ) ; ret = ptr_err ( inode ) ; if ( is_err ( inode ) ) goto err ; ret = - enomem ; state = nfs4_get_open_state ( inode , data -> owner ) ; if ( state == null ) goto err_put_inode ; if ( data -> o_res . delegation_type != 0 ) { int delegation_flags = 0 ; rcu_read_lock ( ) ; delegation = rcu_dereference ( nfs_i ( inode ) -> delegation ) ; if ( delegation ) delegation_flags = delegation -> flags ; rcu_read_unlock ( ) ; if ( ( delegation_flags & 1ul << nfs_delegation_need_reclaim ) == 0 ) nfs_inode_set_delegation ( state -> inode , data -> owner -> so_cred , & data -> o_res ) ; else nfs_inode_reclaim_delegation ( state -> inode , data -> owner -> so_cred , & data -> o_res ) ; } update_open_stateid ( state , & data -> o_res . stateid , null , data -> o_arg . open_flags ) ; iput ( inode ) ; out : return state ; err_put_inode : iput ( inode ) ; err : return err_ptr ( ret ) ; }","<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; iput
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,<S2SV_StartBug> data -> o_arg . open_flags ) ; <S2SV_EndBug>
8233,CWE-200,"void add_interrupt_randomness ( int irq , int irq_flags ) { struct entropy_store * r ; struct fast_pool * fast_pool = this_cpu_ptr ( & irq_randomness ) ; struct pt_regs * regs = get_irq_regs ( ) ; unsigned long now = jiffies ; cycles_t cycles = random_get_entropy ( ) ; __u32 c_high , j_high ; __u64 ip ; unsigned long seed ; int credit = 0 ; if ( cycles == 0 ) cycles = get_reg ( fast_pool , regs ) ; c_high = ( sizeof ( cycles ) > 4 ) ? cycles >> 32 : 0 ; j_high = ( sizeof ( now ) > 4 ) ? now >> 32 : 0 ; fast_pool -> pool [ 0 ] ^= cycles ^ j_high ^ irq ; fast_pool -> pool [ 1 ] ^= now ^ c_high ; ip = regs ? instruction_pointer ( regs ) : _ret_ip_ ; fast_pool -> pool [ 2 ] ^= ip ; fast_pool -> pool [ 3 ] ^= ( sizeof ( ip ) > 4 ) ? ip >> 32 : get_reg ( fast_pool , regs ) ; fast_mix ( fast_pool ) ; add_interrupt_bench ( cycles ) ; if ( unlikely ( crng_init == 0 ) ) { if ( ( fast_pool -> count >= 64 ) && crng_fast_load ( ( char * ) fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ) { fast_pool -> count = 0 ; fast_pool -> last = now ; } return ; } if ( ( fast_pool -> count < 64 ) && ! time_after ( now , fast_pool -> last + hz ) ) return ; r = & input_pool ; if ( ! spin_trylock ( & r -> lock ) ) return ; fast_pool -> last = now ; __mix_pool_bytes ( r , & fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ; if ( arch_get_random_seed_long ( & seed ) ) { __mix_pool_bytes ( r , & seed , sizeof ( seed ) ) ; credit = 1 ; } spin_unlock ( & r -> lock ) ; fast_pool -> count = 0 ; credit_entropy_bits ( r , credit + 1 ) ; }","<S2SV_ModStart> cycles ) ; this_cpu_add ( net_rand_state . s1 , fast_pool -> pool [ cycles & 3 ] ) ;
",torvalds@linux/f227e3ec3b5cad859ad15666874405e8c1bbc1d4,CVE-2020-16166,https://github.com/torvalds/linux/commit/f227e3ec3b5cad859ad15666874405e8c1bbc1d4,2020-07-30T21:15Z,<S2SV_StartBug> if ( unlikely ( crng_init == 0 ) ) { <S2SV_EndBug>
5155,CWE-674,"static void renamecolumnfunc ( sqlite3_context * context , int notused , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; renamectx sctx ; const char * zsql = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zdb = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * ztable = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; int icol = sqlite3_value_int ( argv [ 5 ] ) ; const char * znew = ( const char * ) sqlite3_value_text ( argv [ 6 ] ) ; int bquote = sqlite3_value_int ( argv [ 7 ] ) ; int btemp = sqlite3_value_int ( argv [ 8 ] ) ; const char * zold ; int rc ; parse sparse ; walker swalker ; index * pidx ; int i ; table * ptab ; # ifndef sqlite_omit_authorization sqlite3_xauth xauth = db -> xauth ; # endif unused_parameter ( notused ) ; if ( zsql == 0 ) return ; if ( ztable == 0 ) return ; if ( znew == 0 ) return ; if ( icol < 0 ) return ; sqlite3btreeenterall ( db ) ; ptab = sqlite3findtable ( db , ztable , zdb ) ; if ( ptab == 0 || icol >= ptab -> ncol ) { sqlite3btreeleaveall ( db ) ; return ; } zold = ptab -> acol [ icol ] . zname ; memset ( & sctx , 0 , sizeof ( sctx ) ) ; sctx . icol = ( ( icol == ptab -> ipkey ) ? - 1 : icol ) ; # ifndef sqlite_omit_authorization db -> xauth = 0 ; # endif rc = renameparsesql ( & sparse , zdb , 0 , db , zsql , btemp ) ; memset ( & swalker , 0 , sizeof ( walker ) ) ; swalker . pparse = & sparse ; swalker . xexprcallback = renamecolumnexprcb ; swalker . xselectcallback = renamecolumnselectcb ; swalker . u . prename = & sctx ; sctx . ptab = ptab ; if ( rc != sqlite_ok ) goto renamecolumnfunc_done ; if ( sparse . pnewtable ) { select * pselect = sparse . pnewtable -> pselect ; if ( pselect ) { sparse . rc = sqlite_ok ; sqlite3selectprep ( & sparse , sparse . pnewtable -> pselect , 0 ) ; rc = ( db -> mallocfailed ? sqlite_nomem : sparse . rc ) ; if ( rc == sqlite_ok ) { sqlite3walkselect ( & swalker , pselect ) ; } if ( rc != sqlite_ok ) goto renamecolumnfunc_done ; } else { int bfkonly = sqlite3_stricmp ( ztable , sparse . pnewtable -> zname ) ; fkey * pfkey ; assert ( sparse . pnewtable -> pselect == 0 ) ; sctx . ptab = sparse . pnewtable ; if ( bfkonly == 0 ) { renametokenfind ( & sparse , & sctx , ( void * ) sparse . pnewtable -> acol [ icol ] . zname ) ; if ( sctx . icol < 0 ) { renametokenfind ( & sparse , & sctx , ( void * ) & sparse . pnewtable -> ipkey ) ; } sqlite3walkexprlist ( & swalker , sparse . pnewtable -> pcheck ) ; for ( pidx = sparse . pnewtable -> pindex ; pidx ; pidx = pidx -> pnext ) { sqlite3walkexprlist ( & swalker , pidx -> acolexpr ) ; } for ( pidx = sparse . pnewindex ; pidx ; pidx = pidx -> pnext ) { sqlite3walkexprlist ( & swalker , pidx -> acolexpr ) ; } } # ifndef sqlite_omit_generated_columns for ( i = 0 ; i < sparse . pnewtable -> ncol ; i ++ ) { sqlite3walkexpr ( & swalker , sparse . pnewtable -> acol [ i ] . pdflt ) ; } # endif for ( pfkey = sparse . pnewtable -> pfkey ; pfkey ; pfkey = pfkey -> pnextfrom ) { for ( i = 0 ; i < pfkey -> ncol ; i ++ ) { if ( bfkonly == 0 && pfkey -> acol [ i ] . ifrom == icol ) { renametokenfind ( & sparse , & sctx , ( void * ) & pfkey -> acol [ i ] ) ; } if ( 0 == sqlite3_stricmp ( pfkey -> zto , ztable ) && 0 == sqlite3_stricmp ( pfkey -> acol [ i ] . zcol , zold ) ) { renametokenfind ( & sparse , & sctx , ( void * ) pfkey -> acol [ i ] . zcol ) ; } } } } } else if ( sparse . pnewindex ) { sqlite3walkexprlist ( & swalker , sparse . pnewindex -> acolexpr ) ; sqlite3walkexpr ( & swalker , sparse . pnewindex -> ppartidxwhere ) ; } else { triggerstep * pstep ; rc = renameresolvetrigger ( & sparse , ( btemp ? 0 : zdb ) ) ; if ( rc != sqlite_ok ) goto renamecolumnfunc_done ; for ( pstep = sparse . pnewtrigger -> step_list ; pstep ; pstep = pstep -> pnext ) { if ( pstep -> ztarget ) { table * ptarget = sqlite3locatetable ( & sparse , 0 , pstep -> ztarget , zdb ) ; if ( ptarget == ptab ) { if ( pstep -> pupsert ) { exprlist * pupsertset = pstep -> pupsert -> pupsertset ; renamecolumnelistnames ( & sparse , & sctx , pupsertset , zold ) ; } renamecolumnidlistnames ( & sparse , & sctx , pstep -> pidlist , zold ) ; renamecolumnelistnames ( & sparse , & sctx , pstep -> pexprlist , zold ) ; } } } if ( sparse . ptriggertab == ptab ) { renamecolumnidlistnames ( & sparse , & sctx , sparse . pnewtrigger -> pcolumns , zold ) ; } renamewalktrigger ( & swalker , sparse . pnewtrigger ) ; } assert ( rc == sqlite_ok ) ; rc = renameeditsql ( context , & sctx , zsql , znew , bquote ) ; renamecolumnfunc_done : if ( rc != sqlite_ok ) { if ( sparse . zerrmsg ) { renamecolumnparseerror ( context , 0 , argv [ 1 ] , argv [ 2 ] , & sparse ) ; } else { sqlite3_result_error_code ( context , rc ) ; } } renameparsecleanup ( & sparse ) ; renametokenfree ( db , sctx . plist ) ; # ifndef sqlite_omit_authorization db -> xauth = xauth ; # endif sqlite3btreeleaveall ( db ) ; }","<S2SV_ModStart> pSelect ) { pSelect -> selFlags &= ~ SF_View ; <S2SV_ModStart> & sParse , <S2SV_ModEnd> pSelect , 0
",sqlite@sqlite/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,CVE-2019-19645,https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,2019-12-09T16:15Z,"<S2SV_StartBug> sParse . rc = SQLITE_OK ; <S2SV_EndBug> <S2SV_StartBug> sqlite3SelectPrep ( & sParse , sParse . pNewTable -> pSelect , 0 ) ; <S2SV_EndBug>"
275,CWE-20,"static gboolean parse_netscreen_packet ( file_t fh , struct wtap_pkthdr * phdr , buffer * buf , char * line , int * err , gchar * * err_info ) { int sec ; int dsec ; char cap_int [ netscreen_max_int_name_length ] ; char direction [ 2 ] ; guint pkt_len ; char cap_src [ 13 ] ; char cap_dst [ 13 ] ; guint8 * pd ; gchar * p ; int n , i = 0 ; guint offset = 0 ; gchar dststr [ 13 ] ; phdr -> rec_type = rec_type_packet ; phdr -> presence_flags = wtap_has_ts | wtap_has_cap_len ; if ( sscanf ( line , ""%9d.%9d:<s2sv_blank>%15[a-z0-9/:.-](%1[io])<s2sv_blank>len=%9u:%12s->%12s/"" , & sec , & dsec , cap_int , direction , & pkt_len , cap_src , cap_dst ) < 5 ) { * err = wtap_err_bad_file ; * err_info = g_strdup ( ""netscreen:<s2sv_blank>can\'t<s2sv_blank>parse<s2sv_blank>packet-header"" ) ; return - 1 ; } if ( pkt_len > wtap_max_packet_size ) { * err = wtap_err_bad_file ; * err_info = g_strdup_printf ( ""netscreen:<s2sv_blank>file<s2sv_blank>has<s2sv_blank>%u-byte<s2sv_blank>packet,<s2sv_blank>bigger<s2sv_blank>than<s2sv_blank>maximum<s2sv_blank>of<s2sv_blank>%u"" , pkt_len , wtap_max_packet_size ) ; return false ; } phdr -> ts . secs = sec ; phdr -> ts . nsecs = dsec * 100000000 ; phdr -> len = pkt_len ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; while ( 1 ) { if ( file_gets ( line , netscreen_line_length , fh ) == null ) { break ; } for ( p = & line [ 0 ] ; g_ascii_isspace ( * p ) ; p ++ ) ; if ( * p == '\\0' ) { break ; } n = parse_single_hex_dump_line ( p , pd , offset ) ; if ( offset == 0 && n < 6 ) { if ( info_line ( line ) ) { if ( ++ i <= netscreen_max_infolines ) { continue ; } } else { * err = wtap_err_bad_file ; * err_info = g_strdup ( ""netscreen:<s2sv_blank>cannot<s2sv_blank>parse<s2sv_blank>hex-data"" ) ; return false ; } } if ( n == - 1 ) { * err = wtap_err_bad_file ; * err_info = g_strdup ( ""netscreen:<s2sv_blank>cannot<s2sv_blank>parse<s2sv_blank>hex-data"" ) ; return false ; } offset += n ; if ( offset > pkt_len ) { * err = wtap_err_bad_file ; * err_info = g_strdup ( ""netscreen:<s2sv_blank>too<s2sv_blank>much<s2sv_blank>hex-data"" ) ; return false ; } } if ( strncmp ( cap_int , ""adsl"" , 4 ) == 0 ) { g_snprintf ( dststr , 13 , ""%02x%02x%02x%02x%02x%02x"" , pd [ 0 ] , pd [ 1 ] , pd [ 2 ] , pd [ 3 ] , pd [ 4 ] , pd [ 5 ] ) ; if ( strncmp ( dststr , cap_dst , 12 ) == 0 ) phdr -> pkt_encap = wtap_encap_ethernet ; else phdr -> pkt_encap = wtap_encap_ppp ; } else if ( strncmp ( cap_int , ""seri"" , 4 ) == 0 ) phdr -> pkt_encap = wtap_encap_ppp ; else phdr -> pkt_encap = wtap_encap_ethernet ; phdr -> caplen = offset ; return true ; }","<S2SV_ModStart> ) { int pkt_len ; int <S2SV_ModStart> 2 ] ; <S2SV_ModEnd> char cap_src [ <S2SV_ModStart> = 0 ; int <S2SV_ModEnd> offset = 0 <S2SV_ModStart> ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9d:%12s->%12s/"" <S2SV_ModEnd> , & sec <S2SV_ModStart> return - 1 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""netscreen:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE
",wireshark@wireshark/11edc83b98a61e890d7bb01855389d40e984ea82,CVE-2016-5357,https://github.com/wireshark/wireshark/commit/11edc83b98a61e890d7bb01855389d40e984ea82,2016-08-07T16:59Z,"<S2SV_StartBug> int sec ; <S2SV_EndBug> <S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> <S2SV_StartBug> guint offset = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9u:%12s->%12s/"" , <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug>"
7448,CWE-125,"static void l2tp_framing_cap_print ( netdissect_options * ndo , const u_char * dat ) { const uint32_t * ptr = ( const uint32_t * ) dat ; if ( extract_32bits ( ptr ) & l2tp_framing_cap_async_mask ) { nd_print ( ( ndo , ""a"" ) ) ; } if ( extract_32bits ( ptr ) & l2tp_framing_cap_sync_mask ) { nd_print ( ( ndo , ""s"" ) ) ; } }","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,"<S2SV_StartBug> l2tp_framing_cap_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug>"
4684,CWE-416,"static void host_callback ( void * arg , int status , int timeouts , unsigned char * abuf , int alen ) { struct host_query * hquery = ( struct host_query * ) arg ; int addinfostatus = ares_success ; hquery -> timeouts += timeouts ; hquery -> remaining -- ; if ( status == ares_success ) { addinfostatus = ares__parse_into_addrinfo ( abuf , alen , hquery -> ai ) ; } else if ( status == ares_edestruction ) { end_hquery ( hquery , status ) ; } if ( ! hquery -> remaining ) { if ( addinfostatus != ares_success ) { end_hquery ( hquery , addinfostatus ) ; } else if ( hquery -> ai -> nodes ) { end_hquery ( hquery , ares_success ) ; } else if ( status == ares_enotfound ) { next_lookup ( hquery , status ) ; } else { end_hquery ( hquery , status ) ; } } }","<S2SV_ModStart> status ) ; return ;
",c-ares@c-ares/1cc7e83c3bdfaafbc5919c95025592d8de3a170e,CVE-2020-14354,https://github.com/c-ares/c-ares/commit/1cc7e83c3bdfaafbc5919c95025592d8de3a170e,2021-05-13T14:15Z,<S2SV_StartBug> } <S2SV_EndBug>
5414,CWE-532,"int _pam_parse ( int argc , const char * * argv ) { int ctrl = 0 ; const char * current_secret = null ; memset ( tac_srv , 0 , sizeof ( tacplus_server_t ) * tac_plus_maxservers ) ; memset ( & tac_srv_addr , 0 , sizeof ( struct addrinfo ) * tac_plus_maxservers ) ; memset ( & tac_sock_addr , 0 , sizeof ( struct sockaddr ) * tac_plus_maxservers ) ; memset ( & tac_sock6_addr , 0 , sizeof ( struct sockaddr_in6 ) * tac_plus_maxservers ) ; tac_srv_no = 0 ; tac_service [ 0 ] = 0 ; tac_protocol [ 0 ] = 0 ; tac_prompt [ 0 ] = 0 ; tac_login [ 0 ] = 0 ; for ( ctrl = 0 ; argc -- > 0 ; ++ argv ) { if ( ! strcmp ( * argv , ""debug"" ) ) { ctrl |= pam_tac_debug ; } else if ( ! strcmp ( * argv , ""use_first_pass"" ) ) { ctrl |= pam_tac_use_first_pass ; } else if ( ! strcmp ( * argv , ""try_first_pass"" ) ) { ctrl |= pam_tac_try_first_pass ; } else if ( ! strncmp ( * argv , ""service="" , 8 ) ) { xstrcpy ( tac_service , * argv + 8 , sizeof ( tac_service ) ) ; } else if ( ! strncmp ( * argv , ""protocol="" , 9 ) ) { xstrcpy ( tac_protocol , * argv + 9 , sizeof ( tac_protocol ) ) ; } else if ( ! strncmp ( * argv , ""prompt="" , 7 ) ) { xstrcpy ( tac_prompt , * argv + 7 , sizeof ( tac_prompt ) ) ; unsigned long chr ; for ( chr = 0 ; chr < strlen ( tac_prompt ) ; chr ++ ) { if ( tac_prompt [ chr ] == '_' ) { tac_prompt [ chr ] = '<s2sv_blank>' ; } } } else if ( ! strncmp ( * argv , ""login="" , 6 ) ) { xstrcpy ( tac_login , * argv + 6 , sizeof ( tac_login ) ) ; } else if ( ! strcmp ( * argv , ""acct_all"" ) ) { ctrl |= pam_tac_acct ; } else if ( ! strncmp ( * argv , ""server="" , 7 ) ) { if ( tac_srv_no < tac_plus_maxservers ) { struct addrinfo hints , * servers , * server ; int rv ; char * close_bracket , * server_name , * port , server_buf [ 256 ] ; memset ( & hints , 0 , sizeof hints ) ; memset ( & server_buf , 0 , sizeof ( server_buf ) ) ; hints . ai_family = af_unspec ; hints . ai_socktype = sock_stream ; if ( strlen ( * argv + 7 ) >= sizeof ( server_buf ) ) { _pam_log ( log_err , ""server<s2sv_blank>address<s2sv_blank>too<s2sv_blank>long,<s2sv_blank>sorry"" ) ; continue ; } strcpy ( server_buf , * argv + 7 ) ; if ( * server_buf == '[' && ( close_bracket = strchr ( server_buf , ']' ) ) != null ) { server_name = server_buf + 1 ; _pam_log ( log_err , ""reading<s2sv_blank>server<s2sv_blank>address<s2sv_blank>as:<s2sv_blank>%s<s2sv_blank>"" , server_name ) ; port = strchr ( close_bracket , ':' ) ; * close_bracket = '\\0' ; } else { server_name = server_buf ; port = strchr ( server_buf , ':' ) ; } if ( port != null ) { * port = '\\0' ; port ++ ; } _pam_log ( log_debug , ""sending<s2sv_blank>server<s2sv_blank>address<s2sv_blank>to<s2sv_blank>getaddrinfo<s2sv_blank>as:<s2sv_blank>%s<s2sv_blank>"" , server_name ) ; if ( ( rv = getaddrinfo ( server_name , ( port == null ) ? ""49"" : port , & hints , & servers ) ) == 0 ) { for ( server = servers ; server != null && tac_srv_no < tac_plus_maxservers ; server = server -> ai_next ) { set_tac_srv_addr ( tac_srv_no , server ) ; set_tac_srv_key ( tac_srv_no , current_secret ) ; tac_srv_no ++ ; } _pam_log ( log_debug , ""%s:<s2sv_blank>server<s2sv_blank>index<s2sv_blank>%d<s2sv_blank>"" , __function__ , tac_srv_no ) ; freeaddrinfo ( servers ) ; } else { _pam_log ( log_err , ""skip<s2sv_blank>invalid<s2sv_blank>server:<s2sv_blank>%s<s2sv_blank>(getaddrinfo:<s2sv_blank>%s)"" , server_name , gai_strerror ( rv ) ) ; } } else { _pam_log ( log_err , ""maximum<s2sv_blank>number<s2sv_blank>of<s2sv_blank>servers<s2sv_blank>(%d)<s2sv_blank>exceeded,<s2sv_blank>skipping"" , tac_plus_maxservers ) ; } } else if ( ! strncmp ( * argv , ""secret="" , 7 ) ) { current_secret = * argv + 7 ; if ( tac_srv_no == 0 ) { _pam_log ( log_err , ""secret<s2sv_blank>set<s2sv_blank>but<s2sv_blank>no<s2sv_blank>servers<s2sv_blank>configured<s2sv_blank>yet"" ) ; } else { set_tac_srv_key ( tac_srv_no - 1 , current_secret ) ; } } else if ( ! strncmp ( * argv , ""timeout="" , 8 ) ) { # ifdef have_strtol tac_timeout = strtol ( * argv + 8 , null , 10 ) ; # else tac_timeout = atoi ( * argv + 8 ) ; # endif if ( tac_timeout == long_max ) { _pam_log ( log_err , ""timeout<s2sv_blank>parameter<s2sv_blank>cannot<s2sv_blank>be<s2sv_blank>parsed<s2sv_blank>as<s2sv_blank>integer:<s2sv_blank>%s"" , * argv ) ; tac_timeout = 0 ; } else { tac_readtimeout_enable = 1 ; } } else { _pam_log ( log_warning , ""unrecognized<s2sv_blank>option:<s2sv_blank>%s"" , * argv ) ; } } if ( ctrl & pam_tac_debug ) { unsigned long n ; _pam_log ( log_debug , ""%d<s2sv_blank>servers<s2sv_blank>defined"" , tac_srv_no ) ; for ( n = 0 ; n < tac_srv_no ; n ++ ) { _pam_log ( log_debug , ""server[%lu]<s2sv_blank>{<s2sv_blank>addr=%s,<s2sv_blank>key=\'%s\'<s2sv_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) , tac_srv [ n ] . key ) ; } _pam_log ( log_debug , ""tac_service=\'%s\'"" , tac_service ) ; _pam_log ( log_debug , ""tac_protocol=\'%s\'"" , tac_protocol ) ; _pam_log ( log_debug , ""tac_prompt=\'%s\'"" , tac_prompt ) ; _pam_log ( log_debug , ""tac_login=\'%s\'"" , tac_login ) ; } return ctrl ; }","<S2SV_ModStart> ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'********\'<S2SV_blank>}"" <S2SV_ModEnd> , n , <S2SV_ModStart> -> ai_addr ) <S2SV_ModEnd> ) ; }
",kravietz@pam_tacplus/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0,CVE-2020-13881,https://github.com/kravietz/pam_tacplus/commit/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0,2020-06-06T19:15Z,"<S2SV_StartBug> _pam_log ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'%s\'<S2SV_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) , <S2SV_EndBug>"
7947,CWE-415,"static int parse_key_constraints ( struct sshbuf * m , struct sshkey * k , time_t * deathp , u_int * secondsp , int * confirmp , char * * sk_providerp ) { u_char ctype ; int r ; u_int seconds , maxsign = 0 ; char * ext_name = null ; struct sshbuf * b = null ; while ( sshbuf_len ( m ) ) { if ( ( r = sshbuf_get_u8 ( m , & ctype ) ) != 0 ) { error_fr ( r , ""parse<s2sv_blank>constraint<s2sv_blank>type"" ) ; goto err ; } switch ( ctype ) { case ssh_agent_constrain_lifetime : if ( * deathp != 0 ) { error_f ( ""lifetime<s2sv_blank>already<s2sv_blank>set"" ) ; goto err ; } if ( ( r = sshbuf_get_u32 ( m , & seconds ) ) != 0 ) { error_fr ( r , ""parse<s2sv_blank>lifetime<s2sv_blank>constraint"" ) ; goto err ; } * deathp = monotime ( ) + seconds ; * secondsp = seconds ; break ; case ssh_agent_constrain_confirm : if ( * confirmp != 0 ) { error_f ( ""confirm<s2sv_blank>already<s2sv_blank>set"" ) ; goto err ; } * confirmp = 1 ; break ; case ssh_agent_constrain_maxsign : if ( k == null ) { error_f ( ""maxsign<s2sv_blank>not<s2sv_blank>valid<s2sv_blank>here"" ) ; goto err ; } if ( maxsign != 0 ) { error_f ( ""maxsign<s2sv_blank>already<s2sv_blank>set"" ) ; goto err ; } if ( ( r = sshbuf_get_u32 ( m , & maxsign ) ) != 0 ) { error_fr ( r , ""parse<s2sv_blank>maxsign<s2sv_blank>constraint"" ) ; goto err ; } if ( ( r = sshkey_enable_maxsign ( k , maxsign ) ) != 0 ) { error_fr ( r , ""enable<s2sv_blank>maxsign"" ) ; goto err ; } break ; case ssh_agent_constrain_extension : if ( ( r = sshbuf_get_cstring ( m , & ext_name , null ) ) != 0 ) { error_fr ( r , ""parse<s2sv_blank>constraint<s2sv_blank>extension"" ) ; goto err ; } debug_f ( ""constraint<s2sv_blank>ext<s2sv_blank>%s"" , ext_name ) ; if ( strcmp ( ext_name , ""sk-provider@openssh.com"" ) == 0 ) { if ( sk_providerp == null ) { error_f ( ""%s<s2sv_blank>not<s2sv_blank>valid<s2sv_blank>here"" , ext_name ) ; goto err ; } if ( * sk_providerp != null ) { error_f ( ""%s<s2sv_blank>already<s2sv_blank>set"" , ext_name ) ; goto err ; } if ( ( r = sshbuf_get_cstring ( m , sk_providerp , null ) ) != 0 ) { error_fr ( r , ""parse<s2sv_blank>%s"" , ext_name ) ; goto err ; } } else { error_f ( ""unsupported<s2sv_blank>constraint<s2sv_blank>\\""%s\\"""" , ext_name ) ; goto err ; } free ( ext_name ) ; break ; default : error_f ( ""unknown<s2sv_blank>constraint<s2sv_blank>%d"" , ctype ) ; err : free ( ext_name ) ; sshbuf_free ( b ) ; return - 1 ; } } return 0 ; }","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> while ( sshbuf_len <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } switch <S2SV_ModStart> ""lifetime<S2SV_blank>already<S2SV_blank>set"" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } * <S2SV_ModStart> ""confirm<S2SV_blank>already<S2SV_blank>set"" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } * <S2SV_ModStart> ""maxsign<S2SV_blank>not<S2SV_blank>valid<S2SV_blank>here"" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ""maxsign<S2SV_blank>already<S2SV_blank>set"" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } break <S2SV_ModStart> ( r = parse_key_constraint_extension ( m , sk_providerp ) ) != 0 ) goto out ; break ; default : error_f ( <S2SV_ModEnd> ""Unknown<S2SV_blank>constraint<S2SV_blank>%d"" , ctype <S2SV_ModStart> ctype ) ; r = SSH_ERR_FEATURE_UNSUPPORTED ; goto out ; } } r = 0 ; out : return r <S2SV_ModEnd> ; } <S2SV_null>
",openssh@openssh-portable/e04fd6dde16de1cdc5a4d9946397ff60d96568db,CVE-2021-28041,https://github.com/openssh/openssh-portable/commit/e04fd6dde16de1cdc5a4d9946397ff60d96568db,2021-03-05T21:15Z,"<S2SV_StartBug> char * ext_name = NULL ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ( r = sshbuf_get_cstring ( m , & ext_name , NULL ) ) != 0 ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug>"
7870,CWE-20,"uint16_t enc624j600readphyreg ( netinterface * interface , uint8_t address ) { enc624j600writereg ( interface , enc624j600_reg_miregadr , miregadr_r8 | address ) ; enc624j600writereg ( interface , enc624j600_reg_micmd , micmd_miird ) ; usleep ( 100 ) ; while ( ( enc624j600readreg ( interface , enc624j600_reg_mistat ) & mistat_busy ) != 0 ) { } enc624j600writereg ( interface , enc624j600_reg_micmd , 0x00 ) ; return enc624j600readreg ( interface , enc624j600_reg_mird ) ; }","<S2SV_ModStart> address ) { uint16_t status ; <S2SV_ModStart> ( interface , ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT <S2SV_ModEnd> | address ) <S2SV_ModStart> ( interface , ENC624J600_MICMD , ENC624J600_MICMD_MIIRD <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> 100 ) ; do { status = <S2SV_ModEnd> enc624j600ReadReg ( interface <S2SV_ModStart> ( interface , ENC624J600_MISTAT ) ; } while ( ( status & ENC624J600_MISTAT_BUSY <S2SV_ModEnd> ) != 0 <S2SV_ModStart> != 0 ) ; <S2SV_ModEnd> enc624j600WriteReg ( interface <S2SV_ModStart> ( interface , ENC624J600_MICMD <S2SV_ModEnd> , 0x00 ) <S2SV_ModStart> ( interface , ENC624J600_MIRD <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , MICMD_MIIRD ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> return enc624j600ReadReg ( interface , ENC624J600_REG_MIRD ) ; <S2SV_EndBug>"
4031,CWE-399,"static int rock_continue ( struct rock_state * rs ) { int ret = 1 ; int blocksize = 1 << rs -> inode -> i_blkbits ; const int min_de_size = offsetof ( struct rock_ridge , u ) ; kfree ( rs -> buffer ) ; rs -> buffer = null ; if ( ( unsigned ) rs -> cont_offset > blocksize - min_de_size || ( unsigned ) rs -> cont_size > blocksize || ( unsigned ) ( rs -> cont_offset + rs -> cont_size ) > blocksize ) { printk ( kern_notice ""rock:<s2sv_blank>corrupted<s2sv_blank>directory<s2sv_blank>entry.<s2sv_blank>"" ""extent=%d,<s2sv_blank>offset=%d,<s2sv_blank>size=%d\\n"" , rs -> cont_extent , rs -> cont_offset , rs -> cont_size ) ; ret = - eio ; goto out ; } if ( rs -> cont_extent ) { struct buffer_head * bh ; rs -> buffer = kmalloc ( rs -> cont_size , gfp_kernel ) ; if ( ! rs -> buffer ) { ret = - enomem ; goto out ; } ret = - eio ; bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; if ( bh ) { memcpy ( rs -> buffer , bh -> b_data + rs -> cont_offset , rs -> cont_size ) ; put_bh ( bh ) ; rs -> chr = rs -> buffer ; rs -> len = rs -> cont_size ; rs -> cont_extent = 0 ; rs -> cont_size = 0 ; rs -> cont_offset = 0 ; return 0 ; } printk ( ""unable<s2sv_blank>to<s2sv_blank>read<s2sv_blank>rock-ridge<s2sv_blank>attributes\\n"" ) ; } out : kfree ( rs -> buffer ) ; rs -> buffer = null ; return ret ; }","<S2SV_ModStart> - EIO ; if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;
",torvalds@linux/f54e18f1b831c92f6512d2eedb224cd63d607d3d,CVE-2014-9420,https://github.com/torvalds/linux/commit/f54e18f1b831c92f6512d2eedb224cd63d607d3d,2014-12-26T00:59Z,"<S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug>"
4581,CWE-125,"static pyobject * parsenumber ( struct compiling * c , const char * s ) { char * dup , * end ; pyobject * res = null ; assert ( s != null ) ; if ( strchr ( s , '_' ) == null ) { return parsenumber_raw ( c , s ) ; } dup = pymem_malloc ( strlen ( s ) + 1 ) ; end = dup ; for ( ; * s ; s ++ ) { if ( * s != '_' ) { * end ++ = * s ; } } * end = '\\0' ; res = parsenumber_raw ( c , dup ) ; pymem_free ( dup ) ; return res ; }","<S2SV_ModStart> 1 ) ; if ( dup == NULL ) { return PyErr_NoMemory ( ) ; }
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> end = dup ; <S2SV_EndBug>
3529,CWE-264,"static int load_state_from_tss16 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_16 * tss ) { int ret ; u8 cpl ; ctxt -> _eip = tss -> ip ; ctxt -> eflags = tss -> flag | 2 ; * reg_write ( ctxt , vcpu_regs_rax ) = tss -> ax ; * reg_write ( ctxt , vcpu_regs_rcx ) = tss -> cx ; * reg_write ( ctxt , vcpu_regs_rdx ) = tss -> dx ; * reg_write ( ctxt , vcpu_regs_rbx ) = tss -> bx ; * reg_write ( ctxt , vcpu_regs_rsp ) = tss -> sp ; * reg_write ( ctxt , vcpu_regs_rbp ) = tss -> bp ; * reg_write ( ctxt , vcpu_regs_rsi ) = tss -> si ; * reg_write ( ctxt , vcpu_regs_rdi ) = tss -> di ; set_segment_selector ( ctxt , tss -> ldt , vcpu_sreg_ldtr ) ; set_segment_selector ( ctxt , tss -> es , vcpu_sreg_es ) ; set_segment_selector ( ctxt , tss -> cs , vcpu_sreg_cs ) ; set_segment_selector ( ctxt , tss -> ss , vcpu_sreg_ss ) ; set_segment_selector ( ctxt , tss -> ds , vcpu_sreg_ds ) ; cpl = tss -> cs & 3 ; ret = __load_segment_descriptor ( ctxt , tss -> ldt , vcpu_sreg_ldtr , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> es , vcpu_sreg_es , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> cs , vcpu_sreg_cs , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> ss , vcpu_sreg_ss , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> ds , vcpu_sreg_ds , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; return x86emul_continue ; }","<S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z,"<S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug>"
2487,CWE-000,"static int unix_dgram_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct sockaddr_un * sunaddr = ( struct sockaddr_un * ) addr ; struct sock * other ; unsigned int hash ; int err ; if ( addr -> sa_family != af_unspec ) { err = unix_mkname ( sunaddr , alen , & hash ) ; if ( err < 0 ) goto out ; alen = err ; if ( test_bit ( sock_passcred , & sock -> flags ) && ! unix_sk ( sk ) -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; restart : other = unix_find_other ( net , sunaddr , alen , sock -> type , hash , & err ) ; if ( ! other ) goto out ; unix_state_double_lock ( sk , other ) ; if ( sock_flag ( other , sock_dead ) ) { unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; goto restart ; } err = - eperm ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } else { other = null ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) ) { struct sock * old_peer = unix_peer ( sk ) ; unix_peer ( sk ) = other ; unix_state_double_unlock ( sk , other ) ; if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ; sock_put ( old_peer ) ; } else { unix_peer ( sk ) = other ; unix_state_double_unlock ( sk , other ) ; } return 0 ; out_unlock : unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; out : return err ; }","<S2SV_ModStart> = other ; unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;
",torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c,CVE-2013-7446,https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c,2015-12-28T11:59Z,"<S2SV_StartBug> unix_state_double_unlock ( sk , other ) ; <S2SV_EndBug>"
4292,CWE-362,static void clear_evtchn_to_irq_row ( unsigned row ) { unsigned col ; for ( col = 0 ; col < evtchn_per_row ; col ++ ) evtchn_to_irq [ row ] [ col ] = - 1 ; },"<S2SV_ModStart> col ++ ) WRITE_ONCE ( <S2SV_ModStart> [ col ] , - 1 ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,CVE-2020-27675,https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,2020-10-22T21:15Z,<S2SV_StartBug> evtchn_to_irq [ row ] [ col ] = - 1 ; <S2SV_EndBug>
6185,CWE-639,"int ca_validate_pubkey ( struct iked * env , struct iked_static_id * id , void * data , size_t len , struct iked_id * out ) { bio * rawcert = null ; rsa * peerrsa = null , * localrsa = null ; ec_key * peerec = null ; evp_pkey * peerkey = null , * localkey = null ; int ret = - 1 ; file * fp = null ; char idstr [ iked_id_size ] ; char file [ path_max ] ; struct iked_id idp ; switch ( id -> id_type ) { case ikev2_id_ipv4 : case ikev2_id_fqdn : case ikev2_id_ufqdn : case ikev2_id_ipv6 : break ; default : log_debug ( ""%s:<s2sv_blank>unsupported<s2sv_blank>public<s2sv_blank>key<s2sv_blank>type<s2sv_blank>%s"" , __func__ , print_map ( id -> id_type , ikev2_id_map ) ) ; return ( - 1 ) ; } bzero ( & idp , sizeof ( idp ) ) ; if ( ( idp . id_buf = ibuf_new ( id -> id_data , id -> id_length ) ) == null ) goto done ; idp . id_type = id -> id_type ; idp . id_offset = id -> id_offset ; if ( ikev2_print_id ( & idp , idstr , sizeof ( idstr ) ) == - 1 ) goto done ; if ( len == 0 && data ) { peerkey = ( evp_pkey * ) data ; } if ( len > 0 ) { if ( ( rawcert = bio_new_mem_buf ( data , len ) ) == null ) goto done ; if ( ( peerkey = evp_pkey_new ( ) ) == null ) goto sslerr ; if ( ( peerrsa = d2i_rsapublickey_bio ( rawcert , null ) ) ) { if ( ! evp_pkey_set1_rsa ( peerkey , peerrsa ) ) { goto sslerr ; } } else if ( bio_reset ( rawcert ) == 1 && ( peerec = d2i_ec_pubkey_bio ( rawcert , null ) ) ) { if ( ! evp_pkey_set1_ec_key ( peerkey , peerec ) ) { goto sslerr ; } } else { log_debug ( ""%s:<s2sv_blank>unknown<s2sv_blank>key<s2sv_blank>type<s2sv_blank>received"" , __func__ ) ; goto sslerr ; } } lc_idtype ( idstr ) ; if ( strlcpy ( file , iked_pubkey_dir , sizeof ( file ) ) >= sizeof ( file ) || strlcat ( file , idstr , sizeof ( file ) ) >= sizeof ( file ) ) { log_debug ( ""%s:<s2sv_blank>public<s2sv_blank>key<s2sv_blank>id<s2sv_blank>too<s2sv_blank>long<s2sv_blank>%s"" , __func__ , idstr ) ; goto done ; } if ( ( fp = fopen ( file , ""r"" ) ) == null ) { logit ( len == 0 ? log_debug : log_info , ""%s:<s2sv_blank>could<s2sv_blank>not<s2sv_blank>open<s2sv_blank>public<s2sv_blank>key<s2sv_blank>%s"" , __func__ , file ) ; goto done ; } localkey = pem_read_pubkey ( fp , null , null , null ) ; if ( localkey == null ) { rewind ( fp ) ; localrsa = pem_read_rsapublickey ( fp , null , null , null ) ; fclose ( fp ) ; if ( localrsa == null ) goto sslerr ; if ( ( localkey = evp_pkey_new ( ) ) == null ) goto sslerr ; if ( ! evp_pkey_set1_rsa ( localkey , localrsa ) ) goto sslerr ; } else { fclose ( fp ) ; } if ( localkey == null ) goto sslerr ; if ( peerkey && ! evp_pkey_cmp ( peerkey , localkey ) ) { log_debug ( ""%s:<s2sv_blank>public<s2sv_blank>key<s2sv_blank>does<s2sv_blank>not<s2sv_blank>match<s2sv_blank>%s"" , __func__ , file ) ; goto done ; } log_debug ( ""%s:<s2sv_blank>valid<s2sv_blank>public<s2sv_blank>key<s2sv_blank>in<s2sv_blank>file<s2sv_blank>%s"" , __func__ , file ) ; if ( out && ca_pubkey_serialize ( localkey , out ) ) goto done ; ret = 0 ; sslerr : if ( ret != 0 ) ca_sslerror ( __func__ ) ; done : ibuf_release ( idp . id_buf ) ; if ( localkey != null ) evp_pkey_free ( localkey ) ; if ( peerrsa != null ) rsa_free ( peerrsa ) ; if ( peerec != null ) ec_key_free ( peerec ) ; if ( localrsa != null ) rsa_free ( localrsa ) ; if ( rawcert != null ) { bio_free ( rawcert ) ; if ( peerkey != null ) evp_pkey_free ( peerkey ) ; } return ( ret ) ; }","<S2SV_ModStart> ( peerkey && <S2SV_ModEnd> EVP_PKEY_cmp ( peerkey <S2SV_ModStart> , localkey ) != 1
",openbsd@src/7afb2d41c6d373cf965285840b85c45011357115,CVE-2020-16088,https://github.com/openbsd/src/commit/7afb2d41c6d373cf965285840b85c45011357115,2020-07-28T12:15Z,"<S2SV_StartBug> if ( peerkey && ! EVP_PKEY_cmp ( peerkey , localkey ) ) { <S2SV_EndBug>"
7874,CWE-20,"error_t enc624j600updatemacaddrfilter ( netinterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint16_t hashtable [ 4 ] ; macfilterentry * entry ; trace_debug ( ""updating<s2sv_blank>mac<s2sv_blank>filter...\\r\\n"" ) ; osmemset ( hashtable , 0 , sizeof ( hashtable ) ) ; for ( i = 0 ; i < mac_addr_filter_size ; i ++ ) { entry = & interface -> macaddrfilter [ i ] ; if ( entry -> refcount > 0 ) { crc = enc624j600calccrc ( & entry -> addr , sizeof ( macaddr ) ) ; k = ( crc >> 23 ) & 0x3f ; hashtable [ k / 16 ] |= ( 1 << ( k % 16 ) ) ; } } enc624j600writereg ( interface , enc624j600_reg_eht1 , hashtable [ 0 ] ) ; enc624j600writereg ( interface , enc624j600_reg_eht2 , hashtable [ 1 ] ) ; enc624j600writereg ( interface , enc624j600_reg_eht3 , hashtable [ 2 ] ) ; enc624j600writereg ( interface , enc624j600_reg_eht4 , hashtable [ 3 ] ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht1<s2sv_blank>=<s2sv_blank>%04"" prix16 ""\\r\\n"" , enc624j600readreg ( interface , enc624j600_reg_eht1 ) ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht2<s2sv_blank>=<s2sv_blank>%04"" prix16 ""\\r\\n"" , enc624j600readreg ( interface , enc624j600_reg_eht2 ) ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht3<s2sv_blank>=<s2sv_blank>%04"" prix16 ""\\r\\n"" , enc624j600readreg ( interface , enc624j600_reg_eht3 ) ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht4<s2sv_blank>=<s2sv_blank>%04"" prix16 ""\\r\\n"" , enc624j600readreg ( interface , enc624j600_reg_eht4 ) ) ; return no_error ; }","<S2SV_ModStart> ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> ) ) ;
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ; <S2SV_EndBug>"
6524,CWE-119,"cjson * cjson_createfloatarray ( double * numbers , int count ) { int i ; cjson * n = 0 , * p = 0 , * a = cjson_createarray ( ) ; for ( i = 0 ; a && i < count ; ++ i ) { n = cjson_createfloat ( numbers [ i ] ) ; if ( ! i ) a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }","<S2SV_ModStart> * cJSON_CreateFloatArray ( const float <S2SV_ModEnd> * numbers , <S2SV_ModStart> < count ; i ++ <S2SV_ModEnd> ) { n <S2SV_ModStart> { n = cJSON_CreateNumber <S2SV_ModEnd> ( numbers [ <S2SV_ModStart> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,"<S2SV_StartBug> cJSON * cJSON_CreateFloatArray ( double * numbers , int count ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> n = cJSON_CreateFloat ( numbers [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug>"
